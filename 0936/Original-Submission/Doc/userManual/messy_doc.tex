\documentclass[12pt]{article}
% \documentclass{acmsmall}
\usepackage{amsmath}
\usepackage[title]{appendix}
\usepackage{bm}
\usepackage{url}
\usepackage{hyperref}

\usepackage{amssymb}
\usepackage{listings}
\lstloadlanguages{Fortran}
\lstset{language=Fortran, frame=single, basicstyle=\footnotesize}
\setlength{\textheight}{9in}
\setlength{\textwidth}{6.5in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\topmargin}{-.25in}
\makeatletter% Set up the page style
\DeclareRobustCommand{\us}{\rule{.2pt}{0pt}\rule[-.8pt]{.4em}{.5pt}%
  \rule{.2pt}{0pt}}
\newcommand{\ps@fred}{%
  \renewcommand{\@oddfoot}{%
    \today\hfill Krogh/Hanson:\ Messy Documentation
    \hfill Page \thepage }% \renewcommand{\@evenhead}{}%
  \renewcommand{\@oddhead}{}%
  \renewcommand{\@evenfoot}{}%
}%
\makeatother% End of setting up the page style
\DeclareRobustCommand{\us}{\rule{.2pt}{0pt}\rule[-.8pt]{.4em}{.5pt}%
  \rule{.2pt}{0pt}}
\begin{document}

\pagestyle{fred}
\thispagestyle{empty}
\begin{center}
  {\LARGE \bf Messy Documentation}
  \\[10pt]
  {\large Revised for ACM TOMS, May, 2015\\[5pt]
    Fred T. Krogh and Richard J. Hanson\footnote{Prepared at Math \`a la
      Carte.com by fkrogh@mathalacarte.com and
      richard.koolhans@gmail.com}\vspace{10pt}}
\end{center}

\begin{abstract}
  This document gives more information on the testing and use of the code
  described in \cite{Krogh:2014:FMP} plus many more details on the packaging.
  Two test drivers illustrates the use of several ways of using the Fortran
  code.  The first code shows use with a single thread and the second shows use
  with two threads.  Library versions are created for single, double and
  quadruple floating point data formats.
\end{abstract}

\tableofcontents


\section{Introduction}
\label{sec:introduction}
We have two goals here.  One is to describe how to set up and use the subroutine
{\tt messy()} to output nicely formatted text and error messages.  The other is to
show by example how libraries can be set up to support different precisions, for
use with or without threads, and in different computing environments.  Ideas
related to those in \cite{Snyder:1997:PMT} were used.  By following the example
here one can create libraries that can execute with different precisions.

We believe this complexity pays off
with the flexibility provided in later use of the software. Although technically
not part of the Fortran standard, the C-style preprocessor is used.  The
preprocessor directives reduce the number of  source files that would
be required otherwise.

The test program {\tt tmessy} illustrates all of the different types of output
supported by {\tt messy()}.  For complicated use we recommend looking at the
relevant example there.  An additional test program illustrates support for
OpenMP threads in Fortran.  Without this support one may find output from within
parallel sections merged in a way that makes it difficult to interpret which
thread is doing what.  In the test program, {\tt thrdtmessy}, numerical output and
error messages from different threads are written to different named files.

\section{Getting Started}
% \section{Getting Started}
Unzipping the distributed file {\tt 936.zip} will create the following directory
structure.  The subdirectory for {\bf C} is referenced in the companion file
{\tt cmessy\_doc.pdf}.  It can be ignored here.

\begin{tabbing}
  \hspace{12pt}\=\hspace{12pt}\=\hspace{12pt}\=\hspace{12pt}\=\kill
  {\bf 936}\+\\
  {\tt Makefile} ! For use on Linux systems or Windows systems with {\em Cygwin}\\
  {\tt 936.head} ! Part of ACM TOMS/CALGO packaging\\
  {\tt 936.README} ! Quick instructions to get started.\\
  {\bf Doc}\+\\
  {\tt messy\us doc.pdf} ! This Document\\
  {\tt cmessy\us doc.pdf}\\
  {\tt messy\us doc.tex}, {\tt messy\us doc.bib} ! In case you would like to
  make changes.\-\\
  {\bf Fortran90}\+\\
  {\tt Makefile} ! Used for making the Fortran part of the package on Linux.\\
  {\bf Src}\+\\
  {\tt messy\us m.F90} ! The main part of the package.\\
  {\tt precision\us m.F90} ! For choosing the floating point precision used in
  the codes.\-\\
  {\bf Drivers}\+\\
  {\tt tmessy.F90} ! Shows most of the features of the code\\
  {\tt sample\us m.F90} ! Shows how library packaging can be used\\
  {\tt thrdtmessy.F90} ! Illustrates the use of threads\\
  {\bf Results} ! This directory has expected results from running these codes\+\\
  {\tt result.s, result.d, result.q} ! Results for different precisions\\
  {\tt odd1.?, mes0.?, err0.?} ! From testing threads where ? is {\tt s, d},
  or {\tt q}.\-\-\\
  {\bf MSWin} ! For checks using Windows Visual Studio\+\\
  {\tt checktmessy.f90, checktmessy.bat, checkthrdtmessy.bat}\-\-\\
  {\bf C}\+\\
  {\tt Makefile} ! Used for making the C part of the package on Linux.\\
  {\bf Src}\+\\
  {\tt cmessy.c} ! As for {\tt messy()}, but called from C with a different
  interface.\\
  {\tt cmessy.h} ! An include file needed when compiling C.\\
  {\tt cmessycall\us m.F90} ! Translates the C calls to one made to {\tt
    messy()}.\-\\
  {\bf Drivers}\+\\
  {\tt csample.c} ! Shows how library packaging can be used for C.\\
  {\tt csample.h} ! Include file needed for {\tt csample.c}.\\
  {\tt ctmessy.c} ! Driver illustrating the use of {\tt cmessy} similar to
  {\tt tmessy} for Fortran.\\
  {\tt cthrdtmessy.c} ! Driver illustrating the use of OpenMP threads\\
  {\bf Results} ! This directory has expected results from running {\tt ctmessy.c}\+\\
  {\tt cresult.s, cresult.d} ! Results for two precisions\-\-\\
  {\bf MSWin} ! For checks using Windows Visual Studio\+\+\\
  {\tt checktmessy.f90}, {\tt checktmessy.bat}\-\\
\end{tabbing}

The root directory will contain, {\tt Makefile},  which can be used by
Linux users, and Windows users using {\it Cygwin}\footnote{ For example see  URL
  https://www.cygwin.com/}.

\subsection{Using the make file}
\label{sec:using-makefile}

One must start by editing {\tt Makefile}, in the root directory.  In most cases
you should only need to define the compiler name {\tt FC}, and if you want C
results the name {\tt CC}.  If you wish to change the precisions created, you
can change the definition of {\tt PLETS} (and {\tt CPLETS} for C) just below the
{\tt FC} choices.  Then enter {\tt make} in a terminal window while in the root
directory.  This will run {\tt make} in the {\tt Fortran90} subdirectory which in
turn will create create the chosen subdirectories {\tt s}, {\tt d}, and {\tt q}
present in the string {\tt PLETS}.  These appear in {\tt Libs} and {\tt
  Fortran90/Drivers/Results}.

After all Fortran jobs are completed, if C results are desired, {\tt make} will
be run in the {\tt C} subdirectory.  This will create requested subdirectories
{\tt s} and {\tt d} in {\tt C/Drivers}, and a single subdirectory {\tt
  C/Drivers/NewResults}.

The codes for the precisions requested are stored in the {\tt Libs}
subdirectories.  Object files, ``.o'', and mod file, ``.mod'', are stored for
{\tt messy\_m} and {\tt precision\_m}.  Libraries are created with the names
{\tt libmathg.a} containing these two object files.  Similarly the
subdirectories s, d, q, of {\tt Fortran90/Drivers} are used to store the ``.o'',
and ``.mod'' files for the driver codes.

All precisions are run, and the results stored in {\tt
  Fortran90/Drivers/NewResults}.  The make process ends by comparing these
results with those provided as part of the package in {\tt
  Fortran90/Drivers/Results}, and reporting on any difference.

Analogous results are obtained for C  The make files in
{\tt Fortran 90}, and in {\tt C}, can be run separately as long as all variables
needed by them are defined in those make files.  If this is done the
Fortran use of {\tt make} must precede those done for C  The C code needs the
results generated from the Fortran compiles.

\subsection{What\rq{}s in the make file}

Even if you don't use {\tt Makefile} you must understand some of the variable
names used inside to customize the code that is generated.  Here is a summary of
the variables used in the order they appear in {\tt Makefile}.  You must set the
first of these, the remaining are optional.
\begin{description}\setlength{\itemsep}{-2pt}
\item[FC] is the names used for the Fortran compiler.  Supported and tested
  environments are: {\em gfortran} for linux; {\em ifort} for Intel; {\em ftn}
  for Cray; {\em ifc} also for Intel; {\em nagfor} for the NAG compiler.  This
  is the only thing in {\tt Makefile} that you must set. Section
  \ref{sec:testing} notes problems encountered.
\item[CC] is the name used for the C compiler.  Leave this blank if you only
  want to generate and test the Fortran codes.
\item[OPT] If you want the compiler to optimize the code you need to
  remove the leading comment for this variable.  Set it to the desired level of
  optimization.  Otherwise no optimization is done, and debugging is
  turned on.
\item[NUMT] The maximum number of threads to run when running the test code {\tt
    thrdtmessy}.  This is set to 2 in {\tt Makefile}, although we have done
  testing for larger values.  Set {\bf NUMT}=1, if you have no interest in
  multiple threads, as this will give a slightly smaller object file for
  messy\us m.o.
\item[PLETS] Is set to ``s d q''.  You can choose just the precision
  letters you want.
\item[CPLETS] Is set to ``s d''.  C  offers no portable way to get quadruple
  precision.  If that time should come, it should not be difficult to change the
  make file for C to cover that case.
\item[SRC] Location of Fortran source files.
\item[LIBS] Location of Library files, with subdirectories for
  the different precisions.
\item[DRV] The location of the Fortran drivers source files.
\item[DOC] Directory where this document is stored.
\item[R, RO] Path to the result files and to the original result files.
\item[T] Used to specify options associated with threads.
\item[LIB] Defines options for finding library files.
\item[FFLAGS] Compilation flags passed to the Fortran compiler.
\item[RUN] The command used to run all of the cases.
\item[J,JD] Used to define options for storing modules for the library and
  drivers.
\item[DIFF,DIFF2] The command use do compare the new results with the
  original results.  ({\bf DIFF2} is used in defining {\bf DIFF}.
\end{description}
There are few other variables used which are defined differently for different
compilers.

Some variables in {\tt Makefile} are used to define variables for the
preprocessor.  Those preprocessor variables appear in the source code.  The
variables used are given below.

\begin{description}
\item[numt\us] ($t\us d$) The number of threads used (when testing threads).  If
  this directive is left undefined, drivers or other applications, calling {\tt
    messy()} within parallel sections, will not work as intended and {\tt
    messy\us m.o} will be slightly smaller.  Using any value $t\us d \geq 2$
  will create the necessary internal OpenMP {\em threadprivate} variables.


\item[kind\us] This is one of the values {\tt kinds}, {\tt kindd}, {\tt kindq},
  depending on whether the precision is single, double, or quadruple\footnote{
    Provided the compiler supports this data type.}.  These values are defined
  in the module {\tt precision\us m.F90}.

\item[plet\us] This is one of the strings \verb:"s":, \verb:"d": or
  \verb:"q":; used in suffixing names of output files when executing {\tt
    thrdtmessy}.

\item[MSWin] Used for compiling and executing {\tt tmessy.F90} and {\tt
    thrdtmessy.F90} within the Microsoft Visual Studio environment.  Linux or
  Cygwin users should ignore this.
\end{description}

The following commands may be useful to you.
\begin{description}
\item[make clean] Gets things back to the original state.
\item[make] Make directories as needed, compile codes, run them, and compare
  results with what is provided in the distribution.
\item[make Doc/messy\us doc.pdf] Useful if you make changes this file.
\item[make replace\us orig] Useful if you want to try more threads, and would
  like the output for what is saved for the distribution to include more output.
  You might also use this if you see minor differences between your results and
  ours, and would prefer not to see them again.  You should be sure that the
  results you are getting are good ones before using this.
\end{description}

\section{Getting Started, Microsoft Visual Studio}
This section is specific to use of the Intel compiler packaged within the
Microsoft Visual Studio environment.  Since MS DOS does not provide a native
{\em make} tool, we present the tests with instructions for creating separate
Visual Studio {\em Solutions} using the double precision version of {\tt
  messy()}.

\begin{description}
\item[{\em dmessylib}] Creates a static library {\tt dmessylib.lib} and {\tt
    .mod} files for double precision use.
  \begin{enumerate}
  \item Open a new Visual Studio project.  Under the template {\tt Intel (R)
      Visual Fortran} choose {\tt Library} and next choose {\tt Static Library}.
    Name the project {\tt dmessylib}.
  \item Add source files to the project.  These are {\tt messy\_m.F90} and {\tt
      precision\_m.F90}, found in the distribution directory {\tt
      Fortran90\textbackslash Src}.  For inter-language use with {\bf C},
      add the module {\tt cmessycall\us m.F90}, found in {\tt
     C\textbackslash Src}.
  \item Under the {\em Project Properties} tab, enable the {\em Fortran $>$
      Preprocessor} and add the directives {\tt kind\us=kindd} \footnote{Chooses
      {\tt double precision} for floating point data precision.} and {\tt
      numt\us=2}\footnote{Any integer value $> 1$ will work.}.  Next enable the
    parallel processing of OpenMP directives under {\em Fortran $>$ Language}.
  \item Build the project.  This step compiles the codes, creates {\tt .mod} and
    {\tt .o} files, and the static library {\tt dmessylib.lib}.
  \item The full path name to these files is needed in the testing.  Abbreviate
    this as: {\tt <tpath> = ...\textbackslash Projects\textbackslash
      dmessylib\textbackslash dmessylib\textbackslash Debug}.
  \end {enumerate}


\item[{\em tmessy}] Calls {\tt messy()} in many ways.  Compares results with the
  file\\{\tt Fortran90\textbackslash Drivers\textbackslash Results\textbackslash
    dresult}.  This step can be skipped if you are assured that {\tt
    dmessylib.lib} is built correctly.  There are two {\it projects} within this
  solution, even though it is called a project below.
  \begin{enumerate}
  \item Open a new Visual Studio project.  Under the template {\tt Intel (R)
      Visual Fortran} choose {\tt Console Application} and next choose {\tt
      Empty Project}.  Name the project {\tt tmessy}.
  \item Add the source files {\tt tmessy.F90} and {\tt sample\_m.F90} to the
    project.  These are in the distribution directory {\tt
      Fortran90\textbackslash Drivers}.
  \item Under the {\em Project Properties} enable the {\em Fortran $>$
      Preprocessor} and add the directives {\tt MSWin} and {\tt
      plet\us=\rq{}d\rq{}}.  Next define the path name for the {\tt .mod} files:
    Set {\em Fortran $>$ Preprocessor $>$ Additional Include Directories} as
    {\tt <tpath>}.  This step is for using the {\tt .mod} files for modules {\tt
      messy\_m} and {\tt precision\_m} during compilation of {\tt tmessy.F90}.

  \item Under the {\em Project Properties} set the path name for the linker to
    find the library containing {\tt messy}: {\em Linker $>$ General $>$
      Additional Library Directories} is set to {\tt <tpath>}.

  \item Under the {\em Project Properties} set the path name for the linker to
    use the library containing {\tt messy()}: {\em Linker $>$Input $>$
      Additional Dependencies} is set to {\tt dmessylib.lib}.
  \item Build the project and execute {\tt tmessy}.  The results are written to
    the file {\tt newresult.d}.
  \end {enumerate}

  \begin{enumerate}
  \item Open a second Visual Studio project within the {\em Solution}, {\tt
      tmessy}.  Under the template {\tt Intel (R) Visual Fortran} choose {\tt
      Console Application} and next choose {\tt Empty Project}.  Name the
    project {\tt checktmessy}.

  \item Add the source file {\tt checktmessy.f90} to the {\tt checktmessy}
    project.  This is in the distribution directory {\tt Fortran90\textbackslash
      Drivers\textbackslash MSWin}.

  \item Add the file {\tt dresult} to the {\tt checktmessy} project as a
    Resource.  This is in the distribution directory {\tt
      Fortran90\textbackslash Drivers\textbackslash Results}.

  \item Add the MS DOS batch file {\tt checktmessy.bat} to the {\tt checktmessy}
    project as a Resource.  This is in the distribution directory {\tt
      Fortran90\textbackslash Drivers\textbackslash MSWin}.
  \item Build and execute {\tt checktmessy}.  The results in file {\tt
      newresult.d} are compared with those of {\tt dresult}.
  \end {enumerate}
\item[{\em thrdtmessy}] Calls {\tt messy()} in an OpenMP parallel DO loop with
  numeric and error messages written to separate named files.  Compares results
  with files {\tt mes0.d}, {\tt err0.d} and {\tt odd1.d} found in {\tt
    Fortran90\textbackslash Drivers\textbackslash Results}.
  \begin{enumerate}
  \item Open a new Visual Studio project.  Under the template {\tt Intel (R)
      Visual Fortran} choose {\tt Console Application} and next choose {\tt
      Empty Project}.  Name the project {\tt thrdtmessy}.
  \item Add the source file {\tt thrdtmessy.F90} to the project.  This is in the
    distribution directory {\tt Fortran90\textbackslash Drivers}.
  \item Under the {\em Project Properties} enable the {\em Fortran $>$
      Preprocessor} and add the directives {\tt MSWin}, {\tt
      plet\us=\rq{}d\rq{}}, and {\tt numt\_=2}.  Next define the path name for
    the {\tt .mod} files: Set {\em Fortran $>$ Preprocessor $>$ Additional
      Include Directories} as {\tt <tpath>}.  This step is for using the {\tt
      .mod} files for modules {\tt messy\_m} and {\tt precision\_m} during
    compilation of {\tt thrdtmessy.F90}.  Enable the parallel processing of
    OpenMP directives under {\em Fortran $>$ Language}.
  \item Under the {\em Project Properties} set the path name for the linker to
    find the library containing {\tt messy()}: {\em Linker $>$ General $>$
      Additional Library Directories} is set to {\tt <tpath>}.

  \item Under the {\em Project Properties} set the path name for the linker to
    use the library containing {\tt messy()}: {\em Linker $>$Input $>$
      Additional Dependencies} is set to {\tt dmessylib.lib}.
  \item Add the MS DOS batch file {\tt checkthrdtmessy.bat} to the {\tt
      thrdtmessy} project as a Resource.  This is in the distribution directory
    {\tt Fortran90\textbackslash Drivers\textbackslash MSWin}.
  \item Add the data files {\tt mes0.d}, {\tt err0.d} and {\tt odd1.d} from the
    algorithm distribution as a Resource.
  \item Build and execute {\tt thrdtmessy}.  The results in subdirectory {\tt
      ...\textbackslash NewResults}, {\tt mes0.d}, {\tt err0.d} and {\tt
      odd1.d}, are compared with those from the the algorithm distribution.
  \end{enumerate}
\end{description}

\section{General Fortran Usage}

To use the {\tt messy()} software arrange for access to {\tt.mod} and a library
or {\tt .o} files for modules {\tt messy\_m} and {\tt precision\_m}.
\begin{tabbing}
  {\bf use} {\tt messy\us m}, only : messy, messy\us ty, rk\\
  {\bf type}({\tt messy\us ty}) :: {\tt e} ! Your name could be different.\\
  $<$Declare other types that you need, and/or change public components of
  {\tt messy\us ty}.$>$\\
  $\cdots$\\
  {\bf call} {\tt messy}({\tt e},``The text that defines what you
  want.'', other arguments as needed)
\end{tabbing}\vspace{-15pt}
\begin{lstlisting}[frame=single, caption={Sample use of {\tt messy()} to print
four digits of two complex numbers}]
use messy_m, only: messy, messy_ty, rk
    type(messy_ty) :: e
    complex(rk) :: w=(0.0,1.0)
     call messy(e,''$D4The square-root of the complex number $ZR = $ZR.'', &
      zdat=[w,sqrt(w)])
    end
! The square-root of the complex number (0.,1.000) = (.7071,.7071).
\end{lstlisting}

For real and complex numbers the standard precision is given by intrinsic
functions involving {\tt rk}.  This value is defined at the start of {\tt
  messy\us m.F90} with the statement\\``{\tt integer, parameter :: numdig =
  ceiling($-$log10(epsilon(1.0\us
  rk)))}''.  The type {\tt messy\us ty} has the following public components:
\begin{tabbing}
  {\tt character (len=32) :: ename="Undefined"} ! Name printed in error
  messages.\\
  {\tt integer :: fpprec = numdig} ! Default for floating point precision\\
  {\tt integer :: kdf = numdig} ! Current default real precision.\\
  {\tt integer :: line\us len = 128} ! Default for line length\\
  {\tt integer :: munit = OUTPUT\us UNIT} ! Message unit number\\
  {\tt integer :: eunit = OUTPUT\us UNIT} ! ERROR\us UNIT mixes up output with
  piping\\
  {\tt integer :: maxerr = 0} ! Max value of 1000 * (10*stop + print) +
  |index|\\
  {\tt integer :: lstop = 3} ! Stop indexes $\leq$ this don't stop\\
  {\tt integer :: lprint = 3} ! Print indexes $\leq$ this don't print\\
  {\tt integer :: errcnt = 0} ! Count of the number of error messages,
  incremented\\
  ! \hspace{1.5in}by 1000000 for internal errors inside messy().\\
  {\tt integer :: dblev = 3} ! If 0, an immediate return is made (unless text\\
  ! \hspace{1.5in}starts with "\$E"), else a \$K$<$integer$>$ will behave\\
  ! \hspace{1.5in}as if reaching the end of text if $<$integer$>$ is
  $>$ {\tt dblev}.\\
\end{tabbing}\vspace{-10pt}
In addition this data type contains space for an additional 13 integers used
internally.


The parameters that can be passed into {\tt messy()} are as follows:
\begin{verbatim}
  subroutine messy(e, text, idat, rdat, imat, rmat, zdat, zmat, ix, ptext) 
    type(messy_ty), intent(inout) :: e    !Required
    character(len=*), intent(in) :: text  !Required
    character(len=*), optional, intent(in) :: ptext !The rest are optional
    integer, optional, intent(in) :: idat(:), imat(:,:), ix(:)
    real(rk), optional, intent(in) :: rdat(:), rmat(:,:)
    complex(rk), optional, intent(in) :: zdat(:), zmat(:,:)
\end{verbatim}

When output from either {\tt idat} or {\tt rdat} is requested the first number
printed is the first location in the array and further requests are always from
the location just after the last one printed.

Before a call to {\tt messy}, you can change any of the default values defined
in {\tt messy\us ty} above, but there is another mechanism that can be used to
change some of these values on a more temporary basis, in the {\tt text}
argument using a \$ followed by letters as described below.  The \$ which serves
as an escape character can be changed by changing the value of the parameter
{\tt sc} in {\tt messy\us m.F90}.  Only certain characters are allowed after a
\$ and the actions associated with these are listed below.  In describing some
of these we use ``[ $\cdots$ ]'' to indicate something is optional,
``[integer]'' indicates an optional integer, ``text'' is used for any text, and
\# is used for a single decimal digit.\vspace{-5pt}

\begin{description}\setlength{\itemsep}{-2pt}
\item[A] Print a real matrix from {\tt rmat}.  If column and row headings have
  not been changed using \$O (see below), column headings have the form Col nnn,
  and Row headings have the form Row nnn, where nnn is the index of the column
  or row.  \$A\$T results in the transposed matrix being printed.

\item[B] Break, restores all defaults and returns.

\item[C] Continue. \$C, can be used to end an integer when followed by a digit.
  When this is the last thing in text, and we are processing an error message,
  the error message is not ended at this point, but is continued on the next
  call.  This is useful for output of multiple vectors in an error message.

\item[D] \$D[integer] is used to specify a temporary number of significant
  digits for floating point output.  If the integer is missing it restores the
  default, if the integer is $\leq 0$, then this specifies the negative of the
  number of digits that must follow the decimal point and that no exponent is to
  be used in the output (and thus large numbers will use a lot of space).  The
  usual default is always restored after a \$B.

\item[E] Start an error message, see Section \ref{sec:error-messages}.  The next
  two characters are digits, the first gives the stop index, and the next the
  print index.  If the stop index is 0, it is not treated as an error, but can
  be used to limit printing of other messages.  If this is an error message the
  index of the error, defined by the package generating the error message, is in
  {\tt ix(1)} if it is present (useful if some integer vector is part of the
  error message), and else is in {\tt idat(1)}.  (And if {\tt idat} is not
  present, then a 0 is printed for the error index.)  Note that after any print
  from {\tt idat} the next integer printed from {\tt idat} will come from the
  next location.  If the stop index is 0, print will still come out on the error
  unit.

\item[F] Define an alternate format for integer or floating point output.  The
  \$F is followed by a ``D'', or one of the letters: ``IFE'' followed by
  ``digits.digits'', where the ``. digits'' is optional for ``I''.  The ``D''
  case is primarily intended for use with tables, see item ``H'' below, and
  gives an ``ES'' format to print the number of significant digits that would
  ordinarily be given by e\%kdf (or was last set by \$D) and with a width
  sufficient to give one space at the start of the number.  The ``E'' cases are
  converted to Fortran's scientific edit descriptor ``ES''.  This also does the
  type of output specified by the format.  (Either the next integer from {\tt
    idat} in the ``I'' case, the next real from {\tt rdat} for real formats, or
  in the \$ZF case, the next complex number from {\tt zdat}.  In the complex
  case the format provided is used for both the real and imaginary part unless
  the format is terminated with a ``,'', in which case the format for the
  imaginary part follows.)  These formats are not saved from one call to the
  next.

\item[G] Output the next real from {\tt rdat} using the last real format
  specified by \$F above.

\item[H] In the middle of text, \$H specifies a preferred place for breaking a
  line.  If this is before the start of text, it specifies the start of a table.
  By a table we mean text that is arranged in columns where the caller indicates
  what is to go in each column.  If there are more columns than will fit on a
  line, text that does not fit will be saved in a scratch file.  In most cases
  the end of the table will be indicated with text containing nothing but the
  \$B.  The user is responsible for setting up headings, and formatting the
  following lines so things line up as desired.  The following lines will make
  use of formatting available through the \$F command above.  The heading line
  has the following form: ``\$H|nctext1|nctext2| $\cdots$ \ |nctextk|'', where
  ``|'' is any character the user wants to use, different than anything else in
  the current text string; n is a number giving the number of spaces needed for
  the column (if 0 or missing the column is later formatted with ``\$FD", see
  ``F'' above); and c is a C, R, or L indicating how the following text is to be
  justified in the column.  The test program {\tt tmessy.F90} gives an example
  for setting up tables.  One can have at most {\tt lenbuf}$-$50 characters in a
  heading where {\tt lenbuf} is a parameter in {\tt messy\us m.F90}, currently =
  256.  Note that one can make up headings, and output table entries with a size
  that depends on the precision, by using ``\$FD", and setting e\%kdf to a value
  that depends on the precision (perhaps using ``\$D'').  {\bf \large WARNING},
  nothing but the body of the table can be output by {\tt messy()} until the
  ``\$B'' that ends the table.

\item[I] Print the next integer in {\tt idat}, and continue.

\item[J] As for I above, except use the last integer format defined by a "\$F",
  see above.

\item[K] This is followed by an integer (assumed 0 with no digits given).  If
  that integer is $>$ {\tt e\%dblev}, then actions are as if {\tt text} has
  ended at this point.  If {\tt e\%dblev} is 0, then an immediate return is made
  unless {\tt text} starts with ``\$E'', or we are already processing an error
  message.  The \$K$<$integer$>$ is ignored when processing an error message.
  If this feature is used, then the smaller the integer following the \$K, the
  more likely the following text is to print.  The larger the number in {\tt
    e\%dblev}, the more likely text after a ``\$K'' is to print.

\item[L] Followed by an integer gives a new line length.  Internally the number
  specified is replaced as necessary to get it in the interval [40, lenbuf$-$50]
  (parameter lenbuf in code is now 256).

\item[M] Print a matrix from {\tt imat}.  Headings are as for \$A.  \$M\$T
  results in the transposed matrix being printed.

\item[N] Start a new line, and continue.

\item[O] Define starting indexes for vector or matrix output and for the matrix
  case, alternative formats for output of column and row labels. The \$O may
  only appear immediately after a \$A, \$M, \$V, or \$W or after a \$T following
  one of these.  Following the \$O is an optional integer giving the starting
  index value (which may be negative).  No integer gives the default, which is
  1.  In the matrix case one can indicate the text to output for the column and
  row headings, and whether and where the index should be printed.  A \$O
  following a \$A or \$M, is followed by text which specifies the desired result
  for columns, a \$O, then specifications for rows, and then a terminating \$O.
  Following the optional integer giving the first index, one may have nothing,
  or a specification of the number of characters in the text for the headings in
  each column, and where indexes are to be printed followed by the actual text
  used for headings.  ``$<$\#'' means print the index first with \# characters
  in the text for each column heading (all must be the same).  ``$>$\#'' is the
  same but the heading text follows the index.  ``~\#'' gives no index, but just
  \# characters of heading.  ``$|$\#\#'' has the first \# characters of heading
  text then the index, and then the following \# characters of heading text.
  The sum of the digits in the \#\# must not exceed 9.

  If the text is the same for all columns (or rows) then {\tt text} contains L
  characters, otherwise it contains some multiple of L characters, and different
  text is used for each heading until running out of text in which case the last
  given is repeated.  One can get the default actions by not using the \$O, with
  \$O\$O\$O, with \$O$>$4Col \$O$>$4Row \$O, \$O$>$4Col \$O\$O, or \$O\$O$>$4Row
  \$O.  If column headings were to be Earth, Air, Fire, and Water and row labels
  were to have the form "Case $<$index$>$:", this would be \$O 5Earth Air
  FireWater\$O$|$51Case :\$O.  Column headings are centered over the data for
  that column, unless the column headings are wider than needed by the data in
  which case the data is right justified with the heading.

\item[P] Print the text from ptext at this point.  Useful if you call an
  internal subroutine with a common message except for one small bit of text.

\item[Q] This is used to print integers as bit strings.  If ix is not defined it
  is assumed that the bit string is in a single integer, and that leading 0's
  are not to be printed.  If ix is present then $|$ix(1)$|$ defines the number
  of bits, and if ix(1) $> 0$, then this gives the number of bits and all are
  printed, otherwise it is assumed that leading 0's should not be printed, and
  the bit string consists of at least one integer.  {\tt Idat} contains the bit
  strings much like when {\tt idat} is used for output of integers or integer
  vectors, with the difference that a single bit string may require more than 1
  word.  Following the \$Q must be a B, O or a Z, indicating that one wants the
  bits output in binary, octal, or hexadecimal.  Following this must be an I or
  a V indicating that one wants just a single bit string output, or would like
  to output the contents of {\tt idat} as a vector of bit strings.  Since
  Fortran does not have a bit data type, the high order bit of the integers is
  ignored, thus if one has 32 bit integers, each integer holds only 31 bits.

\item[R] Print the next real entry in {\tt rdat}, and continue.

\item[S] Print the real sparse vector, with row/column indexes in idat and
  values in rdat.  Text at the start of the line containing the \$S is printed
  at the start of each line.

\item[T] Tab to the column that is a multiple of that set with
  \$$<$integer$>$T, see 0--9 below.  If used immediately after a \$A or \$M, \$T
  causes the transpose of a matrix to be printed.

\item[U] Set the output unit to the following integer.  This output unit will be
  used until the next \$B.

\item[V] Print a floating point vector from {\tt rdat}.  If other numbers have
  been printed from {\tt rdat}, then the vector starts with the first unprinted
  number.

\item[W] As for \$V, but for integers from {\tt idat}.

\item[X] Print an integer from {\tt ix}. \$X prints {\tt ix}(1),
  \$X$<$integer$>$ prints ix$($<integer$>$).

\item[Y,y] If you would like to repeat what is in part of text ix(1) times, you
  can do this with \$Y, and then indicate the end of that block with \$y. After
  processing the text in \$Y...\$y ix(1) times, text is then processed in the
  usual way.  This was introduced primarily for tables (\$H) so that tables
  could have a variable number of columns.  When used for column headings, the
  \$Y and the \$y should both be followed by the special character used to
  delimit column headings.

\item[Z] This is used for complex data.  It must be followed immediately by A,
  F, G, R, or V, with these giving the same result as these give in the real
  case when preceded by a "\$".

\item[0--9] Starts an $<$integer$>$ and then either a F, G, J, T, or a '~' will
  repeat the \$F, \$G, or \$J action that number of times, or set the column
  multiple for tab stops, or output that many blanks.

\item[\$] A single \$ is output.

\item[Default] Anything else gives an error message and returns.
\end{description}

Examples illustrating all the features above are in {\tt tmessy.F90}.
Here we just give a simple example.  Suppose you have a real
matrix ``rmatrix'' that you would like to print with 8 significant digits, and
with a line length of 100.  To have ``rmatrix:'' printed along with the matrix,
you could use this fragment:
\newpage
\begin{lstlisting}[frame=single, caption={Use of {\tt messy()} to print eight
digits of a real matrix} ]
 use messy_m, only: messy, messy_ty, rk
    type(messy_ty) :: e
    real(rk) :: rmatrix(2,3)=real(reshape([1,2,3,4,5,6],[2,3]),rk)
    call messy(e,"$D8$L100rmatrix:$A$B", rmat=sqrt(rmatrix))
    end
! rmatrix:
!         Col 1     Col 2     Col 3
! Row 1 1.0000000 1.7320508 2.2360680
! Row 2 1.4142136 2.0000000 2.4494897


\end{lstlisting}
% \verb@call messy(e,"$D8$L100rmatrix:$A$B", rmat=rmatrix)@\vspace{5pt}

You could just accept the default digits (full precision), and the
default line length (128), and you can always make permanent changes to the
defaults in {\tt messy\us ty}.  Leave off the
\verb:$B: if you want the default digits and line length to remain changed.

One might guess that if you pass in a full array, {\tt messy()} would adjust
indexes printed to match those of the array.  But Fortran does not work this
way.  Fortran always passes arrays into {\tt messy()} with a lower bound of 1.
If you want indexes to match those of an array that does not have a lower bound
of 1, use the above \$O feature.

\section{Error Messages}
\label{sec:error-messages}
When it comes to printing or stopping on an error message there is no single
right answer.  Sometimes the user would like the code to print and not stop, or
print and stop, or do neither depending on the message, and on the context in
which the code is being run.  And it may be that they would like the error
messages and other messages to go to separate files.

For the person writing the code which is printing the error message, they should
have set {\tt e\%ename} to the name they use to identify the package as part of
the initialization.  For any particular message they can indicate how important
they think it is for this message to stop and to print.  The text for an error
message must start with {\tt \$Esp}, where {\tt s} is a digit indicating how
important it is to stop on completion of printing this error message, and {\tt
  p} is a digit indicating how important it is that the message print.  One
should only use a 9 for {\tt s} if they have given a flag to the user indicating
that without appropriate action on their part the program will be stopped.  For
errors in passing arguments to {\tt messy()}, the routine makes a recursive call
to itself with a stop index of 4, and a print index of 8. One can avoid a stop
on these internal errors by setting {\tt e\%lstop=4}. One must have {\tt p}
$\geq$ s and {\tt p}=9 only if {\tt s} is 9.  By default a line of \$'s is
printed before and after an error message.  For different actions one can change
the parameter {\tt errchar} in {\tt messy\us m.F90}.  One is encouraged to use
multiple calls to output all possible information of potential interest
concerning the error.  All but the last call for an error message should end
with a \$C, and only the first has the starting \$E.

For the person using a package that processes errors they should have access to
the data in ``{\tt e}\rq{}\rq{}, in order to change the rules for stopping,
printing, line lengths, output units, etc.  Note that {\tt e\%maxerr} will
contain the index of the stop index and print index for the error that seemed
most serious, and {\tt errcnt} will have a count of the total number of error
messages.

\section{With Multiple Levels of Routines}
\label{sec:with-multiple-levels}
Suppose a user is calling a boundary value solver, {\tt bsolve}, and an error
occurs in a linear optimizer, {\tt losolve}, which in turn was called by a
nonlinear optimizer, {\tt nlsolve}.  It is likely that an error message from
{\tt losolve}, will not give the user the clarity needed to correct a problem,
since he is only aware of the interface to {\tt bsolve}.

But if {\tt bsolve} contains a derived type {\tt bsolve\us ty} which contains
inside it a variable of derived type {\tt nlsolve\us ty}, and that data type
contains inside it a type of {\tt losolve\us ty}, and each of these derived type
also include a variable of derived type {\tt messy\us ty}, then upon getting the
error from {\tt losolve}, {\tt nlsolve} can translate that error into an error
that makes sense from the view of the nonlinear solver, and as that error is
passed up the line, {\tt bsolve} can finally output an error message in a form
that is more likely to be understandable to the user since {\tt bsolve}, has
access to error information all the way down the call tree.

The facility for writing messages to a named file is particularly useful in a
parallel computing environment.  Each processor assigns different output units
to itself, and messages for each processor would go to these units. The one node
capable of displaying I/O could pick up the messages from each of these output
units, preventing individual records from different processes getting disordered
in a confusing way.

\section{Threads}
\label{sec:threads}

If you want to use threads, you should pay attention to the {\tt $-$D} options
used in {\tt Makefile} for threads, and of course examine {\tt
  thrdtmessy.F90} to understand better what is needed.  Variable {\tt T} is
defined in {\tt Makefile} is required for threads.

In the comments of {\tt thrdtmessy.F90} you will find five modes for scheduling
threads: STATIC, DYNAMIC, GUIDED, RUNTIME, or AUTO.  There is no guarantee that
the output files from different environments will give the same outputs, but all
output files as a group should contain all that is written.

A programmer can declare variables of type {\tt messy\us ty} to be
OpenMP {\em threadprivate} or they can allocate an array that corresponds to
the maximum number of threads used.  Whatever the choice, we 
recommend using separate named files for output when there is
any chance of confusion with numeric output or error messages.

\section{Testing}
\label{sec:testing}

The code has been tested on the following systems.
\begin{description}\setlength{\itemsep}{-2pt}
\item[Gentoo Linux:] gfortran  4.9.2 and gfortran 5.1.0
\item[Ubuntu Linux:] gfortran 4.9.1
\item[Red Hat Enterprise Linux:] ifort 13.0.1
\item[Cray CCE:] ftn  8.2.4.101
\item[Windows 7:] Intel Fortran 14.0.1.139, 20131008
\item[Ubuntu Linux:] NAG 6.0
\end{description}

\section{Acknowledgments}
\label{sec:acknowledgments}

The authors are indebted to W.\ Van Snyder for answering many questions about
the Fortran standard, and for suggestions on alternative ways of doing things to
take advantage of what the latest versions of Fortran have to offer.  Tim
Hopkins has helped by locating problems in using the NAG compiler.  Philip Sharp
has been a major help in tracking down problems in the NAG compiler, and
checking out the code on Ubuntu Linux, and dealing with the Intel compiler on
RedHat Linux.


The authors wish to acknowledge the contribution of the NeSI high-performance
computing facilities at the University of Auckland and the staff at NeSI and
Centre for eResearch. New Zealand's national facilities are provided by the New
Zealand eScience Infrastructure (NeSI) and funded jointly by NeSI's collaborator
institutions and through the Ministry of Business, Innovation and Employment's
Infrastructure programme.\\ URL \url{http://www.nesi.org.nz}.
\bibliography{messy}
% \bibliographystyle{acmsmall} %%% Works with .dvi does not with .pdf
\bibliographystyle{acm}

\end{document}
