<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of heuristic_pcsv_param</title>
  <meta name="keywords" content="heuristic_pcsv_param">
  <meta name="description" content="HEURISTIC_PCSV_PARAM Obtains heuristic parameter estimates for a PCSV model.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">code</a> &gt; <a href="#">core</a> &gt; <a href="index.html">estimation</a> &gt; heuristic_pcsv_param.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for code/core/estimation&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>heuristic_pcsv_param
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>HEURISTIC_PCSV_PARAM Obtains heuristic parameter estimates for a PCSV model.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [mu, A, lambda_0, kappa, theta, sigma, rho]= heuristic_pcsv_param(y_t, dt, p) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">HEURISTIC_PCSV_PARAM Obtains heuristic parameter estimates for a PCSV model.

  [mu, A, lambda_0, kappa, theta, sigma, rho]
    = heuristic_pcsv_param(y_t, dt) calculates parameter estimates for a PCSV
    model with the time series y_t using a heuristic approach. The results
    are supposed to be used as starting points for an iterative optimization
    algorithm.

    INPUT y_t: A Txn matrix representing the log prices
           dt: The time difference in the observed series y_t
            p: Number of eigenvectors used for this model

 created by Benedikt Rudolph
 DATE: 16-Aug-2012</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../code/main/pcsv_estimation.html" class="code" title="">pcsv_estimation</a>	</li><li><a href="../../../code/main/pcsv_partial_estimation.html" class="code" title="">pcsv_partial_estimation</a>	</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [mu, A, lambda_0, kappa, theta, sigma, rho] </a><span class="keyword">...</span>
0002           = heuristic_pcsv_param(y_t, dt, p)
0003 <span class="comment">%HEURISTIC_PCSV_PARAM Obtains heuristic parameter estimates for a PCSV model.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%  [mu, A, lambda_0, kappa, theta, sigma, rho]</span>
0006 <span class="comment">%    = heuristic_pcsv_param(y_t, dt) calculates parameter estimates for a PCSV</span>
0007 <span class="comment">%    model with the time series y_t using a heuristic approach. The results</span>
0008 <span class="comment">%    are supposed to be used as starting points for an iterative optimization</span>
0009 <span class="comment">%    algorithm.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%    INPUT y_t: A Txn matrix representing the log prices</span>
0012 <span class="comment">%           dt: The time difference in the observed series y_t</span>
0013 <span class="comment">%            p: Number of eigenvectors used for this model</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% created by Benedikt Rudolph</span>
0016 <span class="comment">% DATE: 16-Aug-2012</span>
0017 
0018   [T, n] = size(y_t);
0019   
0020   <span class="comment">% obtain A and lambda_0</span>
0021   [A, Lambda, V] = svd(cov(diff(y_t))/dt);
0022   lambda_0 = diag(Lambda);
0023   <span class="comment">% truncate to desired number of eigenvectors/eigenvalues</span>
0024   lambda_0 = lambda_0(1:p)';
0025   A = A(:,1:p);
0026   
0027   <span class="comment">% obtain mu</span>
0028   mu = (mean(diff(y_t))/dt + (0.5*(A.^2)*lambda_0')')';
0029   
0030   <span class="comment">% obtain a time series l of eigenvalues using rolling estimates</span>
0031   roll_period = 8;
0032   l = zeros(T-roll_period, p);
0033   <span class="comment">%_dY = zeros(T-roll_period, p);</span>
0034   r_t = diff(y_t);
0035   <span class="comment">%dB = zeros(T-roll_period-1, p);</span>
0036   <span class="comment">%dW = zeros(T-roll_period-1, p);</span>
0037   <span class="keyword">for</span> k=1:(T-roll_period)
0038     S = cov(diff(y_t(k:(k+roll_period-1),:)))/dt;
0039     [A_k, Lambda_k, V_k] = svd(S);
0040     lambda_k = diag(Lambda_k);
0041     l(k,:) = lambda_k(1:p);
0042     <span class="comment">%_dY(k,:) = mean(diff(y_t(k:(k+roll_period-1),:)));</span>
0043     <span class="comment">%dW(k,:) = (A*diag(sqrt(l(k,:))))*sqrt(dt) ...</span>
0044     <span class="comment">%         \ (r_t(k,:)' - (mu - 0.5*A.^2*l(k,:)')*dt);</span>
0045   <span class="keyword">end</span>
0046   
0047   <span class="comment">% Obtain kappa,theta and sigma using OLS on the eigenvalue estimates l</span>
0048   kappa = zeros(1,p);
0049   theta = zeros(1,p);
0050   sigma = zeros(1,p);
0051   feller_condition = @(kappa, theta, sigma) 2*kappa.*theta &gt; sigma.^2;
0052   <span class="keyword">for</span> k=1:p
0053     lambda = l(:,k);
0054     Y = diff(lambda)./sqrt(lambda(1:(end-1)));
0055     X = [dt./sqrt(lambda(1:(end-1))), dt*sqrt(lambda(1:(end-1)))];
0056     b = X \ Y;
0057     r = Y - X*b;
0058     s = (r'*r) / (size(X,1)-2);
0059     <span class="comment">%dB(:,k) = r/sqrt(s);</span>
0060     sigma(k) = sqrt(s/dt);
0061     <span class="comment">%theta(k) = -b(1) / b(2);</span>
0062     theta(k) = lambda_0(k);
0063     kappa(k) = -b(2);
0064     <span class="comment">% if kappa, theta and sigma do not satisfy the Feller condition</span>
0065     <span class="comment">% shift the parameters equally so that they do satisfy it</span>
0066     <span class="keyword">if</span> ~feller_condition(kappa(k), theta(k), sigma(k))
0067       alpha = - ( sqrt(2*kappa(k).*theta(k)) - sigma(k) ) ./ <span class="keyword">...</span>
0068                 ( sqrt(2*kappa(k).*theta(k)) + sigma(k) ) * 1.01;
0069       kappa(k) = (1+alpha) * kappa(k);
0070       theta(k) = (1+alpha) * theta(k);
0071       sigma(k) = (1-alpha) * sigma(k);
0072     <span class="keyword">end</span>
0073   <span class="keyword">end</span>
0074   
0075    <span class="comment">% Obtain rho</span>
0076   period_length = 12;
0077   number_of_periods = floor((T-1)/period_length)-1;
0078   dB = zeros(number_of_periods, p);
0079   dW = zeros(number_of_periods, p);
0080   lambda_last = lambda_0;
0081   <span class="keyword">for</span> k=1:number_of_periods
0082     idx = (k*period_length):((k+1)*period_length);
0083     period_returns = r_t(idx, :);
0084     S = cov(period_returns);
0085     [A_k, Lambda_k, V_k] = svd(S);
0086     lambda_k = diag(Lambda_k);
0087     lambda_k = lambda_k(1:p);
0088     dlambda = (lambda_k'-lambda_last) / period_length;
0089     dY = mean(period_returns);
0090     dB(k,:) = ( (dlambda - kappa.*(theta-lambda_k')*dt) ./ <span class="keyword">...</span>
0091                                   (sigma .* sqrt(lambda_k')) ) / sqrt(dt);
0092     dW(k, :) = ( (A*diag(sqrt(lambda_k)))*sqrt(dt) <span class="keyword">...</span>
0093               \ (dY' - (mu - 0.5*A.^2*lambda_k)*dt) )' / sqrt(dt);
0094   <span class="keyword">end</span>
0095   rho = diag(corr(dW,dB))';
0096 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Mon 29-Apr-2013 19:29:13 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>