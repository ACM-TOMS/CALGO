/* ALC2DLIB-Version 1.0 implemented by WH 22.3.99, all rights reserved */
/*please report problems or bugs to whoer@statistik.wu-wien.ac.at      */
/*                               or hormannw@boun.edu.tr               */

/*this file:         alc2d.h */

/*as the follwing constants are changed from time to time we put
 them right at the front of the code */ 
#define OUTPUT 0 /*default: 0  */
/*-1... nothing, 0...little, 1...more,  2..even more
  output about setup and generation*/

/*the following two defined constants can be used to check the dynamic
                                                         memory allocation*/
#define MEMCONTROL 1 /*default 0*/
/*0... no controll,1..controll allmost without output,2... more output
  MEMCONTROL >=1 is allso necessary that the two diagnostic procedures
  for counting the number of trials and the number of corners work*/
#define MEMOUTPUT 0/*0..none, 2.. everything, 1.. only longer lasting memory*/




/*
The algorithm implemented here is a universal algorithm for two-dimensional
log-concave distributions.

To use the algorithm it is first necessary to call the function   "setup"
which allocates the necessary memory and computes all constants necessary
for generation. Of course set-up needs as input several informations about
the distribution. It returns a pointer to the structure of the constants.

After calling set-up once, pairs of the two-dimensional distribution
are generated by calling the function "sample2d", which needs as input
only the pointer to the structure of constants returned by setup. During
these calls to "sample2d" the setup procedure is still improving the
fit of the hat-function until the maximal number of design-points is reached.

If no further samples of the distribution are needed the allocated memory
must be freed using "freesetup".

The use of these functions is demonstrated in the samplefiles
main.c and main1.c

Of course a uniform generator is needed. Please include the call of
your favorite generator or of the generator included in you C-compiler.
We only have included a very small generator in our sample files. As it
has a period of only 2^32=4.1e9 numbers it should not be used for big
simulations!!!*/

#define UNIFORM unif/*name of your uniform generator;
       the generator is called without an argument: UNIFORM()*/

/* The input of the below function "setup" is very important, as it
must include all information necessary for sampling from the distribution.

Before you can use the algorithm to generate variates form the desired
2dimensional distribution the following steps are necessary:

1) Check that the density f(x) is log concave, i.e.
   log(f(x)) must be a concave function over the entire domain.

2) Code the function  h(x)=log(f(x)) in the below style:
   (All parameters must be included in the double array param[];)
   double h(double x[2],double param[])
   
   For example for the standard normal distribution:
   double hstnor(double x[2],double param[])
   { return -0.5*(x[0]*x[0]+x[1]*x[1]); }
   For further examples see the sample files.

3) Code the two partial derivatives of h(x) in the same style as  h.

4) Define the domain of the distribution (a possibly open convex polygon)
   by storing all border lines of this polygon in an array eq[][3].
   lines must be stored in the form  0 = eq[0][0] + eq[0][1]*x + eq[0][2]*y;
Remark: The domain of the distribution is only fully defined together
   with the starting point, described in step 5.

5) Provide one (ore more) starting-points, if possible close to the mode
   of the distribution. Of course all starting points must be inside
   the domain of the distribution!!

6) If the domain of the distribution is unbounded it can be necessary to
   add an "auxiliary domain" in order that the set-up algorithm can construct
   a bounded hat function. This auxiliary domain must be a bounded convex
   polygon, that is inside the domain of the distribution and must allways
   contain the mode of the distribution.
   To define this auxiliary domain add the border lines of the auxiliary
   domain in the array eq[][3] after the equalities defining the domain
   of the distribution.
   In most cases the auxiliary domain can simply be a rectangle
   containing the mode. (see the sample files for examples)

7) The last information required is the maximal number of design-points, that
   can be used by the algorithm. Sensible values are between 10 and 30, if the
   desired samplesize is small to moderate and should go up to about 100
   if good generation speed is desired for large samples.


*/

extern void
*setup(
  int nrsp,/*Number of starting points*/
  int nn, /* maximal number of design points*/
  double sp[][2],/* array of starting points*/
  int nreq, /*number of equalities*/
  double eq[][3],/* array of the equalities defining the domain
                    equalities are stored in the form   
                    0 = eq[0][0] + eq[0][1]*x + eq[0][2]*y ;*/
  int nrauxun,/*total number of equalities for domain and auxiliary domain
              we must have    nrauxun >=nreq
              nrauxun== nreq means that no auxiliary domain is provided*/
  double (*h)(double x[2],double param[]),/*logarithm of density function*/
  double (*hx)(double x[2],double param[]),
       /*partial derivative (with respect to x) of h*/
  double (*hy)(double x[2],double param[]),
       /*partial derivative (with respect to x) of h*/
  double param[],/*current setting of the parameters, NULL if nparam=0*/
  int nparam/*number of parameters of the density function*/);


extern void sample2d(double res[2],void *t1);
/*samples from the 2-dimensional distribution,
  generated random pair is stored in res[2]
  t1 must be the pointer that was returned by the "setup" function*/

extern void freesetup(void *t);
/*frees all memory that was assigned during the set-up*/

 

/*The follwing are some internal constants for the algorithm;
  unless you try to optimize the speed or the memory requirements
  of the sampling algorithm or of the set-up it is not necessary
  to change them*/

#define CFGT 20 /* default 20; recommended intervall: 10 to 30 */
/*small values leed to a faster set-up but to a slower sampling-time*/
/*length of guide-table q is determined as CFGT*nn */

#define CFGTSU (0.2) /*default 0.2; must be <=1. */
/*can be used to optimize the speed of the set-up*/
/*length of guide table during setup = CFGT*nn*CFGTSU */

#define NC 10 /*default 10; must be >=4 */
/*A small value of NC can reduce the memory size, but slows down the set-up*/
/*starting number of corners of polygon*/

#define SUNC 10 /*default 10; should be >=5*/
/*for for small values of SUNC the set-up is much faster. High values of
  SUNC eg. 100 imply a slower set-up but a slightly better fit of the hat.
  In sampled2d() allways nn/SUNC rejected points together are used
  as new construction points and a new hat is computed*/


/*the follwing function can be used to find the maximal number of corners
  (ncmax) of a single polygon that occured in this program.*/

extern int returnncmax(void);
/*returns the current value of ncmax
  The function olny works correctly if MEMCONTOL>=1,
  otherwise -1 is returned                                */

/* The following functions can be used to count the number of trials
   to compute the acceptance probability in the rejection algorithm
   they only work if MEMCONTROL>=1 is true.
   In this case for every trial of the rejection-algorithm in sample2d
   the counter widcount is automatically advanced.
PROBLEM: sample2d is also called from the setup function, if the auxiliary
   domain is utilized to find good starting points. In this case widcount
   is advanced allthough the user has never called sample2d().
   Therefore it is best to reset widcount between the call to setup()
   and the first call to sample2d().
   It must also be considered, that the acceptance probability changes
   during the first calls to sample2d() as the hat is updated.*/

extern void setwidcount(unsigned long int newval);
/*sets the value of widcount to the value passed to the function;
  is normally used to reset the widcount value to 0 */

extern unsigned long int returnwidcount(void);
/*returns the current value of widcount*/




extern void pr_2dlib_def();
/*prints the current settings of the defined constants*/


#ifndef NULL
#define NULL (void *) 0
#endif
