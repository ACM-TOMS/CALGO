% Generated by ADiMat 0.6.0-4870
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_XML  -- Write list of unbound identifiers in XML format.
% DEPENDENCIES_XML  -- Write list of functions in XML format.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% FUNCTION_LIST_XML	-- Write list of functions to XML file.
% VERBOSITYLEVEL=5
% AD_IVARS= x
% AD_DVARS= F

function [g_F, F]= g_MinpackCPF_F(g_x, x, Prob)
   % MinpackCPF_FJ: Function & Jacobian for Minpack CPF problem
   %
   %     Computes function and, optionally, the Jacobian for the combustion of
   %     propane full formulation (CPF) problem from the MINPACK-2 collection.
   %
   % USE:
   %       F=MinpackCPF_FJ(x)
   % where
   %   x      : input vector with length(x)=11
   %
   % Returns
   %  F  : Function
   %  J  : Jacobian
   
   % AUTHOR: S.A.Forth & K. Lenton
   % DATE: 30/06/09
   % Copyright 2009-2009: S.A. Forth, Cranfield University
   % REVISIONS:
   % DATE  WHO   WHAT
   
   % Original Fortran Header Comments follow
   %
   % subroutine dcpffj(n,x,fvec,fjac,ldfjac,task)
   %      character*(*) task
   %      integer n, ldfjac
   %      double precision x(n), fvec(n), fjac(ldfjac,n)
   % **********
   %
   % Subroutine dcpffj
   %
   % This subroutine computes the function and the Jacobian matrix of
   % the combustion of propane (full formulation) problem.
   %
   % The subroutine statement is
   %
   %   subroutine dcpffj(n,x,fvec,fjac,ldfjac,task)
   %
   % where
   %
   %   n is an integer variable.
   %     On entry n is the number of variables. n = 11.
   %     On exit n is unchanged.
   %
   %   x is a double precision array of dimension n.
   %     On entry x specifies the vector x if task = 'F', 'J', or 'FJ'.
   %        Otherwise x need not be specified.
   %     On exit x is unchanged if task = 'F', 'J', or 'FJ'. Otherwise
   %        x is set according to task.
   %
   %   fvec is a double precision array of dimension n.
   %     On entry fvec need not be specified.
   %     On exit fvec contains the function evaluated at x if
   %        task = 'F' or 'FJ'.
   %
   %   fjac is a double precision array of dimension (ldfjac,n).
   %     On entry fjac need not be specified.
   %     On exit fjac contains the Jacobian matrix evaluated at x if
   %        task = 'J' or 'FJ'.
   %
   %   ldfjac is an integer variable.
   %      On entry ldfjac is the leading dimension of fjac.
   %      On exit ldfjac is unchanged.
   %
   %   task is a character variable.
   %     On entry task specifies the action of the subroutine:
   %
   %        task               action
   %        ----               ------
   %         'F'     Evaluate the function at x.
   %         'J'     Evaluate the Jacobian matrix at x.
   %         'FJ'    Evaluate the function and the Jacobian at x.
   %         'XS'    Set x to the standard starting point xs.
   %         'XL'    Set x to the lower bound xl.
   %
   %     On exit task is unchanged.
   %
   % MINPACK-2 Project. November 1993.
   % Argonne National Laboratory and University of Minnesota.
   % Brett M. Averick.
   %
   % **********
   
   % check we have correct number of arguments
   narginmapper_00000= [0, 1, 2];
   if narginmapper_00000(nargin)~= 2
      error('MADMinpack:CPF:MinpackCPF_FJ:nargin', 'MADMinpack:CPF:MinpackCPF_FJ:nargin - must have 2 inputs')
   end
   
   % check n
   n= length(x); 
   if n~= 11
      error('MADMinpack:CPF:MinpackCPF_Prob:n', ['MADMinpack:CPF:MinpackCPF_Prob:n - n = length(x) = ', num2str(n), ' is illegal, n must = 11'])
   end
   
   % constants
   k= Prob.user.k; 
   p= Prob.user.p; 
   rr= Prob.user.rr; 
   
   % coding
   g_tmp_x_00000= g_x(11);
   tmp_x_00000= x(11);
   g_pdx= adimat_g_mrdivide2(p, g_tmp_x_00000, tmp_x_00000);
   pdx= p/ tmp_x_00000; 
   sqpdx= sqrt(pdx); 
   g_sqpdx= g_pdx./ (2.* sqpdx);
   tmp_MinpackCPF_F_00000= n- 1;
   tmp_MinpackCPF_F_00001= 1: tmp_MinpackCPF_F_00000;
   g_tmp_x_00001= g_x(tmp_MinpackCPF_F_00001);
   tmp_x_00001= x(tmp_MinpackCPF_F_00001);
   g_xtau= call(@sum, g_tmp_x_00001);
   xtau= sum(tmp_x_00001); 
   
   g_tmp_x_00002= g_x(1);
   tmp_x_00002= x(1);
   g_tmp_x_00003= g_x(4);
   tmp_x_00003= x(4);
   g_tmp_MinpackCPF_F_00002= g_tmp_x_00002+ g_tmp_x_00003+ g_zeros(1);
   tmp_MinpackCPF_F_00002= tmp_x_00002+ tmp_x_00003- 3.0d0;
   g_tmp_x_00004= g_x(1);
   tmp_x_00004= x(1);
   g_tmp_MinpackCPF_F_00003= 2* g_tmp_x_00004;
   tmp_MinpackCPF_F_00003= 2* tmp_x_00004;
   g_tmp_x_00005= g_x(2);
   tmp_x_00005= x(2);
   g_tmp_x_00006= g_x(4);
   tmp_x_00006= x(4);
   g_tmp_x_00007= g_x(7);
   tmp_x_00007= x(7);
   g_tmp_x_00008= g_x(8);
   tmp_x_00008= x(8);
   g_tmp_x_00009= g_x(9);
   tmp_x_00009= x(9);
   g_tmp_x_00010= g_x(10);
   tmp_x_00010= x(10);
   g_tmp_MinpackCPF_F_00004= 2* g_tmp_x_00010;
   tmp_MinpackCPF_F_00004= 2* tmp_x_00010;
   g_tmp_MinpackCPF_F_00005= g_tmp_MinpackCPF_F_00003+ g_tmp_x_00005+ g_tmp_x_00006+ g_tmp_x_00007+ g_tmp_x_00008+ g_tmp_x_00009+ g_tmp_MinpackCPF_F_00004+ g_zeros(size(rr));
   tmp_MinpackCPF_F_00005= tmp_MinpackCPF_F_00003+ tmp_x_00005+ tmp_x_00006+ tmp_x_00007+ tmp_x_00008+ tmp_x_00009+ tmp_MinpackCPF_F_00004- rr;
   g_tmp_x_00011= g_x(2);
   tmp_x_00011= x(2);
   g_tmp_MinpackCPF_F_00006= 2* g_tmp_x_00011;
   tmp_MinpackCPF_F_00006= 2* tmp_x_00011;
   g_tmp_x_00012= g_x(5);
   tmp_x_00012= x(5);
   g_tmp_MinpackCPF_F_00007= 2* g_tmp_x_00012;
   tmp_MinpackCPF_F_00007= 2* tmp_x_00012;
   g_tmp_x_00013= g_x(6);
   tmp_x_00013= x(6);
   g_tmp_x_00014= g_x(7);
   tmp_x_00014= x(7);
   g_tmp_MinpackCPF_F_00008= g_tmp_MinpackCPF_F_00006+ g_tmp_MinpackCPF_F_00007+ g_tmp_x_00013+ g_tmp_x_00014+ g_zeros(1);
   tmp_MinpackCPF_F_00008= tmp_MinpackCPF_F_00006+ tmp_MinpackCPF_F_00007+ tmp_x_00013+ tmp_x_00014- 8.0d0;
   g_tmp_x_00015= g_x(3);
   tmp_x_00015= x(3);
   g_tmp_MinpackCPF_F_00009= 2* g_tmp_x_00015;
   tmp_MinpackCPF_F_00009= 2* tmp_x_00015;
   g_tmp_x_00016= g_x(9);
   tmp_x_00016= x(9);
   tmp_MinpackCPF_F_00010= 4.0d0* rr;
   g_tmp_MinpackCPF_F_00011= g_tmp_MinpackCPF_F_00009+ g_tmp_x_00016+ g_zeros(size(tmp_MinpackCPF_F_00010));
   tmp_MinpackCPF_F_00011= tmp_MinpackCPF_F_00009+ tmp_x_00016- tmp_MinpackCPF_F_00010;
   g_tmp_x_00017= g_x(2);
   tmp_x_00017= x(2);
   g_tmp_x_00018= g_x(4);
   tmp_x_00018= x(4);
   g_tmp_MinpackCPF_F_00012= k(5)* g_tmp_x_00017* tmp_x_00018+ k(5)* tmp_x_00017* g_tmp_x_00018;
   tmp_MinpackCPF_F_00012= k(5)* tmp_x_00017* tmp_x_00018;
   g_tmp_x_00019= g_x(1);
   tmp_x_00019= x(1);
   g_tmp_x_00020= g_x(5);
   tmp_x_00020= x(5);
   g_tmp_MinpackCPF_F_00013= g_tmp_x_00019* tmp_x_00020+ tmp_x_00019* g_tmp_x_00020;
   tmp_MinpackCPF_F_00013= tmp_x_00019* tmp_x_00020;
   g_tmp_MinpackCPF_F_00014= g_tmp_MinpackCPF_F_00012- g_tmp_MinpackCPF_F_00013;
   tmp_MinpackCPF_F_00014= tmp_MinpackCPF_F_00012- tmp_MinpackCPF_F_00013;
   g_tmp_x_00021= g_x(2);
   tmp_x_00021= x(2);
   g_tmp_x_00022= g_x(4);
   tmp_x_00022= x(4);
   g_tmp_MinpackCPF_F_00015= g_tmp_x_00021* tmp_x_00022+ tmp_x_00021* g_tmp_x_00022;
   tmp_MinpackCPF_F_00015= tmp_x_00021* tmp_x_00022;
   tmp_sqrt_00000= sqrt(tmp_MinpackCPF_F_00015);
   g_tmp_sqrt_00000= g_tmp_MinpackCPF_F_00015./ (2.* tmp_sqrt_00000);
   g_tmp_MinpackCPF_F_00016= k(6)* g_tmp_sqrt_00000;
   tmp_MinpackCPF_F_00016= k(6)* tmp_sqrt_00000;
   g_tmp_x_00023= g_x(1);
   tmp_x_00023= x(1);
   tmp_sqrt_00001= sqrt(tmp_x_00023);
   g_tmp_sqrt_00001= g_tmp_x_00023./ (2.* tmp_sqrt_00001);
   g_tmp_x_00024= g_x(6);
   tmp_x_00024= x(6);
   g_tmp_MinpackCPF_F_00017= g_tmp_sqrt_00001* tmp_x_00024* sqpdx+ tmp_sqrt_00001* g_tmp_x_00024* sqpdx+ tmp_sqrt_00001* tmp_x_00024* g_sqpdx;
   tmp_MinpackCPF_F_00017= tmp_sqrt_00001* tmp_x_00024* sqpdx;
   g_tmp_MinpackCPF_F_00018= g_tmp_MinpackCPF_F_00016- g_tmp_MinpackCPF_F_00017;
   tmp_MinpackCPF_F_00018= tmp_MinpackCPF_F_00016- tmp_MinpackCPF_F_00017;
   g_tmp_x_00025= g_x(1);
   tmp_x_00025= x(1);
   g_tmp_x_00026= g_x(2);
   tmp_x_00026= x(2);
   g_tmp_MinpackCPF_F_00019= g_tmp_x_00025* tmp_x_00026+ tmp_x_00025* g_tmp_x_00026;
   tmp_MinpackCPF_F_00019= tmp_x_00025* tmp_x_00026;
   tmp_sqrt_00002= sqrt(tmp_MinpackCPF_F_00019);
   g_tmp_sqrt_00002= g_tmp_MinpackCPF_F_00019./ (2.* tmp_sqrt_00002);
   g_tmp_MinpackCPF_F_00020= k(7)* g_tmp_sqrt_00002;
   tmp_MinpackCPF_F_00020= k(7)* tmp_sqrt_00002;
   g_tmp_x_00027= g_x(4);
   tmp_x_00027= x(4);
   tmp_sqrt_00003= sqrt(tmp_x_00027);
   g_tmp_sqrt_00003= g_tmp_x_00027./ (2.* tmp_sqrt_00003);
   g_tmp_x_00028= g_x(7);
   tmp_x_00028= x(7);
   g_tmp_MinpackCPF_F_00021= g_tmp_sqrt_00003* tmp_x_00028* sqpdx+ tmp_sqrt_00003* g_tmp_x_00028* sqpdx+ tmp_sqrt_00003* tmp_x_00028* g_sqpdx;
   tmp_MinpackCPF_F_00021= tmp_sqrt_00003* tmp_x_00028* sqpdx;
   g_tmp_MinpackCPF_F_00022= g_tmp_MinpackCPF_F_00020- g_tmp_MinpackCPF_F_00021;
   tmp_MinpackCPF_F_00022= tmp_MinpackCPF_F_00020- tmp_MinpackCPF_F_00021;
   g_tmp_x_00029= g_x(1);
   tmp_x_00029= x(1);
   g_tmp_MinpackCPF_F_00023= k(8)* g_tmp_x_00029;
   tmp_MinpackCPF_F_00023= k(8)* tmp_x_00029;
   g_tmp_x_00030= g_x(4);
   tmp_x_00030= x(4);
   g_tmp_x_00031= g_x(8);
   tmp_x_00031= x(8);
   g_tmp_MinpackCPF_F_00024= g_tmp_x_00030* tmp_x_00031* pdx+ tmp_x_00030* g_tmp_x_00031* pdx+ tmp_x_00030* tmp_x_00031* g_pdx;
   tmp_MinpackCPF_F_00024= tmp_x_00030* tmp_x_00031* pdx;
   g_tmp_MinpackCPF_F_00025= g_tmp_MinpackCPF_F_00023- g_tmp_MinpackCPF_F_00024;
   tmp_MinpackCPF_F_00025= tmp_MinpackCPF_F_00023- tmp_MinpackCPF_F_00024;
   g_tmp_x_00032= g_x(1);
   tmp_x_00032= x(1);
   g_tmp_x_00033= g_x(3);
   tmp_x_00033= x(3);
   tmp_sqrt_00004= sqrt(tmp_x_00033);
   g_tmp_sqrt_00004= g_tmp_x_00033./ (2.* tmp_sqrt_00004);
   g_tmp_MinpackCPF_F_00026= k(9)* g_tmp_x_00032* tmp_sqrt_00004+ k(9)* tmp_x_00032* g_tmp_sqrt_00004;
   tmp_MinpackCPF_F_00026= k(9)* tmp_x_00032* tmp_sqrt_00004;
   g_tmp_x_00034= g_x(4);
   tmp_x_00034= x(4);
   g_tmp_x_00035= g_x(9);
   tmp_x_00035= x(9);
   g_tmp_MinpackCPF_F_00027= g_tmp_x_00034* tmp_x_00035* sqpdx+ tmp_x_00034* g_tmp_x_00035* sqpdx+ tmp_x_00034* tmp_x_00035* g_sqpdx;
   tmp_MinpackCPF_F_00027= tmp_x_00034* tmp_x_00035* sqpdx;
   g_tmp_MinpackCPF_F_00028= g_tmp_MinpackCPF_F_00026- g_tmp_MinpackCPF_F_00027;
   tmp_MinpackCPF_F_00028= tmp_MinpackCPF_F_00026- tmp_MinpackCPF_F_00027;
   g_tmp_x_00036= g_x(1);
   tmp_x_00036= x(1);
   g_tmp_MinpackCPF_F_00029= adimat_g_pow_left(g_tmp_x_00036, tmp_x_00036, 2);
   tmp_MinpackCPF_F_00029= tmp_x_00036^ 2;
   g_tmp_MinpackCPF_F_00030= k(10)* g_tmp_MinpackCPF_F_00029;
   tmp_MinpackCPF_F_00030= k(10)* tmp_MinpackCPF_F_00029;
   g_tmp_x_00037= g_x(4);
   tmp_x_00037= x(4);
   g_tmp_MinpackCPF_F_00031= adimat_g_pow_left(g_tmp_x_00037, tmp_x_00037, 2);
   tmp_MinpackCPF_F_00031= tmp_x_00037^ 2;
   g_tmp_x_00038= g_x(10);
   tmp_x_00038= x(10);
   g_tmp_MinpackCPF_F_00032= g_tmp_MinpackCPF_F_00031* tmp_x_00038* pdx+ tmp_MinpackCPF_F_00031* g_tmp_x_00038* pdx+ tmp_MinpackCPF_F_00031* tmp_x_00038* g_pdx;
   tmp_MinpackCPF_F_00032= tmp_MinpackCPF_F_00031* tmp_x_00038* pdx;
   g_tmp_MinpackCPF_F_00033= g_tmp_MinpackCPF_F_00030- g_tmp_MinpackCPF_F_00032;
   tmp_MinpackCPF_F_00033= tmp_MinpackCPF_F_00030- tmp_MinpackCPF_F_00032;
   g_tmp_x_00039= g_x(11);
   tmp_x_00039= x(11);
   g_tmp_MinpackCPF_F_00034= g_tmp_x_00039- g_xtau;
   tmp_MinpackCPF_F_00034= tmp_x_00039- xtau;
   g_F= [g_tmp_MinpackCPF_F_00002;
      g_tmp_MinpackCPF_F_00005;
      g_tmp_MinpackCPF_F_00008;
      g_tmp_MinpackCPF_F_00011;
      g_tmp_MinpackCPF_F_00014;
      g_tmp_MinpackCPF_F_00018;
      g_tmp_MinpackCPF_F_00022;
      g_tmp_MinpackCPF_F_00025;
      g_tmp_MinpackCPF_F_00028;
      g_tmp_MinpackCPF_F_00033;
      ;
      g_tmp_MinpackCPF_F_00034];
   F= [tmp_MinpackCPF_F_00002;
      tmp_MinpackCPF_F_00005;
      tmp_MinpackCPF_F_00008;
      tmp_MinpackCPF_F_00011;
      tmp_MinpackCPF_F_00014;
      tmp_MinpackCPF_F_00018;
      tmp_MinpackCPF_F_00022;
      tmp_MinpackCPF_F_00025;
      tmp_MinpackCPF_F_00028;
      tmp_MinpackCPF_F_00033;
      ;
      tmp_MinpackCPF_F_00034]; 
end
