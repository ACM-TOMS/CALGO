% Generated by ADiMat 0.6.0-4870
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_XML  -- Write list of unbound identifiers in XML format.
% DEPENDENCIES_XML  -- Write list of functions in XML format.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% FUNCTION_LIST_XML	-- Write list of functions to XML file.
% VERBOSITYLEVEL=5
% AD_IVARS= x
% AD_DVARS= F

function [g_F, F]= g_MinpackCTS_F(g_x, x, Prob)
   % MinpackCTS_F: Minpack Coating Thickness Standardisation (CTS) function.
   %
   %    Computes function for the Coating Thickness
   %    Standardisation (CTS) problem from the MINPACK-2 collection.
   %
   % USE:
   %           F = MinpackCTS_F(x,Prob)
   % where
   %   x    : solution vector with length(x)=134
   %   Prob : structure created by MinpackEPT_Prob with components
   %     Prob.user.n      : number of variables to be fit
   %     Prob.user.indvar : independent variables in fitting problem
   %     Prob.user.y      : dependent variables in fitting problem
   %     Prob.user.scale1 : scaling for
   %     Prob.user.scale2 : scaling for
   
   % AUTHOR: S.A.Forth & K. Lenton
   % DATE: 21/06/11
   % Copyright 2011-2011: S.A. Forth, Cranfield University
   % REVISIONS:
   % DATE  WHO   WHAT
   
   % Original Fortran Header Comments follow
   %
   %      subroutine dctsfj(m,n,x,fvec,J,ldJ,task)
   %      character*(*) task
   %      integer m, n, ldJ
   %      double precision x(n), fvec(m), J(ldJ,n)
   % **********
   %
   % Subroutine dctsfj
   %
   % This subroutine computes the function and the Jacobian matrix of
   % the coating thickness standardization problem.
   %
   % The subroutine statement is
   %
   %   subroutine dctsfj(m,n,x,fvec,J,ldJ,task)
   %
   % where
   %
   %   m is an integer variable.
   %     On entry m is the number of functions.
   %        For the coating thickness standardization problem m = 252.
   %     On exit m is unchanged.
   %
   %   n is an integer variable.
   %     On entry n is the number of variables.
   %        For the coating thickness standardization problem n = 134.
   %     On exit n is unchanged.
   %
   %   x is a double precision array of dimension n.
   %     On entry x specifies the vector x if task = 'F', 'J', or 'FJ'.
   %        Otherwise x need not be specified.
   %     On exit x is unchanged if task = 'F', 'J', or 'FJ'. Otherwise
   %        x is set according to task.
   %
   %   fvec is a double precision array of dimension m.
   %     On entry fvec need not be specified.
   %     On exit fvec contains the function evaluated at x if
   %        task = 'F' or 'FJ'.
   %
   %   J is a double precision array of dimension (ldJ,n).
   %     On entry J need not be specified.
   %     On exit J contains the Jacobian matrix evaluated at x if
   %        task = 'J' or 'FJ'.
   %
   %   ldJ is an integer variable.
   %      On entry ldJ is the leading dimension of J.
   %      On exit ldJ is unchanged.
   %
   %   task is a character variable.
   %     On entry task specifies the action of the subroutine:
   %
   %        task               action
   %        ----               ------
   %         'F'     Evaluate the function at x.
   %         'J'     Evaluate the Jacobian matrix at x.
   %         'FJ'    Evaluate the function and the Jacobian at x.
   %         'XS'    Set x to the standard starting point xs.
   %
   %     On exit task is unchanged.
   %
   % MINPACK-2 Project. November 1993.
   % Argonne National Laboratory and University of Minnesota.
   % Brett M. Averick.
   %
   % **********
   
   % if nargin~=2
   %     error ('MADMinpack:CTS:MinpackCTS_F:nargin',...
   %         'MADMinpack:CTS:MinpackCTS_F:nargin - must have 2 input arguments x and Prob')
   % end
   % 
   n= length(x); 
   % if (n ~= Prob.user.n)
   %     error ('MADMinpack:CTS:MinpackCTS_F:n',...
   %         ['MADMinpack:CTS:MinpackCTS_F:n - length(x) must be ',num2str(Prob.user.n)])
   % end
   
   % number of equations
   m= 2* (n- 8); 
   mdiv4= m/ 4; 
   
   % unpack user parameters
   indvar= Prob.user.indvar; 
   y= Prob.user.y; 
   scale1= Prob.user.scale1; 
   scale2= Prob.user.scale2; 
   
   % calculate function value
   g_tmp_x_00000= g_x(1);
   tmp_x_00000= x(1);
   g_F= zeros(m, 1).* g_tmp_x_00000;
   F= zeros(m, 1).* tmp_x_00000; 
   
   g_tmp_x_00001= g_x(1);
   tmp_x_00001= x(1);
   g_tmp_x_00002= g_x(2);
   tmp_x_00002= x(2);
   tmp_MinpackCTS_F_00000= 8+ mdiv4;
   tmp_MinpackCTS_F_00001= 9: tmp_MinpackCTS_F_00000;
   g_tmp_x_00003= g_x(tmp_MinpackCTS_F_00001);
   tmp_x_00003= x(tmp_MinpackCTS_F_00001);
   g_tmp_MinpackCTS_F_00002= g_tmp_x_00003+ g_zeros(size(indvar(: , 1)));
   tmp_MinpackCTS_F_00002= indvar(: , 1)+ tmp_x_00003;
   g_tmp_MinpackCTS_F_00003= g_tmp_x_00002* tmp_MinpackCTS_F_00002+ tmp_x_00002* g_tmp_MinpackCTS_F_00002;
   tmp_MinpackCTS_F_00003= tmp_x_00002* tmp_MinpackCTS_F_00002;
   g_tmp_x_00004= g_x(3);
   tmp_x_00004= x(3);
   tmp_MinpackCTS_F_00004= mdiv4+ 9;
   tmp_MinpackCTS_F_00005= 2* mdiv4;
   tmp_MinpackCTS_F_00006= 8+ tmp_MinpackCTS_F_00005;
   tmp_MinpackCTS_F_00007= tmp_MinpackCTS_F_00004: tmp_MinpackCTS_F_00006;
   g_tmp_x_00005= g_x(tmp_MinpackCTS_F_00007);
   tmp_x_00005= x(tmp_MinpackCTS_F_00007);
   g_tmp_MinpackCTS_F_00008= g_tmp_x_00005+ g_zeros(size(indvar(: , 2)));
   tmp_MinpackCTS_F_00008= indvar(: , 2)+ tmp_x_00005;
   g_tmp_MinpackCTS_F_00009= g_tmp_x_00004* tmp_MinpackCTS_F_00008+ tmp_x_00004* g_tmp_MinpackCTS_F_00008;
   tmp_MinpackCTS_F_00009= tmp_x_00004* tmp_MinpackCTS_F_00008;
   g_tmp_x_00006= g_x(4);
   tmp_x_00006= x(4);
   tmp_MinpackCTS_F_00010= 8+ mdiv4;
   tmp_MinpackCTS_F_00011= 9: tmp_MinpackCTS_F_00010;
   g_tmp_x_00007= g_x(tmp_MinpackCTS_F_00011);
   tmp_x_00007= x(tmp_MinpackCTS_F_00011);
   g_tmp_MinpackCTS_F_00012= g_tmp_x_00007+ g_zeros(size(indvar(: , 1)));
   tmp_MinpackCTS_F_00012= indvar(: , 1)+ tmp_x_00007;
   g_tmp_MinpackCTS_F_00013= g_tmp_x_00006* tmp_MinpackCTS_F_00012+ tmp_x_00006* g_tmp_MinpackCTS_F_00012;
   tmp_MinpackCTS_F_00013= tmp_x_00006* tmp_MinpackCTS_F_00012;
   tmp_MinpackCTS_F_00014= mdiv4+ 9;
   tmp_MinpackCTS_F_00015= 2* mdiv4;
   tmp_MinpackCTS_F_00016= 8+ tmp_MinpackCTS_F_00015;
   tmp_MinpackCTS_F_00017= tmp_MinpackCTS_F_00014: tmp_MinpackCTS_F_00016;
   g_tmp_x_00008= g_x(tmp_MinpackCTS_F_00017);
   tmp_x_00008= x(tmp_MinpackCTS_F_00017);
   g_tmp_MinpackCTS_F_00018= g_tmp_x_00008+ g_zeros(size(indvar(: , 2)));
   tmp_MinpackCTS_F_00018= indvar(: , 2)+ tmp_x_00008;
   g_tmp_MinpackCTS_F_00019= g_tmp_MinpackCTS_F_00013.* tmp_MinpackCTS_F_00018+ tmp_MinpackCTS_F_00013.* g_tmp_MinpackCTS_F_00018;
   tmp_MinpackCTS_F_00019= tmp_MinpackCTS_F_00013.* tmp_MinpackCTS_F_00018;
   g_F(1: mdiv4)= g_tmp_x_00001+ g_tmp_MinpackCTS_F_00003+ g_tmp_MinpackCTS_F_00009+ g_tmp_MinpackCTS_F_00019+ g_zeros(size(y(1: mdiv4)));
   F(1: mdiv4)= tmp_x_00001+ tmp_MinpackCTS_F_00003+ tmp_MinpackCTS_F_00009+ tmp_MinpackCTS_F_00019- y(1: mdiv4); 
   g_tmp_x_00009= g_x(5);
   tmp_x_00009= x(5);
   g_tmp_x_00010= g_x(6);
   tmp_x_00010= x(6);
   tmp_MinpackCTS_F_00020= 8+ mdiv4;
   tmp_MinpackCTS_F_00021= 9: tmp_MinpackCTS_F_00020;
   g_tmp_x_00011= g_x(tmp_MinpackCTS_F_00021);
   tmp_x_00011= x(tmp_MinpackCTS_F_00021);
   g_tmp_MinpackCTS_F_00022= g_tmp_x_00011+ g_zeros(size(indvar(: , 1)));
   tmp_MinpackCTS_F_00022= indvar(: , 1)+ tmp_x_00011;
   g_tmp_MinpackCTS_F_00023= g_tmp_x_00010* tmp_MinpackCTS_F_00022+ tmp_x_00010* g_tmp_MinpackCTS_F_00022;
   tmp_MinpackCTS_F_00023= tmp_x_00010* tmp_MinpackCTS_F_00022;
   g_tmp_x_00012= g_x(7);
   tmp_x_00012= x(7);
   tmp_MinpackCTS_F_00024= mdiv4+ 9;
   tmp_MinpackCTS_F_00025= 2* mdiv4;
   tmp_MinpackCTS_F_00026= 8+ tmp_MinpackCTS_F_00025;
   tmp_MinpackCTS_F_00027= tmp_MinpackCTS_F_00024: tmp_MinpackCTS_F_00026;
   g_tmp_x_00013= g_x(tmp_MinpackCTS_F_00027);
   tmp_x_00013= x(tmp_MinpackCTS_F_00027);
   g_tmp_MinpackCTS_F_00028= g_tmp_x_00013+ g_zeros(size(indvar(: , 2)));
   tmp_MinpackCTS_F_00028= indvar(: , 2)+ tmp_x_00013;
   g_tmp_MinpackCTS_F_00029= g_tmp_x_00012* tmp_MinpackCTS_F_00028+ tmp_x_00012* g_tmp_MinpackCTS_F_00028;
   tmp_MinpackCTS_F_00029= tmp_x_00012* tmp_MinpackCTS_F_00028;
   g_tmp_x_00014= g_x(8);
   tmp_x_00014= x(8);
   tmp_MinpackCTS_F_00030= 8+ mdiv4;
   tmp_MinpackCTS_F_00031= 9: tmp_MinpackCTS_F_00030;
   g_tmp_x_00015= g_x(tmp_MinpackCTS_F_00031);
   tmp_x_00015= x(tmp_MinpackCTS_F_00031);
   g_tmp_MinpackCTS_F_00032= g_tmp_x_00015+ g_zeros(size(indvar(: , 1)));
   tmp_MinpackCTS_F_00032= indvar(: , 1)+ tmp_x_00015;
   g_tmp_MinpackCTS_F_00033= g_tmp_x_00014* tmp_MinpackCTS_F_00032+ tmp_x_00014* g_tmp_MinpackCTS_F_00032;
   tmp_MinpackCTS_F_00033= tmp_x_00014* tmp_MinpackCTS_F_00032;
   tmp_MinpackCTS_F_00034= mdiv4+ 9;
   tmp_MinpackCTS_F_00035= 2* mdiv4;
   tmp_MinpackCTS_F_00036= 8+ tmp_MinpackCTS_F_00035;
   tmp_MinpackCTS_F_00037= tmp_MinpackCTS_F_00034: tmp_MinpackCTS_F_00036;
   g_tmp_x_00016= g_x(tmp_MinpackCTS_F_00037);
   tmp_x_00016= x(tmp_MinpackCTS_F_00037);
   g_tmp_MinpackCTS_F_00038= g_tmp_x_00016+ g_zeros(size(indvar(: , 2)));
   tmp_MinpackCTS_F_00038= indvar(: , 2)+ tmp_x_00016;
   g_tmp_MinpackCTS_F_00039= g_tmp_MinpackCTS_F_00033.* tmp_MinpackCTS_F_00038+ tmp_MinpackCTS_F_00033.* g_tmp_MinpackCTS_F_00038;
   tmp_MinpackCTS_F_00039= tmp_MinpackCTS_F_00033.* tmp_MinpackCTS_F_00038;
   g_F(mdiv4+ 1: 2* mdiv4)= g_tmp_x_00009+ g_tmp_MinpackCTS_F_00023+ g_tmp_MinpackCTS_F_00029+ g_tmp_MinpackCTS_F_00039+ g_zeros(size(y(mdiv4+ 1: 2* mdiv4)));
   F(mdiv4+ 1: 2* mdiv4)= tmp_x_00009+ tmp_MinpackCTS_F_00023+ tmp_MinpackCTS_F_00029+ tmp_MinpackCTS_F_00039- y(mdiv4+ 1: 2* mdiv4); 
   tmp_MinpackCTS_F_00040= 8+ mdiv4;
   tmp_MinpackCTS_F_00041= 9: tmp_MinpackCTS_F_00040;
   g_tmp_x_00017= g_x(tmp_MinpackCTS_F_00041);
   tmp_x_00017= x(tmp_MinpackCTS_F_00041);
   g_F(2* mdiv4+ 1: 3* mdiv4)= scale1* g_tmp_x_00017;
   F(2* mdiv4+ 1: 3* mdiv4)= scale1* tmp_x_00017; 
   tmp_MinpackCTS_F_00042= mdiv4+ 9;
   tmp_MinpackCTS_F_00043= 2* mdiv4;
   tmp_MinpackCTS_F_00044= 8+ tmp_MinpackCTS_F_00043;
   tmp_MinpackCTS_F_00045= tmp_MinpackCTS_F_00042: tmp_MinpackCTS_F_00044;
   g_tmp_x_00018= g_x(tmp_MinpackCTS_F_00045);
   tmp_x_00018= x(tmp_MinpackCTS_F_00045);
   g_F(3* mdiv4+ 1: 4* mdiv4)= scale2* g_tmp_x_00018;
   F(3* mdiv4+ 1: 4* mdiv4)= scale2* tmp_x_00018; 

end
