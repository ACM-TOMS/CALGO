%
% File:     README.tex
% Contents: "Using the FORTRAN subroutines for generating box constrained
%            optimization problems"
% Comments: this the README file to the suite of FORTRAN routines
% Authors:  F. Facchinei, J. Judice and J. Soares
% Dates:    Oct/95, revised Oct/96, final version Mar/97
%

\documentstyle{esub2acm}

\def\bkR{{\rm I\kern-.17em R}}
\def\bkN{{\rm I\kern-.17em N}}

\begin{document}

\title{Using the FORTRAN subroutines for generating box constrained 
optimization problems}

\author{Francisco Facchinei\\
Dipartimento di
Informatica  e Sistemistica,
Universit\`a di Roma ``La Sapienza'',
Italy. \and
Joaquim J\'udice \and
Jo\~ao Soares\\ Departamento de Matem\'atica, Universidade de Coimbra, 
Portugal}

\begin{abstract}
We explain how to use a set of FORTRAN subroutines for generating box 
constrained optimization problems as introduced in 
\cite{soares95,soares95a}. The subroutines made available are to be linked 
to the user main program. One example of such a main program, which not only 
exemplifies the usage of the suite of routines but also
tests the installation, is also supplied. 
\end{abstract}

\begin{bottomstuff}
\begin{authinfo}
\address{
Departamento de Matem\'atica, Universidade de Coimbra, 3000 Coimbra, Portugal.
Email: {\tt jsoares@mat.uc.pt}
}
\end{authinfo}
\end{bottomstuff}

\markboth{Facchinei, J\'udice and Soares}
        {Using the FORTRAN subroutines}

\maketitle


\section{\label{software}Implementation and design}

The following subroutines have been  implemented in ANSI Standard FORTRAN 77. 
There are no specific instances of machine 
dependence, except for the maximum size of a common block, which we refer 
to in Section \ref{lastsub}. Check Appendix~\ref{parameters} for a 
description of all parameters
involved in the only routines that should be explicitly employed by the user, 
namely, {\tt BCP01},  {\tt BCP02}, {\tt BCP03}, {\tt BCP10}, {\tt BCP11} and  
{\tt BCP12}. 

\begin{enumerate}
\item subroutine {\tt BCP01}: sets the bounds and
the data required to evaluate the objective function $f$ and its 
derivatives.
\item subroutine {\tt BCP02}: prints an error message on the screen. 
\item subroutine {\tt BCP03}: prints information concerning the problem 
generated.
\item subroutine {\tt BCP04}: alters randomly the position of the 
elements in a vector of integer components. 
\item functions {\tt HI0, HI1, HI2}: compute the value, the
first derivative and the second order derivative of the 
function $h_i$, respectively. 
\item subroutine {\tt BCP10}: computes the objective function $f$ at a 
given point $x$. 
\item subroutine {\tt BCP11}:  computes the gradient vector of the
objective function $f$ at a given point $x$.
\item subroutine {\tt BCP12}: computes the product of the Hessian 
at a given point $x$ by a vector $d$.
\item subroutine {\tt rand\/}: is a portable random 
number generator \cite{schrage79}.
\end{enumerate}


The box constrained problem is generated by a call to 
subroutine {\tt BCP01}, where the user determines the characteristics of the 
problem generated through the choice of various parameters. 
However, the exact definition of the problem also 
depends on some random choices. For example, the user can determine exactly 
the  number of lower bounds and the number of those that are
active at the solution, but their placement is determined randomly. 

On exit from {\tt BCP01}, if the variable {\tt INFRM} is 
not zero then an error has occurred and
the box constrained problem has not been generated. The user may 
get an appropriate error message by calling subroutine {\tt BCP02}.

If the problem has been successfully generated ({\tt INFRM = 0}), 
the user has access to the vectors {\tt L} and {\tt U} containing the lower and 
upper bounds  (infinity was set to $10^{20}$). Additional information may be
obtained through a call to {\tt BCP03}. 
Subroutines {\tt BCP10}, {\tt BCP11} and   {\tt BCP12} provide
the value of the generated problem objective function and its derivatives.
Subroutine  {\tt BCP10} provides in {\tt F} the value of the function 
$f$ calculated at {\tt X}, {\tt BCP11} stores in {\tt GF} the gradient of $f$ 
calculated at {\tt X}, and {\tt BCP12} computes in  {\tt HFD} the product of the
Hessian of $f$ at {\tt X} times the vector {\tt D}.
These are the quantities used by most existing codes for the solution 
of large-scale box constrained nonlinear programs. 


The generation of the box constrained problem is based on
an underlying unconstrained problem. The data concerning the unconstrained
problem must be user-supplied through the definition of the following 
four FORTRAN
subroutines: 

\begin{verbatim}
                SUBROUTINE FUNCTG(N,X,G)
                SUBROUTINE GRADG(N,X,GG)
                SUBROUTINE HESGD(N,X,D,HGD)
                SUBROUTINE SOLUG(N,XBAR)                
\end{verbatim}

Subroutine {\tt FUNCTG\/} gives the value of the function $g$ at a 
given point $x$, {\tt GRADG\/} gives the gradient of $g$  at $x$  
and {\tt HESGD\/} performs
the product of the Hessian of $g$ at $x$ by a vector $d$. Finally,
subroutine {\tt SOLUG\/} provides a solution of the unconstrained 
problem. A detailed description of the
parameters follows.

\begin{itemize}
\item {\tt N} (Input, {\tt INTEGER}) The dimension of the problem.
\item {\tt X} (Input,  {\tt DOUBLE PRECISION}) A vector of dimension {\tt N}
representing a point $x \in \bkR^n$.
\item {\tt G} (Output, {\tt DOUBLE PRECISION}) A variable that gives the value of the
unconstrained objective function evaluated at {\tt X}.
\item {\tt GG} (Output, {\tt DOUBLE PRECISION}) A vector of dimension {\tt N} 
corresponding to the value of the
gradient  of the unconstrained objective function evaluated in {\tt X}.
\item {\tt D} (Input, {\tt DOUBLE PRECISION}) A vector of dimension {\tt N}.
\item {\tt HGD} (Output, {\tt DOUBLE PRECISION}) A variable that provides the product 
of the Hessian of the
unconstrained objective function $g$ evaluated at {\tt X} times the vector 
{\tt D}.
\item {\tt XBAR} (Output, {\tt DOUBLE PRECISION}) A vector of dimension {\tt N} 
corresponding to the unconstrained minimizer. 
\end{itemize}

\section{\label{install}Installation notes}

\subsection{Files}
The FORTRAN subroutines that the user 
should link to his/her code are in the file {\em src.f}. 
The program {\tt BCPVER} in {\em driver.f} performs a test of the 
installation and can also
give insight on the usage of the subroutines. 
Since the execution of the test of installation requires 
the user to provide the four subroutines listed in the previous section,
     we provide a demo set of such routines in the file  {\em bcpex.f}.


The code has already been compiled on a SUN SPARC 10, 
an IBM RS/6000 and an HP Model 712/60. For completeness, we provide 
each of the {\em makefiles\/} in the files {\em make.hp}, {\em make.ibm}
and {\em make.sun}.

\subsection{Limitations\label{lastsub}}

The FORTRAN constant {\tt NN}, defining the size of the vectors in the common
blocks, controls the size of the largest problem that can be generated 
by the suite. 
The value of {\tt NN} is currently fixed 
at 10000 in a {\tt PARAMETER} statement in the 
subroutines {\tt BCP01}, 
{\tt BCP03}, {\tt BCP10}, {\tt BCP11} and {\tt BCP12}, and 
in the program 
{\tt BCPVER}. The user must increase its value in all the 
{\tt PARAMETER} 
statements if he/she wishes to generate larger problems.

%\bibliographystyle{esub2acm}
%\bibliography{abbrv,titles1,titles2,titles3}

\begin{thebibliography}{}

\bibitem[\protect\citeauthoryear{Facchinei, J\'udice, and Soares}{Facchinei
  et~al.}{a}]{soares95}
\bibsc{Facchinei, F., J\'udice, J., and Soares, J.} \bibyear{??a}.
\newblock {FORTRAN} subroutines for generating box constrained optimization
  problems.
\newblock ACM Trans. Math. Software.

\bibitem[\protect\citeauthoryear{Facchinei, J\'udice, and Soares}{Facchinei
  et~al.}{b}]{soares95a}
\bibsc{Facchinei, F., J\'udice, J., and Soares, J.} \bibyear{??b}.
\newblock Generating box constrained optimization problems.
\newblock ACM Trans. Math. Software.

\bibitem[\protect\citeauthoryear{Schrage}{Schrage}{1979}]{schrage79}
\bibsc{Schrage, L.} \bibyear{1979}.
\newblock A more portable fortran random generator.
\newblock \bibemphic{ACM Trans. Math. Software}~\bibemph{5},~2 (June),
  132--138.

\end{thebibliography}

\newpage

\appendix
\label{parameters}

\section{BCP01 parameter list\label{parameters}}
\begin{verbatim}

      SUBROUTINE  BCP01( N     , L     , U     , BND   , LOWBND,
     1                   ACTBND, PAIR  , DEG   , LOWM1 , UPPM1 ,
     2                   LOWM2 , UPPM2 , WIDTH1, WIDTH2, HIF   ,
     3                   ISEED , INFRM                         )

c  N       (input) INTEGER                 
c          The number of variables in the problem. (Must be <= NN, 
c          see common block below)
c
c  L, U    (output) DOUBLE PRECISION vectors of dimension N
c          The bounds of the new problem. 
c
c  BND     (input) INTEGER
c          The number of bound constraints (or simply, bounds), expressed as 
c          the percentage of the 2*n possible constraints, that are really 
c          existing (Must be in [0,100]). 
c          Example: if N is 500 and BND=40 then the problem has 400 bounds.
c
c  LOWBND  (input) INTEGER
c          The number of lower bounds, expressed as the percentage of 
c          the number of constraints as determined by BND (Must be in 
c          [0,100]). This quantity also determines the number of upper 
c          bounds.
c          Example: if N is 500, BND is 40 and LOWBND=75 then there 
c          are 300 (100) lower (upper) bounds.
c
c  ACTBND  (input) INTEGER
c          The number of active bounds at the unconstrained solution, 
c          expressed as the percentage of the number of constraints as 
c          determined by BND (Must be in [0,100]). These active 
c          bounds are distributed proportionally to LOWBND.
c          Example: Continuing the previous example, if ACTBND is 50 then 
c          150 (50) of the lower (upper) bounds should be active at the 
c          unconstrained solution.
c
c  PAIR    (input) INTEGER
c          If this parameter is set to 1 then the constraints as 
c          determined by BND must come in pairs, i.e. each variable 
c          has either no constraint or both lower and upper bounds (in 
c          which case LOWBND must be set to 50).  If PAIR is 
c          set to 0 then the indices of variables having upper bounds are 
c          chosen randomly and independently of the lower bounds
c          (Must be 0 or 1).
c
c  DEG   (input) INTEGER
c          The number of Lagrange multipliers (at the unconstrained solution)
c          uniformly distributed in the interval [LOWM1, UPPM1] (see below), 
c          expressed as the percentage of the active constraints 
c          (Must be in [0,100]).
c          The remaining active constraints have Lagrange multipliers 
c          uniformly distributed in [LOWM2, UPPM2] (see below). 
c          Example: Continuing the example, if  DEG=10 then 15 (5) active 
c          lower (upper) bounds (at the unconstrained solution)  have 
c          Lagrange multipliers uniformly distributed in [LOWM1, UPPM1], 
c          while the remaining active bounds have Lagrange multipliers 
c          uniformly distributed in [LOWM2, UPPM2]. 
c
c  LOWM1, UPPM1, LOWM2, UPPM2   (input) DOUBLE PRECISION
c          These parameters specify the ranges for the 
c          Lagrange multipliers according to what explained above.
c          (Must be >= 0)
c
c  WIDTH1, WIDTH2   (input) DOUBLE PRECISION
c          These two parameters control the value of the bounds that
c          are not active at the unconstrained solution. More precisely, 
c          if the i-th component has a lower bound not active at the 
c          unconstrained solution xbar then this bound is randomly chosen in 
c          the interval [xbar_i - WIDTH2, xbar_i - WIDTH1]. Analogously, 
c          if the i-th component has an upper bound not active at 
c          the unconstrained solution xbar then this bound is randomly chosen 
c          in the interval [xbar_i + WIDTH1, xbar_i + WIDTH2] (Must be >= 0).
c
c  HIF    (input) INTEGER
c          This parameter determines which function h_i is to be used by 
c          the generator. If HIF is equal to
c
c          1: h_i(x_i)= beta_i * ( x_i - xbar_i );
c
c          2: h_i(x_i)=( x_i - xbar_i )^3 + beta_i*( x_i - xbar_i );
c
c          3: h_i(x_i)=( x_i - xbar_i )^(7/3)  + beta_i*( x_i - xbar_i ).
c
c          (Must be  1, 2 or 3)
c
c  ISEED   (input) INTEGER
c          A seed for the random number generator. By running the box 
c          constrained problems generator with the same choice of
c          parameters but two different seeds, two different box 
c          constrained problems are generated with the same overall 
c          characteristics (Must be >= 0).
c
c  INFRM   (output) INTEGER
c          Determines if a successful call to GENBP has occurred 
c          (INFRM=0) or not (INFRM<>0).
\end{verbatim}

\section{BCP02 parameter list}
\begin{verbatim}

      SUBROUTINE BCP02(INFRM)

c  INFRM   (input) INTEGER      (see above)
c          Determines if a successful call to BCP01 has occurred 
c          (INFRM=0) or not (INFRM<>0).
c          If INFRM is equal to
c            1: N is less than 1 or greater than NN 
c            2, 3, 4, 5, 6, 11: Some integer parameter is defined
c               out of its range.
c            7: PAIR=1 but LOWBND is not 50.
c            8: Either LOWM1 or LOWM2 is less than zero.
c            9: Either LOWM1 is greater than UPPM1 or LOWM2 is greater 
c               than UPPM2.
c            10: Either WIDTH1 is less than zero or WIDTH1 is greater 
c               than WIDTH2.
c            12: It is impossible to make a selection because LOWBND
c               is too large.
c            13: It is impossible to make a selection because LOWBND
c               is too small.
c            14: It is impossible to make a selection because ACTBND
c               is too large.
\end{verbatim}

\section{BCP03 parameter list}
\begin{verbatim}
  
      SUBROUTINE  BCP03( N, L, U )

c  N       (input) INTEGER                 
c          The number of variables in the problem.
c
c  L, U    (input) DOUBLE PRECISION vectors of dimension N   
c          The bounds of the new problem. 
\end{verbatim}

\section{BCP10 parameter list}
\begin{verbatim}

        SUBROUTINE BCP10( N, X, F)

c     N    (input) INTEGER
c          The number of variables in the problem.
c
c     X    (input) DOUBLE PRECISION vector of dimension N
c          The point where the objective function is to be evaluated.
c
c     F    (output) DOUBLE PRECISION
c          The objective function value.
\end{verbatim}

\section{BCP11 parameter list}
\begin{verbatim}

      SUBROUTINE BCP11( N, X, GF)

c     N    (input) INTEGER
c          The number of variables in the problem.
c
c     X    (input) DOUBLE PRECISION vector of dimension N
c          The point where the gradient of the objective function is to 
c          be evaluated.
c
c     GF   (output) DOUBLE PRECISION vector of dimension N
c          The gradient of objective function values.
\end{verbatim}

\section{BCP12 parameter list}
\begin{verbatim}

      SUBROUTINE BCP12( N, X, D, HFD )

c     N    (input) INTEGER
c          The number of variables in the problem.
c
c     X    (input) DOUBLE PRECISION vector of dimension N
c          The point where the Hessian matrix of the objective function 
c          is to be evaluated.
c
c     D    (input) DOUBLE PRECISION vector of dimension N
c          The vector that will be multiplied by the Hessian matrix.
c
c     HFD  (output) DOUBLE PRECISION vector of dimension N
c          The resulting vector.  
\end{verbatim}


\end{document}
