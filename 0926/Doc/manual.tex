\documentclass[paper=a4,smallheadings]{scrartcl}
\usepackage{scrpage2}
\usepackage{typearea}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage[colorlinks=true,linkcolor=red,urlcolor=red]{hyperref}
%
%Sets of numbers
\newcommand{\integers}{\mathbb{Z}}
\newcommand{\reals}   {\mathbb{R}}
\newcommand{\complex} {\mathbb{C}}
%
%Roman characters in maths mode
\newcommand{\rd} {\mathrm d}
\newcommand{\re} {\mathrm e}
\newcommand{\ri} {\mathrm i}
%
%Handy shortcut when describing implementation
\newcommand\iitem[1]{\item \texttt{#1} \par}
%
%Style adjustments
%%%%%%%%%%%%%%%%%%%
%
\addtolength{\textheight}{1in}
\areaset{\textwidth}{\textheight}
\pagestyle{scrheadings}
\cfoot{}
\lohead{\today}
\rohead{\pagemark}
\makeatletter
\def\author#1{\gdef\@author{\normalsize{#1}}}%
\makeatother
%
%*************
\begin{document}
\title{\texttt{in\_gamma\_sequence} documentation}
\author{Ian Thompson}
\date{}
%
\maketitle
\tableofcontents
\newpage
%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%
This manual describes the implementation of the algorithm in
\cite{Thompson11b}, which computes a sequence of values
$S_{n_0}(x),\ldots,S_{n_1}(x)$, where $x\ge 0$, and $n_0$ and $n_1$
are arbitrary integers with $n_1\ge n_0$. The function $S_n(x)$ is
related to the lower incomplete gamma function via
\begin{equation}\label{s-gamma}
\gamma(n+\tfrac{1}{2},-x) = \re^x\ri(-1)^n x^{n+1/2} S_n(x).
\end{equation}
Since $S_n(x)$ is real, $\gamma(n+\tfrac{1}{2},-x)$ is purely
imaginary, the upper incomplete gamma function can be computed
using the identity
\begin{equation}\label{split}
\Gamma(n+\tfrac{1}{2},x) = \Gamma(n+\tfrac{1}{2}) - \gamma(n+\tfrac{1}{2},x),
\end{equation}
without any loss of significant digits.
%
\subsection{Files provided}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\setlength{\itemsep}{0pt}
\item \texttt{in\_gamma\_sequence.f90}
\item \texttt{in\_gamma\_test.f90}
\item \texttt{binary\_float.mpl}
\item \texttt{in\_gamma.mpl}
\item \texttt{in\_gamma\_precomp.mpl}
\item \texttt{in\_gamma\_test.mpl}
\item \texttt{in\_gamma\_precomp.dat}
\item \texttt{in\_gamma\_test.dat}
\end{itemize}
%
\section{Compiling}
%%%%%%%%%%%%%%%%%%%
The Fortran 2003 code for the algorithm is contained in the file
\texttt{in\_gamma\_sequence.f90}. This contains no main program, and
so a flag (usually \texttt{-c}) is required to prevent the compiler
from attempting to produce an executable.  Some compilers treat the
features introduced in Fortran 2003 as extensions; it is desirable
suppress warnings concerning these.  Two directives are used to strip
out diagnostic code at compile time, and so a flag may be required to
invoke the preprocessor. Alternatively, the file extension can be
changed (usually to \texttt{.F90} or \texttt{.ff90}), so that the
preprocessor is invoked automatically.  Full details of the preprocessor
and the means of invoking it are provided in the compiler documentation.\footnote{%
Intel:\ \url{http://software.intel.com/en-us/articles/intel-fortran-composer-xe-documentation} \\
NAG:\ \url{http://www.nag.co.uk/nagware/np/r53_doc/index} \\
Gnu:\ \url{http://gcc.gnu.org/onlinedocs/gfortran/}
}
The recommended flags for compiling \texttt{in\_gamma\_sequence.f90} are
as follows:
\begin{itemize}
\item NAG Fortran compiler:\ \texttt{-c -f2003 -fpp}
\item Intel Fortran compiler:\ \texttt{-c -stand=f03 -fpp=1}
\item Gnu Fortran compiler (\texttt{gfortran}):\ \texttt{-c -std=f2003 -cpp}
\end{itemize}
The flags \texttt{-DDIAGNOSTIC=true} and
\texttt{-DSUPERDIAGNOSTIC=true} can be used to activate the diagnostic
code. These options cause the program to output information during
calculations, and have no effect on the results.
The testing program \texttt{in\_gamma\_test.f90} contains no
preprocessor directives, and so only the second flag
(i.e.\ \texttt{-f2003} or the equivalent) is recommended.
%
\section{Testing and using the code}
\label{sec:using}
%%%%%%%%%%%%%%%%%
Sequences of values of the function $S_n(x)$ for $n=n_0,\ldots,n_1$
can be generated by calling the routine \texttt{scaled\_in\_gamma}
(\S\ref{in-gamma-sequence.f90}). For each $n<0$, there is a unique
positive number $x_n$ such that $S_n(x)=0$, and the algorithm requires
that the machine numbers closest to these values, which we denote by
$\tilde{x}_n$, are provided in the file \texttt{in\_gamma\_precomp.dat},
along with the associated values of $S_n(x)$. If data is available for
$n=-1,\ldots,-M$, then the maximum allowable value for $x$ is
$M-0.18$. This restriction does not apply if $n_0\ge0$.  The file
\texttt{in\_gamma\_precomp.dat} that accompanies the code provides
data for $M=-201$.

The program \texttt{in\_gamma\_test} provides a simple front end which
can be used to test the algorithm. It prompts the user to choose
whether to enter values for $n$ and $x$ manually, or to perform an
exhaustive test using data from the file \texttt{in\_gamma\_test.dat},
which is generated by the Maple program \texttt{in\_gamma\_test.mpl}
(\S\ref{in-gamma-test.mpl}).
%
\section{Generating additional data}
\label{sec:additional}
%%%%%%%%%%%%%%%%%%%%%%
The maximum allowable value for $x$ can be increased by calculating
additional data using the Maple program \texttt{in\_gamma\_precomp.mpl}
(\S\ref{in-gamma-precomp.mpl}).  Likewise, additional testing data can
be generated using the Maple program \texttt{in\_gamma\_test.mpl}
(\S\ref{in-gamma-test.mpl}).  Before using these programs, both
\texttt{binary\_float.mpl} (\S\ref{binary-float.mpl}) and
\texttt{in\_gamma.mpl} (\S\ref{in-gamma.mpl}) must be executed.
All Maple code should be placed in the same directory, and the current 
working directory for Maple should be set to this location. The 
\texttt{currentdir} command can be used to set the current working
directory.
%
\section{Maple code}
\subsection{\texttt{binary\_float.mpl}}
\label{binary-float.mpl}
%%%%%%%%%%%%%%%%%%%%%%%%
This module provides mechanisms for converting Maple's software
decimal floats to and from binary floats, and for manipulating binary
floats within Maple. A binary float is a number of the form
\begin{equation}\label{def:bfloat}
\mathtt{B=sg \times mantis \times 2^{xp+1-mantis\_length}},
\end{equation}
where $\mathtt{sg}=1$ or $\mathtt{-1}$, and $\mathtt{mantis\_length}$ is a
fixed parameter. Inside the module, binary floats are represented as ordered
triples of the form \texttt{(sg,xp,mantis)}.
%
\subsubsection*{Parameters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item $\mathtt{nbits}$ \par
The number of bits used in representing a real number as a binary float.
\item $\mathtt{mantis\_length}$ \par
The length of the mantissa, including the hidden bit.
\item $\mathtt{emax}$ \par
The maximum permitted value for the exponent.
\end{itemize}
For double precision, $\mathtt{nbits=64}$,
$\mathtt{mantis\_length=53}$ and $\mathtt{emax=1023}$ \cite{IEEE754}.
The minimum exponent value is always $\mathtt{1-emax}$ \cite{IEEE754}.
The \texttt{binary\_float} module does not compute subnormal numbers,
and so the smallest positive number is obtained by setting all visible
bits in the significand to zero, and setting $\mathtt{xp=1-emax}$.
%
\subsubsection*{Procedures}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\iitem{nearestBinaryFloat( x )} 
Returns the binary float that is closest to the real number \texttt{x}.  
%
\iitem{toFraction( sg , xp , mantis )} 
Converts the binary float represented by the ordered
triple \texttt{(sg,xp,mantis)} to a fraction using the formula
\eqref{def:bfloat}.
%
\iitem{stepBinaryFloat( sg , xp , mantis, direction )}
If $\mathtt{direction=1}$, this function returns the
smallest binary float that exceeds the number represented by
the ordered triple \texttt{(sg,xp,mantis)}.
If $\mathtt{direction=-1}$, the largest binary float that is smaller
than \texttt{(sg,xp,mantis)} is returned.
%
\iitem{transfer( sg , xp , mantis )} Mimics the effect of the Fortran
function call \texttt{transfer( B , 1\_li )}, where \texttt{B} is a
real number given by \eqref{def:bfloat}, and \texttt{li} is a kind
type parameter that denotes an \texttt{nbits} bit integer.  The
return value is an integer \texttt{t} whose representation as a
sequence of \texttt{nbits} binary bits is identical to that of the
real number \texttt{B}. It is assumed that \texttt{t} is stored in
two's complement format, \texttt{B} is stored in the format specified
by \cite{IEEE754}, and that the endianess for integers and reals is
the same.
\end{itemize}
%
\subsection{\texttt{in\_gamma.mpl}}
\label{in-gamma.mpl}
%%%%%%%%%%%%%%%%%%%%
Provides routines for computing $S_n(x)$
to arbitrary precision and locating its zeros.
%
\subsubsection*{Parameters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item $\mathtt{d\_step}$ \par The number of additional significant digits to include
when it is necessary to increase the accuracy of a computation.
\end{itemize}
%
\subsubsection*{Procedures}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item \verb+S( n , x , d )+ \par  Attempts to compute $S_n(x)$ to $\mathtt{d}$ significant 
                                  decimal digits using \cite[(28)]{Thompson11b}.
\item \verb+xS( n , x , d )+ \par Attempts to compute $\re^xS_n(x)$ to $\mathtt{d}$ significant 
                                  decimal digits using \cite[(12)]{Thompson11b}.
\item \verb+double_calc_S( n , x , d )+ \par Repeatedly computes $S_n(x)$ using \verb+S( n , x , d )+
                 and \verb+xS( n , x , d )+, increasing the number of significant digits used until
                 the two agree to \verb+d+ significant decimal digits.
\item \verb+S_root( n , d )+ \par Returns an approximation to the location of the
  point at which $S_n(x)$ evaluates to zero, accurate to at least $\mathtt{d}$ significant
  decimal digits.
\end{itemize}
%
\subsection{\texttt{in\_gamma\_precomp.mpl}}
\label{in-gamma-precomp.mpl}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This program computes data for use by the Fortran subroutine
\texttt{s\_by\_continuation} (see \S\ref{in-gamma-sequence.f90}), and
outputs this to the file \texttt{in\_gamma\_precomp.dat}, which will
be overwritten if it already exists.  See
\cite[\S7]{Thompson11b} for further details.
%
\subsubsection*{Parameters}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\iitem{nmin} The minimum value of \texttt{n} for which data is
generated. The maximum value is $\mathtt{-1}$.
\end{itemize}
%
\subsection{\texttt{in\_gamma\_test.mpl}}
\label{in-gamma-test.mpl}
%%%%%%%%%%%%%%%%%%%%%%%%%
This program computes $S_n(x)$ for a range of parameter
values. The resulting data is converted to integer form using
\texttt{transfer} (\S\ref{binary-float.mpl}) and output to the file
\texttt{in\_gamma\_test.dat}, which will be overwritten if it already
exists. The data contained in \texttt{in\_gamma\_test.dat} is used by
the Fortran program \texttt{in\_gamma\_test.f90}
(\S\ref{in-gamma-test.f90}).
%
\subsubsection*{Parameters}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\iitem{n0}
The minimum value of \texttt{n} for which data is generated.
\iitem{n1}
The maximum value of \texttt{n} for which data is generated.
\iitem{xmin}
The minimum value of \texttt{x} for which data is generated. 
\iitem{xmax}
The maximum value of \texttt{x} for which data is generated.
\iitem{xsteps}
The number of steps in \texttt{x}.
\end{itemize}

\section{Fortran code}
%%%%%%%%%%%%%%%%%%%%%%
\subsection{\texttt{in\_gamma\_sequence.f90}}
\label{in-gamma-sequence.f90}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This module implements the algorithm described in \cite{Thompson11b}.
The only public entity is the subroutine \texttt{scaled\_in\_gamma},
and it should be noted that the other procedures are intended for
internal use only, and therefore they perform no checks on the
validity of their arguments.
%
\subsubsection*{Parameters}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item \texttt{dp} \par
Kind type parameter for real numbers.  The number of binary
bits used to store a variable of type \texttt{real (dp)} must be equal
to the parameter \texttt{nbits} in the Maple code
\texttt{binary\_float.mpl} (\S\ref{binary-float.mpl}).
%
\item \texttt{li} \par
Kind type parameter for integers. The number of bits used to represent
variables of types \texttt{integer (li)} and \texttt{real (dp)} must
be equal.
\end{itemize}
%
\subsubsection*{Procedures}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item \texttt{subroutine scaled\_in\_gamma( n0 , n1 , x , res )}
  \begin{trivlist}%
  \item \verb+  integer   , intent (in) :: n0 , n1+
  \item \verb+  real (dp) , intent (in) :: x+
  \item \verb+  real (dp) , intent (out) , allocatable , dimension (:) :: res+
  \end{trivlist}
Computes a sequence of values of $S_n(x)$ for $n=n_{0},\ldots,n_{1}$,
for $n_1\ge n_0$ and $x\ge 0$, and returns the result in the
allocatable array \texttt{res}.  If $n_0<0$ , then $x$ must not exceed
$M-0.18$ (see \S\ref{sec:using}).
%
\item \texttt{subroutine error( proc\_name , msg )}
  \begin{trivlist}
  \item \verb+  character (*) , intent (in) :: proc_name , msg+
  \end{trivlist}
Reports that procedure \texttt{proc\_name} has encountered an error, outputs
the message \texttt{msg} and terminates execution.
%
\item \texttt{real (dp) function sm1\_series1( x )} 
  \begin{trivlist}
  \item \verb+  real (dp) , intent (in) :: x+
  \end{trivlist}
Calculates $S_{-1}(x)$ using \cite[(12)]{Thompson11b}, 
under the assumption that $0\le x\le 1$. 
%
\iitem{real (dp) function s\_series2( n , x )}
  \begin{trivlist}
  \item \verb+  integer   , intent (in) :: n+
  \item \verb+  real (dp) , intent (in) :: x+
  \end{trivlist}
Calculates $S_n(x)$ using \cite[(28)]{Thompson11b}.
%
\item \texttt{real (dp) function s\_by\_continuation( n , x )}
  \begin{trivlist}
  \item \verb+  integer   , intent (in) :: n+
  \item \verb+  real (dp) , intent (in) :: x+
  \end{trivlist}
Uses analytic continuation to compute $S_n(x)$, as described in \cite[\S5]{Thompson11b}.
%
\item \texttt{subroutine read\_precomp\_data()} \par
Reads the data contained in the file \texttt{in\_gamma\_precomp.dat} into
memory.
\end{itemize}
%
\subsection{\texttt{in\_gamma\_test.f90}}
\label{in-gamma-test.f90}
%%%%%%%%%%%%%%%%%%%%%%%%%
A simple testing program. See \S\ref{sec:using} for details.
%
\bibliographystyle{unsrt}
\bibliography{specialfunctions}
%
\end{document}
