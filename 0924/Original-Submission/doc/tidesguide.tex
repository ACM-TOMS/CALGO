\documentclass[a4]{report}
\usepackage{fullpage}
\usepackage{ifthen}
\usepackage{indentfirst}
\usepackage{color}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{xspace}

%
%
% Opci—nes
%
%
\newcommand{\rojo}[1]{{\color{red}#1} }
\newcommand{\azul}[1]{{\color{blue}#1} }
\definecolor{gris}{gray}{0.80}

\newboolean{SSATColor}
\setboolean{SSATColor}{false}
%\ProcessOptions
\ifthenelse{\boolean{SSATColor}}{%
%\newcommand{\option}[1]{\rojo{\texttt{#1}}}
\newcommand{\option}[1]{\colorbox{yellow}{\texttt{#1}}}
 }{%
%\newcommand{\option}[1]{\textbf{\texttt{#1}}}
\newcommand{\option}[1]{\colorbox{gris}{\texttt{#1}}}
}



\newcommand{\mathematica}{\textsc{Mathematica}\xspace}
\newcommand{\fortran}{\textsc{Fortran}\xspace}
\newcommand{\tides}{\textsf{TIDES}\xspace}
\newcommand{\mathtides}{\textsf{MathTIDES}\xspace}
\newcommand{\libtides}{\textsf{LibTIDES}\xspace}
\newcommand{\tsmi}{\textsf{TSM Integrator}\xspace}
\newcommand{\minftides}{\textsf{minf-tides}\xspace}
\newcommand{\minctides}{\textsf{minc-tides}\xspace}
\newcommand{\stddptides}{\textsf{dp-tides}\xspace}
\newcommand{\stdmptides}{\textsf{mp-tides}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcounter{imath}
\def\theimath{\arabic{imath}}
\newcommand{\newSesionMath}{\setcounter{imath}{0}}

\newcommand{\inmath}{\stepcounter{imath}\noindent{\sl In[\theimath]:=}}	
\newcommand{\outmath}{{\sl  Out[\theimath]= }}	
\newcommand{\slMath}{{\sl Mathematica}\/ }


\newcommand{\lineacolor}{\par\medskip \hrule \par \medskip}


\newcommand{\comienzolistado}{
\dimen255 = \textwidth
\advance \dimen255 by -2.5ex
\par\medskip\noindent\begin{tabular}{|c|}
\hline
\rule{\dimen255}{0pt} \\[-1ex]
\end{tabular}\par\medskip}

\newcommand{\finlistado}{
\dimen255 = \textwidth
\advance \dimen255 by -2.5ex
\par\medskip\noindent\begin{tabular}{|c|}
\rule{\dimen255}{0pt} \\
\hline
\end{tabular}\par\medskip}


\newenvironment{InputMath}{\footnotesize\inmath\begin{quote}}{
\end{quote}\normalsize}
\newenvironment{OutputMath}{\footnotesize\outmath\begin{quote}}{
\end{quote}\normalsize}

\newcommand{\showMath}[1]{
%\lineacolor
\bigpar
\noindent\includegraphics[scale = 1.2]{#1}
\medpar
%\lineacolor
}

\newcommand{\noshowMath}[1]{
\medskip\lineacolor
\noindent\colorLin Aqu’ se insertar‡ el fichero: \colorBlack {#1}
\lineacolor
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\mimbox}[1]{\ensuremath{#1}}
\newcommand{\Vec}[1]{\mbox{\boldmath$#1$}}
\newcommand{\real}{\mathop\mathrm{I\!R}\nolimits}
\newcommand{\medpar}{\par\medskip}
\newcommand{\Eqref}[1]{(\ref{#1})}
\newcommand{\mfun}[1]{\mathop{\mathrm{ #1}}\nolimits}


\newcommand{\asin}{\mfun{asin}}
\newcommand{\acos}{\mfun{acos}}
\newcommand{\atan}{\mfun{atan}}
\newcommand{\acsc}{\mfun{acsc}}
\newcommand{\asec}{\mfun{asec}}
\newcommand{\acot}{\mfun{acot}}

\newcommand{\csch}{\mfun{csch}}
\newcommand{\sech}{\mfun{sech}}

\newcommand{\asinh}{\mfun{asinh}}
\newcommand{\acosh}{\mfun{acosh}}
\newcommand{\atanh}{\mfun{atanh}}
\newcommand{\acsch}{\mfun{acsch}}
\newcommand{\asech}{\mfun{asech}}
\newcommand{\acoth}{\mfun{acoth}}

\newcommand{\Grande}[1]{\displaystyle #1}
\newcommand{\Frac}[2]{\mimbox{\Grande{\frac{#1}{#2}}}}
\newcommand{\Sum}{\Grande{\sum}}
\newcommand{\Der}[2]{\Frac{d#1}{d#2}}
\newcommand{\Dernth}[3]{\Frac{d^{#3}#1}{d#2^{#3}}}
\newcommand{\Derpar}[2]{\Frac{\partial#1}{\partial#2}}
\newcommand{\Derparnth}[3]{\Frac{\partial^{#3}#1}{\partial#2^{#3}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\title{\tides  user guide\\[2ex]
(\tides: a Taylor series Integrator of Differential EquationS)}
\author{A. Abad, R. Barrio, F. Blesa \& M. Rodriguez\\[2ex]
Grupo de Mec\'anica Espacial\\
Universidad de Zaragoza\\
50008 Zaragoza\\
Spain\\[2ex]
e-mail: tides@unizar.es\\[2ex]
\url{http://gme.unizar.es/software/tides}}
\date{Version 1.2}
%\includeonly{files/intstd}

\begin{document}
\maketitle
\tableofcontents

\chapter{\tides  installation}
%------------------------------------------------------------------------------------------------------
\section{What is \tides ?}

The objective of \tides  (Taylor series Integrator of Differential EquationS) is the integration of  systems of first order differential equations (ODEs),
\begin{equation}\label{ode}
\dot{\Vec{y}} = \Vec{f}(t, \Vec{y}(t); \Vec{p}),\quad \Vec{y}(t_0) =  \Vec{y}_0,\quad \Vec{y}\, (\mathrm{variables}) \in \real^n,\quad \Vec{p} \,(\mathrm{parameters})\in \real^m,
\end{equation}by using the Taylor series method. The Taylor series  method (TSM) is based on the evaluation of the time Taylor series of the variables obtained by an iterative way that use the decomposition of the derivatives by automatic differentiation (AD)methods.\medskip\par

\tides  has two different parts (pieces of software): The \mathematica package \mathtides   and the C library \libtides.\medskip\par



\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{\tides} \\[1.ex]
\hline
\multicolumn{2}{|l|}{Product}& Language \\[1.ex]
\hline
{\mathtides} &  preprocessor  &\mathematica\\[.01ex]
 &   & {\small (version 6.0 or greater) \normalsize}\\[1.ex]
\hline
{\libtides} &  library &  C\\[.01ex]
&  (objects or source code) & \\[1.ex]
\hline
\end{tabular}
\end{center}
\medskip\par
The preprocessor \mathtides  writes, automatically,  the files containing the code with the iterative scheme to obtain the Taylor Series of the variables. These files, together with the library \libtides, form the Taylor Series Method integrator (\tsmi). The multiple precision version of the integrator requires the MPFR library (\url{http://www.mpfr.org/}).\medpar

When you receive \tides uncompress it in your home directory and then make the installation process.\medpar

%------------------------------------------------------------------------------------------------------
\section{How to install and use \mathtides}

To install \mathtides you need to copy
the folder MathTIDES inside a directory that is in the \texttt{\$Path} of \mathematica.
You can do this manually, or by opening the
notebook  \texttt{InstallMathTIDES.nb}  that make automatic the installation process.
Follow the installation instructions of  \texttt{InstallMathTIDES.nb} and when \mathtides  has been installed load the package by writing
\begin{verbatim}
<<MathTIDES`
\end{verbatim}

With \texttt{InstallMathTIDES.nb}  you can also uninstall \mathtides.\medpar

%------------------------------------------------------------------------------------------------------
\section{How to install \libtides}

That follows install \libtides in a Unix system (Macos X and Windows with MinGW included). Let's suppose you have administrator privileges.\medpar

By default  the \libtides library uses GMP and MPFR libraries for the multiple
precision computations, so you need to have both installed. Then, you first need to install GMP and MPFR, in this order,  if your system does not have them.
You can download GMP from http://www.gmplib.org and MPFR from
http://www.mpfr.org. Then you must uncompress them  and run on the terminal the following four  orders
\begin{verbatim}
./configure
make
make check
sudo make install
\end{verbatim}
\noindent  inside each of its directories.\medpar

The complete installation of \libtides follows the same steps: uncompress the files and run on the terminal the previous four orders inside the directory of \tides. The installation process changes if you do not want the complete set of options of \tides or you have not administrator privileges. \medpar

\subsection{Configuring the installation}
To configure the complete installation  type on the terminal
\begin{verbatim}
./configure
\end{verbatim}

Depending on where you installed GMP
and/or MPFR, you may need to specify its installation directories. For example,
if you put GMP in /usr/local, then you need to do the following

\begin{verbatim}
./configure --with-gmp=/usr/local
\end{verbatim}

\noindent If MPFR is also in a non-standard directory, you may have to do the same thing
with it:

\begin{verbatim}
./configure --with-gmp=/usr/local --with-mpfr=/usr/local
\end{verbatim}

If you don't have GMP and/or MPFR installed, or you are not interested in having
multiple precision capacities in your program, you have to pass the following
option to configure:

\begin{verbatim}
./configure --disable-multiple-precision
\end{verbatim}

\noindent This will create the needed Makefiles to compile a reduced version of \texttt{libTIDES.a}
without the MPFR extensions.\medpar


By default, the library is installed in \texttt{/usr/local/lib}. If you
prefer another installation directory, you have to specify it by adding the
prefix option to configure.

\begin{verbatim}
./configure --disable-multiple-precision --prefix=......
\end{verbatim}

After this installation process, you will end with a library containing the
objects needed for the standard and multiple precision TIDES packages.

\subsection{Making the library}
To build the library, type on the terminal:
\begin{verbatim}
make
\end{verbatim}

This will create the complete library or only with  the double precision version of the library depending on the options of \texttt{configure}

\subsection{Checking the library}

Before to install \libtides it is useful to check the created library. To check the build library (run the test files), type:

\begin{verbatim}
make check
\end{verbatim}

The test includes the double precision test and the multiple precision test when available. If you have a \fortran compiler and you plan to use the minimal \fortran version of \tides you can pass \fortran tests by adding one option to the configuration

\begin{verbatim}
./configure --enable-fortran-tests
\end{verbatim}

\noindent If everything is OK, you can install it.


\subsection{Installing and uninstalling the library}

If you have administrator privileges you can install the library by typing on the terminal

\begin{verbatim}
sudo make install
\end{verbatim}

\noindent To uninstall the library just type

\begin{verbatim}
sudo make uninstall
\end{verbatim}

\noindent The word \texttt{sudo} it is not necessary if you are \texttt{root user}.\medpar

If you have not administrator privileges take the library \texttt{libTIDES.a} created on the \tides directory and copy it on your desired directory.\medpar

\subsection{Working with Mac OS X}

Taking into account that  Mac OS X is based on a Unix system  you can install \libtides on Mac OS X by following all the previous steps from the terminal, and using the \texttt{gcc} compiler installed on Mac OS X with the Developer tools.\medpar

If you prefer to use XCode, instead working from the terminal, follow the previous steps except the order \texttt{sudo make install}. Then take the library \texttt{libTIDES.a} and include it in your XCode project. If you work with multiple precision do the same with MPFR and GMP libraries.\medpar

\subsection{Working with Windows}

The installation has been tested with \texttt{MinGW} and \texttt{Msys}. The GMP and MPFR libraries are not installed, so you have to build and install them. They will be installed at \texttt{/usr/local}, but \texttt{Msys} does not have it in the path, so you have to use:

\begin{verbatim}
./configure --with-gmp=/usr/local --with-mpfr=/usr/local
\end{verbatim}



\section{What is new in this version of \tides ? }

In this section we describe the big changes between versions. In every new version we fix several bugs that are not described here. Intermediate numbers of versions, that not appear here, correspod to changes to the internal structure of \tides.\medpar

\subsection{Version 1.0}
\begin{itemize}
\item  Base code.
\end{itemize}

\subsection{Version 1.2}
\begin{itemize}
\item  Added the option \texttt{AddFunction} in \mathtides .
\item Added symbolic manipulation of power series in \mathtides .
\item Expression \texttt{TSMCodeFiles} to generate the code of the Taylor Series Method. In previous version we used the expression \texttt{CodeFiles} instead of the previous one. We maintain both expressions for backward compatibility.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Options in \tides}

In this section we present the different options in the construction of the \tsmi, and the options of the  \tsmi  itself. These options are highlighted with a gray or yellow \option{color box}.
%------------------------------------------------------------------------------------------------------
\section{Four versions of the \tsmi }

With the preprocessor \mathtides  we may write four different versions of the \tsmi. Two minimal (faster)  versions in \fortran (\option{minf-tides}) and C  (\option{minc-tides}) respectively, and two standard (more complete) versions in C, with double (\option{dp-tides}) or arbitrary precision (\option{mp-tides}) respectively.\medskip\par

\begin{center}
\begin{tabular}{|r||l|l|l|}
\hline
Version &Contents & \mathtides  generates & linked with\\[1.ex]
\hline\hline
\minftides &  basic TSM & \fortran  files&\\[1.ex]
\hline
\minctides &  basic TSM &C files&\\[1.ex]
\hline
\stddptides &  complete TSM &C files&\\[.01ex]
& + partial derivatives&&\libtides\\ [.01ex]
\hline
\stdmptides & complete TSM &C files&\\[.01ex]
&+ partial derivatives&&\libtides\\[.01ex]
&+ arbitrary precision&&MPFR library\\[.01ex]
\hline
\end{tabular}
\end{center}
%------------------------------------------------------------------------------------------------------
\subsection{Minimal versions (\minftides, \minctides)}
The minimal versions of the \tsmi  produce a basic Taylor series integrator characterized by the following points
\begin{itemize}
\item In the mathematical expression of  $\Vec{f}$ in \Eqref{ode} may appear the following functions:
\begin{itemize}
\item The usual operators:    $+, -, *, /$
\item  A number(or constant parameter)  power to a variables: $a^x, a>0$.
\item  A variable power to a number(or constant parameter): $x^r, r\in \real$.
\item  A variable power to a variable : $x^y$.
\item  Functions: $\sin, \cos, \tan, \log$.
\end{itemize}
\item They integrate only one differential system on each main problem.
\item They  write the output, dense or not,  into a file or on the screen.
\end{itemize}

\minftides  is based on three \fortran files generated by \mathtides. One file contains the iterative procedure to construct the function $\Vec{f}$. The second file, whose name begins by \texttt{dr\_}, contains the driver (main program) to call to the core of the integrator. The third file, named \texttt{minf\_tides.f}, is always the same and contains the kernel of the integrator.\medskip\par

\minctides  is based on four C files generated by \mathtides. Two files with the same names and extensions \texttt{.c, .h} contains the iterative procedure to construct the function $\Vec{f}$. The third file, whose name begins by \texttt{dr\_}, contains the driver (main program) to call to the core of the integrator. The fourth file, named \texttt{minc\_tides.c}, is always the same and contains the kernel of the integrator.\medskip\par

To integrate the ODE we only need to compile and run these files and  it is not necesary to link the files together with the library \libtides.\medskip\par

%------------------------------------------------------------------------------------------------------
\subsection{Standard versions (\stddptides, \stdmptides)}
The standard versions of the integrator produce a complete Taylor series integrator characterized by the following points
\begin{itemize}
\item In the mathematical expression of  $\Vec{f}$ in \Eqref{ode} may appear the following functions:
\begin{itemize}
\item The usual operators:    $+, -, *, /$
\item  A number(or constant parameter)  power to a variables: $a^x, a>0$.
\item  A variable power to a number(or constant parameter): $x^r, r\in \real$.
\item  A variable power to a variable : $x^y$.
\item  Functions: $\sin, \cos, \tan, \sinh, \cosh, \tanh, \asin, \acos, \atan, \asinh, \acosh, \atanh, \log$.
\end{itemize}
\item They  integrate one or more differential systems on each main problem.
\item They  write the output, dense or not,  into a file or on the screen  and/or a bidimensional array.
\item Simultaneously with the integral of the variables they may obtain :
\begin{itemize}	
\item The integral of functions of the variables.
\item The integral of the partials of the variables with respect to the initial conditions.
\item The integral of the partials of the variables with respect to the parameters.
\item The integral of the partials of functions of the variables with respect to the initial conditions.
\item The integral of the partials of functions of the variables with respect to the parameters.
\end{itemize}
\end{itemize}

Both standard versions are based on three C files: the driver (basic main program) an two files, with the same names and extensions \texttt{.c, .h}, that contains the iterative procedure to construct the function $\Vec{f}$. These files must be compiled and linked with the library \libtides  (kernel of the integrator) to integrate the ODE.\medskip\par

\stdmptides  uses the MPFR library (\textbf{libmpfr.a}) to integrate in multiple precision with any number of precision digits.\medskip\par


%------------------------------------------------------------------------------------------------------
\section{Parameters of the Taylor Series Method (TSM)}\label{tsmop}

Let us consider the initial value problem:

\begin{equation}
\label{ode1} \frac{d\Vec{y}(t)}{dt}= \Vec{f}(t,\Vec{y}(t);\, \Vec{p}),
\qquad \Vec{y}(t_0)=\Vec{y}_0, \qquad t \in \real,\, \Vec{y} \in \real^n,
\, \Vec{p} \in \real^m
\end{equation}
Now, the value of the solution at $t_{i+1} = t_i + h_{i+1}$ (that
is, $\Vec{y}(t_{i+1})$) is approximated from the $N$-th degree
Taylor series of $\Vec{y}(t)$ developed at $t_i$ and evaluated at
$t=t_{i+1}$ (the function $\Vec{f}$ has to be a smooth function, in
this paper we consider that $\Vec{f}$ is analytic).
\begin{equation} \hspace*{-0.6cm} \label{eq:1}
\begin{array}{lcl}
\Vec{y}(t_0)&\stackrel{\rm def}{=}&\Vec{y}_0, \\
\Vec{y}(t_{i+1}) &\simeq & \Vec{y}(t_{i})+
\displaystyle\frac{d\Vec{y}(t_{i})}{dt} \, h_{i+1} +
\displaystyle\frac{1}{2!} \,
\displaystyle\frac{d^2\Vec{y}(t_{i})}{dt^2}\, h_{i+1}^2 + \ldots +
\displaystyle\frac{1}{N!} \, \displaystyle\frac{d^N
\Vec{y}(t_{i})}{dt^N}\, h_{i+1}^N\\[2.ex]
&\simeq&  \Vec{y}_{i}+ \Vec{f}(t_{i},  \Vec{y}_{i}) \, h_{i+1} +
\displaystyle\frac{1}{2!} \, \displaystyle\frac{d\Vec{f}(t_{i},
\Vec{y}_{i})}{dt}\, h_{i+1}^2 + \ldots + \displaystyle\frac{1}{N!}
\, \displaystyle\frac{d^{N-1} \Vec{f}(t_{i},
\Vec{y}_{i})}{dt^{N-1}}\, h_{i+1}^N \,\,\, \stackrel{\rm def}{=}
\,\,\, \Vec{y}_{i+1}.
\end{array}
\end{equation}\medpar

From the formulation of the TSM, the problem is reduced to the determination of the
Taylor coefficients $\{ d^j \Vec{y}(t_{i})/dt^j \}$ by means of the use of automatic differentiation (AD) techniques. \medpar


The TSM presents several peculiarities. One of them is
that it gives directly a dense output in the form of a power series
and therefore we can evaluate the solution at any time just by using
the Horner algorithm. Also, as TSM of degree $N$ are also of order $N$,
the use of TSMs of high degree give us numerical methods of high order.
Therefore, they are very useful for high-precision solution of ODEs.\medpar

In the practical implementation of a numerical method for the
solution of ODEs the use of variable stepsizes is a crucial point
because it permits to automatize the control of the error.   In {\sc TIDES}
we use an absolute error tolerance {\tt tolabs} and a
relative tolerance {\tt tolrel}. With both we construct the error
tolerance
\[ {\tt TOL} =\option{tolabs} +
\max(\|\Vec{y}(t_i)\|,\|\Vec{y}(t_{i-1})\|) \times \option{tolrel} \]
Another crucial point in the TSM is the selection of the order of
the method, that is, $N$. In {\sc TIDES} we adopt a modification of
the \emph{optimal order}. On one
hand, when we use an order that depends only on the requested
tolerance {\tt tolabs}, we adopt the simple formula
\[
 \hat{n} =  \lceil -\ln({\tt tolabs})/2 \rceil+\option{nordinc}
\]
where ${\tt maxord}$ is the maximum order and ${\tt nordinc}$ is an
increment of the order with respect to the asymptotic formula (this
may be adjusted by the user). This is the case on the \stddptides
and \stdmptides  programs, where the complexity of the extended
Taylor series algorithm does not justify to use a more adaptive
algorithm. In the \minftides  and \minctides  programs we
use a slightly more sophisticated formula
\[
\begin{array}{l}
{\tt tolorder}(i) = \min\left({\tt
tolabs}/\min(\|\Vec{y}(t_i)\|,\|\Vec{y}(t_{i-1})\|), {\tt
tolrel}\right),\\[1.2ex]
 \hat{n} = \lceil -\ln({\tt tolorder}(i))/2 \rceil+{\tt nordinc}.
 \end{array}
\]
In both cases we use
\[
N = \max\left(\option{minord}, \hat{n}\right).
\]
\medpar
We use two strategies for selecting the stepsize. The first one is
based on estimating the error just by taking the last term in the
Taylor series (in order to avoid problems with odd/even functions we
take the last two terms different from zero, which avoid also
problems with polynomial solutions). Note that this strategy is also
equivalent to the concept of RK pairs (two RK methods, one of lower
order than the other, which permits to estimate the error). So,
\begin{equation}
\label{step3}
\begin{array}{l}
  \hat{h}_{i+1} =\min \left\{ \, \left(\Frac{\tt
  TOL}{\|\Vec{y}^{[N-1]}(t_{i})\|_\infty}\right)^{1/(N-1)}, \,
   \left(\Frac{\tt TOL}{\|\Vec{y}^{[N]}(t_{i})\|_\infty}\right)^{1/N}
   \,  \right\},\\
   h_{i+1}= \option{fac1} \times \max \left(\min (\option{rmaxstep} \times
   h_{i}, \hat{h}_{i+1} ), \option{rminstep} \times h_{i} \right),
   \end{array}
\end{equation}
with $\Vec{y}^{[N]}$ the normalised derivative $\Vec{y}^{[N]}=\Vec{y}^{(N)}/N!$,
{\tt fac1} a safety factor (we use ${\tt fac1}=0.9$),  and {\tt
rmaxstep} and {\tt rminstep} stands for the maximum and minimum
ratio between the actual stepsize and the previous one.

After this selection of the stepsize we may enter, or not, in a
refinement process which is based on the \option{defect error control}. Note that, ``a priori'', in the TSM there is
no rejected step as
 occurs in any variable-stepsize formulation for Runge-Kutta or
multistep methods because we choose the stepsize once the series are
generated in order to obtain a required precision level. But, in
order to give more guarantee about the stepsize we may analyse the
agreement between the tangent vector to the Taylor polynomial and
the vector field at the end of the step, that is, given the Taylor
approximation of the solution on  the interval $[t_i, \, t_{i+1}] =
[t_i, \, t_i + h_{i+1}]$
\[
\Vec{y}(t) \simeq  \Sum_{k=0}^N \,
\Vec{y}^{[k]}(t_i)\cdot(t-t_i)^k, \qquad \Vec{y}'(t) \simeq
\Sum_{k=1}^N \, k \, \Vec{y}^{[k]}(t_i) \cdot(t-t_i)^{k-1}
\]
then evaluating at the end of the interval $\Vec{y}'_{i+1} \equiv
\sum_{k=1}^N \, k \, \Vec{y}^{[k]}(t_i) \cdot(h_{i+1})^{k-1} $ and
the criteria for rejecting the stepsize is
\begin{equation}
\label{rejec} {\rm if} \quad \| \Vec{y}'_{i+1} - \Vec{f}(t_{i+1},
\, \Vec{y}_{i+1} )\|_\infty > \option{fac2} \times {\tt TOL} \quad
{\rm then} \quad \widetilde{h}_{i+1} = \option{fac3} \cdot h_{i+1},
\end{equation}
where {\tt fac2}  and {\tt fac3} are control factors that reduces the stepsize (we have
taken ${\tt fac2}=10, \,{\tt fac3}=0.8$). It is important to remark that although the
stepsize may be rejected we do not have to recalculate the Taylor
coefficients, we only have to consider the new stepsize and enter
again in the criteria for rejecting the stepsize. Therefore we
cannot say that we reject a complete step, we just reject the
estimation of the stepsize, and so the computational cost is not
very hight (in fact the cost of evaluating $\Vec{y}'_{i+1}$ and
$\Vec{f}(t_{i+1}, \, \Vec{y}_{i+1}))$. This process is done a
maximum of \option{nitermax} times.


%------------------------------------------------------------------------------------------------------
\section{Inputs and Outputs of the \tsmi}

To integrate the ODE \Eqref{ode} the \tsmi  needs the numerical value of the initial conditions of the variables
$\Vec{y}_0$ and the numerical value of the parameters $\Vec{p}$. These values must be passed to the \tsmi  as the main input.\medpar

We may choose between a dense output, i.e. the solution in a list of equidistant (or not) points $\{t_0, t_1, \ldots, t_f\}$, or  a non dense output, i.e. only at the final point $t_f$.\medpar

The basic output of a \tsmi  is the result of the integration, i.e. the value of the variables $\Vec{y}(t)$ in the desired points: $\{t_0, t_1, \ldots, t_f\}$. Likewise, we may add to the output the values of a function $G(\Vec{y}(t))$ and the values  of the partials of  $\Vec{y}(t)$ and  $G(\Vec{y}(t))$ with respect to the initial conditions or the parameters evaluated in the same points $\{t_0, t_1, \ldots, t_f\}$.\medpar

The previous output has the format of a matrix in which each row $i$ represent the solution in $t_i$. The elements of the row are: $t_i, \Vec{y}(t_i)$, and depending on the case, $G(\Vec{y}(t_i))$, $\partial \Vec{y}(t_i)/\partial s_j$, $\partial G(\Vec{y}(t_i))/\partial s_j$, with $s_i$ the elements, in order with respect to we compute the partials.\medpar

The output can be written on a data matrix (only in the standard versions) and into a file or the screen (all versions).\medpar

We may summarise the options of a \tsmi , to obtain the desired solution,  in the following scheme
\begin{itemize}
\item A vector with the \option{initial conditions} $\Vec{y}_0$.
\item A vector with the \option{parameters} $\Vec{p}$.
\item The list $\{t_0, t_1, \ldots, t_f\}$ of \option{integration points} for the dense output or the initial and the final point $\{t_0, t_f\}$ for a non dense output.
\item The way in which we want the output: \option{file}, \option{screen} or \option{data matrix}.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{How to use \mathtides}

%------------------------------------------------------------------------------------------------------
\section{Representing ODEs in \mathtides}

The Taylor Series Method integrates only ODE systems of first order. However, a higher order ODE, with certain conditions,  may be transformed into a first order ODE. Applying the Newton's equations to a potential function or the Hamilton's equations to a Hamiltonian we also obtain first order ODEs.\medpar

In \mathtides  a first order ODE is represented by an expression with head \texttt{FirstOrderODE\$}. However,  the user will declare the ODE with an expression with one of the following heads:
\begin{itemize}
\item \texttt{FirstOrderODE} : declares a first order ODE directly.
\item \texttt{NthOrderODE} : declares a first order ODE from a $k$-th order ODE.
\item \texttt{PotentialToODE} : declares a first order ODE from a potential function $V$.
\item \texttt{HamiltonianToODE} : declares a first order ODE from a hamiltonian function $\mathcal{H}$.
\end{itemize}
The result in all cases is an expression with head \texttt{FirstOrderODE\$} that contains the internal representation in \mathtides  of a first order differential equation.
\subsection{First order differential equations}
A  first order ODE is represented by the equation
\begin{equation}
\Der{\Vec{y}}{t}= \Vec{f}(t, \Vec{y}(t);\, \Vec{p}),\quad \Vec{y}(t_0) =  \Vec{y}_0,\quad\Vec{y} \in \real^n, \quad \Vec{p} \in \real^m,
\end{equation}
where
\begin{itemize}
\item $t$ is the independent variable. It may appear explicitely or not.
\item $\Vec{y} = (y_1, \ldots, y_n)$ is the $n$-dimensional vector of variables ($n > 0$).
\item $\Vec{p} = (p_1, \ldots, p_m)$ is the $m$-dimensional vector of parameters ($m \ge 0$).
\item $\Vec{f} = (f_1, \ldots, f_n)$ is the $n$-dimensional vector of functions (expressions) representing the first order derivatives of the variables.
\end{itemize}

To declare a first order differential equation we will use an expression with  the head \texttt{FirstOrderODE} and  the following arguments and options:

\begin{itemize}
\item \textit{First argument: }
the list of the expressions $\{f_1, \ldots, f_n\}$ of the derivatives of the variables.  The number n of elements of the list must be equal to the number of variables. If n = 1 the argument is not a list.
\item \textit{Second argument: }
the symbol that represents the independent variable $t$. This symbol may appear explicitelly or not in the first argument.
\item \textit{Third argument: }
the list  $\{y_1, \ldots, y_n\}$ of symbols that represent the variables. It has the same number of elements than the first argument. If $n = 1$ the argument is not a list.
\item \textit{Fourth argument: }
the list $\{p_1, \ldots, p_m\}$ of symbols that represent the parameters. If the number of parameters $m$ is equal to 1 the argument is not a list. If there is no parameter ($m = 0$) this argument may be avoided.
\end{itemize}

To illustrate the use of \texttt{FirstOrderODE} let us take two examples. The first one is the system of equations
\begin{equation}\label{sincos}
\Der{x}{t} = y, \quad \Der{y}{t} = -x,
\end{equation}
whose solution for $x(0) = 0,\, y(0) = 1$ gives the functions: $x(t) = \sin t, \, y(t) = \cos t$.
To declare this ODE we will write the expression\medpar
\lineacolor
\inmath
\begin{verbatim}
sincos = FirstOrderODE[{y, -x}, t, {x, y}]
\end{verbatim}
\outmath
\begin{verbatim}
FirstOrderODE$[{y, -x}, t, {x, y}, {}]
\end{verbatim}
%\vspace{-15pt}
\lineacolor
\medpar
The second example is the equation that define, for the initial condition $x(0) =0$,  the elliptic integral of the first kind
\begin{equation}\label{ellF}
\Der{x}{t} = \Frac{1}{\sqrt{1 - k^2 \sin^2 t}},
\end{equation}
\noindent that we declare with the expression\medpar
\lineacolor
\inmath
\begin{verbatim}
ellF = FirstOrderODE[1/Sqrt[1 - k^2 Sin[t]^2], t, x, k]
\end{verbatim}
\outmath
\begin{verbatim}
FirstOrderODE$[{1/Sqrt[1 - k^2 Sin[t]^2]}, t, {x}, {k}]
\end{verbatim}
%\vspace{-15pt}
\lineacolor
\medpar \noindent where the modulus $k$ acts as a parameter.

%------------------------------------------------------------------------------------------------------
\subsection{Higher order differential equations}

Let us consider an ODE system represented by means of the expressions
\begin{equation}\label{node}
\Vec{F}(t, \Vec{y}, \Der{\Vec{y}}{t}, \Dernth{\Vec{y}}{t}{2}, \ldots, \Dernth{\Vec{y}}{t}{k}; \, \Vec{p}) = 0, \qquad \Vec{y}(t_0) =  \Vec{y}_0, \ldots, \Dernth{\Vec{y}}{t}{k}(0) = \Vec{y}_0^{(k)},
\end{equation}
\noindent where $\Vec{F}, \Vec{y} \in \real^n$, and $\Vec{p} \in \real^m$. \medpar
If all the derivatives $y_1^{(k)}, \ldots y_n^{(k)}$ of the greatest order $k$ appears explicitely in \Eqref{node}, then, solving the  system \Eqref{node} in  $y_1^{(k)}, \ldots y_n^{(k)}$, if it is possible, we can transform the $k$-th order ODE into a first order ODE by introducing the derivatives $\Der{\Vec{y}}{t}, \Dernth{\Vec{y}}{t}{2}, \ldots, \Dernth{\Vec{y}}{t}{k-1}$ as  new variables of the system. \medpar

\mathtides  tranforms automatically a $k$-th order ODE into a first order ODE by using an expression with head \texttt{NthOrderODE} and the following arguments
\begin{itemize}
\item \textit{First argument: }
the list of the expressions $\{F_1, \ldots, F_n\}$ that represent the system of equations with a format defined by the following rules:
\begin{itemize}
\item The derivatives of a variable of symbol \texttt{x} must be represented by quotes: \texttt{x,  x', x'', x'''}, ..
\item The equations are represented by means of the symbol ==
\item The number of equations is equal to the number of variables.
\item If the number of variables is equal to one, the first and the third arguments are not lists.
\item In the system it must appear the derivatives of greater order of all the variables.
\end{itemize}
\item \textit{Second argument: }
the symbol that represents the independent variable $t$. This symbol may appear explicitely or not in the first argument.
\item \textit{Third argument: }
the list  $\{y_1, \ldots, y_n\}$ of symbols that represent the variables. It has the same number of elements than the first argument. If $n = 1$ the argument is not a list.
\item \textit{Fourth argument: }
the list $\{p_1, \ldots, p_m\}$ of symbols that represent the parameters. If the number of parameters $m$ is equal to 1 the argument is not a list. If there is no parameter ($m = 0$) this argument may be avoided.
\end{itemize}

A $k$-th order differential equation is transformed into an equivalent system of first order differential equations by extending the number of variables. If a variable have the symbol \texttt{xxx}, the derivatives of this variable are converted in new variables whose symbol has the same beginning \texttt{xxx} and ends by \texttt{\$di}, with \texttt{i} the order of the variable:
\begin{verbatim}
x'   ---> x$d1
x''  ---> x$d2
x''' ---> x$d3
\end{verbatim}
\noindent The order of the variables of the final system of equation is the following:
\begin{enumerate}
\item  Variables (in the same order that before)
\item  First derivatives (mantaining the relative order of the variables)
\item  Second derivatives  (mantaining the relative order of the variables)
\item  ........
\end{enumerate}

To illustrate the use of \texttt{NthOrderODE} let us take two examples. The first one is the harmonic oscillator
\begin{equation}\label{harosc}
\Dernth{x}{t}{2} + \omega x = 0.
\end{equation}\medpar
\noindent To declare this differential equation in \mathtides  we will write the expression\medpar

\lineacolor
\inmath
\begin{verbatim}
oscillator = NthOrderODE[x'' + w x == 0, t, x, w]
\end{verbatim}
\outmath
\begin{verbatim}
FirstOrderODE$[{x$d1, -x w}, t, {x, x$d1}, {w}]
\end{verbatim}
%\vspace{-15pt}
\lineacolor
\medpar
\noindent Let us observe the list of variables \texttt{\{x, x\$d1\}} of the transformed system.\medpar

The second example we present the following third  order ODE

\begin{eqnarray*}\label{ODE3}
x'''-2 y'' + x' = 2 x^2 -y,\\
4 y''' - 2 x '' y'   = 2 x + y^2.
\end{eqnarray*}

In \mathtides  we will write\medpar
\lineacolor
\inmath
\begin{verbatim}
ntheq = NthOrderODE[
          {x''' - 2 y'' + x ' == 2 x^2 - y,
          4 y''' - 2 x '' y' == 2 x + y^2}, t, { x, y}]
\end{verbatim}
\outmath
\begin{verbatim}
FirstOrderODE$[{x$d1, y$d1, x$d2, y$d2, 2 x^2 - x$d1 - y + 2 y$d2,
  1/4 (2 x + y^2 + 2 x$d2 y$d1)}, t, {x, y, x$d1, y$d1, x$d2,
  y$d2}, {}]
  \end{verbatim}
\lineacolor\medpar
Let' s observe again the list of variables \texttt{\{x, y, x\$d1, y\$d1, x\$d2, y\$d2\}} of the transformed system.

%------------------------------------------------------------------------------------------------------
\subsection{From potential to Newton's equations}
Let' s suppose a potential  $V(\Vec{y}, \Vec{p})$ in the variables $\Vec{y} \in \real^n$, and with $m$ parameters $\Vec{p} \in \real^m$, then the Newton's equations $\ddot{\Vec{y}} = - \nabla V(\Vec{y}, \Vec{p})$ will be obtained as a first order ODE by means of the \mathtides  expression of head \texttt{PotentialToODE} that have the following arguments:

\begin{itemize}
\item \textit{First argument: }
the expression of the potential $V$. This expression is never a list.
\item \textit{Second argument: }
the symbol that represents the independent variable $t$. This symbol does not appear in the potential function.
\item \textit{Third argument: }
the list  $\{y_1, \ldots, y_n\}$ of symbols that represent the variables.  If $n = 1$ the argument is not a list.
\item \textit{Fourth argument: }
the list $\{p_1, \ldots, p_m\}$ of symbols that represent the parameters. If the number of parameters $m$ is equal to 1 the argument is not a list. If there is no parameter ($m = 0$) this argument may be avoided.
\end{itemize}
\medpar

As an example let us take the Keplerian problem, in which the potential is given by
\begin{equation}\label{potkep}
V = \Frac{\mu}{\sqrt{x^2+y^2+z^2}},
\end{equation}
\noindent where $\mu$ represents a parameter.

\medpar
\lineacolor
\inmath
\begin{verbatim}
PotentialToODE[-mu/Sqrt[x^2 + y^2 + z^2], t, {x, y, z}, mu]
\end{verbatim}
\outmath
\begin{verbatim}
FirstOrderODE$[{x$d1, y$d1,
  z$d1, -((mu x)/(x^2 + y^2 + z^2)^(3/2)), -((
   mu y)/(x^2 + y^2 + z^2)^(3/2)), -((mu z)/(x^2 + y^2 + z^2)^(
   3/2))}, t, {x, y, z, x$d1, y$d1, z$d1}, {mu}]
   \end{verbatim}
\lineacolor\medpar

\texttt{PotentialToODE} computes the gradient of the potential and transforms the second order Newton's equation into a first order equation duplicating the number of variables \texttt{\{x, y, z, x\$d1, y\$d1, z\$d1\}}.


%------------------------------------------------------------------------------------------------------
\subsection{Hamilton's equations}

Let' s suppose a dynamical system described by a Hamiltonian $\mathcal{H}(t, \Vec{x}, \Vec{X}, \Vec{p})$ where
  t is the independent variable (it may appear explicitely or not),  $\Vec{x}$ is the $n$-dimensional vector of variables, $\Vec{X}$ is the $n$-dimensional vector of associated momenta and $\Vec{p}$ is the $m$-dimensional vector of parameters. Then the first order ODE that represents the dynamical system is given by the Hamilton's equations
\begin{equation}\label{hameq}
\Der{\Vec{x}}{t} = \Derpar{\mathcal{H}}{\Vec{X}}, \quad \Der{\Vec{X}}{t} = -\Derpar{\mathcal{H}}{\Vec{x}}.
\end{equation}
\medpar
With MathTIDES we create the  differential equations directly from the Hamiltonian by using an expression with  the head  \texttt{HamiltonianToODE} and  the following arguments and options:


\begin{itemize}
\item \textit{First argument: }
the expression of the Hamiltonian $\mathcal{H}$. This expression is never a list.
\item \textit{Second argument: }
the symbol that represents the independent variable $t$. This symbol may appear or  not in the hamiltonian.
\item \textit{Third argument: }
the list  $\{x_1, \ldots, x_n, X_1, \ldots X_n\}$ of symbols that represent the variables and momenta.  The length of this list is always an even number. The order of the momenta corresponds with the order of the associated variables.
\item \textit{Fourth argument: }
the list $\{p_1, \ldots, p_m\}$ of symbols that represent the parameters. If the number of parameters $m$ is equal to 1 the argument is not a list. If there is no parameter ($m = 0$) this argument may be avoided.
\end{itemize}
\medpar

As an example we take the planar keplerian problem whose hamiltonian is given by the expression
\begin{equation}\label{kepham}
\mathcal{H} = \Frac{X^2+Y^2}{2} - \Frac{\mu}{\sqrt{x^2+y^2}},
\end{equation}
\noindent where the variables $(x,y)$ represent the position,  the momenta $(X,Y)$ represent the velocity and $\mu$ represents a parameter.\medpar


\medpar
\lineacolor
\inmath
\begin{verbatim}
hamkep = HamiltonianToODE[(X^2 + Y^2) /2 -mu/Sqrt[x^2 + y^2],
   t, {x, y, X, Y}, mu]
\end{verbatim}
\outmath
\begin{verbatim}
FirstOrderODE$[{X,
   Y, -((x mu)/(x^2 + y^2)^(3/2)), -((y mu)/(x^2 + y^2)^(
   3/2))}, t, {x, y, X, Y}, {mu}]
   \end{verbatim}
\lineacolor\medpar

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Creating the \tsmi  with \mathtides}
%------------------------------------------------------------------------------------------------------
\subsection{How to create the \tsmi}
To create the C or \fortran code to use together with  the \tides  library we will use an expression with head \texttt{TSMCodeFiles}\footnote{\texttt{CodeFiles} in version 1.0. We maintain both heads for compatibility.}  and the following arguments:

\begin{itemize}
\item \textit{First argument: }
the first order differential equation.  This is an expression with head \texttt{FirstOrderODE\$} created by one of the previously described expressions.
\item \textit{Second argument: }
an string that represents name of the files.  With this name MathTIDES writes several files (depending on the options) with extension \texttt{.h}, \texttt{.c} or \texttt{.f}
\item \textit{Options: }
the options and their default values(the value the \mathematica takes when the option does not appear)  are :
\end{itemize}
\medpar
\lineacolor
\inmath
\begin{verbatim}
Options[TSMCodeFiles]
\end{verbatim}
\outmath
\begin{verbatim}
{PrecisionDigits -> 16, MinTIDES -> False, Driver -> True,
 OnlyDriver -> False, ParametersValue -> Null,
 InitialConditions -> Null, IntegrationPoints -> Null,
 Output -> False, DataMatrix -> False, Factor1 -> Null,
 Factor2 -> Null, Factor3 -> Null, MaxStepRatio -> Null,
 MinStepRatio -> Null, MaxIterationsNumber -> Null,
 OrderIncrement -> Null, MinOrder -> Null,
 RelativeTolerance -> Null, AbsoluteTolerance -> Null,
 DefectErrorControl -> False, AddFunctions -> {},
 AddPartials -> {}, Optimization -> 1}
 \end{verbatim}
\lineacolor\medpar

%------------------------------------------------------------------------------------------------------
\subsection{Files created with \texttt{TSMCodeFiles}}

Let' s suppose that we write \texttt{"name"} as the second argument of \texttt{TSMCodeFiles}. Then \texttt{TSMCodeFiles} writes the following files:
\begin{itemize}
\item Minimal Version in C (\minctides)
\begin{itemize}
\item A driver (main program) named \texttt{"dr\_name.c"}.
\item  A file \ \texttt{"name.c"} with the differential equation.
\item Two files \texttt{"minc\_tides.h"} and\texttt{ "minc\_tides.c"} with the kernel of the \tsmi.
\item Compiling and running the three files with extension \texttt{.c}  we integrates the differential equation.
\end{itemize}
\item Minimal Version in FORTRAN (\minftides)
\begin{itemize}
\item A driver (main program) named \texttt{"dr\_name.f"}.
\item A file  \texttt{"name.f"} with the differential equation.
\item A file \texttt{ "minf\_tides.f"} with the kernel of the \tsmi.
\item Compiling and running \ the three files with extension \texttt{.f}  we integrates the differential equation.
\end{itemize}
\item Standard versions (\stddptides  and \stdmptides)
\begin{itemize}
\item A driver named \texttt{"dr\_name.c"}.
\item Two files \texttt{"name.h"} and \texttt{"name.c"} with the differential equation.
\item Compiling \texttt{"dr\_name.c"} and \texttt{"name.c"} and linking them with \libtides  (and \textbf{libmpfr.a} with the version \stdmptides) we obtain the executable to integrate the ODE.

\end{itemize}
\end{itemize}
\medpar


The files written by \mathtides  are saved on the default directory of \mathematica (that obtained with \texttt{Directory[]}).\medpar

The user may change the default directory by using \texttt{SetDirectory}.  For instance to change the default directory to the directory where the local \mathematica notebook is, use the expression

\medpar
\lineacolor
\inmath
\begin{verbatim}
SetDirectory[NotebookDirectory[]];
\end{verbatim}
\lineacolor\medpar

The expression \texttt{TSMCodeFiles} shows on the screen the names of the created files and the directories where they had been stored.\medpar

%------------------------------------------------------------------------------------------------------
\subsection{Options to change the version and the files written  by TIDES}

\subsubsection{Option \texttt{MinTIDES}}
\texttt{MinTIDES} is used to create files to use with the minimum versions of \tides. Use
\texttt{MinTIDES -> "C"} to create the C minimum version \minctides  and \texttt{MinTIDES -> "Fortran"} to create the FORTRAN minimum version \minftides.

\subsubsection{Option \texttt{PrecisionDigits}}
By default, when the option \texttt{MinTIDES} is not used an standard version is created.  We choose between \stddptides  or  \stdmptides  by means of the option \texttt{PrecisionDigits}.\medpar
By default this option has the value \texttt{PrecisionDigits->16}. This means that the standard double precision version \stddptides  is created. With a number greater than 16 this option declares the number of digits of precision of the \tsmi  and creates the multiple precision version \stdmptides .

\subsubsection{Option \texttt{Driver}}
By default a driver with the main program is created. With the option \texttt{Driver -> False},
\texttt{TSMCodeFiles} does not write a driver, but it writes the rest of the files.
\subsubsection{Option \texttt{OnlyDriver}}
The option  \texttt{OnlyDriver -> True}
 creates only the driver with the main program, and no other file.


%------------------------------------------------------------------------------------------------------
\subsection{Options to change how to call to the integrator in the driver}

\subsubsection{Option \texttt{InitialConditions}}
With the option  \texttt{InitialConditions -> \{0.1, -2.3, ...\}} we change, on the driver,  the initial value of the vector of variables.  The length of the list must be equal to the number of variables. If we do not use this options stars, \texttt{******}, instead of values appear on the driver.

\subsubsection{Option \texttt{ParametersValue}}
With the option  \texttt{ParametersValue -> \{0.1, -2.3, ...\}} we change, on the driver,  the value of the parameters.  The length of the list must be equal to the number of parameters.
If we do not use this options stars, \texttt{******}, instead of values appear on the driver.

\subsubsection{Option \texttt{IntegrationPoints}}
With this option we declare, on the driver,  the list of points in which the solution is computed
There are several versions of this option:
\begin{itemize}
\item \texttt{IntegrationPoints -> \{t0, t1, ..., tf\}}
\begin{itemize}
\item \texttt{t0} is the initial integration point (where the initial conditions are given). It is a real number.
\item \texttt{t1,...,tf} are the points where we want to compute the solution. They all are real numbers. \texttt{tf} is the final integration point.
\item This option is only valid for the standard versions. In minimal versions you can use \texttt{IntegrationPoints -> \{t0, tf\}}, with the initial and final point, for non-dense output.
\item \texttt{\{t0, t1, ..., tf\}} are in order (crescent or decrescent). They can be non-equidistant points.
\end{itemize}
\item \texttt{IntegrationPoints -> \{t0, tf, Delta[dt]\}}
\begin{itemize}
\item \texttt{t0} is the initial integration point (real number).
\item \texttt{tf}  is the final integration point (real number). It can be lesser or greater than \texttt{t0}.
\item \texttt{dt} is the interval between points in dense output (real number). If \texttt{tf} is lesser than \texttt{t0}, it must be negative.
\item The solution is computed in $\{t_0, t_1, \ldots, t_k\}= $
\texttt{\{t0, t0+dt, t0+2*dt, ... t0+k*dt\}}, with \texttt{k} such us  \texttt{t0+k*dt <= tf < t0+(k+1)*dt}. Not always the last point of the dense output coincides with the end integration point \texttt{tf}.
\end{itemize}
\item \texttt{IntegrationPoints -> \{t0, tf, Points[k]\}}
\begin{itemize}
\item \texttt{t0} is the initial integration point (real number).
\item \texttt{tf}  is the final integration point (real number). It can be lesser or greater than \texttt{t0}.
\item \texttt{k} is an integer with  the number of equidistant points in which the solution is computed. \texttt{dt}  for dense output is equal to \texttt{(tf-t0)/k}.
\item The solution is computed in $\{t_0, t_1, \ldots, t_k\}= $
\texttt{\{t0, t0+dt, t0+2*dt, ...,  t0+k*dt = tf\}}.
\end{itemize}
\item \texttt{IntegrationPoints -> \{t0, Delta[dt], Points[k]\}}
\begin{itemize}
\item \texttt{t0} is the initial integration point (real number).
\item \texttt{dt} is the interval between points in dense output (real number). It can be positive or negative.
\item \texttt{k} is an integer with  the number of equidistant points in which the solution is computed.
\item The solution is computed in $\{t_0, t_1, \ldots, t_k\}= $
\texttt{\{t0, t0+dt, t0+2*dt, ...,  t0+k*dt\}}.
\end{itemize}
\end{itemize}



\subsubsection{Options \texttt{RelativeTolerance} and  \texttt{AbsoluteTolerance}}
Declares the value of the tolerances in the application of  the method.
\begin{verbatim}
      RelativeTolerance -> rtol
      AbsoluteTolerance-> atol	
\end{verbatim}
\texttt{rtol} and \texttt{atol} are real numbers.
The default value is $10^{-p}$, where $p$ is the value of the option \texttt{PrecisionDigits} for both tolerances. If only one tolerance is declared both are taken equals.
%------------------------------------------------------------------------------------------------------
\subsection{Options to change the ODE}


\subsubsection{Option \texttt{Optimization} (optimizing the linked functions)}
With the default option \texttt{Optimization-->1}, \mathtides  uses the function \texttt{Simplify} to simplify the linked function used to apply the Taylor method to the ODE. With \texttt{Optimization-->2} \mathtides  tries to simplify with
\texttt{FullSimplify}, and with \texttt{Optimization-->0} no simplification is made. The option \texttt{Optimization-->2} not ensure a drastic simplification, with respect the default but, sometimes, it takes a very long time of computation.

\subsubsection{Option \texttt{AddFunctions} (adding functions to the differential equations)}
The integration of the system \Eqref{ode} gives the function
$\Vec{y}(t)$, i.e. the evolution over the time of the variables. Sometimes, we are interested  in the evolution, along the solution of the system, of a dynamical variable defined by a function $G(t, \Vec{y}, \Vec{p})$, i.e. the function $G(t) = G(t, \Vec{y}(t), \Vec{p})$. Writing the option \texttt{AddFunctions-> \{G1, G2,...\}} we redefine the differential equation to extend the application of the Taylor method to find the time evolution of the functions G1,G2, ...\medpar

For instance, let's suppose we want to check the value of the tangent, together with the sinus and cosinus in the system \Eqref{sincos}, then
\medpar
\lineacolor
\inmath
\begin{verbatim}
sincos =  FirstOrderODE[{y, -x}, t, {x, y}];
\end{verbatim}
\inmath
\begin{verbatim}
TSMCodeFiles[sincos, "sincosf", AddFunctions -> {x/y} ];
\end{verbatim}
\lineacolor\medpar
In the example of the hamiltonian of the planar keplerian problem we may check how the energy maintain its value over the time, to do that we check the evolution of the Hamiltonian
\medpar
\lineacolor
\inmath
\begin{verbatim}
kepHam = (v^2 /2 - mu/r)/.{r -> Sqrt[x^2 + y^2], v -> Sqrt[X^2 + Y^2]};
\end{verbatim}
\inmath
\begin{verbatim}
hamkepener = HamiltonianToODE[kepHam, t, {x, y, X, Y}, mu];
\end{verbatim}
\inmath
\begin{verbatim}
TSMCodeFiles[hamkepener, "hamkepener",  AddFunctions -> {kepHam}];
\end{verbatim}
\lineacolor\medpar

\subsubsection{Option \texttt{AddPartials} (adding partial derivatives to the differential equations)}

Together with the time evolution of the variables and functions we may compute the evolution of the partials of the variables (and partials of the functions) with respect to the initial conditions and with respect to to the parameters. The option to do that has four possible  formats
\begin{itemize}
\item \texttt{AddPartials-> \{\{u,v,..\}, s\} }
\item \texttt{AddPartials-> \{\{u,v,..\}, s, Until\}}
\item \texttt{AddPartials-> \{\{u,v,..\}, s, Only\}}
\item \texttt{AddPartials-> \{\{u,v,..\}, listOfOrders\}}
\end{itemize}

The list \texttt{\{u,v,...\}} represents the symbols of the elements with respect to we want the derivatives.
The symbols of this list are symbols of the variables or symbols of the parameters.
If the symbol corresponds to a variable the partials with respect to the initial value of this variables computed.
If the symbol correspond to a parameter the partial with respect to the parameter is computed.\medpar

An integer \texttt{s} represents the total maximum order  of the partials to compute.\medpar
If no third argument appear (or the third argument is the symbol \texttt{Until}) , all the partials until total order  \texttt{s} are computed. If the third argument is the symbol \texttt{Only}, only the partial derivatives of total order \texttt{s} are computed.\medpar

If the second argument, \texttt{listOfOrders}, is a list, only the partials of the orders in the list are computed. \medpar

Let's assume a differential equation with three variables $x,y,z$ and two parameters $a,b$. Then
\begin{itemize}
\item \texttt{AddPartials-> \{\{y,a\}, 2\} } computes
\[
\Derpar{x}{y_0}, \Derpar{x}{a},
\Derpar{y}{y_0}, \Derpar{y}{a},
\Derpar{z}{y_0}, \Derpar{z}{a},
\Derparnth{x}{y_0}{2}, \Derparnth{x}{a}{2}, \Frac{\partial^2 x}{\partial y_0 \partial a},
\Derparnth{y}{y_0}{2}, \Derparnth{y}{a}{2}, \Frac{\partial^2 y}{\partial y_0 \partial a},
\Derparnth{z}{y_0}{2}, \Derparnth{z}{a}{2}, \Frac{\partial^2 z}{\partial y_0 \partial a}.
\]
\item \texttt{AddPartials-> \{\{y,a\}, 2, Only\} } computes
\[
\Derparnth{x}{y_0}{2}, \Derparnth{x}{a}{2}, \Frac{\partial^2 x}{\partial y_0 \partial a},
\Derparnth{y}{y_0}{2}, \Derparnth{y}{a}{2}, \Frac{\partial^2 y}{\partial y_0 \partial a},
\Derparnth{z}{y_0}{2}, \Derparnth{z}{a}{2}, \Frac{\partial^2 z}{\partial y_0 \partial a}.
\]
\item \texttt{AddPartials-> \{\{y,a\}, \{\{2,3\},\{1,2\}\}\} } computes
\[
\Frac{\partial^5 x}{\partial y_0^2 \partial a^3}, \Frac{\partial^3 x}{\partial y_0 \partial a^2},
\Frac{\partial^5 y}{\partial y_0^2 \partial a^3}, \Frac{\partial^3 y}{\partial y_0 \partial a^2},
\Frac{\partial^5 z}{\partial y_0^2 \partial a^3}, \Frac{\partial^3 z}{\partial y_0 \partial a^2}.
\]
\end{itemize}
\medpar
If a function G is added with the option \texttt{AddFunction}, the partials of this function with respect to the corresponding variables are added to the computation.
%------------------------------------------------------------------------------------------------------
\subsection{Options to change the output of the integrator in the driver}
\subsubsection{Option \texttt{Output}}
This options declares where the solution (dense or not) is written. There are two posiblilities
\begin{verbatim}
      Output -> Screen
      Output -> "file"	
\end{verbatim}
In the first case the solution is written on the screen, in the second case into a file named \texttt{file}.
By default no output is written.\medpar
In the minimal versions if the output is not sending into the screen the solution in \texttt{t0} and the solution in \texttt{tf} is written on the screen.
\subsubsection{Option \texttt{DataMatrix}}
Option only for standard versions. By default \texttt{DataMatrix->False}, but there are two other posibilities
\begin{verbatim}
      DataMatrix -> True
      DataMatrix -> "nameDM"
\end{verbatim}

\texttt{DataMatrix} declares a bidimensional array where the solution is stored. The name is \texttt{nameDM} in the second case or the name of the file joined to \texttt{"\_DataMatrix"} in the first case.
\medpar
Each row corresponds to the solution in the point $t_i$ of the integration interval. The first row represents the initial point. The last row represents the final point.\medpar
The number of columns is sufficient to store $t_i$,  the  variables in $t_i$, the functions in $t_i$, the partial derivatives of variables and functions in $t_i$.%------------------------------------------------------------------------------------------------------
\subsection{Options to change the parameters of the \tsmi  in the driver}\label{tsmopcf}
The following options change the parameters of the numerical integrator. The default values are the best election for the most general cases and usually it is not necessary to change them

\subsubsection{Options \texttt{Factor1}, \texttt{Factor2} and \texttt{Factor3}}
\texttt{Factor1}, \texttt{Factor2} and \texttt{Factor3} change the parameters \texttt{fac1}, \texttt{fac2} and \texttt{fac3} respectively.

\subsubsection{Option \texttt{MaxStepRatio} and \texttt{MinStepRatio}}
\texttt{MaxStepRatio} and \texttt{MinStepRatio} change the parameters \texttt{rmaxstep} and \texttt{rminstep} respectively.

\subsubsection{Option \texttt{MinOrder} }
\texttt{MinOrder}   changes the parameter \texttt{minord}.

\subsubsection{Option \texttt{MaxIterationsNumber}}
\texttt{MaxIterationsNumber} changes the parameter  \texttt{nitermax}.

\subsubsection{Option \texttt{OrderIncrement}}
\texttt{OrderIncrement} changes the parameter  \texttt{nordinc}.

\subsubsection{Option \texttt{DefectErrorControl}}
\texttt{DefectErrorControl} declares if the \tsmi  uses the defect error control or not.
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{How to  use the Minimal versions of the \tsmi}
Usually the drivers (main programs) generated with \texttt{TSMCodeFiles} are sufficient to integrate one ODE. In this chapter we will learn how to run the minimal versions of the \tsmi, from the driver,  and we will explain the driver and the prototypes of the main functions of the kernel of the \tsmi  in order to change the driver or to write another different one.

As an example let's suppose again the differential equation that defines the sinus and cosinus functions

\begin{equation}\label{sincos2}
\Der{x}{t} = y, \quad \Der{y}{t} = -x, \quad x(0) = 0,\, y(0) = 1.
\end{equation}

\noindent With \mathtides  we declare the differential equation \texttt{sincos}\medpar
\lineacolor
\inmath
\begin{verbatim}
sincos = FirstOrderODE[{y, -x}, t, {x, y}];
\end{verbatim}
\lineacolor
\medpar

%----------------------------------------------------------------------------------------

\section{\minftides  version}
To integrate the equation \Eqref{sincos2} between 0 and $2 \pi$ and write a dense output solution (intervals of length equal to  $1.0$) on the screen, we create the driver by  writing, in \mathtides, the expression\medpar

\lineacolor
\inmath
\begin{verbatim}
TSMCodeFiles[sincos, "sincosf", InitialConditions -> {0, 1},
     MinTIDES -> "Fortran", IntegrationPoints -> {0. , 2 Pi, Delta[1.]},
     Output ->  Screen]
\end{verbatim}
\outmath
\begin{verbatim}
Files "dr_sincosf.f", "sincosf.f" and "minc_tides.f"
       written on directory ........
\end{verbatim}
\lineacolor
\medpar

\noindent Finally write in your terminal the following command lines

\begin{Verbatim}[frame = lines]
$gfortran -O2 dr_sincosf.f sincosf.f minf_tides.f -o sincosf
$./sincosf
\end{Verbatim}

\noindent and you will obtain on the screen

\begin{Verbatim}[frame = lines]
   0.0000000000000000E+00   0.0000000000000000E+00   0.1000000000000000E+01
   0.1000000000000000E+01   0.8414709848078965E+00   0.5403023058681398E+00
   0.2000000000000000E+01   0.9092974268256817E+00  -0.4161468365471426E+00
   0.3000000000000000E+01   0.1411200080598671E+00  -0.9899924966004455E+00
   0.4000000000000000E+01  -0.7568024953079282E+00  -0.6536436208636121E+00
   0.5000000000000000E+01  -0.9589242746631387E+00   0.2836621854632264E+00
   0.6000000000000000E+01  -0.2794154981989259E+00   0.9601702866503660E+00
\end{Verbatim}

If you change the option \texttt{Output ->  Screen} by the new one \texttt{Output ->  "dataf"}, a file  named \texttt{dataf} with the previous numbers is created an the program shows on the screen the values at the variables in the first and last points

\begin{Verbatim}[frame = lines]
 t =   0.0000000000000000E+00    X =   0.0000000000000000E+00   0.1000000000000000E+01
 t =   0.6283185307179586E+01    X =  -0.3330669073875470E-15   0.1000000000000000E+01
\end{Verbatim}

Let's note that the dense output (on screen or into a file) ends at the integration point 6.0 instead of the final point  $2 \pi$, but the screen non-dense output writes the value at the end point of integration. The standard version works in a different way.\medpar

Now let's see the driver in order to understand how to change it or how to create a new one:

\begin{Verbatim}[frame = lines, numbers = left]
C-------------------------------------------------------------------------------
C     Driver file of the MinF_TIDES program
C
C     This file has been created by MathTIDES. December 4, 2009, 13:08
C     Copyright (C) 2010 GME-Unizar
C     Authors: Abad, A., Barrio, R., Blesa, F. and Rodriguez, M.
C-------------------------------------------------------------------------------
      Program  dr_sincosf
      IMPLICIT NONE
      INTEGER  i,j
C --- NUMBER OF VARIABLES AND PARAMETERS
      INTEGER  NVAR,NPAR
      PARAMETER  (NVAR = 2)
      PARAMETER  (NPAR = 1)
C --- TOLERANCES
      REAL*8 tolabs,tolrel
C --- TIMES: INITIAL, FINAL, INCREMENT
      REAL*8 tini, tend, dt
C --- VARIABLES AND PARAMETERS
      REAL*8 v(NVAR)
      REAL*8 p(NPAR)
C --- FILE NAME AND UNIT NUMBER OF DENSE OUTPUT
      CHARACTER fname*20
      INTEGER   FL
C --- OPTIONS
      LOGICAL dense_output, defect_error_control
C --- COUNTERS
      INTEGER accepted_steps, rejected_steps
C --- CONSTANTS OF THE METHOD (safety factors, maximum order, ...)
      REAL*8 fac1,fac2,fac3,rminstep,rmaxstep
      INTEGER nitermax,nordinc,minord,maxord
C --- GLOBALS
      COMMON /OPT/ dense_output, defect_error_control
      COMMON /ARS/ accepted_steps, rejected_steps
      COMMON /CONSTMET1/ fac1,fac2,fac3,rminstep,rmaxstep
      COMMON /CONSTMET2/ nitermax,nordinc,minord,maxord
      COMMON /FILE/ FL

C-------------------------------------------------------------------------------
C-------------------------------------------------------------------------------
C     INITIAL CONDITIONS,  INTEGRATION TIMES, TOLERANCES
C     Change ***** by numerical values if it is necesary
C-------------------------------------------------------------------------------
C-------------------------------------------------------------------------------

C --- INITIAL VALUES
      v(1) = 0d0
      v(2) = 0.1d1

C --- INITIAL INTEGRATION POINT
      tini = 0.d0

C --- ENDPOINT OF INTEGRATION
      tend = 6.283185307179586d0

C --- DELTA t FOR DENSE OUTPUT
      dt   = 1.d0

C --- REQUIRED TOLERANCES
      tolrel = 1.d-16
      tolabs = 1.d-16

C-------------------------------------------------------------------------------
C-------------------------------------------------------------------------------
C       DENSE OUTPUT (file , screen or none)
C-------------------------------------------------------------------------------
C-------------------------------------------------------------------------------

      FL = 6


C-------------------------------------------------------------------------------
C-------------------------------------------------------------------------------
C       CALL THE INTEGRATOR
C-------------------------------------------------------------------------------
C-------------------------------------------------------------------------------

      CALL minf_tides(v,NVAR,p,NPAR,tini,tend,dt,
     &   tolrel,tolabs,fname)

      STOP
      END
\end{Verbatim}
\medpar

From lines 9 to 37 all the variables needed on the integration process are declared. There are parameters needful on the driver to call the integration routine \texttt{minf\_tides}, and common parameters that contains the default options of the integration method. \medpar

From line 46 to line 61 the value of the variables, parameters, interval of integration and tolerances are declared. All of them are arguments of the integration routine \texttt{minf\_tides}.\medpar

Line 69 contains a definition to the  output unit, in this case the screen. If you change the option \texttt{Output ->  Screen} by the new one \texttt{Output ->  "dataf"} the lines 69-70 are substituted by
\begin{Verbatim}[frame = lines]
      FL = 72
      OPEN (UNIT = FL, FILE = 'dataf', STATUS = 'UNKNOWN')
\end{Verbatim}

The integration with  \minftides  is made by calling the following subroutine

\begin{Verbatim}[frame = lines]

      SUBROUTINE minf_tides(v,numvar,p,numpar,tini,tend,dt, tolrel,tolabs)

      INTEGER numvar,numpar
      REAL*8  v(numvar),p(numpar)
      REAL*8  tini,tend,dt,tolrel,tolabs

\end{Verbatim}

\noindent where the input arguments are the following
\begin{enumerate}
\item \texttt{v} is a real vector of dimension \texttt{numvar}. On input it contains the initial value of the variables (value of the variables in \texttt{tini}). On output it stores the value of the variables in the final time \texttt{tend}.
\item \texttt{numvar} is an integer value with the number of variables.
\item \texttt{p} is a real vector of dimension \texttt{numpar} (1 if  \texttt{numpar} = 0) with  the value of the parameters.
\item \texttt{numpar} is an integer value with the number of parameters.
\item \texttt{tini} is a real number with the initial integration point.
\item \texttt{tend} is a real number with the final  integration point. It can be lesser or greater than \texttt{tini}
\item \texttt{dt} is a real (negative if \texttt{tend < tini}) number with the increment in time where the dense output is computed. The dense output is computed in: \texttt{\{tini, tini+dt, tini+2*dt, ...tini+k*dt\}}, the last point verifies \texttt{tini+k*dt <= tend <tini+(k+1)*dt}. Not always the last point of the dense output coincides with the end integration point \texttt{tend}.
\item \texttt{tolrel} is a real number with the relative tolerance.
\item \texttt{tolabs} is a real number with the absolute tolerance.
\end{enumerate}

The only output of this routine is the value of the variables \texttt{v} in the final time \texttt{tend}.


%----------------------------------------------------------------------------------------
%----------------------------------------------------------------------------------------
\section{\minctides  version}
To integrate the equation \Eqref{sincos2} between 0 and $2 \pi$ and write the a dense output solution (intervals of length equal to  $1.$) on the screen, we create the driver by  writing, in \mathtides  the expression\lineacolor
\inmath
\begin{verbatim}
TSMCodeFiles[sincos, "sincosc", InitialConditions -> {0, 1},
    MinTIDES -> "C", IntegrationPoints -> {0. , 2 Pi, Delta[1.]},
    Output -> Screen]
\end{verbatim}
\outmath
\begin{verbatim}
Files "dr_sincosc.c", "sincosc.c" , "sincosc.h" , "minc_tides.c" and "minc_tides.h"
     written on directory ........
\end{verbatim}
\lineacolor
\medpar

\noindent Finally write in your terminal the following command lines

\begin{Verbatim}[frame = lines]
$gcc -O2 dr_sincosc.c sincos.c minc_tides.c -o sincosc -lm
$./sincosc
\end{Verbatim}

\noindent and you will obtain on the screen the same solution that in the \minftides  version.\medpar

Like in the \minftides  version if you change the option \texttt{Output ->  Screen} by the new one \texttt{Output ->  "datac"}, a file  named \texttt{datac} with the previous numbers is created an the program shows on the screen the values of the variables at the first and last points. Let's note that the dense output (on screen or into a file) ends at the integration point 6.0 instead of the final point  $2 \pi$, but the screen non-dense output writes the value at the end point of integration. The standard version works in a different way.\medpar

Now let's see the driver in order to understand how to change it or how to create a new one:

\begin{Verbatim}[frame = lines, numbers = left]
/****************************************************************************
	Driver file of the MinC_TIDES program

	This file has been created by MathTIDES. December 4, 2009, 17:44
	TIDES. Copyright (C) 2010 GME-Unizar
	Authors: Abad, A., Barrio, R., Blesa,F. and Rodriguez, M.
*****************************************************************************/

#include "minc_tides.h"

int main() {

	int  i, VARS, PARS;
	VARS = 2;
	PARS = 1;
	double tolrel, tolabs, tini, tend, dt;
	double v[VARS], p[PARS];
	extern FILE     *fd;



/************************************************************/
/************************************************************/
/*      INITIAL CONDITIONS, INTEGRATION TIMES, TOLERANCES    */
/*      Change *****  by numerical values if it is necesary */
/************************************************************/
/************************************************************/

/* --- INITIAL VALUES --- */
	v[0] = 0e0 ;
	v[1] = 0.1e1 ;

/* --- INITIAL INTEGRATION POINT --- */
	tini = 0.e0 ;

/* --- ENDPOINT OF INTEGRATION   --- */
	tend = 6.283185307179586e0 ;

/* --- DELTA t FOR DENSE OUTPUT  --- */
	dt   = 1.e0 ;

/* --- REQUIRED TOLERANCES --- */
	tolrel = 1.e-16 ;
	tolabs = 1.e-16 ;

/***********************************************************/
/***********************************************************/
/*             DENSE OUTPUT (file, screen or none)          */
/***********************************************************/
/***********************************************************/

	fd = stdout;

/***********************************************************/
/***********************************************************/
/*       CALL THE INTEGRATOR                               */
/***********************************************************/
/***********************************************************/

	minc_tides(v,VARS,p,PARS,tini,tend,dt,tolrel,tolabs);


	return 0;
}
\end{Verbatim}


From lines 13 to 18 all the variables needed on the integration process are declared. There are parameters needful on the driver to call the integration routine \texttt{minc\_tides}.  The global parameters that contains the default options of the integration method are declared only when they are changed with options of \texttt{TSMCodeFiles}.\medpar

From line 29 to line 44 the value of the variables, parameters, interval of integration and tolerances are declared. All of them are arguments of the integration routine \texttt{minc\_tides}.\medpar

Line 52 contains a declaration of the output file, in this case the screen (\texttt{stdout}). If you change the option \texttt{Output ->  Screen} by the new one \texttt{Output ->  "datac"} the line  52  is substituted by
\begin{Verbatim}[frame = lines]

	fd = fopen("datac", "w");
	
\end{Verbatim}

 The integration with  \minctides  is made by calling the following function

\begin{Verbatim}[frame = lines]

void  minc_tides(double *var,  int nvar,  double *par,  int npar,
          double tini, double tend, double dt, double tol_rel, double tol_abs);

\end{Verbatim}

\noindent where the input arguments are the following
\begin{enumerate}
\item \texttt{v} is a pointer to an array of dimension \texttt{numvar}. On input the array contains the initial value of the variables (value of the variables in \texttt{tini}). On output it stores the value of the variables in the final time \texttt{tend}.
\item \texttt{numvar} is an integer value with the number of variables.
\item \texttt{p} is a pointer to an array of dimension \texttt{numpar} (1 if  \texttt{numpar} = 0) with  the value of the parameters.
\item \texttt{numpar} is an integer value with the number of parameters.
\item \texttt{tini} is a \texttt{double} with the initial integration point.
\item \texttt{tend} is a \texttt{double} with the final  integration point. It can be lesser or greater than \texttt{tini} .
\item \texttt{dt} is a \texttt{double} (negative if \texttt{tend < tini}) with the increment in time where the dense output is computed. The dense output is computed in: \texttt{\{tini, tini+dt, tini+2*dt, ...tini+k*dt\}}, the last point verifies \texttt{tini+k*dt <= tend <tini+(k+1)*dt}. Not always the last point of the dense output coincides with the end integration point \texttt{tend}.
\item \texttt{tolrel} is a \texttt{double} with the relative tolerance.
\item \texttt{tolabs} is a \texttt{double} with the absolute tolerance.
\end{enumerate}

The only output of this routine is the value of the variables \texttt{v} in the final time \texttt{tend}.

%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{The library \libtides. Standard versions of the \tsmi.}

The kernel of the standard versions of \tides  is contained into the C-library \libtides. This library will be described in this chapter.\medpar

\section{Compiling and running the code. }\label{cri}
Before to describe \libtides  let's remember that,  to use it, we need to use previously \mathtides  in order to create the linked functions with the iterations needful to obtain the Taylor series.  When we call \texttt{TSMCodeFiles} we pass a string as a second argument. This string represents the name associated with all the files created by \texttt{TSMCodeFiles}.
Let's suppose, along this chapter, that we use the name \texttt{"intfunct"}, as the second argument, then it writes two files named \texttt{intfunct.c}, \texttt{intfunct.h} and, if we want,  a third file with the driver  named \texttt{dr\_intfunct.c}.\medpar

The file \texttt{intfunct.c} contains a function named \texttt{intfunct} that contains the iterations needful to create the Taylor Series solution. This function represents the differential equation and it is passed as the first argument in every version of the integrator.\medpar

To compile and run this code, to integrate the differential equation, write on the command line:

\begin{verbatim}
#gcc -O2 dr_intfunct.c intfunct.c  -o intfunct  -lTIDES -lm
#./intfunct
\end{verbatim}
\noindent for the double precision version, and
\begin{verbatim}
#gcc -O2 dr_intfunct.c intfunct.c  -o intfunct  -ltides -lmpfr -lgmp -lm
#./intfunct
\end{verbatim}
\noindent for the multiple precision version. Let's note that to link the MPFR library we need to include the GMP library\footnote{Following the MPFR instruction you must call \texttt{-lmpfr} before \texttt{-lgmp}. }.\medpar

If you write your own driver don't forget to include the header file \texttt{intfunct.h} that include all the \tides  necessary headers to integrate the problem.
\begin{verbatim}
#include "intfunct.h"
\end{verbatim}




\section{The double precision integrator}\label{dpi}

The principal function of the double precision standard version of the integrator is the following:
\begin{Verbatim}[frame = lines]

void dp_tides(LinkedFunction fcn,
	int nvar, int npar, int nfun,
	double x[], double p[],
	double lt[], int ntes, 	
	double tolrel, double tolabs,
	double **mat, FILE* fileout);

\end{Verbatim}

The arguments of both functions are all equal except those arguments relative to the integration points.
\begin{itemize}
\item \textsl{The linked function:} \texttt{fcn} is a pointer to the function that contains the iterations needful to create the Taylor Series solution. It will we described in Section \ref{lkfi}
\item \textsl{The dimensions of the problem:} \texttt{nvar, npar, nfun} are three integer numbers that represent, respectively, the number of variables, the number of parameters and the number of extra functions to evaluate.
\item \textsl{Initial value of the variables:} \texttt{x} is a pointer to a \texttt{double} that represents an array with \texttt{nvar} elements. On input it has the value of the initial conditions (value of the variables at the initial point). On output it has the value of the variables at the final integration point.

\item \textsl{Value of the parameters:} \texttt{p} is a pointer to a \texttt{double}, or an array with \texttt{npar} elements. It has the value of the parameters.

\item \textsl{Integration points: } The integration points are represented by two arguments \texttt{lt} and \texttt{ntes}.  \texttt{lt} is a pointer to a \texttt{double}  that represents an array of dimension \texttt{ntes} that contains the list $\{t_0, \ldots,t_k\}$ of points where the solution will be computed. These points can be non-equidistants. The list must be ordered, but the order can be crescent or decrescent (for backward integration). \par

\item \textsl{Tolerances: } \texttt{tolrel, tolabs} are two \texttt{double} variables with the relative and absolute tolerance of the method.

\item \textsl{Output of the integrator: } \texttt{mat} is a double pointer to a \texttt{double} that represent a data matrix where the output will be stored. \texttt{fileout}  is a pointer to a \texttt{File} where the output will be written on. More details about these outputs appear on the Section \ref{outi}.
\end{itemize}

\section{The multiple precision integrator}\label{mpi}

To handle real numbers in the multiple precision version we substitute the type \texttt{double} by the type \texttt{mpfr\_t}, defined in the MPFR library. The variables of this type must be declared and  initialized before giving them numerical values.
 \medpar
 When \texttt{TSMCodeFiles} is used to create a multiple precision integrator the number of precision digits is declared. This fact permits to simplify the process of initialize and assign values of the \texttt{mpfr\_t} by using  modified\footnote{modified with respect to the standard use of \texttt{mpfr}} functions. For instance to use a variable named \texttt{tend} with the value of $\pi$, and  40 precision digits we write
\begin{verbatim}
mpfr_t  tend;
mpfrts_init(& tend);
mpfrts_set_str(&tend, "3.141592653589793238462643383279502884197");
\end{verbatim}
\noindent The values of the variables are assigned by means of string of the desired length.\medpar

When we use the \stdmptides version it is important to know that \mathtides tries to transform all the (real) numbers of the process  to the required precision. However,  sometimes,  we can find real numbers initialized only with double precision that invalidates the multiple precision process. In order to avoid these problems we must take care in the construction of the ODE and follow the next rule: never use real numbers in the expression of the differential equation, use instead integers, rationals or symbols like \texttt{Pi, E}, etc. If you need to use a real number declare it as a parameter and give the value  of the paramater in the driver with the required precision. The problems can appear too when you use the option \texttt{InitialPoint->{t0, tf, Points[n]}}. For instance  \texttt{InitialPoint->{0, Pi, Points[100]}} works fine, but \texttt{InitialPoint->{0., Pi, Points[100]}} works bad. Use, as possible the same rule that before or inspect the drive and fix it.\medpar

The principal function of the multiple precision standard version of the integrator is the following:

\begin{Verbatim}[frame = lines]

void mp_tides(LinkedFunction fcn,
	int nvar, int npar, int nfun,
	mpfr_t x[], mpfr_t p[],
	mpfr_t lt[], int ntes, 	
	mpfr_t tolrel, mpfr_t tolabs,
	mpfr_t** mat, FILE* fileout);

\end{Verbatim}

The arguments of both functions are all equal except those arguments relative to the integration points.

\begin{itemize}
\item \textsl{The linked function:} \texttt{fcn} is a pointer to the function that contains the iterations needful to create the Taylor Series solution. It will we described in Section \ref{lkfi}

\item \textsl{The dimensions of the problem:} \texttt{nvar, npar, nfun} are three integer numbers that represent, respectively, the number of variables, the number of parameters and the number of extra functions to evaluate.

\item \textsl{Initial value of the variables:} \texttt{x} is a pointer to a \texttt{mpfr\_t}, or an  array with \texttt{nvar} elements. On input it has the value of the initial conditions (value of the variables at the initial point). On output it has the value of the variables at the final integration point.

\item \textsl{Value of the parameters:} \texttt{p} is a pointer to a \texttt{mpfr\_t}, or an array with \texttt{npar} elements. It has the value of the parameters.

\item \textsl{Integration points: } The integration points are represented by two arguments \texttt{lt} and \texttt{ntes}.  \texttt{lt} is a pointer to a \texttt{mpfr\_t} that represents an array of dimension \texttt{ntes} that contains the list $\{t_0, \ldots,t_k\}$ of points where the solution will be computed. These points can be non-equidistants. The list must be ordered, but the order can be crescent or decrescent (for backward integration). \par

\item \textsl{Tolerances: } \texttt{tolrel, tolabs} are to \texttt{mpfr\_t} variables with the relative and absolute tolerance of the method.

\item \textsl{Output of the integrator: } \texttt{mat} is a double pointer to a \texttt{double} that represent a data matrix where the output will be stored. \texttt{fileout}  is a pointer to a \texttt{File} where the output will be written on. More details about these outputs appear on the Section \ref{outi}.

\end{itemize}

\section{The linked function}\label{lkfi}

The linked function that contains the iterations needful to create the Taylor Series solution is passed to the integrator by means to a pointer to a function whose prototype is one of the following

\begin{Verbatim}[frame = lines]

typedef long (*LinkedFunction)(double t, double v[],
		double p[], int orden, double cvfd[][orden+1]);

typedef long (*LinkedFunction)(mpfr_t t, mpfr_t v[],
		mpfr_t p[], int orden, mpfr_t cvfd[][orden+1]);

\end{Verbatim}
\noindent depending on if we use the double precision version or the multiple precision version.\medpar

Let's take the example showed in the Section \ref{cri} of this chapter in which the file
\texttt{intfunct.c} has been created from the expression  \texttt{TSMCodeFiles}. This file contains a function named \texttt{intfunct} (the same name as the second argument of  \texttt{TSMCodeFiles}) that follows the rules of the \texttt{LinkedFunction} prototype. Then, the symbol \texttt{intfunct} can be directly used as the firs argument of the integrator.\medpar

Let's note that this system permits to use the \tsmi  to integrate several ODEs inside the same main program ( on the contrary that in the minimal versions). We only need to create with  \texttt{TSMCodeFiles} files with different names and call the integrator with these different functions.



%----------------------------------------------------------------------------------------
\section{The output of the integrator}\label{outi}

The two last arguments of the integrator tell it what kind of output we want. There are two possibilities: a data matrix or a file (this file can be a physical file or the screen), both with the (same) solution.\medpar

The outputs have \texttt{nrows} rows or lines equal to the number $k+1$ of points $\{t_0, t_1, \ldots, t_k\}$ in which we compute the solution. Each row represents the solution on each point $t_i$.\medpar

Each row has \texttt{ncolumns} elements (columns of the output). This number depends on the options that we choose in \texttt{TSMCodeFiles}, and can be obtained by calling the function
\begin{Verbatim}[frame = lines]

long intfunct_columns();

\end{Verbatim}
\noindent The name of this function is formed adding  \texttt{\_columns} to the string of the second argument of \texttt{TSMCodeFiles}. It returns an integer number (\texttt{long}) with the value of \texttt{ncolumns}.\medpar


The two last arguments of the integrator are \texttt{double** mat} (or \texttt{mpfr\_t** mat}  in the multiple precision case) and \texttt{FILE* fileout}. If we don't want any of these outputs we will pass a value equal to \texttt{NULL} to the integrator. In other case we need to declare a variable of the corresponding type, give it a value and pass it to the integrator.\medpar

To write into a file you must include in your code the lines
\begin{Verbatim}[frame = lines]

FILE   *mydatafile;
mydatafile = fopen("datafilename", "w");

\end{Verbatim}
\noindent where \texttt{datafilename} will be the name of the file. If we want to write into the screen instead a file substitute this line by \texttt{mydatafile = stdout;}. After that use \texttt{mydatafile} as the last argument.\medpar

If you want to write into a data matrix you need to declare and initialize  it as follows

\begin{Verbatim}[frame = lines]

double** mydatamatrix;
Array2DB_init(&mydatamatrix, nrows, ncolumns);

\end{Verbatim}
\noindent in the double precision case,  and

\begin{Verbatim}[frame = lines]

mpfr_t** mydatamatrix;
Array2MP_init(&mydatamatrix, nrows, ncolumns);

\end{Verbatim}
\noindent in the multiple precision case.\medpar

The function \texttt{Array2DB\_init} (\texttt{Array2MP\_init}) allocate storage for a bidimensional array type \texttt{double} (\texttt{mpfr\_t}) with \texttt{nrows} rows and \texttt{ncolumns} columns.\medpar

Eventually we need to understand what information is contained in each column of the output in order to use it. This may be difficult when we compute partial derivatives. In order to identify each column let's remain
that the first file of the file correspond with the column of order zero of the data matrix. Then in what follows we identify each position with the index of the data matrix. The column of order zero represents the time $t$.
 In order to know in what column appears a particular partial derivative of a variable we may use the function
{
\begin{verbatim}
long intfunct_variable_column(int v, char *der);
\end{verbatim} }
\noindent The name of this function is formed adding  \texttt{\_variable\_column} to the string of the second argument of \texttt{TSMCodeFiles}. It returns the position of the partial derivative \texttt{der} of the variable \texttt{v}. The variable is represented by an integer \texttt{v} that represents the index of the variable following the C-style for indexes (0 is the first index). To identify each derivative we use its representation  by means of indexes $\mathbf{i} =\{i_1, i_2, \ldots i_m\}$. Each character of the  string \texttt{der} coincides with  each number $i_k$. \medpar

Let's suppose an example with three variables $\{x,y,z\}$ and several parameters $\sigma, \beta$. Let's suppose we compute the partials with respect to $\{x,y,z,\sigma\}$. Then the position of $\partial^2 y / \partial x_0 \partial \sigma$ is given by the function \texttt{lorenzP\_variable\_column(1, "1001")}. The variable $x$  is at the position \texttt{lorenzP\_variable\_column(0, "0000")}, that returns the value $1$.\medpar

If we add additional functions to the integrator we identify the columns in which these functions and their derivatives appear by means of the function
{
\begin{verbatim}
long intfunct_function_column(int f, char *der);
\end{verbatim} }
\noindent The name of this function is formed adding  \texttt{\_function\_column} to the string of the second argument of \texttt{TSMCodeFiles}. It returns the position of the partial derivative \texttt{der} of the function \texttt{f}. The function is represented by an integer \texttt{f} that represents the index of the function following the C-style for indexes (0 is the first index).\medpar


%----------------------------------------------------------------------------------------
\section{Internal parameters of the integrator}\label{inti}
In Section \ref{tsmop} of this document we discuss a set of internal parameters of the \tsmi. All this parameters, except to the tolerances, have a default value that usually, for the most general cases, are the best election, and the user does not need to change them. However, there are two ways to change this parameters: by options of \texttt{TSMCodeFiles} that change the driver (see \ref{tsmopcf}), or by changing directly the value if we write our own driver.\medpar

The way to access to the parameters is by declaring the parameters as external variables in the main program (driver)

\begin{verbatim}
extern double   fac1;
extern double   fac2;
extern double   fac3;
extern double   rmaxstep;
extern double   rminstep;
extern int      nitermax;
extern int      nirdinc;
extern int      minord;
extern int      defect_error_control;
\end{verbatim}
\noindent where the meaning of names are the same that in \ref{tsmop}.

The default values of the parameters are

\begin{verbatim}
fac1 = 0.95;
fac2 = 10.;
fac3 = 0.8
rmaxstep = 1e2;
rminstep = 1e-2;
nitermax = 5;
nirdinc = 4;
minord = 6;
defect_error_control = 0   /* = False */
\end{verbatim}

To change the value of any of them include a similar line in the driver. For instance to use the defect error control write

\begin{verbatim}
defect_error_control = 1;
\end{verbatim}

%----------------------------------------------------------------------------------------
\section{Three examples of driver}

Let's take again the differential equation \Eqref{sincos} that define the sinus and cosinus functions. \medpar
\lineacolor
\inmath
\begin{verbatim}
sincos = FirstOrderODE[{y, -x}, t, {x, y}]
\end{verbatim}
\lineacolor
\subsubsection{First example}

In the first case let's compute, in double precision the solution, in $[0, 2 \pi]$, together with the partial derivatives with respect to the initial conditions of second order, i.e. $\partial^2 x/\partial x_0^2, \,\partial^2 x/\partial y_0^2, \,\partial^2 x/\partial x \partial y$, and the same for $y$.\medpar

To write the driver file \texttt{dr\_sincosp.c} we write in \mathtides
\medpar
\lineacolor
\inmath
\begin{verbatim}
TSMCodeFiles[sincos, "sincosp",
    InitialConditions -> {0, 1},
    IntegrationPoints -> {0, Pi/2, Pi, 2 Pi},
    DataMatrix -> "scdata",
    DefectErrorControl -> True,
    AddPartials -> {{x, y}, 2, Only}]
\end{verbatim}
\outmath
\begin{verbatim}
Files "dr_sincosp.c", "sincosp.h" and sincosp.c" written on
    directory ....."
\end{verbatim}
%\vspace{-15pt}
\lineacolor
\medpar

\noindent and finally  the file \texttt{dr\_sincosp.c} is

\begin{Verbatim}[frame = lines, numbers = left]
#include <stdio.h>
#include <stdlib.h>
#include "sincosp.h"

int main() {

	int nvar = 2;
	int npar = 0;
	int nfun = 0;
	int nipt = 4;
	double v[nvar], lt[nipt];
	double tolrel, tolabs;
	double** scdata;
	FILE   *fd;

/***********************************************************/
/***********************************************************/
/*       CONSTANTS OF THE METHOD                            */
/***********************************************************/
/***********************************************************/

	extern int defect_error_control;
	defect_error_control = 1;

/************************************************************/
/************************************************************/
/*     INITIAL CONDITIONS, INTEGRATION TIMES, TOLERANCES    */
/*     Change *****  by numerical values if it is necesary  */
/************************************************************/
/************************************************************/

/* --- INITIAL VALUES --- */
	v[0] = 0 ;
	v[1] = 1. ;

/* ---     INTEGRATION POINTS    --- */
	lt[0] = 0. ;
	lt[1] = 1.570796326794897 ;
	lt[2] = 3.141592653589793 ;
	lt[3] = 6.283185307179586 ;

/* --- REQUIRED TOLERANCES --- */
	tolrel = 1.e-16 ;
	tolabs = 1.e-16 ;

/***********************************************************/
/***********************************************************/
/*        OUTPUT:         data matrix                     */
/***********************************************************/
/***********************************************************/

	Array2DB_init(&scdata, nipt, sincosp_columns());


/***********************************************************/
/***********************************************************/
/*       CALL THE INTEGRATOR                               */
/***********************************************************/
/***********************************************************/

	dp_tides(sincosp, nvar, npar, nfun, v, NULL,
			lt, nipt, tolrel, tolabs, scdata, NULL);


	return 0;
}

\end{Verbatim}

Lines 1 to 3 include the header files of the system and the header file created with \texttt{TSMCodeFiles}.\medpar

Lines 7-9 declare the number of variables and functions and, in the appropriate cases, the number of parameters. Line 10 declares the number of points in which the output is written (the number of integration points plus the initial point).  Lines 11-14 declare the local variables of the driver, all of them necessaries to call the integrator.\medpar

Lines 22-23  declare, as external, and change the values of  the internal parameters of the method that we change on the driver. In this example we use defect error control in the integration. If we do not change any parameter of the method these lines that not appear. \medpar

Lines 33-44 assign value to the initial variables, integration points and tolerances. \medpar

Line 52 initialize the data matrix to store the solution. It has 4 rows ($t_0 = 0, t_1 = \pi/2, t_2 = \pi,  t_3 = 2 \pi$). and the number of columns is given by the function \texttt{sincosp\_columns()}.\medpar

Lines 61-62 call the integrator. A \texttt{NULL} is used in the pointer to the parameters (no parameter in the problem) and in the output file (no output file, only data matrix).\medpar

In the data matrix, the integration time appears in the first column. Columns 2 and 3 contains the values $x(t_i), y(t_i)$. To know in what column the partials appear use the function \texttt{sincosp\_variable\_column}. For instance the partial $\partial^2 x /\partial x_o^2$ is in column \texttt{sincosp\_variable\_column(0,"20")}, and $\partial^2 y /\partial x_o\partial y_0$ appears in column  \texttt{sincosp\_variable\_column(1,"11")}.\medpar

%----------------------------------------------------------------------------------------
\subsubsection{Second example}
Let suppose now we want to compute the sinus, cosinus, and simultaneously the tangent. The we include an additional function $x/y$ in the ODE. Let's compute, at the same time all the partial, with respect to the initial condtitions of orders 1 and 2.
\medpar
\lineacolor
\inmath
\begin{verbatim}
TSMCodeFiles[sincos, "sincost",
     InitialConditions -> {0, 1},
     IntegrationPoints -> {0., Pi, 2 Pi},
     DataMatrix -> "scdata",
     Output -> "datasct",
     AddFunctions -> {x/y},
     AddPartials -> {{x, y}, 2}]
 \end{verbatim}
\outmath
\begin{verbatim}
Files "dr_sincost.c", "sincost.h" and sincost.c" written on directory  .....
\end{verbatim}
%\vspace{-15pt}
\lineacolor
\medpar

The driver file \texttt{dr\_sincost.c} is

\begin{Verbatim}[frame = lines, numbers = left]
#include <stdio.h>
#include <stdlib.h>
#include "sincost.h"

int main() {

	int nvar = 2;
	int npar = 0;
	int nfun = 1;
	int nipt = 3;
	double v[nvar], lt[nipt];
	double tolrel, tolabs;
	double** scdata;
	FILE   *fd;


/************************************************************/
/************************************************************/
/*     INITIAL CONDITIONS, INTEGRATION TIMES, TOLERANCES    */
/*     Change *****  by numerical values if it is necesary  */
/************************************************************/
/************************************************************/

/* --- INITIAL VALUES --- */
	v[0] = 0 ;
	v[1] = 1. ;

/* ---     INTEGRATION POINTS    --- */
	lt[0] = 0. ;
	lt[1] = 3.141592653589793 ;
	lt[2] = 6.283185307179586 ;

/* --- REQUIRED TOLERANCES --- */
	tolrel = 1.e-16 ;
	tolabs = 1.e-16 ;

/***********************************************************/
/***********************************************************/
/*        OUTPUT: file   &data matrix                     */
/***********************************************************/
/***********************************************************/

	fd = fopen("datasct", "w");
	Array2DB_init(&scdata, nipt, sincost_columns());


/***********************************************************/
/***********************************************************/
/*       CALL THE INTEGRATOR                               */
/***********************************************************/
/***********************************************************/

	dp_tides(sincost, nvar, npar, nfun, v, NULL,
			lt, nipt, tolrel, tolabs, scdata, fd);


	fclose(fd);

	return 0;
}
\end{Verbatim}

The differences of this driver with respect to the previous one are the following:\medpar

Line 9 declares, in this case one function.\medpar

Line 43 declares an output file named \texttt{datasct} that after the execution of the program is equal that the data matrix \texttt{scdata}.\medpar

The pointer \texttt{fd} to  a file appears as the last argument of the call to the integrator (line 54). \medpar

In the data matrix, the integration time appears in the first column. Columns 2 and 3 contains the values $x(t_i), y(t_i)$ Column 4 contains the extra function, the tangent $T = x/y$. To know in what column the partials appear use the function \texttt{sincost\_variable\_column, sincost\_function\_column}. For instance the partial $\partial^2 y /\partial x_o^2$ is in column \texttt{sincost\_variable\_column(1,"20")}, and $\partial^2 T /\partial x_o\partial y_0$ appears in column  \texttt{sincost\_function\_column(0,"11")}.\medpar
%----------------------------------------------------------------------------------------
\subsubsection{Third example}

Now we will compute only the sinus and cosinus without extra function nor partial derivatives, But we will make the calculation with 40 precision digits. The output has 100 integration points (101 including the initial point), from $0$ to $2 \pi$, it will  appear on the screen and in a data matrix.

\medpar
\lineacolor
\inmath
\begin{verbatim}
TSMCodeFiles[sincos, "sincosmp",
     InitialConditions -> {0, 1},
     IntegrationPoints -> {0, 2 Pi, Points[100]},
     DataMatrix -> "mpscdata",
     Output -> Screen,
     PrecisionDigits -> 40];
 \end{verbatim}
\outmath
\begin{verbatim}
Files "dr_sincosmp.c", "sincosmp.h" and sincosmp.c" written on \
directory  .....
\end{verbatim}
%\vspace{-15pt}
\lineacolor
\medpar

The driver file \texttt{dr\_sincosmp.c} is

\begin{Verbatim}[frame = lines, numbers = left]
#include <stdio.h>
#include <stdlib.h>
#include "mpfr.h"
#include "sincosmp.h"

int main() {

	set_precision_digits(40);

	int i;
	int nvar = 2;
	int npar = 0;
	int nfun = 0;
	int nipt = 101;
	mpfr_t v[nvar], lt[nipt];
	mpfr_t tolrel, tolabs;
	mpfr_t** mpscdata;
	FILE   *fd;


/************************************************************/
/************************************************************/
/*     INITIAL CONDITIONS, INTEGRATION TIMES, TOLERANCES    */
/*     Change *****  by numerical values if it is necesary */
/************************************************************/
/************************************************************/

/* --- INITIAL VALUES --- */
	for(i=0; i<nvar; i++) mpfrts_init(&v[i]);
	mpfrts_set_str(&v[0], "0");
	mpfrts_set_str(&v[1], "1.");

/* ---     INTEGRATION POINTS    --- */
	for(i=0; i<nipt; i++) mpfrts_init(&lt[i]);
	mpfr_t t0,dt,idt;
	mpfrts_init(&t0);
	mpfrts_init(&dt);
	mpfrts_init(&idt);
	mpfrts_set_str(&t0, "0");
	mpfrts_set_str(&dt, "0.06283185307179586476925286766559005768394");
	for(i=0; i<nipt; i++) {
		mpfrts_mul_i(&idt,dt,i);
		mpfrts_add(&lt[i],t0,idt);
	}

/* --- REQUIRED TOLERANCES --- */
	mpfrts_init(&tolrel);
	mpfrts_init(&tolabs);
	mpfrts_set_str(&tolrel, "1.e-40");
	mpfrts_set_str(&tolabs, "1.e-40");

/***********************************************************/
/***********************************************************/
/*        OUTPUT: screen &data matrix                     */
/***********************************************************/
/***********************************************************/

	fd = stdout;
	Array2MP_init(&mpscdata, nipt, sincosmp_columns());

/***********************************************************/
/***********************************************************/
/*       CALL THE INTEGRATOR                               */
/***********************************************************/
/***********************************************************/

	mp_tides(sincosmp, nvar, npar, nfun, v, NULL,
			lt, nipt, tolrel, tolabs, mpscdata, fd);


	return 0;
}
\end{Verbatim}

In line 3 we include the file \texttt{mpfr.h} to work with the MPFR library.\medpar

Lines 30 to 32 declare the variables as \texttt{mpfr\_t} type.\medpar

Lines 29 to 31 contains the initialization and assignation of values of the initial conditions, the integration points and lines 47-50 the tolerances. Let's note that the string with the values of the variables has been computed in \mathematica with the adequate precision. \medpar

Lines 34-44 contain the creation of the list \texttt{lt} of integration points.\medpar

Finally, the output file now is the screen (line 58).\medpar


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Symbolic Power Series in \mathtides}

%------------------------------------------------------------------------------------------------------
\section{Power Series in \mathtides}

Instead of the classical representation of Taylor series $\sum a_i t^i/i!$ we use in \tides the power series representation $\sum a_i t^i$, without factorial, in order to avoid numerical problems dues to the big values of the factorial on high orders.\medpar

The symbolic representation of a power series in \mathtides uses an expression with head \texttt{PWS} and $n+1$ arguments representing the coefficients $\{a_0, a_1, \ldots a_n\}$. Then\medpar

\lineacolor
\inmath
\begin{verbatim}
ser = PWS[a0, a1, a2, a3, a4, a5]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[a0, a1, a2, a3, a4, a5]
\end{verbatim}
\lineacolor
\medpar

\noindent represents the $n$-th order power series $\sum_0^n a_i t^i$. Let's note that the dummy variable $t$ does not appears on the series representation. This expression represents in \mathematica the head of a pure function. You may use it to evaluate the series at any point, symbolico or numeric.\medpar

\lineacolor
\inmath
\begin{verbatim}
ser[t]
\end{verbatim}
\outmath
\begin{verbatim}
a0 + a1 t + a2 t^2 + a3 t^3 + a4 t^4 + a5 t^5
\end{verbatim}
\inmath
\begin{verbatim}
ser[t - 2]
\end{verbatim}
\outmath
\begin{verbatim}
a0 + a1 (-2 + t) + a2 (-2 + t)^2 + a3 (-2 + t)^3 +
a4 (-2 + t)^4 +  a5 (-2 + t)^5
\end{verbatim}
\inmath
\begin{verbatim}
ser[3]
\end{verbatim}
\outmath
\begin{verbatim}
a0 + 3 a1 + 9 a2 + 27 a3 + 81 a4 + 243 a5
\end{verbatim}
\lineacolor
\medpar

The expression \texttt{OrderPWS} gives the order $n$ of the series $\sum_0^n a_i t^i$.\medpar
\lineacolor
\inmath
\begin{verbatim}
OrderPWS[ser]
\end{verbatim}
\outmath
\begin{verbatim}
5
\end{verbatim}
\lineacolor
\medpar

\noindent This function can be used to increase or decrease the order of the series\medpar
\lineacolor
\inmath
\begin{verbatim}
OrderPWS[ser, 10]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[a0, a1, a2, a3, a4, a5, 0, 0, 0, 0, 0]
\end{verbatim}
\inmath
\begin{verbatim}
OrderPWS[ser, 3]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[a0, a1, a2, a3]
\end{verbatim}
\lineacolor
\medpar
\noindent Let's note that the order of the series is increased by adding coefficients equal to zero.\medpar
The coefficients of the series can be changed manually in the following form\medpar
\lineacolor
\inmath
\begin{verbatim}
ser[[1]] = x;
\end{verbatim}
\inmath
\begin{verbatim}
ser
\end{verbatim}
\outmath
\begin{verbatim}
PWS[x, a1, a2, a3, a4, a5]
\end{verbatim}
\inmath
\begin{verbatim}
ser[[3]] = 4;
\end{verbatim}
\inmath
\begin{verbatim}
ser
\end{verbatim}
\outmath
\begin{verbatim}
PWS[x, a1, a2, 4, a4, a5]
\end{verbatim}
\lineacolor
\medpar
\noindent the index to change manually the series is different than the mathematical representation \texttt{ser[[i]]} represents $a_{i-1}$.\medpar
\section{Creating power series}
The most elementary series (zero and unit series) can be created by the expressions \texttt{ZeroPWS} and \texttt{UnitPWS}.
\medpar
\lineacolor
\inmath
\begin{verbatim}
UnitPWS[3]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[1, 0, 0, 0]
\end{verbatim}
\inmath
\begin{verbatim}
ZeroPWS[12]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
\end{verbatim}
\lineacolor
\medpar

The usual way to handle power series in \mathematica is by means of the expression \texttt{Series}
\medpar
\lineacolor
\inmath
\begin{verbatim}
Series[Sin[x], {x, 0, 5}]
\end{verbatim}
\outmath
\begin{verbatim}
x - x^3/6 + x^5/120 + O[x]^6
\end{verbatim}
\lineacolor
\medpar
With \mathtides we can use the expression \texttt{PWSeries} to obtain automatically the \mathtides power series representation. The arguments of \texttt{PWSeries} are the same as  \texttt{Series}
\medpar
\lineacolor
\inmath
\begin{verbatim}
PWSeries[Sin[x], {x, 0, 5}]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[0, 1, 0, -(1/6), 0, 1/120]
\end{verbatim}

\inmath
\begin{verbatim}
ssin = PWSeries[Sin[x], {x, a, 5}]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[Sin[a], Cos[a], -(Sin[a]/2), -(Cos[a]/6), Sin[a]/24, Cos[a]/120]
\end{verbatim}

\inmath
\begin{verbatim}
ssin[t]
\end{verbatim}
\outmath
\begin{verbatim}
t Cos[a] - 1/6 t^3 Cos[a] + 1/120 t^5 Cos[a] + Sin[a] -
 1/2 t^2 Sin[a] + 1/24 t^4 Sin[a]
\end{verbatim}

\inmath
\begin{verbatim}
ssin[4]
\end{verbatim}
\outmath
\begin{verbatim}
(28 Cos[a])/15 + (11 Sin[a])/3
\end{verbatim}
\lineacolor
\medpar

This procedure can be used to obtain the series result of  substitute a variable by a series into a function.
\medpar
\lineacolor
\inmath
\begin{verbatim}
uu = u0 + u1 t + u2 t^2 + u3 t^3 + u4 t^4;
vv = v0 + v1 t + v2 t^2 + v3 t^3 + v4 t^4 + v5 t^5;
\end{verbatim}

\inmath
\begin{verbatim}
PWSeries[Sin[t x y], {t, 0, 3}]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[0, x y, 0, -(1/6) x^3 y^3]
\end{verbatim}

\inmath
\begin{verbatim}
PWSeries[Sin[t x y] /. {x -> uu}, {t, 0, 3}]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[0, u0 y, u1 y, u2 y - (u0^3 y^3)/6]
\end{verbatim}

\inmath
\begin{verbatim}
PWSeries[Sin[t x y] /. {x -> uu, y -> vv}, {t, 0, 3}]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[0, u0 v0, u1 v0 + u0 v1, u2 v0 - (u0^3 v0^3)/6 + u1 v1 + u0 v2]
\end{verbatim}

\lineacolor
\medpar

\section{Algebra of power series}

\mathtides implements a complete arithmetic of power series. Let's suppose the series

\medpar
\lineacolor
\inmath
\begin{verbatim}
s1 = PWS[a0, a1, a2, a3, a4, a5, a6];
s2 = PWS[b0, b1, b2, b3, b4];
\end{verbatim}
\lineacolor
\medpar

\noindent then we can make the usual elementary (+, -, $\times$, /, \^{} ) operations:


\medpar
\lineacolor
\inmath
\begin{verbatim}
s1 + s2
\end{verbatim}
\outmath
\begin{verbatim}
PWS[a0 + b0, a1 + b1, a2 + b2, a3 + b3, a4 + b4]
\end{verbatim}

\inmath
\begin{verbatim}
s1 s2
\end{verbatim}
\outmath
\begin{verbatim}
PWS[a0 b0, a1 b0 + a0 b1, a2 b0 + a1 b1 + a0 b2,
 a3 b0 + a2 b1 + a1 b2 + a0 b3, a4 b0 + a3 b1 + a2 b2 + a1 b3 + a0 b4]
\end{verbatim}

\inmath
\begin{verbatim}
s2^2
\end{verbatim}
\outmath
\begin{verbatim}
PWS[b0^2, 2 b0 b1, b1^2 + 2 b0 b2, 2 (b1 b2 + b0 b3),
 b2^2 + 2 b1 b3 + 2 b0 b4]
\end{verbatim}

\lineacolor
\medpar

\noindent Let's note that the order of the result is the smallest order of the operands.\medpar


We may obtain the function of a series and work with this functions

\medpar
\lineacolor
\inmath
\begin{verbatim}
Sin[s2]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[Sin[b0], b1 Cos[b0],
 b2 Cos[b0] - 1/2 b1^2 Sin[b0], (-(b1^3/6) + b3) Cos[b0] -
  b1 b2 Sin[b0], (-((b1^2 b2)/2) + b4) Cos[b0] +
  1/24 (b1^4 - 12 b2^2 - 24 b1 b3) Sin[b0]]
\end{verbatim}

\inmath
\begin{verbatim}
Sin[s2]^2 + Cos[s2]^2
\end{verbatim}
\outmath
\begin{verbatim}
PWS[Cos[b0]^2 + Sin[b0]^2, -2 b1 Cos[b0] Sin[b0] + b1 Sin[2 b0], 0,
    1/3 (2 b1^3 - 3 b3) Sin[2 b0] + 1/3 (-2 b1^3 + 3 b3) Sin[2 b0],
    1/3 (b1^4 - 3 b2^2 - 6 b1 b3) Cos[
    2 b0] + (-(b1^4/3) + b2^2 + 2 b1 b3) Cos[
    2 b0] + (2 b1^2 b2 - b4) Sin[2 b0] + (-2 b1^2 b2 + b4) Sin[2 b0]]
\end{verbatim}

\inmath
\begin{verbatim}
Simplify[%]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[1, 0, 0, 0, 0]
\end{verbatim}

\inmath
\begin{verbatim}
Log[s2]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[Log[b0], b1/b0, -((b1^2 - 2 b0 b2)/(2 b0^2)), (
    b1^3 - 3 b0 b1 b2 + 3 b0^2 b3)/(
    3 b0^3), -((
    b1^4 - 4 b0 b1^2 b2 + 4 b0^2 b1 b3 + 2 b0^2 (b2^2 - 2 b0 b4))/(
    4 b0^4))]
\end{verbatim}

\lineacolor
\medpar

The functions implemented to work with power series are the following:
\[a^x, x^a, x^y, \sin, \cos, \tan, \sinh, \cosh, \tanh, \asin, \acos, \atan, \asinh, \acosh, \atanh, \log, \exp\]

Finally we may use with power series the \mathematica operators \texttt{D} \texttt{Dt} to compute the partial or total derivative witht respect to any element except the dummy variable o the series


\medpar
\lineacolor
\inmath
\begin{verbatim}
D[s1, a1]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[0, 1, 0, 0, 0, 0, 0]
\end{verbatim}
\inmath
\begin{verbatim}
Dt[s1, t]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[Dt[a0, t], Dt[a1, t], Dt[a2, t], Dt[a3, t], Dt[a4, t], Dt[a5, t], Dt[a6, t]]
\end{verbatim}
\lineacolor
\medpar

\section{Symbolic Taylor Series Method (TSM)}

In the previous chapters we describe the implementation of the numerical TSM that combines the use of \mathtides and \libtides. This numerical method constructs the solution of an ODE by evaluating the power series of the solution of the ODE inside its convergence radius. \mathtides.\medpar


With \mathtides we can obtain the power series solution used to implement the numerical method in both ways: symbolic and numeric. We don not need \libtides to use this possibility. \mathtides. \medpar

To illustrate this option we take again the differential equation
\begin{equation}\label{sincosb}
\Der{x}{t} = y, \quad \Der{y}{t} = -x,
\end{equation}
whose solution for $x(0) = 0,\, y(0) = 1$ gives the functions: $x(t) = \sin t, \, y(t) = \cos t$.
To declare this ODE we will write the expression
\medpar
\lineacolor
\inmath
\begin{verbatim}
sincos = FirstOrderODE[{y, -x}, t, {x, y}]
\end{verbatim}
\outmath
\begin{verbatim}
FirstOrderODE$[{y, -x}, t, {x, y}, {}]
\end{verbatim}
%\vspace{-15pt}
\lineacolor
\medpar

To obtain the Series solution of order $10$ of the previous equation around $t=0$ with the initial conditions $x(0) = 0,\, y(0) = 1$ we use the expression \texttt{TSMSolve} in the following way
\medpar
\lineacolor
\inmath
\begin{verbatim}
TSMSolve[sincos, {t, 0, 10}, {x -> 0, y -> 1}]
\end{verbatim}
\outmath
\begin{verbatim}
{PWS[0, 1, 0, -(1/6), 0, 1/120, 0, -(1/5040), 0, 1/362880, 0],
 PWS[1, 0, -(1/2), 0, 1/24, 0, -(1/720), 0, 1/40320, 0, -(1/3628800)]}
 \end{verbatim}
%\vspace{-15pt}
\lineacolor
\medpar

The previous solution coincides with the power series of the $\sin, \cos$ functions
\medpar
\lineacolor
\inmath
\begin{verbatim}
PWSeries[{Sin[x], Cos[x]}, {x, 0, 10}]
\end{verbatim}
\outmath
\begin{verbatim}
{PWS[0, 1, 0, -(1/6), 0, 1/120, 0, -(1/5040), 0, 1/362880, 0],
 PWS[1, 0, -(1/2), 0, 1/24, 0, -(1/720), 0, 1/40320, 0, -(1/3628800)]}
 \end{verbatim}
%\vspace{-15pt}
\lineacolor
\medpar

The arguments of the expression \texttt{TSMSolve} are the following
\begin{enumerate}
\item The function that defines the ODE.
\item A list with three elements
\begin{enumerate}
\item The symbol of the independent variable $t$.
\item The symbol or the numeric value of the initial instant $t_0$.
\item An integer with the order of the solution.
\end{enumerate}
\item A list with the same number of rules that variables. Each rule has the following structure:  \textit{symbol of the variable} $\rightarrow$ \textit{symbolic or numeric value of the initial condition of the variable}.
\item A list with the same number of rules that parameters. If there is no perameters this arguments it is not necesary. Each rule has the following structure:  \textit{symbol of the parameter} $\rightarrow$ \textit{symbolic or numeric value of the parameter}.
\end{enumerate}

The following example illustrate how to use \texttt{TSMSolve} with parameters
\medpar
\lineacolor
\inmath
\begin{verbatim}
TSMSolve[FirstOrderODE[{y, - a  x}, t, {x, y}, {a}], {t, 0,
  10}, {x -> 0, y -> 1}, {a -> 2}]
\end{verbatim}
\outmath
\begin{verbatim}
{PWS[0, 1, 0, -(1/3), 0, 1/30, 0, -(1/630), 0, 1/22680, 0],
 PWS[1, 0, -1, 0, 1/6, 0, -(1/90), 0, 1/2520, 0, -(1/113400)]}
  \end{verbatim}
\lineacolor
\medpar

We can use symbolic parameters, initial times  or initial conditions

\medpar
\lineacolor
\inmath
\begin{verbatim}
TSMSolve[FirstOrderODE[{y, - a  x}, t, {x, y}, {a}], {t, 0,
  10}, {x -> 0, y -> 1}, {a -> a}]
\end{verbatim}
\outmath
\begin{verbatim}
{PWS[0, 1, 0, -(a/6), 0, a^2/120, 0, -(a^3/5040), 0, a^4/362880, 0],
 PWS[1, 0, -(a/2), 0, a^2/24, 0, -(a^3/720), 0, a^4/40320,
  0, -(a^5/3628800)]}
  \end{verbatim}

  \inmath
\begin{verbatim}
scsol = TSMSolve[sincos, {t, 0, 5}, {x -> x0, y -> y0}]
\end{verbatim}
\outmath
\begin{verbatim}
{PWS[x0, y0, -(x0/2), -(y0/6), x0/24, y0/120],
 PWS[y0, -x0, -(y0/2), x0/6, y0/24, -(x0/120)]}
  \end{verbatim}

\lineacolor
\medpar


The implementation of the numerical TSM in \tides includes two extensions: the evaluation of functions of the solution and partials with respect to the initial conditions or the parameters. The symbolic TSM does not include these options because they are not necessaries with the  algebra of series. For instance, if we want to obtain of the squares of the two components

\medpar
\lineacolor
\inmath
\begin{verbatim}
Simplify[scsol[[1]]^2 + scsol[[2]]^2]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[x0^2 + y0^2, 0, 0, 0, 0, 0]
  \end{verbatim}
\lineacolor
\medpar

\noindent and the partial $\partial x /\partial_0$ of the first variable with respect to the initial condition of the first variable
\medpar
\lineacolor
\inmath
\begin{verbatim}
D[scsol[[1]], x0]
\end{verbatim}
\outmath
\begin{verbatim}
PWS[1, 0, -(1/2), 0, 1/24, 0]
  \end{verbatim}
\lineacolor
\medpar


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{99}

\bibitem{ABBR10}
A. Abad, R. Barrio,  F.  Blesa, M. Rodriguez, 2011:  ``\tides: a Taylor series Integrator of Differential EquationS". {\sl ACM Trans. Math. Software}.

\bibitem{ABBR10b}
A. Abad, R. Barrio,  F.  Blesa, M. Rodriguez, 2011:  ``Symbolic Approach to the Numerical Taylor Series Method". Preprint~2011.

 \bibitem{Aba11a}
  A. Abad, R. Barrio, A. Dena, 2011: ``Computing periodic orbits with arbitrary precision". {\sl Phys. Rev. E}, {\bf 84}-016701.


\bibitem{Bar05}
R. Barrio, 2005: ``Performance of the {T}aylor series method for {ODE}s/{DAE}s".
  {\sl Appl. Math. Comput.} {\bf 163}~(2), pp. 525--545.

\bibitem{BBL05}
R. Barrio, F. Blesa, M. Lara, 2005: ``V{SVO} formulation of the {T}aylor method for the numerical solution of {ODE}s". {\sl Comput. Math. Appl.} {\bf 50}~(1-2),
  pp. 93--111.

\bibitem{Bar06}
R. Barrio, 2006: ``Sensitivity analysis of ODE's/DAE's using the Taylor series method".
  {\sl SIAM J. Sci. Comput.} {\bf 27}~(6), pp. 1929--1947.

  \bibitem{Bar11a}
R. Barrio, M. Rodriguez,  A. Abad, S. Serrano, 2011: ``Breaking the limits: the Taylor series method". {\sl Appl. Math. Comput.}, {\bf 217} (20), pp. 7940-7954.


 \bibitem{Bar11b} R. Barrio, M. Rodriguez, A. Abad, F. Blesa, 2011:``Uncertainty propagation or box propagation". {\sl Math. Comput. Modelling}, {\bf 54}, pp. 2602-2615.

\end{thebibliography}

\end{document} 