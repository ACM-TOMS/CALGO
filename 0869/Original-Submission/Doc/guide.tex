\magnification=1095
%\hsize=5.41in \vsize=7.5in     %for magnification=1200
\hsize=5.41in \vsize=7.1in    %for magnification=1095
\hoffset=0.263in
\voffset=0.56in
\parindent=30pt \parskip=3pt plus 3pt
\baselineskip=13pt plus 2pt minus 1pt \lineskiplimit=2pt
\lineskip=2pt plus 2pt \tolerance=800                   %\raggedright

\font\eightmi=cmmi8 \font\eightsy=cmsy8 \font\rmeight=cmr8
\def\rmVIII{\rmeight \baselineskip=10pt
    plus 2pt minus 1pt \lineskiplimit=2pt \lineskip=2pt plus 1pt
    \parskip=0pt \textfont0=\rmeight \textfont1=\eightmi
\textfont2=\eightsy
    \def\strut{\vrule height 7.5pt depth 2.5pt width 0pt}}
\font\smallcaps=cmcsc8
\font\caps=cmcsc10 \font\bfVIII=cmbx8  \font\slVIII=cmsl8
\font\itVIII=cmti8 \font\capsXIV=cmcsc10 at 14pt  \font\hlv=phvr at 16pt
\font\hlvXII=phvr at 12pt
\font\hlvXIII=phvr at 13pt
\font\hlvXIV=phvr at 14pt
\font\hlvXV=phvr at 15pt
\font\hlvXVIII=phvr at 18pt
\font\hlvbig=phvr at 20pt 
\font\rmXVIII=cmr10 at 18truept
\font\rmXII=cmr12
\font\rmX=cmr10
\font\rmIX=cmr10 at 9pt
\font\bfXII=cmbx12
\font\itVII=cmti8 at 7pt
\font\itX=cmti10
\font\itIX=cmti10 at 9pt
\font\bfXVIII=ptmb at 14pt
\font\ttVIII=cmtt8

\def\today{\ifcase\month\or January\or February\or March\or April\or
May\or June\or July\or August\or September\or October\or November\or
December\fi\ \number\day, \number\year}

% other definitions.
\def\h{\par\smallskip\hangindent=13pt\hangafter=1\noindent}
\def\hh{\par\smallskip\hangindent=40pt\hangafter=1\noindent\hskip 30pt}
\def\pubs{\par\leftskip=20pt \everypar={\hangindent=10pt\hangafter=1}
 \parindent=0pt\parskip=3pt plus 3pt minus 0pt
\frenchspacing\raggedright}
\newbox\mybox
\def\aligntobox{\noindent\hskip \wd\mybox\hangindent=\wd\mybox\hangafter=1}
\def\sqr#1#2{{\vcenter{\hrule height.#2pt \hbox{\vrule width.#2pt height
#1pt \kern#1pt \vrule width.#2pt} \hrule height.#2pt}}}
\def\square{\mathchoice\sqr34\sqr34\sqr{2.1}3\sqr{1.5}3}
\def\cl{\centerline}

% Title page
\nopagenumbers
{\hlvXVIII
\baselineskip=22pt
\
\vskip 1in
\hrule height 2pt
\vskip 20pt
\cl{User's Reference Guide}
\cl{for}
\cl{ODRPACK95 Version 1.00}
\cl{Software for Weighted Orthogonal }
\cl{Distance Regression with }
\cl{Bound Constraints}
\vskip 20pt
\hlvXV
\cl{Jason W. Zwolak, Paul T. Boggs, and }
\cl{Layne T. Watson}
\vskip 20pt
\hlvXIII
\cl{December 2005}
\vskip 15pt
\hrule height 2pt
}
\vfil\eject
\
\vfil\eject
% Contact page
\ 
{
\baselineskip=20pt
\vskip 1.4in
\centerline{\rmXVIII User's Reference Guide}
\centerline{\rmXVIII for}
\centerline{\rmXVIII ODRPACK95 Version 1.00}
\centerline{{\rmXVIII Software for Weighted Orthogonal Distance Regression}}
\cl{{\rmXVIII with Bound Constraints}}
}
\bigskip\bigskip
\cl{{\rmXII Jason W. Zwolak}\footnote{$^1$}{Department of Biological Sciences,
Virginia Tech, Blacksburg, VA 24061}}
\cl{{\rmXII Paul T. Boggs}\footnote{$^2$}{MS 9159,
Sandia National Laboratories, Livermore, CA, 94551}}
\cl{{\rmXII Layne T. Watson}\footnote{$^3$}{Departments of Mathematics and
Computer Science, Virginia Tech, Blacksburg, VA 24061}}
\vfil
\eject
% Abstract
\pageno=-3
\headline={\ifodd\pageno\oddheader \else\evenheader\fi}
\footline={\ifodd\pageno\oddfooter \else\evenfooter\fi}
\def\oddheader{\vbox{\rm\noindent\thissection\hfill\folio\smallskip\hrule}}
\def\evenheader{\vbox{\rm\noindent\folio\hfill\thissection\smallskip\hrule}}
\def\oddfooter{\hfill}
\def\evenfooter{\hfill}
\def\thissection{}
\ 
\vfil\eject
\ 
\vskip 1.4in

\noindent {\capsXIV Abstract}\bigskip\bigskip
\def\thissection{Abstract}

\noindent ODRPACK (TOMS Algorithm 676) has provided a complete
package for weighted orthogonal distance regression for many years.
The code is complete with user selectable reporting facilities, numerical
and analytic derivatives, derivative checking, and many more features.
The foundation for the algorithm is a stable and efficient trust
region Levenberg-Marquardt minimizer that exploits the structure of
the orthogonal distance regression problem.  This user's guide describes
ODRPACK95, a modification of the original ODRPACK code that adds bound
constraints, uses the newer Fortran 95 language, and simplifies the
interface to the user called subroutine.
\bigskip
\setbox\mybox=\hbox{\bf Keywords: }
\noindent{\bf Keywords: }\hangindent=\wd\mybox\hangafter=1 orthogonal distance 
regression; measurement error models; errors in variables; nonlinear least 
squares; bound constraints; Fortran 95.
\vfil\eject
\ 
\vfil\eject
\ 
\vskip 1.4in
\def\thissection{Revision History}
\noindent{\capsXIV Revision History}\bigskip\bigskip


\setbox\mybox=\hbox{2.01 (06-55-92) }
\noindent{1.00 (09-28-2004)} \hangindent=\wd\mybox\hangafter=1 ODRPACK95 1.0 
adds bound constraints to the
original ODRPACK code (version 2.01) and updates the code to the Fortran
95 standard.  The implementation of bound constraints projects the step
(after it is calculated and before the current parameters are updated)
into the feasible region of the parameters.  With the addition of bound
constraints comes

\aligntobox $\bullet$ modified finite difference calculations that avoid
requests for function evaluations outside the bounds, 

\aligntobox $\bullet$ modified initialization that calculates {\tt NDIGIT} 
without requesting function evaluations outside the bounds, and 

\aligntobox $\bullet$ modified steps so that they are projected within the feasible region.

\aligntobox
Note that the convergence criteria are not modified and are evaluated after the
step is projected into the feasible region.  With the rewrite in Fortran 95 came

\aligntobox $\bullet$ a module interface to {\tt ODR},

\aligntobox $\bullet$ use of intrinsic Fortran functions to get machine constants,

\aligntobox $\bullet$ declaration of functional parameters using the {\tt OPTIONAL} attribute
when a meaningful or reasonable default exists, and

\aligntobox $\bullet$ array allocation and deallocation for all work arrays.
\
\vfil
\eject

\
\vskip 1.4in
\def\thissection{Original ODRPACK Revision History}
\noindent{\capsXIV Original ODRPACK Revision History}\bigskip\bigskip

\noindent{2.01 (06-19-92) }\hangindent=\wd\mybox\hangafter=1 ODRPACK 2.01 corrects two minor errors. The first affected the derivative checking procedure, and the second affected the values specified by {\tt NDIGIT}. The solutions found by ODRPACK 2.00 were not affected in any way by the first of these errors, and were not seriously affected by the second.

\aligntobox Version 2.01 also encorporates several other minor modifications that further improve the code. The most significant of these modifications changes how the scale values are used within the solution procedure. This change should increase the robustness of the procedure for poorly scaled problems, and will result in slightly different computed results for all problems. Another of these changes is to the report generated by the derivative checking procedure. This report now includes the user supplied derivative value, as well as the relative difference between the user supplied value and the finite difference value it was checked against. This should help users assess the validity of the checking procedure results.

\aligntobox The ``ODRPACK 2.01 User's Reference Guide'' is essentially the same as the version 2.00 Guide (NISTIR 89-4103, Revised). The major differences are that

\aligntobox $\bullet$ the minimum length of array {\tt WORK} has been increased by $(p + m)q$ locations, and

\aligntobox $\bullet$ the sample programs and output shown in Chapter 2, and the discussion of the derivative checking results in Chapter 5 have been modified to reflect the above mentioned changes.\medskip

\noindent{2.00 (03-04-92) }\hangindent=\wd\mybox\hangafter=1 ODRPACK 2.00 adds several new features to those available in version 1.8 and earlier versions.

\aligntobox $\bullet$ With version 2.00, ODRPACK can now easily accommodate complex and other types of multiresponse data, i.e., data where each observation is multidimensional.

\aligntobox $\bullet$ It can handle implicit as well as explicit models.

\aligntobox $\bullet$ The weighting scheme has been enhanced to allow for instances when the components of a multidimensional observation are correlated.

\aligntobox $\bullet$ A facility for computing central finite difference derivatives has been added.

\aligntobox $\bullet$ The amount of work space required for the computations has been reduced for most problems.\medskip

\aligntobox {\it Because of these new features, the argument lists for the
ODRPACK 2.00 user callable subroutines, including the user supplied subroutine {\tt FCN} that now comprises the functionality of subroutines {\tt FUN} and {\tt JAC}, are not the same as for earlier versions.\ } The interpretations of some arguments have changed, and new arguments have been added. In addition, the arguments have been reordered, with arguments having similar purpose now grouped together. Those who have been using an earlier release of ODRPACK should be especially careful to examine the new calling sequences, and the definitions for subroutine arguments {\tt FCN, JOB, WE} and {\tt WD.}\medskip

\noindent{1.80 (12-18-90) }\hangindent=\wd\mybox\hangafter=1 ODRPACK 1.80, a test release with only limited distribution, differs from prior releases in several respects.

\aligntobox $\bullet$ The number of function evaluations required to find the solution has been reduced, and the ``restart'' facility has been modified to better accommodate cases where the user supplied subroutines {\tt FUN} and/or {\tt JAC} are very time consuming.

\aligntobox $\bullet$ The printed reports have been redesigned to identify parameters that induce rank deficiency, and to include a 95\% confidence interval for the estimated parameters.

\aligntobox $\bullet$ Several enhancements have been added to the covariance matrix computations, including the option of constructing the covariance matrix without incurring any additional derivative evaluations.

\aligntobox $\bullet$ The finite difference approximation to the Jacobian matrix has been improved.\medskip

\noindent{1.71 (07-27-89) }\hangindent=\wd\mybox\hangafter=1 ODRPACK 1.71 corrects an error in the code that performs the computation of finite difference derivatives with respect to the errors $\Delta$ when $m\geq2$ and the default value of {\tt IFIXX} is invoked. (The default value of {\tt IFIXX} is invoked when {\tt IFIXX(1,1)} is set to a negative value or when ODRPACK routines {\tt DODR} or {\tt SODR} are called.) This error could result in incorrect ``fixing'' of the explanatory variables, which would affect the final solution. Such ``fixing'' could be detected by observing the presence of estimated values for $\Delta$ that are identically zero. The error could go undetected by the user, however, if the values of $\Delta$ were not examined after the fit.
\vfil\eject

\ 
\vskip 1.4in
\def\thissection{Preface}
\noindent{\capsXIV Preface}\bigskip\bigskip

\noindent ODRPACK95 is a portable Fortran 95 code for fitting a
model to data.  Based on the ODRPACK code [Boggs {\it et al.}, 1989], ODRPACK95
adds bound constraints on the parameters and takes advantage of newer Fortran 95
features.  It is designed primarily for instances when all of the
variables have significant errors (see, e.g., [Fuller, 1987] and
[Boggs and Rogers, 1990]), implementing a highly efficient algorithm for
solving the weighted orthogonal distance regression problem [Boggs {\it
et al.}, 1987 and 1989], i.e., for minimizing the sum of the squares
of the weighted orthogonal distances between each data point and the
curve described by the model equation. It can also be used to solve the
ordinary least squares problem where all of the errors are attributed
to the observations of the dependent variable.

\noindent ODRPACK95 is designed to handle many levels of user sophistication and problem difficulty.

\item{$\bullet$} It is easy to use, providing optional subroutine
arguments to control the computations, extensive error handling
facilities, optional printed reports, and no size restrictions other
than effective machine size.

\item{$\bullet$} It can handle implicit as well as explicit models, and can accommodate complex and other types of multiresponse data, i.e., data where each observation is multidimensional.

\item{$\bullet$} The necessary derivatives (Jacobian matrices) are approximated numerically if they are not supplied by the user, and the correctness of user supplied derivatives can be verified by the derivative checking procedure provided.

\item{$\bullet$} Both weighted and unweighted analysis can be performed.

\item{$\bullet$} Subsets of the unknowns can be treated as constants with their values held fixed at their input values, allowing the user to examine the results obtained by estimating subsets of the unknowns of a general model without rewriting the model subroutine.

\item{$\bullet$} The covariance matrix and the standard errors of the model parameter estimators are optionally provided.

\item{$\bullet$} The ODRPACK95 scaling algorithm automatically compensates
for poorly scaled problems, i.e., problems with model parameters, and/or
unknown errors in the explanatory variables that vary widely in magnitude.

\item{$\bullet$} Parameters can have upper and lower bounds constraining the
search space.

\item{$\bullet$} The trust region Levenberg-Marquardt algorithm implemented by
ODRPACK95 [Boggs {\it et al.}, 1987 and 1989] has a computational effort per step that is of the same order as that required for ordinary least squares, even though the number of unknowns estimated in the orthogonal distance regression problem is the number of unknown model parameters plus the number of explanatory variables, while the number of unknowns estimated in the ordinary least squares problem is simply the number of unknown model parameters.

\item{$\bullet$} The code is portable and is easily used with other
Fortran libraries.

\noindent We have used subroutines from LINPACK [Dongarra {\it et al.},
1979], and from the ``Basic Linear Algebra Subprograms for Fortran Usage''
[Lawson {\it et al.}, 1979]. The code that computes the $t$-values used
in constructing the confidence intervals is from DATAPAC [Filliben,
1977], and the code that checks user supplied derivatives was adapted
from STARPAC [Donaldson and Tryon, 1986] using algorithms described in
[Schnabel, 1982].

\noindent We appreciate the comments and suggestions we have received regarding
earlier versions of ODRPACK and welcome yours.\bigskip

{\settabs\+\hskip 4in&\cr
\+&Jason Zwolak\cr
\+&Paul T. Boggs\cr
\+&Layen T. Watson\cr
\bigskip
\+&June 2006\cr}

\vfil\eject

\ \vskip 1.4in
\def\thissection{Contents}
\noindent{\capsXIV Contents}\bigskip\bigskip

\leftline{\bf Abstract\hfill iv}\medskip
\leftline{\bf Revision History\hfill vi}\medskip
\leftline{\bf Preface\hfill x}\medskip
{\settabs\+5\ \ &5.A\ \ &5.A.iii\ \ &5.A.iii.a\ \ &\hskip 3.8in&\cr
\+\bf 1&\bf Getting Started&&&&\bf\ 1\cr
\+&1.A&Notation and Problem Definition&&\hskip 1in\dotfill&\ 2\cr
\+&&1.A.i&Explicit Orthogonal Distance Regression&\hskip 1.9in\dotfill&\ 5\cr
\+&&1.A.ii&Implicit Orthogonal Distance Regression&\hskip 1.9in\dotfill&\ 6\cr
\+&&1.A.iii&Orthogonal Distance Regression for Multidimensional Data&\hskip 3in\dotfill&\  6\cr
\+&&1.A.iv&Orthogonal Distance Regression with Bound Constraints&\hskip 3in\dotfill&\  9\cr
\+&1.B&Algorithm&\quad\dotfill&.\dotfill&\ 9\cr
\+&1.C&Specifying the Task&&\quad\dotfill&\ 10\cr
\+&1.D&ODRPACK95 Generated Results&&\hskip .9in\dotfill&\ 11\cr
\+&&1.D.i&Error Reports&\quad\quad\dotfill&11\cr
\+&&1.D.ii&Computation Reports&\hskip .8in\dotfill&12\cr
\+&&&1.D.ii.a&Initial Reports\dotfill&12\cr
\+&&&1.D.ii.b&Iteration Reports\dotfill&13\cr
\+&&&1.D.ii.c&Final Reports\dotfill&14\cr
\+&1.E&Starting Values .&&\dotfill&14\cr
\+&1.F&Weights&\ \dotfill&.\dotfill&15\cr
\+&1.G&Default Values and Structured Arguments&&\hskip 1.5in\dotfill&16\cr
\+&&1.G.i&Optional Arguments and Default Values&\hskip .4in\dotfill&17\cr
\+&&1.G.ii&Structured Arguments&\hskip .8in\dotfill&17\cr
\medskip
\+\bf 2&\bf Using ODRPACK95&&&&\bf 19\cr
\+&2.A&Subroutine Interface and Argument Descriptions&&\hskip 1.1in\dotfill&19
    \cr
\+&&2.A.i&Synopsis&.\dotfill&19\cr
\+&&2.A.ii&ODRPACK95 Subroutine Argument Definitions&\hskip 2.2in\dotfill&20\cr
\+&2.B&Examples&\quad\dotfill&.\dotfill&36\cr
\+&&2.B.i&Example Problem for an Explicit Model&\hskip 1.9in\dotfill&36\cr
\vfil\eject
\+&&&2.B.i.a&User Supplied Code (file {\tt drive1.f})\dotfill&36\cr
\+&&&2.B.i.b&User Supplied Data (file {\tt data1})\dotfill&42\cr
\+&&&2.B.i.c&Report Generated by ODRPACK95 (file {\tt drive1.out})\dotfill&43\cr
\+&&2.B.ii&Example Problem for an Implicit Model&\hskip 1.9in\dotfill&46\cr
\+&&&2.B.ii.a&User Supplied Code (file {\tt drive2.f})\dotfill&46\cr
\+&&&2.B.ii.b&User Supplied Data (file {\tt data2})\dotfill&51\cr
\+&&&2.B.ii.c&Report Generated by ODRPACK95 (file {\tt drive2.out})\dotfill&52\cr
\+&&2.B.iii&Example Problem for an Explicit Model with Multiresponse Data&\hskip 3.5in\dotfill&54\cr
\+&&&2.B.iii.a&User Supplied Code (file {\tt drive3.f})\dotfill&55\cr
\+&&&2.B.iii.b&User Supplied Data (file {\tt data3})\dotfill&61\cr
\+&&&2.B.iii.c&Report Generated by ODRPACK95 (file {\tt drive3.out})\dotfill&62\cr
\+&&2.B.iv&Example Problem for an Explicit Model with Bound Constraints&\hskip 3.5in\dotfill&65\cr
\+&&&2.B.iv.a&User Supplied Code (file {\tt drive4.f})\dotfill&65\cr
\+&&&2.B.iv.b&Report Generated by ODRPACK95 (file {\tt drive4.out})\dotfill&70\cr
\medskip
\+\bf 3&\bf When the Model Is Very Time Consuming&&&&\bf 73\cr
\medskip
\+\bf 4&\bf Computational Details&&&&\bf 76\cr
\+&4.A&Computing the Jacobian Matrices&&\hskip 1.1in\dotfill&76\cr
\+&&4.A.i&``Hand Coded'' Derivatives&\hskip 1.1in\dotfill&76\cr
\+&&4.A.ii&Automatic Differentiation&\hskip 1.1in\dotfill&77\cr
\+&&4.A.iii&Finite Difference Derivatives&\hskip 1.2in\dotfill&78\cr
\+&&&4.A.iii.a&Forward Finite Difference Derivatives\dotfill&78\cr
\+&&&4.A.iii.b&Central Finite Difference Derivatives\dotfill&79\cr
\+&4.B&Covariance Matrix&&\quad\dotfill&79\cr
\+&4.C&Condition Number&&\quad\dotfill&82\cr
\+&4.D&Scaling Algorithms&&\quad\dotfill&83\cr
\+&&4.D.i&Scaling $\beta$&\dotfill&84\cr
\+&&4.D.ii&Scaling $\Delta$&\dotfill&85\cr
\medskip
\+\bf 5&\bf Work Vectors&&&&\bf 86\cr
\+&5.A&Extracting Information from Vector {\tt WORK}&&\hskip 1.5in\dotfill&86\cr
\+&5.B&Extracting Information from Vector {\tt IWORK}&&\hskip
1.5in\dotfill&94\cr
\medskip
\+\bf Bibliography&&&&&\bf 99\cr}
\vfil\eject

\pageno=1
\ \vskip 1.4in
\def\thissection{Getting Started}
\noindent{\capsXIV 1. Getting Started}\bigskip\bigskip

\noindent ODRPACK95 is a portable Fortran 95 code for fitting a model to
data.  Based on the ODRPACK code [Boggs {\it et al.}, 1989], ODRPACK95 adds
support for bound constraints and takes advantage of newer Fortran
95 features.  It is designed primarily for instances when all of
the variables have significant errors (see, e.g., [Fuller, 1987] and
[Boggs and Rogers, 1990]), implementing a highly efficient algorithm
for solving the weighted orthogonal distance regression problem [Boggs
{\it et al.}, 1987 and 1989]. It can also be used to solve the ordinary
least squares problem, however, where all of the errors are attributed
to the observations of only one of the variables.

\noindent We suggest that first time users of ODRPACK95 begin by at least
skimming this chapter, and then proceed to the sample programs given in \S 2.B,
modifying them as necessary to solve their particular problem. The sample
programs are distributed in machine readable form with the ODRPACK95 release, and thus should be available for use as templates without requiring that the user enter the code. The subroutine arguments used in these examples are defined in detail in \S 2.A.ii.

\noindent Chapter 1 presents information that is especially important to first
time users of ODRPACK95. Users are directed to \S 1.A for a brief description of
the orthogonal distance regression problem. This section introduces notation and
provides background material for understanding the remainder of the
documentation. The algorithm itself is described briefly in \S 1.B, and in
greater detail in [Boggs {\it et al.}, 1987 and 1989]. Options available for
specifying the problem are briefly discussed in \S 1.C, and ODRPACK95's report
generation facility is discussed in \S 1.D. The need for good starting values
for the unknown parameters of the model is explained in \S 1.E, and the use of
weights in \S 1.F. Finally, \S 1.G describes two features of ODRPACK95 that simplify the user interface with the package.

\noindent Chapter 2 describes the use of ODRPACK95 in detail. Most
experienced users of ODRPACK95 will only need the information in this
chapter. The declaration and call statement for the ODRPACK95 subroutine
is given in \S 2.A, the subroutine arguments are defined in \S 2.A,
and sample programs are shown in \S 2.B.

\noindent The last three chapters provide auxiliary information. Chapter 3 is
generally only needed by users with very time consuming functions; it explains
how ODRPACK95's features can be exploited in order to minimize cost, and to
reduce the possibility of losing results because limits imposed by their
computer system were reached. Chapter 4 describes the details of certain
ODRPACK95 computations, and Chapter 5 describes how the user can extract computed results from the work vectors.
\bigskip
\noindent{\bf 1.A. Notation and Problem Definition}\medskip
\noindent The method of least squares is often used to find the parameters
$\beta\in\Re^p$ of a mathematical model that defines a relationship between
variables that are subject to errors. When errors occur in more than one of the
variables, then the relationship between the variables is frequently referred to
as a {\it measurement error model\ } or an {\it errors in variables problem}.
The computational problem associated with finding the maximum likelihood
estimators of the parameters of such models is known as {it orthogonal distance
regression}. These models are discussed in [Fuller, 1987], and [Seber and Wild,
1989]. The orthogonal distance regression procedure implemented in ODRPACK95 is reviewed in [Boggs and Rogers, 1990]. That publication also summarizes the results of several simulation studies that compare orthogonal distance regression results to those obtained using ordinary least squares, where the errors are assumed to occur in only one of the variables. (See also [Boggs {\it et al.}, 1988].)

\noindent The model $f$ that defines the relationship between the variables can be either linear or nonlinear in its parameters $\beta$. Sometimes one of the observed variables is distinguished as being a {\it response\ } that is {\it
dependent\ } upon the remaining variables, which are commonly called the {\it explanatory, regressor\ } or {\it independent\ } variables. In these cases, the explanatory variables are often used to predict the behavior of the response variable. In other cases, however, there is no such distinction among the variables.

\noindent We say that there is an {\bf explicit} relationship $f$ between the variables $(x,y)$ if
$$y\approx f(x;\beta)\ ,\eqno (1.1)$$
\noindent where $y$ denotes the response variable, $x$ denotes the explanatory variables, and $y$ is assumed to be only approximately equal to $f(x;\beta)$ because of the measurement errors in $y$ and possibly $x$. When both $x$ and $y$ are observed with error, then the parameters $\beta$ can be found by {\it orthogonal distance regression}. If only $y$ is subject to measurement error, and $x$ is observed without error, then the parameters of such an explicit model can be obtained using {\it ordinary least squares procedures}.

\h{\bf Example:} The model shown in \S 2.B.i, 
$$y_{i}\ \approx\ f_{i}(x_{i};\beta)\ \equiv\ \beta_{1}+\beta_{2}\lbrack
e^{\beta_{3}x_{i}}-1\rbrack^2$$
for $i = 1,\ldots, n,$ which is example 3.2.2 on pages 230--238 of [Fuller, 1987], is an explicit orthogonal distance regression model. In this case, $x$ is the percent saturation of nitrogen gas in a brine solution forced into the pores of sandstone, and $y$ is the observed compressional wave velocity of ultrasonic signals propagated through the sandstone. Here, as in most explicit models, the explanatory variable $x$ is used primarily to predict the behavior of the response variable $y$.\hfill$\square$

\noindent If the relationship between the variables is expressed {\bf implicitly}, then 
$$f(x;\beta)\approx 0\ ,$$
\noindent where here we denote {\it all} of the variables by $x$. Although one
of these variables may still be dependent on the others, when the model is
implicit we do not assume that such a dependent variable can be expressed as an
explicit function of the other explanatory variables as in (1.1). Thus, in the
implicit case the distinction between response and regressor variables is
unnecessary. When the relationship is implicit, then the parameters $\beta$
cannot be estimated by most ordinary least squares procedures, but can be
estimated by orthogonal distance regression procedures such as ODRPACK95.

\h{\bf Example:} One of the simplist examples of an implicit model is that of fitting a circle or ellipse in a plane, as is done in example 3.2.4 on page 244 of [Fuller, 1987]. In this example, shown in \S 2.B.ii, the data are observations digitized from the x-ray image of a hip prosthesis, where the variables $x_{i}=(v_{i},h_{i}), i=1,\ldots, n,$ are the vertical and horizontal distances from the origin, respectively, and the implicit model is that of the ellipse
$$f_{i}(x_{i};\beta)\ \equiv\ \beta_{3}(v_{i}-\beta_{1})^{2}+2\beta_{4}(v_{i}-\beta_{1})(h_{i}-\beta_{2})+\beta_{5}(h_{i}-\beta_{2})^{2}\ \approx\ 0$$
for $i=1,\ldots, n.\hfill\square$

\noindent Sometimes the observations are {\bf multiresponse} and thus must satisfy more than one relationship $f$. This most commonly arises when the observations are complex variables, although it can occur in other cases as well.

\h{\bf Example:} The problem shown in \S
2.B.iii is an example of multiresponse data that originates because the underlying data are complex. The problem is described in Chapter 4, and on pages 280--281, of [Bates and Watts, 1988]. In this case, the response variable is the pair of values representing the real and imaginary parts of complex-valued impedance measurements, $z_{i},\ i=1,\ldots, n,$ of a polymer, and the explanatory variable, $x_{i},\ i=1,\ldots, n,$ is the (real-valued) frequency. The function is explicit, representing the dielectric constant by a general model proposed in [Havriliak and Negami, 1967],
$$z_{i}\approx\beta_{2}+{{\beta_{1}-\beta_{2}}\over{\bigl(1+(\jmath2\pi x_{i}e^{-\beta_{3}})^{\beta_{4}}\bigr)^{\beta_{5}}}}$$
for $i=1,\ldots, n,$ where $\jmath=\sqrt{-1}$. For ODRPACK95, this must be encoded as a two-term multiresponse problem with $y_{i}\in\Re^{2}$ representing the pair of values $[\Re(z_{i}),\Im(z_{i})],
i=1,\ldots, n.\hfill\square$

\noindent Finally, sometimes parameters have physical or logical bounds
constraining the search space.  This problem arises frequently in chemical
kinetic models where rates of chemical reactions are represented by
parameters.  A change in the sign of a parameter represents a qualitative
change in the model usually violating empirical observations.  In systems
biology chemical kinetic models of proteins can be very complex and
empirical data very noisy.  [Zwolak et al. 2005] found it necessary to
constrain parameters and did so by manually fixing parameters while using
the original ODRPACK.

\h{\bf Example:} The problem shown in \S 2.B.iv is taken from Zwolak
et al.  (2001).  They use a simple phenomenological model of MPF (mitosis
promoting factor) activity in frog egg extracts.  In this model MPF
activity $M$ remains low for some time and eventually activates at a
time $t$ (the timelag) dependent on the total cyclin concentration $C$ (the
independent variable).  The model has three kinetic parameters
(or rates): $k_{wee}$, $k_{25}$, and $k_{25}'$ (all of which are constrained
with a lower bound of 0).  MPF activity $M$ is defined as
the ordinary differential equation
$$
{dM \over dt} = -k_{wee}M+(k_{25}+k_{25}'M^2)(C-M).
$$
The data are in pairs $(C,t)$ where $C$ is the independent variable and $t$ is 
the dependent variable.  MPF is defined as
``active'' when half the total cyclin (a component of MPF in both active and
inactive forms) is in active MPF molecules.  This inverse function defining the
relationship between the timelag and total cyclin can be defined as
$$
t = M^{-1}(C / 2; k_{wee}, k_{25}, k_{25}'),
$$
where $k_{wee}$, $k_{25}$, and $k_{25}'$ are included because $M$ is dependent
on these rate constants.
The function given to ODRPACK95 becomes
$$
f_i(x_i;\beta) \equiv M^{-1}(x_i/2; \beta_1, \beta_2, \beta_3).
$$
for $i=1,\ldots, n.\hfill\square$

\noindent The explicit, implicit, multiresponse, and constrained problem
types are described in greater detail in the following sections. They
are each easily solved using ODRPACK95. The solution procedures required
for single and multiresponse data are essentially the same, although, as
noted below, ODRPACK95 does need to know that the data are multiresponse
rather than single response in order to find the correct solution. The
solution procedures required for explicit and implicit functions,
however, are different, with the implicit relationships generally
costing more to solve. (See \S 1.B.) The constrained and unconstrained
problem types are treated identically in ODRPACK95; when the problem
is ``unconstrained'' ODRPACK95 puts bounds on the parameters at the
limits of the machine numbers (Fortran 95 {\tt HUGE} and {\tt -HUGE}).
For constrained problems the user need only specify bounds different from
the defaults. It is important that users be aware of the differences
between explicit and implicit models, between single and multiresponse
data, and between constrained and unconstrained parameters, and invoke
ODRPACK95 appropriately for their particular model and data type.
\bigskip
\noindent{\bf 1.A.i. Explicit Orthogonal Distance Regression} 
\medskip
\noindent We define the explicit orthogonal distance regression problem as follows. Let $(x_{i},y_{i}),
i=1,\ldots, n$, be an observed set of data, where, for simplicity, we assume that $x_{i}\in\Re^{1}$ and $y_{i}\in\Re^{1}$. (For a discussion of the orthogonal distance regression problem for higher dimensional data, see \S 1.A.iii.) Suppose that the values of $y_i$ are a possibly nonlinear function of $x_i$ and a set of unknown parameters $\beta\in\Re^p$, but that both the $x_i$ and the $y_i$ contain actual but unknown errors $\delta^{*}_{i}\in\Re^1$ and
$\epsilon^{*}_{i}\in\Re^1$, respectively, where here, and in the remainder of this document, we use a superscript ``$\ast$'' to denote such actual but unknown quantities. Then the observed value of $y_i$ satisfies
$$y_{i}=f_{i}(x_{i}+\delta^{*}_{i};\beta^{*})-\epsilon^{*}_{i}\qquad
i=1,\ldots, n,$$
for some actual but again unknown value $\beta^*$.

\noindent The explicit orthogonal distance regression problem is to approximate $\beta^*$ by finding the $\beta$ for which the sum of the squares of the $n$ orthogonal distances from the curve $f(x;\beta)$ to the $n$ data points is minimized. This is accomplished by the minimization problem 
$$\min_{\beta,\delta,\epsilon}\sum^{n}_{i=1}(\epsilon^{2}_{i}+\delta^{2}_{i})\eqno(1.2)$$
subject to the constraints
$$y_{i}=f_{i}(x_{i}+\delta_{i};\beta)-\epsilon_{i}\qquad i=1,\ldots,
n.\eqno(1.3)$$
Since the constraints (1.3) are linear in $\epsilon_{i}$, we can eliminate them and thus the $\epsilon_{i}$ from (1.2), thereby obtaining
$$\min_{\beta,\delta}\sum^{n}_{i=1}\bigl([f_{i}(x_{i}+\delta_{i};\beta)-y_{i}]^{2}+\delta^{2}_{i}\bigr)\ .\eqno(1.4)$$
We then generalize (1.4) to the weighted orthogonal distance regression (ODR) problem
$$\min_{\beta,\delta}\sum_{i=1}^{n}\bigl(w_{\epsilon_{i}
}[f_{i}(x_{i}+\delta_{i};\beta)-y_{i}]^{2}+w_{\delta_{i}}\delta^{2}_{i}\bigr)\eqno(1.5)$$
by introducing the weights $w_{\epsilon_{i}}\in\Re^{1}$ and
$w_{\delta_{i}}\in\Re^{1}, i=1,\ldots, n$, which are sets of nonnegative numbers. The weights $w_{\epsilon_{i}}$ and $w_{\delta_{i}}$ can thus be used to compensate for instances when the $y_i$ and $x_i$ have unequal precision, or when there are observations that should be eliminated from the analysis. (See \S 1.F.)

\bigskip\noindent{\bf 1.A.ii. Implicit Orthogonal Distance Regression}\noindent 
\medskip
\noindent The univariate implicit orthogonal distance regression problem arises from the assumption that there is no distinguished variable $y$ and thus that the data must satisfy
$$f_{i}(x_{i}+\delta_{i}^{*};\beta^{*})=0\qquad i=1,\ldots,n.$$
For $x_{i}\in\Re^1$, this yields the minimization problem
$$\displaylines{\min_{\beta,\delta}\sum_{i=1}^{n}w_{\delta_{i}}\delta_{i}^2\cr
\hfill\llap(1.6)\cr
{\rm subject\ to}\quad f_{i}(x_{i}+\delta_{i};\beta)=0\quad i=1,\ldots,n,\cr}$$
where $w_{\delta_{i}}\in\Re^{1},i=1,\ldots,n$, again denotes a set of positive numbers used for weighting. (See \S 1.F.) The constraints in (1.6) are not assumed to be linear in $\delta_i$, and therefore cannot be eliminated to create an unconstrained problem as was done above to specify the explicit problem (1.4). The implicit orthogonal distance regression problem must therefore be solved differently than the explicit problem. (See \S 1.B.)\bigskip

\noindent{\bf 1.A.iii. Orthogonal Distance Regression for Multidimensional Data}
\medskip
\noindent For simplicity, the preceding two sections developed the explicit and
implicit orthogonal distance regression problem for univariate data,
i.e., for $x_{i}\in\Re^1$ and $y_{i}\in\Re^1$ with
$f_{i}:\Re^{p+1}\rightarrow\Re^1$. In this section, we generalize these problems to allow for multivariate explanatory data $x_{i}\in\Re^{m}, m\ge1$, and multiresponse dependent variables $y_{i}\in\Re^{q},q\ge1$, which are modeled by
$f_{i}:\Re^{p+m}\rightarrow\Re^q$. For such higher dimensional data, the errors $\delta_{i}\in\Re^m$ associated with $x_i$, and the errors
$\epsilon_{i}\in\Re^q$ associated with $y_i$, can be weighted by $w_{\delta_{i}}\in\Re^{m\times m}$ and $w_{\epsilon_{i}}\in\Re^{q\times q},i=1,\ldots,n$,
respectively, where the $w_{\delta_{i}}$ must be positive definite matrices and the $w_{\epsilon_{i}}$ must be positive semidefinite matrices.
\footnote{$^1$}{\rmVIII The
matrix $A$ is {\itVIII positive definite} if and only if $A^{T}=A$, and
$a^{T}Aa>0$ for all nonzero vectors $a$. It is {\itVIII positive 
semidefinite} if and only if $A^{T}=A$, and $a^{T}Aa\ge0$ for all vectors
$a$. When $A$ is positive definite or positive semidefinite, then there
is an upper triangular matrix $U$ such that $A=U^{T}U$. ODRPACK95 checks
for positive (semi)definiteness by attempting to form $U$.}

\noindent For the explicit problem, we assume that the $q$ responses of the observed values of $y_i$ satisfies
$$y_{i}=f_{i}(x_{i}+\delta_{i}^{*};\beta^{*})-\epsilon_{i}^{*}\qquad
i=1,\ldots,n,$$ for some actual, but unknown value $\beta^{*}$. Thus, if we let $X\in\Re^{n\times m}$ and $Y\in\Re^{n\times q}$ denote the arrays with $i$th row $x_i$ and $y_i$, respectively, and $\Delta\in\Re^{n\times m}$ and $E\in\Re^{n\times q}$ denote the arrays with $i$th row $\delta_i$ and $\epsilon_i$, respectively, we are then assuming that the observed values $X$ and $Y$ satisfy
$$\displaylines{X\ =\ X^{*}-\Delta^{*}\cr
Y\ =\ Y^{*}-E^{*},\cr}$$
and that the estimated values, which we denote by a ``hat,'' will satisfy
$$\displaylines{\hat{X}\ =\ X+\hat{\Delta}\cr
\hat{Y}\ =\ Y+\hat{E}.\cr}$$
Generalizing the problem presented in \S 1.A.i, the {\it explicit multiresponse orthogonal distance regression problem for multivariate explanatory data} is defined as
$$\displaylines{\min_{\beta,\delta,\epsilon}\sum_{i=1}^{n}([\epsilon_{i}^{T}w_{\epsilon_{i}}\epsilon_{i}]+[\delta_{i}^{T}w_{\delta{i}}\delta_{i}])\cr
\hfill\llap(1.7)\cr
{\rm subject\ to}\quad\left.\matrix{Y_{i1}=f_{i1}(x_{i}+\delta_{i};\beta)-E_{i1}\cr
Y_{i2}=f_{i2}(x_{i}+\delta_{i};\beta)-E_{i2}\cr
\vdots\hfill\cr
Y_{iq}=f_{iq}(x_{i}+\delta_{i};\beta)-E_{iq}\cr}\right\}\quad i=1,\ldots,n,\cr}$$
where subscript $il$ denotes the $(i,l)$th element of the corresponding array, e.g., $Y_{il}$ denotes the $l$th response of the $i$th observation, and
$f_{il}(x_{i}+\delta_{i};\beta)$ denotes the model for the $l$th
response of observation $i$. Because the constraints in (1.7) are linear
in $E$, this is equivalent to the problem
$$\min_{\beta,\delta}\sum_{i=1}^{n}([f_{i}(x_{i}+\delta_{i};\beta)-y_{i}]^{T}w_{\epsilon_{i}}[f_{i}(x_{i}+\delta_{i};\beta)-y_{i}]+\delta_{i}^{T}w_{\delta_{i}}\delta_{i})=\min_{\beta,\delta}S(\beta,\delta)\ ,\eqno(1.8)$$
where we define the {\it weighted sum of squares} $S(\beta,\delta)$ by
$$S(\beta,\delta)\equiv S_{\epsilon}(\beta,\delta)+S_{\delta}(\beta,\delta)$$
with
$$S_{\epsilon}(\beta,\delta)\equiv\sum_{i=1}^{n}([f_{i}(x_{i}+\delta_{i};\beta)-y_{i}]^{T}w_{\epsilon_{i}}[f_{i}(x_{i}+\delta_{i};\beta)-y_{i}])$$
and
$$S_{\delta}(\beta,\delta)\equiv\sum_{i=1}^{n}(\delta_{i}^{T}w_{\delta_{i}}\delta_{i})\ .$$
The {\it implicit multiresponse orthogonal distance regression problem for multivariate explanatory data} is
$$\displaylines{\min_{\beta,\delta}\sum_{i=1}^{n}[\delta_{i}^{T}w_{\delta_{i}}\delta_{i}]=\min_{\beta,\delta}S_{\delta}(\beta,\delta)\cr
\hfill\llap(1.9)\cr
{\rm subject\ to}\qquad\left.\matrix{f_{i1}(x_{i}+\delta_{i};\beta)=0\cr
f_{i2}(x_{i}+\delta_{i};\beta)=0\cr
\vdots\hfill\cr
f_{iq}(x_{i}+\delta_{i};\beta)=0\cr}\right\}\qquad i=1,\ldots,n\ .\cr}$$
As was the case in \S 1.A.ii, the constraints in (1.9) are not assumed to be linear in $\delta_i$, and therefore cannot be eliminated to create an unconstrained problem as was done above to specify the explicit problem (1.8). The implicit orthogonal distance regression problem must therefore be solved differently than the explicit problem. (See \S 1.B.)

\noindent Note that when $q>1$, the responses of a multiresponse orthogonal
distance regression problem cannot simply be treated as $q$ separate
observations as can be done for ordinary least squares when the $q$ responses
are uncorrelated. This is because ODRPACK95 would then treat the variables associated with these $q$ observations as unrelated, and thus not constrain the errors $\delta_i$
in $x_i$ to be the same for each of the $q$ occurrences of the $i$th
observation. The user must therefore indicate to ODRPACK95 when the observations
are multiresponse, so that ODRPACK95 can make the appropriate adjustments to the estimation procedure. (See \S 2.A.ii, subroutine argument {\tt NQ}.)

\bigbreak\noindent{\bf 1.A.iv. Orthogonal Distance Regression with Bound
Constraints}
\noindent 
\nobreak
\medskip
\noindent Bound constraints can be applied to the parameters in any of the 
cases mentioned above and seen in equations (1.2)--(1.3), (1.6), (1.7), and 
(1.9).  Using equations (1.2)--(1.3), the bound constrained problem is defined 
as
$$
\displaylines{
\min_{\beta,\delta,\epsilon}\sum^{n}_{i=1}(\epsilon^{2}_{i}+\delta^{2}_{i})\cr
\hfill\llap(1.10)\cr
\matrix{{\rm subject\ to}\quad&
y_{i}=f_{i}(x_{i}+\delta_{i};\beta)-\epsilon_{i}&\qquad i=1,\ldots, n,\cr
{\rm and}\quad&L_j\le \beta_j \le U_j&\qquad j=1,\ldots,p,\cr
}\cr
}
$$
where $L_j\in\Re^1$ and $U_j\in\Re^1$ and are defined by the
user as the lower and upper bound, respectively, on parameter $\beta_j$
for $j=1,\ldots,p$.

\bigskip\noindent{\bf 1.B. Algorithm}
\medskip
\noindent The algorithm implemented in ODRPACK95 is described in [Boggs
{\it et al}., 1987 and 1989] and [Zwolak et al. 2006]. Briefly, the
solution is found iteratively using a trust region Levenberg-Marquardt
method with bound constraints and scaling (used to accommodate
problems in which estimated values have widely varying magnitudes). The
Jacobian matrices, i.e., the matrices of first partial derivatives of
$f_{il}(x_{i}+\delta_{i};\beta), i=1,\ldots,n$, and $l=1,\ldots,q$,
with respect to each component of $\beta$ and $\Delta$, are computed
at every iteration either by finite differences or by a user supplied
subroutine, as specified by subroutine argument {\tt JOB} (see \S 2.A.ii,
and also \S 4.A).  These are used to calculate the step, which is
projected inside the bounds, for the current iterate.  The iterations
are stopped when any one of three stopping criteria are met. Two of
these indicate the iterations have converged to a solution. These are
{\it sum of squares convergence}, which indicates that the change in the
weighted sum of the squared observation errors is sufficiently small,
and {\it parameter convergence}, which indicates the change in the
estimated values of $\beta$ and $\Delta$ is sufficiently small. The
third stopping criterion is a limit on the number of iterations.

\noindent ODRPACK95 finds the solution of an implicit orthogonal distance regression problem using the classic quadratic penalty function method. The {\it
penalty function} is
$$P(\beta,\delta;r_{k})=\sum_{i=1}^{n}(r_{k}[f_{i}(x_{i}+\delta_{i};\beta)]^{T}[f_{i}(x_{i}+\delta_{i};\beta)]+[\delta_{i}^{T}w_{\delta_{i}}\delta_{i}])\
,\eqno(1.11)$$
with {\it penalty term}
$$\sum_{i=1}^{n}r_{k}[f_{i}(x_{i}+\delta_{i};\beta)]^{T}[f_{i}(x_{i}+\delta_{i};\beta)]$$
and {\it penalty parameter} $r_k$. A sequence of unconstrained minimization problems
$$\min_{\beta,\delta}P(\beta,\delta;r_{k})$$
is then solved for a sequence of values of the penalty parameter $r_k$ tending to $\infty$. These problems are equivalent to an explicit orthogonal distance regression problem with $\epsilon_{i}\equiv f_{i}(x_{i}+\delta_{i};\beta)\
.$ As $r_{k}\rightarrow\infty,\epsilon_{i}\rightarrow 0,i=1,\ldots,n$, and the
solution to (1.11) will approach that of the implicit problem defined by (1.9). See, e.g., [Gill {\it et al.}, 1981] for further discussion of penalty function methods.

\bigskip\noindent{\bf 1.C. Specifying the Task}
\medskip
\noindent The user has the option of specifying several different aspects of the problem:
\item{1.} whether the fit is to be by explicit or implicit orthogonal distance regression, or by ordinary least squares (see \S 1.A);
\item{2.} whether the necessary Jacobian matrices should be approximated by
ODRPACK95 using forward or central finite differences, or whether the user has supplied the code to compute them, and, if such code has been provided by the user, whether it should be checked (see \S 4.A);
\item{3.} whether the covariance matrix $V_\beta$ and standard deviations $\sigma_\beta$ should be computed for the estimators of $\beta$, and whether the Jacobian matrices should be recalculated at the solution for this computation (see \S 4.B);
\item{4.} whether the errors $\Delta$ have been initialized by the user (see \S 1.E, and \S 2.A.ii, subroutine arguments {\tt JOB} and {\tt WORK});
\item{5.} whether the fit is a ``restart,'' i.e., whether the fit will use information preserved in the vectors {\tt BETA, WORK} and {\tt IWORK} to continue from a previously found point (see Chapter 3);
\item{6.} whether the data are multiresponse or not;
\item{7.} whether subsets of the unknowns $\beta$ and $\Delta$  should be treated as constants with their values held ``fixed,'' allowing the user to examine the results obtained by estimating subsets of the parameters of a general model without rewriting the model subroutine, and allowing the user to specify that some components of $X$ are to be treated as if they are known exactly;
\item{8.} whether weighted or unweighted analysis should be performed (see \S 1.F);
\item{9.} whether the unknowns $\beta$ and $\Delta$  should be scaled to
compensate for cases where their values vary widely in magnitude (see \S 4.D);
and
\item{10.} which, if any, of the parameters $\beta$ are bound and values of the
lower and upper bounds.

\noindent The first 5 of these options are specified by ODRPACK95
subroutine argument JOB; multiresponse data are indicated by subroutine
argument {\tt NQ}; parameter ``fixing'' is specified by subroutine
arguments {\tt IFIXB} and {\tt IFIXX}; weighting is controlled by
arguments {\tt WE} and {\tt WD}; scaling is controlled by arguments
{\tt SCLB} and {\tt SCLD}; and bound constraints are controlled by arguments
{\tt LOWER} and {\tt UPPER}. A detailed discussion of each of these
subroutine arguments can be found in \S 2.A.ii.

\bigskip\noindent{\bf 1.D. ODRPACK95 Generated Results}
\medskip
\noindent Results generated by ODRPACK95 are returned to the user in four ways:
\item{$\bullet$} the estimated parameter values $\hat{\beta}$ are returned in subroutine argument {\tt BETA};
\item{$\bullet$} the stopping condition is returned in subroutine argument {\tt INFO}; 
\item{$\bullet$} the computed results available at the time the job stopped are returned in the vectors specified by subroutine arguments {\tt WORK} and {\tt IWORK}; and
\item{$\bullet$} selected results are summarized in automatically generated reports.

\noindent Arguments {\tt BETA, INFO, WORK} and {\tt IWORK} are discussed in
detail in \S 2.A.ii. The remainder of this section describes ODRPACK95's automatically generated reports.

\noindent ODRPACK95 can generate two different types of reports. The first is an {\it error report}, and the second is a {\it computation report}. These are written to the logical units specified by subroutine arguments {\tt LUNERR} and {\tt LUNRPT}, respectively. The user can associate these units with a file using a Fortran {\tt OPEN} statement. If the user sets one or the other of these units to a negative value, then the corresponding report will be generated on unit 6. On most systems, unit 6 is ``standard output,'' which for an ``interactive'' run will be the screen. If the user sets one or the other of these units to 0, then generation of the corresponding report is suppressed.

\noindent ODRPACK95's computation reports (see \S 1.D.ii below) can, at the
user's option, be written simultaneously to both the file associated with the
unit specified by {\tt LUNRPT} and to unit 6 (assuming {\tt LUNRPT} does not
specify unit 6). This option, invoked by ODRPACK95 subroutine argument {\tt
IPRINT}, enables the user to monitor ODRPACK95's progress interactively while
still preserving the results in a file for future reference. The option is
especially useful when the user's model is time consuming and the user is
interactively experimenting with starting values and other ODRPACK95 options: results printed to the screen can be used to terminate ineffective or incorrect runs, while results stored on the logical unit specified by {\tt LUNRPT} can be used to preserve the successful experiments.

\bigskip\noindent{\bf 1.D.i. Error Reports}
\medskip
\noindent Error reports identify incorrect user supplied information passed to
ODRPACK95 that prevents the computations from beginning. For example, an error report will be generated if the user specifies the number of observations to be an obviously meaningless number, such as a negative value. Error reports are self explanatory, and are not discussed further here. The information written in the error reports is also encoded and returned to the user in subroutine argument {\tt INFO}. (See \S 2.A.ii.)

\bigskip\noindent{\bf 1.D.ii. Computation Reports}
\medskip
\noindent Computation reports are divided into three sections:
\item{\bf a.} the initial report,
\item{\bf b.} the iteration report, and
\item{\bf c.} the final report.

\noindent Each of these can be either ``short'' or ``long''.

\bigskip\noindent{\bf 1.D.ii.a. Initial Reports}
\medskip
\noindent ODRPACK95's initial report identifies the output for future reference, and provides information that should enable the user to verify that the problem was specified correctly.

\noindent The {\it short initial report} is shown in \S 2.B.i.c. It includes
\item{$\bullet$} the values $n, m, p$ and $q$, the number $\tilde{n}$ of observations with nonzero weights, and the number $\tilde{p}$ of parameters $\beta$ actually being estimated;
\item{$\bullet$} the values specified by ODRPACK95 subroutine arguments {\tt JOB, NDIGIT, TAUFAC, SSTOL, PARTOL,} and {\tt MAXIT}, that indicate, respectively, the requested task, the number of ``good'' digits in the user's function results, the stopping criteria for testing for sum of squares convergence, the stopping criteria for testing for parameter convergence, and the maximum number of iterations permitted; and
\item{$\bullet$} the weighted sum of the squared errors $S(\beta,\delta),\ S_{\delta}(\beta,\delta),\ S_{\epsilon}(\beta,\delta)$, evaluated at the initial values of $\beta$ and $\Delta$.

\noindent The {\it long initial report}, shown in \S 2.B.ii.c and \S 2.B.iii.c, includes all the information in the short initial report and, in addition, includes a brief summary of the information specified for the function parameters $\beta$, and also information about the user supplied values for the $X$ and $Y$ data. This information includes
\item{$\bullet$}the starting parameter values $\beta_{k},k=1,\ldots,p$,
whether or not each parameter is to be treated as ``fixed'', what
``scale'' value will be used, the lower and upper bounds, and, when the
derivatives are constructed using finite differences the step size used
in that calculation, or when the user supplied derivatives were checked
what derivatives were identified as questionable;
\item{$\bullet$} the value of the first and last observation of each column of the explanatory variable $X$, and when the solution is found by orthogonal distance regression, 
\itemitem{$\circ$} the starting errors $\Delta$ for each of these observations,
\itemitem{$\circ$} whether or not these values will be held fixed at their input values,
\itemitem{$\circ$} the scale values,
\itemitem{$\circ$} the diagonal elements of the weights $w_{\delta_{i}}$ associated with each of these observations, and
\itemitem{$\circ$} when the derivatives are constructed using finite differences the step size used in that calculation, or when the user supplied derivatives were checked what derivatives were identified as questionable;
\item{$\bullet$} the value of the first and last observation of the response variable $Y$, and the value of the corresponding diagonal entries of the error weights $w_{\epsilon_{i}}$.

\noindent{\bf 1.D.ii.b. Iteration Reports}
\medskip\noindent The ODRPACK95 iteration reports enable the user to monitor the progress of the fitting procedure, where the user controls at which iterations these reports will be generated.

\noindent ODRPACK95 iteration reports are of the greatest use in cases when
ODRPACK95 fails to find a satisfactory solution. In cases when ODRPACK95 does reach a satisfactory solution, the {\it final report} discussed below summarizes the most useful information.

\noindent The {\it short iteration report}, shown in \S 2.B.i.c, is a one line summary of the results, listing
\item{$\bullet$} the iteration number;
\item{$\bullet$} the cumulative number of function evaluations made by the end of the listed iteration;
\item{$\bullet$} the weighted sum of the squared observation errors $S(\beta,\delta)$ at the current point;
\item{$\bullet$} the actual relative reduction in $S(\beta,\delta)$ at the most recently tried step (used to check for sum of squares convergence);
\item{$\bullet$} the predicted relative reduction in $S(\beta,\delta)$ at the most recently tried step (used to check for sum of squares convergence);
\item{$\bullet$} the ratio of the trust region radius to the scaled norm of $\beta$ and $\Delta$, which is an upper bound on the relative change in the estimated values possible at the next step (used to check for parameter convergence); and
\item{$\bullet$} whether the step was a Gauss-Newton step.

\noindent The {\it long iteration summary} lists all of the information found in the short iteration summary and, in addition, includes
\item{$\bullet$} the values of $\beta$ at the end of the current iteration. (At the last iteration, the values listed will be those that produced the actual and predicted relative reductions shown only if the most recently tried step did in fact make the fit better. If not, then the values of $\beta$ listed are those that produced the best fit.)

\noindent The long iteration report requires 125 columns, and uses $\lceil
p/3\rceil$ lines per iteration.

\bigskip\noindent{\bf 1.D.ii.c. Final Reports}
\medskip
\noindent The final report provides information that allows the user to assess
the quality of the solution found by ODRPACK95.

\noindent The {\it short final report}, shown in \S 2.B.ii.c and \S 2.B.iii.c, includes
\item{$\bullet$} the reason the computations stopped;
\item{$\bullet$} the number of iterations;
\item{$\bullet$} the number of function evaluations and, if the Jacobian was supplied by the user, the number of Jacobian evaluations;
\item{$\bullet$} the rank deficiency of the model at the time the computations stopped;
\item{$\bullet$} the inverse of the condition number of the problem at the time the computations stopped (see \S 4.C);
\item{$\bullet$} the weighted sum of the squared errors,
$S(\beta,\delta),\ S_{\delta}(\beta,\delta)$, and $S_{\epsilon}(\beta,\delta)$, evaluated at the final values $\hat{\beta}$ and $\hat{\Delta}$, and if the covariance matrix was computed, the estimated residual variance of the fit and its associated degrees of freedom; and
\item{$\bullet$} the final values $\hat{\beta}$, whether each value was
``fixed'' using subroutine argument {\tt IFIXB} or ``dropped'' by ODRPACK95
because it induced rank deficiency, the lower and upper bounds, and,
if the covariance matrix $\hat{V}_\beta$ and standard deviations
$\hat{\sigma}_\beta$ were computed, the standard errors and 95\%
confidence intervals for the estimators of $\beta$. (See \S 4.B).

\noindent The {\it long final report} is shown in \S 2.B.i.c. It includes the same information as the short final report, and, in addition, provides the values for all $\hat{E}_{il},i=1,\ldots,n,\ l=1,\ldots,q$, and
$\hat{\Delta}_{ij},i=1,\ldots,n,\ j=1,\ldots,m$.

\bigskip\noindent{\bf 1.E. Starting Values}
\medskip
\noindent The user must supply starting values for the unknowns being estimated, i.e., for $\beta$ and $\Delta$. Users familiar with the nonlinear ordinary least squares problem are generally aware of the importance of obtaining good starting values for $\beta$. It is equally important here. Good initial approximations can significantly decrease the number of iterations required to find a solution; a poor initial approximation may even prevent a solution from being found. Reasonable initial approximations are often available from previous analysis or experiments. When good starting values are not readily available, the user may have to do some preliminary analysis to obtain them. (See, e.g., [Bates and Watts, 1988], or [Himmelblau, 1970].)

\noindent Users who do not provide scale information are strongly encouraged not to use zero as an initial approximation for any of the parameters $\beta$ since a zero value can result in incorrect scaling. (See \S 4.D). Setting the initial approximation to the largest magnitude that, for the user's problem, is effectively zero, rather than to zero, will help to eliminate scaling problems and possibly produce faster convergence. For example, if $\beta_1$ represents change in a cost measured in millions of dollars, then the value 10 might be considered ``effectively zero'' and an initial value of $\beta_{1}^{0}=10$ is preferable to
$\beta_{1}^{0}=0$.

\noindent When using orthogonal distance regression it is also important to have
good starting values for the estimated errors $\Delta$. The ODRPACK95 default is to initialize $\Delta$ to zero, which is the most obvious initial value. (Note that zero starting values for $\Delta$ do not cause scaling problems similar to those discussed above for $\beta$.) Initializing $\Delta$ to zero, however, is equivalent to initially assigning all of the errors to the dependent variable as is done for ordinary least squares. While this is quite adequate in many cases, in others it is not. A plot of the observed data and of the curve described by the model function for the initial parameters may indicate whether or not zero starting values for $\Delta$ are reasonable and may make it possible to visually determine better starting values for some of the $\Delta_ij$. For example, if such a plot shows that the vertical distance from a data point $(x_{i},y_{i})$ to the curve is far larger than the orthogonal distance, then $\delta_i$ should probably not be initialized to zero for that point. This may occur near an asymptote or near a local minimum or maximum. In such cases, it is often appropriate to initialize $\delta_i$ to the horizontal distance from the data point to the curve. (See \S 2.A.ii, subroutine arguments {\tt JOB} and {\tt WORK}.)

\bigskip\noindent{\bf 1.F. Weights}
\medskip
\noindent Weights can be used to eliminate observations from the analysis, to compensate for unequal variances or correlations in the variables $y$ and $x$, or simply to modify the effect of the various errors $\epsilon$ and $\delta$ on the fit.

\noindent The weights $w_{\epsilon_{i}}\in\Re^{q\times q}$ associated
with $\epsilon_{i},i=1,\ldots,n$, must be positive semidefinite
matrices, and the weights $w_{\delta_{i}}\in\Re^{m\times m}$
associated with $\delta_{i},i=1,\ldots,n$, must be positive definite
matrices.\footnote{$^2$}{\rmVIII See footnote 1 on page 7.} If
$w_{\epsilon_{i}}$ is diagonal, then the errors in the $q$ responses
of $y_i$ are treated as uncorrelated. Similarly, if $w_{\delta_{i}}$
is diagonal, then the errors in the $m$ elements of $x_i$ are treated
as uncorrelated. When the weights are not diagonal matrices, then the
errors {\it within} an observation are treated as correlated. In all
cases, however, the errors {\it between} observations are treated as
{\it uncorrelated}.

\noindent Observations can be eliminated from the analysis by setting the
appropriate weight values $w_{\epsilon_{i}}$ to zero. This will produce the same
results as an analysis with the zero-weighted values removed from the data prior
to calling ODRPACK95. Zero weights can be used to allow for cases of multiresponse data where the number of responses is not constant for all observations. They also allow for easy examination of the effect of outliers and influential data points.

\noindent Outliers can often be identified by large values of $\epsilon$ and/or $\delta$. Careful checking of the data often leads to confirmation that the data are in error, and sometimes to a correction. When a cause for suspicious data cannot be found, it may be advisable to compare the analysis with and without the questionable data. Caution is in order if the estimates or conclusions are highly sensitive to a small amount of suspicious data. Data that have a very high influence on a fitted curve may not result in large errors, however, even if they are in error. In fact, extremely influential observations may force the fitted curve to be very close, leading to very small residuals. It is therefore desirable to identify influential observations and to compare the results obtained with and without these points. Several methods for detecting influential observations for ordinary least squares are discussed in [Belsley {\it et al.}, 1980], [Bement and Williams, 1969], [Cook, 1977], and [Hoaglin and Welsch, 1978].

\noindent Using weights to compensate for unequal error variances is not as straightforward as using zero weights to eliminate observations from the analysis. When the errors $e_{i},\ i=1,\ldots,n$, and $\delta_{i},\ i=1,\ldots,n$, have covariances $\sigma_{e_{i}}^{2}\in\Re^{q\times q}$ and $\sigma_{\delta_{i}}^{2}\in\Re^{m\times m}$, respectively, that are {\it known}, then the weights can be set using
$$w_{\epsilon_{i}}=c_{1}\sigma_{e_{i}}^{-2}\qquad {\rm and}\qquad
w_{\delta_{i}}=c_{2}\sigma_{\delta_{i}}^{-2}\ ,$$
$i=1,\ldots,n$, where $c_1$ and $c_2$ are constants selected so that the magnitudes of the weighted errors
$\epsilon_{i}^{T}w_{\epsilon_{i}}\epsilon_{i}$ and
$\delta_{i}^{T}w_{\delta_{i}}\delta_{i}$ will be approximately the same.

\noindent In practice, weights are often derived from theory or obtained from the data being fit. Users must be aware that incorrectly specified weights can adversely affect the results. (See, e.g., [Boggs and Rogers, 1990a].) Thus, when the need for weights is suspected and the error covariances are not known, it is extremely important to analyze how the weights are affecting the computed results. See [Fuller, 1987] for a more complete discussion of weights and their implications for the estimation of the parameters of measurement error models, and also [Bates and Watts, 1988] for a procedure that can be used to estimate the covariance matrix $\sigma_{e_{i}}^{2}$ in the case of multiresponse nonlinear ordinary least squares.

\bigskip\noindent{\bf 1.G. Default Values and Structured Arguments}
\medskip 
\noindent ODRPACK95 uses optional arguments, default values and structured
arguments to simplify the user interface. The availability of default
values in ODRPACK95 means that the user does not have to be concerned
with determining values for many of the ODRPACK95 arguments unless the
problem being solved requires the use of nondefault values. Structured
arguments, described below, can reduce the amount of storage space
required for some arguments, and the work required by the user to
initialize those arguments.

\bigskip\noindent{\bf 1.G.i. Optional Arguments and Default Values}
\medskip
\noindent Default values have been specified for ODRPACK95 subroutine
arguments wherever reasonable. These default values are invoked when the
user sets the corresponding argument to any negative value or leaves the
argument out of the subroutine call. Arrays with default values are
invoked by setting the first element of the array to a negative value
(in which case only the first value of the array will ever be used)
or leaving the array argument out of the subroutine call.  Setting arguments to
negative values to invoke the defaults remains for backwards compatibility with
old code and easy user migration from ODRPACK to ODRPACK95.  For readability
users are encouraged to remove unused arguments from the subroutine call.

\noindent {\it Users are encouraged to invoke the default values of arguments wherever possible.} These values have been found to be reasonable for a wide class of problems. Fine tuning these arguments can then be done later if necessary.

\bigskip\noindent{\bf 1.G.ii. Structured Arguments}
\medskip
\noindent Certain ODRPACK95 arguments specify attributes of the individual components of $X,\ \Delta$, and $Y$. These attribute arrays are frequently either constant for all components or are constant within each column and vary only between the columns. The {\it structured argument} facility allows a scalar to specify an attribute of an entire column or of the whole array.

\noindent For example, ODRPACK95 argument {\tt WD} specifies the attribute array of weights $W_{\Delta}\in\Re^{n\times(m\times m)}$ whose $i$th component specifies the elements of $w_{\delta_{i}},\ i=1,\ldots,n$ (cf. (1.8) and (1.9)). Suppose $X$ contains temperature measurements, where each row indicates a different hour at which the readings were taken, and each column a different day. Then the user might want to weight each component of $\Delta$ equally, and thus $W_{\Delta}$ would be constant throughout. If one column of $X$ contained hourly temperature readings and the other hourly humidity readings, however, then the user would probably not want to weight the errors in the temperature measurements the same as those in the humidity measurements, but might want to specify the same weight $w_\epsilon$ for each observation. In this case, the components of $W_{\Delta}$ would be constant for each row $i,\ i=1,\ldots,n$. Of course, in other cases, the user might want to weight each component of $\Delta$ differently, and thus each component of $W_{\Delta}$ would be different.

\noindent ODRPACK95 structured arguments exploit this structure. If each of the elements of an attribute array is the same, then a scalar can be used to specify all elements of the array. If the values of such an array only vary between the columns, then each column of the array can be specified by a single value using a row vector. Thus, it is only necessary for the user to supply all elements of an attribute array when the elements of one or more of the columns must be individually specified. The use of structured arguments in described in detail in \S 2.A.ii. (See, e.g., subroutine argument {\tt WD}.)
\vfil\eject

\ \vskip 1.4in
\def\thissection{Using ODRPACK95}
\noindent{\capsXIV 2. Using ODRPACK95}\bigskip\bigskip

\noindent{\bf 2.A. Subroutine Interface and Argument Descriptions}\medskip
\noindent{\bf 2.A.i. Synopsis}\medskip
\noindent The arguments of the ODRPACK95 user callable subroutine are logically
grouped as shown below. Arguments shown in parenthesis ($\ldots$) are optional
(as specified by the Fortran 95 keyword: {\tt OPTIONAL})
and automatically preset to the default values given in \S
2.A.ii. All other arguments are required.
\bigskip
{\rmVIII\settabs\+\hskip .9in&\hskip 2in&\cr
\+\hfill Argument\hfill&&\cr
\+\hfill Number\hfill&Arguments&Group Description\cr}
\hrule\vskip .05in
{\rmVIII\settabs\+\hskip .9in&\hskip 2in&\cr
\+\hfill 1\hfill&\tt FCN,&Name of user supplied subroutine\cr
\+&&for function and derivative computation\cr
\medskip
\+\hfill 2 to 5\hfill&\tt N,M,NP,NQ,&Problem size specification\cr
\medskip
\+\hfill 6\hfill&\tt BETA,&Function parameters\cr
\medskip
\+\hfill 7 to 8\hfill&\tt Y,X&Dependent and explanatory variables\cr
\medskip
\+\hfill 9\hfill&\tt (DELTA,)&Initial error in explanatory variables\cr
\medskip
\+\hfill 10 to 11\hfill&\tt (WE,WD,)&Weights\cr
\medskip
\+\hfill 12 to 13\hfill&\tt (IFIXB,IFIXX,)&Parameter and variable fixing\cr
\medskip
\+\hfill 14 to 16\hfill&\tt (JOB,NDIGIT,TAUFAC,)&Computation and
initialization control\cr
\medskip
\+\hfill 17 to 19\hfill&\tt (SSTOL,PARTOL,MAXIT,)&Stopping criteria\cr
\medskip
\+\hfill 20 to 22\hfill&\tt (IPRINT,LUNERR,LUNRPT,)&Print control\cr
\medskip
\+\hfill 23 to 24\hfill&\tt (STPB,STPD,)&Derivative step sizes\cr
\medskip
\+\hfill 25 to 26\hfill&\tt (SCLB,SCLD,)&Scaling\cr
\medskip
\+\hfill 27 to 28\hfill&\tt (WORK,IWORK,)&Work vectors and returned
results\cr
\medskip
\+\hfill 29\hfill&\tt (INFO,)&Stopping condition\cr
\medskip
\+\hfill 30 to 31\hfill&\tt (LOWER,UPPER)&Bound constraints on {\tt BETA}\cr}
\vfil\eject

\noindent{\bf 2.A.ii. ODRPACK95 Subroutine Argument Definitions}
\medskip
\noindent The arguments of ODRPACK95's user callable subroutine are described
below in order of their occurrence in the call statement. Appropriate
declaration statements for each argument are shown in brackets [$\ldots$]
following the argument name; the character string {\tt <real>} denotes {\tt
REAL (KIND=R8)}. Each argument is
numbered as shown in \S 2.A.i, and will be cross referenced by both number and
name, e.g., {\tt 1-FCN}, enabling the user to easily find the definition of a
specific argument. In addition, a flag indicating whether the argument is passed
to or from ODRPACK95 is placed in the left margin by the argument number. The flags are:
\item{$\Longrightarrow$} indicating the argument specifies information that must
be {\it input} to ODRPACK95, and that the input information is preserved upon
return from the ODRPACK95 subroutine;
\item{$\Longleftarrow$} indicating the argument specifies information that is
{\it output} by the ODRPACK95 subroutine; and 
\item{$\Longleftrightarrow$} indicating the argument specifies information that
must be {\it input} to ODRPACK95, but that the input values will be {\it
overwritten} by ODRPACK95 upon return from the subroutine.

\vfil\eject

\setbox\mybox=\hbox{$\Longrightarrow15\ -\ $}
\noindent{$\ \ \Longrightarrow1\ -\ $}\hangindent=\wd\mybox\hangafter=1 {\tt FCN [EXTERNAL FCN]}

\aligntobox The name of the user supplied subroutine that, given the current values of the explanatory variable, $x_{\rm I}+\delta_{\rm I}$, and the current values of the function parameters, $\beta$, computes the predicted values
$${\tt F(I,L)}=f_{\rm IL}(x_{\rm I}+\delta_{\rm I};\beta)\ ,$$
${\tt I}=1,\ldots,n,$ and ${\tt L}=1,\ldots,q$, and optionally computes the matrices of first partial derivatives, i.e., the Jacobian matrices
$${\tt FJACB(I,K,L)}={{\partial f_{\rm IL}(x_{\rm I}+\delta_{\rm
I};\beta)}\over{\partial\beta_{\rm K}}}\ ,$$
for ${\tt I}=1,\ldots,n,\ {\tt K}=1,\ldots,p,$ and ${\tt L} =1,\ldots,q$, and
$${\tt FJACD(I,J,L)}={{\partial f_{\rm IL}(x_{\rm I}+\delta_{\rm I};\beta)}\over{\partial\Delta_{\rm IJ}}}\ ,$$
for ${\tt I}=1,\ldots,n,\ {\tt J}=1,\ldots,m,$ and ${\tt L}=1,\ldots,q$. The
code for evaluating {\tt F} must always be provided. The code for evaluating
{\tt FJACB} and {\tt FJACD} is required only when the second digit of argument
14-{\tt JOB} is greater than or equal to two. (When the second digit of {\tt
JOB} is zero or one, the necessary Jacobian matrices will be approximated by
ODRPACK95 using finite differences. See argument 14-{\tt JOB}, and also \S 4.A.) The code for {\tt FJACD} does not need to be supplied when the fit is by OLS. 

\aligntobox At a given call to subroutine {\tt FCN}, ODRPACK95 will never request that both the function values ({\tt F}) and the derivative values ({\tt FJACB} and {\tt FJACD}) be computed. While it is generally most cost effective if the user only performs the required computations, it is not an error for both function values and derivatives to be computed each time {\tt FCN} is invoked. {\it Note, however, that array\ {\tt FJACD} must never be altered when the fit is by ordinary least squares, since no space is assigned to that array in that case.}

\aligntobox The user must supply a value for every element of the selected
arrays. If some responses of some observations are actually missing, then the
user can set the corresponding weights in argument 10-{\tt WE} to zero in order to remove the effect of the missing observation from the analysis. (See \S 1.F.)

\aligntobox ODRPACK95's parameter fixing arguments {\tt IFIXB, IFIXX} and {\tt
LDIFX} are passed to subroutine {\tt FCN} for the user's convenience. When a
parameter is fixed, then the derivative with respect to that parameter can be
set to zero. ODRPACK95 will automatically zero these derivative values, however, and thus it is not necessary for the user to be concerned with this unless the derivative computations are especially expensive. (See Chapter 3.)

\aligntobox The argument list and dimension statements for subroutine {\tt FCN} must be exactly as shown below.
\bigskip

\noindent\hskip .3in\vbox{\tt\baselineskip=10pt 
\+\ \ \ \ \ \cleartabs&\ SUBROUTINE FCN(&N,M,NP,NQ,\cr
\+&+&LDN,LDM,LDNP,\cr
\+&+&BETA,XPLUSD,\cr
\+&+&IFIXB,IFIXX,LDIFX,\cr
\+&+&IDEVAL,F,FJACB,FJACD,\cr
\+&+&ISTOP)\cr
\+\cr
\+C\ \ \cleartabs&INPUT ARGUMENTS\cr
\+C&(WHICH MUST NOT BE CHANGED BY THIS ROUTINE)\cr
\+&\ \ \ &INTEGER IDEVAL,LDFIX,LDM,LDN,LDNP,M,N,NP,NQ\cr
\+&&INTEGER IFIXB(NP),IFIXX(LDIFX,M),\cr
\+&&<real> BETA(NP),XPLUSD(LDN,M)\cr
\+\cr
\+C&OUTPUT ARGUMENTS\cr
\+&&INTEGER ISTOP\cr
\+&&<real> F(LDN,NQ),FJACB(LDN,LDNP,NQ),FJACD(LDN,LDM,NQ)\cr
\+\cr
\+&&< set ISTOP >\cr
\+\cr
\+&&IF (ISTOP.NE.0) RETURN\cr
\+\cr
\+C&COMPUTE FUNCTION\cr
\+&&IF &(MOD(IDEVAL,10).GE.1) THEN\cr
\+&&&< compute F(I,L), I=1,...,N, & L=1,...,NQ >\cr
\+&&END IF\cr
\+\cr
\+C&COMPUTE DERIVATIVES WITH RESPECT TO BETA\cr
\+&&IF (MOD(IDEVAL/10,10).GE.1) THEN\cr
\+&&&< compute FJACB(I,K,L), I=1,...,N, K=1,...,NP, \& L=1,...,NQ >\cr
\+&&END IF\cr
\+\cr
\+C&COMPUTE DERIVATIVES WITH RESPECT TO DELTA\cr
\+&&IF (MOD(IDEVAL/100,10).GE.1) THEN\cr
\+&&&< compute FJACD(I,J,L), I=1,...,N, J=1,...,M, \& L=1,...,NQ >\cr
\+&&END IF\cr
\+\cr
\+&&RETURN\cr
\+&&END\cr}\bigskip

\aligntobox where
\vfil\eject

\itemitem{\tt N} is the number of observations, $n$. 

\itemitem{\tt M} is the number of elements, $m$, in each explanatory variable, $x_{i}\in\Re^{m}$, i.e., the number of columns of data in $X+\Delta$.

\itemitem{\tt NP} is the number of function parameters, $p$. 

\itemitem{\tt NQ} is the number of responses, $q$, per observation. 

\itemitem{\tt LDN} is an array leading dimension declarator that equals or exceeds $n$. 

\itemitem{\tt LDM} is an array leading dimension declarator that equals or exceeds $m$. 

\itemitem{\tt LDNP} is an array leading dimension declarator that equals or exceeds $p$. 

\itemitem{\tt BETA} is the singly subscripted array that contains the current values of $\beta$.

\itemitem{\tt XPLUSD} is the doubly subscripted array that contains the current value of the explanatory variables, i.e., $X+\Delta$.

\itemitem{\tt IFIXB} is the singly subscripted array designating whether a given
parameter $\beta_{\rm K}$ is to be treated as fixed. (See argument 12-{\tt IFIXB} below.)

\itemitem{\tt IFIXX} is the doubly subscripted array designating whether, when the solution is found by orthogonal distance regression, a given explanatory variable $X_{\rm IJ}$ is to be treated as without error. (See argument 13-{\tt IFIXX} below.)

\itemitem{\tt LDIFX} is the leading dimension of array {\tt IFIXX}. (See argument 19-{\tt LDIFX} below.)

\itemitem{\tt IDEVAL} is a three digit {\tt INTEGER} variable with decimal
expansion ${\cal I}_{3}{\cal I}_{2}{\cal I}_{1}$ passed to subroutine {\tt FCN}
by ODRPACK95 to designate what values are to be computed.
\smallskip
\hskip30pt{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
height1pt&\omit&&\omit&\cr
&Computation&\quad Digit&&\cr
height1pt&\omit&&\omit&\cr
\noalign{\hrule}
height1pt&\omit&&\omit&\cr
&\hfill\tt F\hfill&\ ${\cal I}_1$\ =\ 0\quad array {\tt F} need not be computed\hfil&&\cr
&\omit&\quad\ \ $=1$\quad function values {\tt F} must be computed\hfil&&\cr
&\omit&\qquad\qquad (for constructing finite difference derivatives)&&\cr
&\omit&\quad\ \ $=2$\quad function values {\tt F} must be computed\hfil&&\cr
&\omit&\qquad\qquad (for evaluating $S(\beta,\delta)$ at new
point)\hfil&&\cr
&\omit&\quad\ \ $=3$\quad function values {\tt F} must be
computed\hfil&&\cr 
&\omit&\qquad\qquad (for miscellaneous calculations)\hfil&&\cr 
\noalign{\hrule}
&\hfill\tt FJACB\hfill&\ ${\cal I}_2$\ =\ 0\quad array {\tt FJACB} need not be
computed\hfil&&\cr
&\omit&\quad\ \ $=1$\quad derivative values {\tt FJACB} must be computed\hfil&&\cr
\noalign{\hrule}
&\hfill\tt FJACD\hfill&\ ${\cal I}_3$\ =\ 0\quad array {\tt FJACD} must not be
altered\hfil&&\cr
&\omit&\quad\ \ $=1$\quad derivative values {\tt FJACD} must be
computed\hfil&&\cr
&\omit&\qquad\qquad (required for ODR fits only)\hfil&&\cr}
\hrule}}

\itemitem{\tt F} is the doubly subscripted array in which the $n\times q$ array of predicted values for each response of each observation must be stored.

\itemitem{\tt FJACB} is the triply subscripted array in which the $n\times p\times q$ array of partial derivatives with respect to $\beta$ for each response of each observation must be stored.

\itemitem{\tt FJACD} is the triply subscripted array in which the $n\times m\times q$ array of partial derivatives with respect to $\Delta$ for each response of each observation must be stored.

\itemitem{\tt ISTOP} is a variable that enables the user to instruct ODRPACK95 to reject the current values in {\tt BETA} and {\tt XPLUSD} as unacceptable. 
\smallskip
\hskip30pt\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
height1pt&\omit&&\omit&\cr
&\tt ISTOP&\quad Meaning&&\cr
height2pt&\omit&&\omit&\cr
\noalign{\hrule}
&\hfill$<0$\hfill&\ regression procedure should be stopped\hfil&&\cr
&\hfill$=0$\hfill&\ current $\beta$ and $\Delta$ are acceptable for use
by {\tt FCN:}\hfil&&\cr
&\omit&\quad requested values were properly computed within {\tt FCN} and&&\cr
&\omit&\quad regression procedure should continue\hfil&&\cr
&\hfill$>0$\hfill&\ current $\beta$ and $\Delta$ are unacceptable for use by
{\tt FCN}:\hfil&&\cr
&\omit&\quad if call to {\tt FCN} was for constructing derivatives\hfil&&\cr
&\omit&\qquad regression procedure will be stopped\hfil&&\cr
&\omit&\quad if call to {\tt FCN} was for evaluating
$S(\beta,\delta)$\hfil&&\cr
&\omit&\qquad a new point will be selected closer to the most\hfil&&\cr 
&\omit&\qquad recently tried acceptable values of $\beta$ and
$\Delta$\hfil&&\cr
&\omit&\quad if call to {\tt FCN} was for miscellaneous
calculations\hfil&&\cr
&\omit&\qquad regression procedure will be stopped\hfil&&\cr}
\hrule} 

\itemitem{}Note that even when ISTOP is used to stop the regression procedure,
the final summary of the computation report will still be generated if it has
been requested. (See argument 20-{\tt IPRINT}.)

\noindent{$\ \ \Longrightarrow2\ -\ $}{\tt N [INTEGER N]}

\aligntobox The number of observations, $n$.

\noindent{$\ \ \Longrightarrow3\ -\ $}{\tt M [INTEGER M]}

\aligntobox The number of elements, $m$, in each explanatory variable $x_{i}\in\Re^{m}$, i.e., the number of columns of data in $X$.

\noindent{$\ \ \Longrightarrow4\ -\ $}{\tt NP [INTEGER NP]}

\aligntobox The number of function parameters, $p$.

\noindent{$\ \ \Longrightarrow5\ -\ $}{\tt NQ [INTEGER NQ]}

\aligntobox The number of responses, $q$, per observation.

\noindent{$\ \Longleftrightarrow6\ -\ $}{\tt BETA [<real> BETA(NP)]}

\aligntobox The singly subscripted array that contains the (current) values of $\beta$.

\hangindent 92pt\hangafter=1\noindent\hskip\wd\mybox On input: {\tt
BETA} must contain initial approximations for the function parameters
$\beta$ within the bounds {\tt LOWER} and {\tt UPPER} (if the bounds
are specified). Initial approximations should be chosen with care since
poor initial approximations can significantly increase the number of
iterations required to find a solution and possibly prevent the solution
from being found at all. (See \S 1.E.)

\hangindent 92pt\hangafter=1\noindent\hskip\wd\mybox On return: {\tt BETA} contains the ``best'' estimate of the parameters, $\hat{\beta}$, at the time the computations stopped.

\noindent{$\ \ \Longrightarrow7\ -\ $}{\tt Y [<real> Y(N,NQ)]}

\aligntobox The double subscripted array that contains the values of the
response variable $Y_{\rm IL},{\tt I}=1,\ldots,n,\ {\tt L}=1,\ldots,q$. When the
model is {\it explicit}, the user must supply a value for each of the $n\times
q$ elements of Y; if some responses of some observations are actually missing,
then the user can set the corresponding weight in argument 10-{\tt WE} to zero in order to remove the effect of the missing observation from the analysis. When the model is {\it implicit}, Y is not referenced. (See argument 14-{\tt JOB}, and \S 1.F.)

\noindent{$\ \ \Longrightarrow8\ -\ $}{\tt X [<real> X(N,M)]}

\aligntobox The doubly subscripted array that contains the observed values of the explanatory variable $X$.

\noindent{$\ \ \Longleftrightarrow9\ -\ $}{\tt DELTA [<real> DELTA(N,M)]}

\aligntobox The doubly subscripted array that contains initial errors $\delta$ in the observed values of the explanatory variable $X$.

\noindent{$\Longrightarrow10\ -\ $}{\tt WE [<real> WE(LDWE,LD2WE,NQ)]}

\aligntobox The triply subscripted array that, when the model is {\it explicit} specifies how each $\epsilon_{\rm I}$ is to be weighted in the weighted orthogonal distance, and when the model is {\it implicit} specifies the starting penalty parameter value, $r_0$ (see \S 1.A, \S 1.B, \S 1.F, and argument 14-{\tt JOB}).

\aligntobox For {\it explicit} models, {\tt WE} is a structured argument: only
the specific elements of {\tt WE} identified in the table below are referenced
by ODRPACK95. (See \S 1.G.)
\smallskip
\aligntobox\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\ \hfil#\hfil&\quad\hfil#\hfil&\quad\hfil#\hfil&\ \vrule#&\strut\quad\hfil#\cr
&\omit&\omit&\omit&\ For ${\tt I}=1,\ldots,n,$\hfil&&\cr
&\tt WE(1,1,1)&\tt LDWE&\tt LD2WE&\quad $w_{\epsilon_{\rm I}}\hfil$&&\cr
height1pt&\omit&\omit&\omit&\omit&\omit&\cr
\noalign{\hrule}
&$<0$&---&---&\ = --{\tt WE(1,1,1)}$I_{q},I_{q}$ a $q\times q$ identity matrix\hfil&&\cr
&$\geq0$&= 1&= 1&\ = diag$\{{\tt WE(1,1,L2)},\ {\tt L2}=1,\ldots,q\}$\hfil&&\cr
&\omit&$\geq n$&= 1&\ = diag$\{{\tt WE(I,1,L2)},\ {\tt L2}=1,\ldots,q\}$\hfil&&\cr
&\omit&= 1&$\geq q$&\ = {\tt WE(1,L1,L2)}, ${\tt L1}=1,\ldots,q,$ \&
${\tt L2}=1,\ldots,q$\hfil&&\cr
&\omit&$\geq n$&$\geq q$&\ = {\tt WE(I,L1,L2)}, ${\tt L1}=1,\ldots,q,$ \&
${\tt L2}=1,\ldots,q$\hfil&&\cr
height1pt&\omit&\omit&\omit&\omit&\omit&\cr}
\hrule}

\aligntobox For {\it implicit} models, only the first element of {\tt WE} is ever referenced, and $r_0$ is set as follows.
\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
&\hfill\tt WE(1,1,1)\hfill&\quad$r_0$&&\cr
height2pt&\omit&&\omit&\cr
\noalign{\hrule}
&\hfill$\leq 0$\hfill&\ = 10\hfil&&\cr
&\hfill$> 0$\hfill&\ = {\tt WE(1,1,1)}&&\cr}
\hrule}}

\noindent{$\Longrightarrow11\ -\ $}{\tt WD [<real> WD(LDWD,LD2WD,M)]}

\aligntobox The triply subscripted array that specifies how each
$\delta_{\rm I}$ is to be weighted in the weighted orthogonal distance. (See \S
1.A and \S 1.F.) {\tt WD} is a structured argument: only the specific elements
of {\tt WD} identified in the table below are ever referenced by ODRPACK95. (See \S 1.G.)
\smallskip
\aligntobox\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\ \hfil#\hfil&\quad\hfil#\hfil&\quad\hfil#\hfil&\
\vrule#&\strut\quad\hfil#\cr
&\omit&\omit&\omit&\ For ${\tt I}=1,\ldots,n,$\hfil&&\cr
&\tt WE(1,1,1)&\tt LDWD&\tt LD2WD&\quad $w_{\delta_{\rm I}}\hfil$&&\cr
height1pt&\omit&\omit&\omit&\omit&\omit&\cr
\noalign{\hrule}
&$<0$&---&---&\ = --{\tt WD(1,1,1)}$I_{m},I_{m}$ an $m\times m$ identity
matrix\hfil&&\cr
&= 0&---&---&\ $=I_{m},\ I_{m}$ an $m\times m$ identity matrix\hfil&&\cr
&$>0$&= 1&= 1&\ = diag$\{{\tt WD(1,1,J2)},\ {\tt
J2}=1,\ldots,m\}$\hfil&&\cr
&\omit&$\geq n$&= 1&\ = diag$\{{\tt WD(I,1,J2)},\ {\tt
J2}=1,\ldots,m\}$\hfil&&\cr
&\omit&= 1&$\geq m$&\ = {\tt WD(1,J1,J2)}, ${\tt J1}=1,\ldots,m,$ \&
${\tt J2}=1,\ldots,m$\hfil&&\cr
&\omit&$\geq n$&$\geq m$&\ = {\tt WE(I,J1,J2)}, ${\tt J1}=1,\ldots,m,$ \&
${\tt J2}=1,\ldots,m$\hfil&&\cr}
\hrule}

\noindent{$\Longrightarrow12\ -\ $}{\tt IFIXB [INTEGER IFIXB(NP)]}

\aligntobox The singly subscripted array that specifies the indicator variable ${\cal F}_{\beta_{\rm K}}$ designating whether $\beta_{\rm K}$ is to be treated as ``fixed,'' i.e., is to be treated as a constant, or is to be ``unfixed'' and thus is to be estimated.  

\itemitem{$\bullet$}If ${\cal F}_{\beta_{\rm K}}=0$ then $\beta_{\rm K}$ is fixed and {\tt BETA(K)} is not changed.

\itemitem{$\bullet$}If ${\cal F}_{\beta_{\rm K}}\ne0$ then $\beta_{\rm K}$ is unfixed and {\tt BETA(K)} is overwritten by ${\hat{\beta}}_{\rm K}$.

\aligntobox The default values are ${\cal F}_{\beta_{\rm K}}=1,\ {\tt K}=1,\ldots,p.$
\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
&\omit&\ For ${\tt K}=1,\ldots,p,$&&\cr
&\hfill\tt IFIXB(1)\hfill&\quad${\cal F}_{\beta_{\rm K}}$&&\cr
height2pt&\omit&&\omit&\cr
\noalign{\hrule}
&\hfill$< 0$\hfill&\ = 1\hfil&&\cr
&\hfill$\geq 0$\hfill&\ = {\tt IFIXB(K)}\hfil&&\cr}
\hrule}}

\noindent{$\Longrightarrow13\ -\ $}{\tt IFIXX [INTEGER IFIXX(LDIFX,M)]}

\aligntobox The doubly subscripted array that specifies the indicator variable ${\cal F}_{{\rm X}_{\rm IJ}}$ designating whether, when the solution is found by orthogonal distance regression, the {\tt (I,J)}th element of the explanatory variable $X_{\rm IJ}$ is to be treated as without error and thus $\Delta_{\rm
IJ}$ is to be ``fixed'' at zero, or whether that observation is ``unfixed'' and therefore the error $\Delta_{\rm IJ}$ is to be estimated. (When the solution is found by ordinary least squares, the $X_{\rm IJ}$ are always treated as fixed, and thus $\Delta_{\rm IJ}=0$ for all ${\tt I}=1,\ldots,n$ and ${\tt
J}=1,\ldots,m$.) 

\itemitem{$\bullet$}If ${\cal F}_{\rm X_{\rm IJ}}=0$ then $X_{\rm IJ}$ is fixed and $\Delta_{\rm IJ}$ is set to zero.

\itemitem{$\bullet$}If ${\cal F}_{\rm X_{\rm IJ}}\neq 0$ then $X_{\rm
IJ}$ is unfixed and $\Delta_{\rm IJ}$ is estimated.

\aligntobox The default values are ${\cal F}_{\rm X_{\rm IJ}}=1,\ {\tt
I}=1,\ldots,n$, and ${\tt J}=1,\ldots,m$.

\aligntobox {\tt IFIXX} is a structured argument: only the specific elements of
{\tt IFIXX} identified in the table below are referenced by ODRPACK95. (See \S 1.G.)
\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\ \hfil#\hfil&\quad\hfil#\hfil&\ \vrule#&\strut\quad\hfil#\cr
&\omit&\omit&\ For ${\tt I}=1,\ldots,n,$\hfil&&\cr
&\omit&\omit&\ \& ${\tt J}=1,\ldots,m,$\hfil&&\cr
&\tt IFIXX(1,1)&\tt LDIFX&\quad ${\cal F}_{\rm X_{\rm IJ}}$\hfil&&\cr
height1pt&\omit&\omit&\omit&\omit&\cr
\noalign{\hrule}
&$< 0$&---&\ = 1\hfil&&\cr
&$\geq 0$&= 1&\ = \tt IFIXX(1,J)\hfil&&\cr
&\omit&$\geq n$&\ = \tt IFIXX(I,J)\hfil&&\cr}
\hrule}}

\noindent{$\Longrightarrow14\ -\ $}{\tt JOB [INTEGER JOB]}
 
\aligntobox The variable that specifies problem initialization and computational methods. (See \S 1.C.) The default options, selected when ${\tt JOB}\leq 0$, are that

\aligntobox $\bullet$ the solution will be found by explicit orthogonal distance regression;

\aligntobox $\bullet$ the derivatives will be computed by forward finite differences;

\aligntobox $\bullet$ the covariance matrix will be computed using Jacobian matrices recalculated at the solution;

\aligntobox $\bullet$ $\Delta$ will be initialized to zero; and

\aligntobox $\bullet$ the fit will not be a restart. 

\aligntobox When ${\tt JOB}\geq 0$, it is assumed to be a 5 digit {\tt INTEGER} with decimal expansion ${\cal I}_{5}{\cal I}_{4}{\cal I}_{3}{\cal I}_{2}{\cal I}_{1}$, where each digit controls a different option.
\smallskip
\aligntobox\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\ #\hfil&\vrule\ #&\quad#\hfil&\strut\quad\hfil#\cr
&Option&Digit&Selection\hfil&&\cr
height2pt&\omit&&\omit&\omit&\cr
\noalign{\hrule}
&Computational method&${\cal I}_{1}=0$&explicit orthogonal distance
regression\hfil&&\cr
&(see \S 1.A)&\hfil = 1&implicit orthogonal distance regression\hfil&&\cr
&\omit&\hfil$\geq 2$&ordinary least squares\hfil&&\cr
\noalign{\hrule}
&Derivative calculation&${\cal I}_{2}=0$&forward finite
differences\hfil&&\cr
&(see \S 4.A)&\hfil = 1&central finite differences\hfil&&\cr
&\omit&\hfil = 2&user supplied derivative code,\hfil&&\cr
&\omit&&checked by ODRPACK95\hfil&&\cr
&\omit&\hfil $\geq 3$&user supplied derivative code,\hfil&&\cr
&\omit&&not checked by ODRPACK95\hfil&&\cr
\noalign{\hrule}
&Covariance matrix $V_\beta$,&${\cal I}_{3}=0$&$V_\beta$ and
$\sigma_\beta$ calculated using\hfil&&\cr
&\& standard deviation $\sigma_\beta$\ &&derivatives recomputed at
solution\hfil&&\cr
&(see \S 4.B)&\hfil = 1&$V_\beta$ and $\sigma_\beta$ calculated
using\hfil&&\cr
&\omit&&derivatives from last iteration\hfil&&\cr
&\omit&\hfil$\geq 2$&$V_\beta$ and $\sigma_\beta$ not
calculated\hfil&&\cr
\noalign{\hrule}
&$\Delta$ Initialization&${\cal I}_{4}=0$&$\Delta$ initialized to zero
by ODRPACK95\hfil&&\cr
&(see \S 1.E)&\hfil $\geq 1$&$\Delta$ initialized by user\hfil&&\cr
&\omit&&(see argument 27-{\tt WORK})\hfil&&\cr
\noalign{\hrule}
&Restart facility&${\cal I}_{5}=0$&fit is not a restart\hfil&&\cr
&(see Chapter 3)&\hfil $\geq 1$&fit is a restart\hfil&&\cr}
\hrule}

\noindent{$\Longrightarrow15\ -\ $}{\tt NDIGIT [INTEGER NDIGIT]}

\aligntobox The variable that specifies the number of reliable decimal digits
$\psi$ in the values computed using subroutine {\tt FCN}. The value $\psi$ is
needed to calculate the default values for the relative step sizes used in
calculating finite difference derivatives. (See arguments 23-{\tt STPB} and
24-{\tt STPD}, and \S 4.A.) It is also used to determine when the Jacobian with
respect to one or more of the parameter $\beta$ appears to be rank deficient. It
can not exceed the number of decimal digits $\Psi$ carried by the user's
computer for a {\tt <real>} value. The default value is experimentally
determined by ODRPACK95 for the user's particular model. This determination of $\psi$ requires 4 evaluations of the model function from user supplied subroutine {\tt FCN}.
\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
&\hfill\tt NDIGIT\hfill&\quad $\psi$\hfil&&\cr
\noalign{\hrule}
&\hfill$\leq 1$\hfill&\ = default value\hfil&&\cr
&\hfill$\geq 2$\hfill&\ = min$\{{\tt NDIGIT},\Psi\}$\hfil&&\cr}
\hrule}}

\noindent{$\Longrightarrow16\ -\ $}{\tt TAUFAC [<real> TAUFAC]}

\aligntobox The variable that specifies the factor $\tau$ used to initialize the trust region radius. The trust region is the region in which the local approximation to $S(\beta,\delta)$ is considered reliable. The diameter of this region is adaptively chosen at each iteration based on information from the previous iteration. At the first iteration, the initial diameter is set to $\tau$ times the length of the full Gauss-Newton step calculated at the initial values of $\beta$ and $\Delta$. The default value is $\tau=1$. When $\tau<1$ the size of the initial step attempted at the first iteration is smaller than the full Gauss-Newton step. This may be appropriate if, at the first iteration, the computed results for the full Gauss-Newton step cause an overflow, or cause $\beta$ and/or $\Delta$ leave the region of interest.
\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
&\hfill\tt TAUFAC\hfill&\quad $\tau$\hfil&&\cr
\noalign{\hrule}
&\hfill$\leq 0$\hfill&\ = 1\hfil&&\cr
&\hfill$>0$\hfill&\ = min$\{{\tt TAUFAC},1\}$\hfil&&\cr}
\hrule}}

\noindent{$\Longrightarrow17\ -\ $}{\tt SSTOL [<real> SSTOL]}

\aligntobox The variable that specifies ${\cal T}_S$, the stopping tolerance for sum of squares convergence, i.e., for convergence based on the relative change in $S(\beta,\delta)$. The default value is ${\cal T}_{S}=\xi^{1/2}$, where $\xi$ is defined as the smallest value such that $1 + \xi > 1$ for a {\tt <real>} computation on the machine being used.
\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
&\hfill\tt SSTOL\hfill&\quad ${\cal T}_S$\hfil&&\cr
\noalign{\hrule}
&\hfill$< 0$\hfill&\ $= \xi^{1/2}$\hfil&&\cr
&\hfill$\geq 0$\hfill&\ = min$\{{\tt SSTOL},1\}$\hfil&&\cr}
\hrule}}

\noindent{$\Longrightarrow18\ -\ $}{\tt PARTOL [<real> PARTOL]}

\aligntobox The variable that specifies ${\cal T}_P$, the stopping tolerance for parameter convergence, i.e., for convergence based on relative change in the estimated parameters $\beta$ and $\Delta$. When the model is {\it explicit} the default value is ${\cal T}_{P}=\xi^{2/3}$, and when the model is {\it implicit} the default value is ${\cal T}_{P}=\xi^{1/3}$, where $\xi$ is defined as the smallest value such that $1 + \xi > 1$ for a {\tt <real>} computation on the machine being used.
\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
&\hfill\tt PARTOL\hfill&\quad ${\cal T}_P$\hfil&&\cr
\noalign{\hrule}
&\hfill$< 0$\hfill&\ = default value\hfil&&\cr
&\hfill$\geq 0$\hfill&\ = min$\{{\tt PARTOL},1\}$\hfil&&\cr}
\hrule}}

\noindent{$\Longrightarrow19\ -\ $}{\tt MAXIT [INTEGER MAXIT]}

\aligntobox The variable that specifies ${\cal T}_I$, the maximum number of iterations allowed. The default value depends on whether the fit is a restart or not. (See argument 14-{\tt JOB}.) If the fit is not a restart, then 
$${\cal T}_{I}=50\ .$$
If the fit is a restart, then
$${\cal T}_{I}={\cal T}_{I^{-}}+10\ ,$$
where ${\cal T}_{I^{-}}$ is the number of iterations completed in the previous run, thus indicating that the procedure will continue for an additional 10 iterations.
\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\ \hfil#\hfil&\quad\hfil#\hfil&\
\vrule#&\strut\quad\hfil#\cr
&\tt MAXIT&Restart&\quad ${\cal T}_I$\hfil&&\cr
height1pt&\omit&\omit&\omit&\omit&\cr
\noalign{\hrule}
&$< 0$&no&\ = 50\hfil&&\cr
&\omit&yes&$\ ={\cal T}_{I^{-}}+10$\hfil&&\cr 
&$\geq 0$&no&\ = \tt MAXIT\hfil&&\cr
&\omit&yes&$\ = {\cal T}_{I^{-}}+\tt MAXIT$\hfil&&\cr}
\hrule}}

\aligntobox If {\tt MAXIT} = 0 then no iterations will be taken, but whatever
computations are required to complete the final computation report will be made.
For example, by setting {\tt MAXIT} = 0 and the third digit of {\tt JOB} to
zero, the user can compute the covariance matrix $V_\beta$ for the input values
$\beta$ and $\Delta$. (See arguments 14-{\tt JOB} and 20-{\tt IPRINT}, and also \S 1.D.)

\noindent{$\Longrightarrow20\ -\ $}{\tt IPRINT [INTEGER IPRINT]}

\aligntobox The variable that controls generation of the computation reports described in \S 1.D. The default computation reports include

\aligntobox $\bullet$ a long initial summary,

\aligntobox $\bullet$ no iteration summary, and 

\aligntobox $\bullet$ a short final summary.

\aligntobox When {\tt IPRINT} $<0$, the default reports are generated only on
${\cal L}_{CR}$, the logical unit specified by argument 22-{\tt LUNRPT}. When {\tt IPRINT} $\geq0$, it is assumed to be a 4 digit {\tt INTEGER} with decimal expansion ${\cal I}_{4}{\cal I}_{3}{\cal I}_{2}{\cal I}_{1}$, where each digit controls a different part of the computation report and whether that report is to be generated only on ${\cal L}_{CR}$ or to both ${\cal L}_{CR}$ and unit 6. (See \S 1.D).
\smallskip
\aligntobox{\vbox{\offinterlineskip\hrule
\halign{&\vrule\ #&\hfil#\hfil&\quad\hfil#\hfil&\quad\hfil#\hfil&\quad\vrule\ #&
\quad\hfil#\hfil&\quad\hfil#\hfil&\quad\hfil#\hfil&\quad\vrule\ #
&\quad\hfil#\hfil&\quad\hfil#\hfil&\quad\hfil#\hfil&\strut\hfil\vrule#\cr
&\span\omit\span Initial summary&\span\span
Iteration summary\span &\span Final summary\span&&\cr
&${\cal I}_4$&\omit\span - unit -&${\cal I}_3$&${\cal I}_2$&\omit\span - unit
-&${\cal I}_1$&\omit\span - unit -&&\cr
&\omit&${\cal L}_{CR}$&6&&\omit&${\cal L}_{CR}$&6&&${\cal
L}_{CR}$&6&&\cr
\noalign{\hrule}
&\omit&\omit&\omit&$\geq0$&$=0$&none&none&&\omit&\omit&&\cr
&$=0$&none&none&$=0$&$\geq1$&none&none&$=0$&none&none&&\cr
&$=1$&short&none&$=1$&$\geq1$&short&none&$=1$&short&none&&\cr
&$=2$&long&none&$=2$&$\geq1$&long&none&$=2$&long&none&&\cr
&$=3$&short&short&$=3$&$\geq1$&short&short&$=3$&short&short&&\cr
&$=4$&long&short&$=4$&$\geq1$&long&short&$=4$&long&short&&\cr
&$=5$&short&long&$=5$&$\geq1$&short&long&$=5$&short&long&&\cr
&$=6$&long&long&$=6$&$\geq1$&long&long&$=6$&long&long&&\cr}
\hrule}}

\itemitem{If ${\cal I}_{2}=0$} no iteration summary will be generated, even if the value of ${\cal I}_3$ is nonzero.
\itemitem{If ${\cal I}_{2}\geq1$} an iteration summary will be generated every ${\cal I}_{2}th$ iteration beginning with iteration one.

\noindent{$\Longrightarrow21\ -\ $}{\tt LUNERR [INTEGER LUNERR]}

\aligntobox The variable that specifies ${\cal L}_{ER}$, the logical unit number to be used for error messages. (See \S 1.D.) By default, ${\cal
L}_{ER}=6.$
\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
&\hfill\tt LUNERR\hfill&\quad ${\cal L}_{ER}$\hfil&&\cr
\noalign{\hrule}
&\hfill$< 0$\hfill&\ = 6\hfil&&\cr
&\hfill$= 0$\hfill&\ error messages suppressed&&\cr
&\hfill$\geq 0$\hfill&\ = {\tt LUNERR}\hfill&&\cr}
\hrule}}

\noindent{$\Longrightarrow22\ -\ $}{\tt LUNRPT [INTEGER LUNRPT]}

\aligntobox The variable that specifies ${\cal L}_{CR}$, the logical unit number
to be used for computation reports. (See also argument 20-{\tt IPRINT}, and \S 1.D.) By default, ${\cal L}_{CR}=6.$
\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
&\hfill\tt LUNRPT\hfill&\quad ${\cal L}_{CR}$\hfil&&\cr
\noalign{\hrule}
&\hfill$< 0$\hfill&\ = 6\hfil&&\cr
&\hfill$=0$\hfill&\ computation records suppressed,\hfill&&\cr
&\omit&\ even when argument 20-{\tt IPRINT} is nonzero\hfill&&\cr
&\hfill$\geq 0$\hfill&\ = {\tt LUNRPT}\hfil&&\cr}
\hrule}}

\noindent{$\Longrightarrow23\ -\ $}{\tt STPB [<real> STPB(NP)]}

\aligntobox The singly subscripted array that specifies the {\it relative} step sizes, $h_{\beta_{\rm K}},\ {\tt K}=1,\ldots,p,$ used to compute the finite difference derivatives with respect to each of the parameters $\beta$ as discussed in \S 4.A. The default value is set as described in \S 4.A.iii depending on whether forward or central finite difference derivatives are being computed. (See argument 14-{\tt JOB}.)

\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
&\omit&\ For ${\tt K}=1,\ldots,p$,\hfil&&\cr
&\hfill\tt STPB(1)\hfill&\quad $h_{\beta_{\rm K}}$\hfil&&\cr
height1pt&\omit&&\omit&\cr
\noalign{\hrule}
&\hfill$\leq0$\hfill&\ = default value\hfil&&\cr
&\hfill$> 0$\hfill&\ = \tt STPB(K)\hfil&&\cr}
\hrule}}

\noindent{$\Longrightarrow24\ -\ $}{\tt STPD [<real> STPD(LDSTPD,M)]}

\aligntobox The doubly subscripted array that specifies the {\it relative} step sizes, $h_{\Delta_{\rm IJ}},\ {\tt I}=1,\ldots,n$, and ${\tt
J}=1,\ldots,m$, used to compute the finite difference derivatives with respect
to the errors in each of the elements of $X$ as discussed in \S 4.A. The default
value is set as described in \S 4.A.iii depending on whether forward or central
finite difference derivatives are being computed. (See argument 14-{\tt JOB}.)
{\tt STPD} is a structured argument: only the specific elements of {\tt STPD}
identified in the table below are referenced by ODRPACK95. (See \S 1.G.)

\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\hfil#\hfil&\vrule#&\quad\hfil#\hfil&\ \vrule#&\strut\quad\hfil#\cr
&\omit&&\omit&\ For ${\tt I}=1,\ldots,n,$\hfil&&\cr
&\omit&&\omit&\ \& ${\tt J}=1,\ldots,m,$\hfil&&\cr
&\ \hfil\tt STPD(1,1)\hfil\ &&\tt LDSTPD\ &\quad $h_{\Delta{\rm
IJ}}$\hfil&&\cr
\noalign{\hrule}
&\hfil$\leq 0$\hfil&&---&\ = default value\hfil&&\cr
&\hfil$>0$\hfil&&$=1$&\ = {\tt STPD(1,J)}\hfil&&\cr
&\omit&&$\geq n$&\ = {\tt STPD(I,J)}\hfill&&\cr}
\hrule}}

\noindent{$\Longrightarrow25\ -\ $}{\tt SCLB [<real> SCLB(NP)]}

\aligntobox The singly subscripted array that specifies the scale values,
{\smallcaps SCALE}$\{\beta_{\rm K}\},\ {\tt K}=1,\ldots,p,$ of the function
parameters, i.e., the reciprocals of the expected magnitudes or typical sizes of
$\beta_{\rm K},\ {\tt K}=1,\ldots,p.$ Scaling is used within the regression
procedure in order that the units of the variable space will have approximately
the same magnitude. This increases the stability of the procedure, but does not
affect the problem specification. Scaling should not be confused with the
weighting matrices $w_{\epsilon_{\rm I}}$ and $w_{\delta_{\rm I}}$ specified by
arguments 10-{\tt WE} and 11-{\tt WD}. (See \S 1.A, and \S 1.F.) Except as noted below, the scale values specified for each value of $\beta$ must be greater than zero. The default values are set as described in \S 4.D.i.

\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
&\omit&\ For ${\tt K}=1,\ldots,p,$\hfil&&\cr
&\hfill\tt SCLB(1)\hfill&\quad {\smallcaps SCALE}$\{\beta_{\rm K}\}$\hfil&&\cr
\noalign{\hrule}
&\hfill$\leq0$\hfill&\ = default value\hfil&&\cr
&\hfill$>0$\hfill&\ = \tt SCLB(K)\hfill&&\cr}
\hrule}}
 
\noindent{$\Longrightarrow26\ -\ $}{\tt SCLD [<real> SCLD(LDSCLD,M)]}

\aligntobox The doubly subscripted array that specifies the scale values for the errors $\Delta$ in the explanatory variable $X$, i.e., the reciprocals of the expected magnitudes or typical sizes of $\Delta_{\rm IJ},\ {\tt
I}=1,\ldots,n,$ and ${\tt J}= 1,\ldots,m$. Scaling is used within the regression
procedure in order to ensure that the units of the variable space will have
approximately the same magnitude. This increases the stability of the procedure,
but does not affect the problem specification. Scaling should not be confused
with the weighting matrices $w_{\epsilon_{\rm I}}$ and $w_{\delta_{\rm I}}$
specified by arguments 10-{\tt WE} and 11-{\tt WD}. (See \S 1.A, and \S 1.F.) Except as noted below, the scale values specified for each value of $\Delta$ must be greater than zero. The default values are set as described in \S 4.D.ii. {\tt
SCLD} is a structured argument: only the specific elements of {\tt SCLD}
identified in the table below are referenced by ODRPACK95. (See \S 1.G.)

\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\hfil#\hfil&\vrule#&\quad\hfil#\hfil&\
\vrule#&\strut\quad\hfil#\cr
&\omit&&\omit&\ For ${\tt I}=1,\ldots,n,$\hfil&&\cr
&\omit&&\omit&\ \& ${\tt J}=1,\ldots,m,$\hfil&&\cr
&\hfil\ \tt SCLD(1,1)\ \hfil&&\tt LDSCLD\ &\quad {\smallcaps
SCALE}$\{\Delta_{\rm IJ}\}$\hfil&&\cr
\noalign{\hrule}
&\hfil$\leq 0$\hfil&&---&\ = default value\hfil&&\cr
&\hfil$>0$\hfil&&$=1$&\ = {\tt SCLD(1,J)}\hfil&&\cr
&\omit&&$\geq n$&\ = {\tt SCLD(I,J)}\hfill&&\cr}
\hrule}}

\noindent{$\Longleftrightarrow27\ -\ $}{\tt WORK [<real> WORK(LWORK)]}

\aligntobox The singly subscripted array used for {\tt <real>} work space, and
an array in which various computed values are returned. The smallest acceptable
dimension of {\tt WORK} is 
{
\textfont0=\rmIX
\textfont1=\itIX
$$
18+13p+p^2+m+m^2+4nq+6nm+2nqp+2nqm+q^2+5q+q(p+m)+({\tt LDWE}*{\tt LD2WE})q,
$$}for orthogonal distance regression and
{
\textfont0=\rmIX
\textfont1=\itIX
$$
18+13p+p^2+m+m^2+4nq+2nm+2nqp+5q+q(p+m)+(LDWE*LD2WE)q,
$$}for ordinary least squares.
The work area does not need to be initialized by the user unless the
user wishes to initialize $\Delta$ (also initializable by 9-{\tt DELTA}),
which is stored in the first $n\times m$ locations of {\tt WORK}. An easy
way to access these values, either for initialization, as is necessary
when the fourth digit of argument 14-{\tt JOB} is nonzero and the fit
is by orthogonal distance regression, or for analysis upon return from
ODRPACK95, is to include in the user's program the declaration statements

\aligntobox {\tt <real> DELTA(<N>,<M>)

\aligntobox EQUIVALENCE (WORK(1), DELTA(1,1))}

\aligntobox where {\tt <N>} indicates that the first dimension of the array {\tt DELTA} must be exactly the number of observations, ${\tt N}= n$; and {\tt <M>} indicates that the second dimension of the array {\tt DELTA} must be exactly the number of columns, ${\tt M}= m$, of the explanatory variable $X$. 

\aligntobox This allows the error associated with observation {\tt X(I,J)} to be accessed as {\tt DELTA(I,J)} rather than as {\tt WORK(I+(J-1)*N)}. The values in {\tt DELTA} will be over written by the final estimates of the errors in the explanatory variable when this equivalencing method is used. Other values returned in array {\tt WORK} may also be of interest and can be accessed as described in \S 5.A.

\aligntobox N.B., if the fit is a ``restart,'' i.e., if the fifth digit of
argument 14-{\tt JOB} is nonzero, then all elements of vector {\tt WORK},
including the values of {\tt DELTA}, must be exactly as returned from a previous
call to ODRPACK95.

\noindent{$\Longleftarrow28\ -\ $}{\tt IWORK [INTEGER IWORK(LIWORK)]}

\aligntobox The singly subscripted array used for {\tt INTEGER} work
space, and an array in which various computed values are returned. The
smallest acceptable dimension of {\tt IWORK} is
$$
20+2p+q(p+m).
$$

\aligntobox Certain values returned in array {\tt IWORK} are of general interest
and can be accessed as described below in \S 5.B. In particular, the results of
the derivative checking procedure are encoded in {\tt IWORK}. These results may
be especially useful if ODRPACK95's error reports have been suppressed. (See
argument 21-{\tt LUNERR}.) 

\aligntobox N.B., if the fit is a ``restart,'' i.e., if the fifth digit of
argument 14-{\tt JOB} is nonzero, then all elements of vector {\tt IWORK} must
be exactly as returned from a previous call to ODRPACK95.

\noindent{$\Longleftarrow29\ -\ $}{\tt INFO [INTEGER INFO]}

\aligntobox The variable used to indicate why the computations stopped.

\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad\hfil#\ \ \cr
&\tt INFO&\ Stopping Condition\hfil&&\cr
\noalign{\hrule}
&\hfill$=1$\hfill&\ sum of squares convergence\hfil&&\cr
&\hfill$=2$\hfill&\ parameter convergence\hfil&&\cr
&\hfill$=3$\hfill&\ both sum of squares and parameter convergence\hfil&&\cr
&\hfill$=4$\hfill&\ iteration limit reached\hfil&&\cr
&\hfill$\geq5$\hfill&\ questionable results or fatal errors detected\hfill&&\cr}
\hrule}}

\aligntobox When ${\tt INFO}\geq5$ the questionable results or fatal errors
detected by ODRPACK95 are reported in the messages generated on the logical
units specified by arguments 21-{\tt LUNERR} and 22-{\tt LUNRPT}. In
this case, {\tt INFO} is a 6 digit {\tt INTEGER} with decimal expansion
${\cal I}_6{\cal I}_5{\cal I}_4{\cal I}_3{\cal I}_2{\cal I}_1$, where
${\cal I}_6{\cal I}_5=00$ and ${\cal I}_4{\cal I}_3{\cal I}_2\ne 000$ indicates that questionable conditions were found,
and ${\cal I}_6{\cal I}_5\geq01$ indicates that fatal errors were detected. The
nonzero values of ${\cal I}_6$, ${\cal I}_5$, ${\cal I}_4$, ${\cal I}_3$,
${\cal I}_2$ and ${\cal I}_1$ are used to identify what conditions were
detected at the time the program stopped.

\smallskip
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\strut\quad#\ \ \cr
&Questionable Results:\hfill&\omit&\omit&\cr
height2pt&\omit&\omit&\omit&\cr
&\hfill\quad${\cal I}_6{\cal I}_5=00$ with
${\cal I}_4\neq0$&\omit&derivatives possibly not correct (see \S 4.A)\hfil&\cr
&\hfill${\cal I}_3\neq0$&\omit&${\rm ISTOP}\neq0$ at last call to {\tt
FCN}\hfil&\cr
&\omit&\omit&(see argument 1-{\tt FCN})\hfil&\cr
&\hfill${\cal I}_2\neq0$&\omit&problem is not full rank at
solution\hfil&\cr
&\hfill${\cal I}_1=1$&\omit&sum of squares convergence\hfil&\cr
&\hfill$=2$&\omit&parameter convergence\hfil&\cr
&\hfill$=3$&\omit&sum of squares and parameter convergence\hfil&\cr
&\hfill$=4$&\omit&iteration limit reached\hfil&\cr
\noalign{\hrule}
}}}
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\quad#&\strut\quad#\ \ \cr
&Fatal Errors:\hfill\span&\omit&\omit&&\cr
height2pt\vrule&&&\omit&&&\cr
%
&\hfill\quad${\cal I}_6{\cal I}_5=01$ with &${\cal I}_4\neq0$&\omit&${\tt
N}<1$\hfil&&\cr
&\hfill&${\cal I}_3\neq0$&\omit&${\tt M}<1$\hfil&&\cr
&\hfill&${\cal I}_2\neq0$&\omit&${\tt NP}<1$ or ${\tt NP}>{\tt N}$\hfil&&\cr
&\hfill&${\cal I}_1\neq0$&\omit&${\tt NQ}<1$\hfil&&\cr
%
&\hfill\quad${\cal I}_6{\cal I}_5=02$ with &${\cal I}_4\neq0$&\omit&{\tt Y} and/or
{\tt X} dimensions too small\hfil&&\cr
&\hfill&${\cal I}_3\neq0$&\omit&{\tt WE} and/or {\tt WD} 
dimensions too small\hfil&&\cr
&\hfill&${\cal I}_2\neq0$&\omit&{\tt IFIXX, STPD} and/or {\tt SCLD}
dimensions too small\hfil&&\cr
&\hfill&${\cal I}_1\neq0$&\omit&{\tt WORK} and/or {\tt IWORK} dimensions too
small\hfil&&\cr
%
&\quad${\cal I}_6{\cal I}_5=03$ with &${\cal I}_4\neq0$&\omit&{\tt STPB} and/or 
{\tt STPD} incorrect\hfil&&\cr
&\hfill&${\cal I}_3\neq0$&\omit&{\tt SCLB} and/or {\tt SCLD}
incorrect\hfil&&\cr
&\hfill&${\cal I}_2\neq0$&\omit&{\tt WE} incorrect\hfil&&\cr
&\hfill&${\cal I}_1\neq0$&\omit&{\tt WD} incorrect\hfil&&\cr
%
&\quad${\cal I}_6{\cal I}_5=04$\hfill&&\omit&error in derivatives\hfil&&\cr
%
\noalign{\hrule}
}}}
\centerline{\vbox{\offinterlineskip\hrule
\halign{&\vrule#&\quad#&\strut\quad#\ \ \cr
&Fatal Errors (continued):\hfill\span&\omit&\omit&&\cr
height2pt\vrule&&&\omit&&&\cr
%
&\quad${\cal I}_6{\cal I}_5=05$\hfill&&\omit&${\tt ISTOP}\neq0$ at last call to {\tt
FCN}\hfil&&\cr
&\omit&&\omit&(see argument 1-{\tt FCN})\hfil&&\cr
%
&\quad${\cal I}_6{\cal I}_5=06$\hfill&&\omit&numerical error detected\hfil&&\cr
%
&\quad${\cal I}_6{\cal I}_5=07$\hfill&&\omit&{\tt JOB} inconsistent with passed
arguments\hfil&&\cr
&\hfill&${\cal I}_4\neq0$&\omit&{\tt DELTA} absent or not associated\hfil&&\cr
&\hfill&${\cal I}_3\neq0$&\omit&{\tt WORK} absent or not associated\hfil&&\cr
&\hfill&${\cal I}_2\neq0$&\omit&{\tt IWORK} absent or not associated\hfil&&\cr
%
&\quad${\cal I}_6{\cal I}_5=08$ with &${\cal I}_4\ne0$&\omit& array allocation
failed for {\tt DELTA}\hfil&&\cr
&\hfill&${\cal I}_3\neq0$&\omit&array allocation failed for {\tt WORK}\hfil&&\cr
&\hfill&${\cal I}_2\neq0$&\omit&array allocation failed for {\tt IWORK}\hfil&&\cr
&\quad${\cal I}_6{\cal I}_5=09$ with &${\cal I}_4=1$&\omit&{\tt UPPER(I) $<$
LOWER(I)} for some {\tt I}\hfil&&\cr
&\hfill&${\cal I}_3=1$&\omit&initial {\tt BETA} outside the bounds\hfil&&\cr
&\hfill&${\cal I}_2=1$&\omit&bounds too small for calculating the
number\hfil&&\cr
&&&\omit&of
reliable digits {\tt NDIGIT}\hfil&&\cr
&\hfill&${\cal I}_2=2$&\omit&bounds too small for derivative
calculations\hfil&&\cr
&\hfill bit &({\cal I})\hfill &\omit&array dimensions too small for one or more
of&&\cr
&\hfill 0 &(1)\hfill &\omit&{\tt BETA}&&\cr
&\hfill 1 &(2)\hfill &\omit&{\tt Y}&&\cr
&\hfill 2 &(4)\hfill &\omit&{\tt X}&&\cr
&\hfill 3 &(8)\hfill &\omit&{\tt DELTA}&&\cr
&\hfill 4 &(16)\hfill &\omit&{\tt WE}&&\cr
&\hfill 5 &(32)\hfill &\omit&{\tt WD}&&\cr
&\hfill 6 &(64)\hfill &\omit&{\tt IFIXB}&&\cr
&\hfill 7 &(128)\hfill &\omit&{\tt IFIXX}&&\cr
&\hfill 8 &(256)\hfill &\omit&{\tt STPB}&&\cr
&\hfill 9 &(512)\hfill &\omit&{\tt STPD}&&\cr
&\hfill 10 &(1024)\hfill &\omit&{\tt SCLB}&&\cr
&\hfill 11 &(2048)\hfill &\omit&{\tt SCLD}&&\cr
&\hfill 12 &(4096)\hfill &\omit&{\tt WORK}&&\cr
&\hfill 13 &(8192)\hfill &\omit&{\tt IWORK}&&\cr
&\hfill 14 &(16384)\hfill &\omit&{\tt UPPER}&&\cr
&\hfill 15 &(32768)\hfill &\omit&{\tt LOWER}&&\cr
}\hrule}}

\aligntobox Note that ${\tt INFO}=60000$ indicates an error possibly caused by
incorrectly specified user input to ODRPACK95, and more commonly by a poor choice of scale or weights, or a discontinuity in the derivatives.

\noindent{$\Longrightarrow30\ -\ $}{\tt LOWER [<real> LOWER(NP)]}

\aligntobox The lower bound of 6-{\tt BETA}.  ODRPACK95 will maintain {\tt
LOWER(I)}$\le${\tt BETA(I)} for {\tt I}$= 1,\ldots,{\tt NP}$.

\noindent{$\Longrightarrow31\ -\ $}{\tt UPPER [<real> UPPER(NP)]}

\aligntobox The upper bound of 6-{\tt BETA}.  ODRPACK95 will maintain {\tt
UPPER(I)}$\ge${\tt BETA(I)} for {\tt I}$= 1,\ldots,{\tt NP}$.

\bigskip\noindent{\bf 2.B. Examples}\medskip

\noindent The following sample programs invoke {\tt ODR} to solve the examples of explicit, implicit and multiresponse problems shown in \S 1.A.

\noindent The first program invokes {\tt ODR} with user supplied derivatives,
the second program invokes {\tt ODR} with the derivatives approximated by
ODRPACK95 using forward finite differences, and the third invokes {\tt ODR} with central finite difference derivatives. The use of forward or central difference derivatives generally causes very little change in the results from those obtained using analytic derivatives. (See \S 4.A.)

\noindent Users are encouraged to use these examples, modified as necessary, to
form their own ODRPACK95 drivers. 

\bigskip\noindent{\bf 2.B.i. Example Problem for an Explicit Model}
\medskip
\noindent The following sample program invokes {\tt ODR} to solve example 3.2.2 on pages 230--238 of [Fuller, 1987]. The data $(x_{i},y-{i})$ are the percent saturation of nitrogen gas in a brine solution forced into the pores of sandstone, and the observed compressional wave velocity of ultrasonic signals propagated through the sandstone, respectively. These data (listed in \S 2.B.i.b) are modeled by the explicit function
$$y_{i}\approx
f(x_{i};\beta)\equiv\beta_{1}+\beta_{2}[e^{\beta_{3}x_{i}}-1]^{2},\quad
i=1,\ldots,n.$$
The starting values for the model parameters are
$$\beta\ =\ (1500.0,-50.0,-0.1)^{\rm T}$$
and $\Delta$ is initialized to zero.

\noindent Fuller notes that it is reasonable to believe that the saturation measurements of 0\% and 100\% are more precise than the other saturation measurements. We have thus ``fixed'' $x_1,x_2$ and $x_{12}$ at their original values. As a consequence, $\delta_{1}^{*}=\delta_{2}^{*}=\delta_{12}^{*}=0$ at the solution. We assume the remaining observed data are all of equal precision, and thus set
$w_\epsilon=w_\delta=1$ using ODRPACK95's structured argument feature. The remaining arguments are set to their default values. (See \S 1.G.)

\bigskip\noindent{\bf 2.B.i.a. User Supplied Code (file {\tt drive1.f})}
\medskip

{
\ttVIII\baselineskip=8pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
      PROGRAM SAMPLE
      USE ODRPACK95
      USE REAL_PRECISION
\phantom{blank line}
C  ODRPACK95 Argument Definitions
C      ==> FCN      Name of the user supplied function subroutine
C      ==> N        Number of observations 
C      ==> M        Columns of data in the explanatory variable
C      ==> NP       Number of parameters
C      ==> NQ       Number of responses per observation
C     <==> BETA     Function parameters
C      ==> Y        Response variable
C      ==> X        Explanatory variable
C      ==> WE       "Epsilon" weights
C      ==> WD       "Delta" weights
C      ==> IFIXB    Indicators for "fixing" parameters (BETA)
C      ==> IFIXX    Indicators for "fixing" explanatory variable (X)
C      ==> JOB      Task to be performed 
C      ==> NDIGIT   Good digits in subroutine function results
C      ==> TAUFAC   Trust region initialization factor
C      ==> SSTOL    Sum of squares convergence criterion
C      ==> PARTOL   Parameter convergence criterion
C      ==> MAXIT    Maximum number of iterations
C      ==> IPRINT   Print control 
c      ==> LUNERR   Logical unit for error reports 
C      ==> LUNRPT   Logical unit for computation reports 
C      ==> STPB     Step sizes for finite difference derivatives wrt BETA
C      ==> STPD     Step sizes for finite difference derivatives wrt DELTA
C      ==> SCLB     Scale values for parameters BETA
C      ==> SCLD     Scale values for errors delta in explanatory variable 
C     <==> WORK     REAL (KIND=R8) work vector
C     <==  IWORK    Integer work vector
C     <==  INFO     Stopping condition 
\phantom{blank line}
C  Parameters specifying maximum problem sizes handled by this driver
C     MAXN          Maximum number of observations 
C     MAXM          Maximum number of columns in explanatory variable
C     MAXNP         Maximum number of function parameters
C     MAXNQ         Maximum number of responses per observation
\phantom{blank line}
C  Parameter Declarations and Specifications
      INTEGER    LDIFX,LDSCLD,LDSTPD,LDWD,LDWE,LDX,LDY,LD2WD,LD2WE,
     &           LIWORK,LWORK,MAXM,MAXN,MAXNP,MAXNQ
      PARAMETER (MAXM=5,MAXN=25,MAXNP=5,MAXNQ=1,
     &           LDY=MAXN,LDX=MAXN,
     &           LDWE=1,LD2WE=1,LDWD=1,LD2WD=1,
     &           LDIFX=MAXN,LDSTPD=1,LDSCLD=1,
     &           LWORK=18 + 11*MAXNP + MAXNP**2 + MAXM + MAXM**2 + 
     &                 4*MAXN*MAXNQ + 6*MAXN*MAXM + 2*MAXN*MAXNQ*MAXNP +  
     &                 2*MAXN*MAXNQ*MAXM + MAXNQ**2 + 
     &                 5*MAXNQ + MAXNQ*(MAXNP+MAXM) + LDWE*LD2WE*MAXNQ,
     &           LIWORK=20+MAXNP+MAXNQ*(MAXNP+MAXM))
\phantom{blank line}
C  Variable Declarations 
      INTEGER        I,INFO,IPRINT,J,JOB,L,LUNERR,LUNRPT,M,MAXIT,N,
     &               NDIGIT,NP,NQ
      INTEGER        IFIXB(MAXNP),IFIXX(LDIFX,MAXM),IWORK(:)
      REAL (KIND=R8) PARTOL,SSTOL,TAUFAC
      REAL (KIND=R8) BETA(MAXNP),SCLB(MAXNP),SCLD(LDSCLD,MAXM),
     &               STPB(MAXNP),STPD(LDSTPD,MAXM),
     &               WD(LDWD,LD2WD,MAXM),WE(LDWE,LD2WE,MAXNQ),
     &               WORK(:),X(LDX,MAXM),Y(LDY,MAXNQ)
      EXTERNAL       FCN
      POINTER        IWORK,WORK
\phantom{blank line}
\phantom{blank line}
C  Allocate work arrays
      ALLOCATE(IWORK(LIWORK),WORK(LWORK))
\phantom{blank line}
C  Specify default values for ODR arguments
      WE(1,1,1)  = -1.0E0_R8
      WD(1,1,1)  = -1.0E0_R8
      IFIXB(1)   = -1
      IFIXX(1,1) = -1
      JOB        = -1
      NDIGIT     = -1
      TAUFAC     = -1.0E0_R8
      SSTOL      = -1.0E0_R8
      PARTOL     = -1.0E0_R8
      MAXIT      = -1
      IPRINT     = -1
      LUNERR     = -1
      LUNRPT     = -1
      STPB(1)    = -1.0E0_R8
      STPD(1,1)  = -1.0E0_R8
      SCLB(1)    = -1.0E0_R8
      SCLD(1,1)  = -1.0E0_R8
\phantom{blank line}
C  Set up ODRPACK95 report files
      LUNERR  =   9
      LUNRPT  =   9
      OPEN (UNIT=9,FILE='REPORT1')
\phantom{blank line}
C  Read problem data, and set nondefault value for argument IFIXX
      OPEN (UNIT=5,FILE='DATA1')
      READ (5,FMT=*) N,M,NP,NQ
      READ (5,FMT=*) (BETA(I),I=1,NP)
      DO 10 I=1,N
         READ (5,FMT=*) (X(I,J),J=1,M),(Y(I,L),L=1,NQ)
         IF (X(I,1).EQ.0.0E0_R8 .OR. X(I,1).EQ.100.0E0_R8) THEN
            IFIXX(I,1) = 0
         ELSE
            IFIXX(I,1) = 1
         END IF
   10 CONTINUE
\phantom{blank line}
C  Specify task: Explicit orthogonal distance regression
C                With user supplied derivatives (checked)
C                Covariance matrix constructed with recomputed derivatives
C                Delta initialized to zero
C                Not a restart
C  And indicate short initial report
C               Short iteration reports every iteration, and
C               Long final report
      JOB     = 00020
      IPRINT  = 1112
\phantom{blank line}
C  Compute solution
      CALL ODR(FCN=FCN,
     &         N=N,M=M,NP=NP,NQ=NQ,
     &         BETA=BETA,
     &         Y=Y,X=X,
     &         WE=WE,WD=WD,
     &         IFIXB=IFIXB,IFIXX=IFIXX,
     &         JOB=JOB,NDIGIT=NDIGIT,TAUFAC=TAUFAC,
     &         SSTOL=SSTOL,PARTOL=PARTOL,MAXIT=MAXIT,
     &         IPRINT=IPRINT,LUNERR=LUNERR,LUNRPT=LUNRPT,
     &         STPB=STPB,STPD=STPD,
     &         SCLB=SCLB,SCLD=SCLD,
     &         WORK=WORK,IWORK=IWORK,
     &         INFO=INFO)
      END
\phantom{blank line}
\phantom{blank line}
      SUBROUTINE FCN(N,M,NP,NQ,
     &               LDN,LDM,LDNP,
     &               BETA,XPLUSD,
     &               IFIXB,IFIXX,LDIFX,
     &               IDEVAL,F,FJACB,FJACD,
     &               ISTOP)
\phantom{blank line}
C  Subroutine arguments
C      ==> N        Number of observations
C      ==> M        Number of columns in explanatory variable
C      ==> NP       Number of parameters
C      ==> NQ       Number of responses per observation
C      ==> LDN      Leading dimension declarator equal or exceeding N
C      ==> LDM      Leading dimension declarator equal or exceeding M
C      ==> LDNP     Leading dimension declarator equal or exceeding NP
C      ==> BETA     Current values of parameters
C      ==> XPLUSD   Current value of explanatory variable, i.e., X + DELTA
C      ==> IFIXB    Indicators for "fixing" parameters (BETA)
C      ==> IFIXX    Indicators for "fixing" explanatory variable (X)
C      ==> LDIFX    Leading dimension of array IFIXX
C      ==> IDEVAL   Indicator for selecting computation to be performed
C     <==  F        Predicted function values
C     <==  FJACB    Jacobian with respect to BETA
C     <==  FJACD    Jacobian with respect to errors DELTA
C     <==  ISTOP    Stopping condition, where
C                     0 means current BETA and X+DELTA were
C                       acceptable and values were computed successfully
C                     1 means current BETA and X+DELTA are
C                       not acceptable;  ODRPACK95 should select values 
C                       closer to most recently used values if possible
C                    -1 means current BETA and X+DELTA are 
C                       not acceptable; ODRPACK95 should stop
\phantom{blank line}
C  Used modules
      USE REAL_PRECISION
\phantom{blank line}
C  Input arguments, not to be changed by this routine:
      INTEGER          I,IDEVAL,ISTOP,L,LDIFX,LDM,LDN,LDNP,M,N,NP,NQ
      REAL (KIND=R8) BETA(NP),XPLUSD(LDN,M)
      INTEGER          IFIXB(NP),IFIXX(LDIFX,M)
C  Output arguments:
      REAL (KIND=R8) F(LDN,NQ),FJACB(LDN,LDNP,NQ),FJACD(LDN,LDM,NQ)
C  Local variables
      INTRINSIC        EXP
\phantom{blank line}
\phantom{blank line}
C  Do something with IFIXB and IFIXX to avoid warnings that they are not being
C  used.  This is simply not to worry users that the example program is failing.
      IF (IFIXB(1) .GT. 0 .AND. IFIXX(1,1) .GT. 0 ) THEN
C        Do nothing.
      END IF
\phantom{blank line}
\phantom{blank line}
C  Check for unacceptable values for this problem
      IF (BETA(1) .LT. 0.0E0_R8) THEN
         ISTOP = 1
         RETURN
      ELSE
         ISTOP = 0
      END IF
\phantom{blank line}
C  Compute predicted values
      IF (MOD(IDEVAL,10).GE.1) THEN
         DO 110 L = 1,NQ
            DO 100 I = 1,N
               F(I,L) = BETA(1) + 
     &                  BETA(2)*(EXP(BETA(3)*XPLUSD(I,1)) - 1.0E0_R8)**2
  100       CONTINUE
  110    CONTINUE
      END IF
\phantom{blank line}
C  Compute derivatives with respect to BETA
      IF (MOD(IDEVAL/10,10).GE.1) THEN
         DO 210 L = 1,NQ
            DO 200 I = 1,N
               FJACB(I,1,L) = 1.0E0_R8
               FJACB(I,2,L) = (EXP(BETA(3)*XPLUSD(I,1)) - 1.0E0_R8)**2
               FJACB(I,3,L) = BETA(2)*2*
     &                        (EXP(BETA(3)*XPLUSD(I,1)) - 1.0E0_R8)*
     &                        EXP(BETA(3)*XPLUSD(I,1))*XPLUSD(I,1)
  200       CONTINUE
  210    CONTINUE
      END IF
\phantom{blank line}
C  Compute derivatives with respect to DELTA
      IF (MOD(IDEVAL/100,10).GE.1) THEN
         DO 310 L = 1,NQ
            DO 300 I = 1,N
               FJACD(I,1,L) = BETA(2)*2*
     &                        (EXP(BETA(3)*XPLUSD(I,1)) - 1.0E0_R8)*
     &                        EXP(BETA(3)*XPLUSD(I,1))*BETA(3)
  300       CONTINUE
  310    CONTINUE
      END IF
\phantom{blank line}
      RETURN
      END
}}
\vfil\eject

\noindent{\bf 2.B.i.b. User Supplied Data (file {\tt data1})}
{
\ttVIII\baselineskip=8pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
   12    1    3    1
1500.0  -50.0  -0.1
    0.0   1265.0 
    0.0   1263.6 
    5.0   1258.0 
    7.0   1254.0 
    7.5   1253.0 
   10.0   1249.8 
   16.0   1237.0 
   26.0   1218.0 
   30.0   1220.6 
   34.0   1213.8 
   34.5   1215.5 
  100.0   1212.0
}}
\ \vfil\eject

\noindent{\bf 2.B.i.c. Report Generated by ODRPACK95 (file {\tt drive1.out})}

{
\ttVIII\baselineskip=8pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
 ********************************************************* 
 * ODRPACK95 version 1.00 of 12-27-2005 (REAL (KIND=R8)) * 
 ********************************************************* 
\phantom{blank line}
\phantom{blank line}
\phantom{blank line}
 *** Derivative checking report for fit by method of ODR ***
\phantom{blank line}
\phantom{blank line}
     For response  1 of observation     3
\phantom{blank line}
                               User                               
                           Supplied     Relative    Derivative 
        Derivative WRT        Value   Difference    Assessment 
\phantom{blank line}
             BETA(  1)     1.00E+00     0.00E+00    Verified
             BETA(  2)     1.55E-01     1.03E-06    Verified
             BETA(  3)     1.19E+02     2.96E-06    Verified
          DELTA( 3, 1)    -2.39E+00     2.96E-06    Verified
\phantom{blank line}
     Number of reliable digits in function results          16
        (estimated by ODRPACK95)
\phantom{blank line}
     Number of digits of agreement required between      
     user supplied and finite difference derivative for  
     user supplied derivative to be considered verified      4
\phantom{blank line}
     Row number at which derivatives were checked            3
\phantom{blank line}
       -values of the explanatory variables at this row
\phantom{blank line}
          X( 3, 1)   5.00000000E+00
 ********************************************************* 
 * ODRPACK95 version 1.00 of 12-27-2005 (REAL (KIND=R8)) * 
 ********************************************************* 
\phantom{blank line}
\phantom{blank line}
 *** Initial summary for fit by method of ODR ***
\phantom{blank line}
 --- Problem Size:
            N =    12          (number with nonzero weight =    12)
           NQ =     1
            M =     1
           NP =     3          (number unfixed =     3)
\phantom{blank line}
 --- Control Values:
          JOB = 00020
              = ABCDE, where
                       A=0 ==> fit is not a restart.
                       B=0 ==> deltas are initialized to zero.
                       C=0 ==> covariance matrix will be computed using
                               derivatives re-evaluated at the solution.
                       D=2 ==> derivatives are supplied by user.
                               derivatives were checked.
                               results appear correct.
                       E=0 ==> method is explicit ODR.
       NDIGIT =    16          (estimated by ODRPACK95)
       TAUFAC =     1.00E+00
\phantom{blank line}
 --- Stopping Criteria:
        SSTOL =     1.49E-08   (sum of squares stopping tolerance)
       PARTOL =     3.67E-11   (parameter stopping tolerance)
        MAXIT =    50          (maximum number of iterations)
\phantom{blank line}
 --- Initial Weighted Sum of Squares        =                    6.63720354E+05
         Sum of Squared Weighted Deltas     =   0.00000000E+00
         Sum of Squared Weighted Epsilons   =   6.63720354E+05
\phantom{blank line}
 *** Iteration reports for fit by method of ODR ***
\phantom{blank line}
\phantom{blank line}
         Cum.                 Act. Rel.   Pred. Rel.
  It.  No. FN     Weighted   Sum-of-Sqs   Sum-of-Sqs              G-N
 Num.   Evals   Sum-of-Sqs    Reduction    Reduction  TAU/PNORM  Step
 ----  ------  -----------  -----------  -----------  ---------  ----
\phantom{blank line}
    1      19  2.51166E+01   9.9996E-01   9.9997E-01  3.499E-01   YES
    2      20  2.14730E+01   1.4507E-01   1.5249E-01  6.900E-02   YES
    3      21  2.14463E+01   1.2418E-03   1.4631E-03  8.573E-03   YES
    4      22  2.14455E+01   3.7676E-05   4.7131E-05  2.016E-03   YES
    5      23  2.14455E+01   1.5116E-06   1.8950E-06  3.927E-04   YES
    6      24  2.14455E+01   6.2002E-08   7.7723E-08  8.017E-05   YES
    7      25  2.14455E+01   2.5359E-09   3.1790E-09  1.617E-05   YES
\phantom{blank line}
 *** Final summary for fit by method of ODR ***
\phantom{blank line}
 --- Stopping Conditions:
         INFO =     1 ==> sum of squares convergence.
        NITER =     7          (number of iterations)
         NFEV =    25          (number of function evaluations)
         NJEV =     8          (number of jacobian evaluations)
        IRANK =     0          (rank deficiency)
        RCOND =     6.12E-03   (inverse condition number)
        ISTOP =     0          (returned by user from subroutine FCN)
\phantom{blank line}
 --- Final Weighted Sums of Squares       =                     2.14455017E+01
         Sum of Squared Weighted Deltas   =    7.78974669E+00
         Sum of Squared Weighted Epsilons =    1.36557550E+01
\phantom{blank line}
 --- Residual Standard Deviation          =                     1.54364294E+00
         Degrees of Freedom               =    9
\phantom{blank line}
 --- Estimated BETA(J), J = 1, ..., NP:
\phantom{blank line}
                     BETA      LOWER     UPPER      S.D.  ___ 95% Confidence ___
                                                    BETA         Interval
\phantom{blank line}
       1   1.26465481E+03  -1.80+308  1.80+308  1.03E+00   1.26E+03 to  1.27E+03
       2  -5.40184100E+01  -1.80+308  1.80+308  1.58E+00  -5.76E+01 to -5.04E+01
       3  -8.78497122E-02  -1.80+308  1.80+308  6.33E-03  -1.02E-01 to -7.35E-02
\phantom{blank line}
 --- Estimated EPSILON(I) and DELTA(I,*), I = 1, ..., N:
\phantom{blank line}
         I    EPSILON(I,1)      DELTA(I,1)
\phantom{blank line}
         1 -3.45194935E-01  0.00000000E+00
         2  1.05480506E+00  0.00000000E+00
         3 -3.00719286E-02 -6.50838155E-02
         4 -1.13916405E-01 -2.67201445E-01
         5 -1.40250730E-01 -3.31357554E-01
         6 -5.53155555E-01 -1.30641313E+00
         7 -6.99564762E-01 -1.32525687E+00
         8  1.88412530E+00  1.45885497E+00
         9 -1.70916306E+00 -1.18803577E+00
        10  1.80916198E+00  7.71243449E-01
        11  1.90299896E-01  8.24139253E-02
        12 -1.34707485E+00  0.00000000E+00
}}
\vfil\eject

\noindent{\bf 2.B.ii. Example Problem for an Implicit Model}
\medskip

\noindent This sample program invokes {\tt ODR} to solve the implicit
problem shown in example 3.2.4 on page 244 of [Fuller, 1987]. In this
example, the data (listed in \S 2.B.ii.b) are observations digitized
from the x-ray image of a hip prosthesis, where the variables
$x_i=(v_i,h_i),\ i=1,\ldots,n$, are the vertical and horizontal distances from the origin, respectively, and the implicit model is that of the ellipse 
$$f_i(x_i;\beta)\ \equiv\
\beta_3(v_i-\beta_1)^2+2\beta_4(v_i-\beta_1)(h_i-\beta_2)+\beta_5(h_i-\beta_2)^2\ =\ 0$$
for $i = 1,\ldots,n$. The starting values for the model parameters are
$$\beta\ =\ (-1.0,-3.0,0.09,0.02,0.08)^{\rm T}$$
and $\Delta$ is initialized to zero. Since the observed data are all of equal
precision, we set $w_\delta=1$ using ODRPACK95's structured argument feature. The remaining arguments are set to their default values. (See \S 1.G.)

\bigskip\noindent{\bf 2.B.ii.a. User Supplied Code (file {\tt drive2.f})}

{
\ttVIII\baselineskip=8pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
      PROGRAM SAMPLE
      USE ODRPACK95
      USE REAL_PRECISION
\phantom{blank line}
C  ODRPACK95 Argument Definitions
C      ==> FCN      Name of the user supplied function subroutine
C      ==> N        Number of observations 
C      ==> M        Columns of data in the explanatory variable
C      ==> NP       Number of parameters
C      ==> NQ       Number of responses per observation
C     <==> BETA     Function parameters
C      ==> Y        Response variable (unused when model is implicit)
C      ==> X        Explanatory variable
C      ==> WE       Initial penalty parameter for implicit model
C      ==> WD       "Delta" weights
C      ==> JOB      Task to be performed
C      ==> IPRINT   Print control
C      ==> LUNERR   Logical unit for error reports
C      ==> LUNRPT   Logical unit for computation reports
C     <==> WORK     REAL (KIND=R8) work vector
C     <==  IWORK    Integer work vector
C     <==  INFO     Stopping condition 
\phantom{blank line}
C  Parameters specifying maximum problem sizes handled by this driver
C     MAXN          Maximum number of observations 
C     MAXM          Maximum number of columns in explanatory variable
C     MAXNP         Maximum number of function parameters
C     MAXNQ         Maximum number of responses per observation
\phantom{blank line}
C  Parameter declarations and specifications
      INTEGER    LDWD,LDWE,LDX,LDY,LD2WD,LD2WE,
     &           LIWORK,LWORK,MAXM,MAXN,MAXNP,MAXNQ
      PARAMETER (MAXM=5,MAXN=25,MAXNP=5,MAXNQ=2,
     &           LDY=MAXN,LDX=MAXN,
     &           LDWE=1,LD2WE=1,LDWD=1,LD2WD=1,
     &           LWORK=18 + 11*MAXNP + MAXNP**2 + MAXM + MAXM**2 + 
     &                 4*MAXN*MAXNQ + 6*MAXN*MAXM + 2*MAXN*MAXNQ*MAXNP +  
     &                 2*MAXN*MAXNQ*MAXM + MAXNQ**2 + 
     &                 5*MAXNQ + MAXNQ*(MAXNP+MAXM) + LDWE*LD2WE*MAXNQ,
     &           LIWORK=20+MAXNP+MAXNQ*(MAXNP+MAXM))
\phantom{blank line}
C  Variable declarations 
      INTEGER        I,INFO,IPRINT,J,JOB,LUNERR,LUNRPT,M,N,NP,NQ
      INTEGER        IWORK(:)   
      REAL (KIND=R8) BETA(MAXNP),
     &               WD(LDWD,LD2WD,MAXM),WE(LDWE,LD2WE,MAXNQ),
     &               WORK(:),X(LDX,MAXM),Y(LDY,MAXNQ)
      EXTERNAL       FCN
      POINTER        IWORK,WORK
\phantom{blank line}
\phantom{blank line}
C  Allocate work arrays
      ALLOCATE(IWORK(LIWORK),WORK(LWORK))
\phantom{blank line}
C  Specify default values for DODR arguments
      WE(1,1,1)  = -1.0E0_R8
      WD(1,1,1)  = -1.0E0_R8
      JOB        = -1
      IPRINT     = -1
      LUNERR     = -1
      LUNRPT     = -1
\phantom{blank line}
C  Set up ODRPACK95 report files
      LUNERR  =   9
      LUNRPT  =   9
      OPEN (UNIT=9,FILE='REPORT2')
\phantom{blank line}
C  Read problem data
      OPEN (UNIT=5,FILE='DATA2')
      READ (5,FMT=*) N,M,NP,NQ
      READ (5,FMT=*) (BETA(I),I=1,NP)
      DO 10 I=1,N
         READ (5,FMT=*) (X(I,J),J=1,M)
   10 CONTINUE
\phantom{blank line}
C  Specify task: Implicit orthogonal distance regression
C                With forward finite difference derivatives
C                Covariance matrix constructed with recomputed derivatives
C                DELTA initialized to zero
C                Not a restart
      JOB     = 00001
\phantom{blank line}
C  Compute solution
      CALL ODR(FCN=FCN,
     &         N=N,M=M,NP=NP,NQ=NQ,
     &         BETA=BETA,
     &         Y=Y,X=X,
     &         WE=WE,WD=WD,
     &         JOB=JOB,
     &         IPRINT=IPRINT,LUNERR=LUNERR,LUNRPT=LUNRPT,
     &         WORK=WORK,IWORK=IWORK,
     &         INFO=INFO)
      END
\phantom{blank line}
\phantom{blank line}
      SUBROUTINE FCN(N,M,NP,NQ,
     &               LDN,LDM,LDNP,
     &               BETA,XPLUSD,
     &               IFIXB,IFIXX,LDIFX,
     &               IDEVAL,F,FJACB,FJACD,
     &               ISTOP)
\phantom{blank line}
C  Subroutine Arguments
C      ==> N        Number of observations
C      ==> M        Number of columns in explanatory variable
C      ==> NP       Number of parameters
C      ==> NQ       Number of responses per observation
C      ==> LDN      Leading dimension declarator equal or exceeding N
C      ==> LDM      Leading dimension declarator equal or exceeding M
C      ==> LDNP     Leading dimension declarator equal or exceeding NP
C      ==> BETA     Current values of parameters
C      ==> XPLUSD   Current value of explanatory variable, i.e., X + DELTA
C      ==> IFIXB    Indicators for "fixing" parameters (BETA)
C      ==> IFIXX    Indicators for "fixing" explanatory variable (X)
C      ==> LDIFX    Leading dimension of array IFIXX
C      ==> IDEVAL   Indicator for selecting computation to be performed
C     <==  F        Predicted function values
C     <==  FJACB    Jacobian with respect to BETA
C     <==  FJACD    Jacobian with respect to errors DELTA
C     <==  ISTOP    Stopping condition, where
C                     0 Means current BETA and X+DELTA were
C                       acceptable and values were computed successfully
C                     1 Means current BETA and X+DELTA are
C                       not acceptable;  ODRPACK95 should select values  
C                       closer to most recently used values if possible
C                    -1 Means current BETA and X+DELTA are
C                       not acceptable;  ODRPACK95 should stop
\phantom{blank line}
C  Used Modules
      USE REAL_PRECISION
\phantom{blank line}
C  Input arguments, not to be changed by this routine:
      INTEGER          I,IDEVAL,ISTOP,L,LDIFX,LDM,LDN,LDNP,M,N,NP,NQ
      REAL (KIND=R8) BETA(NP),XPLUSD(LDN,M)
      INTEGER          IFIXB(NP),IFIXX(LDIFX,M)
C  Output arguments:
      REAL (KIND=R8) F(LDN,NQ),FJACB(LDN,LDNP,NQ),FJACD(LDN,LDM,NQ)
\phantom{blank line}
\phantom{blank line}
C  Do something with FJACD, FJACB, IFIXB and IFIXX to avoid warnings that they 
C  are not being used.  This is simply not to worry users that the example 
C  program is failing.
      IF (IFIXB(1) .GT. 0 .AND. IFIXX(1,1) .GT. 0 
     &    .AND. FJACB(1,1,1) .GT. 0 .AND. FJACD(1,1,1) .GT. 0 ) THEN
C        Do nothing.
      END IF
\phantom{blank line}
\phantom{blank line}
C  Check for unacceptable values for this problem
      IF (BETA(1) .GT. 0.0E0_R8) THEN
         ISTOP = 1
         RETURN
      ELSE
         ISTOP = 0
      END IF
\phantom{blank line}
C  Compute predicted values
      IF (MOD(IDEVAL,10).GE.1) THEN
         DO 110 L = 1,NQ
            DO 100 I = 1,N
               F(I,L) = BETA(3)*(XPLUSD(I,1)-BETA(1))**2 +
     &                  2*BETA(4)*(XPLUSD(I,1)-BETA(1))*
     &                            (XPLUSD(I,2)-BETA(2)) +
     &                  BETA(5)*(XPLUSD(I,2)-BETA(2))**2 - 1.0E0_R8
  100       CONTINUE
  110    CONTINUE
      END IF
\phantom{blank line}
      RETURN
      END
}}
\vfil\eject

\noindent{\bf 2.B.ii.b. User Supplied Data (file {\tt data2})}

{
\ttVIII\baselineskip=8pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
  20  2  5  1
  -1.0 -3.0 0.09 0.02 0.08
  0.50  -0.12
  1.20  -0.60
  1.60  -1.00
  1.86  -1.40
  2.12  -2.54
  2.36  -3.36
  2.44  -4.00
  2.36  -4.75
  2.06  -5.25
  1.74  -5.64
  1.34  -5.97
  0.90  -6.32
 -0.28  -6.44
 -0.78  -6.44
 -1.36  -6.41
 -1.90  -6.25
 -2.50  -5.88
 -2.88  -5.50
 -3.18  -5.24
 -3.44  -4.86
}}
\vfil\eject

\noindent{\bf 2.B.ii.c. Report Generated by ODRPACK95 (file {\tt drive2.out})}

{
\ttVIII\baselineskip=8pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
 ********************************************************* 
 * ODRPACK95 version 1.00 of 12-27-2005 (REAL (KIND=R8)) * 
 ********************************************************* 
\phantom{blank line}
\phantom{blank line}
 *** Initial summary for fit by method of ODR ***
\phantom{blank line}
 --- Problem Size:
            N =    20          (number with nonzero weight =    20)
           NQ =     1
            M =     2
           NP =     5          (number unfixed =     5)
\phantom{blank line}
 --- Control Values:
          JOB = 00001
              = ABCDE, where
                       A=0 ==> fit is not a restart.
                       B=0 ==> deltas are initialized to zero.
                       C=0 ==> covariance matrix will be computed using
                               derivatives re-evaluated at the solution.
                       D=0 ==> derivatives are estimated by forward differences.
                       E=1 ==> method is implicit ODR.
       NDIGIT =    15          (estimated by ODRPACK95)
       TAUFAC =     1.00E+00
\phantom{blank line}
 --- Stopping Criteria:
        SSTOL =     1.49E-08   (sum of squares stopping tolerance)
       PARTOL =     6.06E-06   (parameter stopping tolerance)
        MAXIT =   100          (maximum number of iterations)
\phantom{blank line}
 --- Initial Sum of Squared Weighted Deltas =                    0.00000000E+00
         Initial Penalty Function Value     =   8.39823392E-01
                 Penalty Term               =   8.39823392E-01
                 Penalty Parameter          =   1.0E+01
\phantom{blank line}
 --- Function Parameter Summary:
\phantom{blank line}
       Index   BETA(K)    Fixed     Scale   LOWER(K)   UPPER(K)    Derivative
                                                                    Step Size
         (K)            (IFIXB)    (SCLB)                              (STPB)
\phantom{blank line}
           1 -1.00E+00       NO  1.00E+00 -1.80E+308  1.80E+308   3.16228E-10
           2 -3.00E+00       NO  3.33E-01 -1.80E+308  1.80E+308   3.16228E-10
           3  9.00E-02       NO  1.11E+01 -1.80E+308  1.80E+308   3.16228E-10
           4  2.00E-02       NO  5.00E+01 -1.80E+308  1.80E+308   3.16228E-10
           5  8.00E-02       NO  1.25E+01 -1.80E+308  1.80E+308   3.16228E-10
\phantom{blank line}
 --- Explanatory Variable and Delta Weight Summary:
\phantom{blank line}
       Index      X(I,J)  DELTA(I,J)    Fixed     Scale    Weight    Derivative
                                                                      Step Size
       (I,J)                          (IFIXX)    (SCLD)      (WD)        (STPD)
\phantom{blank line}
         1,1   5.000E-01   0.000E+00       NO  2.00E+00  1.00E+00   3.16228E-10
         N,1  -3.440E+00   0.000E+00       NO  2.91E-01  1.00E+00   3.16228E-10
\phantom{blank line}
         1,2  -1.200E-01   0.000E+00       NO  8.33E+00  1.00E+00   3.16228E-10
         N,2  -4.860E+00   0.000E+00       NO  2.06E-01  1.00E+00   3.16228E-10
\phantom{blank line}
 *** Final summary for fit by method of ODR ***
\phantom{blank line}
 --- Stopping Conditions:
         INFO =     2 ==> parameter convergence.
        NITER =    18          (number of iterations)
         NFEV =   217          (number of function evaluations)
        IRANK =     0          (rank deficiency)
        RCOND =     3.18E-02   (inverse condition number)
        ISTOP =     0          (returned by user from subroutine FCN)
\phantom{blank line}
 --- Final Sum of Squared Weighted Deltas =                     8.82420346E-02
         Final Penalty Function Value     =    8.82445616E-02
               Penalty Term               =    2.52701227E-06
               Penalty Parameter          =    1.0E+05
\phantom{blank line}
 --- Residual Standard Deviation          =                     7.66994283E-02
         Degrees of Freedom               =   15
\phantom{blank line}
 --- Estimated BETA(J), J = 1, ..., NP:
\phantom{blank line}
                     BETA      LOWER     UPPER      S.D.  ___ 95% Confidence ___
                                                    BETA         Interval
\phantom{blank line}
       1  -9.99380462E-01  -1.80+308  1.80+308  1.11E-01  -1.24E+00 to -7.62E-01
       2  -2.93104890E+00  -1.80+308  1.80+308  1.10E-01  -3.17E+00 to -2.70E+00
       3   8.75730642E-02  -1.80+308  1.80+308  4.11E-03   7.88E-02 to  9.63E-02
       4   1.62299601E-02  -1.80+308  1.80+308  2.75E-03   1.04E-02 to  2.21E-02
       5   7.97538109E-02  -1.80+308  1.80+308  3.50E-03   7.23E-02 to  8.72E-02
}}
\vfil\eject

\noindent{\bf 2.B.iii. Example Problem for an Explicit Model with Multiresponse Data}
\medskip
\noindent The problem shown here is an example of multiresponse data that originates because the underlying data are complex. The problem is described in Chapter 4, and on pages 280--281, of [Bates and Watts, 1988]. In this case, the dependent variable is the pair of values representing the real and imaginary parts of complex-valued impedance measurements of a polymer, $z_i,\
i=1,\ldots,n$, and the explanatory variable, $x_i,\ i=1,\ldots,n$ is the (real-valued) frequency. The data are shown in \S 2.B.iii.b. The function form is explicit, representing the dielectric constant by the general model proposed by [Havriliak and Negami, 1967]
$$[\Re(z_i),\Im(z_i)]\approx\beta_2 +{{\beta_1-\beta_2}\over{\bigl(1+(\jmath2\pi x_i e^{-\beta_3})^{\beta_4}\bigr)^{\beta_5}}}$$ 
for $i = 1,\ldots,n$, where $\jmath=\sqrt{-1}$. For ODRPACK95, this must be encoded as two-term multiresponse data with $y_i\in\Re^2$ representing the pair of values $[\Re(z_i),\Im(z_i)],\ i=1,\ldots,n$. Havriliak and Negami (1967) show that the real and imaginary components can be written as
$$\eqalign{\Re(z_i)\ &=\
\beta_2+(\beta_1-\beta_2)R^{\beta_5}\cos(\beta_5\phi)\cr
\Im(z_I)\ &=\ (\beta_1-\beta_2)R^{\beta_5}\sin(\beta_5\phi)\cr}$$
where
$$R^2=\bigl[1+(2\pi x_i/\beta_3)^{\beta_4}\cos(\pi\beta_4/2)\bigr]^2 +
\bigl[(2\pi x_i/\beta_3)^{\beta_4}\sin(\pi\beta_4/2)\bigr]^2$$
and
$$\phi=\arctan\left[{{(2\pi
x_i/\beta_3)^{\beta_4}\sin(\pi\beta_4/2)}\over{1+(2\pi
x_i/\beta_3)^{\beta_4}\cos(\pi\beta_4/2)}}\right]\ .$$

\noindent The estimation procedure described in [Bates and Watts, 1988] for this
multiresponse problem is slightly different from that implemented in ODRPACK95.
In particular, their procedure provides an estimate of $w_\epsilon$, but does
not include estimates of $\Delta$. Thus, we would not assume that the results
obtained here using ODRPACK95 will exactly equal those presented by Bates and Watts.

\noindent For our example, we have set the starting values for the model parameters to be the final solution shown on page 152 of [Bates and Watts, 1988], i.e.,
$$\beta\ =\ (4.398,2.451,8.245,0.487,0.571)^{\rm T}$$
and have initialized $\Delta$ to the decade corrections described by them. Bates and Watts assume that there is no error in the first decade of frequency values, and we have done the same, ``fixing'' these variables at their input values. Bates and Watts also identify two outliers in the data set, which are eliminated from our analysis by setting the corresponding weights to zero. The remaining weights $w_{\epsilon_i}$ in our example are set to an estimate of the $2\times 2$ covariance matrix of the errors in the responses of the dependent variable,
$$w_{\epsilon_i}=(\check{e}_{i}^{\rm T}\check{e}_{i})^{-1},\quad i=1,\ldots,n$$
where $\check{e}_i$ is the estimate of $\epsilon_i,\ i=1,\ldots,n$, obtained using the Bates and Watts solution. The weights $w_{\delta_i}$ are set to values proportional to the magnitude of the frequencies. The remaining arguments are set to their default values. (See \S 1.G.)

\bigskip\noindent{\bf 2.B.iii.a. User Supplied Code (file {\tt drive3.f})}

{
\ttVIII\baselineskip=8pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
      PROGRAM SAMPLE
      USE ODRPACK95
      USE REAL_PRECISION
\phantom{blank line}
C  ODRPACK95 Argument Definitions
C      ==> FCN      Name of the user supplied function subroutine
C      ==> N        Number of observations 
C      ==> M        Columns of data in the explanatory variable
C      ==> NP       Number of parameters
C      ==> NQ       Number of responses per observation
C     <==> BETA     Function parameters
C      ==> Y        Response variable
C      ==> X        Explanatory variable
C      ==> WE       "Epsilon" weights
C      ==> WD       "Delta" weights
C      ==> IFIXB    Indicators for "fixing" parameters (BETA)
C      ==> IFIXX    Indicators for "fixing" explanatory variable (X)
C      ==> JOB      Task to be performed
C      ==> NDIGIT   Good digits in subroutine fcn results
C      ==> TAUFAC   Trust region initialization factor
C      ==> SSTOL    Sum of squares convergence criterion
C      ==> PARTOL   Parameter convergence criterion
C      ==> MAXIT    Maximum number of iterations
C      ==> IPRINT   Print control
C      ==> LUNERR   Logical unit for error reports
C      ==> LUNRPT   Logical unit for computation reports
C      ==> STPB     Step sizes for finite difference derivatives wrt BETA
C      ==> STPD     Step sizes for finite difference derivatives wrt DELTA
C      ==> SCLB     Scale values for parameters BETA 
C      ==> SCLD     Scale values for errors DELTA in explanatory variable
C     <==> WORK     REAL (KIND=R8) work vector
C     <==  IWORK    Integer work vector
C     <==  INFO     Stopping condition 
\phantom{blank line}
C  Parameters specifying maximum problem sizes handled by this driver
C     MAXN          Maximum number of observations 
C     MAXM          Maximum number of columns in explanatory variable
C     MAXNP         Maximum number of function parameters
C     MAXNQ         Maximum number of responses per observation
\phantom{blank line}
C  Parameter declarations and specifications
      INTEGER    LDIFX,LDSCLD,LDSTPD,LDWD,LDWE,LDX,LDY,LD2WD,LD2WE,
     &           LIWORK,LWORK,MAXM,MAXN,MAXNP,MAXNQ
      PARAMETER (MAXM=5,MAXN=100,MAXNP=25,MAXNQ=5,
     &           LDY=MAXN,LDX=MAXN,
     &           LDWE=MAXN,LD2WE=MAXNQ,LDWD=MAXN,LD2WD=1,
     &           LDIFX=MAXN,LDSCLD=1,LDSTPD=1,
     &           LWORK=18 + 11*MAXNP + MAXNP**2 + MAXM + MAXM**2 + 
     &                 4*MAXN*MAXNQ + 6*MAXN*MAXM + 2*MAXN*MAXNQ*MAXNP +  
     &                 2*MAXN*MAXNQ*MAXM + MAXNQ**2 + 
     &                 5*MAXNQ + MAXNQ*(MAXNP+MAXM) + LDWE*LD2WE*MAXNQ,
     &           LIWORK=20+MAXNP+MAXNQ*(MAXNP+MAXM))
\phantom{blank line}
C  Variable declarations 
      INTEGER        I,INFO,IPRINT,J,JOB,L,LUNERR,LUNRPT,M,MAXIT,N,
     &               NDIGIT,NP,NQ
      INTEGER        IFIXB(MAXNP),IFIXX(LDIFX,MAXM),IWORK(:)   
      REAL (KIND=R8) PARTOL,SSTOL,TAUFAC
      REAL (KIND=R8) BETA(MAXNP),DELTA(:,:),
     &               SCLB(MAXNP),SCLD(LDSCLD,MAXM),
     &               STPB(MAXNP),STPD(LDSTPD,MAXM),
     &               WD(LDWD,LD2WD,MAXM),WE(LDWE,LD2WE,MAXNQ),
     &               WORK(:),X(LDX,MAXM),Y(LDY,MAXNQ)
      EXTERNAL       FCN
      POINTER        DELTA,IWORK,WORK
\phantom{blank line}
\phantom{blank line}
C  Specify default values for DODRC arguments
      WE(1,1,1)  = -1.0E0_R8
      WD(1,1,1)  = -1.0E0_R8
      IFIXB(1)   = -1
      IFIXX(1,1) = -1
      JOB        = -1
      NDIGIT     = -1
      TAUFAC     = -1.0E0_R8
      SSTOL      = -1.0E0_R8
      PARTOL     = -1.0E0_R8
      MAXIT      = -1
      IPRINT     = -1
      LUNERR     = -1
      LUNRPT     = -1
      STPB(1)    = -1.0E0_R8
      STPD(1,1)  = -1.0E0_R8
      SCLB(1)    = -1.0E0_R8
      SCLD(1,1)  = -1.0E0_R8
\phantom{blank line}
C  Set up ODRPACK95 report files
      LUNERR  =   9
      LUNRPT  =   9
      OPEN (UNIT=9,FILE='REPORT3')
\phantom{blank line}
C  Read problem data
      OPEN (UNIT=5,FILE='DATA3')
      READ (5,FMT=*) N,M,NP,NQ
      READ (5,FMT=*) (BETA(I),I=1,NP)
      DO 10 I=1,N
         READ (5,FMT=*) (X(I,J),J=1,M),(Y(I,L),L=1,NQ)
   10 CONTINUE
\phantom{blank line}
C  Allocate work arrays
      ALLOCATE(DELTA(N,M),IWORK(LIWORK),WORK(LWORK))
\phantom{blank line}
C  Specify task as explicit orthogonal distance regression
C                  With central difference derivatives
C                  Covariance matrix constructed with recomputed derivatives
C                  DELTA initialized by user
C                  Not a restart
C  And indicate long initial report
C               No iteration reports
C               Long final report
      JOB     = 01010
      IPRINT  = 2002
\phantom{blank line}
C  Initialize DELTA, and specify first decade of frequencies as fixed
      DO 20 I=1,N
         IF (X(I,1).LT.100.0E0_R8) THEN
            DELTA(I,1) = 0.0E0_R8
            IFIXX(I,1) = 0
         ELSE IF (X(I,1).LE.150.0E0_R8) THEN
            DELTA(I,1) = 0.0E0_R8
            IFIXX(I,1) = 1
         ELSE IF (X(I,1).LE.1000.0E0_R8) THEN
            DELTA(I,1) = 25.0E0_R8
            IFIXX(I,1) = 1
         ELSE IF (X(I,1).LE.10000.0E0_R8) THEN
            DELTA(I,1) = 560.0E0_R8
            IFIXX(I,1) = 1
         ELSE IF (X(I,1).LE.100000.0E0_R8) THEN
            DELTA(I,1) = 9500.0E0_R8
            IFIXX(I,1) = 1
         ELSE 
            DELTA(I,1) = 144000.0E0_R8
            IFIXX(I,1) = 1
         END IF
   20 CONTINUE
\phantom{blank line}
C  Set weights
      DO 30 I=1,N
         IF (X(I,1).EQ.100.0E0_R8 .OR. X(I,1).EQ.150.0E0_R8) THEN
            WE(I,1,1) = 0.0E0_R8
            WE(I,1,2) = 0.0E0_R8
            WE(I,2,1) = 0.0E0_R8
            WE(I,2,2) = 0.0E0_R8
         ELSE
            WE(I,1,1) =   559.6E0_R8
            WE(I,1,2) = -1634.0E0_R8
            WE(I,2,1) = -1634.0E0_R8
            WE(I,2,2) =  8397.0E0_R8
         END IF
         WD(I,1,1)    =  (1.0E-4_R8)/(X(I,1)**2)
   30 CONTINUE
\phantom{blank line}
C  Compute solution
      CALL ODR(FCN=FCN,
     &         N=N,M=M,NP=NP,NQ=NQ,
     &         BETA=BETA,
     &         Y=Y,X=X,
     &         DELTA=DELTA,
     &         WE=WE,WD=WD,
     &         IFIXB=IFIXB,IFIXX=IFIXX,
     &         JOB=JOB,NDIGIT=NDIGIT,TAUFAC=TAUFAC,
     &         SSTOL=SSTOL,PARTOL=PARTOL,MAXIT=MAXIT,
     &         IPRINT=IPRINT,LUNERR=LUNERR,LUNRPT=LUNRPT,
     &         STPB=STPB,STPD=STPD,
     &         SCLB=SCLB,SCLD=SCLD,
     &         WORK=WORK,IWORK=IWORK,
     &         INFO=INFO)
      END
\phantom{blank line}
\phantom{blank line}
      SUBROUTINE FCN(N,M,NP,NQ,
     &               LDN,LDM,LDNP,
     &               BETA,XPLUSD,
     &               IFIXB,IFIXX,LDIFX,
     &               IDEVAL,F,FJACB,FJACD,
     &               ISTOP)
\phantom{blank line}
C  Subroutine arguments
C      ==> N        Number of observations
C      ==> M        Number of columns in explanatory variable
C      ==> NP       Number of parameters
C      ==> NQ       Number of responses per observation
C      ==> LDN      Leading dimension declarator equal or exceeding N
C      ==> LDM      Leading dimension declarator equal or exceeding M
C      ==> LDNP     Leading dimension declarator equal or exceeding NP
C      ==> BETA     Current values of parameters
C      ==> XPLUSD   Current value of explanatory variable, i.e., X + DELTA
C      ==> IFIXB    Indicators for "fixing" parameters (BETA)
C      ==> IFIXX    Indicators for "fixing" explanatory variable (X)
C      ==> LDIFX    Leading dimension of array IFIXX
C      ==> IDEVAL   Indicator for selecting computation to be performed
C     <==  F        Predicted function values
C     <==  FJACB    Jacobian with respect to BETA
C     <==  FJACD    Jacobian with respect to errors DELTA
C     <==  ISTOP    Stopping condition, where
C                     0 Means current BETA and X+DELTA were
C                       acceptable and values were computed successfully
C                     1 Means current BETA and X+DELTA are
C                       not acceptable;  ODRPACK95 should select values  
C                       closer to most recently used values if possible 
C                    -1 Means current BETA and X+DELTA are
C                       not acceptable;  ODRPACK95 should stop
\phantom{blank line}
C  Used modules
      USE REAL_PRECISION
\phantom{blank line}
C  Input arguments, not to be changed by this routine:
      INTEGER          I,IDEVAL,ISTOP,LDIFX,LDM,LDN,LDNP,M,N,NP,NQ
      REAL (KIND=R8) BETA(NP),XPLUSD(LDN,M)
      INTEGER          IFIXB(NP),IFIXX(LDIFX,M)
C  Output arguments:
      REAL (KIND=R8) F(LDN,NQ),FJACB(LDN,LDNP,NQ),FJACD(LDN,LDM,NQ)
C  Local variables
      REAL (KIND=R8) FREQ,PI,OMEGA,CTHETA,STHETA,THETA,PHI,R
      INTRINSIC        ATAN2,EXP,SQRT
\phantom{blank line}
\phantom{blank line}
C  Do something with FJACD, FJACB, IFIXB and IFIXX to avoid warnings that they 
C  are not being used.  This is simply not to worry users that the example 
C  program is failing.
      IF (IFIXB(1) .GT. 0 .AND. IFIXX(1,1) .GT. 0 
     &    .AND. FJACB(1,1,1) .GT. 0 .AND. FJACD(1,1,1) .GT. 0 ) THEN
C        Do nothing.
      END IF
\phantom{blank line}
\phantom{blank line}
C  Check for unacceptable values for this problem
      DO 10 I=1,N
         IF (XPLUSD(I,1).LT.0.0E0_R8) THEN
            ISTOP = 1
            RETURN
         END IF
   10 CONTINUE
      ISTOP = 0
\phantom{blank line}
      PI = 3.141592653589793238462643383279E0_R8
\phantom{blank line}
      THETA = PI*BETA(4)*0.5E0_R8
      CTHETA = COS(THETA)
      STHETA = SIN(THETA)
\phantom{blank line}
C  Compute predicted values
      IF (MOD(IDEVAL,10).GE.1) THEN
         DO 100 I = 1,N
            FREQ  = XPLUSD(I,1)
            OMEGA = (2.0E0_R8*PI*FREQ*EXP(-BETA(3)))**BETA(4)
            PHI   = ATAN2((OMEGA*STHETA),(1+OMEGA*CTHETA))
            R     = (BETA(1)-BETA(2)) * 
     &              SQRT((1+OMEGA*CTHETA)**2+
     &                       (OMEGA*STHETA)**2)**(-BETA(5))
            F(I,1) = BETA(2) + R*COS(BETA(5)*PHI)
            F(I,2) =           R*SIN(BETA(5)*PHI)
  100    CONTINUE
      END IF
\phantom{blank line}
      RETURN
      END
}}
\vfil\eject

\noindent{\bf 2.B.iii.b. User Supplied Data (file {\tt data3})}

{
\ttVIII\baselineskip=8pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
   23    1    5   2
  4.0 2.0 7.0 0.40 0.50
      30.0  4.220  0.136
      50.0  4.167  0.167
      70.0  4.132  0.188
     100.0  4.038  0.212
     150.0  4.019  0.236
     200.0  3.956  0.257
     300.0  3.884  0.276
     500.0  3.784  0.297
     700.0  3.713  0.309
    1000.0  3.633  0.311
    1500.0  3.540  0.314
    2000.0  3.433  0.311
    3000.0  3.358  0.305
    5000.0  3.258  0.289
    7000.0  3.193  0.277
   10000.0  3.128  0.255
   15000.0  3.059  0.240
   20000.0  2.984  0.218
   30000.0  2.934  0.202
   50000.0  2.876  0.182
   70000.0  2.838  0.168
  100000.0  2.798  0.153
  150000.0  2.759  0.139
}}
\vfil\eject

\noindent{\bf 2.B.iii.c. Report Generated by ODRPACK95 (file {\tt
drive3.out})}

{
\ttVIII\baselineskip=8pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
 ********************************************************* 
 * ODRPACK95 version 1.00 of 12-27-2005 (REAL (KIND=R8)) * 
 ********************************************************* 
\phantom{blank line}
\phantom{blank line}
 *** Initial summary for fit by method of ODR ***
\phantom{blank line}
 --- Problem Size:
            N =    23          (number with nonzero weight =    21)
           NQ =     2
            M =     1
           NP =     5          (number unfixed =     5)
\phantom{blank line}
 --- Control Values:
          JOB = 01010
              = ABCDE, where
                       A=0 ==> fit is not a restart.
                       B=1 ==> deltas are initialized by user.
                       C=0 ==> covariance matrix will be computed using
                               derivatives re-evaluated at the solution.
                       D=1 ==> derivatives are estimated by central differences.
                       E=0 ==> method is explicit ODR.
       NDIGIT =    16          (estimated by ODRPACK95)
       TAUFAC =     1.00E+00
\phantom{blank line}
 --- Stopping Criteria:
        SSTOL =     1.49E-08   (sum of squares stopping tolerance)
       PARTOL =     3.67E-11   (parameter stopping tolerance)
        MAXIT =    50          (maximum number of iterations)
\phantom{blank line}
 --- Initial Weighted Sum of Squares        =                    1.71064070E+03
         Sum of Squared Weighted Deltas     =   2.01382943E-04
         Sum of Squared Weighted Epsilons   =   1.71064050E+03
\phantom{blank line}
 --- Function Parameter Summary:
\phantom{blank line}
       Index   BETA(K)    Fixed     Scale   LOWER(K)   UPPER(K)    Derivative
                                                                    Step Size
         (K)            (IFIXB)    (SCLB)                              (STPB)
\phantom{blank line}
           1  4.00E+00       NO  2.50E-01 -1.80E+308  1.80E+308   4.64159E-06
           2  2.00E+00       NO  5.00E-01 -1.80E+308  1.80E+308   4.64159E-06
           3  7.00E+00       NO  1.43E-01 -1.80E+308  1.80E+308   4.64159E-06
           4  4.00E-01       NO  2.50E+00 -1.80E+308  1.80E+308   4.64159E-06
           5  5.00E-01       NO  2.00E+00 -1.80E+308  1.80E+308   4.64159E-06
\phantom{blank line}
 --- Explanatory Variable and Delta Weight Summary:
\phantom{blank line}
       Index      X(I,J)  DELTA(I,J)    Fixed     Scale    Weight    Derivative
                                                                      Step Size
       (I,J)                          (IFIXX)    (SCLD)      (WD)        (STPD)
\phantom{blank line}
         1,1   3.000E+01   0.000E+00      YES  3.33E-02  1.11E-07   4.64159E-06
         N,1   1.500E+05   1.440E+05       NO  6.67E-06  4.44E-15   4.64159E-06
\phantom{blank line}
 --- Response Variable and Epsilon Error Weight Summary:
\phantom{blank line}
       Index      Y(I,L)      Weight
       (I,L)                    (WE)
\phantom{blank line}
         1,1   4.220E+00   5.596E+02
         N,1   2.759E+00   5.596E+02
\phantom{blank line}
         1,2   1.360E-01   8.397E+03
         N,2   1.390E-01   8.397E+03
\phantom{blank line}
 *** Final summary for fit by method of ODR ***
\phantom{blank line}
 --- Stopping Conditions:
         INFO =     1 ==> sum of squares convergence.
        NITER =     8          (number of iterations)
         NFEV =   121          (number of function evaluations)
        IRANK =     0          (rank deficiency)
        RCOND =     8.15E-03   (inverse condition number)
        ISTOP =     0          (returned by user from subroutine FCN)
\phantom{blank line}
 --- Final Weighted Sums of Squares       =                     4.20538922E-01
         Sum of Squared Weighted Deltas   =    5.54021897E-04
         Sum of Squared Weighted Epsilons =    4.19984900E-01
\phantom{blank line}
 --- Residual Standard Deviation          =                     1.62122431E-01
         Degrees of Freedom               =   16
\phantom{blank line}
 --- Estimated BETA(J), J = 1, ..., NP:
\phantom{blank line}
                     BETA      LOWER     UPPER      S.D.  ___ 95% Confidence ___
                                                    BETA         Interval
\phantom{blank line}
       1   4.37998803E+00  -1.80+308  1.80+308  1.31E-02   4.35E+00 to  4.41E+00
       2   2.43330576E+00  -1.80+308  1.80+308  1.30E-02   2.41E+00 to  2.46E+00
       3   8.00288459E+00  -1.80+308  1.80+308  1.17E-01   7.76E+00 to  8.25E+00
       4   5.10114716E-01  -1.80+308  1.80+308  1.33E-02   4.82E-01 to  5.38E-01
       5   5.17390233E-01  -1.80+308  1.80+308  2.89E-02   4.56E-01 to  5.79E-01
\phantom{blank line}
 --- Estimated EPSILON(I) and DELTA(I,*), I = 1, ..., N:
\phantom{blank line}
         I    EPSILON(I,1)    EPSILON(I,2)      DELTA(I,1)
\phantom{blank line}
         1 -7.38558795E-03  1.25939187E-03  0.00000000E+00
         2 -1.05614733E-03 -1.22846292E-03  0.00000000E+00
         3 -2.70863921E-03 -2.14347329E-03  0.00000000E+00
         4  4.68593517E-02 -4.25940138E-03  0.00000000E+00
         5  8.08102389E-03 -3.47539194E-03  0.00000000E+00
         6  1.53882522E-03  3.85293713E-04  3.03694400E+01
         7  4.60535703E-03  1.19118896E-03  3.78986750E+01
         8  4.50906165E-03  1.23570892E-03  6.22630487E+01
         9 -1.00621895E-03 -2.91865042E-04  1.11186980E+02
        10  1.05810803E-02  3.27284194E-03  1.15709877E+02
        11  6.93622740E-03  2.43482106E-03  2.41436590E+02
        12  3.95828022E-05  1.75905019E-05  9.61344532E+02
        13 -3.77617796E-03 -2.42907814E-03  1.33029845E+03
        14 -5.56734974E-04 -1.70123784E-03  2.07511566E+03
        15  2.08263807E-03 -2.23723233E-03  2.90289532E+03
        16 -7.50689916E-03  2.16462893E-03  5.21815818E+03
        17 -1.56731844E-03  2.03367085E-04  7.54564636E+03
        18 -5.93223182E-04  2.72069170E-05  1.74201021E+04
        19  1.15260099E-04 -2.42126138E-07  2.42745472E+04
        20  2.63641111E-04  5.18510319E-06  3.78492052E+04
        21 -3.81011181E-04 -1.03963849E-05  5.53493280E+04
        22 -3.36822612E-04 -1.26141392E-05  8.75791432E+04
        23  2.87173883E-03  1.41199841E-04  1.29496300E+05
}}
\vfil\eject

\bigskip\noindent{\bf 2.B.iv. Example Problem for an Explicit Model with Bound
Constraints}
\medskip
\noindent The following sample program invokes {\tt ODR} to find the parameters
for the simple frog egg model of [Zwolak et al., 2001].  They use a simple
phenomenological model of MPF (mitosis promoting factor) activity in frog
egg extracts.  In this model MPF activity $M$ remains low for some time
and eventually activates at a time $t$ (the timelag) dependent on the
total cyclin concentration $C$ (the independent variable).  The model has
three kinetic parameters (or rates): $k_{wee}$, $k_{25}$, and $k_{25}'$
(all of which are constrained with a lower bound of 0).  MPF activity $M$
is defined as the ordinary differential equation
$$
{dM \over dt} = -k_{wee}M+(k_{25}+k_{25}'M^2)(C-M).
$$
The data are in pairs $(C,t)$ where $C$ is the independent variable and $t$ is 
the dependent variable.  MPF is defined as
``active'' when half the total cyclin (a component of MPF in both active and
inactive forms) is in active MPF molecules.  This inverse function defining the
relationship between the timelag and total cyclin can be defined as
$$
t = M^{-1}(C / 2; k_{wee}, k_{25}, k_{25}'),
$$
where $k_{wee}$, $k_{25}$, and $k_{25}'$ are included because $M$ is dependent
on these rate constants.
The function given to ODRPACK95 becomes
$$
f_i(x_i;\beta) \equiv M^{-1}(x_i/2; \beta_1, \beta_2, \beta_3).
$$
for $i=1,\ldots, n.$

\noindent The starting values for the model parameters are
$$
\beta = (1.1, 3.3, 8.7)^T,
$$
$\Delta$ is initialized to zero, the lower bounds are
$$
L = (0,0,0)^T,
$$
and the upper bounds are left to the defaults.  The iterations are limited to 20
by setting {\tt MAXIT}, the reporting facility is set to long reports to
${\cal L}_{CR}$ only by setting {\tt IPRINT}, and all other ODRPACK95 settings
are left to their default values. (see \S 1.G.)

\bigskip\noindent{\bf 2.B.iv.a. User Supplied Code (file {\tt drive4.f})}
\medskip

{
\ttVIII\baselineskip=8pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
C  This sample problem comes from Zwolak et al. 2001 (High Performance Computing
C  Symposium, "Estimating rate constants in cell cycle models").  The call to
C  ODRPACK95 is modified from the call the authors make to ODRPACK.  This is
C  done to illustrate the need for bounds.  The authors could just have easily
C  used the call statement here to solve their problem.
C
C  Curious users are encouraged to remove the bounds in the call statement,
C  run the code, and compare the results to the current call statement.
      PROGRAM SAMPLE
      USE REAL_PRECISION
      USE ODRPACK95
      IMPLICIT NONE
      INTEGER :: I
      DOUBLE PRECISION :: C, M, TOUT
      INTERFACE
          SUBROUTINE FCN(N,M,NP,NQ,LDN,LDM,LDNP,BETA,XPLUSD,IFIXB,
     +        IFIXX,LDIFX,IDEVAL,F,FJACB,FJACD,ISTOP)
          USE REAL_PRECISION
          INTEGER, INTENT(IN) :: IDEVAL,LDIFX,LDM,LDN,LDNP,M,N,NP,NQ
          INTEGER, INTENT(IN) :: IFIXB(NP),IFIXX(LDIFX,M)
          REAL(KIND=R8), INTENT(IN) :: BETA(NP),XPLUSD(LDN,M)
          INTEGER, INTENT(OUT) :: ISTOP
          REAL(KIND=R8), INTENT(OUT) :: F(LDN,NQ),FJACB(LDN,LDNP,NQ),
     +        FJACD(LDN,LDM,NQ)
          END SUBROUTINE FCN
      END INTERFACE
      REAL(KIND=R8) :: BETA(3) = (/ 1.1E-0_R8, 3.3E+0_R8, 8.7_R8 /)
      OPEN(9,FILE="REPORT4")
      CALL ODR(
     +    FCN,
     +    N = 5, M = 1, NP = 3, NQ = 1,
     +    BETA = BETA,
     +    Y = RESHAPE((/ 55.0_R8, 45.0_R8, 40.0_R8, 30.0_R8, 20.0_R8 /),
     +        (/5,1/)),
     +    X = RESHAPE((/ 0.15_R8, 0.20_R8, 0.25_R8, 0.30_R8, 0.50_R8 /),
     +        (/5,1/)),
     +    LOWER = (/ 0.0_R8, 0.0_R8, 0.0_R8 /),
     +    IPRINT = 2222,
     +    LUNRPT = 9,
     +    MAXIT  = 20
     +)
      CLOSE(9)
C  The following code will reproduce the plot in Figure 2 of Zwolak et
C  al. 2001.
C      DO I = 0, 100
C          C = 0.05+(0.7-0.05)*I/100
C          TOUT = 1440.0D0
C          !CALL MPF(M,C,1.1D-10,3.3D-3,8.7D0,0.0D0,TOUT,C/2)
C          CALL MPF(M,C,1.15395968E-02_R8, 2.61676386E-03_R8, 
C     +             9.23138811E+00_R8,0.0D0,TOUT,C/2)
C          WRITE(*,*) C, TOUT
C      END DO
      END PROGRAM
\phantom{blank line}
      SUBROUTINE FCN(N,M,NP,NQ,LDN,LDM,LDNP,BETA,XPLUSD,IFIXB,
     +    IFIXX,LDIFX,IDEVAL,F,FJACB,FJACD,ISTOP)
      USE REAL_PRECISION
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: IDEVAL,LDIFX,LDM,LDN,LDNP,M,N,NP,NQ
      INTEGER, INTENT(IN) :: IFIXB(NP),IFIXX(LDIFX,M)
      REAL(KIND=R8), INTENT(IN) :: BETA(NP),XPLUSD(LDN,M)
      INTEGER, INTENT(OUT) :: ISTOP
      REAL(KIND=R8), INTENT(OUT) :: F(LDN,NQ),FJACB(LDN,LDNP,NQ),
     +    FJACD(LDN,LDM,NQ)
      ! Local variables
      REAL(KIND=R8) :: MOUT
      INTEGER :: I
      ISTOP = 0
      FJACB(:,:,:) = 0.0E0_R8
      FJACD(:,:,:) = 0.0E0_R8
      IF ( MOD(IDEVAL,10).GE.1 ) THEN
          DO I = 1, N
              F(I,1) = 1440.0_R8
              CALL MPF(MOUT,XPLUSD(I,1),BETA(1),BETA(2),BETA(3),0.0_R8,
     +            F(I,1),XPLUSD(I,1)/2)
          END DO
      END IF
      END SUBROUTINE FCN
\phantom{blank line}
C-------------------------------------------------------------------------------
C
C  MPF
C
C  If ROOT is not zero then returns value of time when M==ROOT in TOUT.  Else,
C  runs until TOUT and returns value in M.  If PRINT_EVERY is non-zero then
C  the solution is printed every PRINT_EVERY time units or every H (which ever
C  is greater).
C
C  This routine is not meant to be precise, it is only intended to be good
C  enough for providing a working example of ODRPACK95 with bounds.  4th order 
C  Runge Kutta and linear interpolation are used for numerical integration and
C  root finding, respectively.
C
C  M - MPF
C  C - Total Cyclin
C  KWEE, K25, K25P - Model parameters (BETA(1:3))
C
      SUBROUTINE MPF(M,C,KWEE,K25,K25P,PRINT_EVERY,TOUT,ROOT)
          DOUBLE PRECISION, INTENT(OUT) :: M
          DOUBLE PRECISION, INTENT(IN)  :: C, KWEE, K25, K25P,
     +        PRINT_EVERY, ROOT
          DOUBLE PRECISION, INTENT(INOUT) :: TOUT
          !  Local variables
          DOUBLE PRECISION, PARAMETER :: H = 1.0D-1
          DOUBLE PRECISION :: LAST_PRINT, LAST_M, LAST_T, T
          DOUBLE PRECISION :: K1, K2, K3, K4
          M = 0.0D0
          T = 0.0D0
          IF ( PRINT_EVERY .GT. 0.0D0 ) THEN
              WRITE(*,*) T, M
          END IF
          DO WHILE ( T .LT. TOUT )
              LAST_T = T
              LAST_M = M
              K1 = H*DMDT(M,C,KWEE,K25,K25P)
              K2 = H*DMDT(M+K1/2,C,KWEE,K25,K25P)
              K3 = H*DMDT(M+K2/2,C,KWEE,K25,K25P)
              K4 = H*DMDT(M+K3,C,KWEE,K25,K25P)
              M = M+(K1+2*K2+2*K3+K4)/6
              T = T + H
              IF ( T .GE. PRINT_EVERY+LAST_PRINT .AND. 
     +            PRINT_EVERY .GT. 0.0D0 )             
     +        THEN
                  WRITE(*,*) T, M
                  LAST_PRINT = LAST_PRINT + PRINT_EVERY
              END IF
              IF ( ROOT .GT. 0.0D0 ) THEN
                  IF ( LAST_M .LE. ROOT .AND. ROOT .LT. M ) THEN
                      TOUT = (T-LAST_T)/(M-LAST_M)*(ROOT-LAST_M)+LAST_T
                      RETURN
                  END IF
              END IF
          END DO
      END SUBROUTINE MPF
\phantom{blank line}
\phantom{blank line}
C  Equation from Zwolak et al. 2001.
      DOUBLE PRECISION FUNCTION DMDT(M,C,KWEE,K25,K25P)
          DOUBLE PRECISION :: M, C, KWEE, K25, K25P
          DMDT = KWEE*M+(K25+K25P*M**2)*(C-M)
      END FUNCTION DMDT
}}
\vfil\eject

\noindent{\bf 2.B.iv.b. Report Generated by ODRPACK95 (file {\tt drive4.out})}
{
\ttVIII\baselineskip=8pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
 ********************************************************* 
 * ODRPACK95 version 1.00 of 12-27-2005 (REAL (KIND=R8)) * 
 ********************************************************* 
\phantom{blank line}
\phantom{blank line}
 *** Initial summary for fit by method of ODR ***
\phantom{blank line}
 --- Problem Size:
            N =     5          (number with nonzero weight =     5)
           NQ =     1
            M =     1
           NP =     3          (number unfixed =     3)
\phantom{blank line}
 --- Control Values:
          JOB = 00000
              = ABCDE, where
                       A=0 ==> fit is not a restart.
                       B=0 ==> deltas are initialized to zero.
                       C=0 ==> covariance matrix will be computed using
                               derivatives re-evaluated at the solution.
                       D=0 ==> derivatives are estimated by forward differences.
                       E=0 ==> method is explicit ODR.
       NDIGIT =    16          (estimated by ODRPACK95)
       TAUFAC =     1.00E+00
\phantom{blank line}
 --- Stopping Criteria:
        SSTOL =     1.49E-08   (sum of squares stopping tolerance)
       PARTOL =     3.67E-11   (parameter stopping tolerance)
        MAXIT =    20          (maximum number of iterations)
\phantom{blank line}
 --- Initial Weighted Sum of Squares        =                    7.88051339E+03
         Sum of Squared Weighted Deltas     =   0.00000000E+00
         Sum of Squared Weighted Epsilons   =   7.88051339E+03
\phantom{blank line}
 --- Function Parameter Summary:
\phantom{blank line}
       Index   BETA(K)    Fixed     Scale   LOWER(K)   UPPER(K)    Derivative
                                                                    Step Size
         (K)            (IFIXB)    (SCLB)                              (STPB)
\phantom{blank line}
           1  1.10E+00       NO  1.15E-01  0.00E+000  1.80E+308   1.00000E-10
           2  3.30E+00       NO  1.15E-01  0.00E+000  1.80E+308   1.00000E-10
           3  8.70E+00       NO  1.15E-01  0.00E+000  1.80E+308   1.00000E-10
\phantom{blank line}
 --- Explanatory Variable and Delta Weight Summary:
\phantom{blank line}
       Index      X(I,J)  DELTA(I,J)    Fixed     Scale    Weight    Derivative
                                                                      Step Size
       (I,J)                          (IFIXX)    (SCLD)      (WD)        (STPD)
\phantom{blank line}
         1,1   1.500E-01   0.000E+00       NO  2.00E+00  1.00E+00   1.00000E-10
         N,1   5.000E-01   0.000E+00       NO  2.00E+00  1.00E+00   1.00000E-10
\phantom{blank line}
 --- Response Variable and Epsilon Error Weight Summary:
\phantom{blank line}
       Index      Y(I,L)      Weight
       (I,L)                    (WE)
\phantom{blank line}
         1,1   5.500E+01   1.000E+00
         N,1   2.000E+01   1.000E+00
\phantom{blank line}
 *** Iteration reports for fit by method of ODR ***
\phantom{blank line}
\phantom{blank line}
         Cum.                 Act. Rel.   Pred. Rel.
  It.  No. FN     Weighted   Sum-of-Sqs   Sum-of-Sqs              G-N
 Num.   Evals   Sum-of-Sqs    Reduction    Reduction  TAU/PNORM  Step
 ----  ------  -----------  -----------  -----------  ---------  ----
\phantom{blank line}
    1      21  7.46931E+03   5.2180E-02   6.8748E-03  3.471E-01    NO
    3      37  6.11407E+03   1.1907E-01   6.2899E-02  1.281E-02    NO
    5      55  2.72616E+02   9.1085E-01   4.7752E-01  1.662E-03    NO
    7      73  1.41168E+00   9.8681E-01   9.9999E-01  7.550E-02    NO
    9      84  2.30945E-02   4.8180E-01   9.8153E-01  6.620E-02    NO
   11      96  1.75440E-03   1.0773E-01   5.8170E-01  1.469E-02    NO
   13     107  8.78907E-04   8.6083E-03   7.2672E-02  7.139E-03    NO
   15     118  8.24618E-04   4.7535E-04   3.7037E-03  3.321E-03    NO
   17     129  8.22040E-04   4.7114E-05   2.4203E-04  1.604E-03    NO
   19     140  8.21853E-04   2.2162E-05   3.4216E-05  1.574E-03    NO
\phantom{blank line}
 *** Final summary for fit by method of ODR ***
\phantom{blank line}
 --- Stopping Conditions:
         INFO =     4 ==> iteration limit reached.
        NITER =    20          (number of iterations)
         NFEV =   149          (number of function evaluations)
        IRANK =     0          (rank deficiency)
        RCOND =     1.28E-06   (inverse condition number)
        ISTOP =     0          (returned by user from subroutine FCN)
\phantom{blank line}
 --- Final Weighted Sums of Squares       =                     8.21833725E-04
         Sum of Squared Weighted Deltas   =    8.21734527E-04
         Sum of Squared Weighted Epsilons =    9.91982003E-08
\phantom{blank line}
 --- Residual Standard Deviation          =                     2.02710844E-02
         Degrees of Freedom               =    2
\phantom{blank line}
 --- Estimated BETA(J), J = 1, ..., NP:
\phantom{blank line}
                     BETA      LOWER     UPPER      S.D.  ___ 95% Confidence ___
                                                    BETA         Interval
\phantom{blank line}
       1   1.37157532E-02   0.00E+00  1.80+308  6.63E-02  -2.72E-01 to  2.99E-01
       2   2.02887855E-03   0.00E+00  1.80+308  1.74E-02  -7.29E-02 to  7.69E-02
       3   1.16507107E+01   0.00E+00  1.80+308  9.20E+01  -3.84E+02 to  4.07E+02
\phantom{blank line}
 --- Estimated EPSILON(I) and DELTA(I,*), I = 1, ..., N:
\phantom{blank line}
         I    EPSILON(I,1)      DELTA(I,1)
\phantom{blank line}
         1  7.15956516E-05  4.90397616E-03
         2  4.74369190E-05  1.20102885E-04
         3 -8.72587955E-05 -1.95283255E-02
         4  2.70223053E-04  1.97270726E-02
         5 -1.05770536E-04 -5.21135562E-03
}}
\vfil\eject

\ \vskip 1.4in
\def\thissection{When the Model Is Very Time Consuming}
\noindent{\capsXIV 3. When the Model Is Very Time Consuming}\bigskip\bigskip

\noindent ODRPACK95 executes user supplied subroutine {\tt FCN} not only to compute the initial sum of the squared errors $S(\beta,\delta)$ and to obtain function and derivative values within its main iterative procedure, but also when setting the default value for the number of good digits in the function results, when performing derivative checking, and when constructing the covariance matrix and standard deviations of the estimated parameters $\hat{\beta}$. When the time required for finding the solution is dominated by the evaluation of {\tt FCN}, the user will want to make judicious use of these options in light of their ``cost.'' Let $\tilde p$ be the number of unfixed parameters $\beta$, and let $\varphi = 1$ if the fit is by orthogonal distance regression and $\varphi = 0$ if the fit is by ordinary least squares. Then the number of times the function and derivatives are evaluated in each of these instances is summarized as follows:
\medskip
\vbox{\halign{&#&\quad#&\quad\hfill#\hfill&\quad\hfill#\hfill\ \cr
&\hfill Computation\hfill&Function&Derivative&\hfil Controlling\hfil&\cr
&&Evaluations&Evaluations$^1$&\hfil Variable\hfil\cr
&$\bullet$ Initial $S(\beta,\delta)$:\hfil&1&0&\hfil---\hfil\cr
&$\bullet$ Per Iteration:\hfil&$\geq 1$&1&\hfil---\hfil\cr
&$\bullet$ Default number of\hfil&&&&\cr
&\qquad good digits in function results:\hfil&4&0&\hfil\tt NDIGIT\hfil\cr
&$\bullet$ Derivative checking:\hfil&$\geq q(\tilde p +\varphi m)$&1&\hfil\tt JOB\hfil\cr
&$\bullet$ Default covariance matrix:\hfil&0&1&\hfil\tt JOB\hfil\cr}}\footnote{}{$^1$\rmVIII A forward finite difference approximation to the derivative requires $q(\tilde p +\varphi m)$ function evaluations, and a central finite
difference approximation requires $2q(\tilde p +\varphi m)$ function
evaluations. (See \S 4.A.)}

\noindent Users with a very time consuming subroutine {\tt FCN} should also be
aware of two of ODRPACK95's options that are specifically designed for such
problems. The most important of these is the restart facility. The other is the
option of constructing the covariance matrix without recomputing the derivative
matrices at the solution. This second option is discussed in \S 2.A.ii, under
the description of subroutine argument {\tt JOB}, and also in \S 4.B. The
remainder of this section describes how ODRPACK95's restart facility can be used to minimize the risk of losing important results because system imposed time limits are reached before the solution is found.

\noindent The restart facility enables the user to step through the solution procedure one or more iterations at a time without incurring any additional function or derivative evaluations over what would be required if the procedure were allowed to run to convergence. Figure 3.1 shows an example of how the restart facility can be employed. This example allows up to a total of 30 iterations, and writes the contents of arrays {\tt BETA, WORK} and {\tt IWORK} to a file between every iteration, alternating between two files. This minimizes the chance of losing significant amounts of important information due to system imposed limits: if such a limit is reached before convergence, arrays {\tt BETA, WORK} and {\tt IWORK} can be restored using the saved data and the computations restarted. In this example, the initial computation report is only generated at the first iteration, while the final computation report is generated after every iteration. The options selected include constructing the covariance matrix using the derivative matrices from the last iteration, and thus no additional calls to subroutine {\tt FCN} are incurred in order to provide the standard deviations of the parameters printed in each of the reports.

\noindent Users with very time consuming problems should be aware that,
depending on which options are selected, ODRPACK95 will make at least one and
possibly more calls to subroutine {\tt FCN} before attempting to generate any
computation reports. Also, on many systems the output generated by a program is
not written directly in a file but rather is stored in a ``buffer'' until the
buffer is full, and is only written to the file at that point. If a run is
aborted prematurely, either by the user or because a system imposed limit is
reached, then the content of these buffers might not be emptied into the files
associated with them. Thus, the files associated with the logical units
specified by arguments {\tt LUNERR} and {\tt LUNRPT} might not include all
information actually generated by ODRPACK95 at the time it stopped. When the
user is not getting the expected reports from ODRPACK95, it may be necessary to
have ODRPACK95 generate reports directly to ``standard output,'' which is usually not buffered, in order to determine exactly where the computations are stopping. (See \S 2.A.ii, subroutine arguments {\tt IPRINT, LUNERR} and {\tt LUNRPT}.

\vfil\eject
\bigskip\centerline{Figure 3.1: Using ODRPACK95's Restart Facility}

{
\ttVIII\baselineskip=7pt
{\obeyspaces\global\let =\ }\obeylines\obeyspaces\parindent=0pt
%{\catcode`\^^M=\active
%  \gdef\obeylines{\catcode`\^^M=\active \let^^M=\par}
%  \global\let^^M=\par}
%\newcount\linenumber
%\lineno=0
%\everypar{\advance\lineno by1 \llap{\sevenrm\the\lineno\ \ }}
\chardef\other=12
\catcode`\&=\other
\catcode`\^=\other
\catcode`\_=\other
\catcode`\+=\other
\catcode`\-=\other
\catcode`\%=\other
\catcode`\#=\other
{
c set up files to save computations for future restarts
      lun1 = 11
      OPEN (unit=lun1,file='save1.dat')
      lun2 = 12
      OPEN (unit=lun2,file='save2.dat')
\phantom{blank line}
c set the maximum number of iterations for each call to ODRPACK to one 
c so results can be stored between iterations
      maxit = 1
\phantom{blank line}
c set argument appropriately, making sure for first iteration that 
c       fit is not a restart and 
c       covariance matrix is constructed without recomputing derivatives
      job = 00100
\phantom{blank line}
c set iprint to indicate a long initial report, 
c                        a short iteration report, and 
c                        a long final report
      iprint = 2112
\phantom{blank line}
c step through up to 30 iterations
      DO 100 niter = 1, 30
          CALL odr(fcn, ... ,work=work,iwork=iwork,info=info,job=job)
\phantom{blank line}
c save the contents of beta, work and iwork for future reference
          IF (mod(niter,2).eq.1) THEN
              lun = lun1
          ELSE
              lun = lun2
          END IF
          OPEN (UNIT=lun)
          WRITE (lun,*) (beta(k),k=1,np)
          WRITE (lun,*) (work(i),i=1,lwork)
          WRITE (lun,*) (iwork(i),i=1,liwork)
          CLOSE (UNIT=lun)
\phantom{blank line}
          IF (info.ge.10000 .or. mod(info,10).le.3) then
c stop because either a fatal error was detected, or the problem converged
              stop
          ELSE 
c set job to indicate the next iteration is a restart and 
c set iprint to suppress the initial report for future iterations.
              job = 10100
              iprint = 0112
          END IF
      100 CONTINUE
}}
\vfil\eject

\ \vskip 1.4in
\def\thissection{Computational Details}
\noindent{\capsXIV 4. Computational Details}\bigskip\bigskip

\noindent{\bf 4.A. Computing the Jacobian Matrices}\medskip

\noindent As was noted in \S 1.A, the matrices of first partial derivatives, i.e., the Jacobian matrices
$$\eqalign{{{\partial f_{il}(x_i+\delta_i;\beta)}\over{\partial\beta_k}},\quad
i&=1,\ldots,n,\quad k=1,\ldots,p,\quad \& l=1,\ldots,q,\cr
{{\partial f_{il}(x_i+\delta_i;\beta)}\over{\partial\Delta_{ij}}},\quad
i&=1,\ldots,n,\quad j=1,\ldots,m,\quad \& l=1,\ldots,q,}\eqno(4.1)$$
are required at every iteration. These can be provided by the user as described
for subroutine argument {\tt FCN} in \S 2.A.ii, or can be approximated
automatically by ODRPACK95. User supplied derivatives are generally either
``hand coded'' as is done in the example program shown in \S 2.B.i, or are the
product of an ``automatic differentiation'' tool. ODRPACK95's approximations are formed using either forward or central finite differences.

\bigskip\noindent{\bf 4.A.i. ``Hand Coded'' Derivatives}\medskip

\noindent Hand coded derivatives are those produced by the user without the aid
of a differentiation tool. Because coding errors are a common problem with hand
coded derivatives, ODRPACK95 has an option to check the validity of the user supplied derivative code by comparing its results to finite difference values for the derivative. The derivative checking procedure examines the unfixed variables at only one row of the Jacobian matrix, and is therefore quite efficient. Checking only one row is reasonable for regression models since the same code is frequently used to compute the model function and derivatives for each row, as is the case for each of the examples shown in \S 2.B.

\noindent When the value of the user supplied derivative disagrees with the corresponding finite difference value, the checking procedure attempts to determine whether the disagreement is due to an error in the user's code, or is due to the inaccuracy of the finite difference approximation. The checking procedure generates an error report when one or more of the derivatives are found to be questionable. This information is also returned to the user in subroutine argument {\tt IWORK}. (See \S 5.B.)

\noindent Questionable derivatives can occur when the derivative is exactly zero
or when the numerical derivative used in the checking procedure is believed to
be inaccurate because of the properties of the function. Zero valued derivatives
are questionable because they could indicate that the initial values of the
function parameters $\beta$ might be hiding an error in the derivative, such as
could occur if the initial value of one of the parameters was zero. Users should
examine the ODRPACK95 error reports, or the encoded values in subroutine argument {\tt IWORK} as described in \S 5.B, to determine the cause of the questionable results, and then examine subroutine {\tt FCN} to insure that there is not an error in the user supplied derivatives that could be adversely affecting the least squares results.

\bigskip\noindent{\bf 4.A.ii. Automatic Differentiation}\medskip

\noindent Automatic differentiation tools produce code to calculate a function's
derivatives directly from the code used to compute the function values. Such
tools enable the user to generate the derivatives required by ODRPACK95 without
the tedium and errors associated with hand coded derivatives. An overview of
automatic differentiation is presented in [Griewank, 1989], and a survey of
automatic differentiation software is provided in [Juedes, 1991]. We have found
tools such as ADIFOR [Bischof {\it et al}., 1991] and DAPRE [Stephens and Pryce,
1991], which are precompilers that transform a Fortran subroutine that evaluates
the function into a Fortran subroutine that evaluates both the function and its
derivatives, especially suitable for use with ODRPACK95.

\noindent Currently, most differentiation tools, including ADIFOR and DAPRE, generate code to evaluate the function and derivative values simultaneously. Least squares procedures, however, need the derivatives only after determining that a satisfactory new point has been found, and this determination requires at least one and possibly more function evaluations. Thus, when using a differentiation tool, one has two choices: either the function and derivatives can be always evaluated together using the code generated by the differentiation tool; or the hand coded function can be evaluated by itself until a satisfactory new point has been found, at which time the derivative code generated by the differentiation tool code can be evaluated. The first choice has the drawback that sometimes the computed derivative values will not be used. If the second option is selected, the function values produced by the differentiation tool generated code are used only for the evaluation of the Jacobian matrices and not within the least squares procedure.

\noindent For the differentiation tools and problems examined by the authors,
the time required to evaluate the derivative and function together using code
generated by automatic differentiation is frequently significantly more than
that required to evaluate only the hand coded function. We thus believe that in
most cases it will be more cost effective for users to employ the second of the
two choices mentioned above. Users must also be aware that ODRPACK95 never asks
that both the function and its derivatives be computed in a single call to
subroutine {\tt FCN}, and that it is possible that an invocation of {\tt FCN}
for evaluating the derivative will not be {\it immediately} preceded with a call
to {\tt FCN} to evaluate the function for the same parameter values. Thus, if
the first of the two options is employed, the user will need to construct a
mechanism for saving the computed derivatives until ODRPACK95 actually requests them, possibly using the Fortran {\tt COMMON} facility, and also a mechanism for determining whether the saved derivative values were in fact those evaluated at the selected parameter values.

\bigskip\noindent{\bf 4.A.iii. Finite Difference Derivatives}\medskip

\noindent Finite difference derivatives are automatically constructed by
ODRPACK95 to approximate the Jacobian matrices when the user does not supply code within subroutine {\tt FCN} to compute them. Either forward or central finite differences can be employed for the approximation. (See \S 2.A.ii, subroutine argument {\tt JOB}.) A central finite difference derivative gives a more accurate approximation than the corresponding forward finite difference derivative, but at the expense of an additional call to subroutine {\tt FCN} for each partial derivative computed. The interested reader is referred to [Dennis and Schnabel, 1983] and [Gill {\it et al}., 1981] for a more complete discussion of forward and central finite difference approximations.

\bigskip\noindent{\bf 4.A.iii.a. Forward Finite Difference Derivatives}\medskip

\noindent The forward finite difference derivative with respect to $\beta$ for response $l$ of observation $i$ is computed using
$${{f_{il}(x_i+\delta_i;\
\beta+\tilde{h}_{\beta_k}u_k)-f_{il}(x_i+\delta_i;\beta)}
\over{\tilde{h}_{\beta_k}}}\ ,$$
$i = 1,\ldots,n$, $k = 1,\ldots,p$, and $l = 1,\ldots,q$, where $u_k$ is the $k$th unit vector, i.e., the $k$th column of a $p \times  p$ identity matrix, and where $\tilde{h}_{\beta_k}$ is the finite difference step size,
$$\tilde{h}_{\beta_k}=h_{\beta_k}|\beta_k|,\qquad k=1,\ldots,p,\eqno(4.2)$$
with $h_{\beta_k}$ the {\it relative} step size for parameter $\beta_k$ specified by subroutine argument {\tt STPB}. (See \S 2.A.ii.) The default value for the relative step for a forward finite difference derivative is
$$h={1\over100}10^{-\psi/2}\ ,$$
where $\psi$ indicates the number of good digits in the results of the user supplied subroutine {\tt FCN}. (See \S 2.A.ii, subroutine argument {\tt NDIGIT}.) This default value is selected based on empirical evidence that indicates it generally outperforms the commonly recommended value $h=10^{(-\psi/2)}$. (See, e.g., [Dennis and Schnabel, 1983].) Procedures for selecting near optimal relative step sizes are discussed in [Gill {\it et al.}, 1981] and [Schnabel, 1982].)

\noindent The step $\tilde{h}_{\beta_k}$ must be large enough so that approximately half of the good digits of $f_{il}(x_i+\delta_i;\ \beta+\tilde{h}_{\beta_k}u_k)$ and $f_{il}(x_i+\delta_i;\beta)$ will be the same. The forward finite difference approximation to the derivative can then be expected to have roughly half the number of good digits as are in the computed value of $f_{il}(x_i+\delta_i;\beta)$. When the computation of $f_{il}(x_i+\delta_i;\beta)$ has sufficient precision, then forward finite difference derivatives will cause very little change in the results from those that would be obtained using hand coded or automatic differentiation derivatives.

\noindent The forward finite difference derivatives with respect to $\Delta$ are formed analogously to those with respect to $\beta$. (See \S 2.A.ii, subroutine argument {\tt STPD}, for specification of the relative stepsize.)

\bigskip\noindent{\bf 4.A.iii.b. Central Finite Difference Derivatives}\medskip

\noindent When the user suspects that the forward finite difference approximation will not provide sufficient precision, then a central finite difference approximation can be used. (See \S 2.A.ii, subroutine argument {\tt JOB}.) The central finite difference approximation to the partial derivative with respect to
$\beta_k$ for response $l$ of observation $i$ is given by
$${{f_{il}(x_i+\delta_i;\beta+\tilde{h}_k u_k)-f_{il}(x_i+\delta_i;\beta-\tilde{h}_k u_k)}\over{\tilde{h}_k}}\ ,$$
$i = 1,\ldots,n$, $k = 1,\ldots,p$, and $l = 1,\ldots,q$. The step
$\tilde{h}_k$ is formed as in (4.2), where the default value for the relative step for a central finite difference derivative is
$$h=10^{-\psi/3}\ .$$
The central finite difference derivatives with respect to $\Delta$ are again formed analogously.

\bigskip\noindent{\bf 4.B. Covariance Matrix}\medskip

\noindent The linearized confidence regions and intervals for the unknowns
$\beta$ and $\Delta$ estimated by orthogonal distance regression are the same as
the linearized regions and intervals that would be obtained if the orthogonal
distance regression problem were solved as a $p+nm$ parameter nonlinear ordinary
least squares problem.  The confidence intervals are meaningful only for
unbounded parameters, but are calculated and reported just the same for bounded
parameters.  Parameters far from their bounds can still
retain some useful information as the probability that the actual parameter is
at or beyond the bound (according to the probability distribution for that
parameter) becomes small.  Even parameters on their bounds have
useful information in the confidence intervals if one were to ignore the bounds,
albeit the user likely does not wish to ignore the bounds he or she chose.
If we express the orthogonal distance regression problem defined by (1.8) or (1.9) as such a nonlinear ordinary least squares problem with $nq + nm$ observations and $p + nm$ unknowns, and we designate the unknowns of this ordinary least squares problem as $\eta^{\rm T}=(\beta^{\rm
T},\delta^{\rm T}_1,\ldots,\delta^{\rm T}_n)$, then the sum of squares to be minimized is
$$S(\eta)\equiv G(\eta)^{\rm T}\Omega G(\eta)$$
where $G(\eta)$ is the vector valued function whose $i$th ``element'' is defined by
$$g_i(\eta)=\cases{f_i(x_i+\delta_i;\beta)-y_i\qquad i=1,\ldots,n,\cr
\delta_{i-n}\hskip1.06in i=n+1,\ldots,2n,\cr}$$
and $\Omega\in\Re^{(nq+nm)\times(nq+nm)}$ is the block diagonal weighting matrix given by
$$\Omega=\left[\matrix{w_{\epsilon 1}&&&&&\cr&\ddots&&&&\cr
&&w_{\epsilon_n}&&&\cr&&&w_{\delta_1}&&\cr&&&&\ddots&\cr&&&&&w_{\delta_n}\cr}\right]\ .$$
The ordinary least squares representation of (1.8) or (1.9) is thus
$$\min_\eta S(\eta)=\min_\eta\sum_{i=1}^{2n}g_i(\eta)^{\rm
T}\Omega_{ii}g_i(\eta)\eqno(4.3)$$
where $\Omega_{ii}$ denotes the $(i,i)$th ``element'' of $\Omega$.

\noindent Let $G^\prime(\hat{\eta})\in\Re^{(nq+nm)\times(p+nm)}$ denote the Jacobian matrix with $(\nu,k)$th element equal to $\partial
g_\nu(\eta)/\partial\eta_k$ evaluated at $\hat{\eta}$. If we assume that $G^\prime(\hat{\eta})$ and $\Omega$ are full rank, so that
$[G^\prime(\hat{\eta})^{\rm T}\Omega G^\prime(\hat{\eta})]$ is nonsingular, then the linearized covariance matrix for the estimators $\hat{\eta}$ is the $(p + nm)\times(p + nm)$ matrix
$$\hat{V}\ =\ \hat{\sigma}^2[G^\prime(\hat{\eta})^{\rm T}\Omega
G^\prime(\hat{\eta})]^{-1},$$
where $\hat{\sigma} = S(\hat{\eta})/\mu=S(\hat{\beta},\hat{\delta})/\mu$ is the estimated residual variance with $\mu$ degrees of freedom. (The degrees of freedom is the number of observations with nonzero weights minus the number of parameters actually being estimated, i.e., $\mu = \tilde{n}-\tilde{p}$.) This covariance matrix $\hat{V}$ can be partitioned
$$\hat{V}=\left[\matrix{\hat{V}_\beta&\hat{V}_{\beta\delta}\cr
\hat{V}_{\delta\beta}&\hat{V}_\delta\cr}\right]$$
where $\hat{V}_\beta\in\Re^{p\times p}$ is the covariance matrix for the estimators $\hat{\beta}$, $\hat{V}_\delta\in\Re^{nm\times nm}$ is the covariance matrix for the estimators $\hat{\Delta}$, and
$\hat{V}_{\beta\delta}=\hat{V}_{\delta\beta}^{\rm T}\in\Re^{p\times nm}$ gives covariances between $\beta$ and $\Delta$. It is the covariance matrix
$\hat{V}_\beta$ of the estimators $\hat{\beta}$ that is automatically provided
by ODRPACK95. The actual computational technique used by ODRPACK95 to compute
$\hat{V}_\beta$ is described in detail in [Boggs and Rogers, 1990b].

\noindent By default, ODRPACK95 will recompute the Jacobian matrices at
the final solution before constructing the covariance matrix. However,
ODRPACK95 also provides the option of constructing the covariance matrix
using the Jacobian matrices from the last iteration. (See \S 2.A.ii,
subroutine argument {\tt JOB}.) The option of using the Jacobian matrices
from the last iteration to construct the covariance matrix is especially
useful when the evaluation of user supplied subroutine {\tt FCN} is very
time consuming. Assuming that the algorithm has actually converged, using
the Jacobian matrices from the last iteration should give essentially
the same covariance matrix as that which would be obtained using the
Jacobian matrices recomputed at the solution. Once the user confirms
that the solution is satisfactory, the covariance matrix can easily
be computed at the actual solution by calling ODRPACK95 with the final
values of $\beta$ and $\Delta$ as input, and with argument ${\tt MAXIT}
= 0$ and the third digit of argument {\tt JOB} set to 0.

\noindent The standard deviations, $\hat{\sigma}_\beta$, of the function
parameters $\hat{\beta}$ listed in the ODRPACK95 final report are the square roots of the diagonal elements of $\hat{V}_\beta$, i.e.,
$$\hat{\sigma}_{\beta_k}=\hat{V}_\beta^{1/2}(k,k)\ .$$
The 95\% confidence intervals are computed using
$$\hat{\beta}_k\pm t_{.975,\mu}\hat{\sigma}_{\beta_k}$$
where $t_{.975,\mu}$ is the appropriate value for constructing a two-sided 95\% confidence interval using the Student's $t$ value for $\mu$ degrees of freedom. When $\mu>20$, $t_{.975,\mu}\approx2$; when $\mu<5$, $t_{.975,\mu}>2.5$.

\noindent If necessary, the full covariance matrix $\hat{V}$ for all of the
estimators $\hat{\eta}$ can be computed using the equations given in [Boggs and
Rogers, 1990b], or can be ``automatically'' obtained from most ordinary least
squares software (including ODRPACK95) by solving the orthogonal distance regression problem as the ordinary least squares problem defined by (4.3).

\noindent Note that for nonlinear ordinary least squares, the linearized confidence regions and intervals are asymptotically correct as $n\rightarrow\infty$ [Jennrich, 1969]. For the orthogonal distance regression problem, they have been shown to be asymptotically correct as $\sigma^\ast\rightarrow0$ [Fuller, 1987]. The difference between the conditions of asymptotic correctness can be explained by the fact that, as the number of observations increases in the orthogonal distance regression problem one does not obtain additional information for $\Delta$. Note also that $\hat{V}$ is dependent upon the weight matrix $\Omega$, which must be assumed to be correct, and cannot be confirmed from the orthogonal distance regression results. Errors in the values of $w_{\epsilon_i}$ and
$w_{\delta_i}$ that form $\Omega$ will have an adverse affect on the accuracy of $\hat{V}$ and its component parts. The results of a Monte Carlo experiment examining the accuracy of the linearized confidence intervals for four different measurement error models is presented in [Boggs and Rogers, 1990b]. Those results indicate that the confidence regions and intervals for $\Delta$ are not as accurate as those for $\beta$.

\noindent Despite its potential inaccuracy, the covariance matrix is frequently used to construct confidence regions and intervals for both nonlinear ordinary least squares and measurement error models because the resulting regions and intervals are inexpensive to compute, often adequate, and familiar to practitioners. {\it Caution must be exercised when using such regions and intervals, however, since the validity of the approximation will depend on the nonlinearity of the model, the variance and distribution of the errors, and the data itself.} When more reliable intervals and regions are required, other more accurate methods should be used. (See, e.g., [Bates and Watts, 1988], [Donaldson and Schnabel, 1987], and [Efron, 1985].)

\bigskip\noindent{\bf 4.C. Condition Number}\medskip

\noindent For a {\it linear} least squares system of equations
$$A\beta=_2 Y\ ,\eqno(4.4)$$
with $A\in\Re^{n\times p}$ assumed to have full column rank and $=_2$ meaning ``equals in the least squares sense,'' the {\it condition number} of $A$ is defined as
$$\kappa(A)\equiv\|A\|\bigl\|A^\dagger\bigr\|\ ,$$
where $A^\dagger\equiv(A^{\rm T}A)^{-1}A^{\rm T}$ is known as the pseudo inverse of $A$. From this definition, we can show that $\kappa(A)\geq1$, and that $\kappa(A)\rightarrow\infty$ as the columns of $A$ become dependent.

\noindent Using $\kappa(A)$, bounds can be constructed on the relative error in the true least squares solution $\beta^\ast=A^\dagger Y$ due to a perturbation $E_Y$ of $Y$, or to a perturbation $E_A$ of $A$. While the actual bounds, discussed in detail in [Stewart, 1973], are quite complicated, we can roughly approximate them as follows. Let $\bar{\beta}_Y$ and $\bar{\beta}_A$ denote the solutions to the perturbed systems, $\bar{\beta}_Y=A^\dagger(Y+E_Y)$ and
$\bar{\beta}_A=(A+E_A)^\dagger Y$, respectively, and let
$R=A\beta^\ast-Y$ denote the residual at $\beta^\ast$. Then
$${\|\beta^\ast-\bar{\beta}_Y\|\over\|\beta^\ast\|}\ \ {\buildrel<\over\approx}\ \ \kappa(A)\ {\|E_Y\|\over\|Y\|}\eqno(4.5)$$
and
$${\|\beta^\ast-\bar{\beta}_A\|\over\|\beta^\ast\|}\ \ 
{\buildrel<\over\approx}\ \ \biggl(\kappa(A)+\kappa^2(A)\ {\|R\|\over\|Y\|}\biggr){\|E_A\|\over\|A\|}\ .\eqno(4.6)$$ 

\noindent For (4.5) we thus observe that the relative error in the solution could be as much as $\kappa(A)$ larger than the relative error in $Y$. Similarly, for (4.6) we observe that if the residual $R$ is small, then the relative error in $A$ is multiplied by $\kappa(A)$, whereas if the residual is not small, then the second term in (4.6) will dominate and the relative error in $A$ could be multiplied by as much as $\kappa^2(A)$.

\noindent If we express the condition number $\kappa(A)$ as a power of 10, i.e.,
$\kappa(A)=10^{\cal K}$, then (4.5) implies that the elements of the least
squares solution could have $\cal K$ fewer significant digits of accuracy than
the elements of $Y$, while (4.6) implies that the least squares solution could
have as many as $2{\cal K}$ fewer significant digits of accuracy than the
elements of $A$. {\it Therefore, $\kappa(A)$ sufficiently large could indicate
that the least squares solution has no significant digits.} For the condition
number to provide a meaningful estimate of ill-conditioning, however, the user's
problem must be formulated so that the errors in the columns of $A$ are
equilibrated. This requires an intimate knowledge of the problem, and cannot be
done as part of ODRPACK95's automatic scaling procedure. If this equilibration
has not been done by the user, the condition number returned by ODRPACK95 may not reflect the true conditioning of the problem.

\noindent ODRPACK95 returns an approximation to the inverse of the condition
number $\kappa(M_\delta J_\beta)$, where $J_\beta$ is the Jacobian matrix of
partial derivatives with respect to $\beta$, and $M_\delta$ is a block diagonal
matrix formed using the partial derivatives with respect to $\Delta$ as
described in [Boggs {\it et al}., 1987]. The matrix $M_\delta J_\beta$ is used
by ODRPACK95 to form a linearization of the user's problem at the solution, and can thus be substituted for the matrix $A$ in in the above discussions. The approximate inverse condition number is calculated as described in the {\it Linpack Users' Guide} [Dongarra {\it et al}., 1980].

\bigskip\noindent{\bf 4.D. Scaling Algorithms}\medskip

\noindent Poorly scaled problems, i.e., problems in which the unknowns $\beta$
and $\Delta$ vary over several orders of magnitude, can cause difficulty for
least squares procedures. ODRPACK95's scaling algorithms (discussed below)
attempt to overcome these difficulties automatically, although it is preferable
for the user to choose the units of $\beta$ and $\Delta$ so that their estimated
values will have roughly the same magnitude. (See, e.g., [Dennis and Schnabel,
1983].) When the variables have roughly the same magnitude, the ODRPACK95
scaling algorithm will select scale values that are roughly equal, and the
resulting computations will be the same (except for the effect of finite
precision arithmetic) as an unscaled analysis, i.e., an analysis in which all of
the scale values are set to one. If the user does not do this, the ODRPACK95 scaling algorithm will select varying scale values. This will not change the optimal solution, but it may affect the number of iterations required, or, in some cases, whether the algorithm is or is not successful.

\noindent The scale value times the corresponding absolute value of the expected solution should be approximately one. For example, if $\beta_{\rm K}$ is expected to be of order $10^{10}$ then {\smallcaps SCALE}$\{\beta_{\rm K}\}$ should be set to $10^{-10}$, while if $\beta_{\rm K}$ is expected to lie between
$-10^{-2}$ and $-10^{-4}$ then {\smallcaps SCALE}$\{\beta_{\rm K}\}$ should be set to $10^3$. Scaling should not be confused with the weighting matrices $w_{\epsilon_i}$ and $w_{\delta_i}$ specified by subroutine arguments {\tt WE} and {\tt WD}. (See also \S 1.A and \S 1.F.)

\noindent{\bf 4.D.i. Scaling $\beta$}\medskip

\noindent ODRPACK95 chooses the default scale values for the estimated values of $\beta$ as follows.\medskip

\vbox{\+ If some \cleartabs& of the values of $\beta$ are nonzero then\cr
\+& Let $\beta_{\rm max}=$ the largest nonzero absolute value in $\beta$,
and\cr
\+& Let $\beta_{\rm min}=$ the smallest nonzero absolute value in
$\beta$.\cr 
\+&For &${\tt K} =$ &$1,\ldots,p$ do\cr
\+&&&If &$\beta_{\rm K}=0$ then\cr
\+&&&&{\smallcaps SCALE}$\{\beta_{\rm K}\}=10/\beta_{\rm min}$\cr
\+&&Else if $\log(\beta_{\rm max})-\log(\beta_{\rm min})>1$
then\cr
\+&&&&{\smallcaps SCALE}$\{\beta_{\rm K}\}=1/|\beta_{\rm K}|$\cr
\+&&\ \ Else\cr
\+&&&&{\smallcaps SCALE}$\{\beta_{\rm K}\}=1/\beta_{\rm max}$\cr
\+Else if all of the values of $\beta$ are zero then\cr
\+& For ${\tt K} = 1,\ldots,p$ do\cr
\+&&{\smallcaps SCALE}$\{\beta_{\rm K}\}=1$\cr}

\noindent Users may also substitute their own scaling values for $\beta$. (See \S 2.A.ii, subroutine argument {\tt SCLB}.)\vfil\eject

\noindent{\bf 4.D.ii. Scaling $\Delta$}\medskip

\noindent ODRPACK95 chooses default scale values for the estimated errors $\Delta_{\rm IJ}$ in the explanatory variables as follows.\medskip

\vbox{\+ For {\tt J}\cleartabs&$\ = 1,\ldots,$&$\ m$ do\cr
\+& If some values in column {\tt J} of $X$ are nonzero then\cr
\+&& Let $X_{\rm max}=$ the largest nonzero absolute value in column
{\tt J}\cr
\+&& Let $X_{\rm min}=$ the smallest nonzero absolute value in column
{\tt J}\cr
\+&&For &${\tt I}=\ $&$1,\ldots,n$ do\cr
\+&&&&If &$X_{\rm IJ}=0$ then\cr
\+&&&&&{\smallcaps SCALE}$\{\Delta_{\rm IJ}\}=10/X_{\rm min}$\cr
\+&&&Else if $\log(X_{\rm max})-\log(X_{\min})>1$ then\cr
\+&&&&&{\smallcaps SCALE}$\{\Delta_{\rm IJ}\}=1/|X_{\rm IJ}|$\cr
\+&&&\ \ Else\cr
\+&&&&&{\smallcaps SCALE}$\{\Delta_{\rm IJ}\}=1/X_{\rm max}$\cr
\+&Else if all values in column {\tt J} of $X$ are zero then\cr
\+&&For ${\tt I}=1,\ldots,n$ do\cr
\+&&&{\smallcaps SCALE}$\{\Delta_{\rm IJ}\}=1$\cr}

\noindent Users may also substitute their own scaling values for $\Delta$. (See \S 2.A.ii, subroutine argument {\tt SCLD}.)

\ \vfil\eject

\ \vskip 1.4in
\def\thissection{Work Vectors}
\noindent{\capsXIV 5. Work Vectors}\bigskip\bigskip

\noindent{\bf 5.A. Extracting Information from Vector {\tt WORK}}\medskip

\noindent Upon return from a call to ODRPACK95, array {\tt WORK} contains values that may be of interest to the user. To extract information from {\tt WORK}, the following declaration statement must be added to the user's program:\medskip

\indent\vbox{\tt
\+\ LOGICAL\cr
\++\ \ \ \cleartabs&ISODR\cr
\+\ INTEGER\cr
\++&DELTAI,EPSI,XPLUSI,FNI,SDI,VCVI,\cr
\++&RVARI,WSSI,WSSDEI,WSSEPI,RCONDI,ETAI,\cr
\++&OLMAVI,TAUI,ALPHAI,ACTRSI,PNORMI,RNORSI,PRERSI,\cr
\++&PARTLI,SSTOLI,TAUFCI,EPSMAI,\cr
\++&BETA0I,BETACI,BETASI,BETANI,SI,SSI,SSFI,QRAUXI,UI,\cr
\++&FSI,FJACBI,WE1I,DIFFI,\cr
\++&DELTSI,DELTNI,TI,TTI,OMEGAI,FJACDI,\cr
\++&WRK1I,WRK2I,WRK3I,WRK4I,WRK5I,WRK6I,WRK7I,\cr
\++&LOWERI,UPPERI,\cr
\++&LWKMN\cr}\medskip

\noindent where {\tt DELTAI} through {\tt WRK7I} are variables that indicate the starting locations within {\tt WORK} of the stored values, and {\tt LWKMN} is the minimum acceptable length of array {\tt WORK}.

\noindent The appropriate values of {\tt DELTAI} through {\tt UPPERI} are
obtained by invoking subroutine {\tt DWINF}.  To invoke the subroutine,
use\medskip

\indent\vbox{\tt
\+\ CALL DWINF\cr
\++\ \ \ \cleartabs&(N,M,NP,NQ,LDWE,LD2WE,ISODR,\cr
\++&DELTAI,EPSI,XPLUSI,FNI,SDI,VCVI,\cr
\++&RVARI,WSSI,WSSDEI,WSSEPI,RCONDI,ETAI,\cr
\++&OLMAVI,TAUI,ALPHAI,ACTRSI,PNORMI,RNORSI,PRERSI,\cr
\++&PARTLI,SSTOLI,TAUFCI,EPSMAI,\cr
\++&BETA0I,BETACI,BETASI,BETANI,SI,SSI,SSFI,QRAUXI,UI,\cr
\++&FSI,FJACBI,WE1I,DIFFI,\cr
\++&DELTSI,DELTNI,TI,TTI,OMEGAI,FJACDI,\cr
\++&WRK1I,WRK2I,WRK3I,WRK4I,WRK5I,WRK6I,WRK7I,\cr
\++&LOWERI,UPPERI,\cr
\++&LWKMN).\cr}\medskip

\noindent The variables {\tt N, M, NP, NQ, LDWE,} and {\tt LD2WE}
must be input to {\tt DWINF} with exactly the same values as were used
in the original call to ODRPACK95, and {\tt ISODR} must be input set to
{\it true\/} if the fit was by orthogonal distance regression, and be
input set to {\it false\/} if the fit was by ordinary least squares. {\it
Note that when {\tt ISODR} is false, the locations that are specified by
{\tt DELTASI} through {\tt WRK1I} are the same as the location specified
by {\tt DELTAI}}.

\noindent In the following descriptions of the information returned in {\tt WORK}, $\triangleright$ indicates values that are most likely to be of interest.\bigskip

\setbox\mybox=\hbox to 1.2in{}

\hangindent\wd\mybox\hangafter=1\noindent\hbox to 1.2in{$\triangleright$\hfil{\tt WORK(DELTAI)} }is the first element of an $n\times m$ array {\tt DELTA} containing the estimated errors $\hat{\Delta}$ in the explanatory variables at the solution, where

\aligntobox {\tt WORK(DELTAI-1+I+(J-1)*N)} = {\tt DELTA(I,J)} = $\hat{\Delta}_{\rm IJ}$

\aligntobox for ${\tt I} = 1,\ldots,n$, and ${\tt J} = 1,\ldots,m$.

\aligntobox ${\tt DELTAI} = 1\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to 1.2in{$\triangleright$\hfill{\tt WORK(EPSI)} }is the first element of an $n \times q$ array {\tt EPS} containing the estimated errors $\hat E$ in the response variables at the solution, where

\aligntobox {\tt WORK(EPSI-1+I+(L-1)*N)} = {\tt EPS(I,L)} = $\hat{E}_{\rm
IL}$

\aligntobox for ${\tt I} = 1,\ldots,n$, and ${\tt L} = 1,\ldots,q$.

\aligntobox ${\tt EPSI} = nm + 1\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to 1.2in{$\triangleright$\hfill{\tt WORK(XPLUSI)} }is the first element of an $n \times m$ array {\tt XPLUSD} containing the final estimates of the explanatory variable $\hat{X}$, where

\aligntobox {\tt WORK(XPLUSI-1+I+(J-1)*N)} = {\tt XPLUSD(I,J)} =
$\hat{X}_{\rm IJ}$ = $X_{\rm IJ}+\hat{\Delta}_{\rm IJ}$

\aligntobox for ${\tt I} = 1,\ldots,n$, and ${\tt J} = 1,\ldots,m$.

\aligntobox ${\tt XPLUSI} = nm + nq + 1\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to 1.2in{$\triangleright$\hfill\tt WORK(FNI) }is the first element of an $n\times q$ array {\tt FN} containing the final estimates of the response variable $\hat{Y}$, where

\aligntobox {\tt WORK(FNI-1+I+(L-1)*N)} = {\tt FN(I,L)} = $\hat{Y}_{\rm IL}$ =
$f_{\rm IL}(x_{\rm I}+\hat{\delta}_{\rm I};\hat{\beta})$

\aligntobox for ${\tt I} = 1,\ldots,n$, and ${\tt L} = 1,\ldots,q$.

\aligntobox ${\tt FNI}=2nm+nq+1\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to 1.2in{$\triangleright$\hfill\tt WORK(SDI) }is the first element of a $p \times 1$ array {\tt SD} containing the standard deviations $\hat{\sigma}_{\beta_{\rm K}}$ of the function parameters $\beta$, i.e., the square roots of the diagonal entries of the covariance matrix, where

\aligntobox {\tt WORK(SDI-1+K)} = {\tt SD(K)} = $\hat{V}_\beta^{1/2}({\tt K, K})$ = $\hat{\sigma}_{\beta_{\rm K}}$

\aligntobox for ${\tt K} = 1,\ldots,p$. The standard deviations are only computed when the third digit of {\tt JOB} is less than or equal to 1. (See \S 2.A.ii, subroutine argument {\tt JOB}, and \S 4.B.) Rows of {\tt SD} corresponding to fixed elements of $\beta$, and to elements dropped because they induced rank deficiency, are set to zero.

\aligntobox ${\tt SDI} = 2nm + 2nq + 1\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to 1.2in{$\triangleright$\hfil{\tt WORK(VCVI)} }is the first element of a $p \times p$ array {\tt VCV} containing the values of the covariance matrix of the parameters $\beta$ prior to scaling by the residual variance, where

\aligntobox {\tt WORK(VCVI-1+I+(J-1)*(NP))} = {\tt VCV(I,J)} = $\hat{\sigma}^{-2}\hat{V}_\beta({\tt I,J})$

\aligntobox for ${\tt I} = 1,\ldots,p$ and ${\tt J} = 1,\ldots,p$. The covariance matrix is only computed when the third digit of {\tt JOB} is less than or equal to 1. (See \S 2.A.ii, subroutine argument {\tt JOB}, and \S 4.B.) Rows and columns of {\tt VCV} corresponding to fixed elements of $\beta$, and to elements dropped because they induced rank deficiency, are set to zero.

\aligntobox ${\tt VCVI} = 2nm + 2nq + p + 1\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to 1.2in{$\triangleright$\hfill\tt WORK(RVARI) }is the estimated residual variance
$\hat{\sigma}^2=S(\hat{\beta},\hat{\delta})/\mu$. (See \S 4.B.)

\aligntobox ${\tt RVARI} = 2nm + 2nq + p + p^2 + 1\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{$\triangleright$\hfill\tt WORK(WSSI) }is $S(\hat{\beta},\hat{\delta})$. (See \S 1.A.)

\aligntobox ${\tt WSSI} = 2nm + 2nq + p + p^2 + 2\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{$\triangleright$\hfill\tt WORK(WSSDEI) }is $S_\delta(\hat{\beta},\hat{\delta})$. (See \S 1.A.)

\aligntobox ${\tt WSSDEI} = 2nm + 2nq + p + p^2 + 3\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{$\triangleright$\hfill\tt WORK(WSSEPI) }is $S_\epsilon(\hat{\beta},\hat{\delta})$. (See \S 1.A.)

\aligntobox ${\tt WSSEPI} = 2nm + 2nq + p + p^2 + 4\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{$\triangleright$\hfill\tt WORK(RCONDI) }is $\kappa^{-1}(M_\delta
J_\beta)$ at the solution. (See \S 4.C.)

\aligntobox ${\tt RCONDI} = 2nm + 2nq + p + p^2 + 5\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{$\triangleright$\hfill\tt WORK(ETAI) }is the relative error in the function values computed within {\tt FCN}.

\aligntobox ${\tt ETAI} = 2nm + 2nq + p + p^2 + 6\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(OLMAVI) }is the average number of steps required to obtain the Levenberg-Marquardt parameter.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(TAUI) }is the trust region radius at the time the computations stopped.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(ALPHAI) }is the Levenberg-Marquardt parameter at the time the computations stopped.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(ACTRSI) }is the actual relative reduction in $S(\beta,\delta)$ from the last iteration.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(PNROMI) }is the norm of the scaled values of $\hat{\beta}$ and $\hat{\delta}$.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(RNORSI) }is $S(\hat{\beta},\hat{\delta})^{1/2}$.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(PRERSI) }is the predicted relative reduction in $S(\beta,\delta)$ from the last iteration.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(PARTLI) }is the stopping tolerance used to detect parameter convergence.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(SSTOLI) }is the stopping tolerance used to detect sum of squares convergence.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(TAUFCI) }is the factor used to compute the initial trust region radius.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(EPSMAI) }is machine precision, i.e., the smallest value $\xi$ such that $1 + \xi > 1$.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(BETA0I) }is the first element of a $p \times 1$ array {\tt BETA0} containing the {\it initial\/} estimates of the function parameters
$\beta^0$, where

\aligntobox {\tt WORK(BETAI0-1+K)} = {\tt BETA0(K)} = $\beta^0_{\rm K}$

\aligntobox for ${\tt K} = 1,\ldots,p$. For implicit models, {\tt BETA0} is the initial value used for the last value of the penalty parameter.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(BETACI) }is the first element of a $p \times 1$ array {\tt BETAC} containing the {\it current\/} working estimates of the $\tilde{p}$ unfixed function parameters $\tilde{\beta}^c$, where

\aligntobox {\tt WORK(BETACI-1+K)} = {\tt BETAC(K)} =
$\tilde{\beta}^c_{\rm K}$

\aligntobox for ${\tt K} = 1,\ldots,\tilde{p}$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(BETASI) }is the first element of a $p \times 1$ array {\tt BETAS} containing the saved working estimates of the $\tilde{p}$ unfixed function parameters $\tilde{\beta}^s$, where

\aligntobox {\tt WORK(BETASI-1+K)} = {\tt BETAS(K)} =
$\tilde{\beta}^s_{\rm K}$

\aligntobox for ${\tt K} = 1,\ldots,\tilde{p}$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(BETANI) }is the first element of a $p \times 1$ array {\tt BETAN} containing the new working estimates of the $\tilde{p}$ unfixed function parameters $\tilde{\beta}^n$, where

\aligntobox {\tt WORK(BETANI-1+K)} = {\tt BETAN(K)} =
$\tilde{\beta}^n_{\rm K}$

\aligntobox for ${\tt K} = 1,\ldots,\tilde{p}$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(SI) }is the first element of a $p \times 1$ array {\tt
S} containing the step in the $\tilde{p}$ unfixed function parameters at the last iteration, where

\aligntobox {\tt WORK(SI-1+K)} = {\tt S(K)}

\aligntobox  for ${\tt K} = 1,\ldots,\tilde{p}$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(SSI) }is the first element of a $p \times 1$ array {\tt SS} containing the scale of the $\tilde{p}$ unfixed function parameters
$\tilde{\beta}$, where

\aligntobox {\tt WORK(SSI-1+K)} = {\tt SS(K)} = {\smallcaps SCALE}$\{\tilde{\beta}_{\rm K}\}$

\aligntobox for ${\tt K} = 1,\ldots,\tilde{p}$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(SSFI) }is the first element of a $p \times 1$ array {\tt SSF} containing the scale of all of the function parameters $\beta$, where

\aligntobox {\tt WORK(SSFI-1+K)} = {\tt SSF(K)} = {\smallcaps
SCALE}$\{\beta_{\rm K}\}$ 

\aligntobox for ${\tt K} = 1,\ldots,p$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(QRAUXI) }is the first element of a $p \times 1$ array {\tt QRAUX} used during the computations, where

\aligntobox {\tt WORK(QRAUXI-1+I)} = {\tt QRAUX(I)}

\aligntobox for ${\tt I} = 1,\ldots,p$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(U) }is the first element of a $p \times 1$ array {\tt U} used during the computations, where

\aligntobox {\tt WORK(UI-1+I)} = {\tt U(I)}

\aligntobox for ${\tt I} = 1,\ldots,p$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(FSI) }is the first element of an $n \times q$ array {\tt FS} containing the saved estimated errors $E^s$ in the response variable, where

\aligntobox {\tt WORK(FSI-1+I+L*N)} = {\tt FS(I,L)} = $E^s_{\rm IJ}$

\aligntobox for ${\tt I} = 1,\ldots,n$, and ${\tt L} = 1,\ldots,q$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(FJACBI) }is the first element of an $n\times p\times q$ array {\tt FJACB} containing the weighted partial derivative with respect to the $\tilde{p}$ unfixed function parameters $\tilde{\beta}$, where

\aligntobox {\tt WORK(FJACBI-1+I+(K-1)*N+(L-1)*N*NP)}

\aligntobox \ \ \ \ \ = {\tt FJACB(I,K,L)} = ${\cal W}_{\rm I}{{\partial
f_{\rm IL}(x_{\rm I}+\delta_{\rm
I};\beta)}\over{\partial\tilde{\beta}_{\rm K}}}$ 

\aligntobox for ${\tt I} = 1,\ldots,n$, ${\tt K} = 1,\ldots,\tilde{p}$, ${\tt L} = 1,\ldots,q$, and ${\cal W}_{\rm I}^{\rm T}{\cal W}_{\rm I} =
w_{\epsilon_{\rm I}}$. The derivatives are the values evaluated at the beginning of the last iteration unless the user requested that the covariance matrix be computed using the final solution, in which case they are the values obtained at the final solution. (See \S 2.A.ii, subroutine argument {\tt JOB}.)
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(WE1I) }is the first element of an ${\tt LDWE}\times {\tt LD2WE}\times q$ array {\tt WE1} containing the Cholesky factorizations for the weights $w_\epsilon$ specified in {\tt WE}, where

\aligntobox {\tt WORK(WE1I-1+I+(L1-1)*LDWE+(L2-1)*LDWE*LD2WE)}

\aligntobox\ \ \ \ \ = {\tt WE1I(I,L1,L2)}

\aligntobox for ${\tt I} = 1,\ldots,{\tt LDWE}$, ${\tt L1} = 1,\ldots,{\tt LD2WE}$, and ${\tt L2} = 1,\ldots,q$. {\tt WE1I} specifies the factorization in the same manner that subroutine argument {\tt WE} is used to specify $w_\epsilon$. (See \S 2.A.ii.)
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(DIFFI) }is the first element of an $q \times (p + m)$ array {\tt DIFF} containing the relative differences between the user supplied derivatives and the finite difference values they were checked against, where

\aligntobox {\tt WORK(DIFFI-1+L+(J-1)*NQ)} = {\tt DIFF(L,J)}

\aligntobox for ${\tt L} = 1,\ldots,q$, and ${\tt J} = 1,\ldots,(p + m)$. 
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(DELTSI) }is the first element of an $n \times m$ array {\tt DELTAS} containing the saved working estimates of the errors $\Delta^s$ in the explanatory variables, where

\aligntobox {\tt WORK(DELTSI-1+I+(J-1)*N)} = {\tt DELTAS(I,J)} = $\Delta^s_{\rm
IJ}$ 

\aligntobox for ${\tt I} = 1,\ldots,n$, and ${\tt J} = 1,\ldots,m$. If {\tt ISODR} is {\it false\/}, then this array is equivalenced to the array {\tt DELTA} beginning in {\tt WORK(DELTAI)}.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(DELTNI) }is the first element of an $n \times m$ array {\tt DELTAN} containing the new working estimates of the errors $\Delta^n$ in the explanatory variables, where

\aligntobox {\tt WORK(DELTNI-1+I+(J-1)*N)} = {\tt DELTAN(I,J)} = $\Delta^n_{\rm
IJ}$ 

\aligntobox for ${\tt I} = 1,\ldots,n$, and ${\tt J} = 1,\ldots,m$. If {\tt ISODR} is {\it false\/}, then this array is equivalenced to the array {\tt DELTA} beginning in {\tt WORK(DELTAI)}.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(TI) }is the first element of an $n \times m$ array {\tt T} used in the computations, where

\aligntobox {\tt WORK(TI-1+I+(J-1)*N)} = {\tt T(I,J)}

\aligntobox for ${\tt I} = 1,\ldots,n$, and ${\tt J} = 1,\ldots,m$. If {\tt ISODR} is {\it false\/}, then this array is equivalenced to the array {\tt DELTA} beginning in {\tt WORK(DELTAI)}.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(TTI) }is the first element of an $n \times m$ array {\tt TT} containing the scale of each of the estimated errors $\Delta$ in the explanatory variable, where

\aligntobox {\tt WORK(TTI-1+I+(J-1)*N)} = {\tt TT(I,J)} = {\smallcaps SCALE}$\{\Delta_{\rm IJ}\}$ 

\aligntobox for ${\tt I} = 1,\ldots,n$, and ${\tt J} = 1,\ldots,m$. If {\tt ISODR} is {\it false\/}, then this array is equivalenced to the array {\tt DELTA} beginning in {\tt WORK(DELTAI)}.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(OMEGAI) }is the first element of a $q \times q$ array {\tt OMEGA} used during the computations, where

\aligntobox {\tt WORK(OMEGAI-1+L1+(L2-1)*NQ)} = {\tt OMEGA(L1,L2)}

\aligntobox for ${\tt L1} = 1,\ldots,q$, and ${\tt L2} = 1,\ldots,q$. If {\tt ISODR} is {\it false\/}, then this array is equivalenced to the array {\tt DELTA} beginning in {\tt WORK(DELTAI)}.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(FJACDI) }is the first element of an $n \times m \times q$ array {\tt FJACD} containing the weighted partial derivative with respect to $\Delta$, where

\aligntobox {\tt WORK(FJACDI-1+I+(J-1)*N+(L-1)*N*M)}

\aligntobox\ \ \ \ \ = {\tt FJACD(I,J,L)} = ${\cal W}_{\rm I}{{\partial
f_{\rm IL}(x_{\rm I}+\delta_{\rm I};\beta)}\over{\partial\Delta_{\rm
IJ}}}$

\aligntobox for ${\tt I} = 1,\ldots,n$, ${\tt J} = 1,\ldots,m$, ${\tt L} = 1,\ldots,q$, and ${\cal W}_{\rm I}^{\rm T}{\cal W}_{\rm I}=w_{\epsilon_{\rm
I}}$. The derivatives are the values evaluated at the beginning of the last iteration unless the user requested that the covariance matrix be computed using the final solution, in which case they are the values obtained at the final solution. (See \S 2.A.ii, subroutine argument {\tt JOB}.) If {\tt ISODR} is {\it false\/}, then this array is equivalenced to the array {\tt DELTA} beginning in {\tt WORK(DELTAI)}.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(WRK1I) }is the first element of an $n \times m \times q$ array {\tt WRK1} required for work space, where

\aligntobox {\tt WORK(WRK1I-1+I+(J-1)*N+(L-1)*N*NQ)} = {\tt WRK1(I,J,L)}

\aligntobox for ${\tt I} = 1,\ldots,n$, ${\tt J} = 1,\ldots,m$, and ${\tt L} = 1,\ldots,q$. If {\tt ISODR} is {\it false\/}, then this array is equivalenced to the array {\tt DELTA} beginning in {\tt WORK(DELTAI)}.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(WRK2I) }is the first element of an $n \times q$ array {\tt WRK2} required for work space, where

\aligntobox {\tt WORK(WRK2I-1+I+(L-1)*N)} = {\tt WRK2(I,L)}

\aligntobox for ${\tt I} = 1,\ldots,n$, and ${\tt L} = 1,\ldots,q$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(WRK3) }is the first element of a $p \times 1$ array {\tt WRK3} required for work space, where

\aligntobox {\tt WORK(WRK3-1+K)} = {\tt WRK3(K)}

\aligntobox for ${\tt K} = 1,\ldots,p$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(WRK4I) }is the first element of an $m \times m$ array {\tt WRK4} required for work space, where

\aligntobox {\tt WORK(WRK4I-1+J1+(J2-1)*M)} = {\tt WRK4(J1,J2)} 

\aligntobox for ${\tt J1} = 1,\ldots,m$, and ${\tt J2} = 1,\ldots,m$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(WRK5I) }is the first element of an $m$ array {\tt WRK5} required for work space, where

\aligntobox {\tt WORK(WRK5I-1+J)} = {\tt WRK5(J)}

\aligntobox for ${\tt J} = 1,\ldots,m$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(WRK6I) }is the first element of an $n \times p \times q$ array {\tt WRK6} required for work space, where

\aligntobox {\tt WORK(WRK6I-1+I+(K-1)*N+(L-1)*N*NQ)} = {\tt WRK6(I,K,L)}

\aligntobox for ${\tt I} = 1,\ldots,n$, ${\tt K} = 1,\ldots,p$, and ${\tt L} = 1,\ldots,q$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(WRK7I) }is the first element of an $5q$ array {\tt WRK7} required for work space, where

\aligntobox {\tt WORK(WRK7I-1+J)} = {\tt WRK7(J)}

\aligntobox for ${\tt J} = 1,\ldots,5q$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(LOWERI) }is the first element of an $p$ array used to store the lower bounds of the user supplied or default 30-{\tt LOWER}

\aligntobox {\tt WORK(LOWERI-1+J)} = {\tt LOWER(J)}

\aligntobox for ${\tt J} = 1,\ldots,p$.
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt WORK(UPPERI) }is the first element of an $p$ array used to store the upper bounds of the user supplied or default 31-{\tt UPPER}

\aligntobox {\tt WORK(UPPERI-1+J)} = {\tt UPPER(J)}

\aligntobox for ${\tt J} = 1,\ldots,p$.
\bigskip

\noindent{\bf 5.B. Extracting Information from Vector {\tt IWORK}}\medskip

\noindent Upon return from a call to ODRPACK95, array {\tt IWORK} contains values that may be of interest to the user. To extract information from {\tt IWORK}, the following declaration statement must be added to the user's program\medskip

\indent\vbox{\tt
\+\ INTEGER\cr
\++\ \ \ \cleartabs&MSGBI,MSGDI,IFIX2I,ISTOPI,\cr
\++&NNZWI,NPPI,IDFI,\cr
\++&JOBI,IPRINI,LUNERI,LUNRPI,\cr
\++&NROWI,NTOLI,NETAI,\cr
\++&MAXITI,NITERI,NFEVI,NJEVI,INT2I,IRANKI,LDTTI,\cr
\++&LIWKMN\cr}\medskip

\noindent where {\tt MSGBI} through {\tt LDTTI} are variables that
indicate the starting locations within {\tt IWORK} of the stored
values, and {\tt LIWKMN} is the minimum acceptable length of array
{\tt IWORK}. The appropriate values of {\tt MSGBI} through {\tt LDTTI}
are obtained by invoking subroutine {\tt DIWINF}. To invoke the
subroutine, use\medskip

\indent\vbox{\tt
\+\ CALL DIWINF\cr
\++\ \ \ \cleartabs&(M,NP,NQ,\cr
\++&MSGBI,MSGDI,IFIX2I,ISTOPI,\cr
\++&NNZWI,NPPI,IDFI,\cr
\++&JOBI,IPRINI,LUNERI,LUNRPI,\cr
\++&NROWI,NTOLI,NETAI,\cr
\++&MAXITI,NITERI,NFEVI,NJEVI,INT2I,IRANKI,LDTTI,\cr
\++&LIWKMN).\cr}

\noindent Note that the values of {\tt M, NP,} and {\tt NQ} must be
input to {\tt DIWINF} with exactly the same values as
were used in the original call to ODRPACK95.

\noindent In the following descriptions of the information returned in {\tt IWORK}, $\ \triangleright\ $ indicates values that are most likely to be of interest.\medskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{$\triangleright$\hfill\tt IWORK(MSGBI) }is the first element of a $1\ +\ (q\ \times\ p)$ array {\tt MSGB} used to indicate the results of checking the partial derivatives with respect to $\beta$ at observation {\tt NROW}. (See {\tt IWORK(NROWI)} below.)

{\parindent=1.35in 
\aligntobox The value of {\tt IWORK(MSGBI)} summarizes the results over all $\beta$.

\item{$\bullet$} If ${\tt IWORK(MSGBI)} < 0$ then\hfil\break the partial derivatives with respect to $\beta$ were not checked.

\item{$\bullet$} If ${\tt IWORK(MSGBI)} = 0$ then\hfil\break the partial derivatives with respect to each of the $\beta_{\rm K},\ {\tt K} = 1,\ldots,p$, for each of the $q$ responses appear to be correct.

\item{$\bullet$} If ${\tt IWORK(MSGBI)} = 1$ then\hfil\break the partial derivative with respect to at least one of the $\beta_{\rm K},\ {\tt K}=1,\ldots,p$, appears to be questionable for at least one of the $q$ responses.

\item{$\bullet$} If ${\tt IWORK(MSGBI)} = 2$ then\hfil\break the partial derivative with respect to at least one of the $\beta_{\rm K},\ {\tt K}=1,\ldots,p$, appears to be seriously questionable for at least one of the $q$ responses.

\aligntobox The value of {\tt IWORK(MSGBI+L+(K-1)*NQ)}, ${\tt L} = 1,\ldots,q$, ${\tt K} = 1,\ldots,p$, indicates the individual results of checking the partial derivative of the {\tt L}th response with respect to each $\beta_{\rm K}$, where for ${\tt L} = 1,\ldots,q$, and ${\tt K} = 1,\ldots,p$ :

\item{$\bullet$} If ${\tt IWORK(MSGBI+L+(K-1)*NQ)} = -1$ then\hfil\break the partial derivative of the {\tt L}th response with respect to $\beta_{\rm K}$ was not checked because $\beta_{\rm K}$ was fixed.

\item{$\bullet$} If ${\tt IWORK(MSGBI+L+(K-1)*NQ)} = 0$ then\hfil\break the partial derivative of the {\tt L}th response with respect to $\beta_{\rm K}$ appears to be correct, i.e., the relative difference between its value and the finite difference approximation it is checked against is within the required tolerance. 

\item{$\bullet$} If ${\tt IWORK(MSGBI+L+(K-1)*NQ)} = 1$ then\hfil\break the partial derivative of the {\tt L}th response with respect to $\beta_{\rm K}$ is questionable because the user supplied derivative and the finite difference value it is checked against are both zero.

\item{$\bullet$} If ${\tt IWORK(MSGBI+L+(K-1)*NQ)} = 2$ then\hfil\break the partial derivative of the {\tt L}th response with respect to $\beta_{\rm K}$ is
questionable because either the user supplied derivative is exactly zero and the finite difference value it is checked against is only approximately zero, or the user supplied derivative only approximately zero and and the finite difference value it is checked against is exactly zero.

\item{$\bullet$} If ${\tt IWORK(MSGBI+L+(K-1)*NQ)} = 3$ then\hfil\break the partial derivative of the {\tt L}th response with respect to $\beta_{\rm K}$ is questionable because either the user supplied derivative is exactly zero and the finite difference value it is checked against is not even approximately zero, or the user supplied derivative not even approximately zero and and the finite difference value it is checked against is exactly zero.

\item{$\bullet$} If ${\tt IWORK(MSGBI+L+(K-1)*NQ)} = 4$ then\hfil\break the partial derivative of the {\tt L}th response with respect to $\beta_{\rm K}$ is questionable because the finite difference value it is being checked against is questionable due to a high ratio of relative curvature to relative slope or to an incorrect scale value.

\item{$\bullet$} If ${\tt IWORK(MSGBI+L+(K-1)*NQ)} = 5$ then\hfil\break the partial derivative of the {\tt L}th response with respect to $\beta_{\rm K}$ is questionable because the finite difference value it is being checked against is questionable due to a high ratio of relative curvature to relative slope.

\item{$\bullet$} If ${\tt IWORK(MSGBI+L+(K-1)*NQ)} = 6$ then\hfil\break the partial derivative of the {\tt L}th response with respect to $\beta_{\rm K}$ is questionable because it does not agree with the finite difference value it is being checked against to the required tolerance, although the values do agree in their first two digits. (See {\tt IWORK(NTOLI)} below.)

\item{$\bullet$} If ${\tt IWORK(MSGBI+L+(K-1)*NQ)} = 7$ then\hfil\break the partial derivative of the {\tt L}th response with respect to $\beta_{\rm K}$ is seriously questionable because it has fewer than two digits agreement with the finite difference value it is being checked against.

\aligntobox ${\tt MSGBI} = 1\ .$}\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{$\triangleright$\hfill\tt IWORK(MSGDI) }is the first element of a $1 + (q \times m)$ array {\tt MSGD} used to indicate the results of checking the partial derivatives with respect to $\Delta$, analogous to {\tt MSGB} described above. The values in {\tt MSGD} have the same meanings as those used to indicate the results of checking the partial derivatives with respect to $\beta$, except that the value of {\tt IWORK(MSGDI)} summarizes the results over all columns of $\Delta$, and the values of {\tt IWORK(MSGDI+L+(J-1)*NQ)}, ${\tt L} = 1,\ldots,q$, ${\tt J} = 1,\ldots,m$, indicates the individual results for checking the partial derivative of the {\tt L}th response with respect to the {\tt J}th column of $\Delta$ at observation {\tt NROW}. (See {\tt IWORK(NROWI)} below.)

\aligntobox ${\tt MSGDI} = qp + 2\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{$\triangleright$\hfill\tt IWORK(IFIX2I) }is the first element of a $p \times 1$ array {\tt IFIX2} containing values used to indicate whether a given parameter is unfixed, fixed or dropped because it induced rank deficiency, where

\aligntobox {\tt WORK(IFIX2I-1+K)} = {\tt IFIX2(K)}

{\parindent=1.35in
\aligntobox for ${\tt K} = 1,\ldots,p$. If

\item{$\bullet$} ${\tt IFIX2(K)} =\ 1$ the parameter was unfixed,
\item{$\bullet$} ${\tt IFIX2(K)} =\ 0$ the parameter was fixed,
\item{$\bullet$} ${\tt IFIX2(K)} = -1$ the parameter was dropped, and
\item{$\bullet$} ${\tt IFIX2(K)} = -2$ no parameters were estimated.

\aligntobox ${\tt IFIX2I} = qp + qm + 3\ .$}\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{$\triangleright$\hfill\tt IWORK(ISTOPI) }is value of {\tt ISTOP} returned from the last call to subroutine {\tt FCN}.

\aligntobox ${\tt ISTOPI} = qp + qm + p + 3\ .$
\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(NNZWI) }is the number of nonzero $\epsilon$ error weights, $w_{\epsilon_{\rm I}}$, ${\tt I} = 1,\ldots,n$.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(NPPI) }is the number $\tilde{p}$ of function parameters actually being estimated, i.e., the number of unfixed parameters.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(IDFI) }is the degrees of freedom, $\mu$, of the fit, i.e., the number of observations with nonzero weights minus the number of parameters actually being estimated.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(JOBI) }is the value used to specify problem initialization and computational methods.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(IPRINI) }is the print control value used.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(LUNERI) }is the logical unit number used for error reports.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(LUNRPI) }is the logical unit number used for computation reports.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(NROWI) }is the observation {\tt NROW} at which the derivatives were checked.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(NTOLI) }is the number of digits of agreement required between the numerical derivatives and the user supplied derivatives for the user supplied derivatives to be considered correct.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(NETAI) }is the number of good digits in the function results returned by user supplied subroutine {\tt FCN}.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(MAXITI) }is the maximum number of iterations allowed.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(NITERI) }is the number of iterations taken.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(NFEVI) }is the number of function evaluations made.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(NJEVI) }is the number of Jacobian matrix evaluations made.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(INT2I) }is the number of internal doubling steps taken at the time the computations stopped.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(IRANKI) }is the rank deficiency at the solution.\bigskip

\hangindent\wd\mybox\hangafter=1\noindent\hbox to
1.2in{\hfill\tt IWORK(LDTTI) }is the leading dimension of the $n \times m$ array {\tt TT}. (See \S 5.A.)

\vfil\eject

\ \vskip 1.4in
\def\thissection{Bibliography}
\noindent{\capsXIV Bibliography}\bigskip\bigskip

\setbox\mybox=\hbox{[25]\ }
\def\ref#1#2{\noindent\hangindent=\wd\mybox\hangafter=1 
\hbox to \wd\mybox{\hss[#1]\ }#2\medskip}

\ref{1}{American National Standards Institute (1977), {\it ANS FORTRAN X3.9-1977\/}, American National Standards Institute, New York, NY.}

\ref{2}{Bates, D. M., and D. G. Watts (1988), {\it Nonlinear Regression Analysis and its Applications\/}, John Wiley and Sons, New York, NY.}

\ref{3}{Belsley, D. A., E. Kuh, and R. E. Welsch (1980), {\it Regression diagnostics\/}, John Wiley and Sons, New York, NY.}

\ref{4}{Bement, T. R., and J. S. Williams (1969), ``Variance of weighted regression estimators when sampling errors are independent and heteroscedastic,'' {\it J. Amer. Statists. Assoc.\/}, 64:1369--1382.}

\ref{5}{Bischof, C., A. Carle, G. Corliss, A. Griewank, P. Hovland (1991), ``ADIFOR --- generating derivative codes from Fortran programs,'' ADIFOR Working Note \#1, MCS-P263-0991, Mathematics and Computer Science Division, Argonne National Laboratory, Argonne, IL; also available as CRPC-TR91185, Center for Research on Parallel Computation, Rice University, Houston, TX.}

\ref{6}{Boggs, P. T., R. H. Byrd, and R. B. Schnabel (1987), ``A stable and efficient algorithm for nonlinear orthogonal distance regression,'' {\it SIAM J. Sci. Stat. Comput.\/}, 8(6):1052--1078.}

\ref{7}{Boggs, P. T., R. H. Byrd, J. R. Donaldson, and R. B. Schnabel (1989), ``Algorithm 676 --- ODRPACK: Software for Weighted Orthogonal Distance Regression,'' {\it ACM Trans. Math. Software\/}, 15(4):348--364.}

\ref{8}{Boggs, P. T., J. R. Donaldson, R. B. Schnabel, and C. H. Spiegelman (1988), ``A computational examination of orthogonal distance regression,'' {\it J. Econometrics\/}, 38(1/2):169--201.}

\ref{9}{Boggs, P. T., and J. E. Rogers (1990a), ``Orthogonal Distance Regression,'' {\it Contemporary Mathematics\/}, 112:183--194.}

\ref{10}{Boggs, P. T., and J. E. Rogers (1990b), ``The Computation and Use of the Asymptotic Covariance Matrix for Measurement Error Models,'' Internal Report 89-4102, Applied and Computational Mathematics Division, National Institute of Standards and Technology, Gaithersburg, MD.}

\ref{11}{Cook, D. R. (1977), ``Detection of influential observations in linear regression,'' {\it Technometrics\/}, 19:15--18.}

\ref{12}{Dennis, J. E., and R. B. Schnabel (1983), {\it Numerical Methods for Unconstrained Optimization and Nonlinear Equations\/}, Prentice-Hall, Englewood Cliffs, NJ.}

\ref{13}{Donaldson, J. R., and Schnabel, R. B. (1987), ``Computational Experience with Confidence Regions and Confidence Intervals for Nonlinear Least Squares,'' {\it Technometrics\/}, 29(1):67--82.}

\ref{14}{Donaldson, J. R., and P. V. Tryon (1986), ``STARPAC --- the Standards Time Series and Regression Package,'' Internal Report 86-3448, Computing and Applied Mathematics Laboratory, National Institute of Standards and Technology, Boulder, CO.}

\ref{15}{Dongarra, J. J., C. B. Moler, J. R. Bunch, and G. W. Stewart (1979), {\it LINPACK Users' Guide\/}, SIAM, Philadelphia, PA.}

\ref{16}{Efron, B. (1985), {\it The Jackknife, the Bootstrap and Other Resampling Plans\/}, SIAM, Philadelphia, PA.}

\ref{17}{Filliben, J. J. (1977), ``User's Guide to the DATAPAC Data Analysis Package,'' (unpublished: available from NIST Statistical Engineering Division, Gaithersburg, MD).}

\ref{18}{Fox, P. A., A. D. Hall, and N. L. Schryer (1978), ``Algorithm 528 --- Framework for a Portable Library [z],'' {\it ACM Trans. Math. Software\/}, 4(2):177--188.}

\ref{19}{Fuller, W. A. (1987), {\it Measurement Error Models\/}, John Wiley and Sons, New York, NY.}

\ref{20}{Gill, P. E., W. Murray, and M. H. Wright (1981), {\it Practical Optimization\/}, Academic Press, New York, NY.}

\ref{21}{Griewank, A. (1989), ``On automatic differentiation,'' in {\it Mathematical Programming: Recent Developments and Applications\/}, M. Iri and K. Tanabe, editors, Kluwer Academic Publishers, Amsterdam, Holland.}

\ref{22}{Havriliak, S. Jr., and S. Negami (1967), ``A Complex Plane Representation of Dielectric and Mechanical Relaxation Processes in Some Polymers,'' {\it Polymer\/}, 8: 161--205.}

\ref{23}{Himmelblau, D. M. (1970), {\it Process Analysis by Statistical Methods\/}, John Wiley and Sons, New York, NY.}

\ref{24}{Hoaglin, D. C., and R. E. Welsch (1978), ``The hat matrix in regression and ANOVA,'' {\it American Statistician\/}, 32:17--22.}

\ref{25}{Jennrich, R. I. (1969), ``Asymptotic Properties of Non-linear Least Squares Estimators,'' {\it Annals of Mathematical Statistics\/}, 40:633--643.}

\ref{26}{Juedes, D. (1991) ``A taxonomy of automatic differentiation tools,'' in {\it Proceedings of the Workshop on Automatic Differentiation of Algorithms: Theory, Implementation, and Application\/}, A. Griewank and P. L. Toint, editors, SIAM, Philadelphia, PA.}

\ref{27}{Lawson, C., R. Hanson, D. Kincaid, and F. Krogh (1979), ``Basic linear algebra subprograms for FORTRAN usage,'' {\it ACM Trans. Math. Software\/}, 5(3):308--371.}

\ref{28}{Schnabel, R. B. (1982), ``Finite difference derivatives --- theory and practice,'' (unpublished: available from author).}

\ref{29}{Seber, G. A. F., and C. J. Wild (1989), {\it Nonlinear Regression\/}, John Wiley and Sons, New York, NY.}

\ref{30}{Stephens, B. R., and J. D. Pryce (1991), ``DAPRE: a differentiation arithmetic system for Fortran,'' Technical Report ACM-91-3, Royal Military College of Science, Shrivenham, UK.}

\ref{31}{Stewart, G. W. (1973), {\it Introduction to Matrix Computations\/}, Academic Press, New York, NY.}

\ref{32}{Zwolak, J. W., J. J. Tyson, and L. T. Watson (2001), ``Estimating rate
constants in cell cycle models.'' {\it Proc. High Performance Computing
Symposium 2001}, A. Tentner (ed.), Soc. for Modeling and Simulation
Internat., San Diego, CA, 53--57.}

\ref{33}{Zwolak, J. W., J. J. Tyson, and L. T. Watson (2005), ``Parameter
Estimation for a Mathematical Model of the Cell Cycle in Frog Eggs.'' {\it
Journal of Computational Biology}, 12(1):48--63.}

\ref{34}{Zwolak, J. W., J. J. Tyson, and L. T. Watson (2005), ``Globally
Optimized Parameters for a Model of Mitotic Control in Frog Egg Extracts.'' {\it
IEE Systems Biology}, 152(2):81--92.}

\ref{35}{Zwolak, J. W., P. T. Boggs, and L. T. Watson (2006), ``ODRPACK95: A
Weighted Orthogonal Distance Regression Code with Bound Constraints'' {\it ACM
TOMS}, submitted.}

\vfil\eject\bye
