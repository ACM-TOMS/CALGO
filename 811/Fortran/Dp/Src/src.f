************************************************************************
* SUBROUTINE PMINU              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR UNCONSTRAINED MINIMAX OPTIMIZATION.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  RO  AF(NA)  VECTOR CONTAINING VALUES OF THE APPROXIMATED
*         FUNCTIONS.
*  IA  IA(NA+NF+1)  AUXILIARY ARRAY.
*  RA  RA((NF+NA+8)*NF+2*NA+4)  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  SCALING OF THE BFGS UPDATE. IPAR(1)=1-NO SCALING.
*         IPAR(1)=2-SCALING IN THE FIRST ITERATION.
*         IPAR(1)=3-CONTROLLED SCALING.
*      IPAR(2)  CORRECTION OF THE BFGS UPDATE IF A NEGATIVE CURVATURE
*         OCCURS. IPAR(2)=1-NO CORRECTION. IPAR(2)=2-POWELL'S
*         CORRECTION.
*      IPAR(3)  RESTART AFTER UNSUCCESSFUL UPDATE. IPAR(3)=0-RESTART
*         SUPPRESSED. IPAR(3)=1-RESTART PERFORMED.
*      IPAR(4)  INTERPOLATION IN LINE SEARCH. IPAR(4)=1-BISECTION.
*         IPAR(4)=2-TWO POINT QUADRATIC INTERPOLATION. IPAR(4)=3-THREE
*         POINT QUADRATIC INTERPOLATION. IPAR(4)=4-THREE POINT CUBIC
*         INTERPOLATION.
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(7)=0-NO PRINT.
*         ABS(IPAR(7))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(7))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(7)>0-BASIC FINAL RESULTS. IPAR(7)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(7)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE FUNCTION FALUE.
*      RPAR(4)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(5)  TOLERANCE FOR A DESCENT DIRECTION.
*      RPAR(6)  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*      RPAR(7)  MAXIMUM STEPSIZE.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM PARTIAL DERIVATIVE.
*  II  IEXT  TYPE OF OBJECTIVE FUNCTION. IEXT<0-MAXIMUM OF POSITIVE
*         VALUES. IEXT=0-MAXIMUM OF ABSOLUTE VALUES. IEXT>0-MAXIMUM
*         OF NEGATIVE VALUES.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PMIN  RECURSIVE QUADRATIC PROGRAMMING METHOD WITH THE BFGS
*         VARIABLE METRIC UPDATE.
*
* EXTERNAL SUBROUTINES :
*  SE  FUN  CONPUTATION OF THE VALUE OF THE APPROXIMATED FUNCTION.
*         CALLING SEQUENCE: CALL FUN(NF,KA,X,FA) WHERE NF IS A NUMBER
*         OF VARIABLES, KA IS THE INDEX OF THE APPROXIMATED FUNCTION,
*         X(NF) IS A VECTOR OF VARIABLES AND FA IS THE VALUE OF THE
*         APPROXIMATED FUNCTION.
*  SE  DER  CONPUTATION OF THE GRADIENT OF THE APPROXIMATED FUNCTION.
*         CALLING SEQUENCE: CALL DER(NF,KA,X,GA) WHERE NF IS A NUMBER
*         OF VARIABLES, KA IS THE INDEX OF THE APPROXIMATED FUNCTION,
*         X(NF) IS A VECTOR OF VARIABLES AND GA(NF) IS THE GRADIENT OF
*         THE APPROXIMATED FUNCTION.
*
      SUBROUTINE PMINU(NF,NA,X,AF,IA,RA,IPAR,RPAR,F,GMAX,IEXT,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION F,GMAX
      INTEGER IEXT,ITERM,NA,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),RA(*),RPAR(7),X(*)
      INTEGER IA(*),IPAR(7)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAFD,LAFO,LAG,LAR,LAZ,LG,LGA,LGO,LH,LIA,LIAA,LS,LXO,NB,NC
C     ..
C     .. External Subroutines ..
      EXTERNAL PMIN
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      NB = 0
      NC = 0
*
*     POINTERS FOR AUXILIARY ARRAYS
*
      LAFO = 1
      LAFD = LAFO + NA
      LGA = LAFD + NA
      LAG = LGA + NF
      LAR = LAG + NF*NA
      LAZ = LAR + (NF+1)* (NF+2)/2
      LG = LAZ + NF + 1
      LH = LG + NF + 1
      LS = LH + NF* (NF+1)/2
      LXO = LS + NF + 1
      LGO = LXO + NF
      LIA = 1
      LIAA = LIA + NA
      CALL PMIN(NF,NA,NB,NC,X,IA,RA,RA,RA,IA,RA,RA,RA,RA,AF,IA,RA(LAFO),
     +          RA(LAFD),RA(LGA),RA(LAG),IA(LIAA),RA(LAR),RA(LAZ),
     +          RA(LG),RA(LH),RA(LS),RA(LXO),RA(LGO),RPAR(1),RPAR(2),
     +          RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),GMAX,F,IEXT,
     +          IPAR(1),IPAR(2),IPAR(3),IPAR(4),IPAR(5),IPAR(6),IPAR(7),
     +          ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PMINS              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR MINIMAX OPTIMIZATION WITH SIMPLE BOUNDS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  II  NB  CHOICE OF SIMPLE BOUNDS. NB=0-SIMPLE BOUNDS SUPPRESSED.
*         NB>0-SIMPLE BOUNDS ACCEPTED.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS. IX(I)=0-VARIABLE
*         X(I) IS UNBOUNDED. IX(I)=1-LOVER BOUND XL(I).LE.X(I).
*         IX(I)=2-UPPER BOUND X(I).LE.XU(I). IX(I)=3-TWO SIDE BOUND
*         XL(I).LE.X(I).LE.XU(I). IX(I)=5-VARIABLE X(I) IS FIXED.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RO  AF(NA)  VECTOR CONTAINING VALUES OF THE APPROXIMATED
*         FUNCTIONS.
*  IA  IA(NA+NF+1)  AUXILIARY ARRAY.
*  RA  RA((NF+NA+8)*NF+2*NA+4)  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  SCALING OF THE BFGS UPDATE. IPAR(1)=1-NO SCALING.
*         IPAR(1)=2-SCALING IN THE FIRST ITERATION.
*         IPAR(1)=3-CONTROLLED SCALING.
*      IPAR(2)  CORRECTION OF THE BFGS UPDATE IF A NEGATIVE CURVATURE
*         OCCURS. IPAR(2)=1-NO CORRECTION. IPAR(2)=2-POWELL'S
*         CORRECTION.
*      IPAR(3)  RESTART AFTER UNSUCCESSFUL UPDATE. IPAR(3)=0-RESTART
*         SUPPRESSED. IPAR(3)=1-RESTART PERFORMED.
*      IPAR(4)  INTERPOLATION IN LINE SEARCH. IPAR(4)=1-BISECTION.
*         IPAR(4)=2-TWO POINT QUADRATIC INTERPOLATION. IPAR(4)=3-THREE
*         POINT QUADRATIC INTERPOLATION. IPAR(4)=4-THREE POINT CUBIC
*         INTERPOLATION.
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(7)=0-NO PRINT.
*         ABS(IPAR(7))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(7))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(7)>0-BASIC FINAL RESULTS. IPAR(7)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(7)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(4)  TOLERANCE FOR THE FUNCTION FALUE.
*      RPAR(5)  TOLERANCE FOR A DESCENT DIRECTION.
*      RPAR(6)  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*      RPAR(7)  MAXIMUM STEPSIZE.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM PARTIAL DERIVATIVE.
*  II  IEXT  TYPE OF OBJECTIVE FUNCTION. IEXT<0-MAXIMUM OF POSITIVE
*         VALUES. IEXT=0-MAXIMUM OF ABSOLUTE VALUES. IEXT>0-MAXIMUM
*         OF NEGATIVE VALUES.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PMIN  RECURSIVE QUADRATIC PROGRAMMING METHOD WITH THE BFGS
*         VARIABLE METRIC UPDATE.
*
* EXTERNAL SUBROUTINES :
*  SE  FUN  CONPUTATION OF THE VALUE OF THE APPROXIMATED FUNCTION.
*         CALLING SEQUENCE: CALL FUN(NF,KA,X,FA) WHERE NF IS A NUMBER
*         OF VARIABLES, KA IS THE INDEX OF THE APPROXIMATED FUNCTION,
*         X(NF) IS A VECTOR OF VARIABLES AND FA IS THE VALUE OF THE
*         APPROXIMATED FUNCTION.
*  SE  DER  CONPUTATION OF THE GRADIENT OF THE APPROXIMATED FUNCTION.
*         CALLING SEQUENCE: CALL DER(NF,KA,X,GA) WHERE NF IS A NUMBER
*         OF VARIABLES, KA IS THE INDEX OF THE APPROXIMATED FUNCTION,
*         X(NF) IS A VECTOR OF VARIABLES AND GA(NF) IS THE GRADIENT OF
*         THE APPROXIMATED FUNCTION.
*
* METHOD :
* RECURSIVE QUADRATIC PROGRAMMING METHOD WITH THE VARIABLE METRIC
* UPDATE.
*
      SUBROUTINE PMINS(NF,NA,NB,X,IX,XL,XU,AF,IA,RA,IPAR,RPAR,F,GMAX,
     +                 IEXT,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION F,GMAX
      INTEGER IEXT,ITERM,NA,NB,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),RA(*),RPAR(7),X(*),XL(*),XU(*)
      INTEGER IA(*),IPAR(7),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAFD,LAFO,LAG,LAR,LAZ,LG,LGA,LGO,LH,LIA,LIAA,LS,LXO,NC
C     ..
C     .. External Subroutines ..
      EXTERNAL PMIN
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      NC = 0
*
*     POINTERS FOR AUXILIARY ARRAYS
*
      LAFO = 1
      LAFD = LAFO + NA
      LGA = LAFD + NA
      LAG = LGA + NF
      LAR = LAG + NF*NA
      LAZ = LAR + (NF+1)* (NF+2)/2
      LG = LAZ + NF + 1
      LH = LG + NF + 1
      LS = LH + NF* (NF+1)/2
      LXO = LS + NF + 1
      LGO = LXO + NF
      LIA = 1
      LIAA = LIA + NA
      CALL PMIN(NF,NA,NB,NC,X,IX,XL,XU,RA,IA,RA,RA,RA,RA,AF,IA,RA(LAFO),
     +          RA(LAFD),RA(LGA),RA(LAG),IA(LIAA),RA(LAR),RA(LAZ),
     +          RA(LG),RA(LH),RA(LS),RA(LXO),RA(LGO),RPAR(1),RPAR(2),
     +          RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),GMAX,F,IEXT,
     +          IPAR(1),IPAR(2),IPAR(3),IPAR(4),IPAR(5),IPAR(6),IPAR(7),
     +          ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PMINL              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR MINIMAX OPTIMIZATION WITH SIMPLE BOUNDS
* AND GENERAL LINEAR CONSTRAINTS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  II  NB  CHOICE OF SIMPLE BOUNDS. NB=0-SIMPLE BOUNDS SUPPRESSED.
*         NB>0-SIMPLE BOUNDS ACCEPTED.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS. IX(I)=0-VARIABLE
*         X(I) IS UNBOUNDED. IX(I)=1-LOVER BOUND XL(I).LE.X(I).
*         IX(I)=2-UPPER BOUND X(I).LE.XU(I). IX(I)=3-TWO SIDE BOUND
*         XL(I).LE.X(I).LE.XU(I). IX(I)=5-VARIABLE X(I) IS FIXED.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  CF(NC)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*         IC(KC)=0-CONSTRAINT CF(KC) IS NOT USED. IC(KC)=1-LOVER
*         CONSTRAINT CL(KC).LE.CF(KC). IC(KC)=2-UPPER CONSTRAINT
*         CF(KC).LE.CU(KC). IC(KC)=3-TWO SIDE CONSTRAINT
*         CL(KC).LE.CF(KC).LE.CU(KC). IC(KC)=5-EQUALITY CONSTRAINT
*         CF(KC).EQ.CL(KC).
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RO  AF(NA)  VECTOR CONTAINING VALUES OF THE APPROXIMATED
*         FUNCTIONS.
*  IA  IA(NA+NF+1)  AUXILIARY ARRAY.
*  RA  RA((NF+NA+8)*NF+2*NA+4)  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  SCALING OF THE BFGS UPDATE. IPAR(1)=1-NO SCALING.
*         IPAR(1)=2-SCALING IN THE FIRST ITERATION.
*         IPAR(1)=3-CONTROLLED SCALING.
*      IPAR(2)  CORRECTION OF THE BFGS UPDATE IF A NEGATIVE CURVATURE
*         OCCURS. IPAR(2)=1-NO CORRECTION. IPAR(2)=2-POWELL'S
*         CORRECTION.
*      IPAR(3)  RESTART AFTER UNSUCCESSFUL UPDATE. IPAR(3)=0-RESTART
*         SUPPRESSED. IPAR(3)=1-RESTART PERFORMED.
*      IPAR(4)  INTERPOLATION IN LINE SEARCH. IPAR(4)=1-BISECTION.
*         IPAR(4)=2-TWO POINT QUADRATIC INTERPOLATION. IPAR(4)=3-THREE
*         POINT QUADRATIC INTERPOLATION. IPAR(4)=4-THREE POINT CUBIC
*         INTERPOLATION.
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(7)=0-NO PRINT.
*         ABS(IPAR(7))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(7))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(7)>0-BASIC FINAL RESULTS. IPAR(7)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(7)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE FUNCTION FALUE.
*      RPAR(4)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(5)  TOLERANCE FOR A DESCENT DIRECTION.
*      RPAR(6)  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*      RPAR(7)  MAXIMUM STEPSIZE.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM PARTIAL DERIVATIVE.
*  II  IEXT  TYPE OF OBJECTIVE FUNCTION. IEXT<0-MAXIMUM OF POSITIVE
*         VALUES. IEXT=0-MAXIMUM OF ABSOLUTE VALUES. IEXT>0-MAXIMUM
*         OF NEGATIVE VALUES.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PMIN  RECURSIVE QUADRATIC PROGRAMMING METHOD WITH THE BFGS
*         VARIABLE METRIC UPDATE.
*
* EXTERNAL SUBROUTINES :
*  SE  FUN  CONPUTATION OF THE VALUE OF THE APPROXIMATED FUNCTION.
*         CALLING SEQUENCE: CALL FUN(NF,KA,X,FA) WHERE NF IS A NUMBER
*         OF VARIABLES, KA IS THE INDEX OF THE APPROXIMATED FUNCTION,
*         X(NF) IS A VECTOR OF VARIABLES AND FA IS THE VALUE OF THE
*         APPROXIMATED FUNCTION.
*  SE  DER  CONPUTATION OF THE GRADIENT OF THE APPROXIMATED FUNCTION.
*         CALLING SEQUENCE: CALL DER(NF,KA,X,GA) WHERE NF IS A NUMBER
*         OF VARIABLES, KA IS THE INDEX OF THE APPROXIMATED FUNCTION,
*         X(NF) IS A VECTOR OF VARIABLES AND GA(NF) IS THE GRADIENT OF
*         THE APPROXIMATED FUNCTION.
*
      SUBROUTINE PMINL(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,AF,IA,RA,
     +                 IPAR,RPAR,F,GMAX,IEXT,ITERM)
*
*     POINTERS FOR AUXILIARY ARRAYS
*
C     .. Scalar Arguments ..
      DOUBLE PRECISION F,GMAX
      INTEGER IEXT,ITERM,NA,NB,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),CF(*),CG(*),CL(*),CU(*),RA(*),RPAR(7),X(*),
     +                 XL(*),XU(*)
      INTEGER IA(*),IC(*),IPAR(7),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAFD,LAFO,LAG,LAR,LAZ,LCFD,LG,LGA,LGO,LH,LIA,LIAA,LS,LXO
C     ..
C     .. External Subroutines ..
      EXTERNAL PMIN
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      LCFD = 1
      LAFO = LCFD + NC
      LAFD = LAFO + NA
      LGA = LAFD + NA
      LAG = LGA + NF
      LAR = LAG + NF*NA
      LAZ = LAR + (NF+1)* (NF+2)/2
      LG = LAZ + NF + 1
      LH = LG + NF + 1
      LS = LH + NF* (NF+1)/2
      LXO = LS + NF + 1
      LGO = LXO + NF
      LIA = 1
      LIAA = LIA + NA
      CALL PMIN(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,RA,AF,IA,RA(LAFO),
     +          RA(LAFD),RA(LGA),RA(LAG),IA(LIAA),RA(LAR),RA(LAZ),
     +          RA(LG),RA(LH),RA(LS),RA(LXO),RA(LGO),RPAR(1),RPAR(2),
     +          RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),GMAX,F,IEXT,
     +          IPAR(1),IPAR(2),IPAR(3),IPAR(4),IPAR(5),IPAR(6),IPAR(7),
     +          ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PMIN               ALL SYSTEMS                   97/01/22
* PURPOSE :
* GENERAL SUBROUTINE FOR MINIMAX OPTIMIZATION WITH SIMPLE BOUNDS
* AND GENERAL LINEAR CONSTRAINTS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  II  NB  CHOICE OF SIMPLE BOUNDS. NB=0-SIMPLE BOUNDS SUPPRESSED.
*         NB>0-SIMPLE BOUNDS ACCEPTED.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS. IX(I)=0-VARIABLE
*         X(I) IS UNBOUNDED. IX(I)=1-LOVER BOUND XL(I).LE.X(I).
*         IX(I)=2-UPPER BOUND X(I).LE.XU(I). IX(I)=3-TWO SIDE BOUND
*         XL(I).LE.X(I).LE.XU(I). IX(I)=5-VARIABLE X(I) IS FIXED.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RO  CF(NC)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*         IC(KC)=0-CONSTRAINT CF(KC) IS NOT USED. IC(KC)=1-LOVER
*         CONSTRAINT CL(KC).LE.CF(KC). IC(KC)=2-UPPER CONSTRAINT
*         CF(KC).LE.CU(KC). IC(KC)=3-TWO SIDE CONSTRAINT
*         CL(KC).LE.CF(KC).LE.CU(KC). IC(KC)=5-EQUALITY CONSTRAINT
*         CF(KC).EQ.CL(KC).
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RA  CFD(NA)  VECTOR CONTAINING INCREMENTS OF THE CONSTRAINT
*         FUNCTIONS.
*  RO  AF(NA)  VECTOR CONTAINING VALUES OF THE APPROXIMATED
*         FUNCTIONS.
*  II  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  RA  AFO(NA)  VECTOR CONTAINING SAVED VALUES OF THE APPROXIMATED
*         FUNCTIONS.
*  RA  AFD(NA)  VECTOR CONTAINING INCREMENTS OF THE APPROXIMATED
*         FUNCTIONS.
*  RA  GA(NF)  GRADIENT OF THE SELECTED APPROXIMATED FUNCTION.
*  RO  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE GRADIENTS OF THE
*         APPROXIMATED FUNCTIONS.
*  IO  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RO  AR((NF+1)*(NF+2)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RO  AZ(NF+1)  VECTOR OF LAGRANGE MULTIPLIERS.
*  RO  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  RU  H(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OR INVERSION OF THE
*         HESSIAN MATRIX APPROXIMATION.
*  RO  S(NF+1)  DIRECTION VECTOR.
*  RU  XO(NF)  VECTORS OF VARIABLES DIFFERENCE.
*  RI  GO(NF)  GRADIENTS DIFFERENCE.
*  RI  TOLX  TOLERANCE FOR CHANGE OF VARIABLES.
*  RI  TOLF  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*  RI  TOLB  TOLERANCE FOR THE FUNCTION FALUE.
*  RI  TOLG  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RI  TOLD  TOLERANCE FOR A DESCENT DIRECTION.
*  RI  TOLS  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*  RI  XMAX  MAXIMUM STEPSIZE.
*  RO  GMAX  MAXIMUM PARTIAL DERIVATIVE.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*         FUNCTIONS.
*  II  IEXT  TYPE OF OBJECTIVE FUNCTION. IEXT<0-MAXIMUM OF POSITIVE
*         VALUES. IEXT=0-MAXIMUM OF ABSOLUTE VALUES. IEXT>0-MAXIMUM
*         OF NEGATIVE VALUES.
*  II  MET  SELECTION OF SELF SCALING. MET=1-SELF SCALING SUPPRESSED.
*         MET=2 INITIAL SELF SCALING. MET=3 CONTROLLED SELF SCALING.
*  II  MEC  CORRECTION IF THE NEGATIVE CURVATURE OCCURS.
*         MEC=1-CORRECTION SUPPRESSED. MEC=2-POWELL'S CORRECTION.
*  II  MER  RESTART AFTER UNSUCCESSFUL UPDATE. MER=0-RESTART
*         SUPPRESSED. MER=1-RESTART PERFORMED.
*  II  MES  INTERPOLATION METHOD SELECTION. MES=1-BISECTION. MES=2-TWO
*         POINT QUADRATIC INTERPOLATION. MES=3-THREE POINT QUADRATIC
*         INTERPOLATION. MES=4-THREE POINT CUBIC INTERPOLATION.
*  II  MIT  MAXIMUN NUMBER OF ITERATIONS.
*  II  MFV  MAXIMUN NUMBER OF FUNCTION EVALUATIONS.
*  II  IPRNT  PRINT SPECIFICATION. IPRNT=0-NO PRINT.
*         ABS(IPRNT)=1-PRINT OF FINAL RESULTS.
*         ABS(IPRNT)=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPRNT>0-BASIC FINAL RESULTS. IPRNT<0-EXTENDED FINAL
*         RESULTS.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PDDXQ1  DETERMINATION OF THE DESCENT DIRECTION.
*  S   PA1MX2  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION WHICH IS DEFINED AS A MAXIMUM OF THE
*         APPROXIMATED FUNCTIONS.
*  S   PS0LA2  LINE SEARCH USING ONLY FUNCTION VALUES.
*  S   PYTRFD  DETERMINATION OF DIFFERENCES FOR VARIABLE METRIC
*         UPDATES.
*  S   PUDBG1  VARIABLE METRIC UPDATE AFTER GILL-MURRAY DECOMPOSITION.
*  S   MXDSMI  SYMMETRIC MATRIX IS REPLACED BY THE UNIT MATRIX.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*  S   MXVCOP  COPYING OF A VECTOR.
*  RF  MXVMAX  L-INFINITY NORM OF A VECTOR.
*
* EXTERNAL SUBROUTINES :
*  SE  FUN  CONPUTATION OF THE VALUE OF THE APPROXIMATED FUNCTION.
*         CALLING SEQUENCE: CALL FUN(NF,KA,X,FA) WHERE NF IS A NUMBER
*         OF VARIABLES, KA IS THE INDEX OF THE APPROXIMATED FUNCTION,
*         X(NF) IS A VECTOR OF VARIABLES AND FA IS THE VALUE OF THE
*         APPROXIMATED FUNCTION.
*  SE  DER  CONPUTATION OF THE GRADIENT OF THE APPROXIMATED FUNCTION.
*         CALLING SEQUENCE: CALL DER(NF,KA,X,GA) WHERE NF IS A NUMBER
*         OF VARIABLES, KA IS THE INDEX OF THE APPROXIMATED FUNCTION,
*         X(NF) IS A VECTOR OF VARIABLES AND GA(NF) IS THE GRADIENT OF
*         THE APPROXIMATED FUNCTION.
*
* METHOD :
* RECURSIVE QUADRATIC PROGRAMMING METHOD WITH THE BFGS VARIABLE METRIC
* UPDATE.
*
      SUBROUTINE PMIN(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,CFD,AF,IA,
     +                AFO,AFD,GA,AG,IAA,AR,AZ,G,H,S,XO,GO,TOLX,TOLF,
     +                TOLB,TOLG,TOLD,TOLS,XMAX,GMAX,F,IEXT,MET,MEC,MER,
     +                MES,MIT,MFV,IPRNT,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION F,GMAX,TOLB,TOLD,TOLF,TOLG,TOLS,TOLX,XMAX
      INTEGER IEXT,IPRNT,ITERM,MEC,MER,MES,MET,MFV,MIT,NA,NB,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AFD(*),AFO(*),AG(*),AR(*),AZ(*),CF(*),
     +                 CFD(*),CG(*),CL(*),CU(*),G(*),GA(*),GO(*),H(*),
     +                 S(*),X(*),XL(*),XO(*),XU(*)
      INTEGER IA(*),IAA(*),IC(*),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION ALF1,ALF2,DMAX,EPS7,EPS9,ETA0,ETA2,ETA9,FA,FMAX,
     +                 FMIN,FO,GNORM,P,PO,R,RMAX,RMIN,RO,SNORM,TEMP,
     +                 UMAX,XNORM
      INTEGER I,IDECF,IREST,ITERD,ITERH,ITERL,ITERQ,ITERS,K,KA,KBC,KBF,
     +        KC,KD,KIT,LD,MRED,MTESF,MTESX,N,NTESF,NTESX
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDSMI,MXVCOP,MXVSET,PA1MX2,PDDXQ1,PLLPB2,PLNEWS,PS0LA2,
     +         PUDBG1,PYTRFD
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN,SQRT
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (ABS(IPRNT).GT.1) WRITE (6,FMT='(1X,''ENTRY TO PMIN :'')')
*
*     INITIATION
*
      KBF = 0
      KBC = 0
      IF (NB.GT.0) KBF = 2
      IF (NC.GT.0) KBC = 2
      NIT = 0
      NFV = 0
      NTESX = 0
      NTESF = 0
      MTESX = 2
      MTESF = 2
      ITERM = 0
      ITERS = 0
      ITERD = 0
      ITERQ = 0
      MRED = 20
      IREST = 1
      ITERS = 2
      NDECF = 0
      IDECF = 1
      ETA0 = 1.0D-15
      ETA2 = 1.0D-15
      ETA9 = 1.0D60
      EPS7 = 1.0D-10
      EPS9 = 1.0D-8
      ALF1 = 1.0D-10
      ALF2 = 1.0D10
      FMAX = 1.0D60
      FMIN = 0.0D0
      IF (IEXT.NE.0) FMIN = -FMAX
      IF (TOLX.LE.0.0D0) TOLX = 1.0D-8
      IF (TOLF.LE.0.0D0) TOLF = 1.0D-16
      IF (TOLG.LE.0.0D0) TOLG = 1.0D-6
      IF (TOLB.LE.0.0D0) TOLB = FMIN + 1.0D-16
      IF (TOLD.LE.0.0D0) TOLD = 1.0D-8
      IF (TOLS.LE.0.0D0) TOLS = 1.0D-4
      IF (XMAX.LE.0.0D0) XMAX = 1.0D3
      IF (MET.LE.0) MET = 3
      IF (MEC.LE.0) MEC = 1
      IF (MES.LE.0) MES = 1
      IF (MIT.LE.0) MIT = 1000
      IF (MFV.LE.0) MFV = 2000
      IF (NC.GT.0) EPS7 = 1.0D-8
      KD = 1
      LD = -1
      KIT = 0
*
*     INITIATION OF TYPES OF DEVIATIONS
*
      DO 10 KA = 1,NA
          IA(KA) = 3
          IF (IEXT.LT.0) IA(KA) = 2
          IF (IEXT.GT.0) IA(KA) = 1
   10 CONTINUE
*
*     INITIAL OPERATIONS WITH SIMPLE BOUNDS
*
      IF (KBF.GT.0) THEN
          DO 20 I = 1,NF
              IF ((IX(I).EQ.3.OR.IX(I).EQ.4) .AND. XU(I).LE.XL(I)) THEN
                  XU(I) = XL(I)
                  IX(I) = 5

              ELSE IF (IX(I).EQ.5 .OR. IX(I).EQ.6) THEN
                  XL(I) = X(I)
                  XU(I) = X(I)
                  IX(I) = 5
              END IF

              IF (IX(I).EQ.1 .OR. IX(I).EQ.3) X(I) = MAX(X(I),XL(I))
              IF (IX(I).EQ.2 .OR. IX(I).EQ.3) X(I) = MIN(X(I),XU(I))
   20     CONTINUE
      END IF
*
*     INITIAL OPERATIONS WITH GENERAL LINEAR CONSTRAINTS
*
      IF (KBC.GT.0) THEN
          K = 0
          DO 30 KC = 1,NC
              IF ((IC(KC).EQ.3.OR.IC(KC).EQ.4) .AND.
     +            CU(KC).LE.CL(KC)) THEN
                  CU(KC) = CL(KC)
                  IC(KC) = 5

              ELSE IF (IC(KC).EQ.5 .OR. IC(KC).EQ.6) THEN
                  CU(KC) = CL(KC)
                  IC(KC) = 5
              END IF

              CF(KC) = MXVDOT(NF,X,CG(K+1))
              K = K + NF
   30     CONTINUE
      END IF
*
*     DETERMINATION OF AN INITIAL FEASIBLE POINT
*
      IF (KBC.GT.0) THEN
          CALL MXVSET(NF,0.0D0,GO)
          CALL PLLPB2(NF,NC,X,IX,XO,XL,XU,CF,CFD,IC,IAA,CL,CU,CG,AR,AZ,
     +                GO,GO,S,1,KBF,KBC,ETA9,EPS7,EPS9,UMAX,GMAX,N,
     +                ITERL)

      ELSE IF (KBF.GT.0) THEN
          DO 40 I = 1,NF
              IF (IX(I).GE.5) IX(I) = -IX(I)
              IF (IX(I).LE.0) THEN

              ELSE IF ((IX(I).EQ.1.OR.IX(I).EQ.3) .AND.
     +                 X(I).LE.XL(I)) THEN
                  X(I) = XL(I)

              ELSE IF ((IX(I).EQ.2.OR.IX(I).EQ.3) .AND.
     +                 X(I).GE.XU(I)) THEN
                  X(I) = XU(I)
              END IF

              CALL PLNEWS(X,IX,XL,XU,EPS9,I,ITERL)
              IF (IX(I).GT.10) IX(I) = 10 - IX(I)
   40     CONTINUE
      END IF

      FO = FMIN
      GMAX = ETA9
      DMAX = ETA9
*
*     COMPUTATION OF THE VALUE AND THE GRADIENT OF THE OBJECTIVE
*     FUNCTION TOGETHER WITH THE VALUES AND THE GRADIENTS OF THE
*     APPROXIMATED FUNCTIONS
*
      CALL PA1MX2(NF,NA,X,F,FA,AF,GA,AG,G,KD,LD,IEXT)
   50 CONTINUE
      IF (ABS(IPRNT).GT.1) WRITE (6,FMT=
     +'(1X,''NIT='',I5,2X,''NFV='',I5,2X,''NFG='',I5,2X,       ''F ='',
     +D15.8,2X,''G ='',D11.4)') NIT,NFV,NFG,F,GMAX
*
*     START OF THE ITERATION WITH TESTS FOR TERMINATION.
*
      N = NF
      UMAX = 0.0D0
      IF (ITERM.LT.0) GO TO 90
      IF (ITERS.EQ.0) GO TO 60
      IF (NIT.LE.0) FO = F + MIN(SQRT(ABS(F)),ABS(F)/1.0D1)
      IF (F.LE.TOLB) THEN
          ITERM = 3
          GO TO 90

      END IF

      IF (KD.GT.0) THEN
          IF (GMAX.LE.TOLG .AND. UMAX.LE.TOLG) THEN
              ITERM = 4
              GO TO 90

          END IF

      END IF

      IF (DMAX.LE.TOLX) THEN
          ITERM = 1
          NTESX = NTESX + 1
          IF (NTESX.GE.MTESX) GO TO 90

      ELSE
          NTESX = 0
      END IF

      TEMP = ABS(FO-F)/MAX(ABS(F),1.0D0)
      IF (TEMP.LE.TOLF) THEN
          ITERM = 2
          NTESF = NTESF + 1
          IF (NTESF.GE.MTESF) GO TO 90

      ELSE
          NTESF = 0
      END IF

   60 IF (NIT.GE.MIT) THEN
          ITERM = 12
          GO TO 90

      END IF

      IF (NFV.GE.MFV) THEN
          ITERM = 11
          GO TO 90

      END IF

      ITERM = 0
      NIT = NIT + 1
   70 CONTINUE
      N = NF
*
*     RESTART
*
      IF (IREST.GT.0) THEN
          CALL MXDSMI(N,H)
          LD = MIN(LD,1)
          IDECF = -1
          IF (KIT.LT.NIT) THEN
              NRES = NRES + 1
              KIT = NIT

          ELSE
              ITERM = -10
              IF (ITERS.LT.0) ITERM = ITERS - 5
              GO TO 90

          END IF

      END IF
*
*     DIRECTION DETERMINATION USING A SPECIAL QUADRATIC PROGRAMMING
*     PROCEDURE
*
      CALL MXVCOP(NA,AF,AFO)
      CALL PDDXQ1(NF,NA,NC,X,IX,XL,XU,AF,AFD,IA,IAA,AG,AR,AZ,CF,IC,CL,
     +            CU,CG,G,H,S,F,KBF,KBC,IDECF,ETA0,ETA2,ETA9,EPS7,EPS9,
     +            TOLG,UMAX,GMAX,GNORM,SNORM,XNORM,N,ITERQ,ITERD,ITERM)
      IF (ITERQ.LT.0) THEN
          IREST = 1
          GO TO 70

      END IF

      IF (ITERD.LT.0) ITERM = ITERD
      IF (ITERM.NE.0) GO TO 90
*
*     TEST FOR SUFFICIENT DESCENT
*
      P = MXVDOT(NF,G,S)
      IREST = 1
      IF (SNORM.LE.0.0D0) THEN

      ELSE IF (P+TOLD*GNORM*SNORM.LE.0.0D0) THEN
          IREST = 0
      END IF

      IF (IREST.EQ.0) THEN
          NRED = 0
          RMIN = ALF1*GNORM/SNORM
          RMAX = MIN(ALF2*GNORM/SNORM,XMAX/SNORM)

      ELSE
          GO TO 70

      END IF
*
*     PREPARATION OF LINE SEARCH
*
      RO = 0.0D0
      FO = F
      PO = P
      CALL MXVCOP(NF,X,XO)
      CALL MXVCOP(NF,G,GO)
*
*     LINE SEARCH WITHOUT DIRECTIONAL DERIVATIVES
*
      CALL PS0LA2(NF,NA,X,XO,S,R,RO,F,FO,PO,RMIN,RMAX,FMIN,FMAX,FA,AF,
     +            GA,AG,G,KD,LD,IEXT,NIT,KIT,TOLS,MES,NRED,MRED,ITERS)
*
*     DECISION AFTER UNSUCCESSFUL LINE SEARCH
*
      IF (ITERS.LE.0) THEN
          R = 0.0D0
          F = FO
          P = PO
          CALL MXVCOP(NF,XO,X)
          CALL MXVCOP(NA,AFO,AF)
          IREST = 1
          LD = KD
          GO TO 70

      ELSE IF (KBC.GT.0) THEN
          K = 0
          DO 80 KC = 1,NC
              CF(KC) = MXVDOT(NF,X,CG(K+1))
              K = K + NF
   80     CONTINUE
      END IF
*
*     COMPUTATION OF THE VALUE AND THE GRADIENT OF THE OBJECTIVE
*     FUNCTION TOGETHER WITH THE VALUES AND THE GRADIENTS OF THE
*     APPROXIMATED FUNCTIONS
*
      IF (KD.GT.LD) THEN
          CALL PA1MX2(NF,NA,X,F,FA,AF,GA,AG,G,KD,LD,IEXT)
      END IF
*
*     PREPARATION OF VARIABLE METRIC UPDATE
*
      CALL PYTRFD(NF,NC,X,XO,IAA,AG,AZ,CG,G,GO,N,KD,LD,R,F,FO,P,PO,DMAX,
     +            ITERS)
*
*     VARIABLE METRIC UPDATE
*
      CALL PUDBG1(N,H,G,S,XO,GO,R,PO,NIT,KIT,ITERH,MET,MEC)
      IF (MER.GT.0 .AND. ITERH.GT.0) IREST = 1
*
*     END OF THE ITERATION
*
      GO TO 50

   90 IF (IPRNT.GT.1 .OR. IPRNT.LT.0) WRITE (6,
     +    FMT='(1X,''EXIT FROM PMIN :'')')
      IF (IPRNT.NE.0) WRITE (6,FMT=
     +'(1X,''NIT='',I5,2X,''NFV='',I5,2X,''NFG='',I5,2X,       ''F ='',
     +D15.8,2X,''G ='',D11.4,2X,''ITERM='',I3)') NIT,NFV,NFG,F,GMAX,
     +    ITERM
      IF (IPRNT.LT.0) WRITE (6,FMT='(1X,''X ='',5D15.7:/(4X,5D15.7))')
     +    (X(I),I=1,NF)
      RETURN

      END
************************************************************************
* SUBROUTINE PBUNU              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR UNCONSTRAINED NONSMOOTH OPTIMIZATION.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  IA  IA(NA+NF+1)  AUXILIARY ARRAY.
*  RA  RA(NF*(NF+1)/2+NF*(NA+9)+5*NA+4)  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  WEIGHT UPDATING METHOD SPECIFICATION.
*         IPAR(1)=1-QUADRATIC INTERPOLATION. IPAR(1)=2-LOCAL MINIMUM
*         LOCALIZATION. IPAR(1)=3-QUASI-NEWTON CONDITION.
*      IPAR(2)  INTERPOLATION IN LINE SEARCH. IPAR(2)=1-BISECTION.
*         IPAR(2)=2-TWO POINT QUADRATIC INTERPOLATION. IPAR(2)=3-THREE
*         POINT QUADRATIC INTERPOLATION. IPAR(2)=4-THREE POINT CUBIC
*         INTERPOLATION.
*      IPAR(3)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN RPAR(1).
*      IPAR(4)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN RPAR(2).
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(7)=0-NO PRINT.
*         ABS(IPAR(7))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(7))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(7)>0-BASIC FINAL RESULTS. IPAR(7)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(9)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE FUNCTION FALUE.
*      RPAR(4)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(5)  TOLERANCE FOR A DESCENT DIRECTION.
*      RPAR(6)  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*      RPAR(7)  TOLERANCE FOR DIRECTIONAL DERIVATIVE IN THE LINE SEARCH.
*      RPAR(8)  DISTANCE MEASURE PARAMETER.
*      RPAR(9)  MAXIMUM STEPSIZE.
*  RO  FP  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PBUN  PROXIMAL BUNDLE METHOD WITH LINE SEARCH WHICH USES A
*         SPECIAL QUADRATIC PROGRAMMING SUBALGORITHM.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*
      SUBROUTINE PBUNU(NF,NA,X,IA,RA,IPAR,RPAR,FP,GMAX,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION FP,GMAX
      INTEGER ITERM,NA,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION RA(*),RPAR(9),X(*)
      INTEGER IA(*),IPAR(7)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAF,LAFD,LAG,LAR,LAZ,LG,LGO,LGS,LH,LIA,LIAA,LS,LXO,LXS,NB,
     +        NC
C     ..
C     .. External Subroutines ..
      EXTERNAL PBUN
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (NA.LE.0) NA = NF + 3
      NB = 0
      NC = 0
*
*     POINTERS FOR AUXILIUARY ARRAYS
*
      LAF = 1
      LAFD = LAF + 4*NA
      LAG = LAFD + NA
      LAR = LAG + NF*NA
      LAZ = LAR + (NF+1)* (NF+2)/2
      LG = LAZ + NF + 1
      LH = LG + NF
      LS = LH + NF
      LXO = LS + NF + 1
      LGO = LXO + NF
      LXS = LGO + NF + 1
      LGS = LXS + NF
      LIA = 1
      LIAA = LIA + NA
      CALL PBUN(NF,NA,NB,NC,X,IA,RA,RA,RA,IA,RA,RA,RA,RA,RA(LAF),IA,
     +          RA(LAFD),RA(LAG),IA(LIAA),RA(LAR),RA(LAZ),RA(LG),RA(LH),
     +          RA(LS),RA(LXO),RA(LGO),RA(LXS),RA(LGS),RPAR(1),RPAR(2),
     +          RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),RPAR(8),RPAR(9),
     +          GMAX,FP,IPAR(1),IPAR(2),IPAR(3),IPAR(4),IPAR(5),IPAR(6),
     +          IPAR(7),ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PBUNS              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR NONSMOOTH OPTIMIZATION WITH SIMPLE
* BOUNDS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  II  NB  NUMBER OF SIMPLE BOUNDS. NB=0-SIMPLE BOUNDS SUPPRESSED.
*         NB=NF-SIMPLE BOUNDS ACCEPTED.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS. IX(I)=0-VARIABLE
*         X(I) IS UNBOUNDED. IX(I)=1-LOVER BOUND XL(I).LE.X(I).
*         IX(I)=2-UPPER BOUND X(I).LE.XU(I). IX(I)=3-TWO SIDE BOUND
*         XL(I).LE.X(I).LE.XU(I). IX(I)=5-VARIABLE X(I) IS FIXED.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  IA  IA(NA+NF+1)  AUXILIARY ARRAY.
*  RA  RA(NF*(NF+1)/2+NF*(NA+9)+5*NA+4)  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  WEIGHT UPDATING METHOD SPECIFICATION.
*         IPAR(1)=1-QUADRATIC INTERPOLATION. IPAR(1)=2-LOCAL MINIMUM
*         LOCALIZATION. IPAR(1)=3-QUASI-NEWTON CONDITION.
*      IPAR(2)  INTERPOLATION IN LINE SEARCH. IPAR(2)=1-BISECTION.
*         IPAR(2)=2-TWO POINT QUADRATIC INTERPOLATION. IPAR(2)=3-THREE
*         POINT QUADRATIC INTERPOLATION. IPAR(2)=4-THREE POINT CUBIC
*         INTERPOLATION.
*      IPAR(3)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN RPAR(1).
*      IPAR(4)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN RPAR(2).
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(7)=0-NO PRINT.
*         ABS(IPAR(7))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(7))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(7)>0-BASIC FINAL RESULTS. IPAR(7)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(9)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(4)  TOLERANCE FOR THE FUNCTION FALUE.
*      RPAR(5)  TOLERANCE FOR A DESCENT DIRECTION.
*      RPAR(6)  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*      RPAR(7)  TOLERANCE FOR DIRECTIONAL DERIVATIVE IN THE LINE SEARCH.
*      RPAR(8)  DISTANCE MEASURE PARAMETER.
*      RPAR(9)  MAXIMUM STEPSIZE.
*  RO  FP  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF AN ELEMENT OF THE LAGARANGIAN
*         FUNCTION.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PBUN  PROXIMAL BUNDLE METHOD WITH LINE SEARCH WHICH USES A
*         SPECIAL QUADRATIC PROGRAMMING SUBALGORITHM.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*
      SUBROUTINE PBUNS(NF,NA,NB,X,IX,XL,XU,IA,RA,IPAR,RPAR,FP,GMAX,
     +                 ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION FP,GMAX
      INTEGER ITERM,NA,NB,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION RA(*),RPAR(9),X(*),XL(*),XU(*)
      INTEGER IA(*),IPAR(7),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAF,LAFD,LAG,LAR,LAZ,LG,LGO,LGS,LH,LIA,LIAA,LS,LXO,LXS,NC
C     ..
C     .. External Subroutines ..
      EXTERNAL PBUN
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (NA.LE.0) NA = NF + 3
      NC = 0
*
*     POINTERS FOR AUXILIUARY ARRAYS
*
      LAF = 1
      LAFD = LAF + 4*NA
      LAG = LAFD + NA
      LAR = LAG + NF*NA
      LAZ = LAR + (NF+1)* (NF+2)/2
      LG = LAZ + NF + 1
      LH = LG + NF
      LS = LH + NF
      LXO = LS + NF + 1
      LGO = LXO + NF
      LXS = LGO + NF + 1
      LGS = LXS + NF
      LIA = 1
      LIAA = LIA + NA
      CALL PBUN(NF,NA,NB,NC,X,IX,XL,XU,RA,IA,RA,RA,RA,RA,RA(LAF),IA,
     +          RA(LAFD),RA(LAG),IA(LIAA),RA(LAR),RA(LAZ),RA(LG),RA(LH),
     +          RA(LS),RA(LXO),RA(LGO),RA(LXS),RA(LGS),RPAR(1),RPAR(2),
     +          RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),RPAR(8),RPAR(9),
     +          GMAX,FP,IPAR(1),IPAR(2),IPAR(3),IPAR(4),IPAR(5),IPAR(6),
     +          IPAR(7),ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PBUNL              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR NONSMOOTH OPTIMIZATION WITH SIMPLE
* BOUNDS AND GENERAL LINEAR CONSTRAINTS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  II  NB  NUMBER OF SIMPLE BOUNDS. NB=0-SIMPLE BOUNDS SUPPRESSED.
*         NB=NF-SIMPLE BOUNDS ACCEPTED.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS. IX(I)=0-VARIABLE
*         X(I) IS UNBOUNDED. IX(I)=1-LOVER BOUND XL(I).LE.X(I).
*         IX(I)=2-UPPER BOUND X(I).LE.XU(I). IX(I)=3-TWO SIDE BOUND
*         XL(I).LE.X(I).LE.XU(I). IX(I)=5-VARIABLE X(I) IS FIXED.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  CF(NC)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*         IC(KC)=0-CONSTRAINT CF(KC) IS NOT USED. IC(KC)=1-LOVER
*         CONSTRAINT CL(KC).LE.CF(KC). IC(KC)=2-UPPER CONSTRAINT
*         CF(KC).LE.CU(KC). IC(KC)=3-TWO SIDE CONSTRAINT
*         CL(KC).LE.CF(KC).LE.CU(KC). IC(KC)=5-EQUALITY CONSTRAINT
*         CF(KC).EQ.CL(KC).
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  IA  IA(NA+NF+1)  AUXILIARY ARRAY.
*  RA  RA(NF*(NF+1)/2+NF*(NA+9)+5*NA+4)  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  WEIGHT UPDATING METHOD SPECIFICATION.
*         IPAR(1)=1-QUADRATIC INTERPOLATION. IPAR(1)=2-LOCAL MINIMUM
*         LOCALIZATION. IPAR(1)=3-QUASI-NEWTON CONDITION.
*      IPAR(2)  INTERPOLATION IN LINE SEARCH. IPAR(2)=1-BISECTION.
*         IPAR(2)=2-TWO POINT QUADRATIC INTERPOLATION. IPAR(2)=3-THREE
*         POINT QUADRATIC INTERPOLATION. IPAR(2)=4-THREE POINT CUBIC
*         INTERPOLATION.
*      IPAR(3)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN RPAR(1).
*      IPAR(4)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN RPAR(2).
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(7)=0-NO PRINT.
*         ABS(IPAR(7))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(7))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(7)>0-BASIC FINAL RESULTS. IPAR(7)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(9)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE FUNCTION FALUE.
*      RPAR(4)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(5)  TOLERANCE FOR A DESCENT DIRECTION.
*      RPAR(6)  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*      RPAR(7)  TOLERANCE FOR DIRECTIONAL DERIVATIVE IN THE LINE SEARCH.
*      RPAR(8)  DISTANCE MEASURE PARAMETER.
*      RPAR(9)  MAXIMUM STEPSIZE.
*  RO  FP  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF AN ELEMENT OF THE LAGARANGIAN
*         FUNCTION.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PBUN  PROXIMAL BUNDLE METHOD WITH LINE SEARCH WHICH USES A
*         SPECIAL QUADRATIC PROGRAMMING SUBALGORITHM.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*
      SUBROUTINE PBUNL(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,IA,RA,IPAR,
     +                 RPAR,FP,GMAX,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION FP,GMAX
      INTEGER ITERM,NA,NB,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CG(*),CL(*),CU(*),RA(*),RPAR(9),X(*),XL(*),
     +                 XU(*)
      INTEGER IA(*),IC(*),IPAR(7),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAF,LAFD,LAG,LAR,LAZ,LCFD,LG,LGO,LGS,LH,LIA,LIAA,LS,LXO,
     +        LXS
C     ..
C     .. External Subroutines ..
      EXTERNAL PBUN
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (NA.LE.0) NA = NF + 3
*
*     POINTERS FOR AUXILIUARY ARRAYS
*
      LCFD = 1
      LAF = LCFD + NC
      LAFD = LAF + 4*NA
      LAG = LAFD + NA
      LAR = LAG + NF*NA
      LAZ = LAR + (NF+1)* (NF+2)/2
      LG = LAZ + NF + 1
      LH = LG + NF
      LS = LH + NF
      LXO = LS + NF + 1
      LGO = LXO + NF
      LXS = LGO + NF + 1
      LGS = LXS + NF
      LIA = 1
      LIAA = LIA + NA
      CALL PBUN(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,RA,RA(LAF),IA,
     +          RA(LAFD),RA(LAG),IA(LIAA),RA(LAR),RA(LAZ),RA(LG),RA(LH),
     +          RA(LS),RA(LXO),RA(LGO),RA(LXS),RA(LGS),RPAR(1),RPAR(2),
     +          RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),RPAR(8),RPAR(9),
     +          GMAX,FP,IPAR(1),IPAR(2),IPAR(3),IPAR(4),IPAR(5),IPAR(6),
     +          IPAR(7),ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PBUN               ALL SYSTEMS                   97/01/22
* PURPOSE :
* GENERAL SUBROUTINE FOR NONSMOOTH OPTIMIZATION WITH SIMPLE BOUNDS
* AND GENERAL LINEAR CONSTRAINTS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  II  NB  NUMBER OF SIMPLE BOUNDS. NB=0-SIMPLE BOUNDS SUPPRESSED.
*         NB>0-SIMPLE BOUNDS ACCEPTED.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RU  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS. IX(I)=0-VARIABLE
*         X(I) IS UNBOUNDED. IX(I)=1-LOWER BOUND XL(I).LE.X(I).
*         IX(I)=2-UPPER BOUND X(I).LE.XU(I). IX(I)=3-TWO SIDE BOUND
*         XL(I).LE.X(I).LE.XU(I). IX(I)=5-VARIABLE X(I) IS FIXED.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RO  CF(NC)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*         IC(KC)=0-CONSTRAINT CF(KC) IS NOT USED. IC(KC)=1-LOWER
*         CONSTRAINT CL(KC).LE.CF(KC). IC(KC)=2-UPPER CONSTRAINT
*         CF(KC).LE.CU(KC). IC(KC)=3-TWO SIDE CONSTRAINT
*         CL(KC).LE.CF(KC).LE.CU(KC). IC(KC)=5-EQUALITY CONSTRAINT
*         CF(KC).EQ.CL(KC).
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RA  AF(4*NA)  VECTOR OF BUNDLE VALUES.
*  IA  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  RA  AFD(NA)  VECTOR CONTAINING INCREMENTS OF BUNDLE FUNCTIONS.
*  RA  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE BUNDLE GRADIENTS.
*  IA  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RA  AR((NF+1)*(NF+2)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RA  AZ(NF+1)  VECTOR OF LAGRANGE MULTIPLIERS.
*  RA  G(NF)  SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RA  H(NF)  DIAGONAL MATRIX OF WEIGHT PARAMETERS.
*  RA  S(NF+1)  DIRECTION VECTOR.
*  RA  XO(NF)  INCREMENT VECTOR.
*  RA  GO(NF+1)  GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RA  XS(NF)  AUXILIARY VECTOR.
*  RA  GS(NF)  AUXILIARY VECTOR.
*  RI  TOLX  TOLERANCE FOR CHANGE OF VARIABLES.
*  RI  TOLF  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*  RI  TOLB  TOLERANCE FOR THE FUNCTION VALUE.
*  RI  TOLG  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RI  TOLD  TOLERANCE FOR A DESCENT DIRECTION.
*  RI  TOLS  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*  RI  TOLP  TOLERANCE FOR DIRECTIONAL DERIVATIVE IN THE LINE SEARCH.
*  RI  ETA  DISTANCE MEASURE PARAMETER.
*  RI  XMAX  MAXIMUM STEPSIZE.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  RO  FP  VALUE OF THE OBJECTIVE FUNCTION.
*  II  MET  WEIGHT UPDATING METHOD SPECIFICATION. MET=1-QUADRATIC
*         INTERPOLATION. MET=2-LOCAL MINIMUM LOCALIZATION.
*         MET=3-QUASI-NEWTON CONDITION.
*  II  MES  METHOD SELECTION. MES=1-BISECTION. MES=2-TWO POINT
*         QUADRATIC INTERPOLATION.
*  II  MTESX  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN TOLX.
*  II  MTESF  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN TOLF.
*  II  MIT  MAXIMUN NUMBER OF ITERATIONS.
*  II  MFV  MAXIMUN NUMBER OF FUNCTION EVALUATIONS.
*  II  IPRNT  PRINT SPECIFICATION. IPRNT=0-NO PRINT.
*         ABS(IPRNT)=1-PRINT OF FINAL RESULTS.
*         ABS(IPRNT)=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPRNT>0-BASIC FINAL RESULTS. IPRNT<0-EXTENDED FINAL
*         RESULTS.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PDDBQ1  DETERMINATION OF THE DESCENT DIRECTION.
*  S   PS1L05  LINE SEARCH USING FUNCTION VALUES AND DERIVATIVES.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVDIF  DIFFERENCE OF TWO VECTORS.
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIABLES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*
* METHOD :
* PROXIMAL BUNDLE METHOD WITH LINE SEARCH WHICH USES A SPECIAL
* QUADRATIC PROGRAMMING SUBALGORITHM.
*
      SUBROUTINE PBUN(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,CFD,AF,IA,
     +                AFD,AG,IAA,AR,AZ,G,H,S,XO,GO,XS,GS,TOLX,TOLF,TOLB,
     +                TOLG,TOLD,TOLS,TOLP,ETA,XMAX,GMAX,FP,MET,MES,
     +                MTESX,MTESF,MIT,MFV,IPRNT,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ETA,FP,GMAX,TOLB,TOLD,TOLF,TOLG,TOLP,TOLS,TOLX,
     +                 XMAX
      INTEGER IPRNT,ITERM,MES,MET,MFV,MIT,MTESF,MTESX,NA,NB,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AFD(*),AG(*),AR(*),AZ(*),CF(*),CFD(*),
     +                 CG(*),CL(*),CU(*),G(*),GO(*),GS(*),H(*),S(*),
     +                 X(*),XL(*),XO(*),XS(*),XU(*)
      INTEGER IA(*),IAA(*),IC(*),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION ALF2,DMAX,EPS7,EPS9,ETA0,ETA2,ETA9,F,FMAX,FMIN,
     +                 FO,FUB,GNORM,P,PO,PP,R,RMAX,RMIN,RP,SNORM,TEMP,
     +                 TO,UMAX,XNORM
      INTEGER I,IDECF,IREST,ITERD,ITERL,ITERQ,ITERS,K,KBC,KBF,KC,KIT,
     +        MAL,MES2,MOS,N,NTESF,NTESX
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
C     .. External Subroutines ..
      EXTERNAL FUNDER,MXVCOP,MXVDIF,MXVDIR,MXVSET,PDDBQ1,PLLPB2,PLNEWS,
     +         PS1L05
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN,SQRT
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (ABS(IPRNT).GT.1) WRITE (6,FMT='(1X,''ENTRY TO PBUN :'')')
*
*     INITIATION
*
      KBF = 0
      KBC = 0
      IF (NB.GT.0) KBF = 2
      IF (NC.GT.0) KBC = 2
      NIT = 0
      NFV = 0
      NFG = 0
      NTESX = 0
      NTESF = 0
      ITERM = 0
      ITERD = 0
      ITERQ = 0
      IREST = 0
      ITERS = 2
      NDECF = 0
      IDECF = 10
      ETA0 = 1.0D-15
      ETA2 = 1.0D-15
      ETA9 = 1.0D60
      EPS7 = 1.0D-10
      EPS9 = 1.0D-8
      ALF2 = 1.0D10
      FMAX = 1.0D60
      FMIN = -FMAX
      IF (TOLX.LE.0.0D0) TOLX = 1.0D-8
      IF (TOLF.LE.0.0D0) TOLF = 1.0D-8
      IF (TOLB.EQ.0.0D0) TOLB = FMIN + 1.0D-16
      IF (TOLG.LE.0.0D0) TOLG = 1.0D-6
      IF (TOLD.LE.0.0D0) TOLD = 1.0D-4
      IF (TOLS.LE.0.0D0) TOLS = 1.0D-2
      IF (TOLP.LE.0.0D0) TOLP = 5.0D-1
      IF (XMAX.LE.0.0D0) XMAX = 1.0D3
      IF (MET.LE.0) MET = 1
      IF (MES.LE.0) MES = 4
      IF (MTESX.LE.0) MTESX = 20
      IF (MTESF.LE.0) MTESF = 2
      IF (MIT.LE.0) MIT = 1000
      IF (MFV.LE.0) MFV = 2000
      MOS = 1
      MES2 = 1
      IF (MET.EQ.2) MES2 = 2
      IF (MET.EQ.3) MOS = 2
      KIT = 0
      MAL = 0
*
*     INITIAL OPERATIONS WITH SIMPLE BOUNDS
*
      IF (KBF.GT.0) THEN
          DO 10 I = 1,NF
              IF ((IX(I).EQ.3.OR.IX(I).EQ.4) .AND. XU(I).LE.XL(I)) THEN
                  XU(I) = XL(I)
                  IX(I) = 5

              ELSE IF (IX(I).EQ.5 .OR. IX(I).EQ.6) THEN
                  XL(I) = X(I)
                  XU(I) = X(I)
                  IX(I) = 5
              END IF

              IF (IX(I).EQ.1 .OR. IX(I).EQ.3) X(I) = MAX(X(I),XL(I))
              IF (IX(I).EQ.2 .OR. IX(I).EQ.3) X(I) = MIN(X(I),XU(I))
   10     CONTINUE
      END IF
*
*     INITIAL OPERATIONS WITH GENERAL LINEAR CONSTRAINTS
*
      IF (KBC.GT.0) THEN
          K = 0
          DO 20 KC = 1,NC
              IF ((IC(KC).EQ.3.OR.IC(KC).EQ.4) .AND.
     +            CU(KC).LE.CL(KC)) THEN
                  CU(KC) = CL(KC)
                  IC(KC) = 5

              ELSE IF (IC(KC).EQ.5 .OR. IC(KC).EQ.6) THEN
                  CU(KC) = CL(KC)
                  IC(KC) = 5
              END IF

              CF(KC) = MXVDOT(NF,X,CG(K+1))
              K = K + NF
   20     CONTINUE
      END IF
*
*     DETERMINATION OF AN INITIAL FEASIBLE POINT
*
      IF (KBC.GT.0) THEN
          CALL MXVSET(NF,0.0D0,GO)
          CALL PLLPB2(NF,NC,X,IX,XO,XL,XU,CF,CFD,IC,IAA,CL,CU,CG,AR,AZ,
     +                GO,GO,S,1,KBF,KBC,ETA9,EPS7,EPS9,UMAX,GMAX,N,
     +                ITERL)

      ELSE IF (KBF.GT.0) THEN
          DO 30 I = 1,NF
              IF (IX(I).GE.5) IX(I) = -IX(I)
              IF (IX(I).LE.0) THEN

              ELSE IF ((IX(I).EQ.1.OR.IX(I).EQ.3) .AND.
     +                 X(I).LE.XL(I)) THEN
                  X(I) = XL(I)

              ELSE IF ((IX(I).EQ.2.OR.IX(I).EQ.3) .AND.
     +                 X(I).GE.XU(I)) THEN
                  X(I) = XU(I)
              END IF

              CALL PLNEWS(X,IX,XL,XU,EPS9,I,ITERL)
              IF (IX(I).GT.10) IX(I) = 10 - IX(I)
   30     CONTINUE
      END IF

      FO = FMIN
      FUB = FMAX
      GMAX = ETA9
      DMAX = ETA9
*
*     COMPUTATION OF THE VALUE AND THE GRADIENT OF THE OBJECTIVE
*     FUNCTION
*
      CALL FUNDER(NF,X,F,G)
      NFV = NFV + 1
      NFG = NFG + 1
   40 CONTINUE
      IF (ABS(IPRNT).GT.1) WRITE (6,FMT=
     +'(1X,''NIT='',I5,2X,''NFV='',I5,2X,''NFG='',I5,2X,       ''F ='',
     +D15.8,2X,''G ='',D11.4)') NIT,NFV,NFG,FP,GMAX
*
*     START OF THE ITERATION WITH TESTS FOR TERMINATION.
*
      N = NF
      UMAX = 0.0D0
      IF (ITERM.LT.0) GO TO 90
      IF (ITERS.EQ.0) GO TO 50
      IF (NIT.LE.0) FO = F + MIN(SQRT(ABS(F)),ABS(F)/1.0D1)
      IF (F.LE.TOLB) THEN
          ITERM = 3
          GO TO 90

      END IF

      IF (DMAX.LE.TOLX) THEN
          ITERM = 1
          NTESX = NTESX + 1
          IF (NTESX.GE.MTESX) GO TO 90

      ELSE
          NTESX = 0
      END IF

      TEMP = ABS(FO-FUB)/MAX(ABS(FUB),1.0D0)
      IF (TEMP.LE.TOLF) THEN
          ITERM = 2
          NTESF = NTESF + 1
          IF (NTESF.GE.MTESF) GO TO 90

      ELSE
          NTESF = 0
      END IF

   50 IF (NIT.GE.MIT) THEN
          ITERM = 12
          GO TO 90

      END IF

      IF (NFV.GE.MFV) THEN
          ITERM = 11
          GO TO 90

      END IF

      ITERM = 0
      NIT = NIT + 1
   60 CONTINUE
*
*     RESTART
*
      IF (IREST.GT.0) THEN
          IF (KIT.LT.NIT) THEN
              NRES = NRES + 1
              KIT = NIT

          ELSE
              ITERM = -10
              IF (ITERS.LT.0) ITERM = ITERS - 5
              GO TO 90

          END IF

      END IF
*
*     DIRECTION DETERMINATION USING A SPECIAL QUADRATIC PROGRAMMING
*     PROCEDURE AND THE BUNDLE UPDATE
*
      CALL PDDBQ1(NF,NA,NC,X,IX,XL,XU,F,FO,FP,FUB,AF,AFD,IA,IAA,AG,AR,
     +            AZ,CF,IC,CL,CU,CG,G,H,S,XO,GO,XS,GS,P,R,RP,TO,KBF,KBC,
     +            IDECF,ETA0,ETA2,ETA9,EPS7,EPS9,TOLF,TOLG,ETA,UMAX,
     +            GMAX,GNORM,SNORM,XNORM,N,MAL,NIT,MOS,NTESF,NTESX,
     +            ITERQ,ITERD,ITERS,ITERM)
      IF (ITERD.LT.0) ITERM = ITERD
      IF (ITERM.NE.0) GO TO 90
*
*     TEST FOR SUFFICIENT DESCENT
*
      P = MXVDOT(NF,GO,S)
      IREST = 1
      IF (SNORM.LE.0.0D0) THEN

      ELSE IF (P+TOLD*GNORM*SNORM.LE.0.0D0) THEN
          IREST = 0
      END IF

      IF (IREST.EQ.0) THEN
          NRED = 0
          RMIN = 1.0D-3
          RMAX = MIN(ALF2*GNORM/SNORM,XMAX/SNORM)

      ELSE
          GO TO 60

      END IF
*
*     PREPARATION OF LINE SEARCH
*
      FP = FO
      FO = F
      PO = P
      PP = MXVDOT(NF,G,S)
      CALL MXVCOP(NF,X,XO)
      CALL MXVCOP(NF,G,GO)
*
*     LINE SEARCH WITH DIRECTIONAL DERIVATIVES WHICH ALLOWS NULL STEPS
*
      CALL PS1L05(NF,X,XO,S,R,RP,F,FO,FP,P,PO,PP,TO,G,SNORM,RMIN,RMAX,
     +            FMIN,FMAX,TOLS,TOLP,ETA,MES,MES2,ITERS)
      ITERD = 0
*
*     DECISION AFTER UNSUCCESSFUL LINE SEARCH
*
      IF (ITERS.LE.0) THEN
          R = 0.0D0
          F = FO
          P = PO
          CALL MXVCOP(NF,XO,X)

      ELSE
          IF (ITERS.GE.9) CALL MXVDIR(NF,RP,S,XO,X)
          CALL MXVDIF(NF,X,XO,XO)
          IF (KBC.GT.0) THEN
              K = 0
              DO 70 KC = 1,NC
                  CF(KC) = MXVDOT(NF,X,CG(K+1))
                  K = K + NF
   70         CONTINUE
          END IF

      END IF
*
*     COMPUTATION OF VALUES FOR TERMINATION CRITERIA
*
      DMAX = 0.0D0
      DO 80 I = 1,NF
          DMAX = MAX(DMAX,ABS(XO(I))/MAX(ABS(X(I)),1.0D0))
   80 CONTINUE
      TEMP = FUB
      FUB = F
      IF (ITERS.GE.9) FUB = FUB - (R-RP)*P
      FUB = (FUB+TEMP)*0.5D0
*
*     END OF THE ITERATION
*
      GO TO 40

   90 IF (IPRNT.GT.1 .OR. IPRNT.LT.0) WRITE (6,
     +    FMT='(1X,''EXIT FROM PBUN :'')')
      IF (IPRNT.NE.0) WRITE (6,FMT=
     +'(1X,''NIT='',I5,2X,''NFV='',I5,2X,''NFG='',I5,2X,       ''F ='',
     +D15.8,2X,''G ='',D11.4,2X,''ITERM='',I3)') NIT,NFV,NFG,FP,GMAX,
     +    ITERM
      IF (IPRNT.LT.0) WRITE (6,FMT='(1X,''X ='',5D15.7:/(4X,5D15.7))')
     +    (X(I),I=1,NF)
      RETURN

      END
************************************************************************
* SUBROUTINE PNEWU              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR UNCONSTRAINED NONSMOOTH OPTIMIZATION.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  IA  IA(NA+NF+1)  AUXILIARY ARRAY.
*  RA  RA((NA+3)*NF*(NF+1)/2+(NA+6)*NF+6*NA+4)  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  EXPONENT FOR DISTANCE MEASURE.
*      IPAR(2)  INTERPOLATION IN LINE SEARCH. IPAR(2)=1-BISECTION.
*         IPAR(2)=2-TWO POINT QUADRATIC INTERPOLATION. IPAR(2)=3-THREE
*         POINT QUADRATIC INTERPOLATION. IPAR(2)=4-THREE POINT CUBIC
*         INTERPOLATION.
*      IPAR(3)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN RPAR(1).
*      IPAR(4)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN RPAR(2).
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(7)=0-NO PRINT.
*         ABS(IPAR(7))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(7))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(7)>0-BASIC FINAL RESULTS. IPAR(7)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(9)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE FUNCTION FALUE.
*      RPAR(4)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(5)  TOLERANCE FOR A DESCENT DIRECTION.
*      RPAR(6)  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*      RPAR(7)  TOLERANCE FOR DIRECTIONAL DERIVATIVE IN THE LINE SEARCH.
*      RPAR(8)  DISTANCE MEASURE PARAMETER.
*      RPAR(9)  MAXIMUM STEPSIZE.
*  RO  FP  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF AN ELEMENT OF THE LAGARANGIAN
*         FUNCTION.
*  II  IHES  A WAY FOR COMPUTING SECOND DERIVATIVES. IHES=0-NUMERICAL
*         COMPUTATION. IHES>0-ANALYTICAL COMPUTATION.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PNEW  BUNDLE NEWTON METHOD WITH LINE SEARCH WHICH USES A SPECIAL
*         QUADRATIC PROGRAMMING SUBALGORITHM.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*  SE  HES  COMPUTATION OF THE HESSIAN MATRIX OF THE OBJECTIVE
*         FUNCTION. CALLING SEQUENCE: CALL HES(NF,X,H) WHERE
*         NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES AND H(NF*(NF+1)/2) IS THE UPPER RIGHT CORNER
*         OF THE SYMMETRIC HESSIAN MATRIX STORED BY COLUMNS. THIS
*         SUBTOUTINE IS USED ONLY IF IHES>0, BUT IT MUST BE
*         INCLUDED AS AN EMPTY SUBROUTINE IF IHES=0.
*
      SUBROUTINE PNEWU(NF,NA,X,IA,RA,IPAR,RPAR,FP,GMAX,IHES,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION FP,GMAX
      INTEGER IHES,ITERM,NA,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION RA(*),RPAR(9),X(*)
      INTEGER IA(*),IPAR(7)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAF,LAFD,LAG,LAH,LAR,LAZ,LG,LGO,LH,LHF,LIA,LIAA,LS,LSO,
     +        LXO,NB,NC
C     ..
C     .. External Subroutines ..
      EXTERNAL PNEW
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (NA.LE.0) NA = NF + 3
      NB = 0
      NC = 0
*
*     POINTERS FOR AUXILIUARY ARRAYS
*
      LAF = 1
      LAFD = LAF + 5*NA
      LAG = LAFD + NA
      LAR = LAG + NF*NA
      LAZ = LAR + (NF+1)* (NF+2)/2
      LG = LAZ + NF + 1
      LH = LG + NF
      LHF = LH + NF* (NF+1)/2
      LAH = LHF + NF* (NF+1)/2
      LS = LAH + NA*NF* (NF+1)/2
      LSO = LS + NF + 1
      LXO = LSO + NF
      LGO = LXO + NF
      LIA = 1
      LIAA = LIA + NA
      CALL PNEW(NF,NA,NB,NC,X,IA,RA,RA,RA,IA,RA,RA,RA,RA,RA(LAF),IA,
     +          RA(LAFD),RA(LAG),IA(LIAA),RA(LAR),RA(LAZ),RA(LG),RA(LH),
     +          RA(LHF),RA(LAH),RA(LS),RA(LSO),RA(LXO),RA(LGO),RPAR(1),
     +          RPAR(2),RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),RPAR(8),
     +          RPAR(9),GMAX,FP,IPAR(1),IPAR(2),IPAR(3),IPAR(4),IPAR(5),
     +          IPAR(6),IPAR(7),IHES,ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PNEWS              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR NONSMOOTH OPTIMIZATION WITH SIMPLE
* BOUNDS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  II  NB  NUMBER OF SIMPLE BOUNDS. NB=0-SIMPLE BOUNDS SUPPRESSED.
*         NB=NF-SIMPLE BOUNDS ACCEPTED.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS. IX(I)=0-VARIABLE
*         X(I) IS UNBOUNDED. IX(I)=1-LOVER BOUND XL(I).LE.X(I).
*         IX(I)=2-UPPER BOUND X(I).LE.XU(I). IX(I)=3-TWO SIDE BOUND
*         XL(I).LE.X(I).LE.XU(I). IX(I)=5-VARIABLE X(I) IS FIXED.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  IA  IA(NA+NF+1)  AUXILIARY ARRAY.
*  RA  RA((NA+3)*NF*(NF+1)/2+(NA+6)*NF+6*NA+4)  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  EXPONENT FOR DISTANCE MEASURE.
*      IPAR(2)  INTERPOLATION IN LINE SEARCH. IPAR(2)=1-BISECTION.
*         IPAR(2)=2-TWO POINT QUADRATIC INTERPOLATION. IPAR(2)=3-THREE
*         POINT QUADRATIC INTERPOLATION. IPAR(2)=4-THREE POINT CUBIC
*         INTERPOLATION.
*      IPAR(3)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN RPAR(1).
*      IPAR(4)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN RPAR(2).
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(7)=0-NO PRINT.
*         ABS(IPAR(7))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(7))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(7)>0-BASIC FINAL RESULTS. IPAR(7)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(9)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(4)  TOLERANCE FOR THE FUNCTION FALUE.
*      RPAR(5)  TOLERANCE FOR A DESCENT DIRECTION.
*      RPAR(6)  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*      RPAR(7)  TOLERANCE FOR DIRECTIONAL DERIVATIVE IN THE LINE SEARCH.
*      RPAR(8)  DISTANCE MEASURE PARAMETER.
*      RPAR(9)  MAXIMUM STEPSIZE.
*  RO  FP  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF AN ELEMENT OF THE LAGARANGIAN
*         FUNCTION.
*  II  IHES  A WAY FOR COMPUTING SECOND DERIVATIVES. IHES=0-NUMERICAL
*         COMPUTATION. IHES>0-ANALYTICAL COMPUTATION.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PNEW  BUNDLE NEWTON METHOD WITH LINE SEARCH WHICH USES A SPECIAL
*         QUADRATIC PROGRAMMING SUBALGORITHM.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*  SE  HES  COMPUTATION OF THE HESSIAN MATRIX OF THE OBJECTIVE
*         FUNCTION. CALLING SEQUENCE: CALL HES(NF,X,H) WHERE
*         NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES AND H(NF*(NF+1)/2) IS THE UPPER RIGHT CORNER
*         OF THE SYMMETRIC HESSIAN MATRIX STORED BY COLUMNS. THIS
*         SUBTOUTINE IS USED ONLY IF IHES>0, BUT IT MUST BE
*         INCLUDED AS AN EMPTY SUBROUTINE IF IHES=0.
*
      SUBROUTINE PNEWS(NF,NA,NB,X,IX,XL,XU,IA,RA,IPAR,RPAR,FP,GMAX,IHES,
     +                 ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION FP,GMAX
      INTEGER IHES,ITERM,NA,NB,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION RA(*),RPAR(9),X(*),XL(*),XU(*)
      INTEGER IA(*),IPAR(7),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAF,LAFD,LAG,LAH,LAR,LAZ,LG,LGO,LH,LHF,LIA,LIAA,LS,LSO,
     +        LXO,NC
C     ..
C     .. External Subroutines ..
      EXTERNAL PNEW
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (NA.LE.0) NA = NF + 3
      NC = 0
*
*     POINTERS FOR AUXILIUARY ARRAYS
*
      LAF = 1
      LAFD = LAF + 5*NA
      LAG = LAFD + NA
      LAR = LAG + NF*NA
      LAZ = LAR + (NF+1)* (NF+2)/2
      LG = LAZ + NF + 1
      LH = LG + NF
      LHF = LH + NF* (NF+1)/2
      LAH = LHF + NF* (NF+1)/2
      LS = LAH + NA*NF* (NF+1)/2
      LSO = LS + NF + 1
      LXO = LSO + NF
      LGO = LXO + NF
      LIA = 1
      LIAA = LIA + NA
      CALL PNEW(NF,NA,NB,NC,X,IX,XL,XU,RA,IA,RA,RA,RA,RA,RA(LAF),IA,
     +          RA(LAFD),RA(LAG),IA(LIAA),RA(LAR),RA(LAZ),RA(LG),RA(LH),
     +          RA(LHF),RA(LAH),RA(LS),RA(LSO),RA(LXO),RA(LGO),RPAR(1),
     +          RPAR(2),RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),RPAR(8),
     +          RPAR(9),GMAX,FP,IPAR(1),IPAR(2),IPAR(3),IPAR(4),IPAR(5),
     +          IPAR(6),IPAR(7),IHES,ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PNEWL              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR NONSMOOTH OPTIMIZATION WITH SIMPLE
* BOUNDS AND GENERAL LINEAR CONSTRAINTS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  II  NB  NUMBER OF SIMPLE BOUNDS. NB=0-SIMPLE BOUNDS SUPPRESSED.
*         NB=NF-SIMPLE BOUNDS ACCEPTED.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS. IX(I)=0-VARIABLE
*         X(I) IS UNBOUNDED. IX(I)=1-LOVER BOUND XL(I).LE.X(I).
*         IX(I)=2-UPPER BOUND X(I).LE.XU(I). IX(I)=3-TWO SIDE BOUND
*         XL(I).LE.X(I).LE.XU(I). IX(I)=5-VARIABLE X(I) IS FIXED.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  CF(NC)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*         IC(KC)=0-CONSTRAINT CF(KC) IS NOT USED. IC(KC)=1-LOVER
*         CONSTRAINT CL(KC).LE.CF(KC). IC(KC)=2-UPPER CONSTRAINT
*         CF(KC).LE.CU(KC). IC(KC)=3-TWO SIDE CONSTRAINT
*         CL(KC).LE.CF(KC).LE.CU(KC). IC(KC)=5-EQUALITY CONSTRAINT
*         CF(KC).EQ.CL(KC).
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  IA  IA(NA+NF+1)  AUXILIARY ARRAY.
*  RA  RA((NA+3)*NF*(NF+1)/2+(NA+6)*NF+6*NA+4)  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  EXPONENT FOR DISTANCE MEASURE.
*      IPAR(2)  INTERPOLATION IN LINE SEARCH. IPAR(2)=1-BISECTION.
*         IPAR(2)=2-TWO POINT QUADRATIC INTERPOLATION. IPAR(2)=3-THREE
*         POINT QUADRATIC INTERPOLATION. IPAR(2)=4-THREE POINT CUBIC
*         INTERPOLATION.
*      IPAR(3)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN RPAR(1).
*      IPAR(4)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN RPAR(2).
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(7)=0-NO PRINT.
*         ABS(IPAR(7))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(7))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(7)>0-BASIC FINAL RESULTS. IPAR(7)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(9)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE FUNCTION FALUE.
*      RPAR(4)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(5)  TOLERANCE FOR A DESCENT DIRECTION.
*      RPAR(6)  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*      RPAR(7)  TOLERANCE FOR DIRECTIONAL DERIVATIVE IN THE LINE SEARCH.
*      RPAR(8)  DISTANCE MEASURE PARAMETER.
*      RPAR(9)  MAXIMUM STEPSIZE.
*  RO  FP  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF AN ELEMENT OF THE LAGARANGIAN
*         FUNCTION.
*  II  IHES  A WAY FOR COMPUTING SECOND DERIVATIVES. IHES=0-NUMERICAL
*         COMPUTATION. IHES>0-ANALYTICAL COMPUTATION.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PNEW  BUNDLE NEWTON METHOD WITH LINE SEARCH WHICH USES A SPECIAL
*         QUADRATIC PROGRAMMING SUBALGORITHM.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*  SE  HES  COMPUTATION OF THE HESSIAN MATRIX OF THE OBJECTIVE
*         FUNCTION. CALLING SEQUENCE: CALL HES(NF,X,H) WHERE
*         NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES AND H(NF*(NF+1)/2) IS THE UPPER RIGHT CORNER
*         OF THE SYMMETRIC HESSIAN MATRIX STORED BY COLUMNS. THIS
*         SUBTOUTINE IS USED ONLY IF IHES>0, BUT IT MUST BE
*         INCLUDED AS AN EMPTY SUBROUTINE IF IHES=0.
*
      SUBROUTINE PNEWL(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,IA,RA,IPAR,
     +                 RPAR,FP,GMAX,IHES,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION FP,GMAX
      INTEGER IHES,ITERM,NA,NB,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CG(*),CL(*),CU(*),RA(*),RPAR(9),X(*),XL(*),
     +                 XU(*)
      INTEGER IA(*),IC(*),IPAR(7),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAF,LAFD,LAG,LAH,LAR,LAZ,LCFD,LG,LGO,LH,LHF,LIA,LIAA,LS,
     +        LSO,LXO
C     ..
C     .. External Subroutines ..
      EXTERNAL PNEW
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (NA.LE.0) NA = NF + 3
*
*     POINTERS FOR AUXILIUARY ARRAYS
*
      LCFD = 1
      LAF = LCFD + 1
      LAFD = LAF + 5*NA
      LAG = LAFD + NA
      LAR = LAG + NF*NA
      LAZ = LAR + (NF+1)* (NF+2)/2
      LG = LAZ + NF + 1
      LH = LG + NF
      LHF = LH + NF* (NF+1)/2
      LAH = LHF + NF* (NF+1)/2
      LS = LAH + NA*NF* (NF+1)/2
      LSO = LS + NF + 1
      LXO = LSO + NF
      LGO = LXO + NF
      LIA = 1
      LIAA = LIA + NA
      CALL PNEW(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,RA,RA(LAF),IA,
     +          RA(LAFD),RA(LAG),IA(LIAA),RA(LAR),RA(LAZ),RA(LG),RA(LH),
     +          RA(LHF),RA(LAH),RA(LS),RA(LSO),RA(LXO),RA(LGO),RPAR(1),
     +          RPAR(2),RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),RPAR(8),
     +          RPAR(9),GMAX,FP,IPAR(1),IPAR(2),IPAR(3),IPAR(4),IPAR(5),
     +          IPAR(6),IPAR(7),IHES,ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PNEW               ALL SYSTEMS                   97/01/22
* PURPOSE :
* GENERAL SUBROUTINE FOR NONSMOOTH OPTIMIZATION WITH SIMPLE BOUNDS
* AND GENERAL LINEAR CONSTRAINTS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  II  NB  NUMBER OF SIMPLE BOUNDS. NB=0-SIMPLE BOUNDS SUPPRESSED.
*         NB>0-SIMPLE BOUNDS ACCEPTED.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RU  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS. IX(I)=0-VARIABLE
*         X(I) IS UNBOUNDED. IX(I)=1-LOWER BOUND XL(I).LE.X(I).
*         IX(I)=2-UPPER BOUND X(I).LE.XU(I). IX(I)=3-TWO SIDE BOUND
*         XL(I).LE.X(I).LE.XU(I). IX(I)=5-VARIABLE X(I) IS FIXED.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RO  CF(NC)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*         IC(KC)=0-CONSTRAINT CF(KC) IS NOT USED. IC(KC)=1-LOWER
*         CONSTRAINT CL(KC).LE.CF(KC). IC(KC)=2-UPPER CONSTRAINT
*         CF(KC).LE.CU(KC). IC(KC)=3-TWO SIDE CONSTRAINT
*         CL(KC).LE.CF(KC).LE.CU(KC). IC(KC)=5-EQUALITY CONSTRAINT
*         CF(KC).EQ.CL(KC).
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RA  AF(5*NA)  VECTOR OF BUNDLE VALUES.
*  IA  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  RA  AFD(NA)  VECTOR CONTAINING INCREMENTS OF BUNDLE FUNCTIONS.
*  RA  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE BUNDLE GRADIENTS.
*  IA  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RA  AR((NF+1)*(NF+2)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RA  AZ(NF+1)  VECTOR OF LAGRANGE MULTIPLIERS.
*  RA  G(NF)  SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RA  H(NF*(NF+1)/2)  AGGREGATE HESSIAN MATRIX.
*  RA  HF(NF*(NF+1)/2)  HESSIAN MATRIX OF THE OBJECTIVE FUNCTION.
*  RA  AH(NA*NF*(NF+1)/2)  BUNDLE OF HESSIAN MATRICES.
*  RA  S(NF+1)  DIRECTION VECTOR.
*  RA  SO(NF)  AUXILIARY VECTOR.
*  RA  XO(NF)  INCREMENT VECTOR.
*  RA  GO(NF+1)  GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RI  TOLX  TOLERANCE FOR CHANGE OF VARIABLES.
*  RI  TOLF  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*  RI  TOLB  TOLERANCE FOR THE FUNCTION FALUE.
*  RI  TOLG  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RI  TOLD  TOLERANCE FOR A DESCENT DIRECTION.
*  RI  TOLS  TOLERANCE FOR A FUNCTION DECREASE IN THE LINE SEARCH.
*  RI  TOLP  TOLERANCE FOR DIRECTIONAL DERIVATIVE IN THE LINE SEARCH.
*  RI  ETA  DISTANCE MEASURE PARAMETER.
*  RI  XMAX  MAXIMUM STEPSIZE.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  RO  FP  VALUE OF THE OBJECTIVE FUNCTION.
*  II  MOS  EXPONENT FOR DISTANCE MEASURE.
*  II  MES  METHOD SELECTION. MES=1-BISECTION. MES=2-TWO POINT
*         QUADRATIC INTERPOLATION. MES=3-THREE POINT QUADRATIC
*         INTERPOLATION. MES=4-THREE POINT CUBIC INTERPOLATION.
*  II  MTESX  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN TOLX.
*  II  MTESF  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN TOLF.
*  II  MIT  MAXIMUN NUMBER OF ITERATIONS.
*  II  MFV  MAXIMUN NUMBER OF FUNCTION EVALUATIONS.
*  II  IPRNT  PRINT SPECIFICATION. IPRNT=0-NO PRINT.
*         ABS(IPRNT)=1-PRINT OF FINAL RESULTS.
*         ABS(IPRNT)=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPRNT>0-BASIC FINAL RESULTS. IPRNT<0-EXTENDED FINAL
*         RESULTS.
*  II  IHES  A WAY FOR COMPUTING SECOND DERIVATIVES. IHES=0-NUMERICAL
*         COMPUTATION. IHES>0-ANALYTICAL COMPUTATION.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PDDBQ2  DETERMINATION OF THE DESCENT DIRECTION.
*  S   PS1L05  LINE SEARCH USING FUNCTION VALUES AND DERIVATIVES.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVDIF  DIFFERENCE OF TWO VECTORS.
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*  SE  HES  COMPUTATION OF THE HESSIAN MATRIX OF THE OBJECTIVE
*         FUNCTION. CALLING SEQUENCE: CALL HES(NF,X,H) WHERE
*         NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES AND H(NF*(NF+1)/2) IS THE UPPER RIGHT CORNER
*         OF THE SYMMETRIC HESSIAN MATRIX STORED BY COLUMNS. THIS
*         SUBTOUTINE IS USED ONLY IF IHES>0, BUT IT MUST BE
*         INCLUDED AS AN EMPTY SUBROUTINE IF IHES=0.
*
* METHOD :
* BUNDLE NEWTON METHOD WITH LINE SEARCH WHICH USES A SPECIAL
* QUADRATIC PROGRAMMING SUBALGORITHM.
*
      SUBROUTINE PNEW(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,CFD,AF,IA,
     +                AFD,AG,IAA,AR,AZ,G,H,HF,AH,S,SO,XO,GO,TOLX,TOLF,
     +                TOLB,TOLG,TOLD,TOLS,TOLP,ETA,XMAX,GMAX,FP,MOS,MES,
     +                MTESX,MTESF,MIT,MFV,IPRNT,IHES,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ETA,FP,GMAX,TOLB,TOLD,TOLF,TOLG,TOLP,TOLS,TOLX,
     +                 XMAX
      INTEGER IHES,IPRNT,ITERM,MES,MFV,MIT,MOS,MTESF,MTESX,NA,NB,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AFD(*),AG(*),AH(*),AR(*),AZ(*),CF(*),
     +                 CFD(*),CG(*),CL(*),CU(*),G(*),GO(*),H(*),HF(*),
     +                 S(*),SO(*),X(*),XL(*),XO(*),XU(*)
      INTEGER IA(*),IAA(*),IC(*),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION ALF2,DMAX,EPS7,EPS9,ETA0,ETA1,ETA2,ETA9,F,FMAX,
     +                 FMIN,FO,FUB,GNORM,P,PO,PP,R,RMAX,RMIN,RP,SNORM,
     +                 TEMP,TO,UMAX,XNORM
      INTEGER I,IDECF,IREST,ITERD,ITERL,ITERQ,ITERS,K,KBC,KBF,KC,KIT,
     +        MAL,MES2,N,NTESF,NTESX
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
C     .. External Subroutines ..
      EXTERNAL FUNDER,HES,MXDSMI,MXVCOP,MXVDIF,MXVDIR,MXVSET,PDDBQ2,
     +         PF1HS1,PLLPB2,PLNEWS,PS1L05
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN,SQRT
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (ABS(IPRNT).GT.1) WRITE (6,FMT='(1X,''ENTRY TO PNEW :'')')
*
*     INITIATION
*
      KBF = 0
      KBC = 0
      IF (NB.GT.0) KBF = 2
      IF (NC.GT.0) KBC = 2
      NIT = 0
      NFV = 0
      NFG = 0
      NFH = 0
      NTESX = 0
      NTESF = 0
      ITERM = 0
      ITERS = 0
      ITERD = 0
      ITERQ = 0
      IREST = 0
      ITERS = 2
      NDECF = 0
      IDECF = 0
      ETA0 = 1.0D-15
      ETA1 = 1.0D-15
      ETA2 = 1.0D-4
      ETA9 = 1.0D60
      EPS7 = 1.0D-10
      EPS9 = 1.0D-8
      ALF2 = 1.0D10
      FMAX = 1.0D60
      FMIN = -FMAX
      IF (TOLX.LE.0.0D0) TOLX = 1.0D-8
      IF (TOLF.LE.0.0D0) TOLF = 1.0D-8
      IF (TOLB.EQ.0.0D0) TOLB = FMIN + 1.0D-16
      IF (TOLG.LE.0.0D0) TOLG = 1.0D-6
      IF (TOLD.LE.0.0D0) TOLD = 1.0D-4
      IF (TOLS.LE.0.0D0) TOLS = 1.0D-2
      IF (TOLP.LE.0.0D0) TOLP = 5.0D-1
      IF (XMAX.LE.0.0D0) XMAX = 1.0D3
      IF (MES.LE.0) MES = 4
      IF (MOS.LE.0) MOS = 1
      IF (MTESX.LE.0) MTESX = 20
      IF (MTESF.LE.0) MTESF = 2
      IF (MIT.LE.0) MIT = 1000
      IF (MFV.LE.0) MFV = 2000
      MES2 = 1
      KIT = 0
      MAL = 0
*
*     INITIAL OPERATIONS WITH SIMPLE BOUNDS
*
      IF (KBF.GT.0) THEN
          DO 10 I = 1,NF
              IF ((IX(I).EQ.3.OR.IX(I).EQ.4) .AND. XU(I).LE.XL(I)) THEN
                  XU(I) = XL(I)
                  IX(I) = 5

              ELSE IF (IX(I).EQ.5 .OR. IX(I).EQ.6) THEN
                  XL(I) = X(I)
                  XU(I) = X(I)
                  IX(I) = 5
              END IF

              IF (IX(I).EQ.1 .OR. IX(I).EQ.3) X(I) = MAX(X(I),XL(I))
              IF (IX(I).EQ.2 .OR. IX(I).EQ.3) X(I) = MIN(X(I),XU(I))
   10     CONTINUE
      END IF
*
*     INITIAL OPERATIONS WITH GENERAL LINEAR CONSTRAINTS
*
      IF (KBC.GT.0) THEN
          K = 0
          DO 20 KC = 1,NC
              IF ((IC(KC).EQ.3.OR.IC(KC).EQ.4) .AND.
     +            CU(KC).LE.CL(KC)) THEN
                  CU(KC) = CL(KC)
                  IC(KC) = 5

              ELSE IF (IC(KC).EQ.5 .OR. IC(KC).EQ.6) THEN
                  CU(KC) = CL(KC)
                  IC(KC) = 5
              END IF

              CF(KC) = MXVDOT(NF,X,CG(K+1))
              K = K + NF
   20     CONTINUE
      END IF
*
*     DETERMINATION OF AN INITIAL FEASIBLE POINT
*
      IF (KBC.GT.0) THEN
          CALL MXVSET(NF,0.0D0,GO)
          CALL PLLPB2(NF,NC,X,IX,XO,XL,XU,CF,CFD,IC,IAA,CL,CU,CG,AR,AZ,
     +                GO,GO,S,1,KBF,KBC,ETA9,EPS7,EPS9,UMAX,GMAX,N,
     +                ITERL)

      ELSE IF (KBF.GT.0) THEN
          DO 30 I = 1,NF
              IF (IX(I).GE.5) IX(I) = -IX(I)
              IF (IX(I).LE.0) THEN

              ELSE IF ((IX(I).EQ.1.OR.IX(I).EQ.3) .AND.
     +                 X(I).LE.XL(I)) THEN
                  X(I) = XL(I)

              ELSE IF ((IX(I).EQ.2.OR.IX(I).EQ.3) .AND.
     +                 X(I).GE.XU(I)) THEN
                  X(I) = XU(I)
              END IF

              CALL PLNEWS(X,IX,XL,XU,EPS9,I,ITERL)
              IF (IX(I).GT.10) IX(I) = 10 - IX(I)
   30     CONTINUE
      END IF

      FO = FMIN
      FUB = FMAX
      GMAX = ETA9
      DMAX = ETA9
*
*     COMPUTATION OF THE VALUE AND THE GRADIENT OF THE OBJECTIVE
*     FUNCTION
*
      CALL FUNDER(NF,X,F,G)
      NFV = NFV + 1
      NFG = NFG + 1
      IF (IHES.GT.0) THEN
          CALL HES(NF,X,HF)
          NFH = NFH + 1

      ELSE
          CALL PF1HS1(NF,X,HF,G,SO,ETA1)
      END IF

   40 CONTINUE
      IF (ABS(IPRNT).GT.1) WRITE (6,FMT=
     +'(1X,''NIT='',I5,2X,''NFV='',I5,2X,''NFG='',I5,2X,       ''F ='',
     +D15.8,2X,''G ='',D11.4)') NIT,NFV,NFG,FP,GMAX
*
*     START OF THE ITERATION WITH TESTS FOR TERMINATION.
*
      N = NF
      UMAX = 0.0D0
      IF (ITERM.LT.0) GO TO 90
      IF (ITERS.EQ.0) GO TO 50
      IF (NIT.LE.0) FO = F + MIN(SQRT(ABS(F)),ABS(F)/1.0D1)
      IF (F.LE.TOLB) THEN
          ITERM = 3
          GO TO 90

      END IF

      IF (DMAX.LE.TOLX) THEN
          ITERM = 1
          NTESX = NTESX + 1
          IF (NTESX.GE.MTESX) GO TO 90

      ELSE
          NTESX = 0
      END IF

      TEMP = ABS(FO-FUB)/MAX(ABS(FUB),1.0D0)
      IF (TEMP.LE.TOLF) THEN
          ITERM = 2
          NTESF = NTESF + 1
          IF (NTESF.GE.MTESF) GO TO 90

      ELSE
          NTESF = 0
      END IF

   50 IF (NIT.GE.MIT) THEN
          ITERM = 12
          GO TO 90

      END IF

      IF (NFV.GE.MFV) THEN
          ITERM = 11
          GO TO 90

      END IF

      ITERM = 0
      NIT = NIT + 1
   60 CONTINUE
*
*     RESTART
*
      IF (IREST.GT.0) THEN
          CALL MXDSMI(NF,HF)
          IDECF = -1
          IF (KIT.LT.NIT) THEN
              NRES = NRES + 1
              KIT = NIT

          ELSE
              ITERM = -10
              IF (ITERS.LT.0) ITERM = ITERS - 5
              GO TO 90

          END IF

      END IF

      N = NF
*
*     DIRECTION DETERMINATION USING A SPECIAL QUADRATIC PROGRAMMING
*     PROCEDURE AND THE BUNDLE UPDATE
*
      CALL PDDBQ2(NF,NA,NC,X,IX,XL,XU,F,FO,FP,FUB,AF,AFD,IA,IAA,AG,AR,
     +            AZ,CF,IC,CL,CU,CG,G,H,HF,AH,S,GO,P,R,RP,KBF,KBC,IDECF,
     +            ETA0,ETA2,ETA9,EPS7,EPS9,TOLF,TOLG,ETA,UMAX,GMAX,
     +            GNORM,SNORM,XNORM,N,MAL,NIT,MOS,NTESF,NTESX,ITERQ,
     +            ITERD,ITERS,ITERM)
      IF (ITERD.LT.0) ITERM = ITERD
      IF (ITERM.NE.0) GO TO 90
*
*     TEST FOR SUFFICIENT DESCENT
*
      P = MXVDOT(NF,GO,S)
      IREST = 1
      IF (SNORM.LE.0.0D0) THEN

      ELSE IF (P+TOLD*GNORM*SNORM.LE.0.0D0) THEN
          IREST = 0
      END IF

      IF (IREST.EQ.0) THEN
          NRED = 0
          RMIN = 1.0D-3
          RMAX = MIN(ALF2*GNORM/SNORM,XMAX/SNORM)

      ELSE
          GO TO 60

      END IF

      IF (NIT.EQ.1) KIT = NIT
*
*     PREPARATION OF LINE SEARCH
*
      FP = FO
      FO = F
      PO = P
      PP = MXVDOT(NF,G,S)
      CALL MXVCOP(NF,X,XO)
      CALL MXVCOP(NF,G,GO)
*
*     LINE SEARCH WITH DIRECTIONAL DERIVATIVES WHICH ALLOWS NULL STEPS
*
      TO = 1.0D0
      CALL PS1L05(NF,X,XO,S,R,RP,F,FO,FP,P,PO,PP,TO,G,SNORM,RMIN,RMAX,
     +            FMIN,FMAX,TOLS,TOLP,ETA,MES,MES2,ITERS)

      ITERD = 0
      IF (IHES.GT.0) THEN
          CALL HES(NF,X,HF)
          NFH = NFH + 1

      ELSE
          CALL PF1HS1(NF,X,HF,G,SO,ETA1)
      END IF
*
*     DECISION AFTER UNSUCCESSFUL LINE SEARCH
*
      IF (ITERS.LE.0) THEN
          R = 0.0D0
          F = FO
          P = PO
          CALL MXVCOP(NF,XO,X)

      ELSE
          IF (ITERS.GE.9) CALL MXVDIR(NF,RP,S,XO,X)
          CALL MXVDIF(NF,X,XO,XO)
C          F = F - MXVDOT(NF,XO,G)
          IF (KBC.GT.0) THEN
              K = 0
              DO 70 KC = 1,NC
                  CF(KC) = MXVDOT(NF,X,CG(K+1))
                  K = K + NF
   70         CONTINUE
          END IF

      END IF
*
*     COMPUTATION OF VALUES FOR TERMINATION CRITERIA
*
      DMAX = 0.0D0
      DO 80 I = 1,NF
          DMAX = MAX(DMAX,ABS(XO(I))/MAX(ABS(X(I)),1.0D0))
   80 CONTINUE
      TEMP = FUB
      FUB = F
      IF (ITERS.GE.9) FUB = FUB - (R-RP)*P
      FUB = (FUB+TEMP)*0.5D0
*
*     END OF THE ITERATION
*
      GO TO 40

   90 IF (IPRNT.GT.1 .OR. IPRNT.LT.0) WRITE (6,
     +    FMT='(1X,''EXIT FROM PNEW :'')')
      IF (IPRNT.NE.0) WRITE (6,FMT=
     +'(1X,''NIT='',I5,2X,''NFV='',I5,2X,''NFG='',I5,2X,       ''F ='',
     +D15.8,2X,''G ='',D11.4,2X,''ITERM='',I3)') NIT,NFV,NFG,FP,GMAX,
     +    ITERM
      IF (IPRNT.LT.0) WRITE (6,FMT='(1X,''X ='',5D15.7:/(4X,5D15.7))')
     +    (X(I),I=1,NF)
      RETURN

      END
************************************************************************
* SUBROUTINE PVARU              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR UNCONSTRAINED NONSMOOTH OPTIMIZATION.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  RA  RA(NF*(NF+11)/2+2*NA*(NF+2))  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  CONVEXITY ASSUMPTION. IPAR(1)=0 IF THE OBJECTIVE
*         FUNCTION IS CONVEX. IPAR(1)=1 IF THE OBJECTIVE FUNCTION
*         IS NONCONVEX.
*      IPAR(2)  EXPONENT FOR DISTANCE MEASURE.
*      IPAR(3)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN TOLX.
*      IPAR(4)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN TOLF.
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(5)=0-NO PRINT.
*         ABS(IPAR(5))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(5))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(5)>0-BASIC FINAL RESULTS. IPAR(5)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(7)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE FUNCTION VALUE.
*      RPAR(4)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(5)  DISTANCE MEASURE PARAMETER.
*      RPAR(6)  MAXIMUM STEPSIZE.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PVAR  BUNDLE VARIABLE METRIC METHOD FOR CONVEX NONSMOOTH
*         OPTIMIZATION.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*
      SUBROUTINE PVARU(NF,NA,X,RA,IPAR,RPAR,F,GMAX,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION F,GMAX
      INTEGER ITERM,NA,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION RA(*),RPAR(7),X(*)
      INTEGER IPAR(7)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAF,LAG,LAX,LG,LGO,LGP,LGS,LH,LS,LXO,NB,NC
C     ..
C     .. Local Arrays ..
      INTEGER IA(1)
C     ..
C     .. External Subroutines ..
      EXTERNAL PVAR
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (NA.LE.0) NA = NF + 3
      NB = 0
      NC = 0
*
*     POINTERS FOR AUXILIUARY ARRAYS
*
      LAF = 1
      LAX = LAF + 4*NA
      LAG = LAX + NF*NA
      LG = LAG + NF*NA
      LH = LG + NF
      LS = LH + NF* (NF+1)/2
      LXO = LS + NF
      LGO = LXO + NF
      LGP = LGO + NF
      LGS = LGP + NF
      CALL PVAR(NF,NA,NB,NC,X,IA,RA,RA,RA,IA,RA,RA,RA,IA,RA,RA,RA,
     +          RA(LAF),RA(LAX),RA(LAG),RA(LG),RA(LGP),RA(LH),RA(LS),
     +          RA(LS),RA(LXO),RA(LGO),RA(LGP),RA(LGS),RPAR(1),RPAR(2),
     +          RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),GMAX,F,IPAR(1),
     +          IPAR(2),IPAR(3),IPAR(4),IPAR(5),IPAR(6),IPAR(7),ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PVARS              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR UNCONSTRAINED NONSMOOTH OPTIMIZATION.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  RA  RA(NF*(NF+11)/2+2*NA*(NF+2))  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  CONVEXITY ASSUMPTION. IPAR(1)=0 IF THE OBJECTIVE
*         FUNCTION IS CONVEX. IPAR(1)=1 IF THE OBJECTIVE FUNCTION
*         IS NONCONVEX.
*      IPAR(2)  EXPONENT FOR DISTANCE MEASURE.
*      IPAR(3)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN TOLX.
*      IPAR(4)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN TOLF.
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(5)=0-NO PRINT.
*         ABS(IPAR(5))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(5))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(5)>0-BASIC FINAL RESULTS. IPAR(5)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(6)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE FUNCTION VALUE.
*      RPAR(4)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(5)  DISTANCE MEASURE PARAMETER.
*      RPAR(6)  MAXIMUM STEPSIZE.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PVAR  BUNDLE VARIABLE METRIC METHOD FOR CONVEX NONSMOOTH
*         OPTIMIZATION.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*
      SUBROUTINE PVARS(NF,NA,NB,X,IX,XL,XU,RA,IPAR,RPAR,F,GMAX,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION F,GMAX
      INTEGER ITERM,NA,NB,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION RA(*),RPAR(7),X(*),XL(*),XU(*)
      INTEGER IPAR(7),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAF,LAG,LAX,LG,LGN,LGO,LGP,LGS,LH,LS,LXO,NC
C     ..
C     .. External Subroutines ..
      EXTERNAL PVAR
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (NA.LE.0) NA = NF + 3
      NC = 0
*
*     POINTERS FOR AUXILIUARY ARRAYS
*
      LAF = 1
      LAX = LAF + 4*NA
      LAG = LAX + NF*NA
      LG = LAG + NF*NA
      LGN = LG + NF
      LH = LGN + NF
      LS = LH + NF* (NF+1)/2
      LXO = LS + NF
      LGO = LXO + NF
      LGP = LGO + NF
      LGS = LGP + NF
      CALL PVAR(NF,NA,NB,NC,X,IX,XL,XU,RA,IX,RA,RA,RA,IX,RA,RA,RA,
     +          RA(LAF),RA(LAX),RA(LAG),RA(LG),RA(LGN),RA(LH),RA(LS),
     +          RA(LS),RA(LXO),RA(LGO),RA(LGP),RA(LGS),RPAR(1),RPAR(2),
     +          RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),GMAX,F,IPAR(1),
     +          IPAR(2),IPAR(3),IPAR(4),IPAR(5),IPAR(6),IPAR(7),ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PVARL              ALL SYSTEMS                   97/01/22
* PURPOSE :
* EASY TO USE SUBROUTINE FOR UNCONSTRAINED NONSMOOTH OPTIMIZATION.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  RA  RA(NF*(NF+11)/2+2*NA*(NF+2))  AUXILIARY ARRAY.
*  II  IPAR(7)  INTEGER PAREMETERS:
*      IPAR(1)  CONVEXITY ASSUMPTION. IPAR(1)=0 IF THE OBJECTIVE
*         FUNCTION IS CONVEX. IPAR(1)=1 IF THE OBJECTIVE FUNCTION
*         IS NONCONVEX.
*      IPAR(2)  EXPONENT FOR DISTANCE MEASURE.
*      IPAR(3)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN TOLX.
*      IPAR(4)  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN TOLF.
*      IPAR(5)  MAXIMUM NUMBER OF ITERATIONS.
*      IPAR(6)  MAXIMUM NUMBER OF FUNCTION EVALUATIONS.
*      IPAR(7)  PRINT SPECIFICATION. IPAR(5)=0-NO PRINT.
*         ABS(IPAR(5))=1-PRINT OF FINAL RESULTS.
*         ABS(IPAR(5))=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPAR(5)>0-BASIC FINAL RESULTS. IPAR(5)<0-EXTENDED FINAL
*         RESULTS.
*  RI  RPAR(6)  REAL PARAMETERS:
*      RPAR(1)  TOLERANCE FOR CHANGE OF VARIABLES.
*      RPAR(2)  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*      RPAR(3)  TOLERANCE FOR THE FUNCTION VALUE.
*      RPAR(4)  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*      RPAR(5)  DISTANCE MEASURE PARAMETER.
*      RPAR(6)  MAXIMUM STEPSIZE.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PVAR  BUNDLE VARIABLE METRIC METHOD FOR CONVEX NONSMOOTH
*         OPTIMIZATION.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIALES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*
      SUBROUTINE PVARL(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,IA,RA,IPAR,
     +                 RPAR,F,GMAX,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION F,GMAX
      INTEGER ITERM,NA,NB,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CG(*),CL(*),CU(*),RA(*),RPAR(7),X(*),XL(*),
     +                 XU(*)
      INTEGER IA(*),IC(*),IPAR(7),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER LAF,LAG,LAX,LCFD,LCR,LCZ,LG,LGN,LGO,LGP,LGS,LH,LS,LSN,LXO
C     ..
C     .. External Subroutines ..
      EXTERNAL PVAR
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (NA.LE.0) NA = NF + 3
*
*     POINTERS FOR AUXILIUARY ARRAYS
*
      LCFD = 1
      LCR = LCFD + NC
      LCZ = LCR + NF* (NF+1)/2
      LAF = LCZ + NF*NF
      LAX = LAF + 4*NA
      LAG = LAX + NF*NA
      LG = LAG + NF*NA
      LGN = LG + NF
      LH = LGN + NF
      LS = LH + NF* (NF+1)/2
      LSN = LS + NF
      LXO = LSN + NF
      LGO = LXO + NF
      LGP = LGO + NF
      LGS = LGP + NF
      CALL PVAR(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,IA,RA(LCFD),
     +          RA(LCR),RA(LCZ),RA(LAF),RA(LAX),RA(LAG),RA(LG),RA(LGN),
     +          RA(LH),RA(LS),RA(LSN),RA(LXO),RA(LGO),RA(LGP),RA(LGS),
     +          RPAR(1),RPAR(2),RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),
     +          GMAX,F,IPAR(1),IPAR(2),IPAR(3),IPAR(4),IPAR(5),IPAR(6),
     +          IPAR(7),ITERM)
      RETURN

      END
************************************************************************
* SUBROUTINE PVAR               ALL SYSTEMS                   99/01/22
* PURPOSE :
* GENERAL VARIABLE METRIC SUBROUTINE FOR NONSMOOTH OPTIMIZATION.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  II  NB  NUMBER OF BOX CONSTRAINTS.
*  II  NC  NUMBER OF GENERAL LINEAR CONSTRAINTS.
*  RU  X(NF)  VECTOR OF VARIABLES.
*  RA  AF(4*NA)  VECTOR OF BUNDLE VALUES.
*  RA  AX(NF*NA)  MATRIX WHOSE COLUMNS ARE BUNDLE POINTS.
*  RA  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE BUNDLE GRADIENTS.
*  RA  G(NF)  SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RA  H(NF*(NF+1)/2)  APPROXIMATION OF THE HESSIAN MATRIX.
*  RA  S(NF)  DIRECTION VECTOR.
*  RA  XO(NF)  DIFFERENCE OF VECTORS OF VARIABLES.
*  RA  GO(NF)  DIFFERENCE OF GRADIENTS.
*  RA  GP(NF)  AUXILIARY VECTOR.
*  RI  TOLX  TOLERANCE FOR CHANGE OF VARIABLES.
*  RI  TOLF  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*  RI  TOLB  TOLERANCE FOR THE FUNCTION VALUE.
*  RI  TOLG  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RI  ETA  DISTANCE MEASURE PARAMETER.
*  RI  XMAX  MAXIMUM STEPSIZE.
*  RO  GMAX  VALUE OF THE TERMINATION CRITERION.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
C*PL*ERROR* Comment line too long
*  II  MEX  CONVEXITY ASSUMPTION. MEX=0-CONVEX VERSION OF THE METHOD IS USED.
*         MEX=1-NONCONVEX VERSION OF THE METHOD IS USED.
*  II  MOS  EXPONENT FOR DISTANCE MEASURE.
*  II  MTESX  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF VARIABLES
*         SMALLER THAN TOLX.
*  II  MTESF  MAXIMUM NUMBER OF ITERATIONS WITH CHANGES OF FUNCTION
*         VALUES SMALLER THAN TOLF.
*  II  MIT  MAXIMUN NUMBER OF ITERATIONS.
*  II  MFV  MAXIMUN NUMBER OF FUNCTION EVALUATIONS.
*  II  IPRNT  PRINT SPECIFICATION. IPRNT=0-NO PRINT.
*         ABS(IPRNT)=1-PRINT OF FINAL RESULTS.
*         ABS(IPRNT)=2-PRINT OF FINAL RESULTS AND ITERATIONS.
*         IPRNT>0-BASIC FINAL RESULTS. IPRNT<0-EXTENDED FINAL
*         RESULTS.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* VARIABLES IN COMMON /STAT/ (STATISTICS) :
*  IO  NDECF  NUMBER OF MATRIX DECOMPOSITION.
*  IO  NRES  NUMBER OF RESTARTS.
*  IO  NRED  NUMBER OF MINOR ITERATIONS.
*  IO  NREM  NUMBER OF CONSTRAINT DELETIONS.
*  IO  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  NIT  NUMBER OF ITERATIONS.
*  IO  NFV  NUMBER OF FUNCTION EVALUATIONS.
*  IO  NFG  NUMBER OF GRADIENT EVALUATIONS.
*  IO  NFH  NUMBER OF HESSIAN EVALUATIONS.
*
* SUBPROGRAMS USED :
*  S   PS1L07 LINE SEARCH USING FUNCTION VALUES AND DERIVATIVES.
*  S   PS1L08 LINE SEARCH USING FUNCTION VALUES AND DERIVATIVES.
*  S   PUDVI2 VARIABLE METRIC UPDATE OF THE INVERSE HESSIAN MATRIX.
*  S   PYBUN1  BUNDLE SELECTION.
*  S   PYAGR1  SUBGRADIENT AGGREGATION.
*  S   PYAGR2  SIMPLIFIED SUBGRADIENT AGGREGATION.
*  S   MXDPGF  GILL-MURRAY DECOMPOSITION OF A DENSE SYMMETRIC MATRIX.
*  S   MXDPGB  BACK SUBSTITUTION AFTER GILL-MURRAY DECOMPOSITION.
*  S   MXDSMI  DENSE SYMMETRIC MATRIX A IS SET TO THE UNIT MATRIX.
*  S   MXDSMM  MATRIX VECTOR PRODUCT.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVDIF  DIFFERENCE OF TWO VECTORS.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*  S   MXVNEG  COPYING OF A VECTOR WITH CHANGE OF THE SIGN.
*  RF  MXVSAB  L-1 NORM OF A VECTOR.
*
* EXTERNAL SUBROUTINES :
*  SE  FUNDER  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION. CALLING SEQUENCE: CALL FUNDER(NF,X,F,G)
*         WHERE NF IS A NUMBER OF VARIABLES, X(NF) IS A VECTOR OF
*         VARIABLES, F IS THE VALUE OF THE OBJECTIVE FUNCTION AND
*         G(NF) IS THE GRADIENT OF THE OBJECTIVE FUNCTION.
*
* METHOD :
* MEX=0 - L.LUKSAN, J.VLCEK: GLOBALLY CONVERGENT VARIABLE METRIC METHOD
*         FOR CONVEX NONSMOOTH UNCONSTRAINED MINIMIZATION. JOTA 102
*         (1999) 593-613.
* MEX=1 - J.VLCEK, L.LUKSAN: GLOBALLY CONVERGENT VARIABLE METRIC METHOD
*         FOR NONCONVEX NONDIFFERENTIABLE UNCONSTRAINED MINIMIZATION.
*         REPORT B 8/1999, DEPARTMENT OF MATHEMATICAL INFORMATION
*         TECHNOLOGY, UNIVERSITY OF JYVASKYLA, 1999.
*
      SUBROUTINE PVAR(NF,NA,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,CG,ICA,CFD,CR,
     +                CZ,AF,AX,AG,G,GN,H,S,SN,XO,GO,GP,GS,TOLX,TOLF,
     +                TOLB,TOLG,ETA,EPS,XMAX,GMAX,F,MEX,MOS,MTESX,MTESF,
     +                MIT,MFV,IPRNT,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS,ETA,F,GMAX,TOLB,TOLF,TOLG,TOLX,XMAX
      INTEGER IPRNT,ITERM,MEX,MFV,MIT,MOS,MTESF,MTESX,NA,NB,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AG(*),AX(*),CF(*),CFD(*),CG(*),CL(*),CR(*),
     +                 CU(*),CZ(*),G(*),GN(*),GO(*),GP(*),GS(*),H(*),
     +                 S(*),SN(*),X(*),XL(*),XO(*),XU(*)
      INTEGER IC(*),ICA(*),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION ALF,ALFN,ALFV,BET,CON1,CON2,DF,DMAX,EPS0,EPS1,
     +                 EPS2,EPS7,EPS9,ETA2,ETA9,FMAX,FMIN,FO,GAM,GNORM,
     +                 P,PO,POM,R,RHO,RMAX,RMIN,RO,RP,SNORM,UMAX,XNORM
      INTEGER I,IDECF,IER,INEW,INF,IOLD,IREST,IRET,ITERL,ITERS,JC,JE,JL,
     +        JR,JU,K,KBC,KBF,KC,KIT,KOLD,KREM,MAL,N,NNC,NNK,NNV,NTESF,
     +        NTESX
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT,MXVNOR,MXVSAB
      EXTERNAL MXVDOT,MXVNOR,MXVSAB
C     ..
C     .. External Subroutines ..
      EXTERNAL FUNDER,MXDPGF,MXDPGI,MXDSDA,MXDSMI,MXDSMM,MXDSMS,MXVCOP,
     +         MXVDIR,MXVNEG,MXVSET,PLLPB1,PLNEWS,PS1L07,PS1L08,PUDVI2,
     +         PYADB4,PYAGB1,PYAGB2,PYBUN1,PYRMB1,PYTRBD,PYTRBG,PYTRBS
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN,SQRT
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (ABS(IPRNT).GT.1) WRITE (6,FMT='(1X,''ENTRY TO PVAR :'')')
*
*     INITIATION
*
      KBF = 0
      KBC = 0
      IF (NB.GT.0) KBF = 2
      IF (NC.GT.0) KBC = 2
      NIT = 0
      NFV = 0
      NFG = 0
      KREM = 0
      NREM = 0
      NRES = 0
      NADD = 0
      NTESX = 0
      NTESF = 0
      ITERM = 0
      ITERS = 0
      IREST = 1
      ITERS = 2
      NDECF = 0
      IDECF = 0
      ETA9 = 1.0D60
      EPS0 = 1.0D-6
      EPS1 = 1.0D-4
      EPS2 = 2.5D-1
      EPS7 = 1.0D-8
      EPS9 = 1.0D-8
      FMAX = 1.0D60
      FMIN = -FMAX
      IF (TOLX.LE.0.0D0) TOLX = 1.0D-8
      IF (TOLF.LE.0.0D0) TOLF = 1.0D-8
      IF (TOLB.EQ.0.0D0) TOLB = FMIN + 1.0D-16
      IF (TOLG.LE.0.0D0) TOLG = 1.0D-6
      IF (XMAX.LE.0.0D0) XMAX = 1.0D3
      IF (EPS.LE.0.0D0) EPS = 0.5D0
      IF (MOS.LE.0) MOS = 2
      IF (MTESX.LE.0) MTESX = 2
      IF (MTESF.LE.0) MTESF = 2
      IF (MIT.LE.0) MIT = 1000
      IF (MFV.LE.0) MFV = 2000
      N = NF
      KIT = 0
*
*     INITIAL OPERATIONS WITH SIMPLE BOUNDS
*
      IF (KBF.GT.0) THEN
          DO 10 I = 1,NF
              IF ((IX(I).EQ.3.OR.IX(I).EQ.4) .AND. XU(I).LE.XL(I)) THEN
                  XU(I) = XL(I)
                  IX(I) = 5

              ELSE IF (IX(I).EQ.5 .OR. IX(I).EQ.6) THEN
                  XL(I) = X(I)
                  XU(I) = X(I)
                  IX(I) = 5
              END IF

              IF (IX(I).EQ.1 .OR. IX(I).EQ.3) X(I) = MAX(X(I),XL(I))
              IF (IX(I).EQ.2 .OR. IX(I).EQ.3) X(I) = MIN(X(I),XU(I))
   10     CONTINUE
      END IF
*
*     INITIAL OPERATIONS WITH GENERAL LINEAR CONSTRAINTS
*
      IF (KBC.GT.0) THEN
          K = 0
          DO 20 KC = 1,NC
              IF ((IC(KC).EQ.3.OR.IC(KC).EQ.4) .AND.
     +            CU(KC).LE.CL(KC)) THEN
                  CU(KC) = CL(KC)
                  IC(KC) = 5

              ELSE IF (IC(KC).EQ.5 .OR. IC(KC).EQ.6) THEN
                  CU(KC) = CL(KC)
                  IC(KC) = 5
              END IF

              CF(KC) = MXVDOT(NF,X,CG(K+1))
              K = K + NF
   20     CONTINUE
      END IF
*
*     DETERMINATION OF AN INITIAL FEASIBLE POINT
*
      IF (KBC.GT.0) THEN
          CALL MXVSET(NF,0.0D0,GO)
          CALL PLLPB1(NF,NC,X,IX,XO,XL,XU,CF,CFD,IC,ICA,CL,CU,CG,CR,CZ,
     +                GO,GO,S,1,KBF,KBC,ETA9,EPS7,EPS9,UMAX,GMAX,N,
     +                ITERL)

      ELSE IF (KBF.GT.0) THEN
          DO 30 I = 1,NF
              IF (IX(I).GE.5) IX(I) = -IX(I)
              IF (IX(I).LE.0) THEN

              ELSE IF ((IX(I).EQ.1.OR.IX(I).EQ.3) .AND.
     +                 X(I).LE.XL(I)) THEN
                  X(I) = XL(I)

              ELSE IF ((IX(I).EQ.2.OR.IX(I).EQ.3) .AND.
     +                 X(I).GE.XU(I)) THEN
                  X(I) = XU(I)
              END IF

              CALL PLNEWS(X,IX,XL,XU,EPS9,I,INEW)
              IF (IX(I).GT.10) IX(I) = 10 - IX(I)
   30     CONTINUE
      END IF

      MAL = 0
      JR = 0
      JC = 0
      JE = 0
      JU = 0
      NNC = 0
      NNK = 0
      NNV = 0
      GAM = 1.0D0
      IF (MEX.EQ.0) THEN
          CON1 = 2.0D0
          CON2 = 1.0D0
          RHO = 1.0D-8
          ETA2 = 1.0D-8

      ELSE
          CON1 = 1.0D2
          CON2 = 1.0D-1
          RHO = 1.0D-12
          ETA2 = 1.0D-12
      END IF

      FO = FMIN
*
*     COMPUTATION OF THE VALUE AND THE GRADIENT OF THE OBJECTIVE
*     FUNCTION
*
      CALL FUNDER(NF,X,F,G)
      NFV = NFV + 1
      NFG = NFG + 1
      DF = ABS(F) + 1.0D0
      CALL PYBUN1(NF,NA,MAL,X,G,F,AX,AG,AF,ITERS)
      CALL MXDSMI(N,H)
*
*     START OF THE ITERATION WITH TESTS FOR TERMINATION.
*
   40 CONTINUE
      IF (ITERS.GT.0) THEN
          IF (MEX.EQ.0) THEN
              JC = 0
              JU = 0
              NNC = 0
          END IF

          ALFN = 0.0D0
          ALFV = 0.0D0
          CALL MXVCOP(NF,G,GP)
      END IF

      CALL PYTRBG(NF,N,NC,IX,IC,ICA,CG,CR,CZ,GP,GN,UMAX,GMAX,KBF,KBC,
     +            IOLD,KOLD)
      IF (ABS(IPRNT).GT.1) WRITE (6,FMT=
     +'(1X,''NIT='',I5,2X,''NFV='',I5,2X,''NFG='',I5,2X,       ''F ='',
     +D15.8,2X,''G ='',D11.4)') NIT,NFV,NFG,F,GMAX
      IF (ITERM.LT.0) GO TO 80
      IF (F.LE.TOLB) THEN
          ITERM = 3
          GO TO 80

      END IF

      IF (NIT.GE.MIT) THEN
          ITERM = 12
          GO TO 80

      END IF

      IF (NFV.GE.MFV) THEN
          ITERM = 11
          GO TO 80

      END IF

      ITERM = 0
      NIT = NIT + 1
      CALL PYRMB1(NF,N,IX,IC,ICA,CG,CR,CZ,GP,GN,H,EPS,UMAX,GMAX,KBF,KBC,
     +            IOLD,KOLD,KREM,IER,ITERM)
      IF (ITERM.NE.0) GO TO 80
   50 CONTINUE
*
*     RESTART
*
      IF (IREST.GT.0) THEN
          CALL MXDSMI(N,H)
          IDECF = -1
          IF (KIT.LT.NIT) THEN
              NRES = NRES + 1
              KIT = NIT

          ELSE
              ITERM = -10
              IF (ITERS.LT.0) ITERM = ITERS - 5
              GO TO 80

          END IF

      END IF

      IF (MEX.EQ.1 .AND. JE.GT.0) GO TO 60
*
*     DIRECTION DETERMINATION
*
      IF (IDECF.LT.0) THEN
          IDECF = 9
          INF = 0
      END IF

      IF (IDECF.EQ.0) THEN
*
*     INVERSION
*
          ALF = ETA2
          CALL MXDPGF(N,H,INF,ALF,BET)
          CALL MXDPGI(N,H)
          NDECF = NDECF + 1
          IDECF = 9

      ELSE IF (IDECF.EQ.9) THEN

      ELSE
          ITERM = -1
          GO TO 80

      END IF

      GNORM = SQRT(MXVDOT(N,GN,GN))
*
*     NEWTON LIKE STEP
*
      CALL MXDSMM(N,H,GN,SN)
      CALL MXVNEG(N,SN,SN)
      SNORM = SQRT(MXVDOT(N,SN,SN))
      P = MXVDOT(N,GN,SN)
*
*     TEST ON DESCENT DIRECTION
*
      IF (P+EPS0*GNORM*SNORM.LE.0.0D0) THEN
          IREST = 0

      ELSE
          IREST = 1
          GO TO 50

      END IF

      XNORM = -P + 2.0D0*ALFV
      POM = RHO*GNORM**2
      IF (XNORM.LT.POM .OR. (JC.EQ.1.AND.JU.EQ.1)) THEN
          NNC = NNC + 1
          IF (NNC.GE.1) JC = 1
          CALL MXVDIR(N,-RHO,GN,SN,SN)
          CALL MXDSDA(N,H,RHO)
          XNORM = XNORM + POM
      END IF

   60 CONTINUE
      IF (XNORM.LE.TOLG) THEN
          IF (SNORM.LE.0.0D0) ITERM = 4
          NTESX = NTESX + 1
          IF (ITERS.GT.0 .AND. DF.LT.CON1*TOLF*
     +        MAX(ABS(F),1.0D0)) ITERM = 4
          IF (NTESX.GE.2 .AND. NNK.GT.1) ITERM = 4

      ELSE
          NTESX = 0
      END IF

      IF (ITERM.NE.0) GO TO 80
*
*     PREPARATION OF LINE SEARCH
*
      IF (SNORM.GT.0.0D0) RMAX = XMAX/SNORM
      RMIN = 1.0D-10
      CALL PYTRBS(NF,N,NC,X,IX,XO,XL,XU,G,GO,CF,CFD,IC,CL,CU,CG,CZ,SN,S,
     +            RO,POM,FO,F,PO,P,RMAX,KBF,KBC,KREM,INEW)
      IF (RMAX.LE.RMIN) THEN
          R = 0.0D0
          GO TO 70

      END IF
*
*     LINE SEARCH WITH DIRECTIONAL DERIVATIVES WHICH ALLOWS NULL STEPS
*
      IF (MEX.EQ.0) THEN
          CALL PS1L07(NF,NA,MAL,X,G,S,XO,GO,AF,AG,AX,R,RP,FO,F,PO,RMIN,
     +                RMAX,1.0D-4*XNORM,DF,ETA9,TOLF,JL,JE,NNV,NTESF,
     +                MTESF,ITERS)

      ELSE
          CALL PS1L08(NF,NA,MAL,X,G,S,XO,AF,AG,AX,R,RP,FO,F,PO,P,RMIN,
     +                RMAX,SNORM,XNORM,EPS1,EPS2,ETA,ETA9,JE,MOS,ITERS)
      END IF

      IF (KBC.GT.0 .OR. KBF.GT.0) THEN
          IF (F.EQ.FO .AND. R.GE.RMAX .AND. INEW.NE.0) THEN
              ITERS = 1
          END IF

      END IF

      IF (MEX.EQ.0) THEN
          IF (JL.GT.0 .AND. ITERS.EQ.0) F = FO
          IF (JL.GT.0) THEN
              ITERM = 2
              GO TO 80

          END IF

          IF (JE.GT.0) NTESX = 0

      ELSE
          NNV = NNV + 1
          POM = DF
          IF (ABS(FO-F).GE.DF*1.0D-5) POM = ABS(FO-F)
          IF (ITERS.GT.0) DF = POM
          IF (POM.LE.TOLF*MAX(ABS(F),1.0D0) .OR.
     +        FO.EQ.F .AND. (R.LT.RMAX.OR.INEW.EQ.0)) THEN
              NTESF = NTESF + 1
              IF (NTESF.GE.MTESF) THEN
                  F = FO
                  ITERM = 2
                  GO TO 80

              END IF

          ELSE
              NTESF = 0
          END IF

      END IF

      CALL PYBUN1(NF,NA,MAL,X,G,F,AX,AG,AF,ITERS)
      IF (RP.LT.SQRT(ETA9)) GAM = (MAX(CON2,MIN(1.0D2,RP))+2.0D0*GAM)/
     +                            3.0D0
      IRET = 0
      IF (ITERS.EQ.0) THEN
          NNK = NNK + 1
          IF (MEX.EQ.0) THEN
              ALFN = ABS((FO-F)/R+P)

          ELSE
              ALFN = MAX(ABS(FO-F+P*R),ETA* (SNORM*R)**MOS)
          END IF

          IF (NNK.EQ.1) THEN
              CALL PYAGB2(NF,N,IX,H,G,GP,GN,SN,CZ,S,ALFN,ALFV,KBF,KBC)

          ELSE
              CALL PYAGB1(NF,N,IX,H,G,GO,GP,GN,SN,CZ,S,GS,ALFN,ALFV,KBF,
     +                    KBC)
          END IF

          F = FO

      ELSE
          NNK = 0
          IF (MEX.EQ.0) THEN
              RHO = 1.0D-8/NFV
              IF (GNORM.GT.0.0D0) RHO = RHO*
     +                                  MIN(1.0D0/MIN(GNORM**2,1.0D3),
     +                                  GNORM**2)
          END IF

          IF (GAM.GT.1.0D0) JR = JR + 1
          IF (GAM.GT.1.0D1 .AND. NNV.GT.3 .AND. JR.GT.1) THEN
*
*     MATRIX SCALING
*
              NNV = 0
              JR = 0
              CALL MXDSMS(N,H,GAM)
              GAM = SQRT(GAM)
              IRET = 1
          END IF

      END IF

      CALL PYTRBD(NF,N,X,IX,XO,G,GO,CZ,SN,R,F,FO,POM,PO,DMAX,ITERS,KBF,
     +            KBC)
      POM = MXVSAB(N,GO)
      IF (IRET.GT.0) THEN
          IF (POM.NE.0.0D0) JE = 0
          GO TO 70

      END IF

      IF (MEX.EQ.0) THEN
          JU = 0
          POM = MXVDOT(N,XO,GO)
          IF (POM.GT.1.0D-5*R*SNORM**2 .AND.
     +        ABS(POM).GT.1.0D-6*MXVNOR(N,XO)*MXVNOR(N,GO)) THEN
              CALL PUDVI2(N,H,XO,GN,GO,S,POM,RHO,JC,JU,NNK,0,NIT)
          END IF

      ELSE
          IF (POM.EQ.0.0D0 .AND. ITERS.GT.0) THEN
              JE = JE + 1
              IF (JE.GT.7) JE = 99
              GO TO 70

          ELSE
              JE = 0
          END IF

          POM = MXVDOT(N,XO,GO)
          IF (POM.GT.R*RHO .AND. ABS(POM).GT.
     +        1.0D-6*MXVNOR(N,XO)*MXVNOR(N,GO)) THEN
              CALL PUDVI2(N,H,XO,GN,GO,S,POM,RHO,JC,JU,NNK,1,NIT)
          END IF

      END IF

   70 CONTINUE
      IF (ITERS.NE.0 .OR. RMAX.LE.RMIN .AND. INEW.NE.0) THEN
          CALL PYADB4(NF,N,NC,X,IX,XL,XU,CF,CFD,IC,ICA,CL,CU,CG,CR,CZ,H,
     +                S,R,EPS7,EPS9,GMAX,UMAX,KBF,KBC,INEW,IER,ITERM)
      END IF

      GO TO 40

   80 GMAX = XNORM
      IF (IPRNT.GT.1 .OR. IPRNT.LT.0) WRITE (6,
     +    FMT='(1X,''EXIT FROM PVAR :'')')
      IF (IPRNT.NE.0) WRITE (6,FMT=
     +'(1X,''NIT='',I5,2X,''NFV='',I5,2X,''NFG='',I5,2X,       ''F ='',
     +D15.8,2X,''G ='',D11.4,2X,''ITERM='',I3)') NIT,NFV,NFG,F,GMAX,
     +    ITERM
      IF (IPRNT.LT.0) WRITE (6,FMT='(1X,''X ='',5D15.7:/(4X,5D15.7))')
     +    (X(I),I=1,NF)
      RETURN

      END
* SUBROUTINE PA1MX2             ALL SYSTEMS                 92/12/01
* PORTABILITY : ALL SYSTEMS
* 92/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* COMPUTATION OF THE VALUE AND THE GRADIENT OF THE OBJECTIVE FUNCTION
* WHICH IS DEFINED AS A MAXIMUM OF THE APPROXIMATED FUNCTIONS.
*
* PARAMETERS :
*  II  NF DECLARED NUMBER OF VARIABLES.
*  II  NA  NUMBER OF APPROXIMATED FUNCTIONS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RA  FA  VALUE OF THE APPROXIMATED FUNCTION.
*  RO  AF(NA)  VECTOR WHOSE ELEMENTS ARE VALUES OF THE
*         APPROXIMATED FUNCTIONS.
*  RA  GA(NF)  GRADIENT OF THE APPROXIMATED FUNCTION.
*  RO  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE GRADIENTS OF THE
*         APPROXIMATED FUNCTIONS.
*  RO  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  II  KD  DEGREE OF REQUIRED DERVATIVES.
*  IU  LD  DEGREE OF PREVIOUSLY COMPUTED DERIVATIVES.
*  II  IEXT  TYPE OF OBJECTIVE FUNCTION. IEXT<0-MAXIMUM OF POSITIVE
*         VALUES. IEXT=0-MAXIMUM OF ABSOLUTE VALUES. IEXT>0-MAXIMUM
*         OF NEGATIVE VALUES.
*
* SUBPROGRAMS USED :
*  SE  FUN  COMPUTATION OF THE VALUE OF THE APPROXIMATED FUNCTION.
*  SE  DER  COMPUTATION OF THE GRADIENT OF THE APPROXIMATED FUNCTION.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVNEG  COPYING OF A VECTOR WITH CHANGE OF THE SIGN.
*
      SUBROUTINE PA1MX2(NF,NA,X,F,FA,AF,GA,AG,G,KD,LD,IEXT)
C     .. Scalar Arguments ..
      DOUBLE PRECISION F,FA
      INTEGER IEXT,KD,LD,NA,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AG(*),G(*),GA(*),X(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION FTEMP,FVAL
      INTEGER K,KA,KAP,L,NAG,NAV
C     ..
C     .. External Subroutines ..
      EXTERNAL DER,FUN,MXVCOP,MXVNEG
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
C     .. Save statement ..
      SAVE NAV,NAG,KAP
C     ..
      IF (NIT.EQ.0) THEN
          NAV = 0
          NAG = 0
      END IF

      IF (KD.LE.LD) RETURN
      DO 20 KA = 1,NA
          IF (KD.LT.0) GO TO 20
          IF (LD.GE.0) THEN
              FA = AF(KA)
              GO TO 10

          ELSE
              NAV = NAV + 1
              CALL FUN(NF,KA,X,FA)
              AF(KA) = FA
          END IF

          IF (IEXT.EQ.0 .AND. FA.GE.0.0D0 .OR. IEXT.LT.0) THEN
              FTEMP = FA
              K = 1

          ELSE
              FTEMP = -FA
              K = -1
          END IF

          IF (KA.EQ.1 .OR. FVAL.LT.FTEMP) THEN
              FVAL = FTEMP
              KAP = KA
              L = K
          END IF

   10     IF (KD.LT.1) GO TO 20
          NAG = NAG + 1
          CALL DER(NF,KA,X,GA)
          CALL MXVCOP(NF,GA,AG((KA-1)*NF+1))
   20 CONTINUE
      IF (KD.GE.0 .AND. LD.LT.0) F = FVAL
      IF (KD.GE.1 .AND. LD.LT.1) THEN
          IF (L.GE.0) THEN
              CALL MXVCOP(NF,AG((KAP-1)*NF+1),G)

          ELSE
              CALL MXVNEG(NF,AG((KAP-1)*NF+1),G)
          END IF

      END IF

      NFV = NAV/NA
      NFG = NAG/NA
      LD = KD
      RETURN

      END
* SUBROUTINE PF1HS1                ALL SYSTEMS                90/12/01
* PORTABILITY : ALL SYSTEMS
* 90/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* NUMERICAL COMPUTATION OF THE HESSIAN MATRIX OF THE MODEL FUNCTION
* USING ITS GRADIENTS.
*
* PARAMETERS :
*  II  NF NUMBER OF VARIABLES.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  RO  HF(M) HESSIAN MATRIX OF THE MODEL FUNCTION.
*  RI  GF(NF)  GRADIENT OF THE MODEL FUNCTION.
*  RA  GO(NF)  AUXILIARY VECTOR.
*  RI  ETA1  PRECISION OF COMPUTED GRADIENTS.
*
*
* SUBPROGRAMS USED :
*  SE  FUNDER  OBJECTIVE FUNCTION AND SUBGRADIENT EVALUATION.
*  S   MXVCOP  COPYING OF A VECTOR.
*
      SUBROUTINE PF1HS1(NF,X,HF,GF,GO,ETA1)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ETA1
      INTEGER NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION GF(*),GO(*),HF(*),X(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION ETA,FTEMP,XSTEP,XTEMP
      INTEGER I,IJ,IVAR,J
C     ..
C     .. External Subroutines ..
      EXTERNAL FUNDER,MXVCOP
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN,SQRT
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
C     .. Statement Functions ..
      INTEGER IND
C     ..
C     .. Statement Function definitions ..
      IND(I,J) = MAX(I,J)* (MAX(I,J)-1)/2 + MIN(I,J)
C     ..
      CALL MXVCOP(NF,GF,GO)
      ETA = SQRT(ETA1)
      DO 20 IVAR = 1,NF
*
*     STEP SELECTION
*
          XTEMP = X(IVAR)
          IF (XTEMP.GE.0.0D0) THEN
              XSTEP = ETA*MAX(ABS(XTEMP),1.0D0)

          ELSE
              XSTEP = -ETA*MAX(ABS(XTEMP),1.0D0)
          END IF

          X(IVAR) = XTEMP + XSTEP
          XSTEP = X(IVAR) - XTEMP
          CALL FUNDER(NF,X,FTEMP,GF)
          NFG = NFG + 1
*
*     NUMERICAL DIFFERENTIATION
*
          DO 10 J = 1,NF
              IJ = IND(IVAR,J)
              IF (J.GE.IVAR) THEN
                  HF(IJ) = (GF(J)-GO(J))/XSTEP

              ELSE
                  HF(IJ) = 0.5D0* (HF(IJ)+ (GF(J)-GO(J))/XSTEP)
              END IF

   10     CONTINUE
          X(IVAR) = XTEMP
   20 CONTINUE
      CALL MXVCOP(NF,GO,GF)
      RETURN

      END
* SUBROUTINE PDDXQ1             ALL SYSTEMS                   91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DUAL RANGE SPACE QUADRATIC PROGRAMMING METHOD FOR MINIMAX
* APPROXIMATION.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  AF(NA)  VECTOR CONTAINING VALUES OF THE APPROXIMATED
*         FUNCTIONS.
*  RO  AFD(NA)  VECTOR CONTAINING INCREMENTS OF THE APPROXIMATED
*         FUNCTIONS.
*  II  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  IO  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RI  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         APPROXIMATED FUNCTIONS.
*  RO  AR((NF+1)*(NF+2)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RO  AZ(NF+1)  VECTOR OF LAGRANGE MULTIPLIERS.
*  RI  CF(NF)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RO  G(NF+1)  GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RU  H(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OR INVERSION OF THE
*         HESSIAN MATRIX APPROXIMATION.
*  RO  S(NF+1)  DIRECTION VECTOR.
*  RI  F  VALUE OF THE OBJECTIVE FUNCTION.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*  IU  IDECF  DECOMPOSITION INDICATOR. IDECF=0-NO DECOMPOSITION.
*         IDECF=1-GILL-MURRAY DECOMPOSITION. IDECF=9-INVERSION.
*         IDECF=10-DIAGONAL MATRIX.
*  RI  ETA0  MACHINE PRECISION.
*  RI  ETA2  TOLERANCE FOR POSITIVE DEFINITENESS OF THE HESSIAN MATRIX.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RI  EPS9  TOLERANCE FOR ACTIVITY OF CONSTRAINTS.
*  RI  TOLG  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RO  UMAX  MAXIMUM LAGRANGE MULTIPLIER.
*  RO  GMAX  MAXIMUM PARTIAL DERIVATIVE.
*  RO  GNORM  NORM OF THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RO  SNORM  NORM OF THE DIRECTION VECTOR.
*  RO  XNORM  VALUE OF LINEARIZED MINIMAX FUNCTION.
*  IO  N  DIMENSION OF MANIFOLD DEFINED BY ACTIVE CONSTRAINTS.
*  IO  ITERQ  TYPE OF FEASIBLE POINT. ITERQ=1-ARBITRARY FEASIBLE POINT.
*         ITERQ=2-OPTIMUM FEASIBLE POINT. ITERQ=-1 FEASIBLE POINT DOES
*         NOT EXISTS. ITERQ=-2 OPTIMUM FEASIBLE POINT DOES NOT EXISTS.
*  IO  ITERD  TYPE OF DIRECTION VECTOR. ITERD=1-CORRECT DIRECTION
*         VECTOR. ITERD=<0-FAILURE IN QUADRATIC PROGRAMMING.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* SUBPROGRAMS USED :
*  S   PLQDF1  DUAL RANGE SPACE QUADRATIC PROGRAMMING METHOD FOR
*         MINIMAX APPROXIMATION WITH LINEAR CONSTRAINTS.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*  RF  MXVMAX  L-INFINITY NORM OF A VECTOR.
*
      SUBROUTINE PDDXQ1(NF,NA,NC,X,IX,XL,XU,AF,AFD,IA,IAA,AG,AR,AZ,CF,
     +                  IC,CL,CU,CG,G,H,S,F,KBF,KBC,IDECF,ETA0,ETA2,
     +                  ETA9,EPS7,EPS9,TOLG,UMAX,GMAX,GNORM,SNORM,XNORM,
     +                  N,ITERQ,ITERD,ITERM)
*
*     SPECIAL QUADRATIC PROGRAMMING SUBROUTINE
*
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,EPS9,ETA0,ETA2,ETA9,F,GMAX,GNORM,SNORM,TOLG,
     +                 UMAX,XNORM
      INTEGER IDECF,ITERD,ITERM,ITERQ,KBC,KBF,N,NA,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AFD(*),AG(*),AR(*),AZ(*),CF(*),CG(*),CL(*),
     +                 CU(*),G(*),H(*),S(*),X(*),XL(*),XU(*)
      INTEGER IA(*),IAA(*),IC(*),IX(*)
C     ..
C     .. Local Scalars ..
      INTEGER MFP
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT,MXVMAX
      EXTERNAL MXVDOT,MXVMAX
C     ..
C     .. External Subroutines ..
      EXTERNAL PLQDF1
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MIN,SQRT
C     ..
      MFP = 2
      CALL PLQDF1(NF,NA,NC,X,IX,XL,XU,AF,AFD,IA,IAA,AG,AR,AZ,CF,IC,CL,
     +            CU,CG,G,H,S,MFP,KBF,KBC,IDECF,ETA0,ETA2,ETA9,EPS7,
     +            EPS9,XNORM,UMAX,GMAX,N,ITERQ)
      IF (ITERQ.LT.0) THEN
          ITERD = ITERQ - 10
          RETURN

      END IF

      ITERD = 1
*
*     COMPUTATION OF VALUES FOR TERMINATION CRITERIA
*
      GMAX = MXVMAX(NF,G)
      GNORM = SQRT(MXVDOT(NF,G,G))
      SNORM = SQRT(MXVDOT(NF,S,S))
      IF (GMAX.LE.1.0D-2*TOLG* (MIN(1.0D0,ABS(F)))) THEN
          ITERM = 4
      END IF

      RETURN

      END
* SUBROUTINE PDDBQ1             ALL SYSTEMS                   96/12/01
* PORTABILITY : ALL SYSTEMS
* 96/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
* DUAL RANGE SPACE QUADRATIC PROGRAMMING METHOD FOR MINIMAX
* APPROXIMATION AND BUNDLE UPDATING.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RU  F  COMPUTED VALUE OF THE OBJECTIVE FUNCTION.
*  RI  FO  PREVIOUS VALUE OF THE OBJECTIVE FUNCTION.
*  RU  FP  CURRENT MINIMUM VALUE OF THE OBJECTIVE FUNCTION.
*  RO  FUB  COMPARED VALUE OF THE OBJECTIVE FUNCTION.
*  RU  AF(4*NA)  VECTOR OF BUNDLE VALUES.
*  RO  AFD(NA)  VECTOR CONTAINING INCREMENTS OF BUNDLE FUNCTIONS.
*  IU  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  IO  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RU  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE BUNDLE GRADIENTS.
*  RO  AR((NF+1)*(NF+2)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RO  AZ(NF+1)  VECTOR OF LAGRANGE MULTIPLIERS.
*  RI  CF(NF)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RI  G(NF)  SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RU  H(NF)  DIAGONAL MATRIX OF WEIGHT PARAMETERS.
*  RU  S(NF+1)  DIRECTION VECTOR.
*  RI  XO(NF)  INCREMENT VECTOR.
*  RU  GO(NF+1)  GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RA  XS(NF)  AUXILIARY VECTOR.
*  RA  GS(NF)  AUXILIARY VECTOR.
*  RO  P  VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RO  R  VALUE OF THE STEPSIZE PARAMETER.
*  RO  RP  VALUE OF THE STEPSIZE PARAMETER CORRESPONDING TO THE
*         CURRENT MINIMUM VALUE OF THE OBJECTIVE FUNCTION.
*  RU  TO  WEIGHT PARAMETER.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*  IU  IDECF  DECOMPOSITION INDICATOR. IDECF=0-NO DECOMPOSITION.
*         IDECF=1-GILL-MURRAY DECOMPOSITION. IDECF=9-INVERSION.
*         IDECF=10-DIAGONAL MATRIX.
*  RI  ETA0  MACHINE PRECISION.
*  RI  ETA2  TOLERANCE FOR POSITIVE DEFINITENESS OF THE HESSIAN MATRIX.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RI  EPS9  TOLERANCE FOR ACTIVITY OF CONSTRAINTS.
*  RI  TOLF  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*  RI  TOLG  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RI  ETA  DISTANCE MEASURE PARAMETER.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF A NEGATIVE LAGRANGE MULTIPLIER.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  RO  GNORM  NORM OF THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RO  SNORM  NORM OF THE DIRECTION VECTOR.
*  RA  XNORM  AUXILIARY VARIABLE.
*  IO  N  DIMENSION OF MANIFOLD DEFINED BY ACTIVE CONSTRAINTS.
*  IU  MAL  CURRENT BUNDLE DIMENSION.
*  II  NIT  ACTUAL NUMBER OF ITERATIONS.
*  II  MOS  WEIGHT UPDATING METHOD SPECIFICATION. MOS=1-QUADRATIC
*         INTERPOLATION (MES2=1) OR LOCAL MINIMUM LOCALIZATION (MES2=2).
*         MOS=2-QUASI-NEWTON CONDITION.
*  IU  NTESF  ACTUAL NUMBER OF TESTS ON FUNCTION DECREASE.
*  IU  NTESX  ACTUAL NUMBER OF TESTS ON STEPLENGTH.
*  IO  ITERQ  TYPE OF FEASIBLE POINT. ITERQ=1-ARBITRARY FEASIBLE POINT.
*         ITERQ=2-OPTIMUM FEASIBLE POINT. ITERQ=-1 FEASIBLE POINT DOES
*         NOT EXISTS. ITERQ=-2 OPTIMUM FEASIBLE POINT DOES NOT EXISTS.
*  IO  ITERD  TERMINATION INDICATOR. ITERD<0-BAD DECOMPOSITION.
*         ITERD=0-DESCENT DIRECTION. ITERD=1-NEWTON LIKE STEP.
*         ITERD=2-INEXACT NEWTON LIKE STEP. ITERD=3-BOUNDARY STEP.
*         ITERD=4-DIRECTION WITH THE NEGATIVE CURVATURE.
*         ITERD=5-MARQUARDT STEP.
*  IO  ITERS  TERMINATION INDICATOR. ITERS=0-ZERO STEP. ITERS=1-PERFECT
*         LINE SEARCH. ITERS=2 GOLDSTEIN STEPSIZE. ITERS=3-CURRY
*         STEPSIZE. ITERS=4-EXTENDED CURRY STEPSIZE.
*         ITERS=5-ARMIJO STEPSIZE. ITERS=6-FIRST STEPSIZE.
*         ITERS=7-MAXIMUM STEPSIZE. ITERS=8-UNBOUNDED FUNCTION.
*         ITERS=9-SHORT STEP. ITERS=10-ZERO STEP.
*         ITERS=-1-MRED REACHED. ITERS=-2-POSITIVE DIRECTIONAL
*         DERIVATIVE. ITERS=-3-ERROR IN INTERPOLATION.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* SUBPROGRAMS USED :
*  S   PLQDF1  DUAL RANGE SPACE QUADRATIC PROGRAMMING METHOD FOR MINIMAX
*              APPROXIMATION WITH LINEAR CONSTRAINTS.
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVSET  INITIATION OF A VECTOR.
*
      SUBROUTINE PDDBQ1(NF,NA,NC,X,IX,XL,XU,F,FO,FP,FUB,AF,AFD,IA,IAA,
     +                  AG,AR,AZ,CF,IC,CL,CU,CG,G,H,S,XO,GO,XS,GS,P,R,
     +                  RP,TO,KBF,KBC,IDECF,ETA0,ETA2,ETA9,EPS7,EPS9,
     +                  TOLF,TOLG,ETA,UMAX,GMAX,GNORM,SNORM,XNORM,N,MAL,
     +                  NIT,MOS,NTESF,NTESX,ITERQ,ITERD,ITERS,ITERM)
*
*     INITIALIZATION
*
C     .. Parameters ..
      DOUBLE PRECISION HALF,ONE,ZERO
      PARAMETER (HALF=5.0D-1,ONE=1.0D0,ZERO=0.0D0)
C     ..
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,EPS9,ETA,ETA0,ETA2,ETA9,F,FO,FP,FUB,GMAX,
     +                 GNORM,P,R,RP,SNORM,TO,TOLF,TOLG,UMAX,XNORM
      INTEGER IDECF,ITERD,ITERM,ITERQ,ITERS,KBC,KBF,MAL,MOS,N,NA,NC,NF,
     +        NIT,NTESF,NTESX
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AFD(*),AG(*),AR(*),AZ(*),CF(*),CG(*),CL(*),
     +                 CU(*),G(*),GO(*),GS(*),H(*),S(*),X(*),XL(*),
     +                 XO(*),XS(*),XU(*)
      INTEGER IA(*),IAA(*),IC(*),IX(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION DELF,FS,FU,PU,TOS,WK
      INTEGER I,IND,K,KA,L,MFP
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT,MXVMAX,MXVNM2
      EXTERNAL MXVDOT,MXVMAX,MXVNM2
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVCOP,MXVDIR,MXVSET,PLQDF1
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN,SQRT
C     ..
C     .. Save statement ..
      SAVE DELF,FU,PU,TOS,WK,IND
C     ..
      IF (NIT.LE.1) THEN
          CALL MXVCOP(NF,G,GO)
          CALL MXVCOP(NF,GO,AG(1))
          CALL MXVSET(NF,ZERO,S)
          SNORM = ZERO
          RP = ZERO
          R = ZERO
          FP = F
          FU = ZERO
          PU = ZERO
          IA(1) = 2
          MAL = 0
          WK = ZERO
          IND = 0
          TO = ONE
          TOS = ONE
          IDECF = 10
      END IF
*
*     MATRIX UPDATE
*
      IF (MOS.EQ.2) THEN
          IF (IND.GE.1 .AND. ITERS.NE.9 .AND. NIT.GT.3) THEN
              WK = MXVDOT(NF,XS,XS)
              FS = (MXVDOT(NF,GO,XS)-MXVDOT(NF,GS,XS))/WK
              WK = MXVNM2(NF,GO,GS)/SQRT(WK)
              TOS = MIN(MAX(ABS(FS),1D-3),1D3)
              IF (FS.LT.WK*1D-3) TOS = MIN(MAX(WK,1D-3),1D4)
              IND = IND + 1
          END IF

          TO = TOS
          IF (ITERS.EQ.5) THEN
              CALL MXVCOP(NF,XO,XS)
              CALL MXVCOP(NF,GO,GS)
              IND = 1 + MIN(1,IND)
          END IF

      END IF

      CALL MXVSET(NF,TO,H)
*
*     BUNDLE VALUES UPDATE
*
      FS = F
      IF (ITERS.GE.9) FS = FS - (R-RP)*P
      K = 1
      DO 10 KA = 1,MAL
          AF(NA+NA+KA) = AF(NA+NA+KA) + RP*SNORM
          IF (IA(KA).GT.0) THEN

          ELSE IF (IA(KA).LT.0) THEN
              AFD(KA) = MXVDOT(NF,AG(K),S)
          END IF

          K = K + NF
   10 CONTINUE
      CALL MXVDIR(MAL,RP,AFD,AF(NA+1),AF(NA+1))
      PU = PU + RP*SNORM
      FU = FU + RP*MXVDOT(NF,AG,S)
*
*     BUNDLE REDUCTION
*
      DO 30 L = MAL,1,-1
          IF (IA(L).NE.0) GO TO 30
          K = (L-1)*NF + 1
          DO 20 KA = L,MAL - 1
              AF(NA+KA) = AF(NA+KA+1)
              AF(NA+NA+KA) = AF(NA+NA+KA+1)
              AF(NA*3+KA) = AF(NA*3+KA+1)
              IA(KA) = IA(KA+1)
              CALL MXVCOP(NF,AG(K+NF),AG(K))
              K = K + NF
   20     CONTINUE
          MAL = MAL - 1
   30 CONTINUE
      IF (MAL.GE.NA) THEN
          K = NF + 1
          DO 40 KA = 2,MAL - 1
              AF(NA+KA) = AF(NA+KA+1)
              AF(NA+NA+KA) = AF(NA+NA+KA+1)
              AF(NA*3+KA) = AF(NA*3+KA+1)
              IA(KA) = IA(KA+1)
              CALL MXVCOP(NF,AG(K+NF),AG(K))
              K = K + NF
   40     CONTINUE
          MAL = MAL - 1
      END IF
*
*     BUNDLE COMPLETION
*
      MAL = MAX(2,MAL+1)
      K = (MAL-1)*NF + 1
      AF(NA+1) = FU
      AF(NA+MAL) = FS
      AF(NA+NA+1) = PU
      AF(NA+NA+MAL) = (R-RP)*SNORM
      AF(NA*3+MAL) = SQRT(MXVDOT(NF,G,G))
      DO 50 KA = 1,MAL
          AF(KA) = -MAX(ABS(AF(NA+KA)-FP),ETA*AF(NA+NA+KA)**2)
   50 CONTINUE
      CALL MXVCOP(NF,G,AG(K))
      IA(MAL) = 2
*
*     MAIN STOPPING CRITERION
*
      F = FP
      IF (ITERS.LE.0) F = FO
      IF (MOS.EQ.1) WK = HALF* (SNORM*TO)**2 +
     +                   5D2*MAX(ABS(FU-FP),PU*PU)/ (ABS(FP)+1D-3)
      IF (MOS.EQ.2) WK = HALF*GNORM*SNORM +
     +                   5D1*MAX(ABS(FU-FP),ETA*PU*PU)/ (ABS(FP)+1D-3)
      IF (NIT.LE.1) WK = ONE
      IF (WK.LE.TOLG) THEN
          ITERM = 4
          NIT = NIT - 1
          GO TO 100

      END IF
*
*     PREPARATION FOR QUADRATIC PROGRAMMING
*
      IF (NTESX.GT.0 .AND. NTESX.LT.NTESF) NTESF = NTESX
      IF (NIT.LE.1) DELF = ONE
      IF (FO.NE.F) DELF = ABS(FO-F)/MAX(ABS(F),ONE)
      MFP = 2
   60 CALL PLQDF1(NF,MAL,NC,X,IX,XL,XU,AF,AFD,IA,IAA,AG,AR,AZ,CF,IC,CL,
     +            CU,CG,GO,H,S,MFP,KBF,KBC,IDECF,ETA0,ETA2,ETA9,EPS7,
     +            EPS9,XNORM,UMAX,GMAX,N,ITERQ)
      IF (ITERQ.LT.0) THEN
          ITERD = -2
          GO TO 80

      END IF

      ITERD = 1
      GMAX = MXVMAX(NF,GO)
      GNORM = SQRT(MXVDOT(NF,GO,GO))
      SNORM = SQRT(MXVDOT(NF,S,S))
      IF (DELF.LE.TOLF .OR. ABS(FO-F)/MAX(ABS(F),ONE).GT.ONE) THEN

      ELSE IF (GNORM.LT.TOLG*TOLG*MXVMAX(MAL-1,AF(NA*3+2))) THEN
*
*     REDEFINE BUNDLE FOR TOO SMALL DIRECTION VECTOR
*
          I = MAL
          DO 70 KA = MAL,1,-1
              IF (IA(KA).LT.0) I = KA
   70     CONTINUE
          IF (I.EQ.MAL) GO TO 80
          IA(I) = 0
          GO TO 60

      END IF

   80 CONTINUE
*
*     AGGREGATION
*
      FU = ZERO
      PU = ZERO
      DO 90 KA = 1,NF - N
          L = IAA(KA)
          IF (L.GT.NC) THEN
              L = L - NC
              IF (L.GT.0) FU = FU - AZ(KA)*AF(NA+L)
              IF (L.GT.0) PU = PU - AZ(KA)*AF(NA+NA+L)
          END IF

   90 CONTINUE
      CALL MXVCOP(NF,GO,AG(1))
*
*     PREPARATION FOR UYTRXD.I - TEST VALUES DETERMINATION
*
  100 FUB = FP
      RETURN

      END
* SUBROUTINE PDDBQ2             ALL SYSTEMS                   96/12/01
* PORTABILITY : ALL SYSTEMS
* 96/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
* DUAL RANGE SPACE QUADRATIC PROGRAMMING METHOD FOR MINIMAX
* APPROXIMATION AND BUNDLE UPDATING
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  MAXIMUM BUNDLE DIMENSION.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RU  F  COMPUTED VALUE OF THE OBJECTIVE FUNCTION.
*  RI  FO  PREVIOUS VALUE OF THE OBJECTIVE FUNCTION.
*  RU  FP  CURRENT MINIMUM VALUE OF THE OBJECTIVE FUNCTION.
*  RO  FUB  COMPARED VALUE OF THE OBJECTIVE FUNCTION.
*  RU  AF(5*NA)  VECTOR OF BUNDLE VALUES.
*  RO  AFD(NA)  VECTOR CONTAINING INCREMENTS OF BUNDLE FUNCTIONS.
*  IU  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  IO  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RU  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE BUNDLE GRADIENTS.
*  RO  AR((NF+1)*(NF+2)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RO  AZ(NF+1)  VECTOR OF LAGRANGE MULTIPLIERS.
*  RI  CF(NF)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RI  G(NF)  SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RI  H(NF*(NF+1)/2)  AGGREGATE HESSIAN MATRIX.
*  RI  HF(NF*(NF+1)/2)  HESSIAN MATRIX OF THE OBJECTIVE FUNCTION.
*  RU  AH(NF*(NF+1)/2*NA)  FIELD CONTAINING BUNDLE HESSIAN MATRICES.
*  RU  S(NF+1)  DIRECTION VECTOR.
*  RU  GO(NF+1)  GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RO  P  VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RO  R  VALUE OF THE STEPSIZE PARAMETER.
*  RO  RP  VALUE OF THE STEPSIZE PARAMETER CORRESPONDING TO THE
*         CURRENT MINIMUM VALUE OF THE OBJECTIVE FUNCTION.
*  II  MFP  TYPE OF FEASIBLE POINT. MFP=1-ARBITRARY FEASIBLE POINT.
*         MFP=2-OPTIMUM FEASIBLE POINT.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*  IU  IDECF  DECOMPOSITION INDICATOR. IDECF=0-NO DECOMPOSITION.
*         IDECF=1-GILL-MURRAY DECOMPOSITION. IDECF=9-INVERSION.
*         IDECF=10-DIAGONAL MATRIX.
*  RI  ETA0  MACHINE PRECISION.
*  RI  ETA2  TOLERANCE FOR POSITIVE DEFINITENESS OF THE HESSIAN MATRIX.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RI  EPS9  TOLERANCE FOR ACTIVITY OF CONSTRAINTS.
*  RI  TOLF  TOLERANCE FOR CHANGE OF FUNCTION VALUES.
*  RI  TOLG  TOLERANCE FOR THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RI  ETA  DISTANCE MEASURE PARAMETER.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF A NEGATIVE LAGRANGE MULTIPLIER.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  RO  GNORM  NORM OF THE GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RO  SNORM  NORM OF THE DIRECTION VECTOR.
*  RA  XNORM  AUXILIARY VARIABLE.
*  IO  N  DIMENSION OF MANIFOLD DEFINED BY ACTIVE CONSTRAINTS.
*  IU  MAL  CURRENT BUNDLE DIMENSION.
*  II  NIT  ACTUAL NUMBER OF ITERATIONS.
*  II  MOS  EXPONENT FOR DISTANCE MEASURE.
*  IU  NTESF  ACTUAL NUMBER OF TESTS ON FUNCTION DECREASE.
*  IU  NTESX  ACTUAL NUMBER OF TESTS ON STEPLENGTH.
*  IO  ITERQ  TYPE OF FEASIBLE POINT. ITERQ=1-ARBITRARY FEASIBLE POINT.
*         ITERQ=2-OPTIMUM FEASIBLE POINT. ITERQ=-1 FEASIBLE POINT DOES
*         NOT EXISTS. ITERQ=-2 OPTIMUM FEASIBLE POINT DOES NOT EXISTS.
*  IO  ITERD  TERMINATION INDICATOR. ITERD<0-BAD DECOMPOSITION.
*         ITERD=0-DESCENT DIRECTION. ITERD=1-NEWTON LIKE STEP.
*         ITERD=2-INEXACT NEWTON LIKE STEP. ITERD=3-BOUNDARY STEP.
*         ITERD=4-DIRECTION WITH THE NEGATIVE CURVATURE.
*         ITERD=5-MARQUARDT STEP.
*  IO  ITERS  TERMINATION INDICATOR. ITERS=0-ZERO STEP. ITERS=1-PERFECT
*         LINE SEARCH. ITERS=2 GOLDSTEIN STEPSIZE. ITERS=3-CURRY
*         STEPSIZE. ITERS=4-EXTENDED CURRY STEPSIZE.
*         ITERS=5-ARMIJO STEPSIZE. ITERS=6-FIRST STEPSIZE.
*         ITERS=7-MAXIMUM STEPSIZE. ITERS=8-UNBOUNDED FUNCTION.
*         ITERS=9-SHORT STEP. ITERS=10-ZERO STEP.
*         ITERS=-1-MRED REACHED. ITERS=-2-POSITIVE DIRECTIONAL
*         DERIVATIVE. ITERS=-3-ERROR IN INTERPOLATION.
*  IO  ITERM  CAUSE OF TERMINATION.
*
* SUBPROGRAMS USED :
*  SE  FUNDER  OBJECTIVE FUNCTION AND SUBGRADIENT EVALUATION.
*  S   PLQDF1  DUAL RANGE SPACE QUADRATIC PROGRAMMING METHOD FOR MINIMAX
*              APPROXIMATION WITH LINEAR CONSTRAINTS.
*  S   MXPDGF  GILL-MURRAY DECOMPOSITION OF A DENSE SYMMETRIC MATRIX.
*  S   MXPDGB  BACK SUBSTITUTION AFTER GILL-MURRAY DECOMPOSITION.
*  S   MXDPRB  BACK SUBSTITUTION AFTER CHOLESKI DECOMPOSITION.
*  S   MXDSMM  MATRIX VECTOR PRODUCT.
*  RF  MXDSMQ  VALUE OF A QUADRATIC FORM WITH A DENSE SYMMETRIC MATRIX.
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVINA  ABSOLUTE VALUES OF ELEMENTS OF INTEGER VECTOR.
*  S   MXVINV  CHANGE OF INTEGER VECTOR AFTER CONSTRAINT ADDITION.
*  RF  MXVMAX  L-INFINITY NORM OF A VECTOR.
*  S   MXVNEG  COPYING OF A VECTOR WITH CHANGE OF THE SIGN.
*  S   MXVSET  INITIATION OF A VECTOR.
*
      SUBROUTINE PDDBQ2(NF,NA,NC,X,IX,XL,XU,F,FO,FP,FUB,AF,AFD,IA,IAA,
     +                  AG,AR,AZ,CF,IC,CL,CU,CG,G,H,HF,AH,S,GO,P,R,RP,
     +                  KBF,KBC,IDECF,ETA0,ETA2,ETA9,EPS7,EPS9,TOLF,
     +                  TOLG,ETA,UMAX,GMAX,GNORM,SNORM,XNORM,N,MAL,NIT,
     +                  MOS,NTESF,NTESX,ITERQ,ITERD,ITERS,ITERM)
C     .. Parameters ..
      DOUBLE PRECISION HALF,ONE,ZERO
      PARAMETER (HALF=5D-1,ONE=1D0,ZERO=0D0)
C     ..
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,EPS9,ETA,ETA0,ETA2,ETA9,F,FO,FP,FUB,GMAX,
     +                 GNORM,P,R,RP,SNORM,TOLF,TOLG,UMAX,XNORM
      INTEGER IDECF,ITERD,ITERM,ITERQ,ITERS,KBC,KBF,MAL,MOS,N,NA,NC,NF,
     +        NIT,NTESF,NTESX
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AFD(*),AG(*),AH(*),AR(*),AZ(*),CF(*),CG(*),
     +                 CL(*),CU(*),G(*),GO(*),H(*),HF(*),S(*),X(*),
     +                 XL(*),XU(*)
      INTEGER IA(*),IAA(*),IC(*),IX(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION DELF,FS,FU,FV,PP,PU,PV,WK
      INTEGER I,IND,IPOC,J,K,KA,L,MFP,NFF
      LOGICAL LA,LQ
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXDSMQ,MXVDOT,MXVMAX
      EXTERNAL MXDSMQ,MXVDOT,MXVMAX
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDSMM,MXVCOP,MXVDIR,MXVSET,PLQDF1
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,SQRT
C     ..
C     .. Save statement ..
      SAVE DELF,FS,FU,PU,PP,WK,IND,IPOC
C     ..
      NFF = NF* (NF+1)/2
      I = NA*4
*
*     INITIALIZATION
*
      IF (NIT.LE.1) THEN
          CALL MXVCOP(NF,G,GO)
          CALL MXVCOP(NF,GO,AG)
          CALL MXVCOP(NFF,HF,H)
          CALL MXVCOP(NFF,HF,AH)
          CALL MXVSET(NF,ZERO,S)
          AF(I+1) = ZERO
          GNORM = ZERO
          SNORM = ZERO
          RP = ZERO
          R = ZERO
          FP = F
          FU = ZERO
          PU = ZERO
          IA(1) = 2
          MAL = 0
          IPOC = 0
          IND = 0
          WK = ZERO
      END IF
*
*     NULL STEPS COUNTER
*
      IPOC = IPOC + 1
      IF (ITERS.NE.10) IPOC = 0
      LQ = IPOC .LE. 3
*
*     BUNDLE VALUES  s, f  LINEAR UPDATE
*
      K = 1
      DO 10 KA = 1,MAL
          AF(NA+NA+KA) = AF(NA+NA+KA) + RP*SNORM
          IF (IA(KA).GT.0) THEN

          ELSE IF (IA(KA).LT.0) THEN
              AFD(KA) = MXVDOT(NF,AG(K),S)
          END IF

          K = K + NF
   10 CONTINUE
      CALL MXVDIR(MAL,RP,AFD,AF(NA+1),AF(NA+1))
      PU = PU + RP*SNORM
      FU = FU + RP*MXVDOT(NF,AG,S)
*
*     DAMPING PARAMETER  ro (PP)  DETERMINATION
*
      FS = F
      PP = ONE
      IF (RP.NE.R) THEN
          FS = FS + (RP-R)*P
          FV = FS + HALF* (RP-R)**2*MXDSMQ(NF,HF,S,S)
          LA = (FV.GT.FS) .AND. (FV.GT.FP)
          IF (LA) PP = MAX(ZERO, (FP-FS)/ (FV-FS))
          IF (LQ) FS = FS + PP* (FV-FS)

      ELSE IF (IND.GT.1) THEN
          PV = AF(NA+IND)
          FV = PV + HALF*R*R*MXDSMQ(NF,AH((IND-1)*NFF+1),S,S)
          LA = (FV.GT.PV) .AND. (FV.GT.FP)
          IF (LA) PP = MAX(ZERO, (FP-PV)/ (FV-PV))
      END IF
*
*     BUNDLE VALUES  f  QUADRATIC UPDATE
*
      PV = MXDSMQ(NF,AH,S,S)
      CALL MXVCOP(NFF,H,AH)
      DO 20 KA = 1,MAL
          AF(NA+KA) = AF(NA+KA) + AF(I+KA)*HALF*RP*RP*
     +                MXDSMQ(NF,AH(1+ (KA-1)*NFF),S,S)
   20 CONTINUE
      IF (RP.EQ.R .AND. IND.GT.1) AF(I+IND) = PP
*
*     FU  CORRECTION - COMPUTATION WITH NEW AGGREGATE MATRIX
*
      FU = FU + AF(I+1)*HALF*RP*RP* (MXDSMQ(NF,AH,S,S)* (ONE+WK)-WK*PV)
*
*     BUNDLE REDUCTION
*
      DO 40 L = MAL,1,-1
          IF (IA(L).NE.0) GO TO 40
          K = (L-1)*NF + 1
          DO 30 KA = L,MAL - 1
              AF(NA+KA) = AF(NA+KA+1)
              AF(NA+NA+KA) = AF(NA+NA+KA+1)
              AF(NA*3+KA) = AF(NA*3+KA+1)
              AF(I+KA) = AF(I+KA+1)
              IA(KA) = IA(KA+1)
              CALL MXVCOP(NF,AG(K+NF),AG(K))
              CALL MXVCOP(NFF,AH(L*NFF+1),AH(L*NFF+1-NFF))
              K = K + NF
   30     CONTINUE
          IND = IND - 1
          MAL = MAL - 1
   40 CONTINUE
      IF (MAL.GE.NA) THEN
          K = 1 + NF
          L = 1 + NFF
          DO 50 KA = 2,MAL - 1
              AF(NA+KA) = AF(NA+KA+1)
              AF(NA+NA+KA) = AF(NA+NA+KA+1)
              AF(NA*3+KA) = AF(NA*3+KA+1)
              AF(I+KA) = AF(I+KA+1)
              IA(KA) = IA(KA+1)
              CALL MXVCOP(NF,AG(K+NF),AG(K))
              CALL MXVCOP(NFF,AH(L+NFF),AH(L))
              K = K + NF
              L = L + NFF
   50     CONTINUE
          IND = IND - 1
          MAL = MAL - 1
      END IF
*
*     BUNDLE COMPLETION
*
      MAL = MAX(2,MAL+1)
      K = (MAL-1)*NF + 1
      L = (MAL-1)*NFF + 1
      AF(NA+1) = FU
      AF(NA+MAL) = FS
      AF(NA+NA+1) = PU
      AF(NA+NA+MAL) = (R-RP)*SNORM
      AF(NA*3+MAL) = SQRT(MXVDOT(NF,G,G))
      AF(I+1) = ONE
      DO 60 KA = 1,MAL
          AF(KA) = -MAX(ABS(AF(NA+KA)-FP),ETA*ABS(AF(NA+NA+KA))**MOS)
   60 CONTINUE
      DO 70 KA = 0,MAL - 2
          CALL MXDSMM(NF,AH(1+KA*NFF),S,AH(L))
          CALL MXVDIR(NF,RP*AF(I+KA+1),AH(L),AG(1+KA*NF),AG(1+KA*NF))
   70 CONTINUE
      CALL MXVCOP(NF,G,AG(K))
      IF (R.EQ.RP) THEN
          AF(I+MAL) = ONE
          IND = MAL

      ELSE
          AF(I+MAL) = PP
          IF (.NOT.LQ) AF(I+MAL) = ZERO
          CALL MXDSMM(NF,HF,S,AH(L))
          CALL MXVDIR(NF, (RP-R)*AF(I+MAL),AH(L),AG(K),AG(K))
      END IF

      CALL MXVCOP(NFF,HF,AH(L))
      IA(MAL) = 2
*
*     MAIN STOPPING CRITERION - SEE ALSO UYFUT4.I
*
      F = FP
      IF (ITERS.LE.0) F = FO
      WK = HALF*GNORM*SNORM + 5D1*MAX(ABS(FU-FP),ETA*PU*PU)/
     +     (ABS(FP)+1D-3)
      IF (NIT.LE.1) WK = ONE
      IF (WK.LE.TOLG) THEN
          ITERM = 4
          NIT = NIT - 1
          RETURN

      END IF

      CALL MXVCOP(NFF,H,HF)
*
*     PREPARATION FOR QUADRATIC PROGRAMMING
*
      IF (NTESX.GT.0 .AND. NTESX.LT.NTESF) NTESF = NTESX
      IF (NIT.LE.1) DELF = ONE
      IF (FO.NE.F) DELF = ABS(FO-F)/MAX(ABS(F),ONE)
      MFP = 2
   80 CALL PLQDF1(NF,MAL,NC,X,IX,XL,XU,AF,AFD,IA,IAA,AG,AR,AZ,CF,IC,CL,
     +            CU,CG,GO,HF,S,MFP,KBF,KBC,IDECF,ETA0,ETA2,ETA9,EPS7,
     +            EPS9,XNORM,UMAX,GMAX,N,ITERQ)
      IF (ITERQ.LT.0) THEN
          ITERD = -2
          GO TO 100

      END IF

      ITERD = 1
      GMAX = MXVMAX(NF,GO)
      GNORM = SQRT(MXVDOT(NF,GO,GO))
      SNORM = SQRT(MXVDOT(NF,S,S))
      IF (DELF.LE.TOLF .OR. ABS(FO-F)/MAX(ABS(F),ONE).GT.ONE) THEN

      ELSE IF (GNORM.LT.TOLG*TOLG*MXVMAX(MAL-1,AF(NA*3+2))) THEN
*
*     REDEFINE BUNDLE FOR TOO SMALL DIRECTION VECTOR
*
          J = MAL
          DO 90 KA = MAL,1,-1
              IF (IA(KA).LT.0) J = KA
   90     CONTINUE
          IF (J.EQ.MAL) GO TO 100
          IA(J) = 0
          GO TO 80

      END IF

  100 CONTINUE
*
*     AGGREGATION
*
      FU = ZERO
      PU = ZERO
      IF (NF.GT.N) CALL MXVSET(NFF,ZERO,H)
      K = 0
      DO 110 KA = 1,NF - N
          L = IAA(KA)
          IF (L.GT.NC) THEN
              L = L - NC
              FU = FU - AZ(KA)*AF(NA+L)
              PU = PU - AZ(KA)*AF(NA+NA+L)
              CALL MXVDIR(NFF,-AZ(KA)*AF(I+L),AH((L-1)*NFF+1),H,H)
              IF (L.EQ.1) K = KA
          END IF

  110 CONTINUE
      IDECF = 0
      CALL MXVCOP(NF,GO,AG)
*
*     CORRECTION FACTOR FOR  FU  (FIRST LAGRANGE MULTIPLIER, IF ACTIVE)
*
      WK = ZERO
      IF (K.GT.0) WK = -AZ(K)
*
*     PREPARATION FOR UYTRXD.I - TEST VALUES DETERMINATION
*
      FUB = FP
      RETURN

      END
* SUBROUTINE PLQDF1             ALL SYSTEMS                   91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DUAL RANGE SPACE QUADRATIC PROGRAMMING METHOD FOR MINIMAX
* APPROXIMATION WITH LINEAR CONSTRAINTS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NA  NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  AF(NA)  VECTOR CONTAINING VALUES OF THE APPROXIMATED
*         FUNCTIONS.
*  RO  AFD(NA)  VECTOR CONTAINING INCREMENTS OF THE APPROXIMATED
*         FUNCTIONS.
*  II  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  IO  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RI  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         APPROXIMATED FUNCTIONS.
*  RO  AR((NF+1)*(NF+2)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RO  AZ(NF+1)  VECTOR OF LAGRANGE MULTIPLIERS.
*  RI  CF(NF)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RO  G(NF+1)  GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RU  H(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OR INVERSION OF THE
*         HESSIAN MATRIX APPROXIMATION.
*  RO  S(NF+1)  DIRECTION VECTOR.
*  II  MFP  TYPE OF FEASIBLE POINT. MFP=1-ARBITRARY FEASIBLE POINT.
*         MFP=2-OPTIMUM FEASIBLE POINT. MFP=3-REPEATED SOLUTION.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*  IU  IDECF  DECOMPOSITION INDICATOR. IDECF=0-NO DECOMPOSITION.
*         IDECF=1-GILL-MURRAY DECOMPOSITION. IDECF=9-INVERSION.
*         IDECF=10-DIAGONAL MATRIX.
*  RI  ETA0  MACHINE PRECISION.
*  RI  ETA2  TOLERANCE FOR POSITIVE DEFINITENESS OF THE HESSIAN MATRIX.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RI  EPS9  TOLERANCE FOR ACTIVITY OF CONSTRAINTS.
*  RO  XNORM  VALUE OF LINEARIZED MINIMAX FUNCTION.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF A NEGATIVE LAGRANGE MULTIPLIER.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  IO  N  DIMENSION OF MANIFOLD DEFINED BY ACTIVE CONSTRAINTS.
*  IO  ITERQ  TYPE OF FEASIBLE POINT. ITERQ=1-ARBITRARY FEASIBLE POINT.
*         ITERQ=2-OPTIMUM FEASIBLE POINT. ITERQ=-1 FEASIBLE POINT DOES
*         NOT EXISTS. ITERQ=-2 OPTIMUM FEASIBLE POINT DOES NOT EXISTS.
*
* SUBPROGRAMS USED :
*  S   PLMINA  DETERMINATION OF THE NEW ACTIVE FUNCTION.
*  S   PLMINL  DETERMINATION OF THE NEW ACTIVE LINEAR CONSTRAINT.
*  S   PLMINS  DETERMINATION OF THE NEW ACTIVE SIMPLE BOUND.
*  S   PLMINT  DETERMINATION OF THE NEW ACTIVE TRUST REGION BOUND.
*  S   PLADF1  CONSTRAINT ADDITION.
*  S   PLRMF0  CONSTRAINT DELETION.
*  S   MXPDGF  GILL-MURRAY DECOMPOSITION OF A DENSE SYMMETRIC MATRIX.
*  S   MXPDGB  BACK SUBSTITUTION AFTER GILL-MURRAY DECOMPOSITION.
*  S   MXDPRB  BACK SUBSTITUTION AFTER CHOLESKI DECOMPOSITION.
*  S   MXDSMM  MATRIX VECTOR PRODUCT.
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVINA  ABSOLUTE VALUES OF ELEMENTS OF INTEGER VECTOR.
*  S   MXVINV  CHANGE OF INTEGER VECTOR AFTER CONSTRAINT ADDITION.
*  S   MXVNEG  COPYING OF A VECTOR WITH CHANGE OF THE SIGN.
*  S   MXVSET  INITIATION OF A VECTOR.
*
* L.LUKSAN: DUAL METHOD FOR SOLVING A SPECIAL PROBLEM OF QUADRATIC
* PROGRAMMING AS A SUBPROBLEM AT LINEARLY CONSTRAINED NONLINEAR MINIMAX
* APPROXIMATION. kYBERNETIKA 20 (1984) 445-457.
*
      SUBROUTINE PLQDF1(NF,NA,NC,X,IX,XL,XU,AF,AFD,IA,IAA,AG,AR,AZ,CF,
     +                  IC,CL,CU,CG,G,H,S,MFP,KBF,KBC,IDECF,ETA0,ETA2,
     +                  ETA9,EPS7,EPS9,XNORM,UMAX,GMAX,N,ITERQ)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,EPS9,ETA0,ETA2,ETA9,GMAX,UMAX,XNORM
      INTEGER IDECF,ITERQ,KBC,KBF,MFP,N,NA,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AFD(*),AG(*),AR(*),AZ(*),CF(*),CG(*),CL(*),
     +                 CU(*),G(*),H(*),S(*),X(*),XL(*),XU(*)
      INTEGER IA(*),IAA(*),IC(*),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION BET,CON,E,GAM,PAR,SNORM,STEP,STEP1,STEP2,T,TEMP
      INTEGER I,IER,INEW,INF,IOLD,J,K,KA,KC,KNEW,KOLD,KREM,L,NAA,NAR
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT,MXVMAX
      EXTERNAL MXVDOT,MXVMAX
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDPGB,MXDPGF,MXDPRB,MXDSMM,MXVCOP,MXVDIR,MXVINA,MXVINV,
     +         MXVMUL,MXVNEG,MXVSET,PLADF1,PLDLAG,PLMINA,PLMINL,PLMINS,
     +         PLRMF0
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MIN,SIGN
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      T = 1.0D0
      CON = ETA9
      IF (IDECF.LT.0) IDECF = 1
      IF (IDECF.EQ.0) THEN
*
*     GILL-MURRAY DECOMPOSITION
*
          TEMP = ETA2
          CALL MXDPGF(NF,H,INF,TEMP,STEP)
          NDECF = NDECF + 1
          IDECF = 1
      END IF

      IF (IDECF.GE.2 .AND. IDECF.LE.8) THEN
          ITERQ = -10
          RETURN

      END IF
*
*     INITIATION
*
      NRED = 0
      IF (MFP.EQ.3) GO TO 10
      N = NF
      NAA = 0
      NAR = 0
      XNORM = -ETA9
      CALL MXVINA(NA,IA)
      IF (KBF.GT.0) CALL MXVINA(NF,IX)
      IF (KBC.GT.0) CALL MXVINA(NC,IC)
*
*     DIRECTION DETERMINATION
*
   10 CALL MXVSET(NF,0.0D0,S)
      DO 20 J = 1,NAA
          L = IAA(J)
          IF (L.GT.NC) THEN
              L = L - NC
              CALL MXVDIR(NF,AZ(J),AG((L-1)*NF+1),S,S)

          ELSE IF (L.GT.0) THEN
              CALL MXVDIR(NF,AZ(J),CG((L-1)*NF+1),S,S)

          ELSE
              L = -L
              S(L) = S(L) + AZ(J)
          END IF

   20 CONTINUE
      CALL MXVCOP(NF,S,G)
      IF (NAA.GT.0) THEN
          IF (IDECF.EQ.1) THEN
              CALL MXDPGB(NF,H,S,0)

          ELSE IF (IDECF.EQ.9) THEN
              CALL MXDSMM(NF,H,G,S)

          ELSE
              CALL MXVMUL(NF,H,S,S,-1)
          END IF

      END IF
*
*     INITIAL MINIMAX VARIABLE
*
      IF (NAA.EQ.1) THEN
          TEMP = AF(INEW-NC) + MXVDOT(NF,AG((INEW-NC-1)*NF+1),S)
          XNORM = -SIGN(1,KNEW)*TEMP
      END IF
*
*     CHECK OF FEASIBILITY
*
      INEW = 0
      PAR = 0.0D0
      CALL PLMINA(NF,NA,NC,AF,AFD,IA,AG,S,INEW,KNEW,EPS9,XNORM,PAR)
      IF (NAA.GT.0) THEN
          CALL PLMINL(NF,NC,CF,IC,CL,CU,CG,S,KBC,INEW,KNEW,EPS9,PAR)
          CALL PLMINS(NF,IX,X,XL,XU,S,KBF,INEW,KNEW,EPS9,PAR)
      END IF

      IF (INEW.EQ.0) THEN
*
*     SOLUTION ACHIEVED
*
          CALL MXVNEG(NF,G,G)
          ITERQ = 2
          RETURN

      ELSE
          SNORM = 0.0D0
      END IF

   30 IER = 0
*
*     STEPSIZE DETERMINATION
*
      CALL PLADF1(NF,NC,IA,IAA,AG,AR,CG,H,S,G,IDECF,N,INEW,KNEW,IER,
     +            EPS7,GMAX,UMAX,E,T)
      CALL PLDLAG(NF,NC,IA,IAA,S,N,KOLD)
      IF (KOLD.EQ.0) THEN
*
*     ZERO STEPSIZE
*
          STEP1 = 0.0D0
          STEP = STEP1
          SNORM = SIGN(1,KNEW)
          XNORM = XNORM - PAR

      ELSE
*
*     PRIMAL STEPSIZE
*
          CALL MXDPRB(NAA,AR,S,1)
          BET = E - MXVDOT(NAA,S,G)
          GAM = BET/MXVDOT(NAA,S,S)
          UMAX = BET*GAM + UMAX
          IF (UMAX.LE.EPS7*GMAX) THEN
              STEP1 = CON

          ELSE
              STEP1 = -PAR/UMAX
          END IF
*
*     DUAL STEPSIZE
*
          CALL MXDPRB(NAA,AR,S,-1)
          CALL MXDPRB(NAA,AR,G,-1)
          CALL MXVDIR(NAA,GAM,S,G,G)
          IF (KNEW.LT.0) CALL MXVNEG(NAA,G,G)
          STEP = MXVMAX(NAA,G)
          IOLD = 0
          STEP2 = CON
          DO 40 J = 1,NAA
              L = IAA(J)
              IF (L.GT.NC) THEN
                  L = L - NC
                  K = IA(L)

              ELSE IF (L.GT.0) THEN
                  K = IC(L)

              ELSE
                  L = -L
                  K = IX(L)
              END IF

              IF (K.LE.-5) THEN

              ELSE IF ((K.EQ.-1.OR.K.EQ.-3.) .AND. G(J).LE.0.0D0) THEN

              ELSE IF ((K.EQ.-2.OR.K.EQ.-4.) .AND. G(J).GE.0.0D0) THEN

              ELSE IF (ABS(G(J)).LE.ETA0*STEP) THEN

              ELSE
                  TEMP = AZ(J)/G(J)
                  IF (STEP2.GT.TEMP) THEN
                      IOLD = J
                      STEP2 = TEMP
                  END IF

              END IF

   40     CONTINUE
*
*     FINAL STEPSIZE
*
          STEP = MIN(STEP1,STEP2)
          IF (STEP.GE.CON) THEN
*
*     FEASIBLE SOLUTION DOES NOT EXIST
*
              ITERQ = -1
              RETURN

          END IF
*
*     NEW LAGRANGE MULTIPLIERS
*
          CALL MXVDIR(NAA,-STEP,G,AZ,AZ)
          SNORM = SNORM + SIGN(1,KNEW)*STEP
          XNORM = XNORM + SIGN(1,KNEW)*STEP*GAM
          PAR = PAR - (STEP/STEP1)*PAR
      END IF

      IF (STEP.EQ.STEP1) THEN
          IF (N.LT.0) THEN
*
*     IMPOSSIBLE SITUATION
*
              ITERQ = -5
              RETURN

          END IF
*
*     CONSTRAINT ADDITION
*
          IF (IER.EQ.0) THEN
              N = N - 1
              NAA = NAA + 1
              NAR = NAR + NAA
              AZ(NAA) = SNORM
          END IF

          IF (INEW.GT.NC) THEN
              KA = INEW - NC
              CALL MXVINV(IA,KA,KNEW)

          ELSE IF (INEW.GT.0) THEN
              KC = INEW
              CALL MXVINV(IC,KC,KNEW)

          ELSE IF (ABS(KNEW).EQ.1) THEN
              I = -INEW
              CALL MXVINV(IX,I,KNEW)

          ELSE
              I = -INEW
              IF (KNEW.GT.0) IX(I) = -3
              IF (KNEW.LT.0) IX(I) = -4
          END IF

          NRED = NRED + 1
          NADD = NADD + 1
          GO TO 10

      ELSE
*
*     CONSTRAINT DELETION
*
          DO 50 J = IOLD,NAA - 1
              AZ(J) = AZ(J+1)
   50     CONTINUE
          CALL PLRMF0(NF,NC,IX,IA,IAA,AR,IC,G,N,IOLD,KREM,IER)
          NAR = NAR - NAA
          NAA = NAA - 1
          CALL MXVINA(NA,IA)
          IF (KBC.GT.0) CALL MXVINA(NC,IC)
          IF (KBF.GT.0) CALL MXVINA(NF,IX)
          DO 60 J = 1,NAA
              L = IAA(J)
              IF (L.GT.NC) THEN
                  L = L - NC
                  IA(L) = -IA(L)

              ELSE IF (L.GT.0) THEN
                  IC(L) = -IC(L)

              ELSE
                  L = -L
                  IX(L) = -IX(L)
              END IF

   60     CONTINUE
          GO TO 30

      END IF

      END
* SUBROUTINE PLMINA             ALL SYSTEMS                   90/12/01
* PORTABILITY : ALL SYSTEMS
* 90/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF THE NEW ACTIVE FUNCTION.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  NA  NUMBER OF CURRENT LINEAR APPROXIMATED FUNCTIONS.
*  II  NC  NUMBER OF CURRENT LINEAR CONSTRAINTS.
*  RI  AF(NA)  VECTOR CONTAINING VALUES OF THE APPROXIMATED
*         FUNCTIONS.
*  RO  AFD(NA)  VECTOR CONTAINING INCREMENTS OF THE APPROXIMATED
*         FUNCTIONS.
*  II  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  RI  AG(NF*NA)  VECTOR CONTAINING SCALING PARAMETERS.
*  RI  S(NF)  DIRECTION VECTOR.
*  IO  INEW  INDEX OF THE NEW ACTIVE FUNCTION.
*  IO  KNEW  SIGNUM OF THE NEW ACTIVE GRADIENT.
*  RI  EPS9  TOLERANCE FOR ACTIVE FUNCTIONS.
*  RO  XNORM  VALUE OF LINEARIZED MINIMAX FUNCTION.
*  RA  PAR  AUXILIARY VARIABLE.
*
* SUBPROGRAMS USED :
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*
      SUBROUTINE PLMINA(NF,NA,NC,AF,AFD,IA,AG,S,INEW,KNEW,EPS9,XNORM,
     +                  PAR)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS9,PAR,XNORM
      INTEGER INEW,KNEW,NA,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AFD(*),AG(*),S(*)
      INTEGER IA(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION POM,TEMP
      INTEGER JCG,KA
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN
C     ..
      JCG = 1
      DO 10 KA = 1,NA
          IF (IA(KA).GT.0) THEN
              TEMP = MXVDOT(NF,AG(JCG),S)
              AFD(KA) = TEMP
              TEMP = AF(KA) + TEMP
              IF (IA(KA).EQ.1 .OR. IA(KA).GE.3) THEN
                  POM = XNORM + TEMP
                  IF (POM.LT.MIN(PAR,-EPS9*MAX(ABS(XNORM),1.0D0))) THEN
                      INEW = KA + NC
                      KNEW = 1
                      PAR = POM
                  END IF

              END IF

              IF (IA(KA).EQ.2 .OR. IA(KA).GE.3) THEN
                  POM = XNORM - TEMP
                  IF (POM.LT.MIN(PAR,-EPS9*MAX(ABS(XNORM),1.0D0))) THEN
                      INEW = KA + NC
                      KNEW = -1
                      PAR = POM
                  END IF

              END IF

          END IF

          JCG = JCG + NF
   10 CONTINUE
      RETURN

      END
* SUBROUTINE PLMINL             ALL SYSTEMS                   90/12/01
* PORTABILITY : ALL SYSTEMS
* 90/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF THE NEW ACTIVE LINEAR CONSTRAINT.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  NC  NUMBER OF CONSTRAINTS.
*  RI  CF(NC)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RI  S(NF)  DIRECTION VECTOR.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*  IO  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*  IO  KNEW  SIGNUM OF THE NEW ACTIVE NORMAL.
*  RI  EPS9  TOLERANCE FOR ACTIVE CONSTRAINTS.
*  RA  PAR  AUXILIARY VARIABLE.
*
* SUBPROGRAMS USED :
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*
      SUBROUTINE PLMINL(NF,NC,CF,IC,CL,CU,CG,S,KBC,INEW,KNEW,EPS9,PAR)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS9,PAR
      INTEGER INEW,KBC,KNEW,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CG(*),CL(*),CU(*),S(*)
      INTEGER IC(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION POM,TEMP
      INTEGER JCG,KC
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN
C     ..
      IF (KBC.GT.0) THEN
          JCG = 1
          DO 10 KC = 1,NC
              IF (IC(KC).GT.0) THEN
                  TEMP = CF(KC) + MXVDOT(NF,CG(JCG),S)
                  IF (IC(KC).EQ.1 .OR. IC(KC).GE.3) THEN
                      POM = TEMP - CL(KC)
                      IF (POM.LT.MIN(PAR,-EPS9*MAX(ABS(CL(KC)),
     +                    1.0D0))) THEN
                          INEW = KC
                          KNEW = 1
                          PAR = POM
                      END IF

                  END IF

                  IF (IC(KC).EQ.2 .OR. IC(KC).GE.3) THEN
                      POM = CU(KC) - TEMP
                      IF (POM.LT.MIN(PAR,-EPS9*MAX(ABS(CU(KC)),
     +                    1.0D0))) THEN
                          INEW = KC
                          KNEW = -1
                          PAR = POM
                      END IF

                  END IF

              END IF

              JCG = JCG + NF
   10     CONTINUE
      END IF

      RETURN

      END
* SUBROUTINE PLMINS             ALL SYSTEMS                   91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF THE NEW ACTIVE SIMPLE BOUND.
*
* PARAMETERS :
*  II  NF DECLARED NUMBER OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RI  XO(NF)  SAVED VECTOR OF VARIABLES.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  S(NF)  DIRECTION VECTOR.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  IO  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*  IO  KNEW  SIGNUM OF THE NEW NORMAL.
*  RI  EPS9  TOLERANCE FOR ACTIVE CONSTRAINTS.
*  RA  PAR  AUXILIARY VARIABLE.
*
      SUBROUTINE PLMINS(NF,IX,XO,XL,XU,S,KBF,INEW,KNEW,EPS9,PAR)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS9,PAR
      INTEGER INEW,KBF,KNEW,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION S(*),XL(*),XO(*),XU(*)
      INTEGER IX(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION POM,TEMP
      INTEGER I
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN
C     ..
      IF (KBF.GT.0) THEN
          DO 10 I = 1,NF
              IF (IX(I).GT.0) THEN
                  TEMP = 1.0D0
                  IF (IX(I).EQ.1 .OR. IX(I).GE.3) THEN
                      POM = XO(I) + S(I)*TEMP - XL(I)
                      IF (POM.LT.MIN(PAR,-EPS9*MAX(ABS(XL(I)),
     +                    TEMP))) THEN
                          INEW = -I
                          KNEW = 1
                          PAR = POM
                      END IF

                  END IF

                  IF (IX(I).EQ.2 .OR. IX(I).GE.3) THEN
                      POM = XU(I) - S(I)*TEMP - XO(I)
                      IF (POM.LT.MIN(PAR,-EPS9*MAX(ABS(XU(I)),
     +                    TEMP))) THEN
                          INEW = -I
                          KNEW = -1
                          PAR = POM
                      END IF

                  END IF

              END IF

   10     CONTINUE
      END IF

      RETURN

      END
* SUBROUTINE PLDLAG               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* VECTOR OF LAGRANGE MULTIPLIERS FOR DUAL QP METHOD IS DETERMINED.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  NC  NUMBER OF LINEARIZED CONSTRAINTS.
*  II  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  II  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RO  AZ(NF+1)  OUTPUT VECTOR.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  IA  KOLD  AUXILIARY VARIABLE.
*
      SUBROUTINE PLDLAG(NF,NC,IA,IAA,AZ,N,KOLD)
C     .. Scalar Arguments ..
      INTEGER KOLD,N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AZ(*)
      INTEGER IA(*),IAA(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER J,L,NAA
C     ..
      NAA = NF - N
      KOLD = 0
      DO 10 J = 1,NAA
          L = IAA(J)
          IF (L.GT.NC) THEN
              L = L - NC
              TEMP = 1.0D0
              IF (IA(L).EQ.-2 .OR. IA(L).EQ.-4) TEMP = -TEMP
              AZ(J) = TEMP
              KOLD = 1

          ELSE
              AZ(J) = 0.0D0
          END IF

   10 CONTINUE
      RETURN

      END
* SUBROUTINE PLADF1               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* TRIANGULAR DECOMPOSITION OF KERNEL OF THE GENERAL PROJECTION
* IS UPDATED AFTER FUNCTION OR CONSTRAINT ADDITION.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  NC  NUMBER OF LINEARIZED CONSTRAINTS.
*  II  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  IU  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RI  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE GRADIENTS OF THE LINEAR
*          APPROXIMATED FUNCTIONS.
*  RU  AR((NF+1)*(NF+2)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF
*        THE ORTHOGONAL PROJECTION.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RI  H(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OR INVERSION OF THE
*         HESSIAN MATRIX APPROXIMATION.
*  RA  S(NF+1)  AUXILIARY VECTOR.
*  RO  G(NF+1)  VECTOR USED IN THE DUAL RANGE SPACE QUADRATIC
*        PROGRAMMING METHOD.
*  IU  IDECF  DECOMPOSITION INDICATOR. IDECF=0-NO DECOMPOSITION.
*         IDECF=1-GILL-MURRAY DECOMPOSITION. IDECF=9-INVERSION.
*         IDECF=10-DIAGONAL MATRIX.
*  IU  N  ACTUAL NUMBER OF VARIABLES.
*  II  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*  II  KNEW  SIGNUM OF THE NEW ACTIVE GRADIENT.
*  IO  IER  ERROR INDICATOR.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF A NEGATIVE LAGRANGE MULTIPLIER.
*  RO  E  AUXILIARY VARIABLE.
*  RI  T  AUXILIARY VARIABLE.
*
* SUBPROGRAMS USED :
*  S   MXPDGB  BACK SUBSTITUTION AFTER GILL-MURRAY DECOMPOSITION.
*  S   MXDPRB  BACK SUBSTITUTION AFTER CHOLESKI DECOMPOSITION.
*  S   MXDSMM  MATRIX-VECTOR PRODUCT.
*  S   MXDSMV  COPYING OF A ROW OF DENSE SYMMETRIC MATRIX.
*  S   MXVCOP  COPYING OF A VECTOR.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*
      SUBROUTINE PLADF1(NF,NC,IA,IAA,AG,AR,CG,H,S,G,IDECF,N,INEW,KNEW,
     +                  IER,EPS7,GMAX,UMAX,E,T)
C     .. Scalar Arguments ..
      DOUBLE PRECISION E,EPS7,GMAX,T,UMAX
      INTEGER IDECF,IER,INEW,KNEW,N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AG(*),AR(*),CG(*),G(*),H(*),S(*)
      INTEGER IA(*),IAA(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION POM,TEMP
      INTEGER J,JAG,JOB,K,L,NAA,NAR
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDPGB,MXDPRB,MXDSMM,MXDSMV,MXVCOP,MXVMUL,MXVSET
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC SIGN,SQRT
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      JOB = 1
      E = 0.0D0
      IF (INEW.GT.NC) E = SIGN(1,KNEW)
      IER = 0
      IF (JOB.EQ.0 .AND. N.LT.0) IER = 2
      IF (INEW.EQ.0) IER = 3
      IF (IDECF.GE.2 .AND. IDECF.LE.8) IER = -2
      IF (IER.NE.0) RETURN
      NAA = NF - N
      NAR = NAA* (NAA+1)/2
      IF (INEW.GT.NC) THEN
          JAG = (INEW-NC-1)*NF + 1
          IF (IDECF.EQ.1) THEN
              CALL MXVCOP(NF,AG(JAG),S)
              CALL MXDPGB(NF,H,S,0)

          ELSE IF (IDECF.EQ.9) THEN
              CALL MXDSMM(NF,H,AG(JAG),S)

          ELSE
              CALL MXVCOP(NF,AG(JAG),S)
              CALL MXVMUL(NF,H,S,S,-1)
          END IF

          GMAX = MXVDOT(NF,AG(JAG),S) + T

      ELSE IF (INEW.GT.0) THEN
          JAG = (INEW-1)*NF + 1
          IF (IDECF.EQ.1) THEN
              CALL MXVCOP(NF,CG(JAG),S)
              CALL MXDPGB(NF,H,S,0)

          ELSE IF (IDECF.EQ.9) THEN
              CALL MXDSMM(NF,H,CG(JAG),S)

          ELSE
              CALL MXVCOP(NF,CG(JAG),S)
              CALL MXVMUL(NF,H,S,S,-1)
          END IF

          GMAX = MXVDOT(NF,CG(JAG),S)

      ELSE
          K = -INEW
          IF (IDECF.EQ.1) THEN
              CALL MXVSET(NF,0.0D0,S)
              S(K) = 1.0D0
              CALL MXDPGB(NF,H,S,0)

          ELSE IF (IDECF.EQ.9) THEN
              CALL MXDSMV(NF,H,S,K)

          ELSE
              CALL MXVSET(NF,0.0D0,S)
              S(K) = 1.0D0/H(K)
          END IF

          GMAX = S(K)
      END IF

      IF (NAA.GT.0) THEN
          POM = T*E
          DO 10 J = 1,NAA
              L = IAA(J)
              IF (L.GT.NC) THEN
                  L = L - NC
                  G(J) = MXVDOT(NF,AG((L-1)*NF+1),S)
                  IF (INEW.GT.NC) THEN
                      TEMP = POM
                      IF (IA(L).EQ.-2 .OR. IA(L).EQ.-4) TEMP = -TEMP
                      G(J) = G(J) + TEMP
                  END IF

              ELSE IF (L.GT.0) THEN
                  G(J) = MXVDOT(NF,CG((L-1)*NF+1),S)

              ELSE
                  L = -L
                  G(J) = S(L)
              END IF

   10     CONTINUE
      END IF

      IF (N.LT.0) THEN
          CALL MXDPRB(NAA,AR,G,1)
          UMAX = 0.0D0
          IER = 2
          RETURN

      ELSE IF (NAA.EQ.0) THEN
          UMAX = GMAX

      ELSE
          CALL MXDPRB(NAA,AR,G,1)
          UMAX = GMAX - MXVDOT(NAA,G,G)
          CALL MXVCOP(NAA,G,AR(NAR+1))
      END IF

      IF (UMAX.LE.EPS7*GMAX) THEN
          IER = 1
          RETURN

      ELSE
          NAA = NAA + 1
          NAR = NAR + NAA
          IAA(NAA) = INEW
          AR(NAR) = SQRT(UMAX)
          IF (JOB.EQ.0) THEN
              N = N - 1
              NADD = NADD + 1
          END IF

      END IF

      RETURN

      END
* SUBROUTINE PLRMF0             ALL SYSTEMS                   91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* OPERATIONS AFTER CONSTRAINT DELETION.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  NC  NUMBER OF CONSTRAINTS.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  II  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  IU  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RU  AR((NF+1)*(NF+2)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RA  S(NF+1)  AUXILIARY VECTOR.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  IOLD  INDEX OF THE OLD ACTIVE CONSTRAINT.
*  IO  KREM  AUXILIARY VARIABLE.
*  IO  IER  ERROR INDICATOR.
*
* SUBPROGRAMS USED :
*  S   PLRMR0  CORRECTION OF KERNEL OF THE ORTHOGONAL PROJECTION
*         AFTER CONSTRAINT DELETION.
*
      SUBROUTINE PLRMF0(NF,NC,IX,IA,IAA,AR,IC,S,N,IOLD,KREM,IER)
C     .. Scalar Arguments ..
      INTEGER IER,IOLD,KREM,N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AR(*),S(*)
      INTEGER IA(*),IAA(*),IC(*),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER L
C     ..
C     .. External Subroutines ..
      EXTERNAL PLRMR0
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      CALL PLRMR0(NF,IAA,AR,S,N,IOLD,KREM,IER)
      N = N + 1
      NREM = NREM + 1
      L = IAA(NF-N+1)
      IF (L.GT.NC) THEN
          L = L - NC
          IA(L) = -IA(L)

      ELSE IF (L.GT.0) THEN
          IC(L) = -IC(L)

      ELSE
          L = -L
          IX(L) = -IX(L)
      END IF

      RETURN

      END
* SUBROUTINE PLRMR0               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* TRIANGULAR DECOMPOSITION OF KERNEL OF THE ORTHOGONAL PROJECTION IS
* UPDATED AFTER CONSTRAINT DELETION.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  IU  ICA(NF)  VECTOR CONTAINING INDICES OF ACTIVE CONSTRAINTS.
*  RU  CR(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RA  G(NF)  AUXILIARY VECTOR.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  IOLD  INDEX OF THE OLD ACTIVE CONSTRAINT.
*  IO  KREM  AUXILIARY VARIABLE.
*  IO  IER  ERROR INDICATOR.
*
* SUBPROGRAMS USED :
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVORT  DETERMINATION OF AN ELEMENTARY ORTHOGONAL MATRIX FOR
*         PLANE ROTATION.
*  S   MXVROT  PLANE ROTATION OF A VECTOR.
*  S   MXVSET  INITIATION OF A VECTOR.
*
      SUBROUTINE PLRMR0(NF,ICA,CR,G,N,IOLD,KREM,IER)
C     .. Scalar Arguments ..
      INTEGER IER,IOLD,KREM,N,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CR(*),G(*)
      INTEGER ICA(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION CK,CL
      INTEGER I,J,K,KC,L,NCA
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVCOP,MXVORT,MXVROT,MXVSET
C     ..
      NCA = NF - N
      IF (IOLD.LT.NCA) THEN
          K = IOLD* (IOLD-1)/2
          KC = ICA(IOLD)
          CALL MXVCOP(IOLD,CR(K+1),G)
          CALL MXVSET(NCA-IOLD,0.0D0,G(IOLD+1))
          K = K + IOLD
          DO 20 I = IOLD + 1,NCA
              K = K + I
              CALL MXVORT(CR(K-1),CR(K),CK,CL,IER)
              CALL MXVROT(G(I-1),G(I),CK,CL,IER)
              L = K
              DO 10 J = I,NCA - 1
                  L = L + J
                  CALL MXVROT(CR(L-1),CR(L),CK,CL,IER)
   10         CONTINUE
   20     CONTINUE
          K = IOLD* (IOLD-1)/2
          DO 30 I = IOLD,NCA - 1
              L = K + I
              ICA(I) = ICA(I+1)
              CALL MXVCOP(I,CR(L+1),CR(K+1))
              K = L
   30     CONTINUE
          ICA(NCA) = KC
          CALL MXVCOP(NCA,G,CR(K+1))
      END IF

      KREM = 1
      RETURN

      END
* SUBROUTINE PLADB0               ALL SYSTEMS                97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* NEW LINEAR CONSTRAINT OR A NEW SIMPLE BOUND IS ADDED TO THE
* ACTIVE SET.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  IU  N  ACTUAL NUMBER OF VARIABLES.
*  IU  ICA(NF)  VECTOR CONTAINING INDICES OF ACTIVE CONSTRAINTS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RU  CR(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RU  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM THE
*         CURRENT REDUCED SUBSPACE.
*  RA  S(NF)  AUXILIARY VECTOR.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF A NEGATIVE LAGRANGE MULTIPLIER.
*  II  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*  IU  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  IER  ERROR INDICATOR.
*
* SUBPROGRAMS USED :
*  S   PLADR0  CORRECTION OF KERNEL OF THE ORTHOGONAL PROJECTION
*         AFTER CONSTRAINT ADDITION.
*  S   MXDRMM  PREMULTIPLICATION OF A VECTOR BY A ROWWISE STORED DENSE
*         RECTANGULAR MATRIX.
*  S   MXDRMV  COPY OF THE SELECTED COLUMN OF A ROWWISE STORED DENSE
*         RECTANGULAR MATRIX.
*  S   MXDRGR  PLANE ROTATION OF A TRANSPOSED DENSE RECTANGULAR MATRIX.
*  S   MXVORT  DETERMINATION OF AN ELEMENTARY ORTHOGONAL MATRIX FOR
*         PLANE ROTATION.
*
      SUBROUTINE PLADB0(NF,N,ICA,CG,CR,CZ,S,EPS7,GMAX,UMAX,INEW,NADD,
     +                  IER)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,GMAX,UMAX
      INTEGER IER,INEW,N,NADD,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CG(*),CR(*),CZ(*),S(*)
      INTEGER ICA(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION CK,CL
      INTEGER K,L,N1
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDRGR,MXDRMM,MXDRMV,MXVORT,PLADR0
C     ..
      CALL PLADR0(NF,N,ICA,CG,CR,S,EPS7,GMAX,UMAX,INEW,NADD,IER)
      IF (IER.NE.0) RETURN
      IF (N.GT.0) THEN
          N1 = N + 1
          IF (INEW.GT.0) THEN
              CALL MXDRMM(NF,N1,CZ,CG((INEW-1)*NF+1),S)

          ELSE
              CALL MXDRMV(NF,N1,CZ,S,-INEW)
          END IF

          DO 10 L = 1,N
              K = L + 1
              CALL MXVORT(S(K),S(L),CK,CL,IER)
              CALL MXDRGR(NF,CZ,K,L,CK,CL,IER)
              IF (IER.LT.0) RETURN
   10     CONTINUE
      END IF

      IER = 0
      RETURN

      END
* SUBROUTINE PLADB4               ALL SYSTEMS                97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* NEW LINEAR CONSTRAINT OR A NEW SIMPLE BOUND IS ADDED TO THE ACTIVE
* SET. TRANSFORMED HESSIAN MATRIX APPROXIMATION OR ITS INVERSION
* IS UPDATED.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  IU  N  ACTUAL NUMBER OF VARIABLES.
*  IU  ICA(NF)  VECTOR CONTAINING INDICES OF ACTIVE CONSTRAINTS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RU  CR(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RU  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM THE
*         CURRENT REDUCED SUBSPACE.
*  RU  H(NF*(NF+1)/2)  TRANSFORMED HESSIAN MATRIX APPROXIMATION OR
*         ITS INVERSION.
*  RA  S(NF)  AUXILIARY VECTOR.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF A NEGATIVE LAGRANGE MULTIPLIER.
*  IU  IDECF  DECOMPOSITION INDICATOR. IDECF=0-NO DECOMPOSITION.
*         IDECF=1-GILL-MURRAY DECOMPOSITION. IDECF=9-INVERSION.
*         IDECF=10-DIAGONAL MATRIX.
*  II  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*  IU  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  IER  ERROR INDICATOR.
*
* SUBPROGRAMS USED :
*  S   PLADR0  CORRECTION OF KERNEL OF THE ORTHOGONAL PROJECTION
*         AFTER CONSTRAINT ADDITION.
*  S   MXDRMM  PREMULTIPLICATION OF A VECTOR BY A ROWWISE STORED DENSE
*         RECTANGULAR MATRIX.
*  S   MXDRMV  COPY OF THE SELECTED COLUMN OF A ROWWISE STORED DENSE
*         RECTANGULAR MATRIX.
*  S   MXDRGR  PLANE ROTATION OF A TRANSPOSED DENSE RECTANGULAR MATRIX.
*         RECTANGULAR MATRIX.
*  S   MXDSMR  PLANE ROTATION OF A DENSE SYMMETRIC MATRIX.
*  S   MXVORT  DETERMINATION OF AN ELEMENTARY ORTHOGONAL MATRIX FOR
*         PLANE ROTATION.
*
      SUBROUTINE PLADB4(NF,N,ICA,CG,CR,CZ,H,S,EPS7,GMAX,UMAX,IDECF,INEW,
     +                  NADD,IER)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,GMAX,UMAX
      INTEGER IDECF,IER,INEW,N,NADD,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CG(*),CR(*),CZ(*),H(*),S(*)
      INTEGER ICA(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION CK,CL
      INTEGER I,J,K,L,N1
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDRGR,MXDRMM,MXDRMV,MXDSMR,MXVORT,PLADR0
C     ..
      IF (IDECF.NE.0 .AND. IDECF.NE.9) THEN
          IER = -2
          RETURN

      END IF

      CALL PLADR0(NF,N,ICA,CG,CR,S,EPS7,GMAX,UMAX,INEW,NADD,IER)
      IF (IER.NE.0) RETURN
      IF (N.GT.0) THEN
          N1 = N + 1
          IF (INEW.GT.0) THEN
              CALL MXDRMM(NF,N1,CZ,CG((INEW-1)*NF+1),S)

          ELSE
              CALL MXDRMV(NF,N1,CZ,S,-INEW)
          END IF

          DO 10 L = 1,N
              K = L + 1
              CALL MXVORT(S(K),S(L),CK,CL,IER)
              CALL MXDRGR(NF,CZ,K,L,CK,CL,IER)
              CALL MXDSMR(N1,H,K,L,CK,CL,IER)
              IF (IER.LT.0) RETURN
   10     CONTINUE
          IF (IDECF.EQ.9) THEN
              L = N* (N+1)/2
              IF (H(L+N1).NE.0.0D0) THEN
                  CL = 1.0D0/H(L+N1)
                  K = 0
                  DO 30 I = 1,N
                      CK = CL*H(L+I)
                      DO 20 J = 1,I
                          K = K + 1
                          H(K) = H(K) - CK*H(L+J)
   20                 CONTINUE
   30             CONTINUE
              END IF

          END IF

      END IF

      IER = 0
      RETURN

      END
* SUBROUTINE PLADR0               ALL SYSTEMS                97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* TRIANGULAR DECOMPOSITION OF KERNEL OF THE ORTHOGONAL PROJECTION
* IS UPDATED AFTER CONSTRAINT ADDITION.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  IU  N  ACTUAL NUMBER OF VARIABLES.
*  IU  ICA(NF)  VECTOR CONTAINING INDICES OF ACTIVE CONSTRAINTS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RU  CR(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RA  S(NF)  AUXILIARY VECTOR.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF A NEGATIVE LAGRANGE MULTIPLIER.
*  II  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*  IU  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*  IO  IER  ERROR INDICATOR.
*
* SUBPROGRAMS USED :
*  S   MXSPRB  SPARSE BACK SUBSTITUTION.
*  S   MXVCOP  COPYING OF A VECTOR.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*
      SUBROUTINE PLADR0(NF,N,ICA,CG,CR,S,EPS7,GMAX,UMAX,INEW,NADD,IER)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,GMAX,UMAX
      INTEGER IER,INEW,N,NADD,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CG(*),CR(*),S(*)
      INTEGER ICA(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,J,K,L,NCA,NCR
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDPRB,MXVCOP
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC SQRT
C     ..
      IER = 0
      IF (N.LE.0) IER = 2
      IF (INEW.EQ.0) IER = 3
      IF (IER.NE.0) RETURN
      NCA = NF - N
      NCR = NCA* (NCA+1)/2
      IF (INEW.GT.0) THEN
          CALL MXVCOP(NF,CG((INEW-1)*NF+1),S)
          GMAX = MXVDOT(NF,CG((INEW-1)*NF+1),S)
          DO 10 J = 1,NCA
              L = ICA(J)
              IF (L.GT.0) THEN
                  CR(NCR+J) = MXVDOT(NF,CG((L-1)*NF+1),S)

              ELSE
                  I = -L
                  CR(NCR+J) = S(I)
              END IF

   10     CONTINUE

      ELSE
          K = -INEW
          GMAX = 1.0D0
          DO 20 J = 1,NCA
              L = ICA(J)
              IF (L.GT.0) THEN
                  CR(NCR+J) = CG((L-1)*NF+K)*GMAX

              ELSE
                  CR(NCR+J) = 0.0D0
              END IF

   20     CONTINUE
      END IF

      IF (NCA.EQ.0) THEN
          UMAX = GMAX

      ELSE
          CALL MXDPRB(NCA,CR,CR(NCR+1),1)
          UMAX = GMAX - MXVDOT(NCA,CR(NCR+1),CR(NCR+1))
      END IF

      IF (UMAX.LE.EPS7*GMAX) THEN
          IER = 1
          RETURN

      ELSE
          N = N - 1
          NCA = NCA + 1
          NCR = NCR + NCA
          ICA(NCA) = INEW
          CR(NCR) = SQRT(UMAX)
          NADD = NADD + 1
      END IF

      RETURN

      END
* SUBROUTINE PLDIRL               ALL SYSTEMS                   97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF THE NEW VALUES OF THE CONSTRAINT FUNCTIONS.
*
* PARAMETERS :
*  II  NC  NUMBER OF CONSTRAINTS.
*  RU  CF(NF)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  RI  CFD(NF)  VECTOR CONTAINING INCREMENTS OF THE CONSTRAINT
*         FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  STEP  CURRENT STEPSIZE.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*
      SUBROUTINE PLDIRL(NC,CF,CFD,IC,STEP,KBC)
C     .. Scalar Arguments ..
      DOUBLE PRECISION STEP
      INTEGER KBC,NC
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CFD(*)
      INTEGER IC(*)
C     ..
C     .. Local Scalars ..
      INTEGER KC
C     ..
      IF (KBC.GT.0) THEN
          DO 10 KC = 1,NC
              IF (IC(KC).GE.0 .AND. IC(KC).LE.10) THEN
                  CF(KC) = CF(KC) + STEP*CFD(KC)

              ELSE IF (IC(KC).LT.-10) THEN
                  CF(KC) = CF(KC) + STEP*CFD(KC)
              END IF

   10     CONTINUE
      END IF

      RETURN

      END
* SUBROUTINE PLDIRS               ALL SYSTEMS                   97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF THE NEW VECTOR OF VARIABLES.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  RU  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RI  S(NF)  DIRECTION VECTOR.
*  RI  STEP  CURRENT STEPSIZE.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*
      SUBROUTINE PLDIRS(NF,X,IX,S,STEP,KBF)
C     .. Scalar Arguments ..
      DOUBLE PRECISION STEP
      INTEGER KBF,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION S(*),X(*)
      INTEGER IX(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
      DO 10 I = 1,NF
          IF (KBF.LE.0) THEN
              X(I) = X(I) + STEP*S(I)

          ELSE IF (IX(I).GE.0 .AND. IX(I).LE.10) THEN
              X(I) = X(I) + STEP*S(I)

          ELSE IF (IX(I).LT.-10) THEN
              X(I) = X(I) + STEP*S(I)
          END IF

   10 CONTINUE
      RETURN

      END
* SUBROUTINE PLINIT             ALL SYSTEMS                   97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF THE INITIAL POINT WHICH SATISFIES SIMPLE BOUNDS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  RU  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  EPS9  TOLERANCE FOR ACTIVE CONSTRAINTS.
*  IO  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*  IO  IND  INDICATOR. IF IND.NE.0 THEN TRUST REGION BOUNDS CANNOT
*         BE SATISFIED.
*
* SUBPROGRAMS USED :
*  S   PLNEWS  TEST ON ACTIVITY OF A GIVEN SIMPLE BOUND.
*
      SUBROUTINE PLINIT(NF,X,IX,XL,XU,EPS9,KBF,INEW,IND)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS9
      INTEGER IND,INEW,KBF,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),XL(*),XU(*)
      INTEGER IX(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
C     .. External Subroutines ..
      EXTERNAL PLNEWS
C     ..
      IND = 0
      IF (KBF.GT.0) THEN
          DO 10 I = 1,NF
              CALL PLNEWS(X,IX,XL,XU,EPS9,I,INEW)
              IF (IX(I).LT.5) THEN

              ELSE IF (IX(I).EQ.5) THEN
                  IX(I) = -5

              ELSE IF (IX(I).EQ.11 .OR. IX(I).EQ.13) THEN
                  X(I) = XL(I)
                  IX(I) = 10 - IX(I)

              ELSE IF (IX(I).EQ.12 .OR. IX(I).EQ.14) THEN
                  X(I) = XU(I)
                  IX(I) = 10 - IX(I)
              END IF

   10     CONTINUE
      END IF

      RETURN

      END
* SUBROUTINE PLLPB1             ALL SYSTEMS                   97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF THE INITIAL FEASIBLE POINT AND THE LINEAR PROGRAMMING
* SUBROUTINE.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RU  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RO  XO(NF)  SAVED VECTOR OF VARIABLES.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RU  CF(NF)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  RA  CFD(NF)  VECTOR CONTAINING INCREMENTS OF THE CONSTRAINT
*         FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  IO  ICA(NF)  VECTOR CONTAINING INDICES OF ACTIVE CONSTRAINTS.
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RO  CR(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RO  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM THE
*         CURRENT REDUCED SUBSPACE.
*  RI  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  RO  GO(NF)  SAVED GRADIENT OF THE OBJECTIVE FUNCTION.
*  RA  S(NF)  DIRECTION VECTOR.
*  II  MFP  TYPE OF FEASIBLE POINT. MFP=1-ARBITRARY FEASIBLE POINT.
*         MFP=2-OPTIMUM FEASIBLE POINT. MFP=3-REPEATED SOLUTION.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RI  EPS9  TOLERANCE FOR ACTIVITY OF CONSTRAINTS.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF A NEGATIVE LAGRANGE MULTIPLIER.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  IO  N  DIMENSION OF THE MANIFOLD DEFINED BY ACTIVE CONSTRAINTS.
*  IO  ITERL  TYPE OF FEASIBLE POINT. ITERL=1-ARBITRARY FEASIBLE POINT.
*         ITERL=2-OPTIMUM FEASIBLE POINT. ITERL=-1 FEASIBLE POINT DOES
*         NOT EXISTS. ITERL=-2 OPTIMUM FEASIBLE POINT DOES NOT EXISTS.
*
* SUBPROGRAMS USED :
*  S   PLINIT  DETERMINATION OF INITIAL POINT SATISFYING SIMPLE BOUNDS.
*  S   PLMAXL  MAXIMUM STEPSIZE USING LINEAR CONSTRAINTS.
*  S   PLMAXS  MAXIMUM STEPSIZE USING SIMPLE BOUNDS.
*  S   PLMAXT  MAXIMUM STEPSIZE USING TRUST REGION BOUNDS.
*  S   PLNEWL  IDENTIFICATION OF ACTIVE LINEAR CONSTRAINTS.
*  S   PLNEWS  IDENTIFICATION OF ACTIVE SIMPLE BOUNDS.
*  S   PLNEWT  IDENTIFICATION OF ACTIVE TRUST REGION BOUNDS.
*  S   PLDIRL  NEW VALUES OF CONSTRAINT FUNCTIONS.
*  S   PLDIRS  NEW VALUES OF VARIABLES.
*  S   PLSETC  INITIAL VALUES OF CONSTRAINT FUNCTIONS.
*  S   PLSETG  DETERMINATION OF THE FIRST PHASE GRADIENT VECTOR.
*  S   PLTRBG  DETERMINATION OF LAGRANGE MULTIPLIERS AND COMPUTATION
*  S   PLADB0  CONSTRAINT ADDITION.
*  S   PLRMB0  CONSTRAINT DELETION.
*  S   MXDCMM  PREMULTIPLICATION OF A VECTOR BY A DENSE RECTANGULAR
*         MATRIX STORED BY COLUMNS.
*  S   MXDRMM  PREMULTIPLICATION OF A VECTOR BY A DENSE RECTANGULAR
*         MATRIX STORED BY ROWS.
*  S   MXDSMI  DETERMINATION OF THE INITIAL UNIT DENSE SYMMETRIC
*         MATRIX.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVINA  ABSOLUTE VALUES OF ELEMENTS OF AN INTEGER VECTOR.
*  S   MXVINC  UPDATE OF AN INTEGER VECTOR.
*  S   MXVIND  CHANGE OF THE INTEGER VECTOR FOR CONSTRAINT ADDITION.
*  S   MXVINT  CHANGE OF THE INTEGER VECTOR FOR TRUST REGION BOUND
*         ADDITION.
*  S   MXVMUL  DIAGONAL PREMULTIPLICATION OF A VECTOR.
*  S   MXVNEG  COPYING OF A VECTOR WITH CHANGE OF THE SIGN.
*  S   MXVSET  INITIATION OF A VECTOR.
*
      SUBROUTINE PLLPB1(NF,NC,X,IX,XO,XL,XU,CF,CFD,IC,ICA,CL,CU,CG,CR,
     +                  CZ,G,GO,S,MFP,KBF,KBC,ETA9,EPS7,EPS9,UMAX,GMAX,
     +                  N,ITERL)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,EPS9,ETA9,GMAX,UMAX
      INTEGER ITERL,KBC,KBF,MFP,N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CFD(*),CG(*),CL(*),CR(*),CU(*),CZ(*),G(*),
     +                 GO(*),S(*),X(*),XL(*),XO(*),XU(*)
      INTEGER IC(*),ICA(*),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION CON,DMAX,POM
      INTEGER I,IER,INEW,IOLD,IPOM,K,KC,KREM,NCA,NCR,NCZ
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDCMM,MXDRMM,MXDSMI,MXVCOP,MXVINA,MXVIND,MXVNEG,MXVSET,
     +         PLADB0,PLDIRL,PLDIRS,PLINIT,PLMAXL,PLMAXS,PLNEWL,PLNEWS,
     +         PLRMB0,PLSETC,PLSETG,PLTRBG
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      CON = ETA9
*
*     INITIATION
*
      CALL MXVCOP(NF,X,XO)
      IPOM = 0
      NRED = 0
      KREM = 0
      ITERL = 1
      DMAX = 0.0D0
      IF (MFP.EQ.3) GO TO 40
      IF (KBF.GT.0) CALL MXVINA(NF,IX)
*
*     SHIFT OF VARIABLES FOR SATISFYING SIMPLE BOUNDS
*
      CALL PLINIT(NF,X,IX,XL,XU,EPS9,KBF,INEW,ITERL)
      IF (ITERL.LT.0) THEN
          GO TO 60

      END IF

      N = 0
      NCA = 0
      NCZ = 0
      DO 10 I = 1,NF
          IF (KBF.GT.0 .AND. IX(I).LT.0) THEN
              NCA = NCA + 1
              ICA(NCA) = -I

          ELSE
              N = N + 1
              CALL MXVSET(NF,0.0D0,CZ(NCZ+1))
              CZ(NCZ+I) = 1.0D0
              NCZ = NCZ + NF
          END IF

   10 CONTINUE
      CALL MXDSMI(NCA,CR)
      IF (NC.GT.0) THEN
          CALL MXDRMM(NF,NC,CG,X,CF)
*
*     ADDITION OF ACTIVE CONSTRAINTS AND INITIAL CHECK OF FEASIBILITY
*
          CALL MXVINA(NC,IC)
          IF (NF.GT.N) CALL PLSETC(NF,NC,X,XO,CF,IC,CG,S)
          DO 20 KC = 1,NC
              IF (IC(KC).NE.0) THEN
                  INEW = 0
                  CALL PLNEWL(KC,CF,IC,CL,CU,EPS9,INEW)
                  CALL PLADB0(NF,N,ICA,CG,CR,CZ,S,EPS7,GMAX,UMAX,INEW,
     +                        NADD,IER)
                  CALL MXVIND(IC,KC,IER)
                  IF (IC(KC).LT.-10) IPOM = 1
              END IF

   20     CONTINUE
      END IF

   30 IF (IPOM.EQ.1) THEN
*
*     CHECK OF FEASIBILITY AND UPDATE OF THE FIRST PHASE OBJECTIVE
*     FUNCTION
*
          CALL PLSETG(NF,NC,IC,CG,GO,INEW)
          IF (INEW.EQ.0) IPOM = 0
      END IF

      IF (IPOM.EQ.0 .AND. ITERL.EQ.0) THEN
*
*     FEASIBILITY ACHIEVED
*
          ITERL = 1
          CALL MXVCOP(NF,G,GO)
          IF (MFP.EQ.1) GO TO 60
      END IF
*
*     LAGRANGE MULTIPLIERS AND REDUCED GRADIENT DETERMINATION
*
   40 CALL PLTRBG(NF,N,NC,IX,IC,ICA,CG,CR,CZ,GO,S,EPS7,GMAX,UMAX,IOLD)
      INEW = 0
      IF (GMAX.EQ.0.0D0) THEN
*
*     OPTIMUM ON A LINEAR MANIFOLD OBTAINED
*
          IF (IOLD.EQ.0) THEN
              IF (IPOM.EQ.0) THEN
*
*     OPTIMAL SOLUTION ACHIEVED
*
                  ITERL = 2
                  GO TO 60

              ELSE
                  IPOM = 0
                  DO 50 KC = 1,NC
                      IF (IC(KC).LT.-10) THEN
                          INEW = 0
                          CALL PLNEWL(KC,CF,IC,CL,CU,EPS9,INEW)
                          IF (IC(KC).LT.-10) IPOM = 1
                      END IF

   50             CONTINUE
                  IF (IPOM.EQ.0) THEN
*
*     OPTIMAL SOLUTION ACHIEVED
*
                      CALL MXVCOP(NF,GO,G)
                      ITERL = 2
                      GO TO 60

                  ELSE
*
*     FEASIBLE SOLUTION DOES NOT EXIST
*
                      CALL MXVCOP(NF,GO,G)
                      ITERL = -1
                      GO TO 60

                  END IF

              END IF

          ELSE
*
*     CONSTRAINT DELETION
*
              CALL PLRMB0(NF,N,ICA,CG,CR,CZ,GO,S,IOLD,KREM,NREM,IER)
              KC = ICA(NF-N+1)
              IF (KC.GT.0) THEN
                  IC(KC) = -IC(KC)

              ELSE
                  K = -KC
                  IX(K) = -IX(K)
              END IF

              DMAX = 0.0D0
              GO TO 40

          END IF

      ELSE
*
*     DIRECTION DETERMINATION
*
          NCA = NF - N
          NCR = NCA* (NCA+1)/2
          CALL MXDCMM(NF,N,CZ,S,CR(NCR+1))
          CALL MXVNEG(NF,CR(NCR+1),S)
*
*     STEPSIZE SELECTION
*
          POM = CON
          CALL PLMAXL(NF,NC,CF,CFD,IC,CL,CU,CG,S,POM,KBC,KREM,INEW)
          CALL PLMAXS(NF,X,IX,XL,XU,S,POM,KBF,KREM,INEW)
          IF (INEW.EQ.0) THEN
              IF (IPOM.EQ.0) THEN
*
*     BOUNDED SOLUTION DOES NOT EXIST
*
                  ITERL = -2

              ELSE
*
*     FEASIBLE SOLUTION DOES NOT EXIST
*
                  ITERL = -3
              END IF

              GO TO 60

          ELSE
*
*     STEP REALIZATION
*
              CALL PLDIRS(NF,X,IX,S,POM,KBF)
              CALL PLDIRL(NC,CF,CFD,IC,POM,KBC)
*
*     CONSTRAINT ADDITION
*
              IF (INEW.GT.0) THEN
                  KC = INEW
                  INEW = 0
                  CALL PLNEWL(KC,CF,IC,CL,CU,EPS9,INEW)
                  CALL PLADB0(NF,N,ICA,CG,CR,CZ,S,EPS7,GMAX,UMAX,INEW,
     +                        NADD,IER)
                  CALL MXVIND(IC,KC,IER)

              ELSE IF (INEW+NF.GE.0) THEN
                  I = -INEW
                  INEW = 0
                  CALL PLNEWS(X,IX,XL,XU,EPS9,I,INEW)
                  CALL PLADB0(NF,N,ICA,CG,CR,CZ,S,EPS7,GMAX,UMAX,INEW,
     +                        NADD,IER)
                  CALL MXVIND(IX,I,IER)
              END IF

              DMAX = POM
              IF (DMAX.GT.0.0D0) NRED = NRED + 1
              GO TO 30

          END IF

      END IF

   60 CONTINUE
      RETURN

      END
* SUBROUTINE PLLPB2             ALL SYSTEMS                   91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF THE INITIAL FEASIBLE POINT AND THE LINEAR PROGRAMMING
* SUBROUTINE.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NC  NUMBER OF LINEAR CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RO  XO(NF)  SAVED VECTOR OF VARIABLES.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  CF(NF)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCYIONS.
*  RO  CFD(NF)  VECTOR CONTAINING INCREMENTS OF THE CONSTRAINT
*         FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  II  ICA(NF)  VECTOR CONTAINING INDICES OF ACTIVE CONSTRAINTS.
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RI  CR(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RO  CZ(NF)  VECTOR OF LAGRANGE MULTIPLIERS.
*  RI  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  RO  GO(NF)  SAVED GRADIENT OF THE OBJECTIVE FUNCTION.
*  RI  S(NF)  DIRECTION VECTOR.
*  II  MFP  TYPE OF FEASIBLE POINT. MFP=1-ARBITRARY FEASIBLE POINT.
*         MFP=2-OPTIMUM FEASIBLE POINT. MFP=3-REPEATED SOLUTION.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RI  EPS9  TOLERANCE FOR ACTIVITY OF CONSTRAINTS.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF A NEGATIVE LAGRANGE MULTIPLIER.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  IO  N  DIMENSION OF THE MANIFOLD DEFINED BY ACTIVE CONSTRAINTS.
*  IO  ITERL  TYPE OF FEASIBLE POINT. ITERL=1-ARBITRARY FEASIBLE POINT.
*         ITERL=2-OPTIMUM FEASIBLE POINT. ITERL=-1 FEASIBLE POINT DOES
*         NOT EXISTS. ITERL=-2 OPTIMUM FEASIBLE POINT DOES NOT EXISTS.
*
* SUBPROGRAMS USED :
*  S   PLINIT  DETERMINATION OF INITIAL POINT SATISFYING SIMPLE BOUNDS.
*  S   PLMAXL  MAXIMUM STEPSIZE USING LINEAR CONSTRAINTS.
*  S   PLMAXS  MAXIMUM STEPSIZE USING SIMPLE BOUNDS.
*  S   PLMAXT  MAXIMUM STEPSIZE USING TRUST REGION BOUNDS.
*  S   PLNEWL  IDENTIFICATION OF ACTIVE LINEAR CONSTRAINTS.
*  S   PLNEWS  IDENTIFICATION OF ACTIVE SIMPLE BOUNDS.
*  S   PLNEWT  IDENTIFICATION OF ACTIVE TRUST REGION BOUNDS.
*  S   PLDIRL  NEW VALUES OF CONSTRAINT FUNCTIONS.
*  S   PLDIRS  NEW VALUES OF VARIABLES.
*  S   PLSETC  INITIAL VALUES OF CONSTRAINT FUNCTIONS.
*  S   PLSETG  DETERMINATION OF THE FIRST PHASE GRADIENT VECTOR.
*  S   PLGLAG  GRADIENT OF THE LAGRANGIAN FUNCTION IS DETERMINED.
*  S   PLSLAG  NEGATIVE PROJECTED GRADIENT IS DETERMINED.
*  S   PLTLAG  THE OPTIMUM LAGRANGE MULTIPLIER IS DETERMINED.
*  S   PLVLAG  AN AUXILIARY VECTOR IS DETERMINED.
*  S   PLADR0  CONSTRAINT ADDITION.
*  S   PLRMF0  CONSTRAINT DELETION.
*  S   MXDPRB  BACK SUBSTITUTION AFTER CHOLESKI DECOMPOSITION.
*  S   MXDSMI  DETERMINATION OF THE INITIAL UNIT DENSE SYMMETRIC
*         MATRIX.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVDIF  DIFFERENCE OF TWO VECTORS.
*  S   MXVINA  ABSOLUTE VALUES OF ELEMENTS OF AN INTEGER VECTOR.
*  S   MXVINC  UPDATE OF AN INTEGER VECTOR.
*  S   MXVIND  CHANGE OF THE INTEGER VECTOR FOR CONSTRAINT ADDITION.
*  S   MXVINT  CHANGE OF THE INTEGER VECTOR FOR TRUST REGION BOUND
*         ADDITION.
*  S   MXVMUL  DIAGONAL PREMULTIPLICATION OF A VECTOR.
*  S   MXVNEG  COPYING OF A VECTOR WITH CHANGE OF THE SIGN.
*  S   MXVSET  INITIATION OF A VECTOR.
*
      SUBROUTINE PLLPB2(NF,NC,X,IX,XO,XL,XU,CF,CFD,IC,ICA,CL,CU,CG,CR,
     +                  CZ,G,GO,S,MFP,KBF,KBC,ETA9,EPS7,EPS9,UMAX,GMAX,
     +                  N,ITERL)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,EPS9,ETA9,GMAX,UMAX
      INTEGER ITERL,KBC,KBF,MFP,N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CFD(*),CG(*),CL(*),CR(*),CU(*),CZ(*),G(*),
     +                 GO(*),S(*),X(*),XL(*),XO(*),XU(*)
      INTEGER IC(*),ICA(*),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION CON,DMAX,POM
      INTEGER I,IER,INEW,IOLD,IPOM,KC,KREM,MODE
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDPRB,MXDSMI,MXVCOP,MXVINA,MXVIND,MXVNEG,PLADR0,PLDIRL,
     +         PLDIRS,PLINIT,PLMAXL,PLMAXS,PLNEWL,PLNEWS,PLRMF0,PLSETC,
     +         PLSETG,PLSLAG,PLTLAG,PLVLAG
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      CON = ETA9
*
*     INITIATION
*
      CALL MXVCOP(NF,X,XO)
      CALL MXVCOP(NF,G,GO)
      IPOM = 0
      NRED = 0
      KREM = 0
      ITERL = 1
      DMAX = 0.0D0
      IF (MFP.EQ.3) GO TO 40
      IF (KBF.GT.0) CALL MXVINA(NF,IX)
*
*     SHIFT OF VARIABLES FOR SATISFYING SIMPLE BOUNDS
*
      CALL PLINIT(NF,X,IX,XL,XU,EPS9,KBF,INEW,ITERL)
      IF (ITERL.LT.0) THEN
          GO TO 60

      END IF

      N = NF
      DO 10 I = 1,NF
          IF (KBF.GT.0 .AND. IX(I).LT.0) THEN
              N = N - 1
              ICA(NF-N) = -I
          END IF

   10 CONTINUE
      CALL MXDSMI(NF-N,CR)
      IF (NC.GT.0) THEN
*
*     ADDITION OF ACTIVE CONSTRAINTS AND INITIAL CHECK OF FEASIBILITY
*
          CALL MXVINA(NC,IC)
          IF (NF.GT.N) CALL PLSETC(NF,NC,X,XO,CF,IC,CG,S)
          DO 20 KC = 1,NC
              IF (IC(KC).NE.0) THEN
                  INEW = 0
                  CALL PLNEWL(KC,CF,IC,CL,CU,EPS9,INEW)
                  CALL PLADR0(NF,N,ICA,CG,CR,S,EPS7,GMAX,UMAX,INEW,NADD,
     +                        IER)
                  CALL MXVIND(IC,KC,IER)
                  IF (IC(KC).LT.-10) IPOM = 1
              END IF

   20     CONTINUE
      END IF

   30 IF (IPOM.EQ.1) THEN
*
*     CHECK OF FEASIBILITY AND UPDATE OF THE FIRST PHASE OBJECTIVE
*     FUNCTION
*
          CALL PLSETG(NF,NC,IC,CG,G,INEW)
          IF (INEW.EQ.0) IPOM = 0
      END IF

      IF (IPOM.EQ.0 .AND. ITERL.EQ.0) THEN
*
*     FEASIBILITY ACHIEVED
*
          ITERL = 1
          CALL MXVCOP(NF,GO,G)
          IF (MFP.EQ.1) GO TO 60
      END IF
*
*     LAGRANGE MULTIPLIERS DETERMINATION
*
   40 IF (NF.GT.N) THEN
          CALL PLVLAG(NF,N,NC,ICA,CG,CG,G,CZ)
          CALL MXDPRB(NF-N,CR,CZ,0)
          CALL PLTLAG(NF,N,NC,IX,IC,ICA,CZ,IC,EPS7,UMAX,IOLD)

      ELSE
          IOLD = 0
          UMAX = 0.0D0
      END IF
*
*     PROJECTED GRADIENT DETERMINATION
*
      IF (N.GT.0) THEN
          CALL MXVNEG(NF,G,S)
          CALL PLSLAG(NF,N,NC,ICA,CG,CZ,CG,S,EPS7,GMAX)

      ELSE
          GMAX = 0.0D0
      END IF

      MODE = 1 - IPOM
      INEW = 0
      IF (GMAX.EQ.0.0D0) THEN
*
*     OPTIMUM ON A LINEAR MANIFOLD OBTAINED
*
          IF (IOLD.EQ.0) THEN
              IF (IPOM.EQ.0) THEN
*
*     OPTIMAL SOLUTION ACHIEVED
*
                  ITERL = 2
                  GO TO 60

              ELSE
                  IPOM = 0
                  DO 50 KC = 1,NC
                      IF (IC(KC).LT.-10) THEN
                          INEW = 0
                          CALL PLNEWL(KC,CF,IC,CL,CU,EPS9,INEW)
                          IF (IC(KC).LT.-10) IPOM = 1
                      END IF

   50             CONTINUE
                  IF (IPOM.EQ.0) THEN
*
*     OPTIMAL SOLUTION ACHIEVED
*
                      CALL MXVCOP(NF,GO,G)
                      ITERL = 2
                      GO TO 60

                  ELSE
*
*     FEASIBLE SOLUTION DOES NOT EXIST
*
                      CALL MXVCOP(NF,GO,G)
                      ITERL = -1
                      GO TO 60

                  END IF

              END IF

          ELSE
*
*     CONSTRAINT DELETION
*
              CALL PLRMF0(NF,NC,IX,IC,ICA,CR,IC,S,N,IOLD,KREM,IER)
              DMAX = 0.0D0
              GO TO 40

          END IF

      ELSE
*
*     STEPSIZE SELECTION
*
          POM = CON
          CALL PLMAXL(NF,NC,CF,CFD,IC,CL,CU,CG,S,POM,KBC,KREM,INEW)
          CALL PLMAXS(NF,X,IX,XL,XU,S,POM,KBF,KREM,INEW)
          IF (INEW.EQ.0) THEN
              IF (IPOM.EQ.0) THEN
*
*     BOUNDED SOLUTION DOES NOT EXIST
*
                  ITERL = -2

              ELSE
*
*     FEASIBLE SOLUTION DOES NOT EXIST
*
                  ITERL = -3
              END IF

              GO TO 60

          ELSE
*
*     STEP REALIZATION
*
              CALL PLDIRS(NF,X,IX,S,POM,KBF)
              CALL PLDIRL(NC,CF,CFD,IC,POM,KBC)
*
*     CONSTRAINT ADDITION
*
              IF (INEW.GT.0) THEN
                  KC = INEW
                  INEW = 0
                  CALL PLNEWL(KC,CF,IC,CL,CU,EPS9,INEW)
                  CALL PLADR0(NF,N,ICA,CG,CR,S,EPS7,GMAX,UMAX,INEW,NADD,
     +                        IER)
                  CALL MXVIND(IC,KC,IER)

              ELSE IF (INEW+NF.GE.0) THEN
                  I = -INEW
                  INEW = 0
                  CALL PLNEWS(X,IX,XL,XU,EPS9,I,INEW)
                  CALL PLADR0(NF,N,ICA,CG,CR,S,EPS7,GMAX,UMAX,INEW,NADD,
     +                        IER)
                  CALL MXVIND(IX,I,IER)
              END IF

              DMAX = POM
              NRED = NRED + 1
              GO TO 30

          END IF

      END IF

   60 CONTINUE
      RETURN

      END
* SUBROUTINE PLMAXL               ALL SYSTEMS                   97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF THE MAXIMUM STEPSIZE USING LINEAR CONSTRAINTS.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  NC  NUMBER OF CURRENT LINEAR CONSTRAINTS.
*  RI  CF(NF)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCYIONS.
*  RO  CFD(NF)  VECTOR CONTAINING INCREMENTS OF THE CONSTRAINT
*         FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RI  S(NF)  DIRECTION VECTOR.
*  RO  STEP  MAXIMUM STEPSIZE.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*  II  KREM  INDICATION OF LINEARLY DEPENDENT GRADIENTS.
*  IO  INEW  INDEX OF THE NEW ACTIVE FUNCTION.
*
* SUBPROGRAMS USED :
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*
      SUBROUTINE PLMAXL(NF,NC,CF,CFD,IC,CL,CU,CG,S,STEP,KBC,KREM,INEW)
C     .. Scalar Arguments ..
      DOUBLE PRECISION STEP
      INTEGER INEW,KBC,KREM,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CFD(*),CG(*),CL(*),CU(*),S(*)
      INTEGER IC(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER JCG,KC
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
      IF (KBC.GT.0) THEN
          JCG = 1
          DO 10 KC = 1,NC
              IF (KREM.GT.0 .AND. IC(KC).GT.10) IC(KC) = IC(KC) - 10
              IF (IC(KC).GT.0 .AND. IC(KC).LE.10) THEN
                  TEMP = MXVDOT(NF,CG(JCG),S)
                  CFD(KC) = TEMP
                  IF (TEMP.LT.0.0D0) THEN
                      IF (IC(KC).EQ.1 .OR. IC(KC).GE.3) THEN
                          TEMP = (CL(KC)-CF(KC))/TEMP
                          IF (TEMP.LE.STEP) THEN
                              INEW = KC
                              STEP = TEMP
                          END IF

                      END IF

                  ELSE IF (TEMP.GT.0.0D0) THEN
                      IF (IC(KC).EQ.2 .OR. IC(KC).GE.3) THEN
                          TEMP = (CU(KC)-CF(KC))/TEMP
                          IF (TEMP.LE.STEP) THEN
                              INEW = KC
                              STEP = TEMP
                          END IF

                      END IF

                  END IF

              ELSE IF (IC(KC).LT.-10) THEN
                  TEMP = MXVDOT(NF,CG(JCG),S)
                  CFD(KC) = TEMP
                  IF (TEMP.GT.0.0D0) THEN
                      IF (IC(KC).EQ.-11 .OR. IC(KC).EQ.-13 .OR.
     +                    IC(KC).EQ.-15) THEN
                          TEMP = (CL(KC)-CF(KC))/TEMP
                          IF (TEMP.LE.STEP) THEN
                              INEW = KC
                              STEP = TEMP
                          END IF

                      END IF

                  ELSE IF (TEMP.LT.0.0D0) THEN
                      IF (IC(KC).EQ.-12 .OR. IC(KC).EQ.-14 .OR.
     +                    IC(KC).EQ.-16) THEN
                          TEMP = (CU(KC)-CF(KC))/TEMP
                          IF (TEMP.LE.STEP) THEN
                              INEW = KC
                              STEP = TEMP
                          END IF

                      END IF

                  END IF

              END IF

              JCG = JCG + NF
   10     CONTINUE
      END IF

      RETURN

      END
* SUBROUTINE PLMAXS               ALL SYSTEMS                   97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF THE MAXIMUM STEPSIZE USING THE SIMPLE BOUNDS
* FOR VARIABLES.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  S(NF)  DIRECTION VECTOR.
*  RO  STEP  MAXIMUM STEPSIZE.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  IO  KREM  INDICATION OF LINEARLY DEPENDENT GRADIENTS.
*  IO  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*
      SUBROUTINE PLMAXS(NF,X,IX,XL,XU,S,STEP,KBF,KREM,INEW)
C     .. Scalar Arguments ..
      DOUBLE PRECISION STEP
      INTEGER INEW,KBF,KREM,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION S(*),X(*),XL(*),XU(*)
      INTEGER IX(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I
C     ..
      IF (KBF.GT.0) THEN
          DO 10 I = 1,NF
              IF (KREM.GT.0 .AND. IX(I).GT.10) IX(I) = IX(I) - 10
              IF (IX(I).GT.0 .AND. IX(I).LE.10) THEN
                  IF (S(I).LT.0.0D0) THEN
                      IF (IX(I).EQ.1 .OR. IX(I).GE.3) THEN
                          TEMP = (XL(I)-X(I))/S(I)
                          IF (TEMP.LE.STEP) THEN
                              INEW = -I
                              STEP = TEMP
                          END IF

                      END IF

                  ELSE IF (S(I).GT.0.0D0) THEN
                      IF (IX(I).EQ.2 .OR. IX(I).GE.3) THEN
                          TEMP = (XU(I)-X(I))/S(I)
                          IF (TEMP.LE.STEP) THEN
                              INEW = -I
                              STEP = TEMP
                          END IF

                      END IF

                  END IF

              END IF

   10     CONTINUE
      END IF

      KREM = 0
      RETURN

      END
* SUBROUTINE PLNEWL             ALL SYSTEMS                   97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* TEST ON ACTIVITY OF A GIVEN LINEAR CONSTRAINT.
*
* PARAMETERS :
*  II  KC  INDEX OF A GIVEN CONSTRAINT.
*  RI  CF(NC)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  IU  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  EPS9  TOLERANCE FOR ACTIVE CONSTRAINTS.
*  IO  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*
      SUBROUTINE PLNEWL(KC,CF,IC,CL,CU,EPS9,INEW)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS9
      INTEGER INEW,KC
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CL(*),CU(*)
      INTEGER IC(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX
C     ..
      IF (IC(KC).LT.-10) IC(KC) = -IC(KC) - 10
      IF (IC(KC).LE.0) THEN

      ELSE IF (IC(KC).EQ.1) THEN
          TEMP = EPS9*MAX(ABS(CL(KC)),1.0D0)
          IF (CF(KC).GT.CL(KC)+TEMP) THEN

          ELSE IF (CF(KC).GE.CL(KC)-TEMP) THEN
              IC(KC) = 11
              INEW = KC

          ELSE
              IC(KC) = -11
          END IF

      ELSE IF (IC(KC).EQ.2) THEN
          TEMP = EPS9*MAX(ABS(CU(KC)),1.0D0)
          IF (CF(KC).LT.CU(KC)-TEMP) THEN

          ELSE IF (CF(KC).LE.CU(KC)+TEMP) THEN
              IC(KC) = 12
              INEW = KC

          ELSE
              IC(KC) = -12
          END IF

      ELSE IF (IC(KC).EQ.3 .OR. IC(KC).EQ.4) THEN
          TEMP = EPS9*MAX(ABS(CL(KC)),1.0D0)
          IF (CF(KC).GT.CL(KC)+TEMP) THEN
              TEMP = EPS9*MAX(ABS(CU(KC)),1.0D0)
              IF (CF(KC).LT.CU(KC)-TEMP) THEN

              ELSE IF (CF(KC).LE.CU(KC)+TEMP) THEN
                  IC(KC) = 14
                  INEW = KC

              ELSE
                  IC(KC) = -14
              END IF

          ELSE IF (CF(KC).GE.CL(KC)-TEMP) THEN
              IC(KC) = 13
              INEW = KC

          ELSE
              IC(KC) = -13
          END IF

      ELSE IF (IC(KC).EQ.5 .OR. IC(KC).EQ.6) THEN
          TEMP = EPS9*MAX(ABS(CL(KC)),1.0D0)
          IF (CF(KC).GT.CL(KC)+TEMP) THEN
              TEMP = EPS9*MAX(ABS(CU(KC)),1.0D0)
              IF (CF(KC).LT.CU(KC)-TEMP) THEN

              ELSE IF (CF(KC).LE.CU(KC)+TEMP) THEN
                  IC(KC) = 16
                  INEW = KC

              ELSE
                  IC(KC) = -16
              END IF

          ELSE IF (CF(KC).GE.CL(KC)-TEMP) THEN
              IC(KC) = 15
              INEW = KC

          ELSE
              IC(KC) = -15
          END IF

      END IF

      RETURN

      END
* SUBROUTINE PLNEWS             ALL SYSTEMS                   97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* TEST ON ACTIVITY OF A GIVEN SIMPLE BOUND.
*
* PARAMETERS :
*  RI  X(NF)  VECTOR OF VARIABLES.
*  IU  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  EPS9  TOLERANCE FOR ACTIVE CONSTRAINTS.
*  II  I  INDEX OF TESTED SIMPLE BOUND.
*  IO  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*
      SUBROUTINE PLNEWS(X,IX,XL,XU,EPS9,I,INEW)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS9
      INTEGER I,INEW
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),XL(*),XU(*)
      INTEGER IX(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX
C     ..
      TEMP = 1.0D0
      IF (IX(I).LE.0) THEN

      ELSE IF (IX(I).EQ.1) THEN
          IF (X(I).LE.XL(I)+EPS9*MAX(ABS(XL(I)),TEMP)) THEN
              IX(I) = 11
              INEW = -I
          END IF

      ELSE IF (IX(I).EQ.2) THEN
          IF (X(I).GE.XU(I)-EPS9*MAX(ABS(XU(I)),TEMP)) THEN
              IX(I) = 12
              INEW = -I
          END IF

      ELSE IF (IX(I).EQ.3 .OR. IX(I).EQ.4) THEN
          IF (X(I).LE.XL(I)+EPS9*MAX(ABS(XL(I)),TEMP)) THEN
              IX(I) = 13
              INEW = -I
          END IF

          IF (X(I).GE.XU(I)-EPS9*MAX(ABS(XU(I)),TEMP)) THEN
              IX(I) = 14
              INEW = -I
          END IF

      END IF

      RETURN

      END
* SUBROUTINE PLRMB0               ALL SYSTEMS                92/12/01
* PORTABILITY : ALL SYSTEMS
* 92/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* OLD LINEAR CONSTRAINT OR AN OLD SIMPLE BOUND IS REMOVED FROM THE
* ACTIVE SET.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  ICA(NF)  VECTOR CONTAINING INDICES OF ACTIVE CONSTRAINTS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RU  CR(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RU  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM THE
*         CURRENT REDUCED SUBSPACE.
*  RI  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  RU  GN(NF)  TRANSFORMED GRADIENT OF THE OBJECTIVE FUNCTION.
*  II  IOLD  INDEX OF THE OLD ACTIVE CONSTRAINT.
*  IO  KREM  AUXILIARY VARIABLE.
*  IU  NREM NUMBER OF CONSTRAINT DELETION.
*  IO  IER  ERROR INDICATOR.
*
* SUBPROGRAMS USED :
*  S   PLRMR0  CORRECTION OF KERNEL OF THE ORTHOGONAL PROJECTION
*         AFTER CONSTRAINT DELETION.
*  S   MXDPRB  BACK SUBSTITUTION.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*  S   MXVMUL  DIAGONAL PREMULTIPLICATION OF A VECTOR.
*  S   MXVSET  INITIATION OF A VECTOR.
*
      SUBROUTINE PLRMB0(NF,N,ICA,CG,CR,CZ,G,GN,IOLD,KREM,NREM,IER)
C     .. Scalar Arguments ..
      INTEGER IER,IOLD,KREM,N,NF,NREM
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CG(*),CR(*),CZ(*),G(*),GN(*)
      INTEGER ICA(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,J,KC,NCA,NCR,NCZ
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDPRB,MXVCOP,MXVDIR,MXVSET,PLRMR0
C     ..
      IER = 0
      IF (N.EQ.NF) IER = 2
      IF (IOLD.EQ.0) IER = 3
      IF (IER.NE.0) RETURN
      NCA = NF - N
      NCR = NCA* (NCA-1)/2
      NCZ = N*NF
      CALL PLRMR0(NF,ICA,CR,CZ(NCZ+1),N,IOLD,KREM,IER)
      CALL MXVSET(NCA,0.0D0,CZ(NCZ+1))
      CZ(NCZ+NCA) = 1.0D0
      CALL MXDPRB(NCA,CR,CZ(NCZ+1),-1)
      CALL MXVCOP(NCA,CZ(NCZ+1),CR(NCR+1))
      N = N + 1
      CALL MXVSET(NF,0.0D0,CZ(NCZ+1))
      DO 10 J = 1,NCA
          KC = ICA(J)
          IF (KC.GT.0) THEN
              CALL MXVDIR(NF,CR(NCR+J),CG((KC-1)*NF+1),CZ(NCZ+1),
     +                    CZ(NCZ+1))

          ELSE
              I = -KC
              CZ(NCZ+I) = CZ(NCZ+I) + CR(NCR+J)
          END IF

   10 CONTINUE
      GN(N) = MXVDOT(NF,CZ(NCZ+1),G)
      NREM = NREM + 1
      IER = 0
      RETURN

      END
* SUBROUTINE PLSETC             ALL SYSTEMS                   97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF INITIAL VALUES OF THE CONSTRAINT FUNCTIONS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  II  NC  NUMBER OF CURRENT LINEAR CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  RI  XO(NF)  SAVED VECTOR OF VARIABLES.
*  RU  CF(NF)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCYIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  CG(NF*MCL)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RA  S(NF)  AUXILIARY VECTOR.
*
* SUBPROGRAMS USED :
*  S   MXVDIF  DIFFERENCE OF TWO VECTORS.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*  S   MXVMUL  DIAGONAL PREMULTIPLICATION OF A VECTOR.
*
      SUBROUTINE PLSETC(NF,NC,X,XO,CF,IC,CG,S)
C     .. Scalar Arguments ..
      INTEGER NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CG(*),S(*),X(*),XO(*)
      INTEGER IC(*)
C     ..
C     .. Local Scalars ..
      INTEGER JCG,KC
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVDIF
C     ..
      CALL MXVDIF(NF,X,XO,S)
      JCG = 0
      DO 10 KC = 1,NC
          IF (IC(KC).NE.0) CF(KC) = CF(KC) + MXVDOT(NF,S,CG(JCG+1))
          JCG = JCG + NF
   10 CONTINUE
      RETURN

      END
* SUBROUTINE PLSETG             ALL SYSTEMS                   97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* GRADIENT DETERMINATION IN THE FIRST PHASE OF LP SUBROUTINE.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  NC  NUMBER OF CONSTRAINTS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RO  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  IO  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*
* SUBPROGRAMS USED :
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*  S   MXVSET  INITIATION OF A VECTOR.
*
      SUBROUTINE PLSETG(NF,NC,IC,CG,G,INEW)
C     .. Scalar Arguments ..
      INTEGER INEW,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CG(*),G(*)
      INTEGER IC(*)
C     ..
C     .. Local Scalars ..
      INTEGER KC
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVDIR,MXVSET
C     ..
      CALL MXVSET(NF,0.0D0,G)
      INEW = 0
      DO 10 KC = 1,NC
          IF (IC(KC).GE.-10) THEN

          ELSE IF (IC(KC).EQ.-11 .OR. IC(KC).EQ.-13 .OR.
     +             IC(KC).EQ.-15) THEN
              CALL MXVDIR(NF,-1.0D0,CG((KC-1)*NF+1),G,G)
              INEW = 1

          ELSE IF (IC(KC).EQ.-12 .OR. IC(KC).EQ.-14 .OR.
     +             IC(KC).EQ.-16) THEN
              CALL MXVDIR(NF,1.0D0,CG((KC-1)*NF+1),G,G)
              INEW = 1
          END IF

   10 CONTINUE
      RETURN

      END
* SUBROUTINE PLGLAG               ALL SYSTEMS                97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* GRADIENT OF THE LAGRANGIAN FUNCTION IS DETERMINED.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  NC  NUMBER OF LINEARIZED CONSTRAINTS.
*  II  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RI  AG(NF*NC)  MATRIX WHOSE COLUMNS ARE GRADIENTS OF THE LINEAR
*         APPROXIMATED FUNCTIONS.
*  RO  AZ(NF+1)  VECTOR OF LAGRANGE MPLTIPLIERS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RU  G(NF)  GRADIENT OF THE LAGRANGIAN FUNCTION.
*
* SUBPROGRAMS USED :
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*
      SUBROUTINE PLGLAG(NF,N,NC,IAA,AG,AZ,CG,G)
C     .. Scalar Arguments ..
      INTEGER N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AG(*),AZ(*),CG(*),G(*)
      INTEGER IAA(*)
C     ..
C     .. Local Scalars ..
      INTEGER J,L,NAA
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVDIR
C     ..
      NAA = NF - N
      DO 10 J = 1,NAA
          L = IAA(J)
          IF (L.GT.NC) THEN
              L = L - NC
              CALL MXVDIR(NF,-AZ(J),AG((L-1)*NF+1),G,G)

          ELSE IF (L.GT.0) THEN
              CALL MXVDIR(NF,-AZ(J),CG((L-1)*NF+1),G,G)

          ELSE
              L = -L
              G(L) = G(L) - AZ(J)
          END IF

   10 CONTINUE
      RETURN

      END
* SUBROUTINE PLSLAG               ALL SYSTEMS                97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* NEGATIVE PROJECTED GRADIENT IS DETERMINED USING LAGRANGE MULTIPLIERS.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  NC  NUMBER OF LINEARIZED CONSTRAINTS.
*  II  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RI  AG(NF*NC)  MATRIX WHOSE COLUMNS ARE GRADIENTS OF THE LINEAR
*         APPROXIMATED FUNCTIONS.
*  RO  AZ(NF+1)  VECTOR OF LAGRANGE MULTIPLIERS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RO  S(NF)  NEGATIVE PROJECTED GRADIENT OF THE QUADRATIC FUNCTION.
*  RI  EPS7  TOLERANCE FOR LINEAR AND QUADRATIC PROGRAMMING.
*  RO  GMAX  NORM OF THE TRANSFORMED GRADIENT.
*
* SUBPROGRAMS USED :
*  S   UXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*  RF  UXVMAX  L-INFINITY NORM OF A VECTOR.
*
      SUBROUTINE PLSLAG(NF,N,NC,IAA,AG,AZ,CG,S,EPS7,GMAX)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,GMAX
      INTEGER N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AG(*),AZ(*),CG(*),S(*)
      INTEGER IAA(*)
C     ..
C     .. Local Scalars ..
      INTEGER J,L,NAA
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVMAX
      EXTERNAL MXVMAX
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVDIR
C     ..
      NAA = NF - N
      DO 10 J = 1,NAA
          L = IAA(J)
          IF (L.GT.NC) THEN
              L = L - NC
              CALL MXVDIR(NF,AZ(J),AG((L-1)*NF+1),S,S)

          ELSE IF (L.GT.0) THEN
              CALL MXVDIR(NF,AZ(J),CG((L-1)*NF+1),S,S)

          ELSE
              L = -L
              S(L) = S(L) + AZ(J)
          END IF

   10 CONTINUE
      GMAX = MXVMAX(NF,S)
      IF (GMAX.LE.EPS7) GMAX = 0.0D0
      RETURN

      END
* SUBROUTINE PLTLAG               ALL SYSTEMS                97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* MAXIMUM ABSOLUTE VALUE OF THE NEGATIVE LAGRANGE MULTIPLIER IS
* COMPUTED.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  NC  NUMBER OF LINEARIZED CONSTRAINTS.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  II  IA(NA)  VECTOR CONTAINING TYPES OF DEVIATIONS.
*  II  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RI  AZ(NF+1)  VECTOR OF LAGRANGE MULTIPLIERS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  EPS7  TOLERANCE FOR LINEAR AND QUADRATIC PROGRAMMING.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF THE NEGATIVE LAGRANGE MULTIPLIER.
*  IO  IOLD  INDEX OF THE REMOVED CONSTRAINT.
*
      SUBROUTINE PLTLAG(NF,N,NC,IX,IA,IAA,AZ,IC,EPS7,UMAX,IOLD)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,UMAX
      INTEGER IOLD,N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AZ(*)
      INTEGER IA(*),IAA(*),IC(*),IX(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER J,K,L,NAA
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS
C     ..
      IOLD = 0
      UMAX = 0.0D0
      NAA = NF - N
      DO 10 J = 1,NAA
          TEMP = AZ(J)
          L = IAA(J)
          IF (L.GT.NC) THEN
              L = L - NC
              K = IA(L)

          ELSE IF (L.GT.0) THEN
              K = IC(L)

          ELSE
              L = -L
              K = IX(L)
          END IF

          IF (K.LE.-5) THEN

          ELSE IF ((K.EQ.-1.OR.K.EQ.-3) .AND. UMAX+TEMP.GE.0.0D0) THEN

          ELSE IF ((K.EQ.-2.OR.K.EQ.-4) .AND. UMAX-TEMP.GE.0.0D0) THEN

          ELSE
              IOLD = J
              UMAX = ABS(TEMP)
          END IF

   10 CONTINUE
      IF (UMAX.LE.EPS7) IOLD = 0
      RETURN

      END
* SUBROUTINE PLTRBG               ALL SYSTEMS                97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* GRADIENT OF THE OBJECTIVE FUNCTION IS SCALED AND REDUCED. LAGRANGE
* MULTIPLIERS ARE DETERMINED. TEST VALUES GMAX AND UMAX ARE COMPUTED.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  NC  NUMBER OF CURRENT LINEAR CONSTRAINTS.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  II  ICA(NF)  VECTOR CONTAINING INDICES OF ACTIVE CONSTRAINTS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RI  CR(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RU  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM THE
*         CURRENT REDUCED SUBSPACE. VECTOR CZ(1,NF) CONTAINS LAGRANGE
*         MULTIPLIERS BEING DETERMINED.
*  RI  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  RO  GN(NF)  TRANSFORMED GRADIENT OF THE OBJECTIVE FUNCTION IF IT IS
*         NONZERO.
*  RI  EPS7  TOLERANCE FOR LINEAR AND QUADRATIC PROGRAMMING.
*  RO  GMAX  NORM OF THE TRANSFORMED GRADIENT.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF THE NEGATIVE LAGRANGE MULTIPLIER.
*  IO  IOLD  INDEX OF THE REMOVED CONSTRAINT.
*
* SUBPROGRAMS USED :
*  S   PLVLAG  GRADIENT IS PREMULTIPLIED BY THE MATRIX WHOSE COLUMNS
*         ARE NORMALS OF THE ACTIVE CONSTRAINTS.
*  S   PLTLAG  COMPUTATION OF THE MAXIMUM ABSOLUTE VALUE OF THE NEGATIVE
*         LAGRANGE MULTIPLIER.
*  S   MXDRMM  PREMULTIPLICATION OF A VECTOR BY A ROWWISE STORED DENSE
*         RECTANGULAR MATRIX.
*  S   MXDPRB  BACK SUBSTITUTION AFTER A CHOLESKI DECOMPOSITION.
*  RF  MXVMAX  L-INFINITY NORM OF A VECTOR.
*  S   MXVSET  INITIATION OF A VECTOR.
*
      SUBROUTINE PLTRBG(NF,N,NC,IX,IC,ICA,CG,CR,CZ,G,GN,EPS7,GMAX,UMAX,
     +                  IOLD)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,GMAX,UMAX
      INTEGER IOLD,N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CG(*),CR(*),CZ(*),G(*),GN(*)
      INTEGER IC(*),ICA(*),IX(*)
C     ..
C     .. Local Scalars ..
      INTEGER NCA,NCZ
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVMAX
      EXTERNAL MXVMAX
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDPRB,MXDRMM,MXVSET,PLTLAG,PLVLAG
C     ..
      GMAX = 0.0D0
      IF (N.GT.0) THEN
          CALL MXDRMM(NF,N,CZ,G,GN)
          GMAX = MXVMAX(N,GN)
      END IF

      IF (NF.GT.N .AND. GMAX.LE.EPS7) THEN
          NCA = NF - N
          NCZ = N*NF
          CALL PLVLAG(NF,N,NC,ICA,CG,CG,G,CZ(NCZ+1))
          CALL MXDPRB(NCA,CR,CZ(NCZ+1),0)
          CALL PLTLAG(NF,N,NC,IX,IC,ICA,CZ(NCZ+1),IC,EPS7,UMAX,IOLD)
          IF (UMAX.LE.EPS7) IOLD = 0
          CALL MXVSET(N,0.0D0,GN)
          GMAX = 0.0D0

      ELSE
          IOLD = 0
          UMAX = 0.0D0
      END IF

      RETURN

      END
* SUBROUTINE PLVLAG               ALL SYSTEMS                97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* GRADIENT OF THE OBJECTIVE FUNCTION IS PREMULTIPLIED BY TRANSPOSE
* OF THE MATRIX WHOSE COLUMNS ARE NORMALS OF CURRENT ACTIVE CONSTRAINTS
* AND GRADIENTS OF CURRENT ACTIVE FUNCTIONS.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  NC  NUMBER OF LINEARIZED CONSTRAINTS.
*  II  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RI  AG(NF*NA)  VECTOR CONTAINING SCALING PARAMETERS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RI  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  RO  GN(NF+1)  OUTPUT VECTOR.
*
* SUBPROGRAMS USED :
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*
      SUBROUTINE PLVLAG(NF,N,NC,IAA,AG,CG,G,GN)
C     .. Scalar Arguments ..
      INTEGER N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AG(*),CG(*),G(*),GN(*)
      INTEGER IAA(*)
C     ..
C     .. Local Scalars ..
      INTEGER J,L,NAA
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
      NAA = NF - N
      DO 10 J = 1,NAA
          L = IAA(J)
          IF (L.GT.NC) THEN
              L = L - NC
              GN(J) = MXVDOT(NF,AG((L-1)*NF+1),G)

          ELSE IF (L.GT.0) THEN
              GN(J) = MXVDOT(NF,CG((L-1)*NF+1),G)

          ELSE
              L = -L
              GN(J) = G(L)
          END IF

   10 CONTINUE
      RETURN

      END
* SUBROUTINE PUDBG1                ALL SYSTEMS                92/12/01
* PORTABILITY : ALL SYSTEMS
* 92/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* VARIABLE METRIC UPDATE OF A DENSE SYMMETRIC POSITIVE DEFINITE MATRIX
* USING THE FACTORIZATION B=L*D*TRANS(L).
*
* PARAMETERS :
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  RU  H(M)  FACTORIZATION B=L*D*TRANS(L) OF A POSITIVE
*         DEFINITE APPROXIMATION OF THE HESSIAN MATRIX.
*  RI  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  RA  S(NF)  AUXILIARY VECTOR.
*  RU  XO(NF)  VECTORS OF VARIABLES DIFFERENCE.
*  RI  GO(NF)  GRADIENTS DIFFERENCE.
*  RI  R  VALUE OF THE STEPSIZE PARAMETER.
*  RI  PO  OLD VALUE OF THE DIRECTIONAL DERIVATIVE.
*  II  NIT  ACTUAL NUMBER OF ITERATIONS.
*  II  KIT  NUMBER OF THE ITERATION AFTER LAST RESTART.
*  IO  ITERH  TERMINATION INDICATOR. ITERH<0-BAD DECOMPOSITION.
*         ITERH=0-SUCCESSFUL UPDATE. ITERH>0-NONPOSITIVE PARAMETERS.
*  II  MET  SELECTION OF SELF SCALING. MET=1-SELF SCALING SUPPRESSED.
*         MET=2 INITIAL SELF SCALING.
*  II  MOD  CORRECTION IF THE NEGATIVE CURVATURE OCCURS.
*         MOD=1-CORRECTION SUPPRESSED. MOD=2-POWELL'S CORRECTION.
*
* SUBPROGRAMS USED :
*  S   MXDPGU  CORRECTION OF A DENSE SYMMETRIC POSITIVE DEFINITE
*         MATRIX IN THE FACTORED FORM B=L*D*TRANS(L).
*  S   MXDPGS  SCALING OF A DENSE SYMMETRIC POSITIVE DEFINITE MATRIX
*         IN THE FACTORED FORM B=L*D*TRANS(L).
*  S   MXVDIF  DIFFERENCE OF TWO VECTORS.
*  RF  MXVDOT  DOT PRODUCT OF VECTORS.
*  S   MXVSCL  SCALING OF A VECTOR.
*
* METHOD :
* BFGS VARIABLE METRIC METHOD.
*
      SUBROUTINE PUDBG1(N,H,G,S,XO,GO,R,PO,NIT,KIT,ITERH,MET,MOD)
C     .. Scalar Arguments ..
      DOUBLE PRECISION PO,R
      INTEGER ITERH,KIT,MET,MOD,N,NIT
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION G(*),GO(*),H(*),S(*),XO(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION A,B,C,DIS,GAM,PAR
      LOGICAL L1,L3
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXDPGP,MXVDOT
      EXTERNAL MXDPGP,MXVDOT
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDPGB,MXDPGS,MXDPGU,MXVCOP,MXVDIF,MXVDIR,MXVSCL
C     ..
      L1 = MET .GE. 3 .OR. MET .EQ. 2 .AND. NIT .EQ. KIT
      L3 = .NOT. L1
*
*     DETERMINATION OF THE PARAMETERS B, C
*
      B = MXVDOT(N,XO,GO)
      A = 0.0D0
      IF (L1) THEN
          CALL MXVCOP(N,GO,S)
          CALL MXDPGB(N,H,S,1)
          A = MXDPGP(N,H,S,S)
          IF (A.LE.0.0D0) THEN
              ITERH = 1
              RETURN

          END IF

      END IF

      CALL MXVDIF(N,GO,G,S)
      CALL MXVSCL(N,R,S,S)
      C = -R*PO
      IF (C.LE.0.0D0) THEN
          ITERH = 3
          RETURN

      END IF

      IF (MOD.GT.1) THEN
          IF (B.LE.1.0D-4*C) THEN
*
*     POWELL'S CORRECTION
*
              DIS = (1.0D0-0.1D0)*C/ (C-B)
              CALL MXVDIF(N,GO,S,GO)
              CALL MXVDIR(N,DIS,GO,S,GO)
              B = C + DIS* (B-C)
              IF (L1) A = C + 2.0D0* (1.0D0-DIS)* (B-C) + DIS*DIS* (A-C)
          END IF

      ELSE
          IF (B.LE.1.0D-4*C) THEN
              ITERH = 2
              RETURN

          END IF

      END IF

      IF (L1) THEN
*
*     DETERMINATION OF THE PARAMETER GAM (SELF SCALING)
*
          PAR = C/B
          GAM = PAR
          IF (MET.GT.1) THEN
              IF (NIT.NE.KIT) THEN
                  L3 = GAM .LT. 0.5D0 .OR. GAM .GT. 4.0D0
              END IF

          END IF

      END IF

      IF (L3) THEN
          GAM = 1.0D0
          PAR = GAM

      END IF
*
*     BFGS UPDATE
*
      CALL MXDPGU(N,H,PAR/B,GO,XO)
      CALL MXDPGU(N,H,-1.0D0/C,S,XO)
      ITERH = 0
      IF (GAM.EQ.1.0D0) RETURN
      CALL MXDPGS(N,H,1.0D0/GAM)
      RETURN

      END
* SUBROUTINE PUDVI2                ALL SYSTEMS                99/12/01
* PORTABILITY : ALL SYSTEMS
* 99/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
*  NONSMOOTH VARIABLE METRIC UPDATE OF THE INVERSE HESSIAN MATRIX.
*
* PARAMETERS :
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  RU  H(N*(N+1)/2)  POSITIVE DEFINITE APPROXIMATION OF THE INVERSE
*         HESSIAN MATRIX.
*  RI  S(N)  DIRECTION VECTOR.
*  RI  GV(N)  AGGREGATED SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RU  U(N)  DIFFERENCE OF CURRENT AND PREVIOUS GRADIENTS.
*  RA  V(N)  AUXILIARY VECTOR.
*  RI  T  VALUE OF THE STEPSIZE PARAMETER.
*  RI  Z  DOT PRODUCT OF VECTORS S, U.
*  RI  RO  CORRECTION PARAMETER.
*  II  JC  CORRECTION INDICATOR.
*  II  JU  UPDATING INDICATOR.
*  II  NNK  CONSECUTIVE NULL STEPS COUNTER.
*  II  JOB  TYPE OF MINIMIZATION. JOB=0 - CONVEX MINIMIZATION.
*         JOB=1 - NONCONVEX MINIMIZATION.
*
* COMMON DATA :
*
* SUBPROGRAMS USED :
*  S   MXDSMM  MULTIPLICATION OF A DENSE SYMMETRIC MATRIX BY A VECTOR.
*  S   MXDSMU  UPDATE OF A DENSE SYMMETRIC MATRIX.
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*  RF  MXVDEL  SQUARED NORM OF A SHIFTED VECTOR.
*  RF  MXVDOT  DOT PRODUCT OF VECTORS.
*  S   MXVLIN  LINEAR COMBINATION OF TWO VECTORS.
*
      SUBROUTINE PUDVI2(N,H,S,GV,U,V,Z,RO,JC,JU,NNK,JOB,NIT)
C     .. Scalar Arguments ..
      DOUBLE PRECISION RO,Z
      INTEGER JC,JOB,JU,N,NIT,NNK
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION GV(*),H(*),S(*),U(*),V(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION GAM,P,P1,P2,P3,Q,W
      INTEGER I,J,L
      LOGICAL LB,LR
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDEL,MXVDOT
      EXTERNAL MXVDEL,MXVDOT
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDSMM,MXDSMU,MXVDIF,MXVLIN
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX,MIN
C     ..
      IF (JOB.GT.0) JU = 0
      IF (Z.LE.0.0D0) RETURN
      CALL MXDSMM(N,H,U,V)
      W = MXVDOT(N,U,V)
      GAM = 1.0D0
      IF (NIT.EQ.1) THEN
          Q = 1.0D0
          IF (W.NE.0.0D0) Q = Z/W
          IF ((Q-2.5D-1)* (Q-3.0D0).GT.0.0D0) GAM = MIN(3.0D0,
     +        MAX(2.0D-2,Q))
      END IF

      P1 = MXVDEL(N,-1.0D0,S,V)
      P2 = MXVDOT(N,GV,V) - MXVDOT(N,GV,S)
      P3 = MXVDOT(N,GV,GV)
      P = W - Z
      LB = NNK .EQ. 0
      LR = NNK .NE. 0 .AND. P2 .LT. 0.0D0
      IF (JC.EQ.1 .AND. (P1.LT.RO*P*N.OR.P2*P2.LT.RO*P*P3)) LR = .FALSE.
      IF (LB) THEN
          CALL MXVLIN(N,1.0D0/Z,V,-0.5D0* (1.0D0/GAM+W/Z)/Z,S,U)
          L = 1
          IF (JOB.GT.0) JU = 1
          DO 20 I = 1,N
              DO 10 J = 1,I
                  H(L) = (H(L)-U(I)*S(J)-S(I)*U(J))*GAM
                  L = L + 1
   10         CONTINUE
   20     CONTINUE

      ELSE IF (LR) THEN
          CALL MXVDIF(N,V,S,U)
          JU = 1
          CALL MXDSMU(N,H,-1.0D0/P,U)
      END IF

      RETURN

      END
* SUBROUTINE PS0LA2                ALL SYSTEMS                94/12/01
* PORTABILITY : ALL SYSTEMS
* 94/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
*  EXTENDED LINE SEARCH WITHOUT DIRECTIONAL DERIVATIVES.
*
* PARAMETERS :
*  II  NF DECLARED NUMBER OF VARIABLES.
*  II  NA  NUMBER OF APPROXIMATED FUNCTIONS.
*  RU  X(NF)  VECTOR OF VARIABLES.
*  RI  XO(NF)  OLD VECTOR OF VARIABLES.
*  RI  S(NF)  DIRECTION VECTOR.
*  RO  R  VALUE OF THE STEPSIZE PARAMETER.
*  RO  RO  PREVIOUS VALUE OF THE STEPSIZE PARAMETER.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RI  FO  INITIAL VALUE OF THE OBJECTIVE FUNCTION.
*  RI  PO  INITIAL VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RI  RMIN  MINIMUM VALUE OF THE STEPSIZE PARAMETER.
*  RI  RMAX  MAXIMUM VALUE OF THE STEPSIZE PARAMETER.
*  RI  FMIN  LOWER BOUND FOR VALUE OF THE OBJECTIVE FUNCTION.
*  RI  FMAX  UPPER BOUND FOR VALUE OF THE OBJECTIVE FUNCTION.
*  RA  FA  VALUE OF THE APPROXIMATED FUNCTION.
*  RO  AF(NA)  VECTOR WHOSE ELEMENTS ARE VALUES OF THE
*         APPROXIMATED FUNCTIONS.
*  RA  GA(NF)  GRADIENT OF THE APPROXIMATED FUNCTION.
*  RO  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE GRADIENTS OF THE
*         APPROXIMATED FUNCTIONS.
*  RO  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  II  KD  DEGREE OF REQUIRED DERVATIVES.
*  IU  LD  DEGREE OF PREVIOUSLY COMPUTED DERIVATIVES.
*  II  IEXT  TYPE OF OBJECTIVE FUNCTION. IEXT<0-MAXIMUM OF POSITIVE
*         VALUES. IEXT=0-MAXIMUM OF ABSOLUTE VALUES. IEXT>0-MAXIMUM
*         OF NEGATIVE VALUES.
*  II  NIT  ACTUAL NUMBER OF ITERATIONS.
*  II  KIT  NUMBER OF THE ITERATION AFTER LAST RESTART.
*  RI  TOLS  TERMINATION TOLERANCE FOR LINE SEARCH (IN TEST ON THE
*         CHANGE OF THE FUNCTION VALUE).
*  II  MES  METHOD SELECTION. MES=1-BISECTION. MES=2-TWO POINT
*         QUADRATIC INTERPOLATION. MES=3-THREE POINT QUADRATIC
*         INTERPOLATION.
*  IO  NRED  ACTUAL NUMBER OF EXTRAPOLATIONS OR INTERPOLATIONS.
*  II  MRED  MAXIMUM NUMBER OF EXTRAPOLATIONS OR INTERPOLATIONS.
*  IO  ITERS  TERMINATION INDICATOR. ITERS=0-ZERO STEP. ITERS=1-PERFECT
*         LINE SEARCH. ITERS=2 GOLDSTEIN STEPSIZE. ITERS=3-CURRY
*         STEPSIZE. ITERS=4-EXTENDED CURRY STEPSIZE.
*         ITERS=5-ARMIJO STEPSIZE. ITERS=6-FIRST STEPSIZE.
*         ITERS=7-MAXIMUM STEPSIZE. ITERS=8-UNBOUNDED FUNCTION.
*         ITERS=-1-MRED REACHED. ITERS=-2-POSITIVE DIRECTIONAL
*         DERIVATIVE. ITERS=-3-ERROR IN INTERPOLATION.
*
* SUBPROGRAM USED :
*  S   UA1MX2  COMPUTATION OF THE VALUE AND THE GRADIENT OF THE
*         OBJECTIVE FUNCTION WHICH IS DEFINED AS A MAXIMUM OF THE
*         APPROXIMATED FUNCTIONS.
*  S   PNINT3  EXTRAPOLATION OR INTERPOLATION WITHOUT DIRECTIONAL
*         DERIVATIVES.
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*
* METHOD :
* SAFEGUARDED EXTRAPOLATION AND INTERPOLATION WITH EXTENDED TERMINATION
* CRITERIA.
*
      SUBROUTINE PS0LA2(NF,NA,X,XO,S,R,RO,F,FO,PO,RMIN,RMAX,FMIN,FMAX,
     +                  FA,AF,GA,AG,G,KD,LD,IEXT,NIT,KIT,TOLS,MES,NRED,
     +                  MRED,ITERS)
C     .. Scalar Arguments ..
      DOUBLE PRECISION F,FA,FMAX,FMIN,FO,PO,R,RMAX,RMIN,RO,TOLS
      INTEGER IEXT,ITERS,KD,KIT,LD,MES,MRED,NA,NF,NIT,NRED
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AG(*),G(*),GA(*),S(*),X(*),XO(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION FI,FL,FU,RI,RL,RU
      INTEGER MERR,MODE,MTYP
      LOGICAL L1,L2,L3
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVDIR,PA1MX2,PNINT3
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN
C     ..
      IF (PO.GE.0.0D0) THEN
          R = 0.0D0
          ITERS = -2
          RETURN

      END IF

      IF (RMAX.LE.0.0D0) THEN
          ITERS = 0
          RETURN

      END IF
*
*     INITIAL STEPSIZE SELECTION
*
      R = 1.0D0
      R = MAX(R,RMIN)
      R = MIN(R,RMAX)
      MODE = 0
      RU = 0.0D0
      FU = FO
      RI = 0.0D0
      FI = FO
*
*     NEW STEPSIZE SELECTION (EXTRAPOLATION OR INTERPOLATION)
*
   10 CALL PNINT3(RO,RL,RU,RI,FO,FL,FU,FI,PO,R,MODE,MTYP,MERR)
      IF (MERR.GT.0) THEN
          ITERS = -MERR
          RETURN

      ELSE IF (MODE.EQ.1) THEN
          NRED = NRED - 1
          R = MIN(R,RMAX)

      ELSE IF (MODE.EQ.2) THEN
          NRED = NRED + 1
      END IF
*
*     COMPUTATION OF THE NEW FUNCTION VALUE
*
      KD = 0
      LD = -1
      CALL MXVDIR(NF,R,S,XO,X)
      CALL PA1MX2(NF,NA,X,F,FA,AF,GA,AG,G,KD,LD,IEXT)
      KD = 1
      IF (F.LE.FMIN) THEN
          ITERS = 7
          RETURN

      ELSE
          L1 = R .LE. RMIN .AND. NIT .NE. KIT
          L2 = R .GE. RMAX
          L3 = F - FO .LE. TOLS*R*PO .OR. F - FMIN .LE. (FO-FMIN)/1.0D1
      END IF
*
*     TEST ON TERMINATION
*
      IF (L1 .AND. .NOT.L3) THEN
          ITERS = 0
          RETURN

      ELSE IF (L2 .AND. .NOT.F.GE.FU) THEN
          ITERS = 7
          RETURN

      ELSE IF (L3) THEN
          ITERS = 5
          RETURN

      ELSE IF (ABS(NRED).GE.MRED) THEN
          ITERS = -1
          RETURN

      ELSE
          MODE = MAX(MODE,1)
          MTYP = ABS(MES)
          IF (F.GE.FMAX) MTYP = 1
      END IF

      IF (MODE.EQ.1) THEN
*
*     INTERVAL CHANGE AFTER EXTRAPOLATION
*
          RL = RI
          FL = FI
          RI = RU
          FI = FU
          RU = R
          FU = F
          IF (F.GE.FI) THEN
              NRED = 0
              MODE = 2
          END IF
*
*     INTERVAL CHANGE AFTER INTERPOLATION
*
      ELSE IF (R.LE.RI) THEN
          IF (F.LE.FI) THEN
              RU = RI
              FU = FI
              RI = R
              FI = F

          ELSE
              RL = R
              FL = F
          END IF

      ELSE
          IF (F.LE.FI) THEN
              RL = RI
              FL = FI
              RI = R
              FI = F

          ELSE
              RU = R
              FU = F
          END IF

      END IF

      GO TO 10

      END
* SUBROUTINE PS1L05                ALL SYSTEMS                94/12/01
* PORTABILITY : ALL SYSTEMS
* 94/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
*  SPECIAL LINE SEARCH WITH DIRECTIONAL DERIVATIVES FOR BUNDLE METHODS.
*
* PARAMETERS :
*  II  NF  NUMBER OF VARIABLES.
*  RU  X(NF)  VECTOR OF VARIABLES.
*  RI  XO(NF)  OLD VECTOR OF VARIABLES.
*  RU  S(NF+1)  DIRECTION VECTOR.
*  RO  R  VALUE OF THE STEPSIZE PARAMETER.
*  RO  RP  PREVIOUS VALUE OF THE STEPSIZE PARAMETER.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RI  FO  PREVIOUS VALUE OF THE OBJECTIVE FUNCTION.
*  RU  FP  CURRENT MINIMUM VALUE OF THE OBJECTIVE FUNCTION.
*  RO  P  VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RI  PO  INITIAL VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RO  PP  PREVIOUS VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RU  TO  WEIGHT PARAMETER
*  RU  G(NF+1)  SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RO  SNORM  NORM OF THE DIRECTION VECTOR.
*  RI  RMIN  MINIMUM VALUE OF THE STEPSIZE PARAMETER
*  RI  RMAX  MAXIMUM VALUE OF THE STEPSIZE PARAMETER
*  RI  FMIN  LOWER BOUND FOR VALUE OF THE OBJECTIVE FUNCTION.
*  RI  FMAX  UPPER BOUND FOR VALUE OF THE OBJECTIVE FUNCTION.
*  RI  TOLS  LINE SEARCH PARAMETER (IN TEST ON THE DECREASE
*         OF THE FUNCTION VALUE).
*  RI  TOLP  LINE SEARCH PARAMETER (IN TERMINATION CONDITION
*         FOR NULL AND SHORT STEPS).
*  RI  ETA  DISTANCE MEASURE PARAMETER.
*  II  MES  INTERPOLATION METHOD SELECTION. MES=1-BISECTION.
*         MES=2-QUADRATIC INTERPOLATION (WITH ONE DIRECTIONAL
*         DERIVATIVE). MES=3-QUADRATIC INTERPOLATION (WITH TWO
*         DIRECTIONAL DERIVATIVES). MES=4-CUBIC INTERPOLATION.
*         MES=5-CONIC INTERPOLATION.
*  II  MES2  WEIGHT UPDATING METHOD SELECTION. MES2=1-QUADRATIC
*         INTERPOLATION. MES2=2-LOCAL MINIMUM LOCALIZATION.
*  IO  ITERS  TERMINATION INDICATOR. ITERS=0-ZERO STEP. ITERS=1-PERFECT
*         LINE SEARCH. ITERS=2 GOLDSTEIN STEPSIZE. ITERS=3-CURRY
*         STEPSIZE. ITERS=4-EXTENDED CURRY STEPSIZE.
*         ITERS=5-ARMIJO STEPSIZE. ITERS=6-FIRST STEPSIZE.
*         ITERS=7-MAXIMUM STEPSIZE. ITERS=8-UNBOUNDED FUNCTION.
*         ITERS=9-SHORT STEP. ITERS=10-ZERO STEP.
*         ITERS=-1-MRED REACHED. ITERS=-2-POSITIVE DIRECTIONAL
*         DERIVATIVE. ITERS=-3-ERROR IN INTERPOLATION.
*
* SUBPROGRAM USED :
*  SE  FUNDER  OBJECTIVE FUNCTION AND SUBGRADIENT EVALUATION.
*  S   PNINT1  EXTRAPOLATION OR INTERPOLATION WITH DIRECTIONAL
*         DERIVATIVES.
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*
* METHOD :
* SAFEGUARDED EXTRAPOLATION AND INTERPOLATION WITH SPECIAL TERMINATION
* CRITERIA.
*
      SUBROUTINE PS1L05(NF,X,XO,S,R,RP,F,FO,FP,P,PO,PP,TO,G,SNORM,RMIN,
     +                  RMAX,FMIN,FMAX,TOLS,TOLP,ETA,MES,MES2,ITERS)
C     .. Parameters ..
      DOUBLE PRECISION CON1
      PARAMETER (CON1=2D-3)
C     ..
C     .. Scalar Arguments ..
      DOUBLE PRECISION ETA,F,FMAX,FMIN,FO,FP,P,PO,PP,R,RMAX,RMIN,RP,
     +                 SNORM,TO,TOLP,TOLS
      INTEGER ITERS,MES,MES2,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION G(*),S(*),X(*),XO(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION FAUX,FL,FU,PL,PU,RL,RTEMP,RU,TOAUX,TOP,TOP1,TOP2,
     +                 TOPB,TOPC
      INTEGER IPOC,IPOCM,IPOCN,MERR,MODE,MTYP
      LOGICAL L3,L5,M0,M3,M4
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
C     .. External Subroutines ..
      EXTERNAL FUNDER,MXVDIR,PNINT1
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
C     .. Save statement ..
      SAVE IPOC,M4,TOP,TOP1,TOP2,TOAUX,FAUX,IPOCN,IPOCM
C     ..
      IF (NIT.LE.1) THEN
          IPOC = 0
          IPOCN = 0
          TOAUX = 1.0D0
      END IF

      IF (NIT.EQ.NIT/5*5+1) THEN
          FAUX = 0.0D0
          IPOCM = IPOCN
      END IF

      M4 = RP .EQ. R
      IF (.NOT.M4) PP = P
      IF (RMAX.LE.0.0D0) THEN
          ITERS = 0
          GO TO 40

      END IF

      NRED = 0
*
*     INITIAL STEPSIZE SELECTION
*
      RTEMP = FMIN - F
      RP = 0.0D0
      FP = FO
      R = 1.0D0
      R = MIN(MAX(R,RMIN),RMAX)
      MODE = 0
      MTYP = 10
      RL = 0.0D0
      FL = FO
      PL = PO
      RU = 0.0D0
      FU = FO
      PU = PO
*
*     NEW STEPSIZE SELECTION (EXTRAPOLATION OR INTERPOLATION)
*
   10 IF (RL.EQ.0.0D0) THEN
          MTYP = MIN(MTYP,2)
          PL = PP
          CALL PNINT1(RL,RU,FL,FU,PL,PU,R,MODE,MTYP,MERR)

      ELSE
          MERR = 0
          R = 0.5D0* (RU+RL)
      END IF

      IF (MERR.GT.0) THEN
          ITERS = -MERR
          GO TO 40

      ELSE IF (MODE.EQ.1) THEN
          NRED = NRED - 1
          R = MIN(R,RMAX)

      ELSE IF (MODE.EQ.2) THEN
          NRED = NRED + 1
      END IF
*
*     NEW FUNCTION VALUE AND NEW DIRECTIONAL DERIVATIVE
*
      CALL MXVDIR(NF,R,S,XO,X)
      CALL FUNDER(NF,X,F,G)
      NFV = NFV + 1
      NFG = NFG + 1
      P = MXVDOT(NF,G,S)
      IF (F.LE.FMIN) THEN
          ITERS = 7
          GO TO 40

      END IF

      L3 = (F-FO.LE.TOLS*R*PO) .OR. (F.LE.FO-1.0D0)
      MODE = MAX(MODE,1)
      IF (MODE.EQ.1) THEN
*
*     INTERVAL CHANGE AFTER EXTRAPOLATION
*
          TOP2 = 2.0D0* (P*R+FO-F)/ (R*SNORM)**2
          TOP = TOP2
          TOP1 = -1.0D0
          IF (M4) TOP1 = 2.0D0* (F-FO-PP*R)/ (R*SNORM)**2
          IF (TOP.LT.-CON1) THEN
              TOP = TOP1

          ELSE
              IF (TOP1.GE.-CON1) TOP = MIN(TOP1,TOP)
          END IF

          IF (MES2.EQ.2 .AND. PP.LT.0.0D0) THEN
              IF (P.GE.0.0D0) TOP = MIN(TOP,TO/R* (1.0D0-P/PP))
              IF (P.LT.0.0D0) TOP = MIN(TOP,TO/ (1.0D0+1.0D1*P/PP))
          END IF

          M0 = M4 .OR. IPOC .GE. 6 .OR. L3
          RL = RU
          FL = FU
          PL = PU
          RU = R
          FU = F
          PU = P
          IF (.NOT.L3) THEN
              NRED = 0
              MODE = 2
          END IF

      ELSE
*
*     INTERVAL CHANGE AFTER INTERPOLATION
*
          TOPB = 2.0D0* (P*R+FO-F)/ (R*SNORM)**2
          TOPC = 2.0D0* (FU-F-P* (RU-R))/ ((RU-R)*SNORM)**2
          IF (TOPB.LT.-CON1) THEN
              TOP = TOPC

          ELSE
              IF (TOPC.GE.-CON1) TOP = MIN(TOPB,TOPC)
              IF (TOPC.LT.-CON1) TOP = TOPB
          END IF

          IF (L3) THEN
              RL = R
              FL = F
              PL = P

          ELSE
              RU = R
              FU = F
              PU = P
          END IF

      END IF
*
*     TEST ON TERMINATION
*
      IF (F.LT.FP) THEN
          RP = R
          FP = F
      END IF

      RTEMP = MAX(ABS(FP-F+P* (R-RP)),ETA* ((R-RP)*SNORM)**2)
      M3 = P - RTEMP .GE. TOLP*PO
      L5 = RL .EQ. 0.0D0
      MTYP = 1
      IF (L5) MTYP = MES
      IF (F.GE.FMAX) MTYP = 1
      IF (MODE.EQ.1 .AND. L3) L5 = .FALSE.
      IF (L3 .AND. RP.GT.RMIN) GO TO 30
      IF (M3 .AND. (R.LT.1D0.OR. (IPOC.LE.6.AND.NIT.GT.1))) GO TO 20
      IF (M3 .AND. .NOT.M0) GO TO 20
      IF (RU-RL.GE.RMIN) GO TO 10
   20 IF (RP.EQ.0.0D0) THEN
          ITERS = 10
          IPOC = IPOC + 1

      ELSE
          ITERS = 9
          IPOC = 0
      END IF

      GO TO 40

   30 ITERS = 5
      IPOC = 0
      IF (MODE.EQ.1) IPOCN = IPOCN + 1
      R = RP
      F = FP
   40 CONTINUE
*
*     WEIGHT UPDATING
*
      FAUX = MAX(FAUX,F-FP)
      IF (NIT.EQ.NIT/5*5 .AND. MES2.EQ.2) THEN
          IF (IPOCN-IPOCM.GE.4) THEN
              TOAUX = MAX(TOAUX/1.75D0,CON1)

          ELSE IF (IPOCN.EQ.IPOCM .AND. FAUX.GE.-R*PO .AND.
     +             NIT.GT.10) THEN
              TOAUX = MIN(TOAUX*1.25D0,1.0D0/CON1)
          END IF

      END IF

      TOP = TOP*TOAUX
      RU = (TOP+CON1*1D-1)* (TOP*CON1*1D-2-1.0D0)
      IF (M0 .AND. RU.LE.0.0D0 .AND. MES2.EQ.
     +    1) TO = MIN(MAX(TOP,CON1,TO/1.0D1),1.0D0/CON1,TO*1.0D1)
      IF (M0 .AND. RU.LE.0.0D0 .AND. MES2.EQ.
     +    2) TO = MIN(MAX(TOP,CON1/1.0D1,TO/1.0D1),1.0D0/CON1,TO*1.0D1)
      RETURN

      END
* SUBROUTINE PS1L07                ALL SYSTEMS                99/12/01
* PORTABILITY : ALL SYSTEMS
* 99/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
*  SPECIAL LINE SEARCH FOR NONSMOOTH CONVEX VARIABLE METRIC METHOD.
*
* PARAMETERS :
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  MA  DECLARED NUMBER OF LINEAR APPROXIMATED FUNCTIONS
*  II  MAL  CURRENT NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  RU  X(N)  VECTOR OF VARIABLES.
*  RO  G(N)  SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RI  S(N)  DIRECTION VECTOR.
*  RU  U(N)  PREVIOUS VECTOR OF VARIABLES.
*  RI  V(N)  PREVIOUS SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RI  AF(4*MA)  VECTOR OF BUNDLE FUNCTIONS VALUES.
*  RI  AG(N*MA)  MATRIX WHOSE COLUMNS ARE BUNDLE SUBGRADIENTS.
*  RI  AY(N*MA)  MATRIX WHOSE COLUMNS ARE VARIABLE VECTORS.
*  RO  T  VALUE OF THE STEPSIZE PARAMETER.
*  RO  TB  BUNDLE PARAMETER FOR MATRIX SCALING.
*  RO  FO  PREVIOUS VALUE OF THE OBJECTIVE FUNCTION.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RU  PO  PREVIOUS DIRECTIONAL DERIVATIVE.
*  RI  TMIN  MINIMUM VALUE OF THE STEPSIZE PARAMETER.
*  RI  TMAX  MAXIMUM VALUE OF THE STEPSIZE PARAMETER.
*  RI  D1  AUXILIARY VALUE FOR NULL/DESCENT STEP TEST.
*  RU  DF  AUXILIARY VALUE FOR TEST ON FUNCTION DECREASE.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*  RI  TOLF  LOWER BOUND FOR FUNCTION DECREASE.
*  IO  JL  TERMINATION INDICATOR.
*  IO  NE  EXTRAPOLATION COUNTER.
*  IO  NK  NULL STEP INDICATOR. NK=0-DESCENT STEP. NK=2-NULL STEP.
*  IU  NV  AUXILIARY NUMBER OF FUNCTION EVALUATIONS.
*  IU  NTESF  ACTUAL NUMBER OF TESTS ON FUNCTION DECREASE.
*  II  MTESF  MAXIMUM NUMBER OF TESTS ON FUNCTION DECREASE.
*  IO  ITERS  NULL STEP INDICATOR. ITERS=0-NULL STEP. ITERS=1-DESCENT
*         STEP.
*
* SUBPROGRAMS USED :
*  S   MXVCOP  COPYING OF A VECTOR.
*  RF  MXVMX2  L-INFINITY NORM OF VECTOR DIFFERENCE.
*  S   PNSTP2  STEPSIZE DETERMINATION FOR DESCENT STEPS.
*  S   PNSTP3  STEPSIZE DETERMINATION FOR NULL STEPS.
*
* METHOD :
* SPECIAL METHOD OF STEP LENGTH DETERMINATION.
*
      SUBROUTINE PS1L07(N,MA,MAL,X,G,S,U,V,AF,AG,AY,T,TB,FO,F,PO,TMIN,
     +                  TMAX,D1,DF,ETA9,TOLF,JL,NE,NV,NTESF,MTESF,ITERS)
C     .. Scalar Arguments ..
      DOUBLE PRECISION D1,DF,ETA9,F,FO,PO,T,TB,TMAX,TMIN,TOLF
      INTEGER ITERS,JL,MA,MAL,MTESF,N,NE,NTESF,NV
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AG(*),AY(*),G(*),S(*),U(*),V(*),X(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION DT,W
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVMX2
      EXTERNAL MXVMX2
C     ..
C     .. External Subroutines ..
      EXTERNAL FUNDER,MXVCOP,MXVDIR,PNSTP2,PNSTP3
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      T = MIN(1.0D0,TMAX)
      IF (PO.NE.0.0D0) THEN
          IF (ITERS.EQ.1) THEN
              CALL PNSTP2(N,MA,MAL,X,AF,AG,AY,S,F,PO,T,TB,ETA9)

          ELSE
              CALL PNSTP3(N,MA,MAL,X,AF,AG,AY,S,F,PO,T,TB,ETA9)
          END IF

      END IF

      T = MIN(MAX(T,TMIN),TMAX)
      DT = T
      NE = 0
*
*     FUNCTION AND GRADIENT EVALUATION AT A NEW POINT
*
   10 CALL MXVDIR(N,T,S,U,X)
      CALL FUNDER(N,X,F,G)
      NFV = NFV + 1
      NFG = NFG + 1
      NV = NV + 1
*
*     NULL/DESCENT STEP TEST (ITERS=0/1)
*
      ITERS = 1
      IF (F.GT.FO-T*D1) ITERS = 0
      W = DF
      IF (ABS(FO-F).GE.DF*1.0D-5) W = ABS(FO-F)
      IF (ITERS.EQ.1) DF = W
      IF (W/MAX(ABS(F),1.0D0).LE.TOLF .OR. FO.EQ.F) THEN
          NTESF = NTESF + 1
          JL = 1
          IF (NTESF.GE.MTESF) RETURN

      ELSE
          NTESF = 0
      END IF

      W = MXVMX2(N,G,V)
      T = DT
      DT = DT + T
      IF (W.EQ.0.0D0 .AND. ITERS.EQ.1 .AND. NE.LE.9 .AND.
     +    DT.LE.TMAX) THEN
*
*     EXTRAPOLATION
*
          NE = NE + 1
          FO = F
          CALL MXVCOP(N,X,U)
          GO TO 10

      END IF

      JL = 0
      RETURN

      END
* SUBROUTINE PS1L08                ALL SYSTEMS                99/12/01
* PORTABILITY : ALL SYSTEMS
* 99/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
*  SPECIAL LINE SEARCH FOR NONSMOOTH NONCONVEX VARIABLE METRIC METHOD.
*
* PARAMETERS :
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  MA  DECLARED NUMBER OF LINEAR APPROXIMATED FUNCTIONS
*  II  MAL  CURRENT NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  RU  X(N)  VECTOR OF VARIABLES.
*  RO  G(N)  SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RI  S(N)  DIRECTION VECTOR.
*  RU  U(N)  PREVIOUS VECTOR OF VARIABLES.
*  RI  AF(4*MA)  VECTOR OF BUNDLE FUNCTIONS VALUES.
*  RI  AG(N*MA)  MATRIX WHOSE COLUMNS ARE BUNDLE SUBGRADIENTS.
*  RI  AY(N*MA)  MATRIX WHOSE COLUMNS ARE VARIABLE VECTORS.
*  RO  T  VALUE OF THE STEPSIZE PARAMETER.
*  RO  TB  BUNDLE PARAMETER FOR MATRIX SCALING.
*  RO  FO  PREVIOUS VALUE OF THE OBJECTIVE FUNCTION.
*  RO  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RU  PO  PREVIOUS DIRECTIONAL DERIVATIVE.
*  RU  P  DIRECTIONAL DERIVATIVE.
*  RI  TMIN  MINIMUM VALUE OF THE STEPSIZE PARAMETER.
*  RI  TMAX  MAXIMUM VALUE OF THE STEPSIZE PARAMETER.
*  RI  SNORM  EUCLIDEAN NORM OF THE DIRECTION VECTOR.
*  RI  WK  STOPPING PARAMETER.
*  RI  EPS1  TERMINATION TOLERANCE FOR LINE SEARCH (IN TEST ON THE
*         CHANGE OF THE FUNCTION VALUE).
*  RI  EPS2  TERMINATION TOLERANCE FOR LINE SEARCH (IN TEST ON THE
*         DIRECTIONAL DERIVATIVE).
*  RI  ETA5  DISTANCE MEASURE PARAMETER.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*  II  JE  EXTRAPOLATION INDICATOR.
*  RI  MOS3   LOCALITY MEASURE PARAMETER.
*  IO  ITERS  NULL STEP INDICATOR. ITERS=0-NULL STEP. ITERS=1-DESCENT
*         STEP.
* SUBPROGRAMS USED :
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*  S   PNSTP4  STEPSIZE DETERMINATION FOR DESCENT STEPS.
*  S   PNSTP5  STEPSIZE DETERMINATION FOR NULL STEPS.
*  S   PNINT1  EXTRAPOLATION OR INTERPOLATION FOR LINE SEARCH
*              WITH DIRECTIONAL DERIVATIVES.
*
* METHOD :
* SPECIAL METHOD OF STEP LENGTH DETERMINATION.
*
      SUBROUTINE PS1L08(N,MA,MAL,X,G,S,U,AF,AG,AY,T,TB,FO,F,PO,P,TMIN,
     +                  TMAX,SNORM,WK,EPS1,EPS2,ETA5,ETA9,JE,MOS3,ITERS)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS1,EPS2,ETA5,ETA9,F,FO,P,PO,SNORM,T,TB,TMAX,
     +                 TMIN,WK
      INTEGER ITERS,JE,MA,MAL,MOS3,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AG(*),AY(*),G(*),S(*),U(*),X(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION BET,FL,FU,PL,PU,TL,TU
      INTEGER IER
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT
      EXTERNAL MXVDOT
C     ..
C     .. External Subroutines ..
      EXTERNAL FUNDER,MXVDIR,PNINT1,PNSTP4,PNSTP5
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,DBLE,MAX,MIN
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (JE.GT.0) T = DBLE(2-JE/99)*T
      IF (JE.LE.0) T = MIN(1.0D0,TMAX)
      IF (PO.EQ.0.0D0 .OR. JE.GT.0) GO TO 10
      IF (ITERS.EQ.1) THEN
          CALL PNSTP4(N,MA,MAL,X,AF,AG,AY,S,F,PO,T,TB,ETA5,ETA9,MOS3)

      ELSE
          CALL PNSTP5(N,MA,MAL,X,AF,AG,AY,S,F,PO,T,TB,ETA5,ETA9,MOS3)
      END IF

   10 T = MIN(MAX(T,TMIN),TMAX)
      TL = 0.0D0
      TU = T
      FL = FO
      PL = PO
*
*     FUNCTION AND GRADIENT EVALUATION AT A NEW POINT
*
   20 CALL MXVDIR(N,T,S,U,X)
      CALL FUNDER(N,X,F,G)
      NFV = NFV + 1
      NFG = NFG + 1
      P = MXVDOT(N,G,S)
*
*     NULL/DESCENT STEP TEST (ITERS=0/1)
*
      ITERS = 1
      IF (F.LE.FO-T* (EPS1+EPS1)*WK) THEN
          TL = T
          FL = F
          PL = P

      ELSE
          TU = T
          FU = F
          PU = P
      END IF

      BET = MAX(ABS(FO-F+P*T),ETA5* (SNORM*T)**MOS3)
      IF (F.LE.FO-T*EPS1*WK .AND. (T.GE.TMIN.OR.
     +    BET.GT.EPS1*WK)) GO TO 40
      IF (P-BET.GE.-EPS2*WK .OR. TU-TL.LT.TMIN*1.0D-1) GO TO 30
      IF (TL.EQ.0.0D0 .AND. PL.LT.0.0D0) THEN
          CALL PNINT1(TL,TU,FL,FU,PL,PU,T,2,2,IER)

      ELSE
          T = 5.0D-1* (TU+TL)
      END IF

      GO TO 20

   30 ITERS = 0
   40 CONTINUE
      RETURN

      END
* SUBROUTINE PNINT1                ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* EXTRAPOLATION OR INTERPOLATION FOR LINE SEARCH WITH DIRECTIONAL
* DERIVATIVES.
*
* PARAMETERS :
*  RI  RL  LOWER VALUE OF THE STEPSIZE PARAMETER.
*  RI  RU  UPPER VALUE OF THE STEPSIZE PARAMETER.
*  RI  FL  VALUE OF THE OBJECTIVE FUNCTION FOR R=RL.
*  RI  FU  VALUE OF THE OBJECTIVE FUNCTION FOR R=RU.
*  RI  PL  DIRECTIONAL DERIVATIVE FOR R=RL.
*  RI  PU  DIRECTIONAL DERIVATIVE FOR R=RU.
*  RO  R  VALUE OF THE STEPSIZE PARAMETER OBTAINED.
*  II  MODE  MODE OF LINE SEARCH.
*  II  MTYP  METHOD SELECTION. MTYP=1-BISECTION. MTYP=2-QUADRATIC
*         INTERPOLATION (WITH ONE DIRECTIONAL DERIVATIVE).
*         MTYP=3-QUADRATIC INTERPOLATION (WITH TWO DIRECTIONAL
*         DERIVATIVES). MTYP=4-CUBIC INTERPOLATION. MTYP=5-CONIC
*         INTERPOLATION.
*  IO  MERR  ERROR INDICATOR. MERR=0 FOR NORMAL RETURN.
*
* METHOD :
* EXTRAPOLATION OR INTERPOLATION WITH STANDARD MODEL FUNCTIONS.
*
      SUBROUTINE PNINT1(RL,RU,FL,FU,PL,PU,R,MODE,MTYP,MERR)
C     .. Parameters ..
      DOUBLE PRECISION ZERO,HALF,ONE,TWO,THREE,C1L,C1U,C2L,C2U,C3L,FOUR
      PARAMETER (ZERO=0.0D0,HALF=0.5D0,ONE=1.0D0,TWO=2.0D0,THREE=3.0D0,
     +          C1L=1.1D0,C1U=1.0D3,C2L=1.0D-2,C2U=0.9D0,C3L=0.1D0,
     +          FOUR=4.0D0)
C     ..
C     .. Scalar Arguments ..
      DOUBLE PRECISION FL,FU,PL,PU,R,RL,RU
      INTEGER MERR,MODE,MTYP
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION A,B,C,D,DEN,DIS
      INTEGER NTYP
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX,MIN,SQRT
C     ..
      MERR = 0
      IF (MODE.LE.0) RETURN
      IF (PL.GE.ZERO) THEN
          MERR = 2
          RETURN

      ELSE IF (RU.LE.RL) THEN
          MERR = 3
          RETURN

      END IF

      DO 10 NTYP = MTYP,1,-1
          IF (NTYP.EQ.1) THEN
*
*     BISECTION
*
              IF (MODE.EQ.1) THEN
                  R = FOUR*RU
                  RETURN

              ELSE
                  R = HALF* (RL+RU)
                  RETURN

              END IF

          ELSE IF (NTYP.EQ.MTYP) THEN
              A = (FU-FL)/ (PL* (RU-RL))
              B = PU/PL
          END IF

          IF (NTYP.EQ.2) THEN
*
*     QUADRATIC EXTRAPOLATION OR INTERPOLATION WITH ONE DIRECTIONAL
*     DERIVATIVE
*
              DEN = TWO* (ONE-A)

          ELSE IF (NTYP.EQ.3) THEN
*
*     QUADRATIC EXTRAPOLATION OR INTERPOLATION WITH TWO DIRECTIONAL
*     DERIVATIVES
*
              DEN = ONE - B

          ELSE IF (NTYP.EQ.4) THEN
*
*     CUBIC EXTRAPOLATION OR INTERPOLATION
*
              C = B - TWO*A + ONE
              D = B - THREE*A + TWO
              DIS = D*D - THREE*C
              IF (DIS.LT.ZERO) GO TO 10
              DEN = D + SQRT(DIS)

          ELSE IF (NTYP.EQ.5) THEN
*
*     CONIC EXTRAPOLATION OR INTERPOLATION
*
              DIS = A*A - B
              IF (DIS.LT.ZERO) GO TO 10
              DEN = A + SQRT(DIS)
              IF (DEN.LT.ZERO) GO TO 10
              DEN = ONE - B* (ONE/DEN)**3
          END IF

          IF (MODE.EQ.1 .AND. DEN.GT.ZERO .AND. DEN.LT.ONE) THEN
*
*     EXTRAPOLATION ACCEPTED
*
              R = RL + (RU-RL)/DEN
              R = MAX(R,C1L*RU)
              R = MIN(R,C1U*RU)
              RETURN

          ELSE IF (MODE.EQ.2 .AND. DEN.GT.ONE) THEN
*
*     INTERPOLATION ACCEPTED
*
              R = RL + (RU-RL)/DEN
              IF (RL.EQ.ZERO) THEN
                  R = MAX(R,RL+C2L* (RU-RL))

              ELSE
                  R = MAX(R,RL+C3L* (RU-RL))
              END IF

              R = MIN(R,RL+C2U* (RU-RL))
              RETURN

          END IF

   10 CONTINUE
      END
* SUBROUTINE PNINT3                ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* EXTRAPOLATION OR INTERPOLATION FOR LINE SEARCH WITHOUT DIRECTIONAL
* DERIVATIVES.
*
* PARAMETERS :
*  RI  RO  INITIAL VALUE OF THE STEPSIZE PARAMETER.
*  RI  RL  LOWER VALUE OF THE STEPSIZE PARAMETER.
*  RI  RU  UPPER VALUE OF THE STEPSIZE PARAMETER.
*  RI  RI  INNER VALUE OF THE STEPSIZE PARAMETER.
*  RI  FO  VALUE OF THE OBJECTIVE FUNCTION FOR R=RO.
*  RI  FL  VALUE OF THE OBJECTIVE FUNCTION FOR R=RL.
*  RI  FU  VALUE OF THE OBJECTIVE FUNCTION FOR R=RU.
*  RI  FI  VALUE OF THE OBJECTIVE FUNCTION FOR R=RI.
*  RO  PO  INITIAL VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RO  R  VALUE OF THE STEPSIZE PARAMETER OBTAINED.
*  II  MODE  MODE OF LINE SEARCH.
*  II  MTYP  METHOD SELECTION. MTYP=1-BISECTION. MTYP=2-TWO POINT
*         QUADRATIC INTERPOLATION. MTYP=2-THREE POINT QUADRATIC
*         INTERPOLATION.
*  IO  MERR  ERROR INDICATOR. MERR=0 FOR NORMAL RETURN.
*
* METHOD :
* EXTRAPOLATION OR INTERPOLATION WITH STANDARD MODEL FUNCTIONS.
*
      SUBROUTINE PNINT3(RO,RL,RU,RI,FO,FL,FU,FI,PO,R,MODE,MTYP,MERR)
C     .. Parameters ..
      DOUBLE PRECISION ZERO,HALF,ONE,TWO,THREE,C1L,C1U,C2L,C2U,C3L
      PARAMETER (ZERO=0.0D0,HALF=0.5D0,ONE=1.0D0,TWO=2.0D0,THREE=3.0D0,
     +          C1L=1.1D0,C1U=1.0D3,C2L=1.0D-2,C2U=0.9D0,C3L=1.0D-1)
C     ..
C     .. Scalar Arguments ..
      DOUBLE PRECISION FI,FL,FO,FU,PO,R,RI,RL,RO,RU
      INTEGER MERR,MODE,MTYP
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION AI,AL,AU,DEN,DIS
      INTEGER NTYP
      LOGICAL L1,L2
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX,MIN,SQRT
C     ..
      MERR = 0
      IF (MODE.LE.0) RETURN
      IF (PO.GE.ZERO) THEN
          MERR = 2
          RETURN

      ELSE IF (RU.LE.RL) THEN
          MERR = 3
          RETURN

      END IF

      L1 = RL .LE. RO
      L2 = RI .LE. RL
      DO 10 NTYP = MTYP,1,-1
          IF (NTYP.EQ.1) THEN
*
*     BISECTION
*
              IF (MODE.EQ.1) THEN
                  R = TWO*RU
                  RETURN

              ELSE IF (RI-RL.LE.RU-RI) THEN
                  R = HALF* (RI+RU)
                  RETURN

              ELSE
                  R = HALF* (RL+RI)
                  RETURN

              END IF

          ELSE IF (NTYP.EQ.MTYP .AND. L1) THEN
              IF (.NOT.L2) AI = (FI-FO)/ (RI*PO)
              AU = (FU-FO)/ (RU*PO)
          END IF

          IF (L1 .AND. (NTYP.EQ.2.OR.L2)) THEN
*
*     TWO POINT QUADRATIC EXTRAPOLATION OR INTERPOLATION
*
              IF (AU.GE.ONE) GO TO 10
              R = HALF*RU/ (ONE-AU)

          ELSE IF (.NOT.L1 .OR. .NOT.L2 .AND. NTYP.EQ.3) THEN
*
*     THREE POINT QUADRATIC EXTRAPOLATION OR INTERPOLATION
*
              AL = (FI-FL)/ (RI-RL)
              AU = (FU-FI)/ (RU-RI)
              DEN = AU - AL
              IF (DEN.LE.ZERO) GO TO 10
              R = RI - HALF* (AU* (RI-RL)+AL* (RU-RI))/DEN

          ELSE IF (L1 .AND. .NOT.L2 .AND. NTYP.EQ.4) THEN
*
*     THREE POINT CUBIC EXTRAPOLATION OR INTERPOLATION
*
              DIS = (AI-ONE)* (RU/RI)
              DEN = (AU-ONE)* (RI/RU) - DIS
              DIS = AU + AI - DEN - TWO* (ONE+DIS)
              DIS = DEN*DEN - THREE*DIS
              IF (DIS.LT.ZERO) GO TO 10
              DEN = DEN + SQRT(DIS)
              IF (DEN.EQ.ZERO) GO TO 10
              R = (RU-RI)/DEN

          ELSE
              GO TO 10

          END IF

          IF (MODE.EQ.1 .AND. R.GT.RU) THEN
*
*     EXTRAPOLATION ACCEPTED
*
              R = MAX(R,C1L*RU)
              R = MIN(R,C1U*RU)
              RETURN

          ELSE IF (MODE.EQ.2 .AND. R.GT.RL .AND. R.LT.RU) THEN
*
*     INTERPOLATION ACCEPTED
*
              IF (RI.EQ.ZERO .AND. NTYP.NE.4) THEN
                  R = MAX(R,RL+C2L* (RU-RL))

              ELSE
                  R = MAX(R,RL+C3L* (RU-RL))
              END IF

              R = MIN(R,RL+C2U* (RU-RL))
              IF (R.EQ.RI) GO TO 10
              RETURN

          END IF

   10 CONTINUE
      END
* SUBROUTINE PNSTP2                ALL SYSTEMS                99/12/01
* PORTABILITY : ALL SYSTEMS
* 99/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
*  STEPSIZE SELECTION USING POLYHEDRAL APPROXIMATION
*  FOR DESCENT STEP IN CONVEX VARIABLE METRIC METHOD.
*
* PARAMETERS :
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  MA  DECLARED NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  II  MAL  CURRENT NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  RU  X(N)  VECTOR OF VARIABLES.
*  RI  AF(4*MA)  VECTOR OF BUNDLE FUNCTIONS VALUES.
*  RI  AG(N*MA)  MATRIX WHOSE COLUMNS ARE BUNDLE SUBGRADIENTS.
*  RI  AY(N*MA)  MATRIX WHOSE COLUMNS ARE VARIABLE VECTORS.
*  RI  S(N)  DIRECTION VECTOR.
*  RI  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RI  DF  DIRECTIONAL DERIVATIVE.
*  RO  T  VALUE OF THE STEPSIZE PARAMETER.
*  RO  TB  BUNDLE PARAMETER FOR MATRIX SCALING.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*
      SUBROUTINE PNSTP2(N,MA,MAL,X,AF,AG,AY,S,F,DF,T,TB,ETA9)
C     .. Scalar Arguments ..
      DOUBLE PRECISION DF,ETA9,F,T,TB
      INTEGER MA,MAL,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AG(*),AY(*),S(*),X(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION ALF,ALFL,ALFR,BET,BETL,BETR,Q,R,W
      INTEGER I,J,JN,K,L,LQ
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,MIN,SQRT
C     ..
      W = DF*T* (1.0D0-T*0.5D0)
*
*     INITIAL CHOICE OF POSSIBLY ACTIVE LINES
*
      K = 0
      L = -1
      JN = 0
      TB = SQRT(ETA9)
      BETR = -ETA9
      DO 20 J = 1,MAL - 1
          BET = 0.0D0
          ALFL = AF(J) - F
          DO 10 I = 1,N
              Q = AG(JN+I)
              ALFL = ALFL + (X(I)-AY(JN+I))*Q
              BET = BET + S(I)*Q
   10     CONTINUE
          ALF = ABS(ALFL)
          R = 1.0D0 - BET/DF
          IF (R*R+ (ALF+ALF)/DF.GT.1.0D-6) THEN
              K = K + 1
              AF(MA+K) = ALF
              AF(MA+MA+K) = BET
              R = T*BET - ALF
              IF (R.GT.W) THEN
                  W = R
                  L = K
              END IF

          END IF

          IF (BET.GT.0.0D0) TB = MIN(TB,ALF/ (BET-DF))
          BETR = MAX(BETR,BET-ALF)
          JN = JN + N
   20 CONTINUE
      IF (L.LT.0 .OR. BETR.LE.DF*0.5D0) RETURN
      LQ = 1
      BETR = AF(MA+MA+L)
      IF (BETR.LE.0.0D0) THEN
          IF (T.LT.1.0D0 .OR. BETR.EQ.0.0D0) RETURN
          LQ = 2
      END IF

      ALFR = AF(MA+L)
*
*     ITERATION LOOP
*
   30 IF (LQ.GE.1) THEN
          Q = 1.0D0 - BETR/DF
          R = Q + SQRT(Q*Q+ (ALFR+ALFR)/DF)
          IF (BETR.GE.0.0D0) R = - (ALFR+ALFR)/ (DF*R)
          R = MIN(1.95D0,MAX(0.0D0,R))

      ELSE
          IF (ABS(BETR-BETL)+ABS(ALFR-ALFL).LT.-1.0D-4*DF) RETURN
          R = (ALFR-ALFL)/ (BETR-BETL)
      END IF

      IF (ABS(T-R).LT.1.0D-4) RETURN
      T = R
      AF(MA+L) = -1.0D0
      W = T*BETR - ALFR
      L = -1
      DO 40 J = 1,K
          ALF = AF(MA+J)
          IF (ALF.LT.0.0D0) GO TO 40
          BET = AF(MA+MA+J)
          R = T*BET - ALF
          IF (R.GT.W) THEN
              W = R
              L = J
          END IF

   40 CONTINUE
      IF (L.LT.0) RETURN
      BET = AF(MA+MA+L)
      IF (BET.EQ.0.0D0) RETURN
*
*     NEW INTERVAL SELECTION
*
      ALF = AF(MA+L)
      IF (BET.LT.0.0D0) THEN
          IF (LQ.EQ.2) THEN
              ALFR = ALF
              BETR = BET

          ELSE
              ALFL = ALF
              BETL = BET
              LQ = 0
          END IF

      ELSE
          IF (LQ.EQ.2) THEN
              ALFL = ALFR
              BETL = BETR
              LQ = 0
          END IF

          ALFR = ALF
          BETR = BET
      END IF

      GO TO 30

      END
* SUBROUTINE PNSTP3                ALL SYSTEMS                99/12/01
* PORTABILITY : ALL SYSTEMS
* 99/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
*  STEPSIZE SELECTION USING POLYHEDRAL APPROXIMATION
*  FOR NULL STEP IN CONVEX VARIABLE METRIC METHOD.
*
* PARAMETERS :
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  MA  DECLARED NUMBER OF LINEAR APPROXIMATED FUNCTIONS
*  II  MAL  CURRENT NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  RU  X(N)  VECTOR OF VARIABLES.
*  RI  AF(4*MA)  VECTOR OF BUNDLE FUNCTIONS VALUES.
*  RI  AG(N*MA)  MATRIX WHOSE COLUMNS ARE BUNDLE SUBGRADIENTS.
*  RI  AY(N*MA)  MATRIX WHOSE COLUMNS ARE VARIABLE VECTORS.
*  RI  S(N)  DIRECTION VECTOR.
*  RI  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RI  DF  DIRECTIONAL DERIVATIVE.
*  RO  T  VALUE OF THE STEPSIZE PARAMETER.
*  RO  TB  BUNDLE PARAMETER FOR MATRIX SCALING.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*
      SUBROUTINE PNSTP3(N,MA,MAL,X,AF,AG,AY,S,F,DF,T,TB,ETA9)
C     .. Scalar Arguments ..
      DOUBLE PRECISION DF,ETA9,F,T,TB
      INTEGER MA,MAL,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AG(*),AY(*),S(*),X(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION ALF,ALFL,ALFR,BET,BETL,BETR,R,TP,W
      INTEGER I,J,JN,K,L
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MIN,SQRT
C     ..
      W = DF*T
      TP = T
*
*     INITIAL CHOICE OF POSSIBLY ACTIVE LINES
*
      K = 0
      L = -1
      JN = 0
      TB = SQRT(ETA9)
      DO 20 J = 1,MAL - 1
          BET = 0.0D0
          ALFL = AF(J) - F
          DO 10 I = 1,N
              R = AG(JN+I)
              ALFL = ALFL + (X(I)-AY(JN+I))*R
              BET = BET + S(I)*R
   10     CONTINUE
          ALF = ABS(ALFL)
          R = T*BET - ALF
          IF (R.GT.DF*T) THEN
              K = K + 1
              AF(MA+K) = ALF
              AF(MA+MA+K) = BET
              IF (R.GT.W) THEN
                  W = R
                  L = K
              END IF

          END IF

          IF (BET.GT.0.0D0) TB = MIN(TB,ALF/ (BET-DF))
          JN = JN + N
   20 CONTINUE
      IF (L.LT.0) RETURN
      BETR = AF(MA+MA+L)
      IF (BETR.LE.0.0D0) RETURN
      ALFR = AF(MA+L)
      ALF = ALFR
      BET = BETR
      ALFL = 0.0D0
      BETL = DF
*
*     ITERATION LOOP
*
   30 IF (ABS(BETR-BETL)+ABS(ALFR-ALFL).LT.-1.0D-4*DF) RETURN
      R = T
      IF (BETR-BETL.NE.0.0D0) T = MIN((ALFR-ALFL)/ (BETR-BETL),TP)
      IF (ABS(T-R).LT.1.0D-3) RETURN
      AF(MA+L) = -1.0D0
      W = T*BET - ALF
      L = -1
      DO 40 J = 1,K
          ALF = AF(MA+J)
          IF (ALF.LT.0.0D0) GO TO 40
          BET = AF(MA+MA+J)
          R = T*BET - ALF
          IF (R.GT.W) THEN
              W = R
              L = J
          END IF

   40 CONTINUE
      IF (L.LT.0) RETURN
*
*     NEW INTERVAL SELECTION
*
      BET = AF(MA+MA+L)
      ALF = AF(MA+L)
      IF (BET.LE.0.0D0) THEN
          ALFL = ALF
          BETL = BET

      ELSE
          ALFR = ALF
          BETR = BET
      END IF

      GO TO 30

      END
* SUBROUTINE PNSTP4                ALL SYSTEMS                99/12/01
* PORTABILITY : ALL SYSTEMS
* 99/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
*  STEPSIZE SELECTION USING POLYHEDRAL APPROXIMATION
*  FOR DESCENT STEP IN NONCONVEX VARIABLE METRIC METHOD.
*
* PARAMETERS :
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  MA  DECLARED NUMBER OF LINEAR APPROXIMATED FUNCTIONS
*  II  MAL  CURRENT NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  RU  X(N)  VECTOR OF VARIABLES.
*  RI  AF(4*MA)  VECTOR OF BUNDLE FUNCTIONS VALUES.
*  RI  AG(N*MA)  MATRIX WHOSE COLUMNS ARE BUNDLE SUBGRADIENTS.
*  RI  AY(N*MA)  MATRIX WHOSE COLUMNS ARE VARIABLE VECTORS.
*  RI  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RI  DF  DIRECTIONAL DERIVATIVE.
*  RO  T  VALUE OF THE STEPSIZE PARAMETER.
*  RO  TB  BUNDLE PARAMETER FOR MATRIX SCALING.
*  RI  ETA5  DISTANCE MEASURE PARAMETER.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*  RI  MOS3  LOCALITY MEASURE PARAMETER.
*
      SUBROUTINE PNSTP4(N,MA,MAL,X,AF,AG,AY,S,F,DF,T,TB,ETA5,ETA9,MOS3)
C     .. Scalar Arguments ..
      DOUBLE PRECISION DF,ETA5,ETA9,F,T,TB
      INTEGER MA,MAL,MOS3,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AG(*),AY(*),S(*),X(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION ALF,ALFL,ALFR,BET,BETL,BETR,DX,Q,R,W
      INTEGER I,J,JN,K,L,LQ
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,DBLE,MAX,MIN,SQRT
C     ..
      W = DF*T* (1.0D0-T*0.5D0)
*
*     INITIAL CHOICE OF POSSIBLY ACTIVE LINES
*
      K = 0
      L = -1
      JN = 0
      TB = SQRT(ETA9)
      BETR = -ETA9
      DO 20 J = 1,MAL - 1
          R = 0.0D0
          BET = 0.0D0
          ALFL = AF(J) - F
          DO 10 I = 1,N
              DX = X(I) - AY(JN+I)
              Q = AG(JN+I)
              R = R + DX*DX
              ALFL = ALFL + DX*Q
              BET = BET + S(I)*Q
   10     CONTINUE
          IF (MOS3.NE.2) R = R** (DBLE(MOS3)*0.5D0)
          ALF = MAX(ABS(ALFL),ETA5*R)
          R = 1.0D0 - BET/DF
          IF (R*R+ (ALF+ALF)/DF.GT.1.0D-6) THEN
              K = K + 1
              AF(MA+K) = ALF
              AF(MA+MA+K) = BET
              R = T*BET - ALF
              IF (R.GT.W) THEN
                  W = R
                  L = K
              END IF

          END IF

          IF (BET.GT.0.0D0) TB = MIN(TB,ALF/ (BET-DF))
          BETR = MAX(BETR,BET-ALF)
          JN = JN + N
   20 CONTINUE
      LQ = -1
      IF (BETR.LE.DF*0.5D0) RETURN
      LQ = 1
      IF (L.LT.0) RETURN
      BETR = AF(MA+MA+L)
      IF (BETR.LE.0.0D0) THEN
          IF (T.LT.1.0D0 .OR. BETR.EQ.0.0D0) RETURN
          LQ = 2
      END IF

      ALFR = AF(MA+L)
*
*     ITERATION LOOP
*
   30 IF (LQ.GE.1) THEN
          Q = 1.0D0 - BETR/DF
          R = Q + SQRT(Q*Q+ (ALFR+ALFR)/DF)
          IF (BETR.GE.0.0D0) R = - (ALFR+ALFR)/ (DF*R)
          R = MIN(1.95D0,MAX(0.0D0,R))

      ELSE
          IF (ABS(BETR-BETL)+ABS(ALFR-ALFL).LT.-1.0D-4*DF) RETURN
          R = (ALFR-ALFL)/ (BETR-BETL)
      END IF

      IF (ABS(T-R).LT.1.0D-4) RETURN
      T = R
      AF(MA+L) = -1.0D0
      W = T*BETR - ALFR
      L = -1
      DO 40 J = 1,K
          ALF = AF(MA+J)
          IF (ALF.LT.0.0D0) GO TO 40
          BET = AF(MA+MA+J)
          R = T*BET - ALF
          IF (R.GT.W) THEN
              W = R
              L = J
          END IF

   40 CONTINUE
      IF (L.LT.0) RETURN
      BET = AF(MA+MA+L)
      IF (BET.EQ.0.0D0) RETURN
*
*     NEW INTERVAL SELECTION
*
      ALF = AF(MA+L)
      IF (BET.LT.0.0D0) THEN
          IF (LQ.EQ.2) THEN
              ALFR = ALF
              BETR = BET

          ELSE
              ALFL = ALF
              BETL = BET
              LQ = 0
          END IF

      ELSE
          IF (LQ.EQ.2) THEN
              ALFL = ALFR
              BETL = BETR
              LQ = 0
          END IF

          ALFR = ALF
          BETR = BET
      END IF

      GO TO 30

      END
* SUBROUTINE PNSTP5                ALL SYSTEMS                99/12/01
* PORTABILITY : ALL SYSTEMS
* 99/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
*  STEPSIZE SELECTION USING POLYHEDRAL APPROXIMATION
*  FOR NULL STEP IN NONCONVEX VARIABLE METRIC METHOD.
*
* PARAMETERS :
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  MA  DECLARED NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  II  MAL  CURRENT NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  RU  X(N)  VECTOR OF VARIABLES.
*  RI  AF(4*MA)  VECTOR OF BUNDLE FUNCTIONS VALUES.
*  RI  AG(N*MA)  MATRIX WHOSE COLUMNS ARE BUNDLE SUBGRADIENTS.
*  RI  AY(N*MA)  MATRIX WHOSE COLUMNS ARE VARIABLE VECTORS.
*  RI  S(N)  DIRECTION VECTOR.
*  RI  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RI  DF  DIRECTIONAL DERIVATIVE.
*  RO  T  VALUE OF THE STEPSIZE PARAMETER.
*  RO  TB  BUNDLE PARAMETER FOR MATRIX SCALING.
*  RI  ETA5  DISTANCE MEASURE PARAMETER.
*  RI  ETA9  MAXIMUM FOR REAL NUMBERS.
*  RI  MOS3  LOCALITY MEASURE PARAMETER.
*
      SUBROUTINE PNSTP5(N,MA,MAL,X,AF,AG,AY,S,F,DF,T,TB,ETA5,ETA9,MOS3)
C     .. Scalar Arguments ..
      DOUBLE PRECISION DF,ETA5,ETA9,F,T,TB
      INTEGER MA,MAL,MOS3,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AG(*),AY(*),S(*),X(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION ALF,ALFL,ALFR,BET,BETL,BETR,DX,Q,R,W
      INTEGER I,J,JN,K,L
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,DBLE,MAX,MIN,SQRT
C     ..
      W = DF*T
*
*     INITIAL CHOICE OF POSSIBLY ACTIVE PARABOLAS
*
      K = 0
      L = -1
      JN = 0
      TB = SQRT(ETA9)
      BETR = -ETA9
      DO 20 J = 1,MAL - 1
          BET = 0.0D0
          R = 0.0D0
          ALFL = AF(J) - F
          DO 10 I = 1,N
              DX = X(I) - AY(JN+I)
              R = R + DX*DX
              Q = AG(JN+I)
              ALFL = ALFL + DX*Q
              BET = BET + S(I)*Q
   10     CONTINUE
          IF (MOS3.NE.2) R = R** (DBLE(MOS3)*0.5D0)
          ALF = MAX(ABS(ALFL),ETA5*R)
          IF (BET+BET.GT.DF) TB = MIN(TB,ALF/ (BET-DF))
          BETR = MAX(BETR,BET-ALF)
          IF (ALF.LT.BET-DF) THEN
              K = K + 1
              R = T*BET - ALF
              AF(MA+K) = ALF
              AF(MA+MA+K) = BET
              IF (R.GT.W) THEN
                  W = R
                  L = K
              END IF

          END IF

          JN = JN + N
   20 CONTINUE
      IF (L.LT.0) RETURN
      BETR = AF(MA+MA+L)
      ALFR = AF(MA+L)
      ALF = ALFR
      BET = BETR
      ALFL = 0.0D0
      BETL = DF
*
*     ITERATION LOOP
*
   30 W = BET/DF
      IF (ABS(BETR-BETL)+ABS(ALFR-ALFL).LT.-1.0D-4*DF) RETURN
      IF (BETR-BETL.EQ.0.0D0) STOP 11
      R = (ALFR-ALFL)/ (BETR-BETL)
      IF (ABS(T-W).LT.ABS(T-R)) R = W
      Q = T
      T = R
      IF (ABS(T-Q).LT.1.0D-3) RETURN
      AF(MA+L) = -1.0D0
      W = T*BET - ALF
      L = -1
      DO 40 J = 1,K
          ALF = AF(MA+J)
          IF (ALF.LT.0.0D0) GO TO 40
          BET = AF(MA+MA+J)
          R = T*BET - ALF
          IF (R.GT.W) THEN
              W = R
              L = J
          END IF

   40 CONTINUE
      IF (L.LT.0) RETURN
      BET = AF(MA+MA+L)
      Q = BET - T*DF
      IF (Q.EQ.0.0D0) RETURN
*
*     NEW INTERVAL SELECTION
*
      ALF = AF(MA+L)
      IF (Q.LT.0.0D0) THEN
          ALFL = ALF
          BETL = BET

      ELSE
          ALFR = ALF
          BETR = BET
      END IF

      GO TO 30

      END
* SUBROUTINE PYADB4             ALL SYSTEMS                   98/12/01
* PORTABILITY : ALL SYSTEMS
* 98/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* NEW LINEAR CONSTRAINTS OR NEW SIMPLE BOUNDS ARE ADDED TO THE ACTIVE
* SET. GILL-MURRAY FACTORIZATION OF THE TRANSFORMED HESSIAN MATRIX
* APPROXIMATION IS UPDATED.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  IU  N  ACTUAL NUMBER OF VARIABLES.
*  II  NC  NUMBER OF LINEARIZED CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  IU  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  CF(NC)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCTIONS.
*  RI  CFD(NC) VECTOR CONTAINING INCREMENTS OF THE CONSTRAINT FUNCTIONS.
*  IU  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  IU  ICA(NF)  VECTOR CONTAINING INDICES OF ACTIVE CONSTRAINTS.
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RU  CR(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RU  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM THE
*         CURRENT REDUCED SUBSPACE.
*  RU  H(NF*(NF+1)/2)  GILL-MURRAY FACTORIZATION OF THE TRANSFORMED
*         HESSIAN MATRIX APPROXIMATION.
*  RA  S(NF)  AUXILIARY VECTOR.
*  RI  R  VALUE OF THE STEPSIZE PARAMETER.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RI  EPS9  TOLERANCE FOR ACTIVE CONSTRAINTS.
*  RO  GMAX  MAXIMUM ABSOLUTE VALUE OF A PARTIAL DERIVATIVE.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF A NEGATIVE LAGRANGE MULTIPLIER.
*  II  KBF  TYPE OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS. KBF=1-ONE
*         SIDED SIMPLE BOUNDS. KBF=2-TWO SIDED SIMPLE BOUNDS.
*  II  KBC  TYPE OF CONSTRAINTS. KBC=0-NO CONSTRAINTS. KBC=1-CONSTRAINTS
*         WITH ONE SIDED BOUNDS. KBC=2-CONSTRAINTS WITH TWO SIDED
*         BOUNDS.
*  IU  INEW  INDEX OF THE NEW ACTIVE CONSTRAINT.
*  IO  IER  ERROR INDICATOR.
*  IO  ITERM  TERMINATION INDICATOR.
*
* COMMON DATA :
*  IU  NADD  NUMBER OF CONSTRAINT ADDITIONS.
*
* SUBPROGRAMS USED :
*  S   PLADB4  ADDITION OF A NEW ACTIVE CONSTRAINT.
*  S   PLNEWS  IDENTIFICATION OF ACTIVE UPPER BOUNDS.
*  S   PLNEWL  IDENTIFICATION OF ACTIVE LINEAR CONSTRAINRS.
*  S   PLDIRL  NEW VALUES OF CONSTRAINT FUNCTIONS.
*  S   MXVIND  CHANGE OF THE INTEGER VECTOR FOR CONSTRAINT ADDITION.
*
      SUBROUTINE PYADB4(NF,N,NC,X,IX,XL,XU,CF,CFD,IC,ICA,CL,CU,CG,CR,CZ,
     +                  H,S,R,EPS7,EPS9,GMAX,UMAX,KBF,KBC,INEW,IER,
     +                  ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS7,EPS9,GMAX,R,UMAX
      INTEGER IER,INEW,ITERM,KBC,KBF,N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CFD(*),CG(*),CL(*),CR(*),CU(*),CZ(*),H(*),
     +                 S(*),X(*),XL(*),XU(*)
      INTEGER IC(*),ICA(*),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION DEN,TEMP
      INTEGER I,IJ,IK,J,K,KC,KJ,KK,L,LL
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVIND,PLADB4,PLDIRL,PLNEWL,PLNEWS
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (KBC.GT.0) THEN
          IF (R.NE.0.0D0) CALL PLDIRL(NC,CF,CFD,IC,R,KBC)
          IF (INEW.NE.0) THEN
              IF (KBF.GT.0) THEN
                  DO 10 I = 1,NF
                      INEW = 0
                      CALL PLNEWS(X,IX,XL,XU,EPS9,I,INEW)
                      CALL PLADB4(NF,N,ICA,CG,CR,CZ,H,S,EPS7,GMAX,UMAX,
     +                            9,INEW,NADD,IER)
                      CALL MXVIND(IX,I,IER)
                      IF (IER.LT.0) THEN
                          ITERM = -15
                          RETURN

                      END IF

   10             CONTINUE
              END IF

              DO 20 KC = 1,NC
                  INEW = 0
                  CALL PLNEWL(KC,CF,IC,CL,CU,EPS9,INEW)
                  CALL PLADB4(NF,N,ICA,CG,CR,CZ,H,S,EPS7,GMAX,UMAX,9,
     +                        INEW,NADD,IER)
                  CALL MXVIND(IC,KC,IER)
                  IF (IER.LT.0) THEN
                      ITERM = -15
                      RETURN

                  END IF

   20         CONTINUE
          END IF

      ELSE IF (KBF.GT.0) THEN
          K = 0
          DO 70 L = 1,NF
              IF (IX(L).GE.0) K = K + 1
              INEW = 0
              CALL PLNEWS(X,IX,XL,XU,EPS9,L,INEW)
              IF (INEW.NE.0) THEN
                  IX(L) = 10 - IX(L)
                  KK = K* (K-1)/2
                  DEN = H(KK+K)
                  IF (DEN.NE.0.0D0) THEN
                      IJ = 0
                      KJ = KK
                      DO 40 J = 1,N
                          IF (J.LE.K) THEN
                              KJ = KJ + 1

                          ELSE
                              KJ = KJ + J - 1
                          END IF

                          IF (J.NE.K) TEMP = H(KJ)/DEN
                          IK = KK
                          DO 30 I = 1,J
                              IF (I.LE.K) THEN
                                  IK = IK + 1

                              ELSE
                                  IK = IK + I - 1
                              END IF

                              IJ = IJ + 1
                              IF (I.NE.K .AND. J.NE.K) H(IJ) = H(IJ) +
     +                            TEMP*H(IK)
   30                     CONTINUE
   40                 CONTINUE
                  END IF

                  LL = KK + K
                  DO 60 I = K + 1,N
                      DO 50 J = 1,I
                          LL = LL + 1
                          IF (J.NE.K) THEN
                              KK = KK + 1
                              H(KK) = H(LL)
                          END IF

   50                 CONTINUE
   60             CONTINUE
                  N = N - 1
              END IF

   70     CONTINUE
      END IF

      RETURN

      END
* SUBROUTINE PYAGB1                ALL SYSTEMS                99/12/01
* PORTABILITY : ALL SYSTEMS
* 99/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
*  SUBGRADIENT AGGREGATION FOR NONSMOOTH VARIABLE METRIC METHOD.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  RI  H(N*(N+1)/2)  POSITIVE DEFINITE APPROXIMATION OF THE INVERSE
*         HESSIAN MATRIX.
*  RI  G(NF)  SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RI  GO(NF)  PREVIOUS SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RU  GV(NF)  AGGREGATED SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RU  GN(N)  REDUCED AGGREGATED SUBGRADIENT.
*  RI  SN(N)  REDUCED DIRECTION VECTOR.
*  RI  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM THE
*         CURRENT REDUCED SUBSPACE.
*  RU  S(N)  REDUCED SUBGRADIENT.
*  RU  U(N)  PREVIOUS REDUCED SUBGRADIENT.
*  RO  ALF  LINEARIZATION TERM.
*  RU  ALFV  AGGREGATED LINEARIZATION TERM.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*
      SUBROUTINE PYAGB1(NF,N,IX,H,G,GO,GV,GN,SN,CZ,S,U,ALF,ALFV,KBF,KBC)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ALF,ALFV
      INTEGER KBC,KBF,N,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CZ(*),G(*),GN(*),GO(*),GV(*),H(*),S(*),SN(*),U(*)
      INTEGER IX(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION A,ALFM,B,LAM1,LAM2,PQ,PR,PRQR,QQP,QR,RR,RRP,RRQ,
     +                 W,W1,W2
      INTEGER I,J,K,L
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDRMM
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX,MIN
C     ..
      ALFM = 0.0D0
*
*     GENERAL ROUTINE - HERE ALWAYS INPUT PARAMETER ALFM=0
*
      RR = ALFV + ALFV
      RRP = ALFV - ALFM
      RRQ = ALFV - ALF
      PQ = 0.0D0
      PR = 0.0D0
      QR = 0.0D0
      QQP = ALF - ALFM
      PRQR = 0.0D0
      IF (KBC.GT.0) THEN
          CALL MXDRMM(NF,N,CZ,G,S)
          CALL MXDRMM(NF,N,CZ,GO,U)
          DO 10 I = 1,N
              RR = RR - SN(I)*GN(I)
              U(I) = U(I) - GN(I)
              GN(I) = S(I) - GN(I)
              RRP = RRP + SN(I)*U(I)
              RRQ = RRQ + SN(I)*GN(I)
   10     CONTINUE
          DO 40 I = 1,N
              L = I* (I-1)/2 + 1
              W1 = 0.0D0
              W2 = 0.0D0
              DO 20 J = 1,I - 1
                  W = H(L)
                  W1 = W1 + W*GN(J)
                  W2 = W2 + W*U(J)
                  L = L + 1
   20         CONTINUE
              DO 30 J = I,N
                  W = H(L)
                  W1 = W1 + W*GN(J)
                  W2 = W2 + W*U(J)
                  L = L + J
   30         CONTINUE
              PR = PR + U(I)*W2
              QR = QR + GN(I)*W1
              PQ = PQ + (GN(I)-U(I))* (W1-W2)
              QQP = QQP + S(I)* (W1-W2)
              PRQR = PRQR + U(I)*W1
   40     CONTINUE

      ELSE IF (KBF.GT.0) THEN
          K = 0
          DO 50 I = 1,NF
              IF (IX(I).GE.0) THEN
                  K = K + 1
                  RR = RR - S(I)*GV(I)
                  U(K) = GO(I) - GV(I)
                  W = G(I) - GV(I)
                  RRP = RRP + S(I)*U(K)
                  RRQ = RRQ + S(I)*W
                  S(K) = W
              END IF

   50     CONTINUE
          K = 0
          DO 80 I = 1,NF
              IF (IX(I).GE.0) THEN
                  K = K + 1
                  L = K* (K-1)/2 + 1
                  W1 = 0.0D0
                  W2 = 0.0D0
                  DO 60 J = 1,K - 1
                      W = H(L)
                      W1 = W1 + W*S(J)
                      W2 = W2 + W*U(J)
                      L = L + 1
   60             CONTINUE
                  DO 70 J = K,N
                      W = H(L)
                      W1 = W1 + W*S(J)
                      W2 = W2 + W*U(J)
                      L = L + J
   70             CONTINUE
                  PR = PR + U(K)*W2
                  QR = QR + S(K)*W1
                  PQ = PQ + (S(K)-U(K))* (W1-W2)
                  QQP = QQP + G(I)* (W1-W2)
                  PRQR = PRQR + U(K)*W1
              END IF

   80     CONTINUE

      ELSE
          DO 90 I = 1,NF
              RR = RR - S(I)*GV(I)
              U(I) = GO(I) - GV(I)
              GV(I) = G(I) - GV(I)
              RRP = RRP + S(I)*U(I)
              RRQ = RRQ + S(I)*GV(I)
   90     CONTINUE
          DO 120 I = 1,NF
              L = I* (I-1)/2 + 1
              W1 = 0.0D0
              W2 = 0.0D0
              DO 100 J = 1,I - 1
                  W = H(L)
                  W1 = W1 + W*GV(J)
                  W2 = W2 + W*U(J)
                  L = L + 1
  100         CONTINUE
              DO 110 J = I,NF
                  W = H(L)
                  W1 = W1 + W*GV(J)
                  W2 = W2 + W*U(J)
                  L = L + J
  110         CONTINUE
              PR = PR + U(I)*W2
              QR = QR + GV(I)*W1
              PQ = PQ + (GV(I)-U(I))* (W1-W2)
              QQP = QQP + G(I)* (W1-W2)
              PRQR = PRQR + U(I)*W1
  120     CONTINUE
      END IF

      IF (PR.LE.0.0D0 .OR. QR.LE.0.0D0) GO TO 130
      A = RRQ/QR
      B = PRQR/QR
      W = PRQR*B - PR
      IF (W.EQ.0.0D0) GO TO 130
      LAM1 = (A*PRQR-RRP)/W
      LAM2 = A - LAM1*B
      IF (LAM1* (LAM1-1.0D0).LT.0.0D0 .AND.
     +    LAM2* (LAM1+LAM2-1.0D0).LT.0.0D0) GO TO 140
*
*     MINIMUM ON THE BOUNDARY
*
  130 LAM1 = 0.0D0
      LAM2 = 0.0D0
      IF (ALF.LE.ALFV) LAM2 = 1.0D0
      IF (QR.GT.0.0D0) LAM2 = MIN(1.0D0,MAX(0.0D0,RRQ/QR))
      W = (LAM2*QR-RRQ-RRQ)*LAM2
      A = 0.0D0
      IF (ALFM.LE.ALFV) A = 1.0D0
      IF (PR.GT.0.0D0) A = MIN(1.0D0,MAX(0.0D0,RRP/PR))
      B = (A*PR-RRP-RRP)*A
      IF (B.LT.W) THEN
          W = B
          LAM1 = A
          LAM2 = 0.0D0
      END IF

      IF (QQP* (QQP-PQ).GE.0.0D0) GO TO 140
      IF (QR-RRQ-RRQ-QQP*QQP/PQ.GE.W) GO TO 140
      LAM1 = QQP/PQ
      LAM2 = 1.0D0 - LAM1
  140 IF (LAM1.EQ.0.0D0 .AND. LAM2* (LAM2-1.0D0).LT.0.0D0 .AND.
     +    RRP-LAM2*PRQR.GT.0.0D0 .AND. PR.GT.
     +    0.0D0) LAM1 = MIN(1.0D0-LAM2, (RRP-LAM2*PRQR)/PR)
      A = 1.0D0 - LAM1 - LAM2
      B = 1.0D0 - LAM2
      IF (KBC.GT.0) THEN
          DO 150 I = 1,N
              GN(I) = S(I) + LAM1*U(I) - B*GN(I)
  150     CONTINUE
          DO 160 I = 1,NF
              GV(I) = LAM1*GO(I) + LAM2*G(I) + A*GV(I)
  160     CONTINUE

      ELSE IF (KBF.GT.0) THEN
          K = 0
          DO 170 I = 1,NF
              GV(I) = LAM1*GO(I) + LAM2*G(I) + A*GV(I)
              IF (IX(I).GE.0) THEN
                  K = K + 1
                  GN(K) = GV(I)
              END IF

  170     CONTINUE

      ELSE
          DO 180 I = 1,NF
              GV(I) = LAM1*GO(I) + (1.0D0-LAM1)*G(I) - A*GV(I)
  180     CONTINUE
      END IF

      ALFV = LAM1*ALFM + LAM2*ALF + A*ALFV
      RETURN

      END
* SUBROUTINE PYAGB2                ALL SYSTEMS                99/12/01
* PORTABILITY : ALL SYSTEMS
* 99/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
*  SIMPLIFIED AGGREGATION FOR NONSMOOTH VARIABLE METRIC METHOD.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  RI  H(M)  POSITIVE DEFINITE APPROXIMATION OF THE INVERSE HESSIAN
*         MATRIX.
*  RI  G(N)  SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RU  GV(N)  AGGREGATED SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RU  GN(N)  REDUCED AGGREGATED SUBGRADIENT.
*  RI  SN(N)  REDUCED DIRECTION VECTOR.
*  RI  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM THE
*         CURRENT REDUCED SUBSPACE.
*  RU  S(N)  REDUCED SUBGRADIENT.
*  RO  ALF  LINEARIZATION TERM.
*  RU  ALFV  AGGREGATED LINEARIZATION TERM.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*
      SUBROUTINE PYAGB2(NF,N,IX,H,G,GV,GN,SN,CZ,S,ALF,ALFV,KBF,KBC)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ALF,ALFV
      INTEGER KBC,KBF,N,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CZ(*),G(*),GN(*),GV(*),H(*),S(*),SN(*)
      INTEGER IX(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION LAM,P,Q,W
      INTEGER I,J,K,L
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDRMM
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX,MIN,SIGN
C     ..
      P = ALFV - ALF
      IF (KBC.GT.0) THEN
          CALL MXDRMM(NF,N,CZ,G,S)
          DO 10 I = 1,N
              GN(I) = S(I) - GN(I)
              P = P + SN(I)*GN(I)
   10     CONTINUE
          Q = 0.0D0
          DO 40 I = 1,N
              L = I* (I-1)/2 + 1
              W = 0.0D0
              DO 20 J = 1,I - 1
                  W = W + H(L)*GN(J)
                  L = L + 1
   20         CONTINUE
              DO 30 J = I,N
                  W = W + H(L)*GN(J)
                  L = L + J
   30         CONTINUE
              Q = Q + W*GN(I)
   40     CONTINUE
          LAM = 0.5D0 + SIGN(0.5D0,P)
          IF (Q.GT.0.0D0) LAM = MIN(1.0D0,MAX(0.0D0,P/Q))
          P = 1.0D0 - LAM
          DO 50 I = 1,N
              GN(I) = S(I) - P*GN(I)
   50     CONTINUE
          DO 60 I = 1,NF
              GV(I) = LAM*G(I) + P*GV(I)
   60     CONTINUE

      ELSE IF (KBF.GT.0) THEN
          K = 0
          DO 70 I = 1,NF
              IF (IX(I).GE.0) THEN
                  K = K + 1
                  Q = G(I) - GV(I)
                  P = P + S(I)*Q
                  S(K) = Q
              END IF

   70     CONTINUE
          Q = 0.0D0
          K = 0
          DO 100 I = 1,NF
              IF (IX(I).GE.0) THEN
                  K = K + 1
                  L = K* (K-1)/2 + 1
                  W = 0.0D0
                  DO 80 J = 1,K - 1
                      W = W + H(L)*S(J)
                      L = L + 1
   80             CONTINUE
                  DO 90 J = K,N
                      W = W + H(L)*S(J)
                      L = L + J
   90             CONTINUE
                  Q = Q + W*S(K)
              END IF

  100     CONTINUE
          LAM = 0.5D0 + SIGN(0.5D0,P)
          IF (Q.GT.0.0D0) LAM = MIN(1.0D0,MAX(0.0D0,P/Q))
          P = 1.0D0 - LAM
          K = 0
          DO 110 I = 1,NF
              GV(I) = LAM*G(I) + P*GV(I)
              IF (IX(I).GE.0) THEN
                  K = K + 1
                  GN(K) = GV(I)
              END IF

  110     CONTINUE

      ELSE
          DO 120 I = 1,NF
              GV(I) = G(I) - GV(I)
              P = P + S(I)*GV(I)
  120     CONTINUE
          Q = 0.0D0
          DO 150 I = 1,NF
              L = I* (I-1)/2 + 1
              W = 0.0D0
              DO 130 J = 1,I - 1
                  W = W + H(L)*GV(J)
                  L = L + 1
  130         CONTINUE
              DO 140 J = I,NF
                  W = W + H(L)*GV(J)
                  L = L + J
  140         CONTINUE
              Q = Q + W*GV(I)
  150     CONTINUE
          LAM = 0.5D0 + SIGN(0.5D0,P)
          IF (Q.GT.0.0D0) LAM = MIN(1.0D0,MAX(0.0D0,P/Q))
          P = 1.0D0 - LAM
          DO 160 I = 1,NF
              GV(I) = G(I) - P*GV(I)
  160     CONTINUE
      END IF

      ALFV = LAM*ALF + P*ALFV
      RETURN

      END
* SUBROUTINE PYBUN1                ALL SYSTEMS                97/12/01
* PORTABILITY : ALL SYSTEMS
* 97/12/01 VL : ORIGINAL VERSION
*
* PURPOSE :
*  VARIABLE METRIC UPDATE OF A DENSE SYMMETRIC POSITIVE DEFINITE MATRIX
*  WITH THE POSSIBILITY OF MATRIX INNOVATION.
*
* PARAMETERS :
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  MA  DECLARED NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  II  MAL  CURRENT NUMBER OF LINEAR APPROXIMATED FUNCTIONS.
*  RI  X(N)  VECTOR OF VARIABLES.
*  RI  G(N)  SUBGRADIENT OF THE OBJECTIVE FUNCTION.
*  RI  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RU  AY(N*MA)  MATRIX WHOSE COLUMNS ARE VARIABLE VECTORS.
*  RU  AG(N*MA)  MATRIX WHOSE COLUMNS ARE BUNDLE SUBGRADIENTS.
*  RU  AF(4*MA)  VECTOR OF VALUES OF BUNDLE FUNCTIONS.
*  IO  ITERS  NULL STEP INDICATOR. ITERS=0-NULL STEP. ITERS=1-DESCENT
*         STEP.
*
* SUBPROGRAMS USED :
*  RF  MXVDOT  DOT PRODUCT OF VECTORS.
*
      SUBROUTINE PYBUN1(N,MA,MAL,X,G,F,AY,AG,AF,ITERS)
C     .. Scalar Arguments ..
      DOUBLE PRECISION F
      INTEGER ITERS,MA,MAL,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AF(*),AG(*),AY(*),G(*),X(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,IND,K,KN,L
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVCOP
C     ..
      L = 0
      IF (ITERS.EQ.0) L = 1
*
*     BUNDLE REDUCTION
*
      KN = 0
      IF (MAL.GE.MA) THEN
          DO 20 K = 1,MAL - 1
              KN = K*N - N
              DO 10 I = 1,N
                  IF (G(I).NE.AG(KN+I)) GO TO 20
   10         CONTINUE
              IND = K
              GO TO 30

   20     CONTINUE
          IND = 1
   30     DO 40 K = IND,MAL - 1
              AF(K) = AF(K+1)
              AF(K+MA*3) = AF(K+1+MA*3)
              KN = K*N + 1
              CALL MXVCOP(N,AG(KN),AG(KN-N))
              CALL MXVCOP(N,AY(KN),AY(KN-N))
   40     CONTINUE
          MAL = MAL - 1
      END IF
*
*     BUNDLE COMPLETION
*
      IF (L.GT.0 .AND. KN.EQ.0) THEN
          AF(MAL+1) = AF(MAL)
          AF(3*MA+MAL+1) = AF(3*MA+MAL)
          KN = MAL*N + 1
          CALL MXVCOP(N,AG(KN-N),AG(KN))
          CALL MXVCOP(N,AY(KN-N),AY(KN))
      END IF

      MAL = MAL + 1
      KN = MAL - L
      AF(KN) = F
      AF(KN+MA*3) = L
      K = (KN-1)*N + 1
      CALL MXVCOP(N,G,AG(K))
      CALL MXVCOP(N,X,AY(K))
      RETURN

      END
* SUBROUTINE PYRMB1               ALL SYSTEMS                98/12/01
* PORTABILITY : ALL SYSTEMS
* 98/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* OLD LINEAR CONSTRAINT OR AN OLD SIMPLE BOUND IS REMOVED FROM THE
* ACTIVE SET. TRANSFORMED GRADIENT OF THE OBJECTIVE FUNCTION AND
* TRANSFORMED HESSIAN MATRIX APPROXIMATION ARE UPDATED.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  IU  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  IU  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  IU  ICA(NF)  VECTOR CONTAINING INDICES OF ACTIVE CONSTRAINTS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RU  CR(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RU  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM THE
*         CURRENT REDUCED SUBSPACE.
*  RI  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  RU  GN(NF)  TRANSFORMED GRADIENT OF THE OBJECTIVE FUNCTION.
*  RU  H(NF*(NF+1)/2)  TRANSFORMED HESSIAN MATRIX APPROXIMATION.
*  RI  EPS8  TOLERANCE FOR CONSTRAINT TO BE REMOVED.
*  RI  UMAX  MAXIMUN ABSOLUTE VALUE OF THE NEGATIVE LAGRANGE MULTIPLIER.
*  RI  GMAX  NORM OF THE TRANSFORMED GRADIENT.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*  II  IOLD  INDEX OF THE REMOVED CONSTRAINT.
*  IA  KOLD  AUXILIARY VARIABLE.
*  IA  KREM  AUXILIARY VARIABLE.
*  IO  IER  ERROR INDICATOR.
*  IO  ITERM  TERMINATION INDICATOR.
*
* COMMON DATA :
*  IU  NREM  NUMBER OF CONSTRAINT DELETIONS.
*
* SUBPROGRAMS USED :
*  S   PLRMB0  CONSTRAINT DELETION.
*  S   MXVSET  INITIATION OF A VECTOR.
*
      SUBROUTINE PYRMB1(NF,N,IX,IC,ICA,CG,CR,CZ,G,GN,H,EPS8,UMAX,GMAX,
     +                  KBF,KBC,IOLD,KOLD,KREM,IER,ITERM)
C     .. Scalar Arguments ..
      DOUBLE PRECISION EPS8,GMAX,UMAX
      INTEGER IER,IOLD,ITERM,KBC,KBF,KOLD,KREM,N,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CG(*),CR(*),CZ(*),G(*),GN(*),H(*)
      INTEGER IC(*),ICA(*),IX(*)
C     ..
C     .. Scalars in Common ..
      INTEGER NADD,NDECF,NFG,NFH,NFV,NIT,NRED,NREM,NRES
C     ..
C     .. Local Scalars ..
      INTEGER I,J,K,KC,L
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVSET,PLRMB0
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MIN
C     ..
C     .. Common blocks ..
      COMMON /STAT/NDECF,NRES,NRED,NREM,NADD,NIT,NFV,NFG,NFH
C     ..
      IF (KBC.GT.0) THEN
          IF (UMAX.GT.EPS8*GMAX) THEN
              CALL PLRMB0(NF,N,ICA,CG,CR,CZ,G,GN,IOLD,KREM,NREM,IER)
              IF (IER.LT.0) THEN
                  ITERM = -16

              ELSE IF (IER.GT.0) THEN
                  IOLD = 0

              ELSE
                  K = N* (N-1)/2
                  CALL MXVSET(N,0.0D0,H(K+1))
                  H(K+N) = 1.0D0
                  KC = ICA(NF-N+1)
                  IF (KC.GT.0) THEN
                      IC(KC) = -IC(KC)

                  ELSE
                      K = -KC
                      IX(K) = -IX(K)
                  END IF

              END IF

          ELSE
              IOLD = 0
          END IF

      ELSE IF (KBF.GT.0) THEN
          IF (UMAX.GT.EPS8*GMAX) THEN
              IX(IOLD) = MIN(ABS(IX(IOLD)),3)
              DO 10 I = N,KOLD,-1
                  GN(I+1) = GN(I)
   10         CONTINUE
              GN(KOLD) = G(IOLD)
              N = N + 1
              K = N* (N-1)/2
              L = K + N
              DO 30 I = N,KOLD,-1
                  DO 20 J = I,1,-1
                      IF (I.NE.KOLD .AND. J.NE.KOLD) THEN
                          H(L) = H(K)
                          K = K - 1
                          L = L - 1

                      ELSE IF (I.EQ.KOLD .AND. J.EQ.KOLD) THEN
                          H(L) = 1.0D0
                          L = L - 1

                      ELSE
                          H(L) = 0.0D0
                          L = L - 1
                      END IF

   20             CONTINUE
   30         CONTINUE

          ELSE
              IOLD = 0
              KOLD = 0
          END IF

      END IF

      RETURN

      END
* SUBROUTINE PYTRBD             ALL SYSTEMS                   98/12/01
* PORTABILITY : ALL SYSTEMS
* 98/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* VECTORS OF VARIABLES DIFFERENCE AND GRADIENTS DIFFERENCE ARE COMPUTED
* AND TRANSFORMED. TEST VALUE DMAX IS DETERMINED.
*
* PARAMETERS :
*  II  NF DECLARED NUMBER OF VARIABLES.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  RU  XO(NF)  VECTORS OF VARIABLES DIFFERENCE.
*  RI  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  RU  GO(NF)  GRADIENTS DIFFERENCE.
*  RI  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM CURRENT
*         REDUCED SUBSPACE.
*  RU  SN(NF)  TRANSFORMED DIRECTION VECTOR.
*  RI  R  VALUE OF THE STEPSIZE PARAMETER.
*  RU  F  NEW VALUE OF THE OBJECTIVE FUNCTION.
*  RI  FO  OLD VALUE OF THE OBJECTIVE FUNCTION.
*  RU  P  NEW VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RU  PO  OLD VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RO  DMAX  MAXIMUM RELATIVE DIFFERENCE OF VARIABLES.
*  II  ITERS  TERMINATION INDICATOR FOR STEPLENGTH DETERMINATION.
*         ITERS=0 FOR ZERO STEP.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*
* SUBPROGRAMS USED :
*  S   MXDRMM  PREMULTIPLICATION OF A VECTOR BY TRANSPOSE OF A DENSE
*         RECTANGULAR MATRIX.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVDIF  DIFFERENCE OF TWO VECTORS.
*  S   MXVMUL  DIAGONAL PREMULTIPLICATION OF A VECTOR.
*  S   MXVSAV  DIFFERENCE OF TWO VECTORS WITH COPYING AND SAVING THE
*         SUBSTRACTED ONE.
*  S   MXVSCL  SCALING OF A VECTOR.
*
      SUBROUTINE PYTRBD(NF,N,X,IX,XO,G,GO,CZ,SN,R,F,FO,P,PO,DMAX,ITERS,
     +                  KBF,KBC)
C     .. Scalar Arguments ..
      DOUBLE PRECISION DMAX,F,FO,P,PO,R
      INTEGER ITERS,KBC,KBF,N,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CZ(*),G(*),GO(*),SN(*),X(*),XO(*)
      INTEGER IX(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,K
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDRMM,MXVCOP,MXVDIF,MXVSAV,MXVSCL
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX
C     ..
      IF (ITERS.GT.0) THEN
          CALL MXVDIF(NF,X,XO,XO)
          CALL MXVDIF(NF,G,GO,GO)
          PO = R*PO
          P = R*P

      ELSE
          F = FO
          P = PO
          CALL MXVSAV(NF,X,XO)
          CALL MXVSAV(NF,G,GO)
      END IF

      DMAX = 0.0D0
      IF (KBC.GT.0) THEN
          DO 10 I = 1,NF
              DMAX = MAX(DMAX,ABS(XO(I))/MAX(ABS(X(I)),1.0D0))
   10     CONTINUE
          IF (N.GT.0) THEN
              CALL MXVSCL(N,R,SN,XO)
              CALL MXVCOP(NF,GO,SN)
              CALL MXDRMM(NF,N,CZ,SN,GO)
          END IF

      ELSE IF (KBF.GT.0) THEN
          K = 0
          DO 20 I = 1,NF
              IF (IX(I).LT.0) GO TO 20
              K = K + 1
              DMAX = MAX(DMAX,ABS(XO(I))/MAX(ABS(X(I)),1.0D0))
              XO(K) = XO(I)
              GO(K) = GO(I)
   20     CONTINUE

      ELSE
          DO 30 I = 1,NF
              DMAX = MAX(DMAX,ABS(XO(I))/MAX(ABS(X(I)),1.0D0))
   30     CONTINUE
      END IF

      RETURN

      END
* SUBROUTINE PYTRBG               ALL SYSTEMS                98/12/01
* PORTABILITY : ALL SYSTEMS
* 98/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* GRADIENT OF THE OBJECTIVE FUNCTION IS SCALED AND REDUCED.
* TEST VALUES GMAX AND UMAX ARE COMPUTED.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  NC  NUMBER OF CONSTRAINTS.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  II  ICA(NF)  VECTOR CONTAINING INDICES OF ACTIVE CONSTRAINTS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RI  CR(NF*(NF+1)/2)  TRIANGULAR DECOMPOSITION OF KERNEL OF THE
*         ORTHOGONAL PROJECTION.
*  RU  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM THE
*         CURRENT REDUCED SUBSPACE.
*  RI  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  RO  GN(NF)  TRANSFORMED GRADIENT OF THE OBJECTIVE FUNCTION.
*  RI  EPS7  TOLERANCE FOR LINEAR INDEPENDENCE OF CONSTRAINTS.
*  RO  UMAX  MAXIMUM ABSOLUTE VALUE OF THE NEGATIVE LAGRANGE MULTIPLIER.
*  RO  GMAX  NORM OF THE TRANSFORMED GRADIENT.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*  II  IOLD  INDEX OF THE REMOVED CONSTRAINT.
*  IA  KOLD  AUXILIARY VARIABLE.
*
* SUBPROGRAMS USED :
*  S   MXDRMM  PREMULTIPLICATION OF A VECTOR BY A ROWWISE STORED DENSE
*         RECTANGULAR MATRIX.
*  S   MXDPRB  BACK SUBSTITUTION.
*  S   MXVCOP  COPYING OF A VECTOR.
*  RF  MXVDOT  DOT PRODUCT OF TWO VECTORS.
*  RF  MXVMAX  L-INFINITY NORM OF A VECTOR.
*  S   MXVMUL  DIAGONAL PREMULTIPLICATION OF A VECTOR.
*
      SUBROUTINE PYTRBG(NF,N,NC,IX,IC,ICA,CG,CR,CZ,G,GN,UMAX,GMAX,KBF,
     +                  KBC,IOLD,KOLD)
C     .. Scalar Arguments ..
      DOUBLE PRECISION GMAX,UMAX
      INTEGER IOLD,KBC,KBF,KOLD,N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CG(*),CR(*),CZ(*),G(*),GN(*)
      INTEGER IC(NC),ICA(NF),IX(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I,J,K,KC,NCA,NCZ
C     ..
C     .. External Functions ..
      DOUBLE PRECISION MXVDOT,MXVMAX
      EXTERNAL MXVDOT,MXVMAX
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDPRB,MXDRMM,MXVCOP
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX
C     ..
      IOLD = 0
      KOLD = 0
      UMAX = 0.0D0
      GMAX = 0.0D0
      IF (KBC.GT.0) THEN
          IF (NF.GT.N) THEN
              NCA = NF - N
              NCZ = N*NF
              CALL MXVCOP(NF,G,GN)
              DO 10 J = 1,NCA
                  K = ICA(J)
                  IF (K.GT.0) THEN
                      CZ(NCZ+J) = MXVDOT(NF,CG((K-1)*NF+1),GN)

                  ELSE
                      I = -K
                      CZ(NCZ+J) = GN(I)
                  END IF

   10         CONTINUE
              CALL MXDPRB(NCA,CR,CZ(NCZ+1),0)
              DO 20 J = 1,NCA
                  TEMP = CZ(NCZ+J)
                  KC = ICA(J)
                  IF (KC.GT.0) THEN
                      K = IC(KC)

                  ELSE
                      I = -KC
                      K = IX(I)
                  END IF

                  IF (K.LE.-5) THEN

                  ELSE IF ((K.EQ.-1.OR.K.EQ.-3) .AND.
     +                     UMAX+TEMP.GE.0.0D0) THEN

                  ELSE IF ((K.EQ.-2.OR.K.EQ.-4) .AND.
     +                     UMAX-TEMP.GE.0.0D0) THEN

                  ELSE
                      IOLD = J
                      UMAX = ABS(TEMP)
                  END IF

   20         CONTINUE
          END IF

          IF (N.GT.0) THEN
              CALL MXDRMM(NF,N,CZ,G,GN)
              GMAX = MXVMAX(N,GN)
          END IF

      ELSE IF (KBF.GT.0) THEN
          J = 0
          IOLD = 0
          KOLD = 0
          DO 30 I = 1,NF
              TEMP = G(I)
              K = IX(I)
              IF (K.GE.0) THEN
                  J = J + 1
                  GN(J) = TEMP
                  GMAX = MAX(GMAX,ABS(TEMP))

              ELSE IF (K.LE.-5) THEN

              ELSE IF ((K.EQ.-1.OR.K.EQ.-3) .AND.
     +                 UMAX+TEMP.GE.0.0D0) THEN

              ELSE IF ((K.EQ.-2.OR.K.EQ.-4) .AND.
     +                 UMAX-TEMP.GE.0.0D0) THEN

              ELSE
                  IOLD = I
                  KOLD = J + 1
                  UMAX = ABS(TEMP)
              END IF

   30     CONTINUE
          N = J

      ELSE
          DO 40 I = 1,NF
              TEMP = G(I)
              GMAX = MAX(GMAX,ABS(TEMP))
   40     CONTINUE
          N = NF
      END IF

      RETURN

      END
* SUBROUTINE PYTRBS               ALL SYSTEMS                98/12/01
* PORTABILITY : ALL SYSTEMS
* 98/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* SCALED AND REDUCED DIRECTION VECTOR IS BACK TRANSFORMED.
* VECTORS X,G AND VALUES F,P ARE SAVED.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  IU  N  ACTUAL NUMBER OF VARIABLES.
*  II  NC  NUMBER OF LINEARIZED CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  II  IX(NF)  VECTOR CONTAINING TYPES OF BOUNDS.
*  RO  XO(NF)  SAVED VECTOR OF VARIABLES.
*  RI  XL(NF)  VECTOR CONTAINING LOWER BOUNDS FOR VARIABLES.
*  RI  XU(NF)  VECTOR CONTAINING UPPER BOUNDS FOR VARIABLES.
*  RI  G(NF)  GRADIENT OF THE OBJECTIVE FUNCTION.
*  RO  GO(NF)  SAVED GRADIENT OF THE OBJECTIVE FUNCTION.
*  RI  CF(NF)  VECTOR CONTAINING VALUES OF THE CONSTRAINT FUNCYIONS.
*  RO  CFD(NF)  VECTOR CONTAINING INCREMENTS OF THE CONSTRAINT
*         FUNCTIONS.
*  II  IC(NC)  VECTOR CONTAINING TYPES OF CONSTRAINTS.
*  RI  CL(NC)  VECTOR CONTAINING LOWER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CU(NC)  VECTOR CONTAINING UPPER BOUNDS FOR CONSTRAINT FUNCTIONS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RI  CZ(NF*NF)  MATRIX WHOSE COLUMNS ARE BASIC VECTORS FROM THE
*         CURRENT REDUCED SUBSPACE.
*  RI  SN(NF)  TRANSFORMED DIRECTION VECTOR.
*  RO  S(NF)  DIRECTION VECTOR.
*  RO  RO  SAVED VALUE OF THE STEPSIZE PARAMETER.
*  RO  FP  PREVIOUS VALUE OF THE OBJECTIVE FUNCTION.
*  RU  FO  SAVED VALUE OF THE OBJECTIVE FUNCTION.
*  RI  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RO  PO  SAVED VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RI  P  VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RU  RMAX  MAXIMUM VALUE OF THE STEPSIZE PARAMETER.
*  II  KBF  SPECIFICATION OF SIMPLE BOUNDS. KBF=0-NO SIMPLE BOUNDS.
*         KBF=1-ONE SIDED SIMPLE BOUNDS. KBF=2=TWO SIDED SIMPLE BOUNDS.
*  II  KBC  SPECIFICATION OF LINEAR CONSTRAINTS. KBC=0-NO LINEAR
*         CONSTRAINTS. KBC=1-ONE SIDED LINEAR CONSTRAINTS. KBC=2=TWO
*         SIDED LINEAR CONSTRAINTS.
*  IO  KREM  INDICATION OF LINEARLY DEPENDENT GRADIENTS.
*  IO  INEW  INDEX OF THE NEW ACTIVE FUNCTION.
*
* SUBPROGRAMS USED :
*  S   PLMAXS  DETERMINATION OF THE MAXIMUM STEPSIZE USING SIMPLE
*         BOUNDS.
*  S   PLMAXL  DETERMINATION OF THE MAXIMUM STEPSIZE USING LINEAR
*         CONSTRAINTS.
*  S   MXDCMM  MATRIX VECTOR PRODUCT.
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVSET  INITIATION OF A VECTOR.
*
      SUBROUTINE PYTRBS(NF,N,NC,X,IX,XO,XL,XU,G,GO,CF,CFD,IC,CL,CU,CG,
     +                  CZ,SN,S,RO,FP,FO,F,PO,P,RMAX,KBF,KBC,KREM,INEW)
C     .. Scalar Arguments ..
      DOUBLE PRECISION F,FO,FP,P,PO,RMAX,RO
      INTEGER INEW,KBC,KBF,KREM,N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION CF(*),CFD(*),CG(*),CL(*),CU(*),CZ(*),G(*),GO(*),
     +                 S(*),SN(*),X(*),XL(*),XO(*),XU(*)
      INTEGER IC(*),IX(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,K
C     ..
C     .. External Subroutines ..
      EXTERNAL MXDCMM,MXVCOP,MXVSET,PLMAXL,PLMAXS
C     ..
      FP = FO
      RO = 0.0D0
      FO = F
      PO = P
      CALL MXVCOP(NF,X,XO)
      CALL MXVCOP(NF,G,GO)
      IF (KBC.GT.0) THEN
          IF (N.GT.0) THEN
              CALL MXDCMM(NF,N,CZ,SN,S)
              INEW = 0
              CALL PLMAXL(NF,NC,CF,CFD,IC,CL,CU,CG,S,RMAX,KBC,KREM,INEW)
              CALL PLMAXS(NF,X,IX,XL,XU,S,RMAX,KBF,KREM,INEW)

          ELSE
              CALL MXVSET(NF,0.0D0,S)
          END IF

      ELSE IF (KBF.GT.0) THEN
          K = N + 1
          DO 10 I = NF,1,-1
              IF (IX(I).LT.0) THEN
                  S(I) = 0.0D0

              ELSE
                  K = K - 1
                  S(I) = SN(K)
              END IF

   10     CONTINUE
          INEW = 0
          CALL PLMAXS(NF,X,IX,XL,XU,S,RMAX,KBF,KREM,INEW)
      END IF

      RETURN

      END
* SUBROUTINE PYTRFD             ALL SYSTEMS                   90/12/01
* PORTABILITY : ALL SYSTEMS
* 90/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* PREPARATION OF VARIABLE METRIC UPDATE.
*
* PARAMETERS :
*  II  NF  DECLARED NUMBER OF VARIABLES.
*  II  NC  NUMBER OF CONSTRAINTS.
*  RI  X(NF)  VECTOR OF VARIABLES.
*  RU  XO(NF)  SAVED VECTOR OF VARIABLES.
*  II  IAA(NF+1)  VECTOR CONTAINING INDICES OF ACTIVE FUNCTIONS.
*  RI  AG(NF*NA)  MATRIX WHOSE COLUMNS ARE GRADIENTS OF THE LINEAR
*          APPROXIMATED FUNCTIONS.
*  RI  AZ(NF+1)  VECTOR OF LAGRANGE MULTIPLIERS.
*  RI  CG(NF*NC)  MATRIX WHOSE COLUMNS ARE NORMALS OF THE LINEAR
*         CONSTRAINTS.
*  RI  G(NF)  GRADIENT OF THE LAGRANGIAN FUNCTION.
*  RU  GO(NF)  SAVED GRADIENT OF THE LAGRANGIAN FUNCTION.
*  II  N  ACTUAL NUMBER OF VARIABLES.
*  II  KD  DEGREE OF REQUIRED DERVATIVES.
*  IU  LD  DEGREE OF PREVIOUSLY COMPUTED DERIVATIVES.
*  RU  R  VALUE OF THE STEPSIZE PARAMETER.
*  RU  F  VALUE OF THE OBJECTIVE FUNCTION.
*  RI  FO  SAVED VALUE OF THE OBJECTIVE FUNCTION.
*  RU  P  VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RU  PO  SAVED VALUE OF THE DIRECTIONAL DERIVATIVE.
*  RO  DMAX  RELATIVE STEPSIZE.
*  IO  ITERS  TERMINATION INDICATOR. ITERS=0-ZERO STEP. ITERS=1-PERFECT
*         LINE SEARCH. ITERS=2 GOLDSTEIN STEPSIZE. ITERS=3-CURRY
*         STEPSIZE. ITERS=4-EXTENDED CURRY STEPSIZE.
*         ITERS=5-ARMIJO STEPSIZE. ITERS=6-FIRST STEPSIZE.
*         ITERS=7-MAXIMUM STEPSIZE. ITERS=8-UNBOUNDED FUNCTION.
*         ITERS=-1-MRED REACHED. ITERS=-2-POSITIVE DIRECTIONAL
*         DERIVATIVE. ITERS=-3-ERROR IN INTERPOLATION.
*
* SUBPROGRAMS USED :
*  S   MXVCOP  COPYING OF A VECTOR.
*  S   MXVDIF  DIFFERENCE OF TWO VECTORS.
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*  S   MXVSET  INITIATION OF A VECTOR.
*  S   MXVSAV  DIFFERENCE OF TWO VECTORS WITH COPYING AND SAVING THE
*         SUBSTRACTED ONE.
*
      SUBROUTINE PYTRFD(NF,NC,X,XO,IAA,AG,AZ,CG,G,GO,N,KD,LD,R,F,FO,P,
     +                  PO,DMAX,ITERS)
C     .. Scalar Arguments ..
      DOUBLE PRECISION DMAX,F,FO,P,PO,R
      INTEGER ITERS,KD,LD,N,NC,NF
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION AG(*),AZ(*),CG(*),G(*),GO(*),X(*),XO(*)
      INTEGER IAA(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,J,L
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVDIF,MXVDIR,MXVSAV,MXVSET
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX
C     ..
      CALL MXVSET(NF,0.0D0,G)
      DO 10 J = 1,NF - N
          L = IAA(J)
          IF (L.GT.NC) THEN
              L = L - NC
              CALL MXVDIR(NF,-AZ(J),AG((L-1)*NF+1),G,G)

          ELSE IF (L.GT.0) THEN
              CALL MXVDIR(NF,-AZ(J),CG((L-1)*NF+1),G,G)

          ELSE
              L = -L
              G(L) = G(L) - AZ(J)
          END IF

   10 CONTINUE
      IF (ITERS.GT.0) THEN
          CALL MXVDIF(NF,X,XO,XO)
          CALL MXVDIF(NF,G,GO,GO)
          PO = R*PO
          P = R*P

      ELSE
          R = 0.0D0
          F = FO
          P = PO
          CALL MXVSAV(NF,X,XO)
          CALL MXVSAV(NF,G,GO)
          LD = KD
      END IF

      DMAX = 0.0D0
      DO 20 I = 1,NF
          DMAX = MAX(DMAX,ABS(XO(I))/MAX(ABS(X(I)),1.0D0))
   20 CONTINUE
      N = NF
      RETURN

      END
* SUBROUTINE MXDCMM               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* MULTIPLICATION OF A COLUMNWISE STORED DENSE RECTANGULAR MATRIX A
* BY A VECTOR X.
*
* PARAMETERS :
*  II  N  NUMBER OF ROWS OF THE MATRIX A.
*  II  M  NUMBER OF COLUMNS OF THE MATRIX A.
*  RI  A(N*M)  RECTANGULAR MATRIX STORED COLUMNWISE IN THE
*         ONE-DIMENSIONAL ARRAY.
*  RI  X(M)  INPUT VECTOR.
*  RO  Y(N)  OUTPUT VECTOR EQUAL TO A*X.
*
* SUBPROGRAMS USED :
*  S   MXVDIR  VECTOR AUGMENTED BY THE SCALED VECTOR.
*  S   MXVSET  INITIATION OF A VECTOR.
*
      SUBROUTINE MXDCMM(N,M,A,X,Y)
C     .. Scalar Arguments ..
      INTEGER M,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*),X(*),Y(*)
C     ..
C     .. Local Scalars ..
      INTEGER J,K
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVDIR,MXVSET
C     ..
      CALL MXVSET(N,0.0D0,Y)
      K = 0
      DO 10 J = 1,M
          CALL MXVDIR(N,X(J),A(K+1),Y,Y)
          K = K + N
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXDPGB                ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* SOLUTION OF A SYSTEM OF LINEAR EQUATIONS WITH A DENSE SYMMETRIC
* POSITIVE DEFINITE MATRIX A+E USING THE FACTORIZATION A+E=L*D*TRANS(L)
* OBTAINED BY THE SUBROUTINE MXDPGF.
*
* PARAMETERS :
*  II  N ORDER OF THE MATRIX A.
*  RI  A(N*(N+1)/2) FACTORIZATION A+E=L*D*TRANS(L) OBTAINED BY THE
*         SUBROUTINE MXDPGF.
*  RU  X(N)  ON INPUT THE RIGHT HAND SIDE OF A SYSTEM OF LINEAR
*         EQUATIONS. ON OUTPUT THE SOLUTION OF A SYSTEM OF LINEAR
*         EQUATIONS.
*  II  JOB  OPTION. IF JOB=0 THEN X:=(A+E)**(-1)*X. IF JOB>0 THEN
*         X:=L**(-1)*X. IF JOB<0 THEN X:=TRANS(L)**(-1)*X.
*
* METHOD :
* BACK SUBSTITUTION
*
      SUBROUTINE MXDPGB(N,A,X,JOB)
C     .. Scalar Arguments ..
      INTEGER JOB,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*),X(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,II,IJ,J
C     ..
      IF (JOB.GE.0) THEN
*
*     PHASE 1 : X:=L**(-1)*X
*
          IJ = 0
          DO 20 I = 1,N
              DO 10 J = 1,I - 1
                  IJ = IJ + 1
                  X(I) = X(I) - A(IJ)*X(J)
   10         CONTINUE
              IJ = IJ + 1
   20     CONTINUE
      END IF

      IF (JOB.EQ.0) THEN
*
*     PHASE 2 : X:=D**(-1)*X
*
          II = 0
          DO 30 I = 1,N
              II = II + I
              X(I) = X(I)/A(II)
   30     CONTINUE
      END IF

      IF (JOB.LE.0) THEN
*
*     PHASE 3 : X:=TRANS(L)**(-1)*X
*
          II = N* (N-1)/2
          DO 50 I = N - 1,1,-1
              IJ = II
              DO 40 J = I + 1,N
                  IJ = IJ + J - 1
                  X(I) = X(I) - A(IJ)*X(J)
   40         CONTINUE
              II = II - I
   50     CONTINUE
      END IF

      RETURN

      END
* SUBROUTINE MXDPGF                ALL SYSTEMS                89/12/01
* PORTABILITY : ALL SYSTEMS
* 89/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* FACTORIZATION A+E=L*D*TRANS(L) OF A DENSE SYMMETRIC POSITIVE DEFINITE
* MATRIX A+E WHERE D AND E ARE DIAGONAL POSITIVE DEFINITE MATRICES AND
* L IS A LOWER TRIANGULAR MATRIX. IF A IS SUFFICIENTLY POSITIVE
* DEFINITE THEN E=0.
*
* PARAMETERS :
*  II  N ORDER OF THE MATRIX A.
*  RU  A(N*(N+1)/2)  ON INPUT A GIVEN DENSE SYMMETRIC (USUALLY POSITIVE
*         DEFINITE) MATRIX A STORED IN THE PACKED FORM. ON OUTPUT THE
*         COMPUTED FACTORIZATION A+E=L*D*TRANS(L).
*  IO  INF  AN INFORMATION OBTAINED IN THE FACTORIZATION PROCESS. IF
*         INF=0 THEN A IS SUFFICIENTLY POSITIVE DEFINITE AND E=0. IF
*         INF<0 THEN A IS NOT SUFFICIENTLY POSITIVE DEFINITE AND E>0. IF
*         INF>0 THEN A IS INDEFINITE AND INF IS AN INDEX OF THE
*         MOST NEGATIVE DIAGONAL ELEMENT USED IN THE FACTORIZATION
*         PROCESS.
*  RU  ALF  ON INPUT A DESIRED TOLERANCE FOR POSITIVE DEFINITENESS. ON
*         OUTPUT THE MOST NEGATIVE DIAGONAL ELEMENT USED IN THE
*         FACTORIZATION PROCESS (IF INF>0).
*  RO  TAU  MAXIMUM DIAGONAL ELEMENT OF THE MATRIX E.
*
* METHOD :
* P.E.GILL, W.MURRAY : NEWTON TYPE METHODS FOR UNCONSTRAINED AND
* LINEARLY CONSTRAINED OPTIMIZATION, MATH. PROGRAMMING 28 (1974)
* PP. 311-350.
*
      SUBROUTINE MXDPGF(N,A,INF,ALF,TAU)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ALF,TAU
      INTEGER INF,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION BET,DEL,GAM,RHO,SIG,TOL
      INTEGER I,IJ,IK,J,K,KJ,KK,L
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX
C     ..
      L = 0
      INF = 0
      TOL = ALF
*
*     ESTIMATION OF THE MATRIX NORM
*
      ALF = 0.0D0
      BET = 0.0D0
      GAM = 0.0D0
      TAU = 0.0D0
      KK = 0
      DO 20 K = 1,N
          KK = KK + K
          BET = MAX(BET,ABS(A(KK)))
          KJ = KK
          DO 10 J = K + 1,N
              KJ = KJ + J - 1
              GAM = MAX(GAM,ABS(A(KJ)))
   10     CONTINUE
   20 CONTINUE
      BET = MAX(TOL,BET,GAM/N)
*      DEL = TOL*BET
      DEL = TOL*MAX(BET,1.0D0)
      KK = 0
      DO 60 K = 1,N
          KK = KK + K
*
*     DETERMINATION OF A DIAGONAL CORRECTION
*
          SIG = A(KK)
          IF (ALF.GT.SIG) THEN
              ALF = SIG
              L = K
          END IF

          GAM = 0.0D0
          KJ = KK
          DO 30 J = K + 1,N
              KJ = KJ + J - 1
              GAM = MAX(GAM,ABS(A(KJ)))
   30     CONTINUE
          GAM = GAM*GAM
          RHO = MAX(ABS(SIG),GAM/BET,DEL)
          IF (TAU.LT.RHO-SIG) THEN
              TAU = RHO - SIG
              INF = -1
          END IF
*
*     GAUSSIAN ELIMINATION
*
          A(KK) = RHO
          KJ = KK
          DO 50 J = K + 1,N
              KJ = KJ + J - 1
              GAM = A(KJ)
              A(KJ) = GAM/RHO
              IK = KK
              IJ = KJ
              DO 40 I = K + 1,J
                  IK = IK + I - 1
                  IJ = IJ + 1
                  A(IJ) = A(IJ) - A(IK)*GAM
   40         CONTINUE
   50     CONTINUE
   60 CONTINUE
      IF (L.GT.0 .AND. ABS(ALF).GT.DEL) INF = L
      RETURN

      END
* SUBROUTINE MXDPGI                ALL SYSTEMS                89/12/01
* PORTABILITY : ALL SYSTEMS
* 89/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
*  INVERSION OF A DENSE SYMMETRIC MATRIX A+E USING THE DECOMPOSITION
*  A+E=L*D*TRANS(D) OBTAINED BY THE SUBROUTINE MXDPGF.
*
* PARAMETERS :
*  II  N  ORDER OF THE MATRIX A
*  RU  A(N*(N+1)/2)  ON INPUT THE DECOMPOSITION A+E=L*D*TRANS(L)
*                    OBTAINED BY THE SUBROUTINE MXDPGF.
*                    ON OUTPUT THE INVERSION (A+E)**(-1).
*
* METHOD :
*  INVERSION OF THE LOWER TRIANGULAR MATRIX L AND BACK MULTIPLICATION
*  (A+E)**(-1) = TRANS(L)**(-1)*D**(-1)*L**(-1).
*
      SUBROUTINE MXDPGI(N,A)
*
*     INVERSION OF THE LOWER TRIANGULAR MATRIX L
*
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION AII,AIJ,AIK
      INTEGER I,II,IJ,IK,J,JJ,K,KJ,KK
C     ..
      II = 0
      DO 30 I = 1,N
          II = II + I
          A(II) = 1.0D0/A(II)
          IJ = II
          DO 20 J = I + 1,N
              IJ = IJ + J - 1
              AIJ = -A(IJ)
              IK = II
              KJ = IJ
              DO 10 K = I + 1,J - 1
                  IK = IK + K - 1
                  KJ = KJ + 1
                  AIJ = AIJ - A(IK)*A(KJ)
   10         CONTINUE
              A(IJ) = AIJ
   20     CONTINUE
   30 CONTINUE
*
*     BACK MULTIPLICATION (A+E)**(-1)= TRANS(L**(-1))*D**(-1)*L**(-1)
*
      II = 0
      DO 70 I = 1,N
          II = II + I
          AII = A(II)
          IK = II
          KK = II
          DO 40 K = I + 1,N
              IK = IK + K - 1
              KK = KK + K
              AIK = A(IK)*A(KK)
              AII = AII + A(IK)*AIK
              A(IK) = AIK
   40     CONTINUE
          A(II) = AII
          IJ = II
          JJ = II
          DO 60 J = I + 1,N
              IJ = IJ + J - 1
              JJ = JJ + J
              AIJ = A(IJ)
              IK = IJ
              KJ = JJ
              DO 50 K = J + 1,N
                  IK = IK + K - 1
                  KJ = KJ + K - 1
                  AIJ = AIJ + A(IK)*A(KJ)
   50         CONTINUE
              A(IJ) = AIJ
   60     CONTINUE
   70 CONTINUE
      RETURN

      END
      DOUBLE PRECISION
* FUNCTION MXDPGP                  ALL SYSTEMS                91/12/01
C PORTABILITY : ALL SYSTEMS
C 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* COMPUTATION OF THE NUMBER UXDPGP=TRANS(X)*D**(-1)*Y WHERE D IS A
* DIAGONAL MATRIX IN THE FACTORIZATION A+E=L*D*TRANS(L) OBTAINED BY THE
* SUBROUTINE UXDPGF.
*
* PARAMETERS :
*  II  N ORDER OF THE MATRIX A.
*  RI  A(N*(N+1)/2) FACTORIZATION A+E=L*D*TRANS(L) OBTAINED BY THE
*         SUBROUTINE UXDPGF.
*  RI  X(N)  INPUT VECTOR.
*  RI  Y(N)  INPUT VECTOR.
*  RR  MXDPGP  COMPUTED NUMBER UXDPGP=TRANS(X)*D**(-1)*Y.
*
     +  FUNCTION MXDPGP(N,A,X,Y)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(N* (N+1)/2),X(N),Y(N)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I,J
C     ..
      J = 0
      TEMP = 0.0D0
      DO 10 I = 1,N
          J = J + I
          TEMP = TEMP + X(I)*Y(I)/A(J)
   10 CONTINUE
      MXDPGP = TEMP
      RETURN

      END
* SUBROUTINE MXDPGS                ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* SCALING OF A DENSE SYMMETRIC POSITIVE DEFINITE MATRIX A+E USING THE
* FACTORIZATION A+E=L*D*TRANS(L) OBTAINED BY THE SUBROUTINE MXDPGF.
*
* PARAMETERS :
*  II  N ORDER OF THE MATRIX A.
*  RU  A(N*(N+1)/2) FACTORIZATION A+E=L*D*TRANS(L) OBTAINED BY THE
*         SUBROUTINE MXDPGF.
*  RI  ALF  SCALING FACTOR.
*
      SUBROUTINE MXDPGS(N,A,ALF)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ALF
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,J
C     ..
      J = 0
      DO 10 I = 1,N
          J = J + I
          A(J) = A(J)*ALF
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXDPGU                ALL SYSTEMS                89/12/01
* PORTABILITY : ALL SYSTEMS
* 89/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* CORRECTION OF A DENSE SYMMETRIC POSITIVE DEFINITE MATRIX A+E IN THE
* FACTORED FORM A+E=L*D*TRANS(L) OBTAINED BY THE SUBROUTINE MXDPGF.
* THE CORRECTION IS DEFINED AS A+E:=A+E+ALF*X*TRANS(X) WHERE ALF IS A
* GIVEN SCALING FACTOR AND X IS A GIVEN VECTOR.
*
* PARAMETERS :
*  II  N ORDER OF THE MATRIX A.
*  RU  A(N*(N+1)/2) FACTORIZATION A+E=L*D*TRANS(L) OBTAINED BY THE
*         SUBROUTINE MXDPGF.
*  RI  ALF  SCALING FACTOR IN THE CORRECTION TERM.
*  RI  X(N)  VECTOR IN THE CORRECTION TERM.
*  RA  Y(N) AUXILIARY VECTOR.
*
* METHOD :
* P.E.GILL, W.MURRAY, M.SAUNDERS: METHODS FOR COMPUTING AND MODIFYING
* THE LDV FACTORS OF A MATRIX, MATH. OF COMP. 29 (1974) PP. 1051-1077.
*
      SUBROUTINE MXDPGU(N,A,ALF,X,Y)
C     .. Parameters ..
      DOUBLE PRECISION ZERO,ONE,FOUR,CON
      PARAMETER (ZERO=0.0D0,ONE=1.0D0,FOUR=4.0D0,CON=1.0D-8)
C     ..
C     .. Scalar Arguments ..
      DOUBLE PRECISION ALF
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*),X(*),Y(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION B,D,P,R,T,TO
      INTEGER I,II,IJ,J
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVSCL
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC SQRT
C     ..
      IF (ALF.GE.ZERO) THEN
*
*     FORWARD CORRECTION IN CASE WHEN THE SCALING FACTOR IS NONNEGATIVE
*
          ALF = SQRT(ALF)
          CALL MXVSCL(N,ALF,X,Y)
          TO = ONE
          II = 0
          DO 30 I = 1,N
              II = II + I
              D = A(II)
              P = Y(I)
              T = TO + P*P/D
              R = TO/T
              A(II) = D/R
              B = P/ (D*T)
              IF (A(II).LE.FOUR*D) THEN
*
*     AN EASY FORMULA FOR LIMITED DIAGONAL ELEMENT
*
                  IJ = II
                  DO 10 J = I + 1,N
                      IJ = IJ + J - 1
                      D = A(IJ)
                      Y(J) = Y(J) - P*D
                      A(IJ) = D + B*Y(J)
   10             CONTINUE

              ELSE
*
*     A MORE COMPLICATE BUT NUMERICALLY STABLE FORMULA FOR UNLIMITED
*     DIAGONAL ELEMENT
*
                  IJ = II
                  DO 20 J = I + 1,N
                      IJ = IJ + J - 1
                      D = A(IJ)
                      A(IJ) = R*D + B*Y(J)
                      Y(J) = Y(J) - P*D
   20             CONTINUE
              END IF

              TO = T
   30     CONTINUE

      ELSE
*
*     BACKWARD CORRECTION IN CASE WHEN THE SCALING FACTOR IS NEGATIVE
*
          ALF = SQRT(-ALF)
          CALL MXVSCL(N,ALF,X,Y)
          TO = ONE
          IJ = 0
          DO 50 I = 1,N
              D = Y(I)
              DO 40 J = 1,I - 1
                  IJ = IJ + 1
                  D = D - A(IJ)*Y(J)
   40         CONTINUE
              Y(I) = D
              IJ = IJ + 1
              TO = TO - D*D/A(IJ)
   50     CONTINUE
          IF (TO.LE.ZERO) TO = CON
          II = N* (N+1)/2
          DO 70 I = N,1,-1
              D = A(II)
              P = Y(I)
              T = TO + P*P/D
              A(II) = D*TO/T
              B = -P/ (D*TO)
              TO = T
              IJ = II
              DO 60 J = I + 1,N
                  IJ = IJ + J - 1
                  D = A(IJ)
                  A(IJ) = D + B*Y(J)
                  Y(J) = Y(J) + P*D
   60         CONTINUE
              II = II - I
   70     CONTINUE
      END IF

      RETURN

      END
* SUBROUTINE MXDPRB                ALL SYSTEMS                89/12/01
* PORTABILITY : ALL SYSTEMS
* 89/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* SOLUTION OF A SYSTEM OF LINEAR EQUATIONS WITH A DENSE SYMMETRIC
* POSITIVE DEFINITE MATRIX A USING THE FACTORIZATION A=TRANS(R)*R.
*
* PARAMETERS :
*  II  N ORDER OF THE MATRIX A.
*  RI  A(N*(N+1)/2) FACTORIZATION A=TRANS(R)*R.
*  RU  X(N)  ON INPUT THE RIGHT HAND SIDE OF A SYSTEM OF LINEAR
*         EQUATIONS. ON OUTPUT THE SOLUTION OF A SYSTEM OF LINEAR
*         EQUATIONS.
*  II  JOB  OPTION. IF JOB=0 THEN X:=A**(-1)*X. IF JOB>0 THEN
*         X:=TRANS(R)**(-1)*X. IF JOB<0 THEN X:=R**(-1)*X.
*
* METHOD :
* BACK SUBSTITUTION
*
      SUBROUTINE MXDPRB(N,A,X,JOB)
C     .. Scalar Arguments ..
      INTEGER JOB,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*),X(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,II,IJ,J
C     ..
      IF (JOB.GE.0) THEN
*
*     PHASE 1 : X:=TRANS(R)**(-1)*X
*
          IJ = 0
          DO 20 I = 1,N
              DO 10 J = 1,I - 1
                  IJ = IJ + 1
                  X(I) = X(I) - A(IJ)*X(J)
   10         CONTINUE
              IJ = IJ + 1
              X(I) = X(I)/A(IJ)
   20     CONTINUE
      END IF

      IF (JOB.LE.0) THEN
*
*     PHASE 2 : X:=R**(-1)*X
*
          II = N* (N+1)/2
          DO 40 I = N,1,-1
              IJ = II
              DO 30 J = I + 1,N
                  IJ = IJ + J - 1
                  X(I) = X(I) - A(IJ)*X(J)
   30         CONTINUE
              X(I) = X(I)/A(II)
              II = II - I
   40     CONTINUE
      END IF

      RETURN

      END
* SUBROUTINE MXDRGR               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* PLANE ROTATION IS APPLIED TO A ROWWISE STORED DENSE RECTANGULAR
* MATRIX A.
*
* PARAMETERS :
*  II  N  NUMBER OF COLUMNS OF THE MATRIX A.
*  II  M  NUMBER OF ROWS OF THE MATRIX A.
*  RU  A(M*N)  RECTANGULAR MATRIX STORED ROWWISE IN THE
*         ONE-DIMENSIONAL ARRAY.
*  II  K  FIRST INDEX OF THE PLANE ROTATION.
*  II  L  SECOND INDEX OF THE PLANE ROTATION.
*  RI  CK  DIAGONAL ELEMENT OF THE ELEMENTARY ORTHOGONAL MATRIX.
*  RI  CL  OFF-DIAGONAL ELEMENT OF THE ELEMENTARY ORTHOGONAL MATRIX.
*  II  IER  TYPE OF THE PLANE ROTATION. IER=0-GENERAL PLANE ROTATION.
*         IER=1-PERMUTATION. IER=2-TRANSFORMATION SUPPRESSED.
*
* SUBPROGRAMS USED :
*  S   MXVROT  PLANE ROTATION APPLIED TO TWO ELEMENTS.
*
      SUBROUTINE MXDRGR(N,A,K,L,CK,CL,IER)
C     .. Scalar Arguments ..
      DOUBLE PRECISION CK,CL
      INTEGER IER,K,L,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,IK,IL
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVROT
C     ..
      IF (IER.NE.0 .AND. IER.NE.1) RETURN
      IK = (K-1)*N
      IL = (L-1)*N
      DO 10 I = 1,N
          IK = IK + 1
          IL = IL + 1
          CALL MXVROT(A(IK),A(IL),CK,CL,IER)
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXDRMM               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* MULTIPLICATION OF A ROWWISE STORED DENSE RECTANGULAR MATRIX A BY
* A VECTOR X.
*
* PARAMETERS :
*  II  N  NUMBER OF COLUMNS OF THE MATRIX A.
*  II  M  NUMBER OF ROWS OF THE MATRIX A.
*  RI  A(M*N)  RECTANGULAR MATRIX STORED ROWWISE IN THE
*         ONE-DIMENSIONAL ARRAY.
*  RI  X(N)  INPUT VECTOR.
*  RO  Y(M)  OUTPUT VECTOR EQUAL TO A*X.
*
      SUBROUTINE MXDRMM(N,M,A,X,Y)
C     .. Scalar Arguments ..
      INTEGER M,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*),X(*),Y(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I,J,K
C     ..
      K = 0
      DO 20 J = 1,M
          TEMP = 0.0D0
          DO 10 I = 1,N
              TEMP = TEMP + A(K+I)*X(I)
   10     CONTINUE
          Y(J) = TEMP
          K = K + N
   20 CONTINUE
      RETURN

      END
* SUBROUTINE MXDRMV               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* K-TH COLUMN OF A ROWWISE STORED DENSE RECTANGULAR MATRIX A IS COPIED
* TO THE VECTOR X.
*
* PARAMETERS :
*  II  N  NUMBER OF COLUMNS OF THE MATRIX A.
*  II  M  NUMBER OF ROWS OF THE MATRIX A.
*  RI  A(M*N)  RECTANGULAR MATRIX STORED ROWWISE IN THE
*         ONE-DIMENSIONAL ARRAY.
*  RO  X(M)  OUTPUT VECTOR SUCH THAT X(J)=A(J,K) FOR ALL J.
*  II  K  INDEX OF THE ROW BEING COPIED TO THE OUTPUT VECTOR.
*
      SUBROUTINE MXDRMV(N,M,A,X,K)
C     .. Scalar Arguments ..
      INTEGER K,M,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*),X(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,J
C     ..
      IF (K.LT.1 .OR. K.GT.N) RETURN
      I = K
      DO 10 J = 1,M
          X(J) = A(I)
          I = I + N
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXDSDA                ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* A DENSE SYMMETRIC MATRIX A IS AUGMENTED BY THE SCALED UNIT MATRIX
* SUCH THAT A:=A+ALF*I (I IS THE UNIT MATRIX OF ORDER N).
*
* PARAMETERS :
*  II  N  ORDER OF THE MATRIX A.
*  RU  A(N*(N+1)/2)  DENSE SYMMETRIC MATRIX STORED IN THE PACKED FORM.
*  RI  ALF  SCALING FACTOR.
*
      SUBROUTINE MXDSDA(N,A,ALF)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ALF
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,J
C     ..
      J = 0
      DO 10 I = 1,N
          J = J + I
          A(J) = A(J) + ALF
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXDSMI                ALL SYSTEMS                88/12/01
* PORTABILITY : ALL SYSTEMS
* 88/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DENSE SYMMETRIC MATRIX A IS SET TO THE UNIT MATRIX WITH THE SAME
* ORDER.
*
* PARAMETERS :
*  II  N  ORDER OF THE MATRIX A.
*  RO  A(N*(N+1)/2)  DENSE SYMMETRIC MATRIX STORED IN THE PACKED FORM
*         WHICH IS SET TO THE UNIT MATRIX (I.E. A:=I).
*
      SUBROUTINE MXDSMI(N,A)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,M
C     ..
      M = N* (N+1)/2
      DO 10 I = 1,M
          A(I) = 0.0D0
   10 CONTINUE
      M = 0
      DO 20 I = 1,N
          M = M + I
          A(M) = 1.0D0
   20 CONTINUE
      RETURN

      END
* SUBROUTINE MXDSMM                ALL SYSTEMS                89/12/01
* PORTABILITY : ALL SYSTEMS
* 89/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* MULTIPLICATION OF A DENSE SYMMETRIC MATRIX A BY A VECTOR X.
*
* PARAMETERS :
*  II  N  ORDER OF THE MATRIX A.
*  RI  A(N*(N+1)/2)  DENSE SYMMETRIC MATRIX STORED IN THE PACKED FORM.
*  RI  X(N)  INPUT VECTOR.
*  RO  Y(N)  OUTPUT VECTOR EQUAL TO  A*X.
*
      SUBROUTINE MXDSMM(N,A,X,Y)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*),X(*),Y(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I,J,K,L
C     ..
      K = 0
      DO 30 I = 1,N
          TEMP = 0.0D0
          L = K
          DO 10 J = 1,I
              L = L + 1
              TEMP = TEMP + A(L)*X(J)
   10     CONTINUE
          DO 20 J = I + 1,N
              L = L + J - 1
              TEMP = TEMP + A(L)*X(J)
   20     CONTINUE
          Y(I) = TEMP
          K = K + I
   30 CONTINUE
      RETURN

      END
* FUNCTION MXDSMQ                  ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* VALUE OF A QUADRATIC FORM WITH A DENSE SYMMETRIC MATRIX A.
*
* PARAMETERS :
*  II  N  ORDER OF THE MATRIX A.
*  RI  A(N*(N+1)/2)  DENSE SYMMETRIC MATRIX STORED IN THE PACKED FORM.
*  RI  X(N)  GIVEN VECTOR.
*  RI  Y(N)  GIVEN VECTOR.
*  RR  MXDSMQ  VALUE OF THE QUADRATIC FORM MXDSMQ=TRANS(X)*A*Y.
*
      DOUBLE PRECISION FUNCTION MXDSMQ(N,A,X,Y)
C     .. Parameters ..
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
C     ..
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*),X(*),Y(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP,TEMP1,TEMP2
      INTEGER I,J,K
C     ..
      TEMP = ZERO
      K = 0
      DO 20 I = 1,N
          TEMP1 = ZERO
          TEMP2 = ZERO
          DO 10 J = 1,I - 1
              K = K + 1
              TEMP1 = TEMP1 + A(K)*X(J)
              TEMP2 = TEMP2 + A(K)*Y(J)
   10     CONTINUE
          K = K + 1
          TEMP = TEMP + X(I)* (TEMP2+A(K)*Y(I)) + Y(I)*TEMP1
   20 CONTINUE
      MXDSMQ = TEMP
      RETURN

      END
* SUBROUTINE MXDSMR               ALL SYSTEMS                92/12/01
* PORTABILITY : ALL SYSTEMS
* 92/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* PLANE ROTATION IS APPLIED TO A DENSE SYMMETRIC MATRIX A. THE CASE
* K=L+1 IS REQUIRED.
*
* PARAMETERS :
*  II  N  ORDER OF THE MATRIX A.
*  RU  A(N*(N+1)/2) DENSE SYMMETRIC MATRIX STORED IN THE PACKED FORM.
*  II  K  FIRST INDEX OF PLANE ROTATION.
*  II  L  SECOND INDEX OF PLANE ROTATION.
*  RO  CK  DIAGONAL ELEMENT OF THE ELEMENTARY ORTHOGONAL MATRIX.
*  RO  CL  OFF-DIAGONAL ELEMENT OF THE ELEMENTARY ORTHOGONAL MATRIX.
*  IO  IER  INFORMATION ON THE TRANSFORMATION. IER<0-K OR L OUT OF
*         RANGE. IER=0-PLANE ROTATION. IER=1-PERMUTATION.
*         IER=2-TRANSFORMATION SUPPRESSED.
*
* SUBPROGRAMS USED :
*  S   MXVROT  PLANE ROTATION IS APPLIED TO TWO NUMBERS.
*
      SUBROUTINE MXDSMR(N,A,K,L,CK,CL,IER)
C     .. Scalar Arguments ..
      DOUBLE PRECISION CK,CL
      INTEGER IER,K,L,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION AKK,AKL,ALL,CKK,CKL,CLL
      INTEGER J,KJ,KK,KL,LJ,LL
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVROT
C     ..
      IF (IER.NE.0 .AND. IER.NE.1) RETURN
      IF (K.NE.L+1) THEN
          IER = -1
          RETURN

      END IF

      LJ = L* (L-1)/2
      DO 10 J = 1,N
          IF (J.LE.L) THEN
              LJ = LJ + 1
              KJ = LJ + L

          ELSE
              LJ = LJ + J - 1
              KJ = LJ + 1
          END IF

          IF (J.NE.K .AND. J.NE.L) THEN
              CALL MXVROT(A(KJ),A(LJ),CK,CL,IER)
          END IF

   10 CONTINUE
      IF (IER.EQ.0) THEN
          CKK = CK**2
          CKL = CK*CL
          CLL = CL**2
          LL = L* (L+1)/2
          KL = LL + L
          KK = LL + K
          AKL = (CKL+CKL)*A(KL)
          AKK = CKK*A(KK) + CLL*A(LL) + AKL
          ALL = CLL*A(KK) + CKK*A(LL) - AKL
          A(KL) = (CLL-CKK)*A(KL) + CKL* (A(KK)-A(LL))
          A(KK) = AKK
          A(LL) = ALL

      ELSE
          LL = L* (L+1)/2
          KK = LL + K
          AKK = A(KK)
          A(KK) = A(LL)
          A(LL) = AKK
      END IF

      RETURN

      END
* SUBROUTINE MXDSMS                ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* SCALING OF A DENSE SYMMETRIC MATRIX.
*
* PARAMETERS :
*  II  N  ORDER OF THE MATRIX A.
*  RU  A(N*(N+1)/2)  DENSE SYMMETRIC MATRIX STORED IN THE PACKED FORM
*         WHICH IS SCALED BY THE VALUE ALF (I.E. A:=ALF*A).
*  RI  ALF  SCALING FACTOR.
*
      SUBROUTINE MXDSMS(N,A,ALF)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ALF
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,M
C     ..
      M = N* (N+1)/2
      DO 10 I = 1,M
          A(I) = A(I)*ALF
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXDSMU                ALL SYSTEMS                89/12/01
* PORTABILITY : ALL SYSTEMS
* 89/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* UPDATE OF A DENSE SYMMETRIC MATRIX A. THIS UPDATE IS DEFINED AS
* A:=A+ALF*X*TRANS(X) WHERE ALF IS A GIVEN SCALING FACTOR AND X IS
* A GIVEN VECTOR.
*
* PARAMETERS :
*  II  N  ORDER OF THE MATRIX A.
*  RU  A(N*(N+1)/2)  DENSE SYMMETRIC MATRIX STORED IN THE PACKED FORM.
*  RI  ALF  SCALING FACTOR IN THE CORRECTION TERM.
*  RI  X(N)  VECTOR IN THE CORRECTION TERM.
*
      SUBROUTINE MXDSMU(N,A,ALF,X)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ALF
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*),X(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I,J,K
C     ..
      K = 0
      DO 20 I = 1,N
          TEMP = ALF*X(I)
          DO 10 J = 1,I
              K = K + 1
              A(K) = A(K) + TEMP*X(J)
   10     CONTINUE
   20 CONTINUE
      RETURN

      END
* SUBROUTINE MXDSMV                ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* K-TH ROW OF A DENSE SYMMETRIC MATRIX A IS COPIED TO THE VECTOR X.
*
* PARAMETERS :
*  II  N  ORDER OF THE MATRIX A.
*  RI  A(N*(N+1)/2)  DENSE SYMMETRIC MATRIX STORED IN THE PACKED FORM.
*  RO  X(N)  OUTPUT VECTOR.
*  II  K  INDEX OF COPIED ROW.
*
      SUBROUTINE MXDSMV(N,A,X,K)
C     .. Scalar Arguments ..
      INTEGER K,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*),X(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,L
C     ..
      L = K* (K-1)/2
      DO 10 I = 1,N
          IF (I.LE.K) THEN
              L = L + 1

          ELSE
              L = L + I - 1
          END IF

          X(I) = A(L)
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXVCOP                ALL SYSTEMS                88/12/01
* PORTABILITY : ALL SYSTEMS
* 88/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* COPYING OF A VECTOR.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  X(N)  INPUT VECTOR.
*  RO  Y(N)  OUTPUT VECTOR WHERE Y:= X.
*
      SUBROUTINE MXVCOP(N,X,Y)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
      DO 10 I = 1,N
          Y(I) = X(I)
   10 CONTINUE
      RETURN

      END
      DOUBLE PRECISION
* FUNCTION MXVDEL                  ALL SYSTEMS                92/12/01
* PORTABILITY : ALL SYSTEMS
* 92/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
*  SQUARED NORM OF A SHIFTED VECTOR.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  A  SCALING FACTOR.
*  RI  X(N)  INPUT VECTOR.
*  RI  Y(N)  INPUT VECTOR.
*  RR  UXVDEL SQUARED NORM OF Y+A*X.
*
     +  FUNCTION MXVDEL(N,A,X,Y)
C     .. Scalar Arguments ..
      DOUBLE PRECISION A
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I
C     ..
      TEMP = 0.0D0
      DO 10 I = 1,N
          TEMP = TEMP + (Y(I)+A*X(I))**2
   10 CONTINUE
      MXVDEL = TEMP
      RETURN

      END
* SUBROUTINE MXVDIF                ALL SYSTEMS                88/12/01
* PORTABILITY : ALL SYSTEMS
* 88/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* VECTOR DIFFERENCE.
*
* PARAMETERS :
*  RI  X(N)  INPUT VECTOR.
*  RI  Y(N)  INPUT VECTOR.
*  RO  Z(N)  OUTPUT VECTOR WHERE Z:= X - Y.
*
      SUBROUTINE MXVDIF(N,X,Y,Z)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*),Z(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
      DO 10 I = 1,N
          Z(I) = X(I) - Y(I)
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXVDIR                ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* VECTOR AUGMENTED BY THE SCALED VECTOR.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  A  SCALING FACTOR.
*  RI  X(N)  INPUT VECTOR.
*  RI  Y(N)  INPUT VECTOR.
*  RO  Z(N)  OUTPUT VECTOR WHERE Z:= Y + A*X.
*
      SUBROUTINE MXVDIR(N,A,X,Y,Z)
C     .. Scalar Arguments ..
      DOUBLE PRECISION A
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*),Z(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
      DO 10 I = 1,N
          Z(I) = Y(I) + A*X(I)
   10 CONTINUE
      RETURN

      END
* FUNCTION MXVDOT                  ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DOT PRODUCT OF TWO VECTORS.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  X(N)  INPUT VECTOR.
*  RI  Y(N)  INPUT VECTOR.
*  RR  MXVDOT  VALUE OF DOT PRODUCT MXVDOT=TRANS(X)*Y.
*
      DOUBLE PRECISION FUNCTION MXVDOT(N,X,Y)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I
C     ..
      TEMP = 0.0D0
      DO 10 I = 1,N
          TEMP = TEMP + X(I)*Y(I)
   10 CONTINUE
      MXVDOT = TEMP
      RETURN

      END
* SUBROUTINE MXVINA             ALL SYSTEMS                   90/12/01
* PORTABILITY : ALL SYSTEMS
* 90/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* ELEMENTS OF THE INTEGER VECTOR ARE REPLACED BY THEIR ABSOLUTE VALUES.
*
* PARAMETERS :
*  II  N DIMENSION OF THE INTEGER VECTOR.
*  IU  IX(N)  INTEGER VECTOR WHICH IS UPDATED SO THAT IX(I):=ABS(IX(I))
*         FOR ALL I.
*
      SUBROUTINE MXVINA(N,IX)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      INTEGER IX(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS
C     ..
      DO 10 I = 1,N
          IX(I) = ABS(IX(I))
          IF (IX(I).GT.10) IX(I) = IX(I) - 10
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXVIND               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* CHANGE OF THE INTEGER VECTOR ELEMENT FOR THE CONSTRAINT ADDITION.
*
* PARAMETERS :
*  IU  IX(N)  INTEGER VECTOR.
*  II  I  INDEX OF THE CHANGED ELEMENT.
*  II JOB  CHANGE SPECIFICATION. IS JOB.EQ.0 THEN IX(I)=10-IX(I).
*
      SUBROUTINE MXVIND(IX,I,JOB)
C     .. Scalar Arguments ..
      INTEGER I,JOB
C     ..
C     .. Array Arguments ..
      INTEGER IX(*)
C     ..
      IF (JOB.EQ.0) IX(I) = 10 - IX(I)
      RETURN

      END
* SUBROUTINE MXVINS             ALL SYSTEMS                   90/12/01
* PORTABILITY : ALL SYSTEMS
* 90/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* INITIATION OF THE INTEGER VECTOR.
*
* PARAMETERS :
*  II  N DIMENSION OF THE INTEGER VECTOR.
*  II  IP  INTEGER PARAMETER.
*  IO  IX(N)  INTEGER VECTOR SUCH THAT IX(I)=IP FOR ALL I.
*
      SUBROUTINE MXVINS(N,IP,IX)
C     .. Scalar Arguments ..
      INTEGER IP,N
C     ..
C     .. Array Arguments ..
      INTEGER IX(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
      DO 10 I = 1,N
          IX(I) = IP
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXVINV               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* CHANGE OF THE INTEGER VECTOR ELEMENT FOR THE CONSTRAINT ADDITION.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  IU  IX(N)  INTEGER VECTOR.
*  II  I  INDEX OF THE CHANGED ELEMENT.
*  II  JOB  CHANGE SPECIFICATION
*
      SUBROUTINE MXVINV(IX,I,JOB)
C     .. Scalar Arguments ..
      INTEGER I,JOB
C     ..
C     .. Array Arguments ..
      INTEGER IX(*)
C     ..
      IF ((IX(I).EQ.3.OR.IX(I).EQ.5) .AND. JOB.LT.0) IX(I) = IX(I) + 1
      IF ((IX(I).EQ.4.OR.IX(I).EQ.6) .AND. JOB.GT.0) IX(I) = IX(I) - 1
      IX(I) = -IX(I)
      RETURN

      END
* SUBROUTINE MXVLIN                ALL SYSTEMS                92/12/01
* PORTABILITY : ALL SYSTEMS
* 92/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* LINEAR COMBINATION OF TWO VECTORS.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  A  SCALING FACTOR.
*  RI  X(N)  INPUT VECTOR.
*  RI  B  SCALING FACTOR.
*  RI  Y(N)  INPUT VECTOR.
*  RO  Z(N)  OUTPUT VECTOR WHERE Z:= A*X + B*Y.
*
      SUBROUTINE MXVLIN(N,A,X,B,Y,Z)
C     .. Scalar Arguments ..
      DOUBLE PRECISION A,B
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*),Z(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
      DO 10 I = 1,N
          Z(I) = A*X(I) + B*Y(I)
   10 CONTINUE
      RETURN

      END
* FUNCTION MXVMAX               ALL SYSTEMS                   91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* L-INFINITY NORM OF A VECTOR.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  X(N)  INPUT VECTOR.
*  RR  MXVMAX  L-INFINITY NORM OF THE VECTOR X.
*
      DOUBLE PRECISION FUNCTION MXVMAX(N,X)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX
C     ..
      MXVMAX = 0.0D0
      DO 10 I = 1,N
          MXVMAX = MAX(MXVMAX,ABS(X(I)))
   10 CONTINUE
      RETURN

      END
      DOUBLE PRECISION
* FUNCTION MXVMX2                ALL SYSTEMS                95/12/01
* PORTABILITY : ALL SYSTEMS
* 95/12/01 SI : ORIGINAL VERSION
*
* PURPOSE :
*  L-INFINITY NORM OF VECTOR DIFFERENCE.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  X(N)  INPUT VECTOR.
*  RI  Y(N)  INPUT VECTOR.
*  RR  UXVMX2  L-INFINITY NORM OF X-Y.
*
     +  FUNCTION MXVMX2(N,X,Y)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX
C     ..
      TEMP = 0.0D0
      DO 10 I = 1,N
          TEMP = MAX(TEMP,ABS(X(I)-Y(I)))
   10 CONTINUE
      MXVMX2 = TEMP

      END
* SUBROUTINE MXVMUL             ALL SYSTEMS                   89/12/01
* PORTABILITY : ALL SYSTEMS
* 89/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* VECTOR IS PREMULTIPLIED BY THE POWER OF A DIAGONAL MATRIX.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  D(N)  DIAGONAL MATRIX STORED AS A VECTOR WITH N ELEMENTS.
*  RI  X(N)  INPUT VECTOR.
*  RO  Y(N)  OUTPUT VECTOR WHERE Y:=(D**K)*X.
*  II  K  INTEGER EXPONENT.
*
      SUBROUTINE MXVMUL(N,D,X,Y,K)
C     .. Scalar Arguments ..
      INTEGER K,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION D(*),X(*),Y(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
C     .. External Subroutines ..
      EXTERNAL MXVCOP
C     ..
      IF (K.EQ.0) THEN
          CALL MXVCOP(N,X,Y)

      ELSE IF (K.EQ.1) THEN
          DO 10 I = 1,N
              Y(I) = X(I)*D(I)
   10     CONTINUE

      ELSE IF (K.EQ.-1) THEN
          DO 20 I = 1,N
              Y(I) = X(I)/D(I)
   20     CONTINUE

      ELSE
          DO 30 I = 1,N
              Y(I) = X(I)*D(I)**K
   30     CONTINUE
      END IF

      RETURN

      END
* SUBROUTINE MXVNEG                ALL SYSTEMS                88/12/01
* PORTABILITY : ALL SYSTEMS
* 88/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* CHANGE THE SIGNS OF VECTOR ELEMENTS.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  X(N)  INPUT VECTOR.
*  RO  Y(N)  OUTPUT VECTOR WHERE Y:= - X.
*
      SUBROUTINE MXVNEG(N,X,Y)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
      DO 10 I = 1,N
          Y(I) = -X(I)
   10 CONTINUE
      RETURN

      END
* FUNCTION MXVNM2                ALL SYSTEMS                90/12/01
* PORTABILITY : ALL SYSTEMS
* 90/12/01 SI : ORIGINAL VERSION
*
* PURPOSE :
*  EUCLIDEAN NORM OF VECTOR DIFFERENCE.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  X(N)  INPUT VECTOR.
*  RI  Y(N)  INPUT VECTOR.
*  RR  MXVNM2  EUCLIDEAN NORM OF X-Y.
*
      DOUBLE PRECISION FUNCTION MXVNM2(N,X,Y)
C     .. Parameters ..
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
C     ..
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC SQRT
C     ..
      TEMP = ZERO
      DO 10 I = 1,N
          TEMP = TEMP + (X(I)-Y(I))**2
   10 CONTINUE
      MXVNM2 = SQRT(TEMP)
      END
      DOUBLE PRECISION
* FUNCTION  MXVNOR               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* EUCLIDEAN NORM OF A VECTOR.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  X(N)  INPUT VECTOR.
*  RR  MXVNOR  EUCLIDEAN NORM OF X.
*
     +  FUNCTION MXVNOR(N,X)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION DEN,POM
      INTEGER I
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,MAX,SQRT
C     ..
      DEN = 0.0D0
      DO 10 I = 1,N
          DEN = MAX(DEN,ABS(X(I)))
   10 CONTINUE
      POM = 0.0D0
      IF (DEN.GT.0.0D0) THEN
          DO 20 I = 1,N
              POM = POM + (X(I)/DEN)**2
   20     CONTINUE
      END IF

      MXVNOR = DEN*SQRT(POM)
      RETURN

      END
* SUBROUTINE MXVORT               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DETERMINATION OF AN ELEMENTARY ORTHOGONAL MATRIX FOR PLANE ROTATION.
*
* PARAMETERS :
*  RU  XK  FIRST VALUE FOR PLANE ROTATION (XK IS TRANSFORMED TO
*         SQRT(XK**2+XL**2))
*  RU  XL  SECOND VALUE FOR PLANE ROTATION (XL IS TRANSFORMED TO
*         ZERO)
*  RO  CK  DIAGONAL ELEMENT OF THE ELEMENTARY ORTHOGONAL MATRIX.
*  RO  CL  OFF-DIAGONAL ELEMENT OF THE ELEMENTARY ORTHOGONAL MATRIX.
*  IO  IER  INFORMATION ON THE TRANSFORMATION. IER=0-GENERAL PLANE
*         ROTATION. IER=1-PERMUTATION. IER=2-TRANSFORMATION SUPPRESSED.
*
      SUBROUTINE MXVORT(XK,XL,CK,CL,IER)
C     .. Scalar Arguments ..
      DOUBLE PRECISION CK,CL,XK,XL
      INTEGER IER
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION DEN,POM
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS,SQRT
C     ..
      IF (XL.EQ.0.0D0) THEN
          IER = 2

      ELSE IF (XK.EQ.0.0D0) THEN
          XK = XL
          XL = 0.0D0
          IER = 1

      ELSE
          IF (ABS(XK).GE.ABS(XL)) THEN
              POM = XL/XK
              DEN = SQRT(1.0D0+POM*POM)
              CK = 1.0D0/DEN
              CL = POM/DEN
              XK = XK*DEN

          ELSE
              POM = XK/XL
              DEN = SQRT(1.0D0+POM*POM)
              CL = 1.0D0/DEN
              CK = POM/DEN
              XK = XL*DEN
          END IF

          XL = 0.0D0
          IER = 0
      END IF

      RETURN

      END
* SUBROUTINE MXVROT               ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* PLANE ROTATION IS APPLIED TO TWO VALUES.
*
* PARAMETERS :
*  RU  XK  FIRST VALUE FOR PLANE ROTATION.
*  RU  XL  SECOND VALUE FOR PLANE ROTATION.
*  RI  CK  DIAGONAL ELEMENT OF THE ELEMENTARY ORTHOGONAL MATRIX.
*  RI  CL  OFF-DIAGONAL ELEMENT OF THE ELEMENTARY ORTHOGONAL MATRIX.
*  II  IER  INFORMATION ON THE TRANSFORMATION. IER=0-GENERAL PLANE
*         ROTATION. IER=1-PERMUTATION. IER=2-TRANSFORMATION SUPPRESSED.
*
      SUBROUTINE MXVROT(XK,XL,CK,CL,IER)
C     .. Scalar Arguments ..
      DOUBLE PRECISION CK,CL,XK,XL
      INTEGER IER
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION YK,YL
C     ..
      IF (IER.EQ.0) THEN
          YK = XK
          YL = XL
          XK = CK*YK + CL*YL
          XL = CL*YK - CK*YL

      ELSE IF (IER.EQ.1) THEN
          YK = XK
          XK = XL
          XL = YK
      END IF

      RETURN

      END
      DOUBLE PRECISION
* SUBROUTINE MXVSAB             ALL SYSTEMS                   91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* L-1 NORM OF A VECTOR.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  X(N)  INPUT VECTOR.
*  RR  MXVSAB  L-1 NORM OF THE VECTOR X.
*
     +  FUNCTION MXVSAB(N,X)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS
C     ..
      MXVSAB = 0.0D0
      DO 10 I = 1,N
          MXVSAB = MXVSAB + ABS(X(I))
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXVSAV                ALL SYSTEMS                91/12/01
* PORTABILITY : ALL SYSTEMS
* 91/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* DIFFERENCE OF TWO VECTORS RETURNED IN THE SUBSTRACTED ONE.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  X(N)  INPUT VECTOR.
*  RU  Y(N)  UPDATE VECTOR WHERE Y:= X - Y.
*
      SUBROUTINE MXVSAV(N,X,Y)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I
C     ..
      DO 10 I = 1,N
          TEMP = Y(I)
          Y(I) = X(I) - Y(I)
          X(I) = TEMP
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXVSCL                ALL SYSTEMS                88/12/01
* PORTABILITY : ALL SYSTEMS
* 88/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* SCALING OF A VECTOR.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  X(N)  INPUT VECTOR.
*  RI  A  SCALING FACTOR.
*  RO  Y(N)  OUTPUT VECTOR WHERE Y:= A*X.
*
      SUBROUTINE MXVSCL(N,A,X,Y)
C     .. Scalar Arguments ..
      DOUBLE PRECISION A
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
      DO 10 I = 1,N
          Y(I) = A*X(I)
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXVSET                ALL SYSTEMS                88/12/01
* PORTABILITY : ALL SYSTEMS
* 88/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* A SCALAR IS SET TO ALL THE ELEMENTS OF A VECTOR.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  A  INITIAL VALUE.
*  RO  X(N)  OUTPUT VECTOR SUCH THAT X(I)=A FOR ALL I.
*
      SUBROUTINE MXVSET(N,A,X)
C     .. Scalar Arguments ..
      DOUBLE PRECISION A
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
      DO 10 I = 1,N
          X(I) = A
   10 CONTINUE
      RETURN

      END
* SUBROUTINE MXVSUM                ALL SYSTEMS                88/12/01
* PORTABILITY : ALL SYSTEMS
* 88/12/01 LU : ORIGINAL VERSION
*
* PURPOSE :
* SUM OF TWO VECTORS.
*
* PARAMETERS :
*  II  N  VECTOR DIMENSION.
*  RI  X(N)  INPUT VECTOR.
*  RI  Y(N)  INPUT VECTOR.
*  RO  Z(N)  OUTPUT VECTOR WHERE Z:= X + Y.
*
      SUBROUTINE MXVSUM(N,X,Y,Z)
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION X(*),Y(*),Z(*)
C     ..
C     .. Local Scalars ..
      INTEGER I
C     ..
      DO 10 I = 1,N
          Z(I) = X(I) + Y(I)
   10 CONTINUE
      RETURN

      END
