<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Lattice Builder Manual: Weighted Figures of Merit</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lattice Builder Manual
   </div>
   <div id="projectbrief">Software Package for Constructing Rank-1 Lattices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d6/d80/libtut_figures.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Weighted Figures of Merit </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="libtut_figures_storage"></a>
Storage</h1>
<p>In Lattice Builder, the algorithms that evaluate figures of merit all store and operate on some data internally, whose representation may vary depending on the type of lattice and of figure of merit under consideration.</p>
<p>First, evaluating a figure of merit for ordinary or for embedded lattices imposes different requirement on internal data. For example, to evaluate a coordinate-uniform figure of merit, the values \(\omega(i/n)\) of the kernel \(\omega\) for \(i=0,\dots,n-1\) are precomputed and stored in a vector for subsequent use. For ordinary lattices, the elements of the vector are stored in a natural order (see Storage&lt;LatType::ORDINARY&gt;), by increasing value of \(i\). For embedded lattices in bas \(b\), the internal representation of the vector is different (see Storage&lt;LatType::EMBEDDED&gt;): it uses a permutation such that, for \(k=0,\dots,m\) where the highest-level lattice has \(n=b^m\), the values necessary to describe the level with \(b^k\) points can be found in the first \(b^k\) elements stored in the permuted vector. This allows for adding the next higher level simply by extending this vector. It also simplifies performing vector operations on all different levels without having to process each level individually.</p>
<p>Second, the type of compression used also affects the internal representation of vectors. In the case of symmetric figures of merit, i.e. figures of merit that are invariant under the transformation \(a_j \mapsto n - a_j\) where \(a_j\) is any component of the generating vector, it is a waste of space and effort to represent every value internally. Considering the same example as above, only half of the values of \(\omega(i/n)\) need to be stored.</p>
<p>Finally, the size parameter of the lattice directly affects the length of the internal data vector.</p>
<p>To account for these three different aspects, the internal representation of vectors in Lattice Builder is specified by a <a class="el" href="../../df/dcc/singletonLatBuilder_1_1Storage.html" title="Storage policy. ">Storage</a> instance. These classes perform time-critical operations (such as permutation) and for that reason are not polymorphic.</p>
<p>Consider the following example from <a class="el" href="../../d9/d8a/tutorial_2Storage_8cc-example.html">tutorial/Storage.cc</a> : </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;LatType LAT, Compress COMP&gt;</div>
<div class="line"><span class="keywordtype">void</span> test(<a class="code" href="../../df/db1/group__typedefs.html#ga31a914c8177bc9d15ebb7d6047c1c44c">Modulus</a> n)</div>
<div class="line">{</div>
<div class="line">   SizeParam&lt;LAT&gt; size(n);</div>
<div class="line">   Storage&lt;LAT, COMP&gt; storage(size);</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;storage name: &quot;</span> &lt;&lt; storage.name() &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;  size parameter: &quot;</span> &lt;&lt; storage.sizeParam() &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;  virtual size:   &quot;</span> &lt;&lt; storage.virtualSize() &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;  actual size:    &quot;</span> &lt;&lt; storage.size() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line">   <a class="code" href="../../df/db1/group__typedefs.html#ga31a914c8177bc9d15ebb7d6047c1c44c">Modulus</a> n = 16;</div>
<div class="line">   test&lt;LatType::ORDINARY, Compress::NONE&gt;(n);</div>
<div class="line">   test&lt;LatType::EMBEDDED, Compress::NONE&gt;(n);</div>
<div class="line">   test&lt;LatType::ORDINARY, Compress::SYMMETRIC&gt;(n);</div>
<div class="line">   test&lt;LatType::EMBEDDED, Compress::SYMMETRIC&gt;(n);</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>StorageType</code> traits class maps a LatType value to a type of storage through template specialization.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/dcc/singletonLatBuilder_1_1Storage.html" title="Storage policy. ">Storage</a></dd></dl>
<h1><a class="anchor" id="libtut_figures_simple"></a>
A Simple Example</h1>
<p>The example from <a class="el" href="../../d8/d01/tutorial_2WeightedFigureOfMerit_8cc-example.html">tutorial/WeightedFigureOfMerit.cc</a> illustrates how to instantiate a weighted figure of merit and perform a search for the best Korobov lattice. First we instantiate the sequence <code>latSeq</code> of lattice definitions roughly as in the example from <a class="el" href="../../db/d69/libtut_latseq.html#libtut_latseq_korobov">Korobov Sequences</a> . Next, we instantiate a weighted spectral figure of merit, using a sum as its accumulator, and product weights: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> weights = unique&lt;LatCommon::ProductWeights&gt;();</div>
<div class="line">   weights-&gt;setDefaultWeight(0.7);</div>
<div class="line"></div>
<div class="line">   <span class="keyword">typedef</span> ProjDepMerit::Spectral&lt;LatCommon::NormaBestLat&gt; ProjDep;</div>
<div class="line">   WeightedFigureOfMerit&lt;ProjDep, Functor::Max&gt; figure(2, std::move(weights));</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;figure of merit: &quot;</span> &lt;&lt; figure &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Then, we instantiate a sequence of projections to which the figure of merit applies with: </p><div class="fragment"><div class="line">   <a class="code" href="../../d7/d57/classLatCommon_1_1CoordinateSets_1_1FromRanges.html">LatCommon::CoordinateSets::FromRanges</a> allProjections(</div>
<div class="line">         1, latSeq.latDimension(),     <span class="comment">// range for dimension</span></div>
<div class="line">         0, latSeq.latDimension() - 1  <span class="comment">// range for coordinate index</span></div>
<div class="line">         );</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;projections: &quot;</span> &lt;&lt; allProjections &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>We also allocate a storage instance for ordinary lattices with appropriate compression: </p><div class="fragment"><div class="line">   test(Storage&lt;LatType::ORDINARY, Compress::SYMMETRIC&gt;(19), dim);</div>
</div><!-- fragment --><p>We define an observer which will keep track of the best candidate lattice: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Observer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   <span class="keyword">typedef</span> <a class="code" href="../../db/d29/classLatBuilder_1_1LatDef.html">LatBuilder::LatDef&lt;LatType::ORDINARY&gt;</a> LatDef;</div>
<div class="line"></div>
<div class="line">   Observer() { reset(); }</div>
<div class="line"></div>
<div class="line">   <span class="comment">// initializes the best observed merit value to infinity</span></div>
<div class="line">   <span class="keywordtype">void</span> reset() { m_bestMerit = std::numeric_limits&lt;Real&gt;::infinity(); }</div>
<div class="line"></div>
<div class="line">   <span class="comment">// returns the best observed lattice</span></div>
<div class="line">   <span class="keyword">const</span> LatDef&amp; bestLat() { <span class="keywordflow">return</span> m_bestLat; }</div>
<div class="line"></div>
<div class="line">   <span class="comment">// returns the best observed merit value</span></div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="../../df/db1/group__typedefs.html#gacaaada8fcc395f28434f8a32a97b03ca">Real</a> bestMerit() { <span class="keywordflow">return</span> m_bestMerit; }</div>
<div class="line"></div>
<div class="line">   <span class="comment">// notifies the observer that the merit value of a new candidate lattice has</span></div>
<div class="line">   <span class="comment">// been observed; updates the best observed candidate lattice if necessary</span></div>
<div class="line">   <span class="keywordtype">void</span> observe(<span class="keyword">const</span> LatDef&amp; lat, <a class="code" href="../../df/db1/group__typedefs.html#gacaaada8fcc395f28434f8a32a97b03ca">Real</a> merit)</div>
<div class="line">   {</div>
<div class="line">      std::cout &lt;&lt; lat &lt;&lt; <span class="stringliteral">&quot;\t:\t&quot;</span> &lt;&lt; merit;</div>
<div class="line">      <span class="keywordflow">if</span> (merit &lt; m_bestMerit) {</div>
<div class="line">         std::cout &lt;&lt; <span class="stringliteral">&quot; &lt;-- best&quot;</span>;</div>
<div class="line">         m_bestMerit = merit;</div>
<div class="line">         m_bestLat = lat;</div>
<div class="line">      }</div>
<div class="line">      std::cout &lt;&lt; std::endl;</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">   LatDef m_bestLat;</div>
<div class="line">   <a class="code" href="../../df/db1/group__typedefs.html#gacaaada8fcc395f28434f8a32a97b03ca">Real</a> m_bestMerit;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Finally, we can iterate through all lattices and display the best observed candidate lattice: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> <a class="code" href="../../d6/db5/namespaceLatBuilder_1_1Task.html#acfb86d3a616e5b88b750b9fd99621426">eval</a> = figure.evaluator(storage);</div>
<div class="line">   Observer obs;</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lat : latSeq) {</div>
<div class="line">      <span class="comment">// compute merit value of lattice for all projections</span></div>
<div class="line">      <span class="keyword">auto</span> merit = <a class="code" href="../../d6/db5/namespaceLatBuilder_1_1Task.html#acfb86d3a616e5b88b750b9fd99621426">eval</a>(lat, allProjections, initialMerit);</div>
<div class="line">      <span class="comment">// notify the observer</span></div>
<div class="line">      obs.observe(lat, merit);</div>
<div class="line">   }</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;BEST LATTICE: &quot;</span> &lt;&lt; obs.bestLat() &lt;&lt; <span class="stringliteral">&quot; with merit value &quot;</span> &lt;&lt; obs.bestMerit() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The purpose of the <code>initialMerit</code> object is to store the value of the figure of merit for projections other than that for which it is currently being evaluated (all projections, here). Thus, it is possible to split the evaluation of the figure of merit over different sets of coordinates. It is particularly useful in the case of component-by-component construction, where it can be used to store the merit value of the base lattice (before a component is appended to the generating vector). Here, it simply contains the value <code>0.0</code>: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> initialMerit = storage.createMeritValue(0.0);</div>
</div><!-- fragment --><p>The output of this example is: </p><pre class="fragment">figure of merit: WeightedFigureOfMerit(accumulator=max, projDepMerit=spectral^1 (symmetric), weights=ProductWeights([], default=0.7))
projections: [{1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}]
lattice(19, [1, 1, 1])  :       1.6229 &lt;-- best
lattice(19, [1, 2, 4])  :       1.02641 &lt;-- best
lattice(19, [1, 3, 9])  :       1.02641
lattice(19, [1, 4, 16]) :       0.725784 &lt;-- best
lattice(19, [1, 5, 6])  :       0.725784
lattice(19, [1, 6, 17]) :       1.02641
lattice(19, [1, 7, 11]) :       0.7 &lt;-- best
lattice(19, [1, 8, 7])  :       0.7
lattice(19, [1, 9, 5])  :       1.02641
BEST LATTICE: lattice(19, [1, 7, 11]) with merit value 0.7
</pre><dl class="section remark"><dt>Remarks</dt><dd>A weighted \(\mathcal P_\alpha\) discrepancy could be obtained by replacing: <div class="fragment"><div class="line">   <span class="keyword">typedef</span> ProjDepMerit::Spectral&lt;LatCommon::NormaBestLat&gt; ProjDep;</div>
<div class="line">   WeightedFigureOfMerit&lt;ProjDep, Functor::Max&gt; figure(2, std::move(weights));</div>
</div><!-- fragment -->with: <div class="fragment"><div class="line"><span class="keyword">typedef</span> ProjDepMerit::CoordUniform&lt;Kernel::PAlpha&gt; ProjDep;</div>
<div class="line">WeightedFigureOfMerit&lt;ProjDep, Functor::Sum&gt; figure(std::move(weights), ProjDep(2));</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html" title="Weighted figure of merit. ">WeightedFigureOfMerit</a> <a class="el" href="../../d7/d49/namespaceLatBuilder_1_1ProjDepMerit.html" title="Projection-dependent figures of merit. ">ProjDepMerit</a></dd></dl>
<h1><a class="anchor" id="libtut_figures_signals"></a>
A Improved Example Using Signals</h1>
<p>The evaluation of the figure of merit by <a class="el" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html" title="Weighted figure of merit. ">WeightedFigureOfMerit</a> is performed by evaluating term-by-term a sum over a set of projections of a lattice. If, during the progress of evaluating the sum, the value partial sum becomes larger than the smallest merit value of other candidate lattices already evaluated, then there is no need to finish evaluating the sum. The same reasoning holds for a maximum instead of a sum too. The example in <a class="el" href="../../d0/d91/tutorial_2WeightedFigureOfMeritSignals_8cc-example.html">tutorial/WeightedFigureOfMeritSignals.cc</a> shows how the evaluation process can be aborted using <em>signals</em>.</p>
<p>After contributing every new term into the sum (or maximum), <a class="el" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html" title="Weighted figure of merit. ">WeightedFigureOfMerit</a> emits the WeightedFigureOfMerit::onProgress() signal, passing the current cumulated value as its argument. This signal can be connected to any function (a signal listener) which takes for argument a constant reference to a MeritValue instance. If the signal listener returns <code>true</code>, <a class="el" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html" title="Weighted figure of merit. ">WeightedFigureOfMerit</a> continues the evaluation of the figure of merit; otherwise, it is aborted and the figure of merit evaluates to infinity. For example, we define: </p><div class="fragment"><div class="line">   <span class="keywordtype">bool</span> onProgress(<a class="code" href="../../df/db1/group__typedefs.html#gacaaada8fcc395f28434f8a32a97b03ca">Real</a> merit)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">   </span>{ <span class="keywordflow">return</span> merit &lt; m_bestMerit; }</div>
</div><!-- fragment --><p>in the <code>Observer</code> class. We also define a listener for WeightedFigureOfMerit::onAbort() which is emitted by <a class="el" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html" title="Weighted figure of merit. ">WeightedFigureOfMerit</a> upon abortion and which passes the rejected candidate lattice as its argument: </p><div class="fragment"><div class="line">   <span class="keywordtype">void</span> onAbort(<span class="keyword">const</span> LatDef&amp; lat)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">   </span>{ std::cout &lt;&lt; <span class="stringliteral">&quot;rejected &quot;</span> &lt;&lt; lat &lt;&lt; std::endl; }</div>
</div><!-- fragment --><p>Then, we connect the listener to the signals with: </p><div class="fragment"><div class="line">   Observer obs;</div>
<div class="line">   <a class="code" href="../../d6/db5/namespaceLatBuilder_1_1Task.html#acfb86d3a616e5b88b750b9fd99621426">eval</a>.onProgress().connect(boost::bind(&amp;Observer::onProgress, &amp;obs, _1));</div>
<div class="line">   <a class="code" href="../../d6/db5/namespaceLatBuilder_1_1Task.html#acfb86d3a616e5b88b750b9fd99621426">eval</a>.onAbort().connect(boost::bind(&amp;Observer::onAbort, &amp;obs, _1));</div>
</div><!-- fragment --><p> With these changes, the output becomes: </p><pre class="fragment">figure of merit: WeightedFigureOfMerit(accumulator=max, projDepMerit=spectral^1 (symmetric), weights=ProductWeights([], default=0.7))
projections: [{1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}]
lattice(19, [1, 1, 1])  :       1.6229 &lt;-- best
lattice(19, [1, 2, 4])  :       1.02641 &lt;-- best
lattice(19, [1, 3, 9])  :       1.02641
lattice(19, [1, 4, 16]) :       0.725784 &lt;-- best
lattice(19, [1, 5, 6])  :       0.725784
rejected lattice(19, [1, 6, 17])
lattice(19, [1, 6, 17]) :       inf
lattice(19, [1, 7, 11]) :       0.7 &lt;-- best
lattice(19, [1, 8, 7])  :       0.7
rejected lattice(19, [1, 9, 5])
lattice(19, [1, 9, 5])  :       inf
BEST LATTICE: lattice(19, [1, 7, 11]) with merit value 0.7
</pre><h1><a class="anchor" id="libtut_figures_cbc_simple"></a>
A Simple Example Using CBC Construction</h1>
<p>We can modify the example from <a class="el" href="../../d6/d80/libtut_figures.html#libtut_figures_simple">A Simple Example</a> to implement CBC construction as illustrated in <a class="el" href="../../db/d69/libtut_latseq.html#libtut_latseq_cbc">Component-by-Component Sequences</a>. The complete example can be found in <a class="el" href="../../d3/dd3/tutorial_2WeightedFigureOfMeritCBC_8cc-example.html">tutorial/WeightedFigureOfMeritCBC.cc</a>. The first step is to declare a base lattice: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> baseLat = <a class="code" href="../../d1/d74/namespaceLatBuilder.html#a721b2683d05102558a677a9fa5af8f4c">createLatDef</a>(storage.sizeParam());</div>
</div><!-- fragment --><p>and to create a loop over its dimension: </p><div class="fragment"><div class="line">   <span class="keywordflow">while</span> (baseLat.dimension() &lt; dimension) {</div>
<div class="line"></div>
<div class="line">      <a class="code" href="../../df/db1/group__typedefs.html#ga785711973e9eee305b719f19dcb18fea">Dimension</a> baseDim = baseLat.dimension();</div>
<div class="line"></div>
<div class="line">      <span class="keyword">auto</span> latSeq = <a class="code" href="../../d0/d64/namespaceLatBuilder_1_1LatSeq.html#ac73febb35f5e61cd02ed62e93ae3ddc7">LatSeq::cbc</a>(</div>
<div class="line">            baseLat,</div>
<div class="line">            Coprime(baseDim == 0 ? 2 : storage.sizeParam().numPoints())</div>
<div class="line">            );</div>
</div><!-- fragment --><p>where we instantiate a new lattice sequence every time the dimension of the base lattice is increased. When the dimension of the base lattice is zero, we need only consider 1 as a candidate value for the first component of the generating vector, whence the condition on <code>baseDim</code> above. Instead of covering all projections, we need only consider the projections that include the new coordinate in the generating vector: </p><div class="fragment"><div class="line">      <span class="comment">// base projections</span></div>
<div class="line">      FromRanges baseProjections{</div>
<div class="line">            0, baseDim,     <span class="comment">// range for dimension</span></div>
<div class="line">            0, baseDim - 1  <span class="comment">// range for coordinate index</span></div>
<div class="line">            };</div>
<div class="line">      <span class="comment">// add current coordinate to the base projections</span></div>
<div class="line">      AddCoordinate&lt;FromRanges&gt; newProjections(</div>
<div class="line">            baseProjections,</div>
<div class="line">            baseDim         <span class="comment">// current coordinate index</span></div>
<div class="line">            );</div>
</div><!-- fragment --><p>The minimization loop is unchanged, except that <code>allProjections</code> is replace with <code>newProjections</code>. Finally, <code>baseLat</code> and <code>initialMerit</code> must be updated based on the best observed candidate lattice: </p><div class="fragment"><div class="line">      baseLat = obs.bestLat();</div>
<div class="line">      initialMerit = obs.bestMerit();</div>
</div><!-- fragment --><p>After these changes, the output becomes: </p><pre class="fragment">figure of merit: WeightedFigureOfMerit(accumulator=max, projDepMerit=spectral^1 (symmetric), weights=ProductWeights([], default=0.7))
CBC search for dimension: 1
  base lattice: lattice(19, [])
  base merit value: 0
  new projections: [{1}]
lattice(19, [1])        :       0.7 &lt;-- best
BEST LATTICE: lattice(19, [1]) with merit value 0.7
CBC search for dimension: 2
  base lattice: lattice(19, [1])
  base merit value: 0.7
  new projections: [{2}, {1,2}]
lattice(19, [1, 1])     :       1.6229 &lt;-- best
lattice(19, [1, 2])     :       1.02641 &lt;-- best
lattice(19, [1, 3])     :       0.725784 &lt;-- best
lattice(19, [1, 4])     :       0.7 &lt;-- best
lattice(19, [1, 5])     :       0.7
lattice(19, [1, 6])     :       0.725784
lattice(19, [1, 7])     :       0.7
lattice(19, [1, 8])     :       0.7
lattice(19, [1, 9])     :       1.02641
BEST LATTICE: lattice(19, [1, 4]) with merit value 0.7
CBC search for dimension: 3
  base lattice: lattice(19, [1, 4])
  base merit value: 0.7
  new projections: [{3}, {1,3}, {2,3}, {1,2,3}]
lattice(19, [1, 4, 1])  :       1.6229 &lt;-- best
lattice(19, [1, 4, 2])  :       1.02641 &lt;-- best
lattice(19, [1, 4, 3])  :       0.725784 &lt;-- best
lattice(19, [1, 4, 4])  :       1.6229
lattice(19, [1, 4, 5])  :       0.725784
lattice(19, [1, 4, 6])  :       0.725784
lattice(19, [1, 4, 7])  :       0.725784
lattice(19, [1, 4, 8])  :       1.02641
lattice(19, [1, 4, 9])  :       1.02641
BEST LATTICE: lattice(19, [1, 4, 3]) with merit value 0.725784
</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Lattice Builder Manual</a></li><li class="navelem"><a class="el" href="../../da/d6f/libtut.html">Low-Level API Tutorial</a></li>
    <li class="footer">Generated on Wed Apr 1 2015 20:47:00 for Lattice Builder Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
