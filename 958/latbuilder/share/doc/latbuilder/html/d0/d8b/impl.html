<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Lattice Builder Manual: Implementation Notes</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lattice Builder Manual
   </div>
   <div id="projectbrief">Software Package for Constructing Rank-1 Lattices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d0/d8b/impl.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Implementation Notes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="impl_func_args"></a>
Function Arguments</h1>
<p>In Lattice Builder, there are three different types of declarations of function arguments: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keyword">const</span> T&amp; x) <span class="comment">// if f only reads x</span></div>
<div class="line"><span class="keywordtype">void</span> f(T&amp; x)       <span class="comment">// if f writes to x</span></div>
<div class="line"><span class="keywordtype">void</span> f(T x)        <span class="comment">// if f needs a copy of x</span></div>
</div><!-- fragment --><p> Although the first prototype allows <code>f</code> to make a copy of <code>x</code> internally, it is best to leave it to the compiler to do it. For example, the following code will cause two instantiations of objects of type <code>T:</code> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keyword">const</span> T&amp; x) { T y = x; y.modify(); }</div>
<div class="line">...</div>
<div class="line">f(T());</div>
</div><!-- fragment --><p> whereas the following allows the compiler to instantiate only one object of type <code>T:</code> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(T y) { y.modify(); }</div>
<div class="line">...</div>
<div class="line">f(T());</div>
</div><!-- fragment --><h1><a class="anchor" id="impl_seq"></a>
Sequence</h1>
<p>In multiple situations, Lattice Builder needs to access arrays of values that can interchangeably be computed on-the-fly or pre-computed. The concept of <em>sequence</em>, in the sense of ordered list rather than infinite mathematical sequence, provides in Lattice Builder a unified interface for both. The elements of a sequence are accessed via immutable iterators (<code>const_iterator</code>) with the standard syntax as used for the standard C++ containers, as in the following example: </p><div class="fragment"><div class="line">MySeq seq; <span class="comment">// must implement begin() and end()</span></div>
<div class="line"><span class="keywordflow">for</span> (MySeq::const_iterator it = seq.begin(); it != seq.end(); ++it)</div>
<div class="line">   std::cout &lt;&lt; *it &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Or, using the new C++11 <code>auto</code> keyword and <code>for</code> syntax: </p><div class="fragment"><div class="line">MySeq seq; <span class="comment">// must implement begin() and end()</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem : seq)</div>
<div class="line">   std::cout &lt;&lt; elem &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Concrete examples are given in the tutorial in sections <a class="el" href="../../d2/d5f/libtut_genseq.html">Sequences of Generator Values</a>, <a class="el" href="../../db/d69/libtut_latseq.html">Sequences of Lattice Definitions</a> and <a class="el" href="../../d3/db0/libtut_meritseq.html">Sequences of Merit Values</a> .</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d60/namespaceLatBuilder_1_1GenSeq.html" title="Sequences of generator values. ">LatBuilder::GenSeq</a> LatBuilder::GenSeqSeq <a class="el" href="../../d0/d64/namespaceLatBuilder_1_1LatSeq.html" title="Sequences of Lattices. ">LatBuilder::LatSeq</a> <a class="el" href="../../da/d9a/namespaceLatBuilder_1_1MeritSeq.html" title="Sequences of merit values. ">LatBuilder::MeritSeq</a></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="../../dc/d23/namespaceLatBuilder_1_1TextStream.html" title="Overloaded stream operators. ">LatBuilder::TextStream</a> namespace provides streaming operators to iterate over sequences with a more compact syntax: <div class="fragment"><div class="line"><span class="keyword">using</span> TextStream::operator&lt;&lt;;</div>
<div class="line">MySeq seq; <span class="comment">// must implement begin() and end()</span></div>
<div class="line">std::cout &lt;&lt; seq &lt;&lt; std::endl;</div>
</div><!-- fragment --> Concrete examples are given in the tutorial in section <a class="el" href="../../d0/de3/libtut_textstream.html">Text Output</a> .</dd></dl>
<h1><a class="anchor" id="impl_bridgeseq"></a>
Bridge Sequence</h1>
<p>The values in a sequence often need to be mapped to other values, possibly of a different type. For that purpose, Lattice Builder introduces the concept of a <em>bridge sequence</em>, which contains the mapped elements in the same order as the sequence it is based on.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db3/classLatBuilder_1_1BridgeSeq.html" title="Bridge CRTP class for sequence based on another type of sequence, with elements computed by the deriv...">LatBuilder::BridgeSeq</a></dd></dl>
<h1><a class="anchor" id="impl_polymorphism"></a>
Static Polymorphism</h1>
<p>Traditional object-oriented programming makes use of dynamic polymorphism, where the exact class of an object is resolved at execution time, dynamically. It follows that polymorphic member function calls cannot be inlined, so it is often not advisable to place such a call in the core of a loop with many iterations, at the risk of cumulating inderections due to both polymorphism and function calls.</p>
<p>Some algorithms implemented by Lattice Builder come in several variants which require either polymorphic function calls inside such loops or a large amount of duplicated code with tiny differences. C++ allows to circumvent that problem through the use of <em>static polymorphism</em>, which enables compile-time resolution of the types together with member function inlining.</p>
<p>In some places, static polymorphism is used regardless that dynamic polymorphism could have been used without any notable performance loss, in order to maintain a consistent design. We prefer making common usage patterns of Lattice Builder's classes easier to recognize, even if that means a little bit more verbose code in places.</p>
<p>The most obvious example is the case of sequence classes. Their member functions <code>begin()</code> and <code>end()</code> return iterators; the type of an iterator is often specific to the type of the sequence it is pointing to.</p>
<p>Another example is the size parameter is represented by a different class depending on whether ordinary or embedded lattices are considered. In both cases, the class implements a <code>numPoints()</code> member function, that returns the number of points in the lattice, and that is accessed frequently in some parts of the code. In a traditional object-oriented approach, the two classes would derive from the same abstract base class, and would have required runtime object-type resolution at the call points of <code>numPoints()</code>. With the static polymorphism approach, the <code>numPoints()</code> function can be efficiently inlined by the compiler, thus avoiding both the overhead due to the function call and to runtime object-type resolution.</p>
<h1><a class="anchor" id="impl_concepts"></a>
Concept</h1>
<p>Concepts in C++ can be thought of as the static-polymorphism counterpart of dynamic-polymorphism interfaces. Like interfaces, concepts can specify requirements on the members of a class; unlike interfaces, the data types of the arguments and of the return value of a member function can differ across classes implementing the same concept. Furthermore, a concept can require type definitions (typedefs or nested classes) inside of a class. A well-known example of concept it that of <code>iterator</code> or of <code>const_iterator</code> from the STL.</p>
<p>Although requirements on the types are not explicited with concepts definitions in Lattice Builder, but the code is built around the idiom of concepts.</p>
<p>By convention in Lattice Builder, classes representing the same concept are regrouped in the same namespace.</p>
<p>The most important concepts are described by means of example in the <a class="el" href="../../da/d6f/libtut.html">Low-Level API Tutorial</a>.</p>
<h1><a class="anchor" id="impl_memory"></a>
Memory Management</h1>
<p>In Lattice Builder, when a non-trivial object is no longer needed in its scope after it is passed as an argument to a constructor or factory function, it is generally std::move()'d to the constructor or function in question. The compiler takes care of using the default move constructor on the object that is passed to the constructor and thus avoids copying the object, which can safely be stored as a class member of the `owner' object. Generator sequences (see the GenSeq namespace) are an example of non-trivial objects that are transferred to other ̀owner' objects using this mechanism. Weights objects, such as instances of <a class="el" href="../../d2/d08/classLatCommon_1_1ProductWeights.html" title="Product weights. ">LatCommon::ProductWeights</a> or of <a class="el" href="../../d6/d2b/classLatCommon_1_1ProjectionDependentWeights.html" title="Projection-dependent weights. ">LatCommon::ProjectionDependentWeights</a>, are other examples of non-trivial objects, but because they are polymorphic, they are stored using a std::unique_ptr, which in turn, is passed using either std::move() or, equivalently, std::unique_ptr::release(). There are a few exceptions to that ownership policy, notably figures of merit like instances of WeightedFigureOfMerit or of CoordUniformFigureOfMerit. Some classes store references to such objects, so the objects themselves are also stored using std::unique_ptr so that references remain valid even after the object ownership has changed.</p>
<h1><a class="anchor" id="impl_cpp11"></a>
Usage of the C++11 Standard</h1>
<p>Lattice Builder makes uses of the following C++11 features:</p><ul>
<li>auto-typed variables</li>
<li>range-based for-loop</li>
<li>std::function and std::bind</li>
<li>rvalue references</li>
<li>move constructors and assignment operators</li>
<li>static assertions</li>
<li>extern templates</li>
<li>null pointer constant</li>
<li>strongly typed enums</li>
<li>initializer lists</li>
<li>non-static data member initializers</li>
<li>template aliases</li>
</ul>
<h1><a class="anchor" id="impl_boost"></a>
Usage of the Boost C++ Libraries</h1>
<p>The Lattice Builder library depends on the following <a href="http://www.boost.org/">Boost libraries</a>: </p><ul>
<li>
<a href="http://www.boost.org/doc/libs/release/libs/math/doc/html/index.html">Math</a> </li>
<li>
<a href="http://www.boost.org/doc/libs/release/libs/numeric/ublas/doc/index.htm">uBLAS</a> </li>
<li>
<a href="http://www.boost.org/doc/libs/release/libs/iterator/doc/index.html">Iterator</a> </li>
<li>
<a href="http://www.boost.org/doc/libs/release/libs/accumulators/">Accumulators</a> </li>
<li>
<a href="http://www.boost.org/doc/libs/release/libs/signals2/">Signals2</a> </li>
<li>
<a href="http://www.boost.org/doc/libs/release/libs/tokenizer/index.html">Tokenizer</a> </li>
<li>
<a href="http://www.boost.org/doc/libs/release/libs/conversion/lexical_cast.htm">Lexical Cast</a> </li>
</ul>
<p>In addition to these, the Lattice Builder command-line tool also depends on the following <a href="http://www.boost.org/">Boost libraries</a>: </p><ul>
<li>
<a href="http://www.boost.org/doc/libs/release/doc/html/program_options.html">Program Options</a> </li>
</ul>
<p>Only the Program Options library requires building and linking; the others are header-only libraries.</p>
<h1><a class="anchor" id="impl_fftw"></a>
Usage of FFTW</h1>
<p>The fast CBC implementation of Lattice Builder, as well as the computation of the \(R_\alpha\) criterion, depends on the <a href="http://www.fftw.org/">FFTW library</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Lattice Builder Manual</a></li>
    <li class="footer">Generated on Wed Apr 1 2015 20:46:59 for Lattice Builder Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
