%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Introduction:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{0}



\title{Nomad 4}
\date{Jun 08, 2022}
\release{}
\author{C.\@{} Tribes and V.\@{} Rochon Montplaisir}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This user guide is specific to NOMAD 4.

\sphinxAtStartPar
NOMAD 3 is still available. It will be replaced by NOMAD 4 in the future.

\sphinxAtStartPar
Get NOMAD 3 and 4 at \sphinxurl{https://www.gerad.ca/nomad/}.
\end{sphinxadmonition}

\sphinxAtStartPar
NOMAD is a blackbox optimization software. A general presentation of NOMAD is given in {\hyperref[\detokenize{Introduction:introduction}]{\sphinxcrossref{\DUrole{std,std-ref}{Introduction}}}}.

\sphinxAtStartPar
\sphinxstylestrong{New users of NOMAD should refer to}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Installation:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{GettingStarted:getting-started}]{\sphinxcrossref{\DUrole{std,std-ref}{Getting started}}}}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Using NOMAD}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Starting from {\hyperref[\detokenize{HowToUseNomad:basic-nomad-usage}]{\sphinxcrossref{\DUrole{std,std-ref}{NOMAD usage}}}}, all users can find ways to tailor problem definition, algorithmic settings and software output.

\item {} 
\sphinxAtStartPar
Refer to {\hyperref[\detokenize{AdvancedFunctionalities:advanced-functionalities}]{\sphinxcrossref{\DUrole{std,std-ref}{Advanced functionalities}}}} and {\hyperref[\detokenize{TricksOfTheTrade:tricks-of-the-trade}]{\sphinxcrossref{\DUrole{std,std-ref}{Tricks of the trade}}}} for specific problem solving.

\end{itemize}

\sphinxAtStartPar
Please cite NOMAD 4 with reference:

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{Reference book}

\sphinxAtStartPar
\sphinxincludegraphics[width=60bp]{{livre_DFO_AuHa2017}.png}
\end{sphinxShadowBox}

\sphinxAtStartPar
A complete introduction to derivative\sphinxhyphen{}free and blackbox optimization can be found in the textbook:


\chapter{Introduction}
\label{\detokenize{Introduction:introduction}}\label{\detokenize{Introduction:id1}}\label{\detokenize{Introduction::doc}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
NOMAD = Nonlinear Optimization by Mesh Adaptive Direct Search
\end{sphinxadmonition}

\sphinxAtStartPar
NOMAD is a software application for simulation\sphinxhyphen{}based optimization. It can efficiently explore a design space in search of better solutions for a large spectrum of optimization problems. NOMAD is at its best when  applied to blackbox functions.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{blackbox}.png}
\caption{Blackbox optimization}\label{\detokenize{Introduction:id7}}\end{figure}

\sphinxAtStartPar
Such functions are typically the result of expensive computer simulations which
\begin{itemize}
\item {} 
\sphinxAtStartPar
have no exploitable property such as derivatives,

\item {} 
\sphinxAtStartPar
may be contaminated by noise,

\item {} 
\sphinxAtStartPar
may fail to give a result even for feasible points.

\end{itemize}

\sphinxAtStartPar
NOMAD  is a \sphinxcode{\sphinxupquote{C++}} implementation of the  \sphinxstylestrong{Mesh Adaptive Direct Search (MADS)} algorithm (see references \sphinxcite{Introduction:abaudele09}, \sphinxcite{Introduction:aude2006}, \sphinxcite{Introduction:aude09a} for details) designed for constrained optimization of blackbox functions in the form
\begin{equation*}
\begin{split}\min_{x \in \Omega} f(x)\end{split}
\end{equation*}
\sphinxAtStartPar
where the feasible set \(\Omega = \{ x \in X : c_j(x) \leq 0, j \in J\} \subset \mathbb{R}^n\), \(f, c_j : X \rightarrow \mathbb{R} \cup \{ \infty \}\) for  all \(j \in J= \{ 1,2,\ldots,m \}\), and where \(X\) is a subset of \(\mathbb{R}^n\).


\section{Basics of the MADS algorithm}
\label{\detokenize{Introduction:basics-of-the-mads-algorithm}}
\sphinxAtStartPar
At the core of NOMAD resides the \sphinxstyleemphasis{Mesh Adaptive Direct Search (MADS)} algorithm.
As the name implies, this method generates iterates on a series of meshes with varying size.
A mesh is a discretization of the space of variables.
However, also as the name implies, the algorithm performs an adaptive search on the meshes including controlling the refinement of the meshes.
The reader interested in the rather technical details should read Reference \sphinxcite{Introduction:aude2006}.

\sphinxAtStartPar
The objective of each iteration of the \sphinxstyleemphasis{MADS} algorithm, is to generate a trial point on the mesh that improves the current best solution.
When an iteration fails to achieve this, the next iteration is initiated on a finer mesh.

\sphinxAtStartPar
Each iteration is composed of two principal steps called the \sphinxstyleemphasis{Search} and the \sphinxstyleemphasis{Poll} steps \sphinxcite{Introduction:aude2006}.
The \sphinxstyleemphasis{Search} step is crucial in practice because it is so flexible and can improve the performance significantly.
The \sphinxstyleemphasis{Search} step is constrained by the theory to return points on the underlying mesh, but of course,
it is trying to identify a point that improves the current best solution.

\sphinxAtStartPar
The \sphinxstyleemphasis{Poll} step is more rigidly defined, though there is still some flexibility in how this is implemented.
The \sphinxstyleemphasis{Poll} step generates trial mesh points in the vicinity of the best current solution.
Since the \sphinxstyleemphasis{Poll} step is the basis of the convergence analysis, it is the part of the algorithm where most research has been concentrated.

\sphinxAtStartPar
A high\sphinxhyphen{}level presentation of \sphinxstyleemphasis{MADS} is shown in the pseudo\sphinxhyphen{}code below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{mads-algo}.png}
\end{figure}


\section{Using NOMAD}
\label{\detokenize{Introduction:using-nomad}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
NOMAD does not provide a graphical user interface to define and perform optimization.
\end{sphinxadmonition}

\sphinxAtStartPar
Minimally, users must accomplish several tasks to solve their own optimization problems:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Create a custom blackbox program(s) to evaluate the functions \(f\) and \(c_j\) OR embed
the functions evaluations in C++ source code to be linked with the NOMAD library.

\item {} 
\sphinxAtStartPar
Create the optimization problem definition in a parameter file OR embed the problem definition in C++ source code to be linked with the NOMAD library.

\item {} 
\sphinxAtStartPar
Launch the execution at the command prompt OR from another executable system call.

\end{itemize}

\sphinxAtStartPar
Users can find several examples provided in the installation package and described in this user guide to perform customization for their problems.
The installation procedure is given in {\hyperref[\detokenize{Installation:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation}}}}. New users should refer to {\hyperref[\detokenize{GettingStarted:getting-started}]{\sphinxcrossref{\DUrole{std,std-ref}{Getting started}}}}.
The most important instructions to use NOMAD are in :ref:’basic\_nomad\_usage’.
In addition, tricks that may help solving specific problems and improve NOMAD efficiency are presented in {\hyperref[\detokenize{TricksOfTheTrade:tricks-of-the-trade}]{\sphinxcrossref{\DUrole{std,std-ref}{Tricks of the trade}}}}.
Advanced parameters and functionalities are presented in {\hyperref[\detokenize{AdvancedFunctionalities:advanced-functionalities}]{\sphinxcrossref{\DUrole{std,std-ref}{Advanced functionalities}}}}.


\section{Supported platforms and environments}
\label{\detokenize{Introduction:supported-platforms-and-environments}}
\sphinxAtStartPar
NOMAD source codes are in C++ and are identical for all supported platforms.
See {\hyperref[\detokenize{Installation:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation}}}} for details to obtain binaries from the source files.


\section{Authors and fundings}
\label{\detokenize{Introduction:authors-and-fundings}}
\sphinxAtStartPar
The development of NOMAD started in 2001. Three versions of NOMAD have been developed before NOMAD 4.
NOMAD 4 and NOMAD 3 are currently supported. NOMAD 4 is almost a completely new code compared with NOMAD 3.

\sphinxAtStartPar
NOMAD 4 has been funded by Huawei Canada, Rio Tinto, Hydro\sphinxhyphen{}Québec, NSERC (Natural Sciences and Engineering Research Council of Canada), InnovÉÉ (Innovation en Énergie Électrique) and IVADO (The Institute for Data Valorization)

\sphinxAtStartPar
NOMAD 3 was created and developed by Charles Audet, Sebastien Le Digabel, Christophe Tribes and Viviane Rochon Montplaisir and was funded by AFOSR and Exxon Mobil.

\sphinxAtStartPar
NOMAD 1 and 2 were created and developed by Mark Abramson, Charles Audet, Gilles Couture, and John E. Dennis Jr., and were funded by AFOSR and Exxon Mobil.

\sphinxAtStartPar
The library for dynamic surrogates (SGTELIB) has been developed by Bastien Talgorn (\sphinxhref{mailto:bastien-talgorn@fastmail.com}{bastien\sphinxhyphen{}talgorn@fastmail.com}), McGill University, Montreal.
The SGTELIB is included in NOMAD since version 3.8.0.

\sphinxAtStartPar
\sphinxstylestrong{Developers} of the methods behind NOMAD include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Mark A. Abramson (\sphinxhref{mailto:abramson@mathematics.byu.edu}{abramson@mathematics.byu.edu}), Bringham Young University.

\item {} 
\sphinxAtStartPar
Charles Audet (\sphinxurl{https://www.gerad.ca/Charles.Audet}), GERAD and Département de mathématiques et de génie industriel, École Polytechnique de Montréal.

\item {} 
\sphinxAtStartPar
J.E. Dennis Jr. (\sphinxurl{http://www.caam.rice.edu/\~dennis}), Computational and Applied Mathematics Department, Rice University.

\item {} 
\sphinxAtStartPar
Sébastien Le Digabel (\sphinxurl{http://www.gerad.ca/Sebastien.Le.Digabel}), GERAD and Département de mathématiques et de génie industriel, École Polytechnique de Montréal.

\item {} 
\sphinxAtStartPar
Viviane Rochon Montplaisir (\sphinxurl{https://www.linkedin.com/in/montplaisir}).

\item {} 
\sphinxAtStartPar
Christophe Tribes, GERAD (\sphinxurl{https://www.gerad.ca/en/people/christophe-tribes}) and Département de mathématiques et de génie industriel, École Polytechnique de Montréal.

\end{itemize}


\section{Acknowledgments}
\label{\detokenize{Introduction:acknowledgments}}
\sphinxAtStartPar
The developers of NOMAD wish to thank Florian Chambon, Mohamed Sylla and Quentin Reynaud, all from ISIMA, for their contribution
to the project during Summer internships, and to Anthony Guillou and Dominique Orban for their help with AMPL, and their suggestions.

\sphinxAtStartPar
A special thank to Maud Bay, Eve Bélisle, Vincent Garnier, Michal Kvasnička, Alexander Lutz, Rosa\sphinxhyphen{}Maria Torres\sphinxhyphen{}Calderon, Yuri Vilmanis, Martin Posch, Etienne Duclos, Emmanuel Bigeon, Walid Zghal, Jerawan Armstrong, Stéphane Alarie and Klaus Truemper for their feedbacks and tests that significantly contributed to improve NOMAD. Some features of NOMAD have been developed under the impulsion of enthusiastic users/developers: Andrea Ianni, Florian Chambon, Mohamed Sylla, Quentin Reynaud, Amina Ihaddadene, Bastien Talgorn, Nadir Amaioua and Catherine Poissant.
We also wish to thank Pascal Côté for his contribution in the development of the Python interface pyNomad and Jonathan Currie for the development of the foundations for a strong NOMAD interface for MATLAB.
Another special thank to Jean\sphinxhyphen{}Max Redonnet for pushing the development of the Java Swig interface.

\sphinxAtStartPar
The contributions of  Miguel Anjos, Romain Couderc, Miguel Diago Martinez, Solène Kojtych, Guillaume Lameynardie, Wim Lavrijsen, Alexis Montoison, Caroline Rocha, Ludovic Salomon, Renaud Saltet and Yassine Diouri was highly appreciated during the development and testing of NOMAD 4.


\chapter{License}
\label{\detokenize{Introduction:license}}
\sphinxAtStartPar
NOMAD is a free software application released under the GNU Lesser General Public License v 3.0.
As a free software application you can redistribute and/or modify NOMAD source codes under the terms of the GNU Lesser General Public License.

\sphinxAtStartPar
For more information, please refer to the local copy of the license obtained during installation.
For additional information you can contact us or visit the Free Software Foundation website.


\chapter{Contact us}
\label{\detokenize{Introduction:contact-us}}
\sphinxAtStartPar
All queries can be submitted by email at

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxhref{mailto:nomad@gerad.ca}{nomad@gerad.ca}.
\end{sphinxadmonition}

\sphinxAtStartPar
In particular, feel free to ask technical support for problem specification
(creating parameter files or integration with various types of simulations) and system support (installation and plateform\sphinxhyphen{}dependent problems).

\sphinxAtStartPar
Bug reports and suggestions are valuable to us! We are committed to answer to posted requests as quickly as possible.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{References}
\end{sphinxShadowBox}


\chapter{Installation}
\label{\detokenize{Installation:installation}}\label{\detokenize{Installation:id1}}\label{\detokenize{Installation::doc}}
\sphinxAtStartPar
On Linux, Windows and Mac OS X, NOMAD can be compiled using \sphinxstyleemphasis{CMake}, a tool to manage building of source code.

\sphinxAtStartPar
The minimum version of \sphinxstyleemphasis{CMake} is 3.14. Older versions should trigger an error. \sphinxstyleemphasis{CMake} will detect which compiler is available.

\sphinxAtStartPar
A recent C++ compiler supporting C++14 is also required. The compilation has been tested on Linux with gcc 9.3.0, 10.1.0 and 11.1.0. The compilation has been tested on OSX with gcc Homebrew 9.3.0 and 11.2.0, and also Apple clang version 11.0.3 and 13.0.0. The compilation has been tested on Windows 8 and Windows 10 Enterprise with Microsoft Visual Studio 2019 (cl.exe 19.29.300038.1) and Microsoft Visual Studio 2017.

\begin{sphinxadmonition}{warning}{Warning:}\begin{description}
\item[{Some older version of \sphinxstyleemphasis{CMake} do not trigger an explicit error on the version number.}] \leavevmode
\sphinxAtStartPar
If the \sphinxcode{\sphinxupquote{cmake}} commands fail, check the version manually on the command line

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{version}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{The minimum acceptable version is 3.14.}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If the version of \sphinxstyleemphasis{CMake} is older than 3.14 or if you do not have \sphinxstyleemphasis{CMake} installed,
we recommend to install \sphinxstyleemphasis{CMake} using a \sphinxstylestrong{package manager}. The other option is to
follow the procedure given at \sphinxhref{https://cmake.org/install/}{cmake.org} to obtain binaries.

\sphinxAtStartPar
For Mac OSX, \sphinxstyleemphasis{CMake} can be installed on the command line using package manager \sphinxhref{https://www.macports.org/}{MacPorts} or \sphinxhref{http://brew.sh/}{Homebrew}.

\sphinxAtStartPar
For Linux, several package managers exist to automate the procedure.

\sphinxAtStartPar
For Windows, an installer tool is available at \sphinxhref{https://cmake.org/download/}{cmake.org/download}. Please note that all commands are performed in the Windows Command Prompt windows of Visual Studio.
\end{sphinxadmonition}

\sphinxAtStartPar
The NOMAD installation procedure has the three following steps: \sphinxstylestrong{configuration, building and installation}.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Before starting the procedure we recommend to set the environment variable \sphinxcode{\sphinxupquote{\$NOMAD\_HOME}} with the path where NOMAD has been copied. For Linux and OSX,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{export} \PYG{n}{NOMAD\PYGZus{}HOME}\PYG{o}{=}\PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{myUserName}\PYG{o}{/}\PYG{n}{PathToNomad}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
For Windows, add an environment variable \sphinxcode{\sphinxupquote{\%NOMAD\_HOME\%}} containing the path.
\begin{quote}

\sphinxAtStartPar
The remaining of the documentation uses the \sphinxcode{\sphinxupquote{\$NOMAD\_HOME}} environment variable.
\end{quote}


\section{1\sphinxhyphen{} Configuration using provided \sphinxstyleliteralintitle{\sphinxupquote{CMakeLists.txt}} files}
\label{\detokenize{Installation:configuration-using-provided-cmakelists-txt-files}}\label{\detokenize{Installation:cmake-configuration}}
\sphinxAtStartPar
On the command line, in the \sphinxcode{\sphinxupquote{\$NOMAD\_HOME}} directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{S} \PYG{o}{.} \PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{n}{build}\PYG{o}{/}\PYG{n}{release}
\end{sphinxVerbatim}

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{Building options}

\sphinxAtStartPar
To enable time stats build:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DTIME\PYGZus{}STATS}\PYG{o}{=}\PYG{n}{ON} \PYG{o}{\PYGZhy{}}\PYG{n}{S} \PYG{o}{.} \PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{n}{build}\PYG{o}{/}\PYG{n}{release}
\end{sphinxVerbatim}

\sphinxAtStartPar
To enable C interface building:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DBUILD\PYGZus{}INTERFACE\PYGZus{}C}\PYG{o}{=}\PYG{n}{ON} \PYG{o}{\PYGZhy{}}\PYG{n}{S} \PYG{o}{.} \PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{n}{build}\PYG{o}{/}\PYG{n}{release}
\end{sphinxVerbatim}

\sphinxAtStartPar
To enable Matlab interface building:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DBUILD\PYGZus{}INTERFACE\PYGZus{}MATLAB}\PYG{o}{=}\PYG{n}{ON} \PYG{o}{\PYGZhy{}}\PYG{n}{S} \PYG{o}{.} \PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{n}{build}\PYG{o}{/}\PYG{n}{release}
\end{sphinxVerbatim}

\sphinxAtStartPar
To enable Python interface (PyNomad) building:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DBUILD\PYGZus{}INTERFACE\PYGZus{}PYTHON}\PYG{o}{=}\PYG{n}{ON} \PYG{o}{\PYGZhy{}}\PYG{n}{S} \PYG{o}{.} \PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{n}{build}\PYG{o}{/}\PYG{n}{release}
\end{sphinxVerbatim}

\sphinxAtStartPar
To disable \sphinxstyleemphasis{OpenMP} compilation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{DTEST\PYGZus{}OPENMP}\PYG{o}{=}\PYG{n}{OFF} \PYG{o}{\PYGZhy{}}\PYG{n}{S} \PYG{o}{.} \PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{n}{build}\PYG{o}{/}\PYG{n}{release}
\end{sphinxVerbatim}
\end{sphinxShadowBox}

\sphinxAtStartPar
This command creates the files and directories for building (\sphinxcode{\sphinxupquote{\sphinxhyphen{}B}}) in \sphinxcode{\sphinxupquote{build/release}}. The source (\sphinxcode{\sphinxupquote{\sphinxhyphen{}S}}) \sphinxcode{\sphinxupquote{CMakeLists.txt}} file is in the \sphinxcode{\sphinxupquote{\$NOMAD\_HOME}} directory.

\sphinxAtStartPar
The command can be modified to enable/disable some options (see side bar).

\sphinxAtStartPar
\sphinxstyleemphasis{OpenMP} is used for parallelization of evaluations. \sphinxstyleemphasis{CMake} will detect if \sphinxstyleemphasis{OpenMP} is available by default. To forcefully deactivate compilation with \sphinxstyleemphasis{OpenMP}, see option in side bar.


\section{2\sphinxhyphen{} Build}
\label{\detokenize{Installation:build}}
\sphinxAtStartPar
Build the libraries and applications (Linux/OSX):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{build} \PYG{n}{build}\PYG{o}{/}\PYG{n}{release}
\end{sphinxVerbatim}

\sphinxAtStartPar
For Windows, the default configuration is Debug. To obtain the Release version:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{build} \PYG{n}{build}\PYG{o}{/}\PYG{n}{release} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{config} \PYG{n}{Release}
\end{sphinxVerbatim}

\sphinxAtStartPar
Option \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}parallel xx}} can be added for faster build

\sphinxAtStartPar
It is possible to build only a single application in its working directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd \PYGZdl{}NOMAD\PYGZus{}HOME/examples/basic/library/example1
cmake \PYGZhy{}\PYGZhy{}build \PYGZdl{}NOMAD\PYGZus{}HOME/build/release \PYGZhy{}\PYGZhy{}target example1\PYGZus{}lib.exe
\end{sphinxVerbatim}


\section{3\sphinxhyphen{} Install}
\label{\detokenize{Installation:install}}
\sphinxAtStartPar
Copy binaries and headers in build/release/{[}bin, include, lib{]} and in the examples/tests directories:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{install} \PYG{n}{build}\PYG{o}{/}\PYG{n}{release}
\end{sphinxVerbatim}

\sphinxAtStartPar
Option \textendash{}config Release should be used on Windows to install Release configuration.

\sphinxAtStartPar
The executable \sphinxcode{\sphinxupquote{nomad}} will installed into the directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}NOMAD\PYGZus{}HOME/build/release/bin/
\end{sphinxVerbatim}

\sphinxAtStartPar
Additionally a symbolic link to \sphinxcode{\sphinxupquote{nomad}} binary is available:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}NOMAD\PYGZus{}HOME/bin
\end{sphinxVerbatim}


\section{Bulding for debug version}
\label{\detokenize{Installation:bulding-for-debug-version}}
\sphinxAtStartPar
The procedure to configure, build and install the \sphinxcode{\sphinxupquote{debug}} version is the following (linux/OSX). On the command line in the \sphinxcode{\sphinxupquote{\$NOMAD\_HOME}} directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{n}{S} \PYG{o}{.} \PYG{o}{\PYGZhy{}}\PYG{n}{B} \PYG{n}{build}\PYG{o}{/}\PYG{n}{debug} \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{n}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}\PYG{o}{=}\PYG{n}{Debug}

\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{build} \PYG{n}{build}\PYG{o}{/}\PYG{n}{debug}

\PYG{n}{cmake} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{install} \PYG{n}{build}\PYG{o}{/}\PYG{n}{debug}
\end{sphinxVerbatim}

\sphinxAtStartPar
On Windows, all 4 configurations are always build Debug, RelWithDebugInfo, MinSizeRel, Release); the flag CMAKE\_BUILD\_TYPE can be ignored.


\section{Use another compiler}
\label{\detokenize{Installation:use-another-compiler}}
\sphinxAtStartPar
The environment variables \sphinxcode{\sphinxupquote{CC}} and \sphinxcode{\sphinxupquote{CXX}} can be used to select the \sphinxcode{\sphinxupquote{C}} and \sphinxcode{\sphinxupquote{C++}} compilers.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Clang}} is the default compiler for Mac OSX using XCode. But, \sphinxstyleemphasis{OpenMP} (used for parallel evaluations)
support is disabled in \sphinxstyleemphasis{Clang} that come with \sphinxstyleemphasis{Xcode}.
Users of Mac OSX can install and use another compiler to enable \sphinxstyleemphasis{OpenMP} support.
For example, \sphinxcode{\sphinxupquote{GCC}} compilers can be obtained using \sphinxhref{https://www.macports.org/}{MacPorts} or \sphinxhref{http://brew.sh/}{Homebrew}.
\end{sphinxadmonition}


\chapter{Testing installation}
\label{\detokenize{Installation:testing-installation}}
\sphinxAtStartPar
Once building \sphinxstylestrong{and installation} have been performed some tests can be performed.

\sphinxAtStartPar
The NOMAD binary can be tested:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}NOMAD\PYGZus{}HOME/bin/nomad \PYGZhy{}v
\end{sphinxVerbatim}

\sphinxAtStartPar
This should return the version number on the command line.

\sphinxAtStartPar
By default the examples are built and can be tested:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{build}\PYG{o}{/}\PYG{n}{release}
\PYG{n}{ctest}
\end{sphinxVerbatim}

\sphinxAtStartPar
For Windows, the configuration must be provided: \sphinxcode{\sphinxupquote{ctest \sphinxhyphen{}C Release}}.

\sphinxAtStartPar
Please note that the tests will take several minutes. Option \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}parallel xx}} can be added for faster execution.
The log of the tests can be found in \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/build/release/Testing/Temporary}}.


\chapter{Getting started}
\label{\detokenize{GettingStarted:getting-started}}\label{\detokenize{GettingStarted:id1}}\label{\detokenize{GettingStarted::doc}}
\sphinxAtStartPar
NOMAD is an efficient tool for simulation\sphinxhyphen{}based design optimizations provided in the form:
\begin{equation*}
\begin{split}\min_{x \in \Omega} f(x)\end{split}
\end{equation*}
\sphinxAtStartPar
where the feasible set \(\Omega = \{ x \in X : c_j(x) \leq 0, j \in J\} \subset \mathbb{R}^n\), \(f, c_j : X \rightarrow \mathbb{R} \cup \{ \infty \}\)
for  all \(j \in J= \{ 1,2,\ldots,m \}\), and where \(X\) is a subset of \(\mathbb{R}^n\).
The functions \(f\) and \(c_j\), \(j \in J\), are typically blackbox functions whose evaluations require computer simulation.

\sphinxAtStartPar
NOMAD can be used in two different modes: batch mode and library mode.
The batch mode is intended for a basic usage and is briefly presented below (more details will be provided in {\hyperref[\detokenize{HowToUseNomad:basic-nomad-usage}]{\sphinxcrossref{\DUrole{std,std-ref}{NOMAD usage}}}}).
This chapter explains how to get started with NOMAD in batch mode. The following topics will be covered:
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{GettingStarted:create-blackbox-program}]{\sphinxcrossref{\DUrole{std,std-ref}{Create blackbox programs}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{GettingStarted:provide-parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Provide parameters}}}} for defining the problem and displaying optimization results

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{GettingStarted:conduct-optimization}]{\sphinxcrossref{\DUrole{std,std-ref}{Conduct optimization}}}}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Building NOMAD binaries and running the examples provided during the installation requires to have a \sphinxcode{\sphinxupquote{C++}} compiler installed on your machine.

\sphinxAtStartPar
Compilation instructions rely on \sphinxstylestrong{CMake} and have been tested with \sphinxstylestrong{GCC} (GNU Compiler Collection), Clang and Visual Studio.
\end{sphinxadmonition}


\section{Create blackbox programs}
\label{\detokenize{GettingStarted:create-blackbox-programs}}\label{\detokenize{GettingStarted:create-blackbox-program}}
\sphinxAtStartPar
To conduct optimization in batch mode the users must define their separate blackbox program coded as a standalone program.
Blackbox program executions are managed by NOMAD with system calls.
\begin{description}
\item[{A valid blackbox program:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
takes an input vector file as single argument,

\item {} 
\sphinxAtStartPar
reads space\sphinxhyphen{}separated values in input vector file,

\item {} 
\sphinxAtStartPar
returns evaluation values on standard output or file,

\item {} 
\sphinxAtStartPar
returns an evaluation status.

\end{itemize}

\end{description}

\sphinxAtStartPar
In what follows we use the example in the \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/basic/batch/single\_obj}}.
This example optimization problem has a single objective, 5 variables, 2 nonlinear constraints and 8 bound constraints:

\noindent{\sphinxincludegraphics[width=650\sphinxpxdimen]{{example1}.png}\hspace*{\fill}}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The blackbox programs may be coded in any language (even scripts) but must respect \sphinxstylestrong{NOMAD format}:

\sphinxAtStartPar
1. The blackbox program must be callable in a terminal window at the command prompt and take the input vector file name as a single argument.
For the example above, the blackbox executable is \sphinxcode{\sphinxupquote{bb.exe}}, one can execute it with the command  \sphinxcode{\sphinxupquote{./bb.exe x.txt}}. Here \sphinxcode{\sphinxupquote{x.txt}} is a text file containing a total of 5 values.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
NOMAD will manage the creation of the \sphinxstylestrong{input file consisting of one value for each variable separated by space} and the execution of the blackbox program.

\end{enumerate}

\sphinxAtStartPar
3. The blackbox program must return the evaluation values by displaying them in the \sphinxstylestrong{standard output} (default) or by writing them in an output file (see {\hyperref[\detokenize{AdvancedFunctionalities:advanced-functionalities}]{\sphinxcrossref{\DUrole{std,std-ref}{Advanced functionalities}}}} about advanced output options).
It must also \sphinxstylestrong{return an evaluation status of 0} to indicate that the evaluation went well. Otherwise NOMAD considers that the evaluation has failed.

\sphinxAtStartPar
4. The minimum number of values displayed by the blackbox program corresponds to the number of constraints plus one (or two for bi\sphinxhyphen{}objective problems) representing the objective function(s) that one seeks to minimize.
The constraints values correspond to left\sphinxhyphen{}hand side of constraints of the form \(c_j \leq 0\) (for example, the constraint \(0 \leq x_1 + x_2 \leq 10\) must be displayed with the two quantities \(c_1(x)=-x_1-x_2\) and \(c_2(x)=x_1+x_2-10\)).
\end{sphinxadmonition}

\sphinxAtStartPar
The blackbox \sphinxcode{\sphinxupquote{C++}} program of the previous example to evaluate the objective and the two constraints for a given design vector is given as:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{+w}{ }\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{+w}{ }\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{+w}{ }\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{+w}{ }\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}cstdlib\PYGZgt{}}
\PYG{+w}{ }\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}

\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{argc}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{argv}\PYG{+w}{ }\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{f}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1e20}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1e20}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1e20}\PYG{p}{;}
\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}

\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{argc}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{     }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{;}
\PYG{+w}{     }\PYG{n}{ifstream}\PYG{+w}{ }\PYG{n}{in}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{     }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{+w}{ }\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{+w}{ }\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{in}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pow}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{c2}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pow}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{     }\PYG{p}{\PYGZcb{}}
\PYG{+w}{     }\PYG{n}{f}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{     }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{in}\PYG{p}{.}\PYG{n}{fail}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{)}
\PYG{+w}{         }\PYG{n}{f}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1e20}\PYG{p}{;}
\PYG{+w}{     }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{         }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{25}\PYG{p}{;}
\PYG{+w}{         }\PYG{n}{c2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{25}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{c2}\PYG{p}{;}
\PYG{+w}{     }\PYG{p}{\PYGZcb{}}
\PYG{+w}{     }\PYG{n}{in}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{ }\PYG{p}{\PYGZcb{}}
\PYG{+w}{ }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{f}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{c2}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{ }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The blackbox compilation and test are as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Change directory to \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/basic/batch/single\_obj}}.

\item {} 
\sphinxAtStartPar
Optionally, compile the blackbox program with the following command \sphinxcode{\sphinxupquote{g++ \sphinxhyphen{}o bb.exe bb.cpp}} (\sphinxstylestrong{GNU compiler}). This step is not really required because the building procedure with \sphinxstyleemphasis{CMake} normally builds the blackbox executable for this example.

\item {} 
\sphinxAtStartPar
Test the executable with the text file \sphinxcode{\sphinxupquote{x.txt}} containing \sphinxcode{\sphinxupquote{0 0 0 0 0}} by entering the command \sphinxcode{\sphinxupquote{bb.exe x.txt}}.

\end{enumerate}

\sphinxAtStartPar
4. This test  should display \sphinxcode{\sphinxupquote{0 \sphinxhyphen{}20 20}}, which means that the point \(x = (0~0~0~0~0)^T\) has an objective value of \(f(x)=0\),
but is not feasible, since the second constraint is not satisfied (\(c_2(x) = 20 > 0\)).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{} cd \PYGZdl{}NOMAD\PYGZus{}HOME/examples/basic/batch/single\PYGZus{}obj
\PYGZgt{} g++ \PYGZhy{}o bb.exe bb.cpp
\PYGZgt{} more x.txt
0 0 0 0 0
\PYGZgt{} ./bb.exe x.txt
0 \PYGZhy{}20 20
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The order of the displayed outputs must correspond to the order defined in the parameter file (see {\hyperref[\detokenize{HowToUseNomad:bb-output-type}]{\sphinxcrossref{\DUrole{std,std-ref}{BB\_OUTPUT\_TYPE}}}} for details).
If variables have bound constraints, they must be defined in the parameters file and should not appear in the blackbox code.
\end{sphinxadmonition}


\section{Provide parameters}
\label{\detokenize{GettingStarted:provide-parameters}}\label{\detokenize{GettingStarted:id2}}
\sphinxAtStartPar
In batch mode, the parameters are provided in a text file using predefined keywords followed by one or more argument.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Help on parameters is accessible at the command prompt:
\sphinxcode{\sphinxupquote{\$NOMAD\_HOME/bin/nomad \sphinxhyphen{}h param\_name}}
\end{sphinxadmonition}

\sphinxAtStartPar
Here are some of the most important parameters defining an optimization problem (without brackets):
\begin{itemize}
\item {} 
\sphinxAtStartPar
The number of variables (\sphinxcode{\sphinxupquote{DIMENSION n}}).

\item {} 
\sphinxAtStartPar
The name of the blackbox executable that outputs the objective and the constraints (\sphinxcode{\sphinxupquote{BB\_EXE bb\_name}}).

\item {} 
\sphinxAtStartPar
Bounds on variables are defined with the \sphinxcode{\sphinxupquote{LOWER\_BOUND lb}} and \sphinxcode{\sphinxupquote{UPPER\_BOUND ub}} parameters.

\item {} 
\sphinxAtStartPar
The output types of the blackbox executable: objective and constraints (\sphinxcode{\sphinxupquote{BB\_OUTPUT\_TYPE obj cons1 ... consM}}).

\item {} 
\sphinxAtStartPar
A starting point (\sphinxcode{\sphinxupquote{X0 x0}}).

\item {} 
\sphinxAtStartPar
An optional stopping criterion (\sphinxcode{\sphinxupquote{MAX\_BB\_EVAL max\_bb\_eval}}, for example).
If no stopping criterion is specified, the algorithm will stop as soon as the mesh size reaches a given tolerance.

\item {} 
\sphinxAtStartPar
Any entry on a line is ignored after the character \sphinxcode{\sphinxupquote{\#}}.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The order in which the parameters appear in the file or their case is unimportant.
\end{sphinxadmonition}

\sphinxAtStartPar
Example of a basic parameters file extracted from \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/basic/batch/single\_obj/param.txt}}.
The comments in the file describes some of the syntactic rules to provide parameters:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DIMENSION}      \PYG{l+m+mi}{5}              \PYG{c+c1}{\PYGZsh{} number of variables}

\PYG{n}{BB\PYGZus{}EXE}         \PYG{n}{bb}\PYG{o}{.}\PYG{n}{exe}         \PYG{c+c1}{\PYGZsh{} \PYGZsq{}bb.exe\PYGZsq{} is a program that}
\PYG{n}{BB\PYGZus{}OUTPUT\PYGZus{}TYPE} \PYG{n}{OBJ} \PYG{n}{PB} \PYG{n}{EB}      \PYG{c+c1}{\PYGZsh{} takes in argument the name of}
                              \PYG{c+c1}{\PYGZsh{} a text file containing 5}
                              \PYG{c+c1}{\PYGZsh{} values, and that displays 3}
                              \PYG{c+c1}{\PYGZsh{} values that correspond to the}
                              \PYG{c+c1}{\PYGZsh{} objective function value (OBJ),}
                              \PYG{c+c1}{\PYGZsh{} and two constraints values g1}
                              \PYG{c+c1}{\PYGZsh{} and g2 with g1 \PYGZlt{}= 0 and}
                              \PYG{c+c1}{\PYGZsh{} g2 \PYGZlt{}= 0; \PYGZsq{}PB\PYGZsq{} and \PYGZsq{}EB\PYGZsq{}}
                              \PYG{c+c1}{\PYGZsh{} correspond to constraints that}
                              \PYG{c+c1}{\PYGZsh{} are treated by the Progressive}
                              \PYG{c+c1}{\PYGZsh{} and Extreme Barrier approaches}
                              \PYG{c+c1}{\PYGZsh{} (all constraint\PYGZhy{}handling}
                              \PYG{c+c1}{\PYGZsh{}  options are described in the}
                              \PYG{c+c1}{\PYGZsh{}  detailed parameters list)}

\PYG{n}{X0}             \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} starting point}

\PYG{n}{LOWER\PYGZus{}BOUND}    \PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}           \PYG{c+c1}{\PYGZsh{} all variables are \PYGZgt{}= \PYGZhy{}6}
\PYG{n}{UPPER\PYGZus{}BOUND}    \PYG{p}{(} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{o}{\PYGZhy{}} \PYG{o}{\PYGZhy{}} \PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} x\PYGZus{}1 \PYGZlt{}= 5, x\PYGZus{}2 \PYGZlt{}= 6, x\PYGZus{}3 \PYGZlt{}= 7}
                              \PYG{c+c1}{\PYGZsh{} x\PYGZus{}4 and x\PYGZus{}5 have no bounds}

\PYG{n}{MAX\PYGZus{}BB\PYGZus{}EVAL}    \PYG{l+m+mi}{100}            \PYG{c+c1}{\PYGZsh{} the algorithm terminates when}
                              \PYG{c+c1}{\PYGZsh{} 100 black\PYGZhy{}box evaluations have}
                              \PYG{c+c1}{\PYGZsh{} been made}
\end{sphinxVerbatim}

\sphinxAtStartPar
The constraints defined in the parameters file are of different types.
The first constraint \(c_1(x) \leq 0\) is treated by the \sphinxstyleemphasis{Progressive Barrier} approach (\sphinxstyleemphasis{PB}), which allows constraint violations.
The second constraint, \(c_3(x) \leq 0\), is treated by the  \sphinxstyleemphasis{Extreme Barrier} approach (\sphinxstyleemphasis{EB}) that forbids violations.
Hence, evaluations not satisfying extreme barrier constraints are simply not considered when trying to improve the solution.

\sphinxAtStartPar
In the example above, the algorithmic parameters of NOMAD need not to be set because default
values are considered. This will provide the best results in most situations.


\section{Conduct optimization}
\label{\detokenize{GettingStarted:conduct-optimization}}\label{\detokenize{GettingStarted:id3}}
\sphinxAtStartPar
Optimization is conducted by starting NOMAD executable in a command window with the parameter file name given as argument.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}NOMAD\PYGZus{}HOME/bin/nomad param.txt
\end{sphinxVerbatim}

\sphinxAtStartPar
To illustrate the execution, the example provided in \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/basic/batch/single\_obj/}} is considered:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{} cd \PYGZdl{}NOMAD\PYGZus{}HOME/examples/basic/batch/single\PYGZus{}obj
\PYGZgt{} ls
bb.cpp bb.exe CMakeLists.txt makefile param.txt x.txt
\PYGZgt{}\PYGZdl{}NOMAD\PYGZus{}HOME/bin/nomad param.txt
BBE ( SOL ) OBJ
  1   (   0          0          0          0          0        )    0        (Phase One)
  8   (   0          4          0          0          0        )    0        (Phase One)
  28  (   1.4        5          0         \PYGZhy{}0.6       \PYGZhy{}0.4      )   \PYGZhy{}0.4
  29  (   2.6        4          0         \PYGZhy{}1.4       \PYGZhy{}0.8      )   \PYGZhy{}0.8
  33  (   1.63       3          0.92      \PYGZhy{}1.78      \PYGZhy{}0.88     )   \PYGZhy{}0.88
  37  (   2.46       3          0.97      \PYGZhy{}1.87      \PYGZhy{}0.92     )   \PYGZhy{}0.92
  41  (   3.2        3          0.16      \PYGZhy{}1.26      \PYGZhy{}1.05     )   \PYGZhy{}1.05
  42  (   4.27       2         \PYGZhy{}0.23      \PYGZhy{}1.07      \PYGZhy{}1.36     )   \PYGZhy{}1.36
  47  (   3.0        1          1.22      \PYGZhy{}1.92      \PYGZhy{}1.5      )   \PYGZhy{}1.5
  48  (   3.2        0          1.83      \PYGZhy{}2.19      \PYGZhy{}1.86     )   \PYGZhy{}1.86
  57  (   3.91      \PYGZhy{}0          1.02      \PYGZhy{}1.32      \PYGZhy{}1.95     )   \PYGZhy{}1.95
  67  (   3.61      \PYGZhy{}0          1.28      \PYGZhy{}1.83      \PYGZhy{}1.99     )   \PYGZhy{}1.99
  78  (   3.94       1          0.63      \PYGZhy{}1.14      \PYGZhy{}2.02     )   \PYGZhy{}2.02
  79  (   4.32       1          0.02      \PYGZhy{}0.61      \PYGZhy{}2.11     )   \PYGZhy{}2.11
  84  (   3.68       0          0.97      \PYGZhy{}1.23      \PYGZhy{}2.15     )   \PYGZhy{}2.15
  88  (   3.91       1          0.5       \PYGZhy{}0.6       \PYGZhy{}2.2      )   \PYGZhy{}2.2
  89  (   4.07       1          0.1        0.01      \PYGZhy{}2.31     )   \PYGZhy{}2.31
  94  (   3.67       1          0.56      \PYGZhy{}0.47      \PYGZhy{}2.36     )   \PYGZhy{}2.36
  95  (   3.35       1          0.84      \PYGZhy{}0.39      \PYGZhy{}2.48     )   \PYGZhy{}2.48
  99  (   4.15       1         \PYGZhy{}0.37       0.57      \PYGZhy{}2.49     )   \PYGZhy{}2.49
  Reached stop criterion: Max number of blackbox evaluations (Eval Global) 100
  A termination criterion is reached: Max number of blackbox evaluations (Eval Global) No more points to evaluate 100

  Best feasible solution:     \PYGZsh{}1540 ( 4.15 1 \PYGZhy{}0.37 0.57 \PYGZhy{}2.49 )   Evaluation OK    f =  \PYGZhy{}2.4900000000000002132     h =   0

  Best infeasible solution:   \PYGZsh{}1512 ( 3.79 0 1.14 \PYGZhy{}1.75 \PYGZhy{}1.97 )   Evaluation OK    f =  \PYGZhy{}1.9699999999999999734     h =   0.03500640999999999475

  Blackbox evaluations:        100
  Total model evaluations:     1348
  Cache hits:                  3
  Total number of evaluations: 103
\end{sphinxVerbatim}


\chapter{NOMAD usage}
\label{\detokenize{HowToUseNomad:nomad-usage}}\label{\detokenize{HowToUseNomad:basic-nomad-usage}}\label{\detokenize{HowToUseNomad::doc}}
\sphinxAtStartPar
This chapter describes how to use NOMAD for solving blackbox optimization problems. Functionalities of NOMAD that are considered more advanced such as parallel evaluations are presented in {\hyperref[\detokenize{AdvancedFunctionalities:advanced-functionalities}]{\sphinxcrossref{\DUrole{std,std-ref}{Advanced functionalities}}}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
New users are encouraged to first read {\hyperref[\detokenize{GettingStarted:getting-started}]{\sphinxcrossref{\DUrole{std,std-ref}{Getting started}}}} to understand the basics of NOMAD utilization.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Many examples are provided in \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples}} with typical optimization outputs.
\end{sphinxadmonition}

\sphinxAtStartPar
Batch mode is presented first, followed by a description of the basic parameters to setup and solve the majority of optimization problems that NOMAD can handle. The library mode is described in {\hyperref[\detokenize{LibraryMode:library-mode}]{\sphinxcrossref{\DUrole{std,std-ref}{Optimization in library mode}}}}.

\sphinxAtStartPar
NOMAD should be cited with references \sphinxcite{HowToUseNomad:auco04a} and \sphinxcite{index:aulerotr2021}. Other relevant papers by the developers are accessible through  the NOMAD website  \sphinxurl{http://www.gerad.ca/nomad}.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{References}
\end{sphinxShadowBox}


\section{Optimization in batch mode}
\label{\detokenize{HowToUseNomad:optimization-in-batch-mode}}
\sphinxAtStartPar
The batch mode allows to separate the evaluation of the objectives and constraints by the blackbox program from NOMAD executable. This mode has the advantage that if your blackbox program crashes, it will not affect NOMAD: The point that caused this crash will simply be tagged as a blackbox failure.

\sphinxAtStartPar
Handling crashes in library mode requires special attention to isolate the part of code that may generate crashes. And, in general, using the library mode will require more computer programming than the batch mode. However, the library mode offers more options and flexibility for blackbox integration and management of optimization (see {\hyperref[\detokenize{LibraryMode:library-mode}]{\sphinxcrossref{\DUrole{std,std-ref}{Optimization in library mode}}}}).

\sphinxAtStartPar
The different steps for solving your problem in batch mode are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Create a directory for your problem. The problem directory is where the NOMAD command is executed. It is a convenient place to put the blackbox executable, the parameters file and the output files, but those locations can be customized.

\item {} 
\sphinxAtStartPar
Create your blackbox evaluation, which corresponds  to a program (a binary executable or a script). This program can be located in the problem directory or not.  This program outputs the objectives and the constraints for a given design vector. If you already have a blackbox program in a certain format, you need to interface it with a wrapper program to match  NOMAD specifications (see {\hyperref[\detokenize{GettingStarted:getting-started}]{\sphinxcrossref{\DUrole{std,std-ref}{Getting started}}}} for blackbox basics).

\item {} 
\sphinxAtStartPar
Create a parameters file, for example \sphinxcode{\sphinxupquote{param.txt}}. This file can be located in the problem directory or not (see {\hyperref[\detokenize{HowToUseNomad:basic-parameters-description}]{\sphinxcrossref{\DUrole{std,std-ref}{Basic parameters description}}}} for more details).

\item {} 
\sphinxAtStartPar
In the problem directory, start the optimization with a command like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}NOMAD\PYGZus{}HOME/bin/nomad param.txt
\end{sphinxVerbatim}

\end{itemize}


\section{Basic parameters description}
\label{\detokenize{HowToUseNomad:basic-parameters-description}}\label{\detokenize{HowToUseNomad:id3}}
\sphinxAtStartPar
This section describes the basic parameters for the optimization problem definition, the algorithmic parameters and the parameters to manage output information. Additional information can be obtained by executing the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}NOMAD\PYGZus{}HOME/bin/nomad \PYGZhy{}h
\end{sphinxVerbatim}

\sphinxAtStartPar
to see all parameters, or:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}NOMAD\PYGZus{}HOME/bin/nomad \PYGZhy{}h PARAM\PYGZus{}NAME
\end{sphinxVerbatim}

\sphinxAtStartPar
for a particular parameter.

\sphinxAtStartPar
The remaining content of a line is ignored after the character \sphinxcode{\sphinxupquote{\#}}. Except for the file names, all strings and parameter names are case insensitive: \sphinxcode{\sphinxupquote{DIMENSION 2}} is the same as \sphinxcode{\sphinxupquote{Dimension 2}}. File names refer to files in the problem directory. To indicate a file name containing spaces, use quotes \sphinxcode{\sphinxupquote{"name"}} or \sphinxcode{\sphinxupquote{\textquotesingle{}name\textquotesingle{}}}. These names may include directory information relatively to the problem directory. The problem directory will be added to the names, unless the \sphinxcode{\sphinxupquote{\$}} character is used in front of the names. For example, if a blackbox executable is run by the command \sphinxcode{\sphinxupquote{python script.py}}, define parameter \sphinxcode{\sphinxupquote{BB\_EXE "\$python script.py"}}.

\sphinxAtStartPar
Some parameters consists of a list of variable indices taken from 0 to \(n-1\)  (where \(n\) is the number of variables). Variable indices may be entered individually or as a range  with format \sphinxcode{\sphinxupquote{i\sphinxhyphen{}j}}. Character \sphinxcode{\sphinxupquote{*}} may be used to replace 0 to \(n-1\). Other parameters require arguments of type boolean: these values  may be entered with the strings \sphinxcode{\sphinxupquote{yes}}, \sphinxcode{\sphinxupquote{no}}, \sphinxcode{\sphinxupquote{y}}, \sphinxcode{\sphinxupquote{n}},  \sphinxcode{\sphinxupquote{0}}, or \sphinxcode{\sphinxupquote{1}}. Finally, some parameters need vectors as arguments,  use \sphinxcode{\sphinxupquote{(v1 v2 ... vn)}} for those. The strings \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}, \sphinxcode{\sphinxupquote{inf}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}inf}} or \sphinxcode{\sphinxupquote{+inf}}  are accepted to enter undefined real values  (NOMAD considers \(\pm \infty\) as an undefined value).

\sphinxAtStartPar
Parameters are classified into problem, algorithmic and output parameters, and provided in what follows. The advanced functionalities of NOMAD are presented in {\hyperref[\detokenize{AdvancedFunctionalities:advanced-functionalities}]{\sphinxcrossref{\DUrole{std,std-ref}{Advanced functionalities}}}}.


\subsection{Problem parameters}
\label{\detokenize{HowToUseNomad:problem-parameters}}\label{\detokenize{HowToUseNomad:id4}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Basic problem parameters}\label{\detokenize{HowToUseNomad:id21}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{20}{54}|\X{7}{54}|\X{20}{54}|\X{7}{54}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Short description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:bb-exe}]{\sphinxcrossref{\DUrole{std,std-ref}{BB\_EXE}}}}
&
\sphinxAtStartPar
list of strings
&
\sphinxAtStartPar
blackbox executables (required in batch mode)
&
\sphinxAtStartPar
Empty string
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:bb-input-type}]{\sphinxcrossref{\DUrole{std,std-ref}{BB\_INPUT\_TYPE}}}}
&
\sphinxAtStartPar
list of types
&
\sphinxAtStartPar
blackbox input types
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{* R}} (all real)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:bb-output-type}]{\sphinxcrossref{\DUrole{std,std-ref}{BB\_OUTPUT\_TYPE}}}}
&
\sphinxAtStartPar
list of types
&
\sphinxAtStartPar
blackbox output types (required)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OBJ}}
\\
\hline
\sphinxAtStartPar
DIMENSION
&
\sphinxAtStartPar
integer
&
\sphinxAtStartPar
\(n\) the number of variables (required)
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:bounds}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWER\_BOUND}}}}
&
\sphinxAtStartPar
array of doubles
&
\sphinxAtStartPar
lower bounds
&
\sphinxAtStartPar
none
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:bounds}]{\sphinxcrossref{\DUrole{std,std-ref}{UPPER\_BOUND}}}}
&
\sphinxAtStartPar
array of doubles
&
\sphinxAtStartPar
upper bounds
&
\sphinxAtStartPar
none
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{BB\_EXE}}}
\label{\detokenize{HowToUseNomad:bb-exe}}\label{\detokenize{HowToUseNomad:id5}}
\sphinxAtStartPar
In batch mode, \sphinxcode{\sphinxupquote{BB\_EXE}} indicates the names of the blackbox executables.

\sphinxAtStartPar
A single string may be given if a single blackbox is used and gives several outputs. It is also possible to indicate several blackbox executables.

\sphinxAtStartPar
A blackbox program can return more than one function {\hyperref[\detokenize{HowToUseNomad:bb-output-type}]{\sphinxcrossref{\DUrole{std,std-ref}{BB\_OUTPUT\_TYPE}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BB\PYGZus{}EXE}         \PYG{n}{bb}\PYG{o}{.}\PYG{n}{exe}             \PYG{c+c1}{\PYGZsh{} defines that `bb.exe\PYGZsq{} is an}
\PYG{n}{BB\PYGZus{}OUTPUT\PYGZus{}TYPE} \PYG{n}{OBJ} \PYG{n}{EB} \PYG{n}{EB}          \PYG{c+c1}{\PYGZsh{} executable with 3 outputs}
\end{sphinxVerbatim}

\sphinxAtStartPar
A mapping between the names of the blackbox programs and the \sphinxcode{\sphinxupquote{BB\_OUTPUT\_TYPE}} may be established to identify which function is returned by which blackbox:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BB\PYGZus{}EXE}         \PYG{n}{bb1}\PYG{o}{.}\PYG{n}{exe} \PYG{n}{bb2}\PYG{o}{.}\PYG{n}{exe}    \PYG{c+c1}{\PYGZsh{} defines two blackboxes}
\PYG{n}{BB\PYGZus{}OUTPUT\PYGZus{}TYPE} \PYG{n}{OBJ}     \PYG{n}{EB}         \PYG{c+c1}{\PYGZsh{} `bb1.exe\PYGZsq{} and `bb2.exe\PYGZsq{}}
                                  \PYG{c+c1}{\PYGZsh{} with one output each}
\end{sphinxVerbatim}

\sphinxAtStartPar
Blackbox program names can be repeated to establish more complex mapping:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BB\PYGZus{}EXE}   \PYG{n}{bb1}\PYG{o}{.}\PYG{n}{exe} \PYG{n}{bb2}\PYG{o}{.}\PYG{n}{exe} \PYG{n}{bb2}\PYG{o}{.}\PYG{n}{exe}  \PYG{c+c1}{\PYGZsh{} defines TWO blackboxes}
                                  \PYG{c+c1}{\PYGZsh{} NO duplication if names are repeated}
\PYG{n}{BB\PYGZus{}OUTPUT\PYGZus{}TYPE} \PYG{n}{EB} \PYG{n}{OBJ} \PYG{n}{PB}          \PYG{c+c1}{\PYGZsh{} bb1.exe  has one output}
                                  \PYG{c+c1}{\PYGZsh{} bb2.exe  has two outputs}
                                  \PYG{c+c1}{\PYGZsh{} bb1.exe is executed first.}
                                  \PYG{c+c1}{\PYGZsh{}!! If EB constraint is feasible then}
                                  \PYG{c+c1}{\PYGZsh{}!!        bb2.exe is executed.}
                                  \PYG{c+c1}{\PYGZsh{}!! If EB constraint not feasible then}
                                  \PYG{c+c1}{\PYGZsh{}!!      bb2.exe is not launched.}
\end{sphinxVerbatim}

\sphinxAtStartPar
A path can precede the blackbox program but spaces are not accepted in the path:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BB\PYGZus{}EXE} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dir\PYGZus{}of\PYGZus{}blackbox/bb.exe}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
To prevent NOMAD from adding a path,  the special character \sphinxcode{\sphinxupquote{\$}}  should be put in front of a command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BB\PYGZus{}EXE} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}python bb.py}\PYG{l+s+s2}{\PYGZdq{}}          \PYG{c+c1}{\PYGZsh{} the blackbox is a python}
                                \PYG{c+c1}{\PYGZsh{} script: it is run with}
                                \PYG{c+c1}{\PYGZsh{} command}
                                \PYG{c+c1}{\PYGZsh{} `python PROBLEM\PYGZus{}DIR/bb.py\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BB\PYGZus{}EXE} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}nice bb.exe}\PYG{l+s+s2}{\PYGZdq{}}           \PYG{c+c1}{\PYGZsh{} to run bb.exe}
                                \PYG{c+c1}{\PYGZsh{} in nice mode on X systems}
\end{sphinxVerbatim}


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{BB\_INPUT\_TYPE}}}
\label{\detokenize{HowToUseNomad:bb-input-type}}\label{\detokenize{HowToUseNomad:id6}}
\sphinxAtStartPar
This parameter indicates the types of each variable.
It may be defined once with a list of \(n\) input types with format  \sphinxcode{\sphinxupquote{(t1 t2 ... tn)}} or \textasciigrave{}\textasciigrave{} * t\textasciigrave{}\textasciigrave{}.
Input types \sphinxcode{\sphinxupquote{t}} are values in \sphinxcode{\sphinxupquote{R, B, I}}. \sphinxcode{\sphinxupquote{R}} is for real/continuous variables, \sphinxcode{\sphinxupquote{B}} for binary variables, and \sphinxcode{\sphinxupquote{I}} for integer variables.
The default type is \sphinxcode{\sphinxupquote{R}}. See also {\hyperref[\detokenize{ListOfParameters::doc}]{\sphinxcrossref{\DUrole{doc}{Detailed information}}}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Categorical variables are not yet supported in NOMAD 4 but are available in NOMAD 3.
\end{sphinxadmonition}


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{BB\_OUTPUT\_TYPE}}}
\label{\detokenize{HowToUseNomad:bb-output-type}}\label{\detokenize{HowToUseNomad:id7}}
\sphinxAtStartPar
This parameter characterizes the values supplied by the blackbox, and in particular tells how constraint values are to be treated. The arguments are a list of \(m\) types, where \(m\) is the number of outputs of the  blackbox. At least one of these values must correspond to the objective function that NOMAD minimizes. Currently, NOMAD 4 only supports single objective problem (NOMAD 3 can handle bi\sphinxhyphen{}objective). Other values typically are constraints of the form \(c_j(x) \leq 0\), and the blackbox  must display the left\sphinxhyphen{}hand side of the constraint with this format.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
A terminology is used to describe the different types of constraints \sphinxcite{Introduction:aude09a}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EB}} constraints correspond to constraints that need to be always satisfied (\sphinxstyleemphasis{unrelaxable constraints}). The technique used to deal with those is the \sphinxstylestrong{Extreme Barrier} approach, consisting in simply rejecting the  infeasible points.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PB}} and \sphinxcode{\sphinxupquote{F}} constraints correspond to constraints that need to be satisfied only at the solution, and not necessarily at intermediate points (\sphinxstyleemphasis{relaxable constraints}). More precisely, \sphinxcode{\sphinxupquote{F}} constraints are treated with the \sphinxstylestrong{Filter} approach \sphinxcite{HowToUseNomad:aude04a},  and \sphinxcode{\sphinxupquote{PB}} constraints are treated with the \sphinxstylestrong{Progressive Barrier}  approach \sphinxcite{Introduction:aude09a}.

\item {} 
\sphinxAtStartPar
There may be another type of constraints, the \sphinxstyleemphasis{hidden constraints}, but these only  appear inside the blackbox during an execution, and thus they   cannot be indicated in advance to NOMAD  (when such a constraint is violated, the evaluation simply fails and the point  is not considered).

\end{itemize}

\sphinxAtStartPar
If the user is not sure about the nature of its constraints, we suggest using the keyword \sphinxcode{\sphinxupquote{CSTR}}, which corresponds by default to \sphinxcode{\sphinxupquote{PB}} constraints.
\end{sphinxadmonition}

\sphinxAtStartPar
All the types are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CNT\_EVAL}}
&
\sphinxAtStartPar
Must be 0 or 1: count or not the blackbox evaluation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EB}}
&
\sphinxAtStartPar
Constraint treated with \sphinxstylestrong{Extreme Barrier}
(infeasible points are ignored)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{F}}
&
\sphinxAtStartPar
Constraint treated with \sphinxstylestrong{Filter} approach
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NOTHING}}
\sphinxcode{\sphinxupquote{EXTRA\_O}}
\sphinxcode{\sphinxupquote{\sphinxhyphen{}}}
&
\sphinxAtStartPar
The output is ignored
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OBJ}}
&
\sphinxAtStartPar
Objective value to be minimized
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PB}}
\sphinxcode{\sphinxupquote{CSTR}}
&
\sphinxAtStartPar
Constraint treated with \sphinxstylestrong{Progressive Barrier}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Please note that \sphinxcode{\sphinxupquote{F}} constraints are not compatible with \sphinxcode{\sphinxupquote{CSTR}} or \sphinxcode{\sphinxupquote{PB}}. However, \sphinxcode{\sphinxupquote{EB}} can be combined  with \sphinxcode{\sphinxupquote{F}}, \sphinxcode{\sphinxupquote{CSTR}} or \sphinxcode{\sphinxupquote{PB}}.


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{LOWER\_BOUND}} and \sphinxstyleliteralintitle{\sphinxupquote{UPPER\_BOUND}}}
\label{\detokenize{HowToUseNomad:lower-bound-and-upper-bound}}\label{\detokenize{HowToUseNomad:bounds}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
NOMAD is 0 based \(\rightarrow\) The first variable has a 0 index.
\end{sphinxadmonition}

\sphinxAtStartPar
Parameters \sphinxcode{\sphinxupquote{LOWER\_BOUND}} and \sphinxcode{\sphinxupquote{UPPER\_BOUND}} are used to define bounds on variables. For example, with \(n=7\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{LOWER\PYGZus{}BOUND}  \PYG{l+m+mi}{0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}
\PYG{n}{LOWER\PYGZus{}BOUND}  \PYG{l+m+mi}{3}     \PYG{l+m+mf}{0.0}
\PYG{n}{LOWER\PYGZus{}BOUND}  \PYG{l+m+mi}{5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.0}
\PYG{n}{UPPER\PYGZus{}BOUND}  \PYG{l+m+mi}{0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}   \PYG{l+m+mf}{8.0}
\end{sphinxVerbatim}

\sphinxAtStartPar
is equivalent to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{LOWER\PYGZus{}BOUND} \PYG{p}{(} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{p}{)} \PYG{c+c1}{\PYGZsh{} `\PYGZhy{}\PYGZsq{} or `\PYGZhy{}inf\PYGZsq{} means that x\PYGZus{}4}
                                   \PYG{c+c1}{\PYGZsh{} has no lower bound}
\PYG{n}{UPPER\PYGZus{}BOUND} \PYG{p}{(}  \PYG{l+m+mi}{8} \PYG{l+m+mi}{8} \PYG{l+m+mi}{8} \PYG{l+m+mi}{8} \PYG{l+m+mi}{8} \PYG{l+m+mi}{8} \PYG{n}{inf} \PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} `\PYGZhy{}\PYGZsq{} or `inf\PYGZsq{} or `+inf\PYGZsq{} means}
                                   \PYG{c+c1}{\PYGZsh{} that x\PYGZus{}6 has no upper bound.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Each of these two sequences define the following bounds
\begin{equation*}
\begin{split}-5 ~ \leq x_0 \leq ~ 8 \\
-5 ~ \leq x_1 \leq ~ 8 \\
-5 ~ \leq x_2 \leq ~ 8 \\
 0 ~ \leq x_3 \leq ~ 8 \\
          x_4 \leq ~ 8 \\
-4 ~ \leq x_5 \leq ~ 8 \\
-4 ~ \leq x_6 \qquad \\\end{split}
\end{equation*}

\subsection{Algorithmic parameters}
\label{\detokenize{HowToUseNomad:algorithmic-parameters}}\label{\detokenize{HowToUseNomad:id11}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Basic algorithmic parameters}\label{\detokenize{HowToUseNomad:id22}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{20}{54}|\X{7}{54}|\X{20}{54}|\X{7}{54}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Short description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:direction-type}]{\sphinxcrossref{\DUrole{std,std-ref}{DIRECTION\_TYPE}}}}
&
\sphinxAtStartPar
direction type
&
\sphinxAtStartPar
type of directions for the poll
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ORTHO N+1 QUAD}}
\\
\hline
\sphinxAtStartPar
F\_TARGET
&
\sphinxAtStartPar
real \(t\)
&
\sphinxAtStartPar
NOMAD terminates if \(f(x_k) \leq t\) for the objective function
&
\sphinxAtStartPar
none
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:initial-mesh-size}]{\sphinxcrossref{\DUrole{std,std-ref}{INITIAL\_MESH\_SIZE}}}}
&
\sphinxAtStartPar
array of doubles
&
\sphinxAtStartPar
\(\delta_0\) \sphinxcite{Introduction:aude2006}
&
\sphinxAtStartPar
none
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:initial-mesh-size}]{\sphinxcrossref{\DUrole{std,std-ref}{INITIAL\_FRAME\_SIZE}}}}
&
\sphinxAtStartPar
array of doubles
&
\sphinxAtStartPar
\(\Delta_0\) \sphinxcite{Introduction:aude2006}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{r0.1}} or based on \sphinxcode{\sphinxupquote{X0}}
\\
\hline
\sphinxAtStartPar
LH\_SEARCH
&
\sphinxAtStartPar
2 integers: \sphinxcode{\sphinxupquote{p0}} and \sphinxcode{\sphinxupquote{pi}}
&
\sphinxAtStartPar
\sphinxstylestrong{LH (Latin\sphinxhyphen{}Hypercube) search} (\sphinxcode{\sphinxupquote{p0}}: initial and \sphinxcode{\sphinxupquote{pi}}: iterative)
&
\sphinxAtStartPar
none
\\
\hline
\sphinxAtStartPar
MAX\_BB\_EVAL
&
\sphinxAtStartPar
integer
&
\sphinxAtStartPar
maximum number of blackbox evaluations
&
\sphinxAtStartPar
none
\\
\hline
\sphinxAtStartPar
MAX\_TIME
&
\sphinxAtStartPar
integer
&
\sphinxAtStartPar
maximum wall\sphinxhyphen{}clock time (in seconds)
&
\sphinxAtStartPar
none
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:tmp-dir}]{\sphinxcrossref{\DUrole{std,std-ref}{TMP\_DIR}}}}
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
temporary directory for blackbox i/o files
&
\sphinxAtStartPar
problem directory
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:x0}]{\sphinxcrossref{\DUrole{std,std-ref}{X0}}}}
&
\sphinxAtStartPar
point
&
\sphinxAtStartPar
starting point(s)
&
\sphinxAtStartPar
best point from a cache file or from an initial \sphinxstylestrong{LH search}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{DIRECTION\_TYPE}}}
\label{\detokenize{HowToUseNomad:direction-type}}\label{\detokenize{HowToUseNomad:id14}}
\sphinxAtStartPar
This parameter defines the type of directions for \sphinxstyleemphasis{Mads} \sphinxstyleemphasis{Poll} step. The possible arguments are:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Direction types}\label{\detokenize{HowToUseNomad:id23}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{6}{26}|\X{20}{26}|}
\hline

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ORTHO N+1 QUAD}}
&
\sphinxAtStartPar
OrthoMADS, n+1, with ((n+1)th dir = quad model optimization) {[}Default since 4.2{]}{[}AuIaLeDTr2014{]}\_
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ORTHO 2N}}
&
\sphinxAtStartPar
OrthoMADS, 2n. This corresponds to the original \sphinxstyleemphasis{Ortho Mads} algorithm \sphinxcite{Introduction:abaudele09} with \(2n\) directions.
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ORTHO N+1 NEG}}
&
\sphinxAtStartPar
OrthoMADS, n+1, with ((n+1)th dir = negative sum of the first n dirs) \sphinxcite{HowToUseNomad:auialedtr2014}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{N+1 UNI}}
&
\sphinxAtStartPar
MADS with n+1, using \(n+1\) uniformly distributed directions.
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SINGLE}}
&
\sphinxAtStartPar
A single direction is produced
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DOUBLE}}
&
\sphinxAtStartPar
Two opposite directions are produced
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Multiple direction types may be chosen by specifying \sphinxcode{\sphinxupquote{DIRECTION\_TYPE}} several times.


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{INITIAL\_MESH\_SIZE}} and \sphinxstyleliteralintitle{\sphinxupquote{INITIAL\_FRAME\_SIZE}}}
\label{\detokenize{HowToUseNomad:initial-mesh-size-and-initial-frame-size}}\label{\detokenize{HowToUseNomad:initial-mesh-size}}
\sphinxAtStartPar
The \sphinxstyleemphasis{Poll} step initial frame size \(\Delta_0\) is decided by \sphinxcode{\sphinxupquote{INITIAL\_FRAME\_SIZE}}. In order to achieve the scaling between variables, NOMAD considers the frame size parameter for each variable independently. The initial mesh size parameter \sphinxcode{\sphinxupquote{\textbackslash{}delta\_0}} is decided based on \sphinxcode{\sphinxupquote{\textbackslash{}Delta\_0}}. \sphinxcode{\sphinxupquote{INITIAL\_FRAME\_SIZE}} may be entered with the following formats:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
INITIAL\PYGZus{}FRAME\PYGZus{}SIZE     d0 (same initial mesh size for all variables)
INITIAL\PYGZus{}FRAME\PYGZus{}SIZE     (d0 d1 ... dn\PYGZhy{}1) (for all variables ``\PYGZhy{}`` may be used,  and defaults will be considered)
INITIAL\PYGZus{}FRAME\PYGZus{}SIZE i   d0 (initial mesh size provided for variable ``i`` only)
INITIAL\PYGZus{}FRAME\PYGZus{}SIZE i\PYGZhy{}j d0 (initial mesh size provided for variables ``i`` to ``j``)
\end{sphinxVerbatim}

\sphinxAtStartPar
The same logic and format apply for providing the \sphinxcode{\sphinxupquote{INITIAL\_MESH\_SIZE}}, \sphinxcode{\sphinxupquote{MIN\_MESH\_SIZE}} and \sphinxcode{\sphinxupquote{MIN\_FRAME\_SIZE}}.


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{TMP\_DIR}}}
\label{\detokenize{HowToUseNomad:tmp-dir}}\label{\detokenize{HowToUseNomad:id17}}
\sphinxAtStartPar
If NOMAD is installed on a network file system, with the batch mode use,  the cost of read/write files  will be high if no local temporary directory is defined.  On linux/unix/osxsystems, the directory \sphinxcode{\sphinxupquote{/tmp}} is  local and we advise the user to define \sphinxcode{\sphinxupquote{TMP\_DIR /tmp}}.


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{X0}}}
\label{\detokenize{HowToUseNomad:x0}}\label{\detokenize{HowToUseNomad:id18}}
\sphinxAtStartPar
Parameter \sphinxcode{\sphinxupquote{X0}} indicates the starting point of the algorithm. Several starting points may be proposed by entering this parameter several times. If no starting point is indicated, NOMAD considers the best evaluated point from an existing cache file (parameter \sphinxcode{\sphinxupquote{CACHE\_FILE}})  or from an initial \sphinxstyleemphasis{Latin\sphinxhyphen{}Hypercube search} (argument \sphinxcode{\sphinxupquote{p0}} of \sphinxcode{\sphinxupquote{LH\_SEARCH}}).

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{X0}} parameter may take several types of arguments:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A string indicating an existing cache file, containing several points (they can be already evaluated or not). This file may be the same as the one indicated with \sphinxcode{\sphinxupquote{CACHE\_FILE}}. If so, this file will be updated during the program execution, otherwise the file will not be modified.

\item {} 
\sphinxAtStartPar
A string indicating a text file containing the coordinates of one or several points (values are separated by spaces or line breaks).

\item {} 
\sphinxAtStartPar
\(n\) real values with format \sphinxcode{\sphinxupquote{(v0 v1 ... vn\sphinxhyphen{}1)}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{X0}} keyword plus integer(s) and one real

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{X0} \PYG{n}{i} \PYG{n}{v}\PYG{p}{:} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{n}{th} \PYG{n}{coordinate} \PYG{n+nb}{set} \PYG{n}{to} \PYG{n}{v}\PYG{o}{.}
\PYG{n}{X0} \PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{n}{v}\PYG{p}{:} \PYG{n}{coordinates} \PYG{n}{i} \PYG{n}{to} \PYG{n}{j} \PYG{n+nb}{set} \PYG{n}{to} \PYG{n}{v}\PYG{o}{.}
\PYG{n}{X0} \PYG{o}{*} \PYG{n}{v}\PYG{p}{:} \PYG{n+nb}{all} \PYG{n}{coordinates} \PYG{n+nb}{set} \PYG{n}{to} \PYG{n}{v}\PYG{o}{.}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
One integer, another integer (or index range) and one real: the same as above except that the first integer k refers to the (k+1)th starting point.

\end{itemize}

\sphinxAtStartPar
The following example with \(n=3\) corresponds to the two starting points \(( 5~0~0)\) and \((-5~1~1)\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{X0} \PYG{o}{*} \PYG{l+m+mf}{0.0}
\PYG{n}{X0} \PYG{l+m+mi}{0} \PYG{l+m+mf}{5.0}
\PYG{n}{X0} \PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mf}{1.0}
\PYG{n}{X0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}
\end{sphinxVerbatim}


\subsection{Output parameters}
\label{\detokenize{HowToUseNomad:output-parameters}}\label{\detokenize{HowToUseNomad:id19}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Basic output parameters}\label{\detokenize{HowToUseNomad:id24}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{20}{54}|\X{7}{54}|\X{20}{54}|\X{7}{54}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Short description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
CACHE\_FILE
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
cache file; if the file does not exist, it will be created
&
\sphinxAtStartPar
none
\\
\hline
\sphinxAtStartPar
DISPLAY\_ALL\_EVAL
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
if \sphinxcode{\sphinxupquote{yes}} all points are displayed with \sphinxcode{\sphinxupquote{DISPLAY\_STATS}} and \sphinxcode{\sphinxupquote{STATS\_FILE}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{no}}
\\
\hline
\sphinxAtStartPar
DISPLAY\_DEGREE
&
\sphinxAtStartPar
integer in {[}0 ; 3{]} or a string with four digits (see online help)
&
\sphinxAtStartPar
0 no display and 3 full display
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{2}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:display-stats}]{\sphinxcrossref{\DUrole{std,std-ref}{DISPLAY\_STATS}}}}
&
\sphinxAtStartPar
list of strings
&
\sphinxAtStartPar
what information is displayed at each success
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BBE OBJ}}
\\
\hline
\sphinxAtStartPar
HISTORY\_FILE
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
file containing all trial points with format \sphinxcode{\sphinxupquote{x1 x2 ... xn bbo1 bbo2 ... bbom}} on each line
&
\sphinxAtStartPar
none
\\
\hline
\sphinxAtStartPar
SOLUTION\_FILE
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
file to save the best feasible incumbent point in a simple format (SOL BBO)
&
\sphinxAtStartPar
none
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:display-stats}]{\sphinxcrossref{\DUrole{std,std-ref}{STATS\_FILE}}}}
&
\sphinxAtStartPar
string \sphinxcode{\sphinxupquote{file\_name}} + list of strings
&
\sphinxAtStartPar
the same as \sphinxcode{\sphinxupquote{DISPLAY\_STATS}} but for a display into file
&
\sphinxAtStartPar
none
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{DISPLAY\_DEGREE}}}
\label{\detokenize{HowToUseNomad:display-degree}}\label{\detokenize{HowToUseNomad:id20}}
\sphinxAtStartPar
Four different levels of display can be set via the parameter \sphinxcode{\sphinxupquote{DISPLAY\_DEGREE}}. The \sphinxcode{\sphinxupquote{DISPLAY\_MAX\_STEP\_LEVEL}} can be used to control the number of steps displayed. To control the display of the \sphinxstylestrong{Models}, a \sphinxcode{\sphinxupquote{QUAD\_MODEL\_DISPLAY}} and a \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_DISPLAY}} are available. More information on these parameters can be obtained with online documentation: \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/bin/nomad \sphinxhyphen{}h display}}


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{DISPLAY\_STATS}} and \sphinxstyleliteralintitle{\sphinxupquote{STATS\_FILE}}}
\label{\detokenize{HowToUseNomad:display-stats-and-stats-file}}\label{\detokenize{HowToUseNomad:display-stats}}
\sphinxAtStartPar
These parameters display information each time a new feasible incumbent (i.e. a new best solution) is found.  \sphinxcode{\sphinxupquote{DISPLAY\_STATS}} is used to display at the standard output and \sphinxcode{\sphinxupquote{STATS\_FILE}} is used to write into a file.  These parameters need a list of strings as argument, \sphinxstylestrong{without any quotes}.  These strings may include the following keywords:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BBE}}
&
\sphinxAtStartPar
The number of blackbox evaluations
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BBO}}
&
\sphinxAtStartPar
The blackbox outputs
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OBJ}}
&
\sphinxAtStartPar
The objective function value
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SOL}}
&
\sphinxAtStartPar
The current feasible iterate
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
More display options are available. Check the online help: \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/bin/nomad \sphinxhyphen{}h display\_stats}}
\end{sphinxadmonition}

\begin{sphinxShadowBox}
\sphinxstyletopictitle{References}
\end{sphinxShadowBox}


\chapter{Optimization in library mode}
\label{\detokenize{LibraryMode:optimization-in-library-mode}}\label{\detokenize{LibraryMode:library-mode}}\label{\detokenize{LibraryMode::doc}}
\sphinxAtStartPar
The library mode allows to tailor the evaluation of the objectives and constraints within a
specialized executable that calls NOMAD shared object libraries.

\sphinxAtStartPar
For example, it is possible to link your own code with the NOMAD libraries (provided during installation or built)
in a light executable that can define and run optimization for your problem. Contrary to the batch
mode, this has the disadvantage that a crash within the executable (for example during the evaluation of a point)
will end the optimization unless a special treatment of exception is provided by the user.
But, as a counterpart, it offers more options and flexibility for blackbox integration and
optimization management (display, pre\sphinxhyphen{} and post\sphinxhyphen{}processing, multiple optimizations, user search, etc.).

\sphinxAtStartPar
The library mode requires additional coding and compilation before conducting optimization.
First, we will briefly review the compilation of source code to obtain NOMAD binaries
(executable and shared object libraries) and how to use them.
Then, details on how to interface your own code are presented.


\section{Compilation of the source code}
\label{\detokenize{LibraryMode:compilation-of-the-source-code}}
\sphinxAtStartPar
NOMAD source code files are located in \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/src}}.
Examples are provided in \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/basic/library}} and \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/advanced/library}}.

\sphinxAtStartPar
The compilation procedure uses the provided \sphinxcode{\sphinxupquote{CMake}} files along with the source code.

\sphinxAtStartPar
In what follows it is supposed that you have a write access to the source codes directory.
If it is not the case, please consider making a copy in a more convenient location.


\section{Using NOMAD libraries}
\label{\detokenize{LibraryMode:using-nomad-libraries}}
\sphinxAtStartPar
Calling functionalities in NOMAD shared object libraries (so or dll) requires to build a \sphinxcode{\sphinxupquote{C++}} program and link it with the libraries to form an executable
({\hyperref[\detokenize{Installation:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation}}}} describes how to build the libraries and the examples). This is illustrated on the example located in the directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}NOMAD\PYGZus{}HOME/examples/basic/library/example1
\end{sphinxVerbatim}

\sphinxAtStartPar
It is supposed that the environment variable \sphinxcode{\sphinxupquote{NOMAD\_HOME}} is defined and NOMAD shared
object libraries are built. A basic knowledge of object oriented programming with \sphinxcode{\sphinxupquote{C++}} is assumed.
For this example, just one \sphinxcode{\sphinxupquote{C++}} source file is used, but there could be a lot more.


\subsection{Basic example 1}
\label{\detokenize{LibraryMode:basic-example-1}}
\sphinxAtStartPar
Library mode examples are built during the installation procedure. Let us first test the basic example to check that libraries are working fine and accessible:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{} cd \PYGZdl{}NOMAD\PYGZus{}HOME/examples/basic/library/example1
\PYGZgt{} ls
CMakeLists.txt                example1\PYGZus{}lib.cpp        example1\PYGZus{}lib.exe
\PYGZgt{} ./example1\PYGZus{}lib.exe
All variables are granular. MAX\PYGZus{}EVAL is set to 1000000 to prevent algorithm from circling around best solution indefinetely
BBE OBJ
1 \PYGZhy{}28247.525326  (Phase One)
5   \PYGZhy{}398.076167  (Phase One)
47   \PYGZhy{}413.531262
51   \PYGZhy{}490.074916
59   \PYGZhy{}656.349576
60  \PYGZhy{}1192.679165
65  \PYGZhy{}1595.921082
A termination criterion is reached: Maximum number of blackbox evaluations (Eval Global) No more points to evaluate 1000

Best feasible solution:     \PYGZsh{}171 ( 0.9 24.4 2.4 7.8 5.6 10.5 3.8 9.9 2.7 6.5 )        Evaluation OK    f = \PYGZhy{}1595.9210820000000695      h =   0

Best infeasible solution:   \PYGZsh{}66734 ( 0 \PYGZhy{}1.39247e+08 2.57422e+07 \PYGZhy{}6.45581e+06 \PYGZhy{}8.23276e+07 \PYGZhy{}8.42645e+06 7.52545e+07 6.46595e+07 1.91927e+07 3.1608e+07 )       Evaluation OK    f = \PYGZhy{}1999.9964250000000447      h =   0.5625

Blackbox evaluations:        1000
Total model evaluations:     64042
Cache hits:                  205
Total number of evaluations: 1205
\end{sphinxVerbatim}


\subsection{Modify \sphinxstyleliteralintitle{\sphinxupquote{CMake}} files}
\label{\detokenize{LibraryMode:modify-cmake-files}}
\sphinxAtStartPar
As a first task, you can create a \sphinxcode{\sphinxupquote{CMakeLists.txt}} for your source code(s) based on the one for the basic example 1.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{add\PYGZus{}executable}\PYG{p}{(}\PYG{l+s}{example1\PYGZus{}lib.exe} \PYG{l+s}{example1\PYGZus{}lib.cpp} \PYG{p}{)}
\PYG{n+nb}{target\PYGZus{}include\PYGZus{}directories}\PYG{p}{(}\PYG{l+s}{example1\PYGZus{}lib.exe} \PYG{l+s}{PRIVATE} \PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/src}\PYG{p}{)}
\PYG{n+nb}{set\PYGZus{}target\PYGZus{}properties}\PYG{p}{(}\PYG{l+s}{example1\PYGZus{}lib.exe} \PYG{l+s}{PROPERTIES} \PYG{l+s}{INSTALL\PYGZus{}RPATH} \PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYGZcb{}/lib\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{OpenMP\PYGZus{}CXX\PYGZus{}FOUND}\PYG{p}{)}
  \PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries}\PYG{p}{(}\PYG{l+s}{example1\PYGZus{}lib.exe} \PYG{l+s}{PUBLIC} \PYG{l+s}{nomadAlgos} \PYG{l+s}{nomadUtils} \PYG{l+s}{nomadEval} \PYG{l+s}{OpenMP::OpenMP\PYGZus{}CXX}\PYG{p}{)}
\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
  \PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries}\PYG{p}{(}\PYG{l+s}{example1\PYGZus{}lib.exe} \PYG{l+s}{PUBLIC} \PYG{l+s}{nomadAlgos} \PYG{l+s}{nomadUtils} \PYG{l+s}{nomadEval}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} installing executables and libraries}
\PYG{n+nb}{install}\PYG{p}{(}\PYG{l+s}{TARGETS} \PYG{l+s}{example1\PYGZus{}lib.exe}  \PYG{l+s}{RUNTIME} \PYG{l+s}{DESTINATION} \PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}CURRENT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}} \PYG{p}{)}

\PYG{c}{\PYGZsh{} Add a test for this example}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{BUILD\PYGZus{}TESTS} \PYG{l+s}{MATCHES} \PYG{l+s}{ON}\PYG{p}{)}
   \PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS} \PYG{l+s+s2}{\PYGZdq{}    Add example library test 1\PYGZdq{}}\PYG{p}{)}

   \PYG{c}{\PYGZsh{} Can run this test after install}
   \PYG{n+nb}{add\PYGZus{}test}\PYG{p}{(}\PYG{l+s}{NAME} \PYG{l+s}{Example1BasicLib} \PYG{l+s}{COMMAND} \PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}BINARY\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/examples/runExampleTest.sh} \PYG{l+s}{./example1\PYGZus{}lib.exe} \PYG{l+s}{WORKING\PYGZus{}DIRECTORY} \PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}CURRENT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}} \PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you include your problem into the \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples}} directories, you just need to copy
the example \sphinxcode{\sphinxupquote{CMakeLists.txt}} into your own problem directory (for example \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/basic/library/myPb}}),
change the name \sphinxcode{\sphinxupquote{example1\_lib}} with your choice and add the subdirectory into \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/CMakeLists.txt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
add\PYGZus{}subdirectory(\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/basic/library/myPb)
\end{sphinxVerbatim}


\subsection{Modify \sphinxstyleliteralintitle{\sphinxupquote{C++}} files}
\label{\detokenize{LibraryMode:modify-c-files}}
\sphinxAtStartPar
We now describe the other steps required for the creation of the source file (let us use \sphinxcode{\sphinxupquote{example1.cpp}})
which is divided into two parts: a class for the description of the problem, and the main function.

\sphinxAtStartPar
The use of standard \sphinxcode{\sphinxupquote{C++}} types for reals and vectors is of course allowed within your code, but it
is suggested that you use the NOMAD types as much as  possible. For reals, NOMAD uses the class \sphinxcode{\sphinxupquote{NOMAD::Double}},
and for vectors, the classes \sphinxcode{\sphinxupquote{NOMAD::Point}} or \sphinxcode{\sphinxupquote{NOMAD::ArrayOfDouble}}.
A lot of functionalities have been coded for theses classes, which are visible  in files \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/src/Math/*.hpp}}.

\sphinxAtStartPar
The namespace \sphinxcode{\sphinxupquote{NOMAD}} is used for all NOMAD types, and you must type \sphinxcode{\sphinxupquote{NOMAD::}} in front of all types unless you type \sphinxcode{\sphinxupquote{using namespace NOMAD;}}  at the beginning of your program.

\sphinxAtStartPar
Providing the blackbox evaluation of objective and constraints directly in the code avoids
the use of temporary files and system calls by the algorithm. This is achieved by defining a derived
class (let us call it \sphinxcode{\sphinxupquote{My\_Evaluator}}) that inherits from the class \sphinxcode{\sphinxupquote{NOMAD::Evaluator}}.
The blackbox evaluation is programmed in a user\sphinxhyphen{}defined class that will  be automatically called by the algorithm.\}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ \PYGZbs{}file   example1\PYGZus{}lib.cpp}
\PYG{c+cm}{ \PYGZbs{}brief  Library example for nomad}
\PYG{c+cm}{ \PYGZbs{}author Viviane Rochon Montplaisir}
\PYG{c+cm}{ \PYGZbs{}date   2017}
\PYG{c+cm}{ */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}Nomad/nomad.hpp\PYGZdq{}}

\PYG{c+cm}{/*\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/*               The problem              */}
\PYG{c+cm}{/*\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{k}{class} \PYG{n+nc}{My\PYGZus{}Evaluator}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Evaluator}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{    }\PYG{n}{My\PYGZus{}Evaluator}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{EvalParameters}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{evalParams}\PYG{p}{)}
\PYG{+w}{    }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Evaluator}\PYG{p}{(}\PYG{n}{evalParams}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{EvalType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BB}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{o}{\PYGZti{}}\PYG{n}{My\PYGZus{}Evaluator}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{eval\PYGZus{}x}\PYG{p}{(}\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{EvalPoint}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Double}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{hMax}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{countEval}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{k}{override}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{eval\PYGZus{}ok}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// Based on G2.}
\PYG{+w}{        }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Double}\PYG{+w}{ }\PYG{n}{f}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1e+20}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{g1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1e+20}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{g2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1e+20}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Double}\PYG{+w}{ }\PYG{n}{sum1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sum2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sum3}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{prod1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{prod2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{+w}{        }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{k}{try}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{+w}{            }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{sum1}\PYG{+w}{  }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pow}\PYG{p}{(}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{todouble}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{sum2}\PYG{+w}{  }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{sum3}\PYG{+w}{  }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{prod1}\PYG{+w}{ }\PYG{o}{*}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pow}\PYG{p}{(}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{todouble}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{prod2}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{)}
\PYG{+w}{                }\PYG{p}{\PYGZob{}}
\PYG{+w}{                    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{)}
\PYG{+w}{                    }\PYG{p}{\PYGZob{}}
\PYG{+w}{                        }\PYG{n}{prod2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{;}
\PYG{+w}{                    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                    }\PYG{k}{else}
\PYG{+w}{                    }\PYG{p}{\PYGZob{}}
\PYG{+w}{                        }\PYG{n}{prod2}\PYG{+w}{ }\PYG{o}{*}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{                    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}

\PYG{+w}{            }\PYG{n}{g1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{prod2}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mf}{0.75}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{g2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum2}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}7.5}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}

\PYG{+w}{            }\PYG{n}{f}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{g1}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{g2}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum3}\PYG{p}{)}
\PYG{+w}{            }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{f}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n}{sum1}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}2}\PYG{o}{*}\PYG{n}{prod1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{n}{sum3}\PYG{p}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{c+c1}{// Scale}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{f}\PYG{p}{.}\PYG{n}{isDefined}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{            }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{f}\PYG{+w}{ }\PYG{o}{*}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}

\PYG{+w}{            }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Double}\PYG{+w}{ }\PYG{n}{c2000}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{l+m+mi}{\PYGZhy{}2000}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{bbOutputType}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{\PYGZus{}evalParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getAttributeValue}\PYG{o}{\PYGZlt{}}\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BBOutputTypeList}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BB\PYGZus{}OUTPUT\PYGZus{}TYPE}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{bbo}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{g1}\PYG{p}{.}\PYG{n}{tostring}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{bbo}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{g2}\PYG{p}{.}\PYG{n}{tostring}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{bbo}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{.}\PYG{n}{tostring}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{bbo}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{c2000}\PYG{p}{.}\PYG{n}{tostring}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{            }\PYG{n}{x}\PYG{p}{.}\PYG{n}{setBBO}\PYG{p}{(}\PYG{n}{bbo}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{            }\PYG{n}{eval\PYGZus{}ok}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{catch}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exception}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n+nf}{err}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Exception: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{err}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{throw}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{logic\PYGZus{}error}\PYG{p}{(}\PYG{n}{err}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}

\PYG{+w}{        }\PYG{n}{countEval}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{eval\PYGZus{}ok}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The argument \sphinxcode{\sphinxupquote{x}} (in/out in \sphinxcode{\sphinxupquote{eval\_x()}}) corresponds to an evaluation point, i.e. a vector containing the
coordinates of the point to be evaluated, and also the result of the evaluation.
The coordinates are accessed with the operator \sphinxcode{\sphinxupquote{{[}{]}}} (\sphinxcode{\sphinxupquote{x{[}0{]}}} for the first coordinate) and outputs are set with \sphinxcode{\sphinxupquote{x.setBBO(bbo);}}.
The outputs are returned as a string that will be interpreted by NOMAD based on the \sphinxcode{\sphinxupquote{BB\_OUTPUT\_TYPE}} defined by the user.
We recall that constraints must be represented by values \(c_j\) for a constraint \(c_j \leq 0\).

\sphinxAtStartPar
The second argument, the real \sphinxcode{\sphinxupquote{h\_max}} (in), corresponds to the current value of the barrier \(h_{max}\) parameter.
It is not used in this example but it may be used to interrupt an expensive evaluation if the constraint violation value \(h\) grows larger than \(h_{max}\).
See \sphinxcite{Introduction:aude09a} for the definition of \(h\) and \(h_{max}\) and of the \sphinxstyleemphasis{Progressive Barrier} method for handling constraints.

\sphinxAtStartPar
The third argument, \sphinxcode{\sphinxupquote{countEval}} (out), needs to be set to \sphinxcode{\sphinxupquote{true}} if the evaluation counts as a blackbox
evaluation, and \sphinxcode{\sphinxupquote{false}} otherwise (for example, if the user interrupts an evaluation with the \(h_{max}\)
criterion before it costs some expensive computations, then set \sphinxcode{\sphinxupquote{countEval}} to \sphinxcode{\sphinxupquote{false}}).

\sphinxAtStartPar
Finally, note that the call to \sphinxcode{\sphinxupquote{eval\_x()}} inside the NOMAD code  is inserted into a \sphinxcode{\sphinxupquote{try}} block.
This means that if an error is detected inside the \sphinxcode{\sphinxupquote{eval\_x()}} function,  an exception should be thrown.
The choice for the type of this exception is left to the user, but  \sphinxcode{\sphinxupquote{NOMAD::Exception}} is available.
If an exception is thrown by the user\sphinxhyphen{}defined function, then the associated evaluation  is tagged as a failure
and not counted unless the user explicitely set the flag \sphinxcode{\sphinxupquote{countEval}} to \sphinxcode{\sphinxupquote{true}}.


\subsection{Setting parameters}
\label{\detokenize{LibraryMode:setting-parameters}}
\sphinxAtStartPar
Once your problem has been defined, the main function can be written. NOMAD routines may throw \sphinxcode{\sphinxupquote{C++}} exceptions,
so it is recommended that you put your code into a \sphinxcode{\sphinxupquote{try}} block.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/*\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/*            NOMAD main function           */}
\PYG{c+cm}{/*\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{argc}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{+w}{    }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MainStep}\PYG{+w}{ }\PYG{n}{TheMainStep}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{params}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}shared}\PYG{o}{\PYGZlt{}}\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{AllParameters}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{initAllParams}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{TheMainStep}\PYG{p}{.}\PYG{n}{setAllParameters}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{unique\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{My\PYGZus{}Evaluator}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ev}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{My\PYGZus{}Evaluator}\PYG{p}{(}\PYG{n}{params}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getEvalParams}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{TheMainStep}\PYG{p}{.}\PYG{n}{setEvaluator}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{n}{ev}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{try}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{TheMainStep}\PYG{p}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{TheMainStep}\PYG{p}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{TheMainStep}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{catch}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{exception}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{e}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cerr}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{NOMAD has been interrupted (}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{.}\PYG{n}{what}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The execution of NOMAD is controlled by the \sphinxcode{\sphinxupquote{NOMAD::MainStep}} class using the \sphinxcode{\sphinxupquote{start}}, \sphinxcode{\sphinxupquote{run}} and \sphinxcode{\sphinxupquote{end}} functions.
The user defined \sphinxcode{\sphinxupquote{NOMAD::Evaluator}} is set into the \sphinxcode{\sphinxupquote{NOMAD::MainStep}}.

\sphinxAtStartPar
The base evaluator constructor takes an \sphinxcode{\sphinxupquote{NOMAD::EvalParameters}} as input.
The evaluation parameters are included into a \sphinxcode{\sphinxupquote{NOMAD::AllParameters}}.

\sphinxAtStartPar
Hence, in library mode, the main function must declare a \sphinxcode{\sphinxupquote{NOMAD::AllParameters}} object to set all types of parameters.
Parameter names are the same as in batch mode but may be defined programmatically.

\sphinxAtStartPar
A parameter \sphinxcode{\sphinxupquote{PNAME}} is set with the method \sphinxcode{\sphinxupquote{AllParameters::setAttributeValue( "PNAME", PNameValue)}}.
The \sphinxcode{\sphinxupquote{PNameValue}} must be of a type registered for the \sphinxcode{\sphinxupquote{PNAME}} parameter.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
If the \sphinxcode{\sphinxupquote{PNameValue}} has not the type associated to the \sphinxcode{\sphinxupquote{PName}} parameters, the compilation
will succeed but execution will be stopped when setting or getting the value.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
A brief description (including the \sphinxcode{\sphinxupquote{NOMAD::}} type) of all parameters is given {\hyperref[\detokenize{Appendix:appendix-parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Complete list of parameters}}}}.
More information on parameters can be obtained by running \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/bin/nomad \sphinxhyphen{}h KEYWORD}}.
\end{sphinxadmonition}

\sphinxAtStartPar
For the example, the parameters are set in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{initAllParams}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{AllParameters}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{allParams}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// Parameters creation}
\PYG{+w}{    }\PYG{c+c1}{// Number of variables}
\PYG{+w}{    }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAttributeValue}\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DIMENSION}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// The algorithm terminates after}
\PYG{+w}{    }\PYG{c+c1}{// this number of black\PYGZhy{}box evaluations}
\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAttributeValue}\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MAX\PYGZus{}BB\PYGZus{}EVAL}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// Starting point}
\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAttributeValue}\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{X0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Point}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{7.0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getPbParams}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAttributeValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GRANULARITY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ArrayOfDouble}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{0.0000001}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// Constraints and objective}
\PYG{+w}{    }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BBOutputTypeList}\PYG{+w}{ }\PYG{n}{bbOutputTypes}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{bbOutputTypes}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BBOutputType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PB}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{     }\PYG{c+c1}{// g1}
\PYG{+w}{    }\PYG{n}{bbOutputTypes}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BBOutputType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PB}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{     }\PYG{c+c1}{// g2}
\PYG{+w}{    }\PYG{n}{bbOutputTypes}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BBOutputType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{OBJ}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }\PYG{c+c1}{// f}
\PYG{+w}{    }\PYG{n}{bbOutputTypes}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BBOutputType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{EB}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{     }\PYG{c+c1}{// c2000}
\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAttributeValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BB\PYGZus{}OUTPUT\PYGZus{}TYPE}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{bbOutputTypes}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAttributeValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DIRECTION\PYGZus{}TYPE}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NOMAD}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DirectionType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ORTHO\PYGZus{}2N}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAttributeValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DISPLAY\PYGZus{}DEGREE}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAttributeValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DISPLAY\PYGZus{}ALL\PYGZus{}EVAL}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAttributeValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DISPLAY\PYGZus{}UNSUCCESSFUL}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getRunParams}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAttributeValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HOT\PYGZus{}RESTART\PYGZus{}READ\PYGZus{}FILES}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getRunParams}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAttributeValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HOT\PYGZus{}RESTART\PYGZus{}WRITE\PYGZus{}FILES}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}


\PYG{+w}{    }\PYG{c+c1}{// Parameters validation}
\PYG{+w}{    }\PYG{n}{allParams}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{checkAndComply}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{checkAndComply}} function must be called to ensure that parameters are compatible.
Otherwise an exception is triggered.


\subsection{Access to solution and optimization data}
\label{\detokenize{LibraryMode:access-to-solution-and-optimization-data}}
\sphinxAtStartPar
In the basic example 1, final information is displayed at the end of an algorithm. More specialized access to solution and optimization data is allowed.

\sphinxAtStartPar
To access the best feasible and infeasible points, use

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NOMAD::CacheBase::getInstance()\sphinxhyphen{}\textgreater{}findBestFeas(bf, NOMAD::Point(n), NOMAD::EvalType::BB,NOMAD::ComputeType::STANDARD, nullptr);}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NOMAD::CacheBase::getInstance()\sphinxhyphen{}\textgreater{}findBestInf(bi, NOMAD::INF, NOMAD::Point(n), NOMAD::EvalType::BB, NOMAD::ComputeType::STANDARD,nullptr);}}

\sphinxAtStartPar
** More stats will be available in future version. **


\chapter{Matlab interface}
\label{\detokenize{LibraryMode:matlab-interface}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Building the Matlab MEX interface requires compatibility of the versions of Matlab and the compiler. Check the compatibility at \sphinxhref{https://www.mathworks.com/support/requirements/supported-compilers.html}{MathWorks}.
\end{sphinxadmonition}

\sphinxAtStartPar
The Matlab MEX interface allows to run NOMAD within the command line of Matlab.
Some examples and source codes are provided in \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/interface/Matlab\_MEX}}.
To enable the building of the interface, option \sphinxcode{\sphinxupquote{\sphinxhyphen{}DBUILD\_INTERFACE\_MATLAB=ON}} must be
set when configuring for building NOMAD, as such: \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}DTEST\_OPENMP=OFF \sphinxhyphen{}DBUILD\_INTERFACE\_MATLAB=ON \sphinxhyphen{}S . \sphinxhyphen{}B build/release}}.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Building the Matlab MEX interface is disabled when NOMAD uses OpenMP. Hence, the option \sphinxcode{\sphinxupquote{\sphinxhyphen{}DTEST\_OPENMP=OFF}} must be passed during configuration.
\end{sphinxadmonition}

\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}\sphinxhyphen{}build build/release}} (or \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}\sphinxhyphen{}build build/release \sphinxhyphen{}\sphinxhyphen{}config Release}} for Windows) is used for building the selected configuration.
The command \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}\sphinxhyphen{}install build/release}} must be run before using the Matlab \sphinxcode{\sphinxupquote{nomadOpt}} function. Also,
the Matlab command \sphinxcode{\sphinxupquote{addpath(strcat(getenv(\textquotesingle{}NOMAD\_HOME\textquotesingle{}),\textquotesingle{}/build/release/lib\textquotesingle{}))}} or \sphinxcode{\sphinxupquote{addpath(strcat(getenv(\textquotesingle{}NOMAD\_HOME\textquotesingle{}),\textquotesingle{}/build/release/lib64\textquotesingle{}))}} must be executed to have access to the libraries and run the examples.

\sphinxAtStartPar
All functionalities of NOMAD are available in \sphinxcode{\sphinxupquote{nomadOpt}}.
NOMAD parameters are provided in a Matlab structure with keywords and values using the same syntax as used in the NOMAD parameter
files. For example, \sphinxcode{\sphinxupquote{params = struct(\textquotesingle{}initial\_mesh\_size\textquotesingle{},\textquotesingle{}* 10\textquotesingle{},\textquotesingle{}MAX\_BB\_EVAL\textquotesingle{},\textquotesingle{}100\textquotesingle{});}}


\chapter{PyNomad interface}
\label{\detokenize{LibraryMode:pynomad-interface}}
\sphinxAtStartPar
A Python interface for NOMAD called PyNomad can be obtained by building source codes.
Some examples and source codes are provided in \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/interfaces/PyNomad}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The build procedure relies on Python 3.6 and Cython 0.24 or higher. A simple way to make it work is to first install the \sphinxhref{http://www.anaconda.org/}{Anaconda} package.
\end{sphinxadmonition}

\sphinxAtStartPar
To enable the building of the Python interface, option \sphinxcode{\sphinxupquote{\sphinxhyphen{}DBUILD\_INTERFACE\_PYTHON=ON}} must be
set when configuring for building NOMAD. The configuration command \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}DBUILD\_INTERFACE\_PYTHON=ON \sphinxhyphen{}S . \sphinxhyphen{}B build/release}} must be performed within a Conda environment with Cython available (\sphinxcode{\sphinxupquote{conda activate ...}} or \sphinxcode{\sphinxupquote{activate ...}}).

\sphinxAtStartPar
For Windows, the default Anaconda is Win64. Visual Studio can support both Win32 and Win64 compilations.
The configuration must be forced to use Win64 with a command such as \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}DBUILD\_INTERFACE\_PYTHON=ON \sphinxhyphen{}S . \sphinxhyphen{}B build/release \sphinxhyphen{}G"Visual Studio 15 2017 Win64"}}.
The Visual Studio version must be adapted.

\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}\sphinxhyphen{}build build/release}} (or \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}\sphinxhyphen{}build build/release \sphinxhyphen{}\sphinxhyphen{}config Release}} for Windows) is used for building the selected configuration.

\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}\sphinxhyphen{}install build/release}} must be run before using the PyNomad module.

\sphinxAtStartPar
All functionalities of NOMAD are available in PyNomad.
NOMAD parameters are provided in a list of strings using the same syntax as used in the NOMAD parameter
files.
Several tests and examples are proposed in the \sphinxcode{\sphinxupquote{PyNomad}} directory to check that everything is up and
running.


\chapter{C interface}
\label{\detokenize{LibraryMode:c-interface}}
\sphinxAtStartPar
A C interface for NOMAD is available.
The source codes are provided in \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/interfaces/CInterface/}}.
To enable the building of the C interface, option \sphinxcode{\sphinxupquote{\sphinxhyphen{}DBUILD\_INTERFACE\_C=ON}} must be
set when building NOMAD, as such: \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}DBUILD\_TESTS=ON \sphinxhyphen{}S . \sphinxhyphen{}B build/release}}.

\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}\sphinxhyphen{}build build/release}} (or \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}\sphinxhyphen{}build build/release \sphinxhyphen{}\sphinxhyphen{}config Release}} for Windows) is used for building the selected configuration.

\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}\sphinxhyphen{}install build/release}} must be run before using the library.

\sphinxAtStartPar
All functionalities of NOMAD are available in the C interface.
NOMAD parameters are provided via these functions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{addNomadParam}\PYG{p}{(}\PYG{n}{NomadProblem}\PYG{+w}{ }\PYG{n}{nomad\PYGZus{}problem}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{keyword\PYGZus{}value\PYGZus{}pair}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{addNomadValParam}\PYG{p}{(}\PYG{n}{NomadProblem}\PYG{+w}{ }\PYG{n}{nomad\PYGZus{}problem}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{keyword}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{addNomadBoolParam}\PYG{p}{(}\PYG{n}{NomadProblem}\PYG{+w}{ }\PYG{n}{nomad\PYGZus{}problem}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{keyword}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{addNomadStringParam}\PYG{p}{(}\PYG{n}{NomadProblem}\PYG{+w}{ }\PYG{n}{nomad\PYGZus{}problem}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{keyword}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{param\PYGZus{}str}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{addNomadArrayOfDoubleParam}\PYG{p}{(}\PYG{n}{NomadProblem}\PYG{+w}{ }\PYG{n}{nomad\PYGZus{}problem}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{keyword}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{array\PYGZus{}param}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
See examples that are proposed in the \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/advanced/library/c\_api}} directory.


\chapter{Tricks of the trade}
\label{\detokenize{TricksOfTheTrade:tricks-of-the-trade}}\label{\detokenize{TricksOfTheTrade:id1}}\label{\detokenize{TricksOfTheTrade::doc}}
\sphinxAtStartPar
NOMAD has default values for all algorithmic parameters. These values represent a compromise between robustness and performance obtained by developers on sets of problems used for benchmarking. But you might want to improve NOMAD performance for your problem by tuning the parameters or use advanced functionalities. The following sections provide tricks that may work for you.

\sphinxAtStartPar
Here are a few suggestions for tuning NOMAD when facing different symptoms. The suggestions can be tested one by one or all together.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Suggestions for tuning NOMAD}\label{\detokenize{TricksOfTheTrade:id2}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{20}{47}|\X{7}{47}|\X{20}{47}|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Symptom
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Suggestion
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Ref.
\\
\hline
\sphinxAtStartPar
I want to see more display
&
\sphinxAtStartPar
Increase display degree
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:display-degree}]{\sphinxcrossref{\DUrole{std,std-ref}{DISPLAY\_DEGREE}}}}
\\
\hline
\sphinxAtStartPar
Quantifiable constraints
&
\sphinxAtStartPar
Try PB  EB or combinations
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:bb-output-type}]{\sphinxcrossref{\DUrole{std,std-ref}{BB\_OUTPUT\_TYPE}}}}
\\
\hline
\sphinxAtStartPar
Difficult constraint
&
\sphinxAtStartPar
Try PB instead of EB
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:bb-output-type}]{\sphinxcrossref{\DUrole{std,std-ref}{BB\_OUTPUT\_TYPE}}}}
\\
\hline
\sphinxAtStartPar
No initial point
&
\sphinxAtStartPar
Add a LH search
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:x0}]{\sphinxcrossref{\DUrole{std,std-ref}{LH Search and X0}}}}
\\
\hline
\sphinxAtStartPar
Variables of different magnitudes
&
\sphinxAtStartPar
Change blackbox input scaling
&
\sphinxAtStartPar
{\hyperref[\detokenize{GettingStarted:create-blackbox-program}]{\sphinxcrossref{\DUrole{std,std-ref}{Create blackbox programs}}}}
\\
\hline&
\sphinxAtStartPar
Change \(\Delta_0\) per variable
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:initial-mesh-size}]{\sphinxcrossref{\DUrole{std,std-ref}{INITIAL\_MESH\_SIZE and INITIAL\_FRAME\_SIZE}}}}
\\
\hline&
\sphinxAtStartPar
Tighten bounds
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:bounds}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWER\_BOUND and UPPER\_BOUND}}}}
\\
\hline
\sphinxAtStartPar
Many variables
&
\sphinxAtStartPar
Fix some variables
&
\sphinxAtStartPar
{\hyperref[\detokenize{AdvancedFunctionalities:fixed-variable}]{\sphinxcrossref{\DUrole{std,std-ref}{FIXED\_VARIABLE}}}}
\\
\hline&
\sphinxAtStartPar
Use \sphinxstyleemphasis{PSD\sphinxhyphen{}MADS}
&
\sphinxAtStartPar
{\hyperref[\detokenize{AdvancedFunctionalities:psd-mads}]{\sphinxcrossref{\DUrole{std,std-ref}{PSD\sphinxhyphen{}Mads}}}}
\\
\hline
\sphinxAtStartPar
Unsatisfactory solution
&
\sphinxAtStartPar
Change direction type to \sphinxcode{\sphinxupquote{2N}} or \sphinxcode{\sphinxupquote{N+1 UNI}} or \sphinxcode{\sphinxupquote{N+1 NEG}}
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:direction-type}]{\sphinxcrossref{\DUrole{std,std-ref}{DIRECTION\_TYPE}}}}
\\
\hline&
\sphinxAtStartPar
Change initial point
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:x0}]{\sphinxcrossref{\DUrole{std,std-ref}{LH Search and X0}}}}
\\
\hline&
\sphinxAtStartPar
Add a LH search
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:x0}]{\sphinxcrossref{\DUrole{std,std-ref}{LH Search and X0}}}}
\\
\hline&
\sphinxAtStartPar
Add a VNS Mads search
&
\sphinxAtStartPar
{\hyperref[\detokenize{AdvancedFunctionalities:vns-search}]{\sphinxcrossref{\DUrole{std,std-ref}{VNS Mads Search}}}}
\\
\hline&
\sphinxAtStartPar
Tighten bounds
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:bounds}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWER\_BOUND and UPPER\_BOUND}}}}
\\
\hline&
\sphinxAtStartPar
Change \(\Delta_0\)
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:initial-mesh-size}]{\sphinxcrossref{\DUrole{std,std-ref}{INITIAL\_MESH\_SIZE and INITIAL\_FRAME\_SIZE}}}}
\\
\hline&
\sphinxAtStartPar
Modify seeds that affect algorithms
&
\sphinxAtStartPar
{\hyperref[\detokenize{AdvancedFunctionalities:seed}]{\sphinxcrossref{\DUrole{std,std-ref}{SEED}}}}
\\
\hline&
\sphinxAtStartPar
Disable quadratic models
&
\sphinxAtStartPar
set \sphinxcode{\sphinxupquote{QUAD\_MODEL\_SEARCH no}}
\\
\hline&
\sphinxAtStartPar
Unable \sphinxstyleemphasis{SGTELIB} models
&
\sphinxAtStartPar
set \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_SEARCH yes}}
\\
\hline&
\sphinxAtStartPar
Disable opportunistic evaluations
&
\sphinxAtStartPar
set \sphinxcode{\sphinxupquote{EVAL\_OPPORTUNISTIC no}}
\\
\hline&
\sphinxAtStartPar
Disable anisotropic mesh
&
\sphinxAtStartPar
set \sphinxcode{\sphinxupquote{ANISOTROPIC\_MESH no}}
\\
\hline&
\sphinxAtStartPar
Change anisotropy factor
&
\sphinxAtStartPar
set \sphinxcode{\sphinxupquote{ANISOTROPY\_FACTOR 0.05}}
\\
\hline
\sphinxAtStartPar
Improvements get negligible
&
\sphinxAtStartPar
Change stopping criteria
&
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{nomad \sphinxhyphen{}h stop}}
\\
\hline&
\sphinxAtStartPar
Disable quadratic models
&
\sphinxAtStartPar
set \sphinxcode{\sphinxupquote{QUAD\_MODEL\_SEARCH no}}
\\
\hline
\sphinxAtStartPar
It takes long to improve \(f\)
&
\sphinxAtStartPar
Decrease \(\Delta_0\)
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:initial-mesh-size}]{\sphinxcrossref{\DUrole{std,std-ref}{INITIAL\_MESH\_SIZE and INITIAL\_FRAME\_SIZE}}}}
\\
\hline
\sphinxAtStartPar
Optimization is time consuming
&
\sphinxAtStartPar
Perform parallel blackbox evaluations
&
\sphinxAtStartPar
{\hyperref[\detokenize{AdvancedFunctionalities:block-evaluations}]{\sphinxcrossref{\DUrole{std,std-ref}{Blackbox evaluation of a block of trial points}}}} and {\hyperref[\detokenize{AdvancedFunctionalities:parallel-evaluations}]{\sphinxcrossref{\DUrole{std,std-ref}{Parallel evaluations}}}}
\\
\hline
\sphinxAtStartPar
Blackbox is not that expensive
&
\sphinxAtStartPar
Setup maximum wall\sphinxhyphen{}clock time
&
\sphinxAtStartPar
remove \sphinxcode{\sphinxupquote{MAX\_BB\_EVAL}} and set \sphinxcode{\sphinxupquote{MAX\_TIME}}
\\
\hline&
\sphinxAtStartPar
Add a LH search
&
\sphinxAtStartPar
{\hyperref[\detokenize{HowToUseNomad:x0}]{\sphinxcrossref{\DUrole{std,std-ref}{LH Search and X0}}}}
\\
\hline&
\sphinxAtStartPar
Add a VNS Mads search
&
\sphinxAtStartPar
{\hyperref[\detokenize{AdvancedFunctionalities:vns-search}]{\sphinxcrossref{\DUrole{std,std-ref}{VNS Mads Search}}}}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\chapter{Advanced functionalities}
\label{\detokenize{AdvancedFunctionalities:advanced-functionalities}}\label{\detokenize{AdvancedFunctionalities:id1}}\label{\detokenize{AdvancedFunctionalities::doc}}

\section{Advanced parameters}
\label{\detokenize{AdvancedFunctionalities:advanced-parameters}}
\sphinxAtStartPar
Advanced parameters are intended to setup optimization problems, algorithmic and output parameters when specific needs are present.
Only a few advanced parameters are presented below; all advanced parameters can be obtained with \sphinxcode{\sphinxupquote{\$NOMAD\_HOME \sphinxhyphen{}h advanced}}.
Also a complete list of parameters and a short description is available in {\hyperref[\detokenize{Appendix:appendix-parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{Complete list of parameters}}}}.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{EVAL\_QUEUE\_SORT}}}
\label{\detokenize{AdvancedFunctionalities:eval-queue-sort}}\label{\detokenize{AdvancedFunctionalities:id2}}
\sphinxAtStartPar
Allows ordering of points before evaluation. This option has an effect only if the opportunistic strategy is enabled (parameter {\hyperref[\detokenize{AdvancedFunctionalities:eval-opportunistic}]{\sphinxcrossref{\DUrole{std,std-ref}{EVAL\_OPPORTUNISTIC}}}}). The possible arguments are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{QUADRATIC\_MODEL}}: Sort points using values given by dynamic quadratic models.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DIR\_LAST\_SUCCESS}}: Points that are generated in a direction similar to the last direction that provided a successful point are evaluated first.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LEXICOGRAPHICAL}}: Points are sorted in lexicographical order before evaluation.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RANDOM}}: Mix points randomly before evaluation, instead of sorting them.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SURROGATE}}: Sort points using values given by static surrogate. See parameter {\hyperref[\detokenize{AdvancedFunctionalities:surrogate-exe}]{\sphinxcrossref{\DUrole{std,std-ref}{SURROGATE\_EXE}}}}.

\end{itemize}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{FIXED\_VARIABLE}}}
\label{\detokenize{AdvancedFunctionalities:fixed-variable}}\label{\detokenize{AdvancedFunctionalities:id3}}
\sphinxAtStartPar
This parameter is used to fix some variables to a value.
This value is optional if at least one starting point is defined.
The parameter may be entered with several types of arguments:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A vector of \(n\) values with format \sphinxcode{\sphinxupquote{(v0 v1 ... vn\sphinxhyphen{}1)}}. Character \sphinxcode{\sphinxupquote{\sphinxhyphen{}}} is used for free variables.

\item {} 
\sphinxAtStartPar
An index range if at least one starting point has been defined. \sphinxcode{\sphinxupquote{FIXED\_VARIABLE i\sphinxhyphen{}j}}: variables \sphinxcode{\sphinxupquote{i}} to \sphinxcode{\sphinxupquote{j}}
are fixed to their initial (\sphinxcode{\sphinxupquote{i\sphinxhyphen{}j}} may be replaced by \sphinxcode{\sphinxupquote{i}} only). See {\hyperref[\detokenize{HowToUseNomad:x0}]{\sphinxcrossref{\DUrole{std,std-ref}{X0}}}} for practical examples of index ranges.

\end{itemize}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{SEED}}}
\label{\detokenize{AdvancedFunctionalities:seed}}\label{\detokenize{AdvancedFunctionalities:id4}}
\sphinxAtStartPar
The directions that NOMAD explores during the \sphinxstyleemphasis{Poll} phase are dependent upon the seed.
The seed is used to generate a pseudo\sphinxhyphen{}random direction on a unit n\sphinxhyphen{}dimensional sphere.
The user can change the sequence of directions by setting \sphinxcode{\sphinxupquote{SEED}} to a positive integer or \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}. If \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}} or \sphinxcode{\sphinxupquote{DIFF}} is entered the seed is different for each run (PID is used).

\sphinxAtStartPar
Other aspects of NOMAD may depend on a pseudo\sphinxhyphen{}random sequence of numbers depending on selected options: \sphinxstyleemphasis{LH Search} and \sphinxstyleemphasis{PSD Mads}.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{EVAL\_OPPORTUNISTIC}}}
\label{\detokenize{AdvancedFunctionalities:eval-opportunistic}}\label{\detokenize{AdvancedFunctionalities:id5}}
\sphinxAtStartPar
The opportunistic strategy consists in terminating the evaluations of a list of trial points at a given step of the algorithm as soon as an improved value is found.

\sphinxAtStartPar
This strategy is decided with the parameter \sphinxcode{\sphinxupquote{EVAL\_OPPORTUNISTIC}} and applies to both the \sphinxstyleemphasis{Poll} and \sphinxstyleemphasis{Search} steps.
Search with NOMAD help \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/bin/nomad \sphinxhyphen{}h OPPORTUNISTIC}} for more options.

\sphinxAtStartPar
When evaluations are performed by blocks (see {\hyperref[\detokenize{AdvancedFunctionalities:block-evaluations}]{\sphinxcrossref{\DUrole{std,std-ref}{Blackbox evaluation of a block of trial points}}}}) the opportunistic strategy applies after evaluating a block of trial points.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{VARIABLE\_GROUP}}}
\label{\detokenize{AdvancedFunctionalities:variable-group}}\label{\detokenize{AdvancedFunctionalities:id6}}
\sphinxAtStartPar
By default NOMAD creates one group that combines all continuous, integer, and binary variables.

\sphinxAtStartPar
In batch mode, the \sphinxcode{\sphinxupquote{VARIABLE\_GROUP}} parameter followed by variable indices is used to explicitly form a group of variables.
Each group of variable generates its own polling directions. The parameter may be entered several times to define more than one group of variables.
Variables in a group may be of different types.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{QUAD\_MODEL\_SEARCH}} and \sphinxstyleliteralintitle{\sphinxupquote{SGTELIB\_MODEL\_SEARCH}}}
\label{\detokenize{AdvancedFunctionalities:quad-model-search-and-sgtelib-model-search}}\label{\detokenize{AdvancedFunctionalities:quad-model-search}}
\sphinxAtStartPar
The \sphinxstyleemphasis{Search} phase of the \sphinxstyleemphasis{MADS} algorithm can use models of the objectives and constraints that are constructed dynamically from all the evaluations made.
By default, a quadratic model is used to propose new points to be evaluated with the blackbox.
To disable the use of quadratic models, the parameter \sphinxcode{\sphinxupquote{QUAD\_MODEL\_SEARCH}} can be set to \sphinxcode{\sphinxupquote{no}}.

\sphinxAtStartPar
Models from the \sphinxstyleemphasis{SGTELIB} library can be used by setting \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_SEARCH}} to \sphinxcode{\sphinxupquote{yes}}.
Many parameters are available to control \sphinxstyleemphasis{SGTELIB} models: \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/bin/nomad \sphinxhyphen{}h SGTELIB}}, or see {\hyperref[\detokenize{SgteLib:sgtelib}]{\sphinxcrossref{\DUrole{std,std-ref}{Surrogate Library}}}}.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{VNS\_MADS\_SEARCH}}}
\label{\detokenize{AdvancedFunctionalities:vns-mads-search}}\label{\detokenize{AdvancedFunctionalities:vns-search}}
\sphinxAtStartPar
The \sphinxstyleemphasis{Variable Neighborhood Search (VNS)} is a strategy to escape local minima.

\sphinxAtStartPar
The VNS Mads search strategy is described in \sphinxcite{AdvancedFunctionalities:aubele08b}. It is based on the Variable Neighborhood Search metaheuristic \sphinxcite{AdvancedFunctionalities:mlha97a} and \sphinxcite{AdvancedFunctionalities:haml01a}.

\sphinxAtStartPar
VNS Mads should only be used for problems with several such local optima. It will cost some additional evaluations, since each search performs another MADS run from a perturbed starting point. Currently, the VNS Mads search will not use a surrogate if it is provided. This feature will be available in the future.

\sphinxAtStartPar
In NOMAD, the VNS Mads search strategy is not activated by default. In order to use the VNS Mads search, the user has to define the parameter \sphinxcode{\sphinxupquote{VNS\_MADS\_SEARCH}}, with a boolean. The maximum desired ratio of VNS Mads blackbox evaluations over the total number of blackbox evaluations is specified with the real value parameter \sphinxcode{\sphinxupquote{VNS\_MADS\_SEARCH\_TRIGGER}}. For example, a value of 0.75 means that  NOMAD will try to perform a maximum of 75\% blackbox evaluations  within the VNS Mads search. The default trigger ratio is 0.75.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{GRANULARITY}}}
\label{\detokenize{AdvancedFunctionalities:granularity}}\label{\detokenize{AdvancedFunctionalities:id10}}
\sphinxAtStartPar
The \sphinxstyleemphasis{MADS} algorithm handles granular variables, i.e. variables with a controlled number of decimals.
For real numbers the granularity is 0. For integers and binary variables the granularity is automatically set to one.

\sphinxAtStartPar
The possible syntaxes to specify the granularity of the variables are as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(n\) real values with format \sphinxcode{\sphinxupquote{GRANULARITY (v0 v1 ... vn\sphinxhyphen{}1)}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GRANULARITY i\sphinxhyphen{}j v}}: coordinates  \sphinxcode{\sphinxupquote{i}} to  \sphinxcode{\sphinxupquote{j}} set to \sphinxcode{\sphinxupquote{v}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GRANULARITY * v}}: all coordinates set to \sphinxcode{\sphinxupquote{v}}.

\end{itemize}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{SURROGATE\_EXE}}}
\label{\detokenize{AdvancedFunctionalities:surrogate-exe}}\label{\detokenize{AdvancedFunctionalities:id11}}
\sphinxAtStartPar
Static surrogate executable.

\sphinxAtStartPar
A static surrogate, or static surrogate function, is a cheaper blackbox function that is used, at least partially, to drive the optimization.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{surrogate}.png}
\caption{Blackbox optimization using a surrogate}\label{\detokenize{AdvancedFunctionalities:id18}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The static surrogate is provided by the user.
\end{sphinxadmonition}

\sphinxAtStartPar
The current version of NOMAD can use a static surrogate, provided by the user, which is not updated during the algorithm. See \sphinxcite{AdvancedFunctionalities:bodefrsetotr99a} for a survey on surrogate optimization, and \sphinxcite{AdvancedFunctionalities:aucm2019} about using static surrogate evaluations. This surrogate may be used for sorting points before evaluation. This sorting strategy is obtained by setting the parameter {\hyperref[\detokenize{AdvancedFunctionalities:eval-queue-sort}]{\sphinxcrossref{\DUrole{std,std-ref}{EVAL\_QUEUE\_SORT}}}} to \sphinxcode{\sphinxupquote{SURROGATE}}.

\sphinxAtStartPar
In batch mode, the parameter \sphinxcode{\sphinxupquote{SURROGATE\_EXE}} associates a static surrogate executable with the blackbox executable given by parameter \sphinxcode{\sphinxupquote{BB\_EXE}}. The surrogate must display the same input and output types as its associated blackbox, given by parameters \sphinxcode{\sphinxupquote{BB\_INPUT\_TYPE}} and \sphinxcode{\sphinxupquote{BB\_OUTPUT\_TYPE}}. In library mode, if a surrogate function is to be used, then its Evaluator should be of type \sphinxcode{\sphinxupquote{EvalType::SURROGATE}} (see Section {\hyperref[\detokenize{LibraryMode:library-mode}]{\sphinxcrossref{\DUrole{std,std-ref}{Optimization in library mode}}}}).


\section{Blackbox evaluation of a block of trial points}
\label{\detokenize{AdvancedFunctionalities:blackbox-evaluation-of-a-block-of-trial-points}}\label{\detokenize{AdvancedFunctionalities:block-evaluations}}
\sphinxAtStartPar
At different phases of the MADS algorithm, different numbers of trial points are generated.
For example, having selected the direction type as ORTHO 2N, the maximum number of points generated during
the Poll step will be 2N+2. These points can be partitioned into blocks of trial points to be
submitted sequentially for evaluation to a blackbox program. The maximum size of a block of
evaluations is controlled by the BB\_MAX\_BLOCK\_SIZE. By default, a block contains a single trial
point. This can be changed by the user but the blackbox program must support the evaluation
of a varying number of trial points, up to BB\_MAX\_BLOCK\_SIZE.

\sphinxAtStartPar
Due to the strategy of by\sphinxhyphen{}block evaluation, the maximum number of evaluations requested to
NOMAD may be exceeded if BB\_MAX\_BLOCK\_SIZE \textgreater{} 1. The reason for this behaviour is that
block results are analyzed only after completion and the maximum number of evaluations may
be exceeded when checking this termination criterion.
The opportunistic strategy (enabled by default) may apply after each block of trial points.
Evaluations of blocks of trial points can be performed in parallel by the blackbox program. This
strategy of parallelization must be setup by the user within the blackbox. Examples are provided
in what follows.


\subsection{Batch mode}
\label{\detokenize{AdvancedFunctionalities:batch-mode}}
\sphinxAtStartPar
In batch mode, NOMAD creates input files which can contain at most
BB\_MAX\_BLOCK\_SIZE trial points separated by a linebreak. Each point is given as a row of values.
The user must provide a blackbox program that can read the input file, evaluate them and
output the objective and constraints functions (in the order provided by the BB\_OUTPUT\_TYPE
parameter) for each trial point in the same order as provided in the input file.
A blackbox program may fail to evaluate some of the trial points. When block of trial points is
submitted the content of the output file must reflect the outputs for each point.
If one value provided in the output file
cannot be read by NOMAD, then the corresponding trial point is considered as having failed.
The trial points that have failed will not be evaluated again.
An example of blackbox program written is provided in the
directory \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/basic/batch/single\_obj\_parallel}}.
The executable \sphinxcode{\sphinxupquote{bb3.exe}} evaluates up to 4 trial points in parallel.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{} cd \PYGZdl{}NOMAD\PYGZus{}HOME/examples/basic/batch/single\PYGZus{}obj\PYGZus{}parallel
\PYGZgt{} more x.txt
1 2 3 4 5
0 0 0 0 0
2 2 2 2 2
5 4 3 2 1
\PYGZgt{} bb3.exe x.txt
5 5 \PYGZhy{}65
0 \PYGZhy{}20 20
2 \PYGZhy{}20 \PYGZhy{}20
1 5 \PYGZhy{}65
\end{sphinxVerbatim}

\sphinxAtStartPar
The same directory holds the parameter file that specifies this blackbox program with blocks of 4 trial points:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DIMENSION}      \PYG{l+m+mi}{5}              \PYG{c+c1}{\PYGZsh{} number of variables}

\PYG{n}{BB\PYGZus{}EXE} \PYG{n}{bb3}\PYG{o}{.}\PYG{n}{exe}
\PYG{n}{BB\PYGZus{}MAX\PYGZus{}BLOCK\PYGZus{}SIZE} \PYG{l+m+mi}{4}

\PYG{n}{BB\PYGZus{}OUTPUT\PYGZus{}TYPE} \PYG{n}{OBJ} \PYG{n}{PB} \PYG{n}{EB}

\PYG{n}{X0}             \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} starting point}

\PYG{n}{LOWER\PYGZus{}BOUND}    \PYG{o}{*} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0}         \PYG{c+c1}{\PYGZsh{} all variables are \PYGZgt{}= \PYGZhy{}6}
\PYG{n}{UPPER\PYGZus{}BOUND}    \PYG{p}{(} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{o}{\PYGZhy{}} \PYG{o}{\PYGZhy{}} \PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} x\PYGZus{}1 \PYGZlt{}= 5, x\PYGZus{}2 \PYGZlt{}= 6, x\PYGZus{}3 \PYGZlt{}= 7}
                              \PYG{c+c1}{\PYGZsh{} x\PYGZus{}4 and x\PYGZus{}5 have no bounds}

\PYG{n}{MAX\PYGZus{}BLOCK\PYGZus{}EVAL}     \PYG{l+m+mi}{20}         \PYG{c+c1}{\PYGZsh{} the algorithm terminates when}
                              \PYG{c+c1}{\PYGZsh{} 20 blocks have been evaluated}

\PYG{n}{TMP\PYGZus{}DIR} \PYG{o}{/}\PYG{n}{tmp}
\PYG{n}{DISPLAY\PYGZus{}DEGREE} \PYG{l+m+mi}{2}
\PYG{n}{DISPLAY\PYGZus{}STATS} \PYG{n}{BLK\PYGZus{}EVA} \PYG{n}{BLK\PYGZus{}SIZE} \PYG{n}{OBJ}
\PYG{n}{DISPLAY\PYGZus{}ALL\PYGZus{}EVAL} \PYG{n}{true}
\end{sphinxVerbatim}

\sphinxAtStartPar
When evaluations are performed by blocks, i.e., when \sphinxcode{\sphinxupquote{BB\_MAX\_BLOCK\_SIZE}} is greater
than one, the opportunistic strategy applies after evaluating a block of trial points.


\subsection{Library mode}
\label{\detokenize{AdvancedFunctionalities:library-mode}}
\sphinxAtStartPar
Please refer to \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/basic/library/single\_obj\_parallel}} for an example
on how to manage a block of evaluations in parallel using OpenMP.


\section{Parallel evaluations}
\label{\detokenize{AdvancedFunctionalities:parallel-evaluations}}\label{\detokenize{AdvancedFunctionalities:id14}}
\sphinxAtStartPar
When OpenMP is available (see {\hyperref[\detokenize{Installation:cmake-configuration}]{\sphinxcrossref{\DUrole{std,std-ref}{Use OpenMP}}}}), the user may provide the number of threads \sphinxcode{\sphinxupquote{NB\_THREADS\_OPENMP}}
to efficiently access the computer cores. If this parameter is not set, OpenMP computes
the number of available threads. The evaluations of trial points are dispatched to these threads.


\section{PSD\sphinxhyphen{}Mads}
\label{\detokenize{AdvancedFunctionalities:psd-mads}}\label{\detokenize{AdvancedFunctionalities:id15}}
\sphinxAtStartPar
The PSD\sphinxhyphen{}MADS method implements a parallel space decomposition of MADS and is
described in \sphinxcite{AdvancedFunctionalities:audele07}. The method aims at solving larger problems than the scalar version of
NOMAD.
NOMAD is in general efficient for problems with up to about 20 variables, PSD\sphinxhyphen{}MADS has
solved problems with up to 500 variables.
In PSD\sphinxhyphen{}MADS, each worker process has the responsibility for a small number of variables on
which a MADS algorithm is performed. These subproblems are decided by the PSD\sphinxhyphen{}MADS algorithm.
These groups of variables
are chosen randomly, without any specific strategy.
A special worker, called the pollster,
works on all the variables, but with a reduced number of directions. The pollster ensures the
convergence of the algorithm.
Concerning other aspects, the algorithm given here is similar to the program PSD\sphinxhyphen{}MADS given
with NOMAD 3.

\sphinxAtStartPar
The management of parallel processes is done using OpenMP.
To use PSD\sphinxhyphen{}MADS, set parameter \sphinxcode{\sphinxupquote{PSD\_MADS\_OPTIMIZATION}} to \sphinxcode{\sphinxupquote{true}}.
Thread 0 is used for the pollster.
The next \sphinxcode{\sphinxupquote{PSD\_MADS\_NB\_SUBPROBLEM}} threads are used for subproblems. If this parameter is not
set, it is computed using \sphinxcode{\sphinxupquote{PSD\_MADS\_NB\_VAR\_IN\_SUBPROBLEM}}.
Remaining available threads are not used for algorithmic management or point generation,
only for point evaluation.
An example of usage of PSD\sphinxhyphen{}MADS in library mode is in
\sphinxcode{\sphinxupquote{\$NOMAD\_HOME/examples/advanced/library/PSDMads}}.


\section{Hot and Warm Restart}
\label{\detokenize{AdvancedFunctionalities:hot-and-warm-restart}}\label{\detokenize{AdvancedFunctionalities:hot-restart}}
\sphinxAtStartPar
This new feature of NOMAD 4 makes it possible to continue the solving process after it has started,
without having to restart it from the beginning.
In the case of hot restart, the user interrupts the solver to change the value of a parameter.
With warm restart, the user changes a parameter from a resolution that has already reached a termination condition.
In both cases, the solving process is then continued from its current state.


\subsection{Hot restart}
\label{\detokenize{AdvancedFunctionalities:id17}}
\sphinxAtStartPar
To enable hot restart, set parameter \sphinxcode{\sphinxupquote{HOT\_RESTART\_ON\_USER\_INTERRUPT}} to \sphinxcode{\sphinxupquote{true}}.
While NOMAD is running, interrupt the run with the command \sphinxcode{\sphinxupquote{CTRL\sphinxhyphen{}C}}.
New values for parameters may be entered.
For example, entering \sphinxcode{\sphinxupquote{LH\_SEARCH 0 20}} will make LH search be used for the rest of the optimization.
The syntax is the same as the syntax of a parameter file, when in batch mode.
When all new parameter values are entered, continue optimization by entering
the command \sphinxcode{\sphinxupquote{CTRL\sphinxhyphen{}D}}. The new parameter values will be taken into account.


\subsection{Warm restart}
\label{\detokenize{AdvancedFunctionalities:warm-restart}}
\sphinxAtStartPar
To enable warm restart, parameters \sphinxcode{\sphinxupquote{HOT\_RESTART\_READ\_FILES}} and \sphinxcode{\sphinxupquote{HOT\_RESTART\_WRITE\_FILES}} need to be set to \sphinxcode{\sphinxupquote{true}}.
When NOMAD runs a first time, files \sphinxcode{\sphinxupquote{hotrestart.txt}} and \sphinxcode{\sphinxupquote{cache.txt}} are written to the problem directory.
This information is used if NOMAD is run a second time.
Instead of redoing the same optimization, NOMAD will continue where it was when the first run was ended.
For example, suppose the first NOMAD run stopped at evaluation 100 because the value of parameter \sphinxcode{\sphinxupquote{MAX\_BB\_EVAL}} was 100.
The user still has room for 50 more evaluations.
The parameter file may be changed with value \sphinxcode{\sphinxupquote{MAX\_BB\_EVAL 150}}, and the second run of
NOMAD will start where it was, with evaluation 101.


\section{Doxygen}
\label{\detokenize{AdvancedFunctionalities:doxygen}}
\sphinxAtStartPar
A local doxygen documentation can be created by running the \sphinxcode{\sphinxupquote{doxygen}} command (if available) in \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/doc/doxygen}}. The documentation can be opened by a browser at \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/doc/doxygen/html/index.html}}.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{References}
\end{sphinxShadowBox}


\chapter{Surrogate Library}
\label{\detokenize{SgteLib:surrogate-library}}\label{\detokenize{SgteLib:sgtelib}}\label{\detokenize{SgteLib::doc}}
\sphinxAtStartPar
The \sphinxstyleemphasis{SGTELIB} library is a dynamic surrogate modelling library. It is used in the \sphinxstyleemphasis{Search} step of Mads to dynamically construct models from the previous evaluations.
During a \sphinxstyleemphasis{Search} step that uses \sphinxstyleemphasis{SGTELIB}, models of the objective and the constraints are constructed and a surrogate subproblem involving these models is optimized.
The resulting solutions are the next candidates for evaluation by the true problem.

\begin{DUlineblock}{0em}
\item[] Models from the \sphinxstyleemphasis{SGTELIB} library can be used by setting the parameter \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_SEARCH}} to \sphinxcode{\sphinxupquote{yes}} or \sphinxcode{\sphinxupquote{true}}.
\end{DUlineblock}


\section{Models}
\label{\detokenize{SgteLib:models}}
\sphinxAtStartPar
Models in \sphinxstyleemphasis{SGTELIB} are defined by using a succession of field names and field values.
To choose a model, the parameter \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_DEFINITION}} must be used followed by the field name \sphinxcode{\sphinxupquote{TYPE}}, and then by the model type.
The subsequent fields enable to define the settings of the model.
Each field name is made of one single word and each field value is made of one single word or numerical value.

\sphinxAtStartPar
Example : \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_DEFINITION TYPE \textless{}model type\textgreater{} FIELD1 \textless{}field 1 value\textgreater{} FIELD2 \textless{}field 2 value\textgreater{}}}

\sphinxAtStartPar
The section below describes the models and settings available.


\subsection{Types of models}
\label{\detokenize{SgteLib:types-of-models}}
\sphinxAtStartPar
Below is the list of all possible models and their authorized fields.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{PRS}}}
\label{\detokenize{SgteLib:prs}}\label{\detokenize{SgteLib:id1}}
\begin{DUlineblock}{0em}
\item[] PRS (Polynomial Response Surface) is a type of model.
\item[] Authorized fields:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:degree}]{\sphinxcrossref{\DUrole{std,std-ref}{DEGREE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:ridge}]{\sphinxcrossref{\DUrole{std,std-ref}{RIDGE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:budget}]{\sphinxcrossref{\DUrole{std,std-ref}{BUDGET}}}}: Defines the budget allocated for parameter optimization.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:output}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT}}}}: Defines the output text file.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Examples:
\item[] \sphinxcode{\sphinxupquote{TYPE PRS DEGREE 2}}
\item[] \sphinxcode{\sphinxupquote{TYPE PRS DEGREE OPTIM RIDGE OPTIM}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{PRS\_EDGE}}}
\label{\detokenize{SgteLib:prs-edge}}\label{\detokenize{SgteLib:id2}}
\begin{DUlineblock}{0em}
\item[] PRS\_EDGE (Polynomial Response Surface EDGE) is a type of model that allows to model discontinuities at \(0\) by using additional basis functions.
\item[] Authorized fields:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:degree}]{\sphinxcrossref{\DUrole{std,std-ref}{DEGREE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:ridge}]{\sphinxcrossref{\DUrole{std,std-ref}{RIDGE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:budget}]{\sphinxcrossref{\DUrole{std,std-ref}{BUDGET}}}}: Defines the budget allocated for parameter optimization.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:output}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT}}}}: Defines the output text file.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Examples:
\item[] \sphinxcode{\sphinxupquote{TYPE PRS\_EDGE DEGREE 2}}
\item[] \sphinxcode{\sphinxupquote{TYPE PRS\_EDGE DEGREE OPTIM RIDGE OPTIM}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{PRS\_CAT}}}
\label{\detokenize{SgteLib:prs-cat}}\label{\detokenize{SgteLib:id3}}
\begin{DUlineblock}{0em}
\item[] PRS\_CAT (Categorical Polynomial Response Surface) is a type of model that allows to build one PRS model for each different value of the first component of \(x\).
\item[] Authorized fields:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:degree}]{\sphinxcrossref{\DUrole{std,std-ref}{DEGREE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:ridge}]{\sphinxcrossref{\DUrole{std,std-ref}{RIDGE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:budget}]{\sphinxcrossref{\DUrole{std,std-ref}{BUDGET}}}}: Defines the budget allocated for parameter optimization.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:output}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT}}}}: Defines the output text file.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE PRS\_CAT DEGREE 2}}
\item[] \sphinxcode{\sphinxupquote{TYPE PRS\_CAT DEGREE OPTIM RIDGE OPTIM}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{RBF}}}
\label{\detokenize{SgteLib:rbf}}\label{\detokenize{SgteLib:id4}}
\begin{DUlineblock}{0em}
\item[] RBF (Radial Basis Function) is a type of model.
\item[] Authorized fields:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:kernel-type}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_TYPE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:kernel-shape}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_SHAPE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:distance-type}]{\sphinxcrossref{\DUrole{std,std-ref}{DISTANCE\_TYPE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:ridge}]{\sphinxcrossref{\DUrole{std,std-ref}{RIDGE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:preset}]{\sphinxcrossref{\DUrole{std,std-ref}{PRESET}}}}: Defines the type of RBF model used.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:budget}]{\sphinxcrossref{\DUrole{std,std-ref}{BUDGET}}}}: Defines the budget allocated for parameter optimization.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:output}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT}}}}: Defines the output text file.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE RBF KERNEL\_TYPE D1 KERNEL\_SHAPE OPTIM DISTANCE TYPE NORM2}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{KS}}}
\label{\detokenize{SgteLib:ks}}\label{\detokenize{SgteLib:id5}}
\begin{DUlineblock}{0em}
\item[] KS (Kernel Smoothing) is a type of model.
\item[] Authorized fields:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:kernel-type}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_TYPE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:kernel-shape}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_SHAPE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:distance-type}]{\sphinxcrossref{\DUrole{std,std-ref}{DISTANCE\_TYPE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:budget}]{\sphinxcrossref{\DUrole{std,std-ref}{BUDGET}}}}: Defines the budget allocated for parameter optimization.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:output}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT}}}}: Defines the output text file.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE KS KERNEL\_TYPE OPTIM KERNEL\_SHAPE OPTIM}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{KRIGING}}}
\label{\detokenize{SgteLib:kriging}}\label{\detokenize{SgteLib:id6}}
\begin{DUlineblock}{0em}
\item[] KRIGING is a type of model.
\item[] Authorized fields:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:ridge}]{\sphinxcrossref{\DUrole{std,std-ref}{RIDGE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:distance-type}]{\sphinxcrossref{\DUrole{std,std-ref}{DISTANCE\_TYPE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:budget}]{\sphinxcrossref{\DUrole{std,std-ref}{BUDGET}}}}: Defines the budget allocated for parameter optimization.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:output}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT}}}}: Defines the output text file.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE KRIGING}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{LOWESS}}}
\label{\detokenize{SgteLib:lowess}}\label{\detokenize{SgteLib:id7}}
\begin{DUlineblock}{0em}
\item[] LOWESS (Locally Weighted Regression) is a type of model (from \sphinxcite{SgteLib:taaukoled2016}).
\item[] Authorized fields:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:degree}]{\sphinxcrossref{\DUrole{std,std-ref}{DEGREE}}}}: Must be 1 (default) or 2 (Can be optimized).

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:ridge}]{\sphinxcrossref{\DUrole{std,std-ref}{RIDGE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:kernel-type}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_TYPE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:kernel-shape}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_SHAPE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:distance-type}]{\sphinxcrossref{\DUrole{std,std-ref}{DISTANCE\_TYPE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:preset}]{\sphinxcrossref{\DUrole{std,std-ref}{PRESET}}}}: Defines how the weight of each data point is computed.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:budget}]{\sphinxcrossref{\DUrole{std,std-ref}{BUDGET}}}}: Defines the budget allocated for parameter optimization.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:output}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT}}}}: Defines the output text file.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE LOWESS DEGREE 1}}
\item[] \sphinxcode{\sphinxupquote{TYPE LOWESS DEGREE OPTIM KERNEL\_SHAPE OPTIM KERNEL\_TYPE D1}}
\item[] \sphinxcode{\sphinxupquote{TYPE LOWESS DEGREE OPTIM KERNEL\_SHAPE OPTIM KERNEL\_TYPE OPTIM DISTANCE TYPE OPTIM}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{CN}}}
\label{\detokenize{SgteLib:cn}}\label{\detokenize{SgteLib:id9}}
\begin{DUlineblock}{0em}
\item[] CN (Closest Neighbours) is a type of model.
\item[] Authorized fields:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:distance-type}]{\sphinxcrossref{\DUrole{std,std-ref}{DISTANCE\_TYPE}}}} (Can be optimized)

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:budget}]{\sphinxcrossref{\DUrole{std,std-ref}{BUDGET}}}}: Defines the budget allocated for parameter optimization.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:output}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT}}}}: Defines the output text file.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE CN}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{ENSEMBLE}}}
\label{\detokenize{SgteLib:ensemble}}\label{\detokenize{SgteLib:id10}}
\begin{DUlineblock}{0em}
\item[] ENSEMBLE is a type of model that uses multiple models simultaneously.
\item[] Authorized fields:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:weight}]{\sphinxcrossref{\DUrole{std,std-ref}{WEIGHT}}}}: Defines how the ensemble weights are computed.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:metric}]{\sphinxcrossref{\DUrole{std,std-ref}{METRIC}}}}: Defines which metric is used to compute the weights.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:distance-type}]{\sphinxcrossref{\DUrole{std,std-ref}{DISTANCE\_TYPE}}}}: This parameter is transfered to the models contained in the Ensemble.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:preset}]{\sphinxcrossref{\DUrole{std,std-ref}{PRESET}}}}: Defines the selection of models in the ensemble.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:budget}]{\sphinxcrossref{\DUrole{std,std-ref}{BUDGET}}}}: Defines the budget allocated for parameter optimization.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:output}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT}}}}: Defines the output text file.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE WEIGHT SELECT METRIC OECV}}
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE WEIGHT OPTIM METRIC RMSECV DISTANCE TYPE NORM2 BUDGET 100}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{ENSEMBLE\_STAT}}}
\label{\detokenize{SgteLib:ensemble-stat}}\label{\detokenize{SgteLib:id11}}
\begin{DUlineblock}{0em}
\item[] ENSEMBLE\_STAT is a type of model (from \sphinxcite{SgteLib:auledsa2021}).
\item[] Authorized fields:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
all the fields from {\hyperref[\detokenize{SgteLib:ensemble}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE}}}} (with different default values though).

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:uncertainty}]{\sphinxcrossref{\DUrole{std,std-ref}{UNCERTAINTY}}}}: Selects an alternative for the uncertainty (smooth or nonsmooth).

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:size-param}]{\sphinxcrossref{\DUrole{std,std-ref}{SIZE\_PARAM}}}}: Defines the size parameter (different meaning depending on the value of UNCERTAINTY).

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:sigma-mult}]{\sphinxcrossref{\DUrole{std,std-ref}{SIGMA\_MULT}}}}: Defines the scaling factor of the uncertainty.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:lambda-p}]{\sphinxcrossref{\DUrole{std,std-ref}{LAMBDA\_P}}}}: Defines the shape parameter of the probability of feasibility.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:lambda-pi}]{\sphinxcrossref{\DUrole{std,std-ref}{LAMBDA\_PI}}}}: Defines the shape parameter of the probability of improvement.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE\_STAT UNCERTAINTY SMOOTH WEIGHT SELECT5 METRIC RMSECV SIZE\_PARAM 15}}
\end{DUlineblock}

\sphinxAtStartPar
The following table summarizes the possible fields for every model.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Model authorized fields}\label{\detokenize{SgteLib:id35}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Model type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:degree}]{\sphinxcrossref{\DUrole{std,std-ref}{DEGREE}}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:ridge}]{\sphinxcrossref{\DUrole{std,std-ref}{RIDGE}}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:kernel-type}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_TYPE}}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:kernel-shape}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_SHAPE}}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:distance-type}]{\sphinxcrossref{\DUrole{std,std-ref}{DISTANCE\_TYPE}}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:preset}]{\sphinxcrossref{\DUrole{std,std-ref}{PRESET}}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:weight}]{\sphinxcrossref{\DUrole{std,std-ref}{WEIGHT}}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:metric}]{\sphinxcrossref{\DUrole{std,std-ref}{METRIC}}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:uncertainty}]{\sphinxcrossref{\DUrole{std,std-ref}{UNCERTAINTY}}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:budget}]{\sphinxcrossref{\DUrole{std,std-ref}{BUDGET}}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:output}]{\sphinxcrossref{\DUrole{std,std-ref}{OUTPUT}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:prs}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS}}}}
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&&&&&&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:prs-edge}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS\_EDGE}}}}
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&&&&&&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:prs-cat}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS\_CAT}}}}
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&&&&&&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}}
&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:ks}]{\sphinxcrossref{\DUrole{std,std-ref}{KS}}}}
&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&&&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:kriging}]{\sphinxcrossref{\DUrole{std,std-ref}{KRIGING}}}}
&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&&&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:lowess}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWESS}}}}
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:cn}]{\sphinxcrossref{\DUrole{std,std-ref}{CN}}}}
&&&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&&&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:ensemble}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE}}}}
&&&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}}
&&&&&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
&
\sphinxAtStartPar
\(\pmb{\checkmark}\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Main model parameters}
\label{\detokenize{SgteLib:main-model-parameters}}
\sphinxAtStartPar
Below is the list of fields and their descriptions.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{DEGREE}}}
\label{\detokenize{SgteLib:degree}}\label{\detokenize{SgteLib:id13}}
\begin{DUlineblock}{0em}
\item[] The field name DEGREE defines the degree of a polynomial response surface. The value must be an integer \(\geq 1\).
\item[] Allowed for models of type: {\hyperref[\detokenize{SgteLib:prs}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS}}}}, {\hyperref[\detokenize{SgteLib:prs-edge}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS\_EDGE}}}}, {\hyperref[\detokenize{SgteLib:prs-cat}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS\_CAT}}}} and {\hyperref[\detokenize{SgteLib:lowess}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWESS}}}}.
\item[] Default value: 5
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
For PRS models, the default degree is 2.

\item {} 
\sphinxAtStartPar
For LOWESS models, the degree must be 1 (default) or 2.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE PRS DEGREE 3 defines a PRS model of degree 3.}}
\item[] \sphinxcode{\sphinxupquote{TYPE PRS\_EDGE DEGREE 2 defines a PRS\_EDGE model of degree 2.}}
\item[] \sphinxcode{\sphinxupquote{TYPE LOWESS DEGREE OPTIM defines a LOWESS model where the degree is optimized.}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{RIDGE}}}
\label{\detokenize{SgteLib:ridge}}\label{\detokenize{SgteLib:id14}}
\begin{DUlineblock}{0em}
\item[] The field name RIDGE defines the regularization parameter of the model.
\item[] Allowed for models of type: {\hyperref[\detokenize{SgteLib:prs}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS}}}}, {\hyperref[\detokenize{SgteLib:prs-edge}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS\_EDGE}}}}, {\hyperref[\detokenize{SgteLib:prs-cat}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS\_CAT}}}}, {\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}}, {\hyperref[\detokenize{SgteLib:kriging}]{\sphinxcrossref{\DUrole{std,std-ref}{KRIGING}}}} and {\hyperref[\detokenize{SgteLib:lowess}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWESS}}}}.
\item[] Possible values: Real value \(\geq 0\). Recommended values are \(0\) and \(0.001\).
\item[] Default value: \(0.001\).
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE PRS DEGREE 3 RIDGE 0}} defines a PRS model of degree 3 with no ridge.
\item[] \sphinxcode{\sphinxupquote{TYPE PRS DEGREE OPTIM RIDGE OPTIM}} defines a PRS model where the degree and ridge coefficient are optimized.
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{KERNEL\_TYPE}}}
\label{\detokenize{SgteLib:kernel-type}}\label{\detokenize{SgteLib:id15}}
\begin{DUlineblock}{0em}
\item[] The field name KERNEL\_TYPE defines the type of kernel used in the model. The field name \sphinxcode{\sphinxupquote{KERNEL}} is equivalent.
\item[] Allowed for models of type: {\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}}, {\hyperref[\detokenize{SgteLib:lowess}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWESS}}}} and {\hyperref[\detokenize{SgteLib:ks}]{\sphinxcrossref{\DUrole{std,std-ref}{KS}}}}.
\item[] Possible values:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{D1}}: Gaussian kernel

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{D2}}: Inverse Quadratic Kernel

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{D3}}: Inverse Multiquadratic Kernel

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{D4}}: Bi\sphinxhyphen{}quadratic Kernel

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{D5}}: Tri\sphinxhyphen{}cubic Kernel

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{D6}}: Exponential Sqrt Kernel

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{D7}}: Epanechnikov Kernel

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I0}}: Multiquadratic Kernel

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I1}}: Polyharmonic splines, degree 1

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I2}}: Polyharmonic splines, degree 2

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I3}}: Polyharmonic splines, degree 3

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I4}}: Polyharmonic splines, degree 4

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OPTIM}}: The type of kernel is optimized

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Default value: \sphinxcode{\sphinxupquote{D1}}, except for RBF models where it is \sphinxcode{\sphinxupquote{I2}}.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE KS KERNEL\_TYPE D2}} defines a KS model with Inverse Quadratic Kernel.
\item[] \sphinxcode{\sphinxupquote{TYPE KS KERNEL\_TYPE OPTIM KERNEL\_SHAPE OPTIM}} defines a KS model with optimized kernel shape and type.
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{KERNEL\_SHAPE}}}
\label{\detokenize{SgteLib:kernel-shape}}\label{\detokenize{SgteLib:id16}}
\begin{DUlineblock}{0em}
\item[] The field name KERNEL\_SHAPE defines the shape coefficient of the kernel function. The field name \sphinxcode{\sphinxupquote{KERNEL\_COEF}} is equivalent. Note that this field name has no impact for kernel types \sphinxcode{\sphinxupquote{I1}}, \sphinxcode{\sphinxupquote{I2}}, \sphinxcode{\sphinxupquote{I3}} and \sphinxcode{\sphinxupquote{I4}} because these kernels do not include a shape parameter.
\item[] Allowed for models of type: {\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}}, {\hyperref[\detokenize{SgteLib:ks}]{\sphinxcrossref{\DUrole{std,std-ref}{KS}}}} and {\hyperref[\detokenize{SgteLib:lowess}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWESS}}}}.
\item[] Possible values: Real value \(\geq 0\). Recommended range is \([0.1; 10]\). For KS and LOWESS model, small values lead to smoother models.
\item[] Default value: By default, the kernel coefficient is optimized.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE RBF KERNEL\_TYPE D4 KERNEL\_SHAPE 10}} defines a RBF model with an inverse bi\sphinxhyphen{}quadratic kernel of shape coefficient \(10\).
\item[] \sphinxcode{\sphinxupquote{TYPE KS KERNEL\_TYPE OPTIM KERNEL\_SHAPE OPTIM}} defines a KS model with optimized kernel shape and type.
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{DISTANCE\_TYPE}}}
\label{\detokenize{SgteLib:distance-type}}\label{\detokenize{SgteLib:id17}}
\begin{DUlineblock}{0em}
\item[] The field name DISTANCE\_TYPE defines the distance function used in the model.
\item[] Allowed for models of type: {\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}}, {\hyperref[\detokenize{SgteLib:ks}]{\sphinxcrossref{\DUrole{std,std-ref}{KS}}}}, {\hyperref[\detokenize{SgteLib:kriging}]{\sphinxcrossref{\DUrole{std,std-ref}{KRIGING}}}}, {\hyperref[\detokenize{SgteLib:lowess}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWESS}}}}, {\hyperref[\detokenize{SgteLib:cn}]{\sphinxcrossref{\DUrole{std,std-ref}{CN}}}}, {\hyperref[\detokenize{SgteLib:ensemble}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE}}}} and {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}}.
\item[] Possible values:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NORM1}}: Euclidian distance

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NORM2}}: Distance based on norm \(1\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NORMINF}}: Distance based on norm \(1\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NORM2\_IS0}}: Tailored distance for discontinuity in \(0\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NORM2\_CAT}}: Tailored distance for categorical models

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Default value: \sphinxcode{\sphinxupquote{NORM2}}.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE KS DISTANCE NORM2\_IS0}} defines a KS model tailored for VAN optimization.
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{PRESET}}}
\label{\detokenize{SgteLib:preset}}\label{\detokenize{SgteLib:id18}}
\begin{DUlineblock}{0em}
\item[] The field name PRESET defines the type of model used when applicable.
\item[] Allowed for models of type: {\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}}, {\hyperref[\detokenize{SgteLib:lowess}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWESS}}}}, {\hyperref[\detokenize{SgteLib:ensemble}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE}}}} and {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}}.
\end{DUlineblock}
\begin{itemize}
\item {} \begin{description}
\item[{When applied to {\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}} models, PRESET defines the type of RBF.}] \leavevmode
\sphinxAtStartPar
Possible values:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{O}}: RBF with linear terms and orthogonal constraints

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{R}}: RBF with linear terms and regularization term

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I}}: RBF with incomplete set of basis functions (see \sphinxcite{SgteLib:aukoledta2016} for RBFI models)

\end{itemize}

\begin{DUlineblock}{0em}
\item[] 
\item[] Default value: \sphinxcode{\sphinxupquote{I}}.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE RBF PRESET O}}
\end{DUlineblock}

\end{description}

\item {} \begin{description}
\item[{When applied to {\hyperref[\detokenize{SgteLib:lowess}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWESS}}}} models \sphinxcite{SgteLib:taaukoled2016}, PRESET defines how the weight \(w_i\) of each data point \(x_i\) is computed.}] \leavevmode
\sphinxAtStartPar
Possible values:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{D}}: \(w_i=\phi(d_i)\) where \(\phi\) is the kernel of type and shape defined by the fields {\hyperref[\detokenize{SgteLib:kernel-type}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_TYPE}}}} and {\hyperref[\detokenize{SgteLib:kernel-shape}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_SHAPE}}}}, respectively, and \(d_i\) is the distance between the prediction point and the data point \(x_i\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DEN}}: \(w_i=\phi(d_i/d_q)\) where \(d_q\) is the distance between the prediction point and the \(q^{th}\) closest data point, and \(d_q\) is computed with an empirical method

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DGN}}: \(w_i=\phi(d_i/d_q)\) where \(d_q\) is computed with the Gamma method

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RE}}: \(w_i=\phi(r_i)\) where \(r_i\) is the rank of \(x_i\) in terms of distance to the prediction point, and \(r_i\) is computed with empirical method

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RG}}: \(w_i=\phi(r_i)\) where \(r_i\) is computed with the Gamma method

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{REN}}: same as \sphinxcode{\sphinxupquote{RE}} but the ranks are normalized in \([0,1]\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RGN}}: same as \sphinxcode{\sphinxupquote{RG}} but the ranks are normalized in \([0,1]\)

\end{itemize}

\begin{DUlineblock}{0em}
\item[] 
\item[] Default value: \sphinxcode{\sphinxupquote{DGN}}.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE LOWESS PRESET RE}}
\end{DUlineblock}

\end{description}

\item {} \begin{description}
\item[{When applied to {\hyperref[\detokenize{SgteLib:ensemble}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE}}}} or {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}} models, PRESET determines the selection of models in the ensemble.}] \leavevmode
\sphinxAtStartPar
Possible values:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DEFAULT}}: selection of 18 models of types {\hyperref[\detokenize{SgteLib:prs}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS}}}}, {\hyperref[\detokenize{SgteLib:ks}]{\sphinxcrossref{\DUrole{std,std-ref}{KS}}}}, {\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}} and {\hyperref[\detokenize{SgteLib:cn}]{\sphinxcrossref{\DUrole{std,std-ref}{CN}}}} with various settings

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{KS}}: selection of 7 models of type {\hyperref[\detokenize{SgteLib:ks}]{\sphinxcrossref{\DUrole{std,std-ref}{KS}}}} with various kernel shapes

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PRS}}: selection of 7 models of type {\hyperref[\detokenize{SgteLib:prs}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS}}}} with various degrees

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IS0}}: selection of 30 models of type {\hyperref[\detokenize{SgteLib:prs-edge}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS\_EDGE}}}}, {\hyperref[\detokenize{SgteLib:ks}]{\sphinxcrossref{\DUrole{std,std-ref}{KS}}}}, {\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}} with various settings and DISTANCE\_TYPE set to NOMR2\_IS0

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CAT}}: selection of 30 models of type {\hyperref[\detokenize{SgteLib:prs-edge}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS\_EDGE}}}}, {\hyperref[\detokenize{SgteLib:ks}]{\sphinxcrossref{\DUrole{std,std-ref}{KS}}}}, {\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}} with various settings and DISTANCE\_TYPE set to NOMR2\_CAT

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SUPER1}}: selection of 4 models of types {\hyperref[\detokenize{SgteLib:prs}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS}}}}, {\hyperref[\detokenize{SgteLib:ks}]{\sphinxcrossref{\DUrole{std,std-ref}{KS}}}}, {\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}} and {\hyperref[\detokenize{SgteLib:lowess}]{\sphinxcrossref{\DUrole{std,std-ref}{LOWESS}}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SMALL}}: selection of 3 models of types {\hyperref[\detokenize{SgteLib:prs}]{\sphinxcrossref{\DUrole{std,std-ref}{PRS}}}}, {\hyperref[\detokenize{SgteLib:ks}]{\sphinxcrossref{\DUrole{std,std-ref}{KS}}}} and {\hyperref[\detokenize{SgteLib:rbf}]{\sphinxcrossref{\DUrole{std,std-ref}{RBF}}}}

\end{itemize}

\begin{DUlineblock}{0em}
\item[] 
\item[] Default value: \sphinxcode{\sphinxupquote{DEFAULT}}.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE PRESET SUPER1}}
\end{DUlineblock}

\end{description}

\end{itemize}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{WEIGHT}}}
\label{\detokenize{SgteLib:weight}}\label{\detokenize{SgteLib:id21}}
\begin{DUlineblock}{0em}
\item[] The field name WEIGHT defines the method used to compute the weights \(\boldsymbol{w}\) of the ensemble of models. The field name \sphinxcode{\sphinxupquote{WEIGHT\_TYPE}} is equivalent.
\item[] Allowed for models of type: {\hyperref[\detokenize{SgteLib:ensemble}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE}}}} and {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}}.
\item[] Possible values:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{WTA1}}: \(w_k \propto \mathcal{E}_{sum} - \mathcal{E}_k\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{WTA3}}: \(w_k \propto (\mathcal{E}_k + \alpha\mathcal{E}_{mean})^{\beta}\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SELECT}}: \(w_k \propto 1\) if \(\mathcal{E}_k = \mathcal{E}_{min}\) (only the best model is selected)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SELECTN}}: \(w_k \propto \mathcal{E}_{sum}^N - \mathcal{E}_k\) (for \(N=1,2,\dots,6\))

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OPTIM}}: \(\boldsymbol{w}\) minimizes \(\mathcal{E}(\boldsymbol{w})\)

\end{itemize}

\sphinxAtStartPar
Where \(\mathcal{E}_k\) is the error metric (defined by the field name {\hyperref[\detokenize{SgteLib:metric}]{\sphinxcrossref{\DUrole{std,std-ref}{METRIC}}}}) of the \(k^{th}\) model in the ensemble,
\(\mathcal{E}_{sum}\) is the cumulated error of all models,
\(\mathcal{E}_{min}\) is the minimal error,
\(\mathcal{E}_{mean}\) is the average error,
\(\alpha=0.05\), \(\beta=-1\),
and \(\mathcal{E}_{sum}^N\) is the cumulated error metric of the \(N\) best models.

\begin{DUlineblock}{0em}
\item[] Default value: \sphinxcode{\sphinxupquote{SELECT}} for {\hyperref[\detokenize{SgteLib:ensemble}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE}}}} models, \sphinxcode{\sphinxupquote{SELECT3}} for {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}} models with {\hyperref[\detokenize{SgteLib:uncertainty}]{\sphinxcrossref{\DUrole{std,std-ref}{UNCERTAINTY}}}} set to \sphinxcode{\sphinxupquote{SMOOTH}}, and  \sphinxcode{\sphinxupquote{SELECT4}} for {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}} models with {\hyperref[\detokenize{SgteLib:uncertainty}]{\sphinxcrossref{\DUrole{std,std-ref}{UNCERTAINTY}}}} set to \sphinxcode{\sphinxupquote{NONSMOOTH}}.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE WEIGHT SELECT METRIC RMSECV}} defines an ensemble of models which selects the model that has the best RMSECV.
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE WEIGHT OPTIM METRIC RMSECV}} defines an ensemble of models where the weights \(\boldsymbol{w}\) are computed to minimize the RMSECV of the model.
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE WEIGHT SELECT3 METRIC OECV}} defines an ensemble of models which selects the 3 models that have the best OECV.
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{UNCERTAINTY}}}
\label{\detokenize{SgteLib:uncertainty}}\label{\detokenize{SgteLib:id22}}
\sphinxAtStartPar
(specific to {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}} models)

\begin{DUlineblock}{0em}
\item[] The field name UNCERTAINTY defines the type of uncertainty used in ENSEMBLE\_STAT models.
\item[] Possible values:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SMOOTH}}: Smooth alternative of the uncertainty (default)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NONSMOOTH}}: Nonmooth alternative of the uncertainty

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE\_STAT UNCERTAINTY NONSMOOTH}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{SIZE\_PARAM}}}
\label{\detokenize{SgteLib:size-param}}\label{\detokenize{SgteLib:id23}}
\sphinxAtStartPar
(advanced parameter specific to {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}} models)

\begin{DUlineblock}{0em}
\item[] The field name SIZE\_PARAM defines the size of the directions of either :
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the simplex used to compute the simplex gradients of the models if the field {\hyperref[\detokenize{SgteLib:uncertainty}]{\sphinxcrossref{\DUrole{std,std-ref}{UNCERTAINTY}}}} is set to \sphinxcode{\sphinxupquote{SMOOTH}}

\item {} 
\sphinxAtStartPar
the positive spanning set used to compare models values if the field {\hyperref[\detokenize{SgteLib:uncertainty}]{\sphinxcrossref{\DUrole{std,std-ref}{UNCERTAINTY}}}} is set to \sphinxcode{\sphinxupquote{NONSMOOTH}}

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Possible values: Real value \(\geq 0\). Recommended range is \([0.001; 0.1]\).
\item[] Default value: \(0.001\) if the field UNCERTAINTY is set to \sphinxcode{\sphinxupquote{SMOOTH}}, \(0.005\) if the field UNCERTAINTY is set to \sphinxcode{\sphinxupquote{NONSMOOTH}}.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE\_STAT UNCERTAINTY SMOOTH SIZE\_PARAM 0.003}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{SIGMA\_MULT}}}
\label{\detokenize{SgteLib:sigma-mult}}\label{\detokenize{SgteLib:id24}}
\sphinxAtStartPar
(advanced parameter specific to {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}} models)

\begin{DUlineblock}{0em}
\item[] The field name SIGMA\_MULT defines the scaling factor of the uncertain to be multiplied by the variance of already sampled function values.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Possible values: Real value \(\geq 0\). Recommended range is \([1; 100]\).
\item[] Default value: \(10\).
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE\_STAT UNCERTAINTY NONSMOOTH SIGMA\_MULT 30}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{LAMBDA\_P}}}
\label{\detokenize{SgteLib:lambda-p}}\label{\detokenize{SgteLib:id25}}
\sphinxAtStartPar
(advanced parameter specific to {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}} models)

\begin{DUlineblock}{0em}
\item[] The field name LAMBDA\_P defines the shape parameter of the \sphinxstyleemphasis{probability of feasibility} (P).
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Possible values: Real value \(\geq 0\). Recommended range is \([0.1; 10]\).
\item[] Default value: \(3\) if the field UNCERTAINTY is set to \sphinxcode{\sphinxupquote{SMOOTH}}, \(1\) if the field UNCERTAINTY is set to \sphinxcode{\sphinxupquote{NONSMOOTH}}.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE\_STAT UNCERTAINTY NONSMOOTH LAMBDA\_P 1.5}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{LAMBDA\_PI}}}
\label{\detokenize{SgteLib:lambda-pi}}\label{\detokenize{SgteLib:id26}}
\sphinxAtStartPar
(advanced parameterspecific to {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}} models)

\begin{DUlineblock}{0em}
\item[] The field name LAMBDA\_PI defines the shape parameter of the \sphinxstyleemphasis{probability of improvement} (PI).
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Possible values: Real value \(\geq 0\). Recommended range is \([0.01; 3]\).
\item[] Default value: \(0.1\) if the field UNCERTAINTY is set to \sphinxcode{\sphinxupquote{SMOOTH}}, \(0.5\) if the field UNCERTAINTY is set to \sphinxcode{\sphinxupquote{NONSMOOTH}}.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE\_STAT UNCERTAINTY NONSMOOTH LAMBDA\_PI 0.3}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{OUTPUT}}}
\label{\detokenize{SgteLib:output}}\label{\detokenize{SgteLib:id27}}
\sphinxAtStartPar
Defines a text file in which model information are recorded. Allowed for ALL types of model.


\subsection{Parameter optimization and selection}
\label{\detokenize{SgteLib:parameter-optimization-and-selection}}
\sphinxAtStartPar
Below is the list of some field names and values that influence the behaviour of other fields.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{OPTIM}}}
\label{\detokenize{SgteLib:optim}}\label{\detokenize{SgteLib:id28}}
\begin{DUlineblock}{0em}
\item[] The field value OPTIM indicates that the model parameter must be optimized. The default optimization criteria is the AOECV error metric (except for ENSEMBLE\_STAT models where it is OECV).
\item[] Parameters that can be optimized:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:degree}]{\sphinxcrossref{\DUrole{std,std-ref}{DEGREE}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:ridge}]{\sphinxcrossref{\DUrole{std,std-ref}{RIDGE}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:kernel-type}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_TYPE}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:kernel-shape}]{\sphinxcrossref{\DUrole{std,std-ref}{KERNEL\_SHAPE}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{SgteLib:distance-type}]{\sphinxcrossref{\DUrole{std,std-ref}{DISTANCE\_TYPE}}}}

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE PRS DEGREE OPTIM}}
\item[] \sphinxcode{\sphinxupquote{TYPE LOWESS DEGREE OPTIM KERNEL\_TYPE OPTIM KERNEL\_SHAPE OPTIM METRIC ARMSECV}}
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{METRIC}}}
\label{\detokenize{SgteLib:metric}}\label{\detokenize{SgteLib:id29}}
\begin{DUlineblock}{0em}
\item[] The field name METRIC defines the metric used to select the parameters of the model (including the weights of Ensemble models).
\item[] Allowed for ALL types of model.
\item[] Possible values:
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EMAX}}: Error Max

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EMAXCV}}: Error Max with Cross\sphinxhyphen{}Validation

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RMSE}}: Root Mean Square Error

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RMSECV}}: RMSE with Cross\sphinxhyphen{}Validation

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OE}}: Order Error

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{OECV}}: Order Error with Cross\sphinxhyphen{}Validation \sphinxcite{SgteLib:aukoledta2016}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LINV}}: Invert of the Likelihood

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AOE}}: Aggregate Order Error

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AOECV}}: Aggregate Order Error with Cross\sphinxhyphen{}Validation \sphinxcite{SgteLib:taaukoled2016}

\end{itemize}

\begin{DUlineblock}{0em}
\item[] Default value: \sphinxcode{\sphinxupquote{AOECV}}, except for {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}} models where it is \sphinxcode{\sphinxupquote{OECV}}.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE WEIGHT SELECT METRIC RMSECV}} defines an ensemble of models which selects the model that has the best RMSECV.
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{BUDGET}}}
\label{\detokenize{SgteLib:budget}}\label{\detokenize{SgteLib:id32}}
\begin{DUlineblock}{0em}
\item[] Budget for model parameter optimization. The number of sets of model parameters that are tested is equal to the optimization budget multiplied by the number of parameters to optimize.
\item[] Allowed for ALL types of model.
\item[] Default value: \(20\)
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{TYPE LOWESS KERNEL\_SHAPE OPTIM METRIC AOECV BUDGET 100}}
\item[] \sphinxcode{\sphinxupquote{TYPE ENSEMBLE WEIGHT OPTIM METRIC RMSECV BUDGET 50}}
\end{DUlineblock}


\section{Surrogate subproblem formulations}
\label{\detokenize{SgteLib:surrogate-subproblem-formulations}}
\sphinxAtStartPar
The \sphinxstyleemphasis{SGTELIB} library offers different formulations of the surrogate subproblem to be optimized at the \sphinxstyleemphasis{Search} step (see \sphinxcite{SgteLib:taledko2014}).
The \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_FORMULATION}} parameter enables to choose a formulation, and the parameter \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_DIVERSIFICATION}} enables to adjust a diversification parameter.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{SGTELIB\_MODEL\_FORMULATION}}}
\label{\detokenize{SgteLib:sgtelib-model-formulation}}
\begin{DUlineblock}{0em}
\item[] The formulations of the surrogate subproblem involve various quantities.
\item[] \(\hat f\) denotes a model of the objective \(f\) and \(\hat c_j\) a model of the constraint \(c_j\), \(j=1,2,\dots,m\). For \(x\in X\), \(\sigma_f(x)\) denotes the uncertainty associated with the prediction \(\hat f(x)\), and \(\sigma_j(x)\) denotes the uncertainty associated with the prediction \(\hat c_j(x)\), \(j=1,2,\dots,m\). This uncertainty depends on the model chosen.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] For a {\hyperref[\detokenize{SgteLib:kriging}]{\sphinxcrossref{\DUrole{std,std-ref}{KRIGING}}}} model, \(\sigma_f(x)\) (or \(\sigma_j(x)\)) is readily available through the standard deviation that the model natively produces.
\item[] For an {\hyperref[\detokenize{SgteLib:ensemble-stat}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE\_STAT}}}} model, the uncertainty is constructed by comparing the predictions of the ensemble models (see \sphinxcite{SgteLib:auledsa2021}).
\item[] For any other model except ENSEMBLE, \(\sigma_f(x)\) (or \(\sigma_j(x)\)) is computed with the distance from \(x\) to previously evaluated points.
\item[] Finally, for an {\hyperref[\detokenize{SgteLib:ensemble}]{\sphinxcrossref{\DUrole{std,std-ref}{ENSEMBLE}}}} model, the uncertainty is computed through a weighted sum of the squared uncertainties of the ensemble models.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] There are eight different formulations that can be chosen with the parameter \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_FORMULATION}}. Some formulations involve a parameter \(\lambda\) that is described later.
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FS}} (default):

\end{itemize}
\begin{equation*}
\begin{split}\min_{x\in X}&\ \ \hat f(x)-\lambda\hat\sigma_f(x) \\
\mathrm{s.t.}&\ \ \hat c_j(x)-\lambda\hat\sigma_j(x)\leq0,\ \ j=1,2,\dots,m\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FSP}}:

\end{itemize}
\begin{equation*}
\begin{split}\min_{x\in X}&\ \ \hat f(x)-\lambda\hat\sigma_f(x) \\
\mathrm{s.t.}&\ \ \mathrm{P}(x)\geq 0.5\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathrm{P}\) is the \sphinxstyleemphasis{probability of feasibility} which is the probability that a given point is feasible.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EIS}}:

\end{itemize}
\begin{equation*}
\begin{split}\min_{x\in X}&\ -\mathrm{EI}(x)-\lambda\hat\sigma_f(x) \\
\mathrm{s.t.}&\ \ \hat c_j(x)-\lambda\hat\sigma_j(x)\leq0,\ \ j=1,2,\dots,m\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathrm{EI}\) is the \sphinxstyleemphasis{expected improvement} that takes into account the probability of improvement and
the expected amplitude thereof.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EFI}}:

\end{itemize}
\begin{equation*}
\begin{split}\min_{x\in X}\ -\mathrm{EFI}(x)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathrm{EFI}\) is the \sphinxstyleemphasis{expected feasible improvement} : \(\mathrm{EFI} = \mathrm{EI}\times\mathrm{P}\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EFIS}}:

\end{itemize}
\begin{equation*}
\begin{split}\min_{x\in X}\ -\mathrm{EFI}(x)-\lambda\hat\sigma_f(x)\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EFIM}}:

\end{itemize}
\begin{equation*}
\begin{split}\min_{x\in X}\ -\mathrm{EFI}(x)-\lambda\hat\sigma_f(x)\mu(x)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mu\) is the \sphinxstyleemphasis{uncertainty in the feasibility} : \(\mu = 4\mathrm{P}\times(1-\mathrm{P})\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EFIC}}:

\end{itemize}
\begin{equation*}
\begin{split}\min_{x\in X}\ -\mathrm{EFI}(x)-\lambda(\mathrm{EI}(x)\mu(x)
+\mathrm{P}(x)\hat\sigma_f(x))\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PFI}}:

\end{itemize}
\begin{equation*}
\begin{split}\min_{x\in X}\ -\mathrm{PFI}(x)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathrm{PFI}\) is the \sphinxstyleemphasis{probability of improvement} : \(\mathrm{PFI} = \mathrm{PI}\times\mathrm{P}\),
with \(\mathrm{PI}\) being the \sphinxstyleemphasis{probability of improvement} which is the probability that the objective decreases from the best known value at a given point.

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_DEFINITION TYPE KRIGING}}
\item[] \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_FORMULATION EFIC}}
\item[] The two lines above define a surrogate subproblem based on the EFIC formulation that will involve kriging models.
\end{DUlineblock}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{SGTELIB\_MODEL\_DIVERSIFICATION}}}
\label{\detokenize{SgteLib:sgtelib-model-diversification}}
\begin{DUlineblock}{0em}
\item[] The exploration parameter \(\lambda\) enables to control the exploration of the search space against the intensification in the most promising areas. A higher \(\lambda\) favors exploration whereas a lower \(\lambda\) favors intensification.
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \(\lambda\) is a real value in \([0,1]\) defined by the parameter \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_DIVERSIFICATION}}.
\item[] Default value : \(0.01\).
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] Example:
\item[] \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_DEFINITION TYPE ENSEMBLE}}
\item[] \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_FORMULATION FSP}}
\item[] \sphinxcode{\sphinxupquote{SGTELIB\_MODEL\_DIVERSIFICATION 0.1}}
\item[] The three lines above define a surrogate subproblem based on the FSP formulation with an exploration parameter equals to \(0.1\) that will involve ensemble models.
\end{DUlineblock}

\begin{sphinxShadowBox}
\sphinxstyletopictitle{References}
\end{sphinxShadowBox}


\chapter{Release notes and future developments}
\label{\detokenize{ReleaseNotes:release-notes-and-future-developments}}\label{\detokenize{ReleaseNotes::doc}}
\sphinxAtStartPar
NOMAD 4 is a complete redesign compared with NOMAD 3, with a new architecture providing more flexible code, some added functionalities and reusable code.

\sphinxAtStartPar
Some functionalities available in NOMAD 3 will be included in NOMAD 4 in future releases:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{BiMads} \sphinxcite{ReleaseNotes:ausazg2008a}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{RobustMads} \sphinxcite{ReleaseNotes:audihaledtrib2016} and \sphinxstyleemphasis{StoMads} \sphinxcite{ReleaseNotes:g-2019-30}

\item {} 
\sphinxAtStartPar
Categorical \sphinxcite{ReleaseNotes:aude01a} and periodical variables \sphinxcite{ReleaseNotes:aule2012}

\end{itemize}

\sphinxAtStartPar
The performance of NOMAD 4 and 3 are similar when the default parameters of NOMAD 3 are used (see \sphinxcite{index:aulerotr2021}).

\begin{sphinxShadowBox}
\sphinxstyletopictitle{References}
\end{sphinxShadowBox}


\chapter{Complete list of parameters}
\label{\detokenize{Appendix:complete-list-of-parameters}}\label{\detokenize{Appendix:appendix-parameters}}\label{\detokenize{Appendix::doc}}
\sphinxAtStartPar
A set of parameters is available in the table below for fine tuning algorithmic settings. Additional information on each parameter is available by typing \sphinxcode{\sphinxupquote{\$NOMAD\_HOME/bin/nomad \sphinxhyphen{}h PARAM\_NAME}}.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{|\X{20}{93}|\X{3}{93}|\X{10}{93}|\X{50}{93}|\X{10}{93}|}
\sphinxthelongtablecaptionisattop
\caption{NOMAD 4 parameters\strut}\label{\detokenize{Appendix:id1}}\\*[\sphinxlongtablecapskipadjust]
\hline

\endfirsthead

\multicolumn{5}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{5}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
Name
&
\sphinxAtStartPar
Type
&
\sphinxAtStartPar
Argument
&
\sphinxAtStartPar
Short description
&
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
ADD\_SEED\_TO\_FILE\_NAMES
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
The flag to add seed to the file names
\end{quote}
&
\sphinxAtStartPar
true
\\
\hline
\sphinxAtStartPar
ANISOTROPIC\_MESH
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
MADS uses anisotropic mesh for generating directions
\end{quote}
&
\sphinxAtStartPar
true
\\
\hline
\sphinxAtStartPar
ANISOTROPY\_FACTOR
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
MADS anisotropy factor for mesh size change
\end{quote}
&
\sphinxAtStartPar
0.1
\\
\hline
\sphinxAtStartPar
BB\_EXE
&
\sphinxAtStartPar
std::string
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Blackbox executable
\end{quote}
&\\
\hline
\sphinxAtStartPar
BB\_INPUT\_TYPE
&
\sphinxAtStartPar
NOMAD::BBInputTypeList
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
The variable blackbox input types
\end{quote}
&\begin{itemize}
\item {} 
\sphinxAtStartPar
R

\end{itemize}
\\
\hline
\sphinxAtStartPar
BB\_MAX\_BLOCK\_SIZE
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Size of blocks of points, to be used for parallel evaluations
\end{quote}
&
\sphinxAtStartPar
1
\\
\hline
\sphinxAtStartPar
BB\_OUTPUT\_TYPE
&
\sphinxAtStartPar
NOMAD::BBOutputTypeList
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Type of outputs provided by the blackboxes
\end{quote}
&
\sphinxAtStartPar
OBJ
\\
\hline
\sphinxAtStartPar
CACHE\_FILE
&
\sphinxAtStartPar
std::string
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Cache file name
\end{quote}
&\\
\hline
\sphinxAtStartPar
CACHE\_SIZE\_MAX
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Maximum number of evaluation points to be stored in the cache
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
CS\_OPTIMIZATION
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Coordinate Search optimization
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
DIMENSION
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Dimension of the optimization problem (required)
\end{quote}
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
DIRECTION\_TYPE
&
\sphinxAtStartPar
NOMAD::DirectionTypeList
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Direction types for Poll steps
\end{quote}
&
\sphinxAtStartPar
ORTHO N+1 QUAD
\\
\hline
\sphinxAtStartPar
DIRECTION\_TYPE\_SECONDARY\_POLL
&
\sphinxAtStartPar
NOMAD::DirectionTypeList
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Direction types for Mads secondary poll
\end{quote}
&
\sphinxAtStartPar
DOUBLE
\\
\hline
\sphinxAtStartPar
DISPLAY\_ALL\_EVAL
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Flag to display all evaluations
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
DISPLAY\_DEGREE
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Level of verbose during execution
\end{quote}
&
\sphinxAtStartPar
2
\\
\hline
\sphinxAtStartPar
DISPLAY\_HEADER
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Frequency at which the stats header is displayed
\end{quote}
&
\sphinxAtStartPar
40
\\
\hline
\sphinxAtStartPar
DISPLAY\_INFEASIBLE
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Flag to display infeasible
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
DISPLAY\_MAX\_STEP\_LEVEL
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Depth of the step after which info is not printed
\end{quote}
&
\sphinxAtStartPar
20
\\
\hline
\sphinxAtStartPar
DISPLAY\_STATS
&
\sphinxAtStartPar
NOMAD::ArrayOfString
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Format for displaying the evaluation points
\end{quote}
&
\sphinxAtStartPar
BBE OBJ
\\
\hline
\sphinxAtStartPar
DISPLAY\_UNSUCCESSFUL
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Flag to display unsuccessful
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
EVAL\_OPPORTUNISTIC
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Opportunistic strategy: Terminate evaluations as soon as a success is found
\end{quote}
&
\sphinxAtStartPar
true
\\
\hline
\sphinxAtStartPar
EVAL\_QUEUE\_CLEAR
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Opportunistic strategy: Flag to clear EvaluatorControl queue between each run
\end{quote}
&
\sphinxAtStartPar
true
\\
\hline
\sphinxAtStartPar
EVAL\_QUEUE\_SORT
&
\sphinxAtStartPar
NOMAD::EvalSortType
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
How to sort points before evaluation
\end{quote}
&
\sphinxAtStartPar
QUADRATIC\_MODEL
\\
\hline
\sphinxAtStartPar
EVAL\_STATS\_FILE
&
\sphinxAtStartPar
string
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
The name of the file for stats about evaluations and successes
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\sphinxAtStartPar
EVAL\_SURROGATE\_COST
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Cost of the surrogate function versus the true function
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
EVAL\_SURROGATE\_OPTIMIZATION
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Use static surrogate as blackbox for optimization
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
EVAL\_USE\_CACHE
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Use cache in algorithms
\end{quote}
&
\sphinxAtStartPar
true
\\
\hline
\sphinxAtStartPar
FIXED\_VARIABLE
&
\sphinxAtStartPar
NOMAD::Point
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Fix some variables to some specific values
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\sphinxAtStartPar
FRAME\_CENTER\_USE\_CACHE
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Find best points in the cache and use them as frame centers
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
GRANULARITY
&
\sphinxAtStartPar
NOMAD::ArrayOfDouble
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
The granularity of the variables
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\sphinxAtStartPar
HISTORY\_FILE
&
\sphinxAtStartPar
std::string
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
The name of the history file
\end{quote}
&\\
\hline
\sphinxAtStartPar
HOT\_RESTART\_FILE
&
\sphinxAtStartPar
std::string
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
The name of the hot restart file
\end{quote}
&
\sphinxAtStartPar
hotrestart.txt
\\
\hline
\sphinxAtStartPar
HOT\_RESTART\_ON\_USER\_INTERRUPT
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Flag to perform a hot restart on user interrupt
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
HOT\_RESTART\_READ\_FILES
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Flag to read hot restart files
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
HOT\_RESTART\_WRITE\_FILES
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Flag to write hot restart files
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
H\_MAX\_0
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Initial value of hMax.
\end{quote}
&
\sphinxAtStartPar
NOMAD::INF
\\
\hline
\sphinxAtStartPar
INITIAL\_FRAME\_SIZE
&
\sphinxAtStartPar
NOMAD::ArrayOfDouble
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
The initial frame size of MADS
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\sphinxAtStartPar
INITIAL\_MESH\_SIZE
&
\sphinxAtStartPar
NOMAD::ArrayOfDouble
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
The initial mesh size of MADS
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\sphinxAtStartPar
LH\_EVAL
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Latin Hypercube Sampling of points (no optimization)
\end{quote}
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
LH\_SEARCH
&
\sphinxAtStartPar
NOMAD::LHSearchType
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Latin Hypercube Sampling Search method
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\sphinxAtStartPar
LOWER\_BOUND
&
\sphinxAtStartPar
NOMAD::ArrayOfDouble
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
The optimization problem lower bounds for each variable
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\sphinxAtStartPar
MAX\_BB\_EVAL
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Stopping criterion on the number of blackbox evaluations
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
MAX\_EVAL
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Stopping criterion on the number of evaluations (blackbox and cache)
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
MAX\_ITERATIONS
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
The maximum number of iterations of the MADS algorithm
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
MAX\_ITERATION\_PER\_MEGAITERATION
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Maximum number of Iterations to generate for each MegaIteration.
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
MAX\_SURROGATE\_EVAL\_OPTIMIZATION
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Stopping criterion on the number of static surrogate evaluations
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
MAX\_TIME
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Maximum wall\sphinxhyphen{}clock time in seconds
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
MEGA\_SEARCH\_POLL
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Evaluate points generated from Search and Poll steps all at once
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
MIN\_FRAME\_SIZE
&
\sphinxAtStartPar
NOMAD::ArrayOfDouble
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Termination criterion on minimal frame size of MADS
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\sphinxAtStartPar
MIN\_MESH\_SIZE
&
\sphinxAtStartPar
NOMAD::ArrayOfDouble
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Termination criterion on minimal mesh size of MADS
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\sphinxAtStartPar
NB\_THREADS\_OPENMP
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
The number of threads when OpenMP parallel evaluations
are enabled
\end{quote}
&
\sphinxAtStartPar
\sphinxhyphen{}1
\\
\hline
\sphinxAtStartPar
NM\_DELTA\_E
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
NM expansion parameter delta\_e.
\end{quote}
&
\sphinxAtStartPar
2
\\
\hline
\sphinxAtStartPar
NM\_DELTA\_IC
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
NM inside contraction parameter delta\_ic.
\end{quote}
&
\sphinxAtStartPar
\sphinxhyphen{}0.5
\\
\hline
\sphinxAtStartPar
NM\_DELTA\_OC
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
NM outside contraction parameter delta\_oc.
\end{quote}
&
\sphinxAtStartPar
0.5
\\
\hline
\sphinxAtStartPar
NM\_GAMMA
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
NM shrink parameter gamma.
\end{quote}
&
\sphinxAtStartPar
0.5
\\
\hline
\sphinxAtStartPar
NM\_OPTIMIZATION
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Nelder Mead stand alone optimization for constrained and unconstrained pbs
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
NM\_SEARCH
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Nelder Mead optimization used as a search step for Mads
\end{quote}
&
\sphinxAtStartPar
true
\\
\hline
\sphinxAtStartPar
NM\_SEARCH\_MAX\_TRIAL\_PTS\_NFACTOR
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
NM\sphinxhyphen{}Mads search stopping criterion.
\end{quote}
&
\sphinxAtStartPar
80
\\
\hline
\sphinxAtStartPar
NM\_SEARCH\_RANK\_EPS
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
NM\sphinxhyphen{}Mads epsilon for the rank of DZ.
\end{quote}
&
\sphinxAtStartPar
0.01
\\
\hline
\sphinxAtStartPar
NM\_SEARCH\_STOP\_ON\_SUCCESS
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
NM\sphinxhyphen{}Mads search stops on success.
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
NM\_SIMPLEX\_INCLUDE\_FACTOR
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Construct NM simplex using points in cache.
\end{quote}
&
\sphinxAtStartPar
8
\\
\hline
\sphinxAtStartPar
NM\_SIMPLEX\_INCLUDE\_LENGTH
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Construct NM simplex using points in cache.
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
PSD\_MADS\_ITER\_OPPORTUNISTIC
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Opportunistic strategy between the Mads subproblems in PSD\sphinxhyphen{}MADS
\end{quote}
&
\sphinxAtStartPar
true
\\
\hline
\sphinxAtStartPar
PSD\_MADS\_NB\_SUBPROBLEM
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Number of PSD\sphinxhyphen{}MADS subproblems
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
PSD\_MADS\_NB\_VAR\_IN\_SUBPROBLEM
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Number of variables in PSD\sphinxhyphen{}MADS subproblems
\end{quote}
&
\sphinxAtStartPar
2
\\
\hline
\sphinxAtStartPar
PSD\_MADS\_OPTIMIZATION
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
PSD\sphinxhyphen{}MADS optimization algorithm
\end{quote}
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
PSD\_MADS\_ORIGINAL
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Use NOMAD 3 strategy for mesh update in PSD\sphinxhyphen{}MADS
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
PSD\_MADS\_SUBPROBLEM\_MAX\_BB\_EVAL
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Max number of evaluations for each subproblem
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
PSD\_MADS\_SUBPROBLEM\_PERCENT\_COVERAGE
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Percentage of variables that must be covered in subproblems before updating mesh
\end{quote}
&
\sphinxAtStartPar
70
\\
\hline
\sphinxAtStartPar
QUAD\_MODEL\_DISPLAY
&
\sphinxAtStartPar
std::string
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Display of a model
\end{quote}
&\\
\hline
\sphinxAtStartPar
QUAD\_MODEL\_MAX\_BLOCK\_SIZE
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Size of blocks of points, to be used for parallel evaluations
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
QUAD\_MODEL\_MAX\_EVAL
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Max number of model evaluations for each optimization of the quad model problem
\end{quote}
&
\sphinxAtStartPar
5000
\\
\hline
\sphinxAtStartPar
QUAD\_MODEL\_OPTIMIZATION
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Quad model stand alone optimization for constrained and unconstrained pbs
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
QUAD\_MODEL\_SEARCH
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Quad model search
\end{quote}
&
\sphinxAtStartPar
true
\\
\hline
\sphinxAtStartPar
QUAD\_MODEL\_SLD\_SEARCH
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Quad model (SLD) search
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
REJECT\_UNKNOWN\_PARAMETERS
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Flag to reject unknown parameters when checking validity of parameters
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
RHO
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Rho parameter of the progressive barrier
\end{quote}
&
\sphinxAtStartPar
0.1
\\
\hline
\sphinxAtStartPar
SEED
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
The seed for the pseudo\sphinxhyphen{}random number generator
\end{quote}
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
SGTELIB\_MAX\_POINTS\_FOR\_MODEL
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Maximum number of valid points used to build a model
\end{quote}
&
\sphinxAtStartPar
500
\\
\hline
\sphinxAtStartPar
SGTELIB\_MIN\_POINTS\_FOR\_MODEL
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Minimum number of valid points necessary to build a model
\end{quote}
&
\sphinxAtStartPar
1
\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_DEFINITION
&
\sphinxAtStartPar
NOMAD::ArrayOfString
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Definition of the Sgtelib model
\end{quote}
&\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_DISPLAY
&
\sphinxAtStartPar
std::string
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Display of a model
\end{quote}
&\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_DIVERSIFICATION
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Coefficient of the exploration term in the sgtelib model problem
\end{quote}
&
\sphinxAtStartPar
0.01
\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_EVAL
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Sgtelib Model Sampling of points
\end{quote}
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_FEASIBILITY
&
\sphinxAtStartPar
NOMAD::SgtelibModelFeasibilityType
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Method used to model the feasibility of a point
\end{quote}
&
\sphinxAtStartPar
C
\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_FORMULATION
&
\sphinxAtStartPar
NOMAD::SgtelibModelFormulationType
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Formulation of the sgtelib model problem
\end{quote}
&
\sphinxAtStartPar
FS
\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_MAX\_BLOCK\_SIZE
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Size of blocks of points, to be used for parallel evaluations
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_MAX\_EVAL
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Max number of model evaluations for each optimization of the sgtelib model problem
\end{quote}
&
\sphinxAtStartPar
1000
\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_SEARCH
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
Model search using Sgtelib
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_SEARCH\_CANDIDATES\_NB
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Number of candidates returned by the sgtelib model search
\end{quote}
&
\sphinxAtStartPar
\sphinxhyphen{}1
\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_SEARCH\_EXCLUSION\_AREA
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Exclusion area for the sgtelib model search around points of the cache
\end{quote}
&
\sphinxAtStartPar
0.0
\\
\hline
\sphinxAtStartPar
SGTELIB\_MODEL\_SEARCH\_FILTER
&
\sphinxAtStartPar
std::string
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Methods used in the sgtelib search filter to return several search candidates
\end{quote}
&
\sphinxAtStartPar
2345
\\
\hline
\sphinxAtStartPar
SOLUTION\_FILE
&
\sphinxAtStartPar
std::string
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
The name of the file containing the best feasible solution
\end{quote}
&\\
\hline
\sphinxAtStartPar
SPECULATIVE\_SEARCH
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
MADS speculative search method
\end{quote}
&
\sphinxAtStartPar
true
\\
\hline
\sphinxAtStartPar
SPECULATIVE\_SEARCH\_BASE\_FACTOR
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Distance of the MADS speculative search method
\end{quote}
&
\sphinxAtStartPar
4.0
\\
\hline
\sphinxAtStartPar
SPECULATIVE\_SEARCH\_MAX
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
MADS speculative search method
\end{quote}
&
\sphinxAtStartPar
1
\\
\hline
\sphinxAtStartPar
SSD\_MADS\_ITER\_OPPORTUNISTIC
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Opportunistic strategy between the Mads subproblems in SSD\sphinxhyphen{}MADS
\end{quote}
&
\sphinxAtStartPar
true
\\
\hline
\sphinxAtStartPar
SSD\_MADS\_NB\_SUBPROBLEM
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Number of SSD\sphinxhyphen{}MADS subproblems
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
SSD\_MADS\_NB\_VAR\_IN\_SUBPROBLEM
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Number of variables in SSD\sphinxhyphen{}MADS subproblems
\end{quote}
&
\sphinxAtStartPar
2
\\
\hline
\sphinxAtStartPar
SSD\_MADS\_OPTIMIZATION
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
SSD\sphinxhyphen{}MADS optimization algorithm
\end{quote}
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
SSD\_MADS\_RESET\_VAR\_PICKUP\_SUBPROBLEM
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Reset random variable pick\sphinxhyphen{}up for each subproblem
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
SSD\_MADS\_SUBPROBLEM\_MAX\_BB\_EVAL
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Max number of evaluations for each subproblem
\end{quote}
&
\sphinxAtStartPar
INF
\\
\hline
\sphinxAtStartPar
STATS\_FILE
&
\sphinxAtStartPar
NOMAD::ArrayOfString
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
The name of the stats file
\end{quote}
&\\
\hline
\sphinxAtStartPar
STOP\_IF\_FEASIBLE
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Stop algorithm once a feasible point is obtained
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
STOP\_IF\_PHASE\_ONE\_SOLUTION
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Stop algorithm once a phase one solution is obtained
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
SURROGATE\_EXE
&
\sphinxAtStartPar
std::string
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Static surrogate executable
\end{quote}
&\\
\hline
\sphinxAtStartPar
TMP\_DIR
&
\sphinxAtStartPar
std::string
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Directory where to put temporary files
\end{quote}
&\\
\hline
\sphinxAtStartPar
UPPER\_BOUND
&
\sphinxAtStartPar
NOMAD::ArrayOfDouble
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
The optimization problem upper bounds for each variable
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\sphinxAtStartPar
USER\_CALLS\_ENABLED
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
Controls the automatic calls to user function
\end{quote}
&
\sphinxAtStartPar
true
\\
\hline
\sphinxAtStartPar
VARIABLE\_GROUP
&
\sphinxAtStartPar
NOMAD::ListOfVariableGroup
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
The groups of variables)
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\sphinxAtStartPar
VNS\_MADS\_OPTIMIZATION
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
VNS MADS stand alone optimization for constrained and unconstrained pbs
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
VNS\_MADS\_SEARCH
&
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
VNS Mads optimization used as a search step for Mads
\end{quote}
&
\sphinxAtStartPar
false
\\
\hline
\sphinxAtStartPar
VNS\_MADS\_SEARCH\_MAX\_TRIAL\_PTS\_NFACTOR
&
\sphinxAtStartPar
size\_t
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
VNS\sphinxhyphen{}Mads search stopping criterion.
\end{quote}
&
\sphinxAtStartPar
100
\\
\hline
\sphinxAtStartPar
VNS\_MADS\_SEARCH\_TRIGGER
&
\sphinxAtStartPar
NOMAD::Double
&
\sphinxAtStartPar
advanced
&\begin{quote}

\sphinxAtStartPar
VNS Mads search trigger
\end{quote}
&
\sphinxAtStartPar
0.75
\\
\hline
\sphinxAtStartPar
X0
&
\sphinxAtStartPar
NOMAD::ArrayOfPoint
&
\sphinxAtStartPar
basic
&\begin{quote}

\sphinxAtStartPar
The initial point(s)
\end{quote}
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\section{Detailed information}
\label{\detokenize{ListOfParameters:detailed-information}}\label{\detokenize{ListOfParameters::doc}}
\sphinxAtStartPar
\sphinxstylestrong{In progress}

\sphinxAtStartPar
BB\_INPUT\_TYPE

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Type}\PYG{p}{:} \PYG{n}{NOMAD}\PYG{p}{:}\PYG{p}{:}\PYG{n}{BBInputTypeList}

\PYG{n}{Default}\PYG{p}{:} \PYG{o}{*} \PYG{n}{R}

\PYG{n}{Description}\PYG{p}{:}

\PYG{o}{.} \PYG{n}{Blackbox} \PYG{n+nb}{input} \PYG{n}{types}

\PYG{o}{.} \PYG{n}{List} \PYG{n}{of} \PYG{n}{types} \PYG{k}{for} \PYG{n}{each} \PYG{n}{variable}

\PYG{o}{.} \PYG{n}{Available} \PYG{n}{types}\PYG{p}{:}
  \PYG{o}{.} \PYG{n}{B}\PYG{p}{:} \PYG{n}{binary}
  \PYG{o}{.} \PYG{n}{I}\PYG{p}{:} \PYG{n}{integer}
  \PYG{o}{.} \PYG{n}{R}\PYG{p}{:} \PYG{n}{continuous}

\PYG{o}{.} \PYG{n}{Examples}\PYG{p}{:}
  \PYG{o}{.} \PYG{n}{BB\PYGZus{}INPUT\PYGZus{}TYPE} \PYG{o}{*} \PYG{n}{I}       \PYG{c+c1}{\PYGZsh{} all variables are integers}
  \PYG{o}{.} \PYG{n}{BB\PYGZus{}INPUT\PYGZus{}TYPE} \PYG{p}{(} \PYG{n}{R} \PYG{n}{I} \PYG{n}{B} \PYG{p}{)} \PYG{c+c1}{\PYGZsh{} for all 3 variables}
  \PYG{o}{.} \PYG{n}{BB\PYGZus{}INPUT\PYGZus{}TYPE} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{n}{B}     \PYG{c+c1}{\PYGZsh{} NOT YET SUPPORTED ( variables 1 to 3 are binary )}
  \PYG{o}{.} \PYG{n}{BB\PYGZus{}INPUT\PYGZus{}TYPE} \PYG{l+m+mi}{0} \PYG{n}{I}       \PYG{c+c1}{\PYGZsh{} NOT YET SUPPORTED ( first variable is integer )}
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{ListOfParameters:dimension-2}}
\sphinxAtStartPar
DIMENSION

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Type}\PYG{p}{:} \PYG{n}{size\PYGZus{}t}

\PYG{n}{Default}\PYG{p}{:} \PYG{l+m+mi}{0}

\PYG{n}{Description} \PYG{p}{:}

\PYG{o}{.} \PYG{n}{Number} \PYG{n}{of} \PYG{n}{variables}

\PYG{o}{.} \PYG{n}{Argument}\PYG{p}{:} \PYG{n}{one} \PYG{n}{positive} \PYG{n}{integer}

\PYG{o}{.} \PYG{n}{Example}\PYG{p}{:} \PYG{n}{DIMENSION} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxthebibliography}{AudIhaLe}
\bibitem[AuLeRoTr2021]{index:aulerotr2021}
\sphinxAtStartPar
C. Audet, S. Le Digabel, V. Rochon Montplaisir, and C. Tribes.
NOMAD version 4: Nonlinear optimization with the MADS algorithm.
Submitted.
\bibitem[AuHa2017]{index:auha2017}
\sphinxAtStartPar
C. Audet and W. Hare.
Derivative\sphinxhyphen{}Free and Blackbox Optimization.
\sphinxstyleemphasis{Springer Series in Operations Research and Financial Engineering.}
Springer International Publishing, Berlin, 2017.
\bibitem[AbAuDeLe09]{Introduction:abaudele09}
\sphinxAtStartPar
M.A. Abramson, C. Audet, J.E. Dennis, Jr., and S. Le Digabel.
OrthoMADS: A Deterministic MADS Instance with Orthogonal Directions.
\sphinxstyleemphasis{SIAM Journal on Optimization}, 20(2):948\textendash{}966, 2009.
\bibitem[AuDe2006]{Introduction:aude2006}
\sphinxAtStartPar
C. Audet and J.E. Dennis, Jr.
Mesh adaptive direct search algorithms for constrained optimization.
\sphinxstyleemphasis{SIAM Journal on Optimization}, 17(1):188\textendash{}217, 2006.
\bibitem[AuDe09a]{Introduction:aude09a}
\sphinxAtStartPar
C. Audet and J.E. Dennis, Jr.
A Progressive Barrier for Derivative\sphinxhyphen{}Free Nonlinear Programming.
\sphinxstyleemphasis{SIAM Journal on Optimization}, 20(1):445\textendash{}472, 2009.
\bibitem[AuCo04a]{HowToUseNomad:auco04a}
\sphinxAtStartPar
M.A. Abramson, C. Audet, G. Couture, J.E. Dennis, Jr., S. Le Digabel, V. Rochon Montplaisir, and C. Tribes. The NOMAD project. Software available at \sphinxurl{https://www.gerad.ca/nomad}, 2021.
\bibitem[AuDe04a]{HowToUseNomad:aude04a}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Audet and J.E. Dennis, Jr. A pattern search filter method for nonlinear programming without derivatives. \sphinxstyleemphasis{SIAM Journal on Optimization}, 14(4):980\textendash{}1010, 2004.

\end{enumerate}
\bibitem[AuIaLeDTr2014]{HowToUseNomad:auialedtr2014}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Audet and A. Ianni and S. Le Digabel and C. Tribes. Reducing the Number of Function Evaluations in Mesh Adaptive Direct Search Algorithms. \sphinxstyleemphasis{SIAM Journal on Optimization}, 24(2):621\sphinxhyphen{}642, 2014.

\end{enumerate}
\bibitem[AuBeLe08b]{AdvancedFunctionalities:aubele08b}
\sphinxAtStartPar
C. Audet, V. Béchard, and S. Le Digabel.
Nonsmooth optimization through mesh adaptive direct search and variable neighborhood search.
\sphinxstyleemphasis{Journal of Global Optimization}, 41(2):299\textendash{} 318, 2008.
\bibitem[AuCM2019]{AdvancedFunctionalities:aucm2019}
\sphinxAtStartPar
C. Audet and J. Côté\sphinxhyphen{}Massicotte.
Dynamic improvements of static surrogates in direct search optimization.
\sphinxstyleemphasis{Optimization Letters} 13, 6 (2019), 1433\sphinxhyphen{}1447
\bibitem[AuDeLe07]{AdvancedFunctionalities:audele07}
\sphinxAtStartPar
C. Audet, J.E. Dennis, Jr., and S. Le Digabel.
Parallel space decomposition of the mesh adaptive direct search algorithm.
\sphinxstyleemphasis{SIAM Journal on Optimization}, 19(3):1150\textendash{}1170, 2008.
\bibitem[BoDeFrSeToTr99a]{AdvancedFunctionalities:bodefrsetotr99a}
\sphinxAtStartPar
A.J. Booker, J.E. Dennis, Jr., P.D. Frank, D.B. Serafini, V. Torczon, and M.W. Trosset.
A Rigorous Framework for Optimization of Expensive Functions by Surrogates.
\sphinxstyleemphasis{Structural and Multidisciplinary Optimization}, 17(1):1\textendash{}13, 1999.
\bibitem[HaMl01a]{AdvancedFunctionalities:haml01a}
\sphinxAtStartPar
P. Hansen and N. Mladenović.
Variable neighborhood search: principles and applications.
\sphinxstyleemphasis{European Journal of Operational Research}, 130(3):449\textendash{}467, 2001.
\bibitem[MlHa97a]{AdvancedFunctionalities:mlha97a}
\sphinxAtStartPar
N. Mladenović and P. Hansen.
Variable neighborhood search.
\sphinxstyleemphasis{Computers and Operations Research}, 24(11):1097\textendash{}1100, 1997.
\bibitem[TaAuKoLed2016]{SgteLib:taaukoled2016}
\sphinxAtStartPar
B.Talgorn, C.Audet, M.Kokkolaras and S.Le Digabel.
Locally weighted regression models for surrogate\sphinxhyphen{}assisted design optimization.
\sphinxstyleemphasis{Optimization and Engineering}, 19(1):213\textendash{}238, 2018.
\bibitem[TaLeDKo2014]{SgteLib:taledko2014}
\sphinxAtStartPar
B.Talgorn, S.Le Digabel and M.Kokkolaras.
Statistical Surrogate Formulations for Simulation\sphinxhyphen{}Based Design Optimization.
\sphinxstyleemphasis{Journal of Mechanical Design}, 137(2):021405\textendash{}1\textendash{}021405\textendash{}18, 2015
\bibitem[AuKoLedTa2016]{SgteLib:aukoledta2016}
\sphinxAtStartPar
C.Audet, M.Kokkolaras, S.Le Digabel and B.Talgorn.
Order\sphinxhyphen{}based error for managing ensembles of surrogates in mesh adaptive direct search
\sphinxstyleemphasis{Journal of Global Optimization}, 70(3):645\textendash{}675, 2018.
\bibitem[AuLedSa2021]{SgteLib:auledsa2021}
\sphinxAtStartPar
C.Audet, S.Le Digabel and R.Saltet.
Quantifying uncertainty with ensembles of surrogates for blackbox optimization.
Rapport technique G\sphinxhyphen{}2021\sphinxhyphen{}37, Les cahiers du GERAD, 2021.
\sphinxurl{http://www.optimization-online.org/DB\_HTML/2021/07/8489.html}
\bibitem[AuSaZg2008a]{ReleaseNotes:ausazg2008a}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Audet, G. Savard, and W. Zghal. 2008.  Multiobjective Optimization Through a Series of Single\sphinxhyphen{}Objective Formulations. \sphinxstyleemphasis{SIAM Journal onOptimization} 19, 1 (2008), 188\textendash{}210

\end{enumerate}
\bibitem[AudIhaLedTrib2016]{ReleaseNotes:audihaledtrib2016}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Audet, A. Ihaddadene, S. Le Digabel, and C. Tribes. 2018. Robust optimization of noisy blackbox problems using the Mesh Adaptive Direct Search algorithm. \sphinxstyleemphasis{Optimization Letters} 12, 4 (2018), 675\textendash{}689

\end{enumerate}
\bibitem[G\sphinxhyphen{}2019\sphinxhyphen{}30]{ReleaseNotes:g-2019-30}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Audet, K.J. Dzahini, M. Kokkolaras, and S. Le Digabel. 2021.Stochastic mesh adaptive direct search for blackbox optimization using probabilistic estimates. \sphinxstyleemphasis{Technical Report} G\sphinxhyphen{}2019\sphinxhyphen{}30. Les cahiers du GERAD.  To appear in \sphinxstyleemphasis{Computational Optimization and Applications}.

\end{enumerate}
\bibitem[AuDe01a]{ReleaseNotes:aude01a}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Audet and J.E. Dennis, Jr. 2001. Pattern Search Algorithms for Mixed Variable Programming. \sphinxstyleemphasis{SIAM Journal on Optimization} 11, 3 (2001), 573\textendash{}594.

\end{enumerate}
\bibitem[AuLe2012]{ReleaseNotes:aule2012}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Audet and S. Le Digabel. 2012.  The mesh adaptive direct search algorithm for periodic variables. \sphinxstyleemphasis{Pacific Journal of Optimization} 8, 1 (2012),103\textendash{}119

\end{enumerate}
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
