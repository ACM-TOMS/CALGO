procedure approx (m, n, k, x, y, epsh) transients: (maxit, ref)
  results: (hmax, h, a) exits: (exparameter, exmaxit, exsign);
  value m, n, k, epsh;  integer m, n, k, maxit;  real epsh, hmax;
  array x, y, h, a;  integer array ref;
  label exparameter, exmaxit, exsign;
comment This procedure computes the best approximation polynomial
  in the sense of Chebychev of required degree m to a set
  of n distinct points given by their abscissas and ordinates (array
  x, y [1:n]).  The abscissas must be arranged in increasing order
  x[1] < x[2] < ··· < x[n]. The desired polynomial is even, odd,
  or mixed for k = 2, k = 1, or k = 0, respectively. It is expected
  that x[1] ≥ 0 in case of k = 2 and x[1] > 0 in case of k = 1.
  Leveling according to the exchange method described by Stiefel
  [1] is done up to a tolerance of abs(epsh). The sign of epsh
  decides whether ref is expected to supply entry data (cf. 
  parameter ref).
    maxit enters an upper limit for the number of exchange steps
  allowed and returns the number of steps actually performed.
  The parameter ref is used to carry entry data only if epsh < 0. It
  is an integer array containing the subscripts of the points to be
  used as initial reference. The lower array bound is 1, the upper
  bound (say p) is m + 2 in the case of mixed (k = 0) polynomials,
  entier ((m+3)/2) in the case of odd (k = 1), and entier
  ((m+4)/2) in the case of even (k = 2) polynomials. It is expected
  that 1 ≤ ref[1] < ref[2] < ··· < ref[p] ≤ n. Unless an initial
  reference is not explicitly given by means of the array ref and
  indicated by a value epsh < 0, the points lying next to the
  so-called Chebychev abscissas (with regard to the interval [x[1],
  x[n]]) are determined to start off the algorithm. As output, this
  parameter returns the reference belonging to the approximation
  polynomial.
    The output parameters are hmax to return the maximum deviation,
  an array h[1:n] to return the approximation errors at all
  given points, and an array a[0:m] to carry the polynomial
  coefficients. The array h containing the approximation errors is
  introduced as a formal parameter to allow a drawing of the error
  function to be made outside the procedure. This provides a means
  to look at the quality of the computed approximation and is
  recommended to the user. A totally leveled approximation
  polynomial should have an error function with well characterized 
  extrema of equal height.
    Three emergency exits are provided for extraordinary events.
  exparameter is an exit to be used when entry data are entered
  incorrectly, exmaxit is used when the best fit is not found within
  the maximum number of exchange steps allowed. In this case,
  the parameter ref denotes a new reference which may be used as
  entry data for a further call of approx. The exit exsign is used
  when the approximation errors at the points of reference do not
  alternate in sign. In this case, accuracy of the computer is 
  insufficient to generate an approximation polynomial of the required
  degree.
    Acknowledgment. The author wishes to express his appreciation 
  to Prof. Dr. W. Barth for many valuable discussions on the
  subject of Chebychev approximation.
Reference
  1. Stiefel, E. L. Numerical methods of Chebychev approximation.
  In On Numerical Approximation, R. Langer, (Ed.), U. Wisconsin
  Press, 1958, pp. 217–232;
begin
  integer i, j, p, q1, q2, r;  Boolean k0, k1;
  k0 := k = 0;  k1 := k = 1;
  q1 := if k1 then 1 else 0;
  q2 := if k0 then 1 else 2;
  for i := 0 step 1 until m do a[i] := 0;
  if ! k0 then m := entier((m-q1) * 0.5 + 0.1);
  p := m + 2;
  comment Check for properly given parameters;
  if n < p | m < 0 | ! k0 & (! k1 | x[1] <= 0)
    & (k != 2 | x[1] < 0) then go to exparameter;
  for i := 2 step 1 until n do
    if x[i] <= x[i-1] then go to exparameter;
  begin
    procedure exchange (n, p, h, epsh, z, equal);
      value n, p, epsh;
      real epsh;  integer n, p;  label equal;
      array h;  integer array z;
    comment This procedure performs the exchange technique.
      The number of points and the number of reference points
      are entered by n and p. The approximation errors at different
      points are compared relative to epsh. The subscripts of the
      points of reference are carried by z[1] ··· z[p] of the integer
      array z[0:p+1], a parameter which serves to enter the
      former and return the new reference, z[0] and z[p+1] are
      for internal use only and are expected to have the values 0
      and n + 1. If both the old and new references are equal to
      each other, a jump to the label equal occurs. No global
      quantities are contained within this procedure;
    begin
      integer i, j, l, index, indl, indr, sig, ze;
      real hz1, hzp, max, maxl, maxr;
      l := 0;  sig := -sign(h[z[1]]);
      if sig = 0 then sig := 1;
      for i := 1 step 1 until p do
      begin
        max := 0;  sig := -sig;  ze := z[i+1] - 1;
        for j := z[i-1] + 1 step 1 until ze do
        if (h[j]-max) * sig > 0 then
        begin max := h[j];  index := j end;
        if abs (max-h[z[i]]) > abs(max) * epsh then
        begin z[i] := index;  l := 1 end
      end;
      maxl := maxr := 0;
      for j := z[p] + 1 step 1 until n do
      if (maxr -h[j]) * sig > 0 then
      begin maxr := h[j];  indr := j end;
      hz1 := h[z[1]];  sig := sign(hz1);
      for j := 1 step 1 until z[1] - 1 do
      if (maxl-h[j]) * sig > 0 then
      begin maxl := h[j];  indl := j end;
      maxl := abs(maxl);  maxr := abs(maxr);
      hz1 := abs(hz1);  hzp := abs(h[z[p]]);
      if l = 0 then
      begin
        if maxl - hzp <= maxl * epsh &
        maxr - hz1 <= maxr * epsh then go to equal
      end;
      if maxl = 0 & maxr = 0 then go to Lend;
      if maxl > maxr then
      begin
        if maxl > hzp then go to shl
        else if maxr >= hz1 then go to shr
      end
      else
      begin
        if maxr > hz1 then go to shr
        else if maxl >= hzp then go to shl
      end;
      go to Lend;
shr:
      index := z[1];
      for i := 1 step 1 until p - 1 do z[i] := z[i+1];
      z[p] := indr;
      if maxl > 0 then
      for i := 1 step 1 until p - 1 do
      begin
        if abs (h[indl]) >= abs (h[z[i]]) then
        begin j := z[i];  z[i] := indl;  indl := index;
          index := j end
        else go to Lend
      end;
      go to Lend;
shl:
      index := z[p];
      for i := p step - 1 until 2 do z[i] := z[i-1];
      z[1] := indl;
      if maxr > 0 then
      for i := p step -1 until 2 do
      begin
        if abs (h[indr]) >= abs(h[z[i]]) then
        begin j := z[i];  z[i] := indr;  indr := index;
          index := j end
        else go to Lend
      end;
Lend:
    end procedure exchange;
    real arg, max, pi, q, s, t, dt, x1 , xa, xe;  Boolean b1, b2;
    array xx[1:n], aa, daa[0:m], c, d [1:p];
    integer array z[0:p+1];
    comment Set up of initial reference;
    z[0] := 0;  z[p+1] := n + 1;
    if epsh < 0 then
    begin
      j := 0;
      for i := 1 step 1 until p do
      begin
        r := z[i] := ref[i];
        if j < r then j := r else go to exparameter
      end;
      if j > n then go to exparameter;
      epsh := abs (epsh);  go to m1
    end;
    pi := 3.14159265;  x1 := x[1];  xe := x[n];
    if k0 then
    begin xa := xe + x1;  xe := xe - x1;
      arg := pi/(m+1) end
    else
    begin xa := 0;  xe := xe + xe;
      arg := pi/(2*(m+1)+q1) end;
    for j := p step -1 until 1 do
    begin
      x1 := xa + xe * cos (arg * (p-j));  r := z[j+1];
      for i := r-1 step -1 until 2 do
      if x[i] + x[i-1] <= x1 then go to m0;
      i := 1;
m0:
      z[j] := if r > i then i else r - 1
    end;
    if z[1] >= 1 then go to m1;
    for j := 1,j + 1 while z[j] < j do z[j] := j;
m1:
    for i := 0 step 1 until m do aa[i] := 0;
    for i := 1 step 1 until n do
    begin h[i] := y[i];  q := x[i];
      xx[i] := if k0 then q else q * q
    end;
    b1 := b2 := false;  r := -1;  t := 0;
iterat:
    r := r + 1;  s := 1.0;
    comment Computation of the divided difference schemes;
    if k1 then
    begin
      for i := 1 step 1 until p do
      begin
        s := -s;  j := z[i];  q := x[j];
        c[i] := (h[j] + s * t)/q;  d[i] := s/q
      end
    end
    else
    for i := 1 step 1 until p do
    begin s := -s;  c[i] := h[z[i]] + s * t;  d[i] := s end;
    for i := 2 step 1 until p do
      for j := p step -1 until i do
    begin
      q := xx[z[j]] - xx[z[1+j-i]];
      c[j] := (c[j] - c[j-1])/q;
      d[j] := (d[j] - d[j-1])/q
    end;
    dt := -c[p]/d[p];  t := t + dt;
    comment Computation of the polynomial coefficients;
    for i := m step -1 until 0 do
    begin
      daa[i] := c[i+1] + dt * d[i+1];  q := xx[z[i+1]];
      for j := i step 1 until m - 1 do
        daa[j] := daa[j] - q * daa[j+1]
    end;
    for i := 0 step 1 until m do aa[i] := aa[i] + daa[i];
    comment Evaluation of the polynomial to get the approximation
            errors;
    max := 0;
    for i := 1 step 1 until n do
    begin
      s := aa[m];  q := xx[i];
      for j := m - 1 step -1 until 0 do s := s * q + aa[j];
      if k1 then s := s * x[i];
      q := h[i] := y[i] - s;
      if abs (q) > max then max := abs(q)
    end;
    comment Test for alternating signs;
    j := -sign (h[z[1]]);
    for i := 2 step 1 until p do
      if sign (h[z[i]]) = j then j := -j else
      begin b1 := true;  go to m2 end;
    comment Search for another reference;
    exchange (n, p, h, epsh, z, m2);
    if r < maxit then go to iterat else b2 := true;
    comment Results to output parameters;
m2:
    for i := 0 step 1 until m do a[q1+i*q2] := aa[i];
    for i := 1 step 1 until p do ref[i] := z[i];
    hmax := max;  maxit := r;
    if b1 then go to exsign;
    if b2 then go to exmaxit
  end
end procedure approx;
