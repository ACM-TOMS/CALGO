\documentclass[11pt,a4paper]{report}
\def\bl{\mbox{}\newline\mbox{}\newline{}}
\usepackage{color}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{ifthen}
\usepackage{makeidx}
\usepackage{hyperref}
\newcommand{\hide}[2]{
\ifthenelse{\equal{#1}{inherited}}%
{}%
{}%
}
\newcommand{\entityintro}[3]{%
  \hbox to \hsize{%
    \vbox{%
      \hbox to .2in{}%
    }%
    {\bf #1}%
    \dotfill\pageref{#2}%
  }
  \makebox[\hsize]{%
    \parbox{.4in}{}%
    \parbox[l]{5in}{%
      \vspace{1mm}\it%
      #3%
      \vspace{1mm}%
    }%
  }%
}
\newcommand{\isep}[0]{%
\setlength{\itemsep}{-.4ex}
}
\newcommand{\sld}[0]{%
\setlength{\topsep}{0em}
\setlength{\partopsep}{0em}
\setlength{\parskip}{0em}
\setlength{\parsep}{-1em}
}
\newcommand{\headref}[3]{%
\ifthenelse{#1 = 1}{%
\addcontentsline{toc}{section}{\hspace{\qquad}\protect\numberline{}{#3}}%
}{}%
\ifthenelse{#1 = 2}{%
\addcontentsline{toc}{subsection}{\hspace{\qquad}\protect\numerline{}{#3}}%
}{}%
\ifthenelse{#1 = 3}{%
\addcontentsline{toc}{subsubsection}{\hspace{\qquad}\protect\numerline{}{#3}}%
}{}%
\label{#3}%
\makebox[\textwidth][l]{#2 #3}%
}%
\newcommand{\membername}[1]{{\it #1}\linebreak}
\newcommand{\divideents}[1]{\vskip -1em\indent\rule{2in}{.5mm}}
\newcommand{\refdefined}[1]{
\expandafter\ifx\csname r@#1\endcsname\relax
\relax\else
{$($in \ref{#1}, page \pageref{#1}$)$}\fi}
\usepackage{color}
\definecolor{Light}{gray}{.90}
\date{\today}
\pagestyle{myheadings}
\addtocontents{toc}{\protect\thispagestyle{empty}}
\addtocontents{toc}{\protect\def\protect\packagename{}}
\addtocontents{toc}{\protect\def\protect\classname{}}
\oddsidemargin 0in
\evensidemargin 0in
\topmargin -.3in
\chardef\bslash=`\\
\textheight 9.4in
\textwidth 6.5in
\title{JMarkov Reference Manual}
\author{Germ{\'a}n Ria{\~n}o, Julio G{\'o}ez, Juan Fernando P{\'e}rez y Andr{\'e}s Sarmiento}
\makeindex
%%%%% Input preamble file
\input{preamble.tex}
%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle
\sloppy
\raggedright
\addtocontents{toc}{\protect\markboth{Contents}{Contents}}
\tableofcontents
\chapter*{Introduction}{
 \addcontentsline{toc}{chapter}{Introduction}
\thispagestyle{empty}
\markboth{Introduction}{Introduction}
jMarkov is a series of packages designed to model and optimize stochastic models. It consists of various modules:\begin{itemize}
\item{\vskip -.8ex JMarkov allows the user to create any size Markov Models by defining the rules of the system. This is achieved extending a given class called \hyperlink{jmarkov.SimpleMarkovProcess}{SimpleMarkovProcess}{\small 
\refdefined{jmarkov.SimpleMarkovProcess}}, and implementing three functions that describe the dynamics of the system. The user does not need to know the details of the implementation, but rather to describe the dynamics of the system in terms of the states that the system can be and the events that can alter the current state. The user can have freedom to override in many ways the default behavior of the system. The basic steps that the user should follow are\begin{itemize}
\item{\vskip -.8ex Define what the states are by implementing the class \hyperlink{jmarkov.basic.State}{State}{\small 
\refdefined{jmarkov.basic.State}} or the class \hyperlink{jmarkov.basic.PropertiesState}{PropertiesState}{\small 
\refdefined{jmarkov.basic.PropertiesState}}.}
\item{\vskip -.8ex Define what the Events are. This can be accomplished either implementing the \hyperlink{jmarkov.basic.Event}{Event}{\small 
\refdefined{jmarkov.basic.Event}} class.}
\item{\vskip -.8ex Extend the class \hyperlink{jmarkov.MarkovProcess}{MarkovProcess}{\small 
\refdefined{jmarkov.MarkovProcess}} or \hyperlink{jmarkov.SimpleMarkovProcess}{SimpleMarkovProcess}{\small 
\refdefined{jmarkov.SimpleMarkovProcess}}, defining the three following items\begin{itemize}
\item{\vskip -.8ex Define which events can occur when the system is in each state. This is accomplished by implementing the method \hyperlink{jmarkov.SimpleMarkovProcess.active(S, E)}{active}{\small 
\refdefined{jmarkov.SimpleMarkovProcess.active(S, E)}}.}
\item{\vskip -.8ex Define what are the new states when an event occurs. This is accomplished implementing the method \hyperlink{jmarkov.SimpleMarkovProcess.dests(S, E)}{dests}{\small 
\refdefined{jmarkov.SimpleMarkovProcess.dests(S, E)}}.}
\item{\vskip -.8ex Define what is the the rate at which each of these events occur, by implementing the method \hyperlink{jmarkov.SimpleMarkovProcess.rate(S, S, E)}{rate}{\small 
\refdefined{jmarkov.SimpleMarkovProcess.rate(S, S, E)}}.}
\end{itemize}
}
\end{itemize}
}
\item{\vskip -.8ex jQBD allows the user to model quisi-birth and death processes.}
\item{\vskip -.8ex jPhase allows the user to represent and manipulate phase type distributions. See jPhase User's Manual in the file \hyperref{jPhaseManual.pdf}{}{}{jPhaseManual.pdf} (at jPhaseManual.pdf).}
\item{\vskip -.8ex jMDP allows the user to design optimal control for discrete and continuous Markov Chains (Markov Decision Processes) and also deterministic discrete dynamic programs. See jMDP User's Manual in the file \hyperref{jMDPManual.pdf}{}{}{jMDPManual.pdf} (at jMDPManual.pdf).}
\end{itemize}
  \input{intro.tex} jMarkov is a proyect created at Universidad de los Andes by the \hyperref{http://copa.uniandes.edu.co}{}{}{COPA} (at http://copa.uniandes.edu.co) research group.}
\chapter*{Class Hierarchy}{
\thispagestyle{empty}
\markboth{Class Hierarchy}{Class Hierarchy}
\addcontentsline{toc}{chapter}{Class Hierarchy}
\section*{Classes}
\hspace{0.0cm} $\bullet$ java.lang.Object {\tiny \refdefined{java.lang.Object}} \\
\hspace{1.0cm} $\bullet$ Jama.Matrix {\tiny \refdefined{Jama.Matrix}} \\
\hspace{2.0cm} $\bullet$ jphase.MarkovMatrix {\tiny \refdefined{jphase.MarkovMatrix}} \\
\hspace{1.0cm} $\bullet$ java.lang.Enum {\tiny \refdefined{java.lang.Enum}} \\
\hspace{2.0cm} $\bullet$ jmarkov.MarkovProcess.Status {\tiny \refdefined{jmarkov.MarkovProcess.Status}} \\
\hspace{2.0cm} $\bullet$ jmarkov.solvers.MtjSolver.EnumPrecond {\tiny \refdefined{jmarkov.solvers.MtjSolver.EnumPrecond}} \\
\hspace{2.0cm} $\bullet$ jmarkov.solvers.MtjSolver.EnumSolver {\tiny \refdefined{jmarkov.solvers.MtjSolver.EnumSolver}} \\
\hspace{1.0cm} $\bullet$ jmarkov.DebugReporter {\tiny \refdefined{jmarkov.DebugReporter}} \\
\hspace{1.0cm} $\bullet$ jmarkov.MarkovProcess {\tiny \refdefined{jmarkov.MarkovProcess}} \\
\hspace{2.0cm} $\bullet$ jmarkov.SimpleMarkovProcess {\tiny \refdefined{jmarkov.SimpleMarkovProcess}} \\
\hspace{3.0cm} $\bullet$ jmarkov.GeomProcess {\tiny \refdefined{jmarkov.GeomProcess}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.Action {\tiny \refdefined{jmarkov.basic.Action}} \\
\hspace{2.0cm} $\bullet$ jmarkov.basic.PropertiesAction {\tiny \refdefined{jmarkov.basic.PropertiesAction}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.ActionsSet {\tiny \refdefined{jmarkov.basic.ActionsSet}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.DecisionRule {\tiny \refdefined{jmarkov.basic.DecisionRule}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.Event {\tiny \refdefined{jmarkov.basic.Event}} \\
\hspace{2.0cm} $\bullet$ jmarkov.basic.PropertiesEvent {\tiny \refdefined{jmarkov.basic.PropertiesEvent}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.EventsSet {\tiny \refdefined{jmarkov.basic.EventsSet}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.Policy {\tiny \refdefined{jmarkov.basic.Policy}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.Solution {\tiny \refdefined{jmarkov.basic.Solution}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.State {\tiny \refdefined{jmarkov.basic.State}} \\
\hspace{2.0cm} $\bullet$ jmarkov.GeomRelState {\tiny \refdefined{jmarkov.GeomRelState}} \\
\hspace{2.0cm} $\bullet$ jmarkov.GeomState {\tiny \refdefined{jmarkov.GeomState}} \\
\hspace{2.0cm} $\bullet$ jmarkov.basic.PropertiesState {\tiny \refdefined{jmarkov.basic.PropertiesState}} \\
\hspace{2.0cm} $\bullet$ jmarkov.basic.StateC {\tiny \refdefined{jmarkov.basic.StateC}} \\
\hspace{2.0cm} $\bullet$ jmarkov.basic.StateEvent {\tiny \refdefined{jmarkov.basic.StateEvent}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.StatesSet {\tiny \refdefined{jmarkov.basic.StatesSet}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.Transition {\tiny \refdefined{jmarkov.basic.Transition}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.TransitionsSet {\tiny \refdefined{jmarkov.basic.TransitionsSet}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.ValueFunction {\tiny \refdefined{jmarkov.basic.ValueFunction}} \\
\hspace{1.0cm} $\bullet$ jmarkov.jmdp.MDP {\tiny \refdefined{jmarkov.jmdp.MDP}} \\
\hspace{2.0cm} $\bullet$ jmarkov.jmdp.FiniteMDP {\tiny \refdefined{jmarkov.jmdp.FiniteMDP}} \\
\hspace{3.0cm} $\bullet$ jmarkov.jmdp.FiniteDP {\tiny \refdefined{jmarkov.jmdp.FiniteDP}} \\
\hspace{3.0cm} $\bullet$ jmarkov.jmdp.FiniteMDPEv {\tiny \refdefined{jmarkov.jmdp.FiniteMDPEv}} \\
\hspace{2.0cm} $\bullet$ jmarkov.jmdp.InfiniteMDP {\tiny \refdefined{jmarkov.jmdp.InfiniteMDP}} \\
\hspace{3.0cm} $\bullet$ jmarkov.jmdp.CTMDP {\tiny \refdefined{jmarkov.jmdp.CTMDP}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.CTMDPEv {\tiny \refdefined{jmarkov.jmdp.CTMDPEv}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.CTMDPEvA {\tiny \refdefined{jmarkov.jmdp.CTMDPEvA}} \\
\hspace{3.0cm} $\bullet$ jmarkov.jmdp.DTMDP {\tiny \refdefined{jmarkov.jmdp.DTMDP}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.CT2DTConverter {\tiny \refdefined{jmarkov.jmdp.CT2DTConverter}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.DTMDPEv {\tiny \refdefined{jmarkov.jmdp.DTMDPEv}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.DTMDPEvA {\tiny \refdefined{jmarkov.jmdp.DTMDPEvA}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.StochasticShortestPath {\tiny \refdefined{jmarkov.jmdp.StochasticShortestPath}} \\
\hspace{1.0cm} $\bullet$ jmarkov.jmdp.solvers.ProbabilitySolver {\tiny \refdefined{jmarkov.jmdp.solvers.ProbabilitySolver}} \\
\hspace{1.0cm} $\bullet$ jmarkov.jmdp.solvers.Solver {\tiny \refdefined{jmarkov.jmdp.solvers.Solver}} \\
\hspace{2.0cm} $\bullet$ jmarkov.jmdp.solvers.AbstractFiniteSolver {\tiny \refdefined{jmarkov.jmdp.solvers.AbstractFiniteSolver}} \\
\hspace{3.0cm} $\bullet$ jmarkov.jmdp.solvers.FiniteSolver {\tiny \refdefined{jmarkov.jmdp.solvers.FiniteSolver}} \\
\hspace{2.0cm} $\bullet$ jmarkov.jmdp.solvers.AbstractInfiniteSolver {\tiny \refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}} \\
\hspace{3.0cm} $\bullet$ jmarkov.jmdp.solvers.AbstractAverageSolver {\tiny \refdefined{jmarkov.jmdp.solvers.AbstractAverageSolver}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.solvers.LPBCLAverageSolver {\tiny \refdefined{jmarkov.jmdp.solvers.LPBCLAverageSolver}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.solvers.MpsLpAverageSolver {\tiny \refdefined{jmarkov.jmdp.solvers.MpsLpAverageSolver}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.solvers.RelativeValueIterationSolver {\tiny \refdefined{jmarkov.jmdp.solvers.RelativeValueIterationSolver}} \\
\hspace{3.0cm} $\bullet$ jmarkov.jmdp.solvers.AbstractDiscountedSolver {\tiny \refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.solvers.LPBCLDiscountedSolver {\tiny \refdefined{jmarkov.jmdp.solvers.LPBCLDiscountedSolver}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.solvers.MpsLpDiscountedSolver {\tiny \refdefined{jmarkov.jmdp.solvers.MpsLpDiscountedSolver}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.solvers.PolicyIterationSolver {\tiny \refdefined{jmarkov.jmdp.solvers.PolicyIterationSolver}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.solvers.ValueIterationSolver {\tiny \refdefined{jmarkov.jmdp.solvers.ValueIterationSolver}} \\
\hspace{3.0cm} $\bullet$ jmarkov.jmdp.solvers.AbstractTotalSolver {\tiny \refdefined{jmarkov.jmdp.solvers.AbstractTotalSolver}} \\
\hspace{4.0cm} $\bullet$ jmarkov.jmdp.solvers.StochasticShortestPathSolver {\tiny \refdefined{jmarkov.jmdp.solvers.StochasticShortestPathSolver}} \\
\hspace{1.0cm} $\bullet$ jmarkov.solvers.Solver {\tiny \refdefined{jmarkov.solvers.Solver}} \\
\hspace{2.0cm} $\bullet$ jmarkov.solvers.GeometricSolver {\tiny \refdefined{jmarkov.solvers.GeometricSolver}} \\
\hspace{3.0cm} $\bullet$ jmarkov.solvers.MtjLogRedSolver {\tiny \refdefined{jmarkov.solvers.MtjLogRedSolver}} \\
\hspace{2.0cm} $\bullet$ jmarkov.solvers.GeometrixSolver {\tiny \refdefined{jmarkov.solvers.GeometrixSolver}} \\
\hspace{2.0cm} $\bullet$ jmarkov.solvers.SteadyStateSolver {\tiny \refdefined{jmarkov.solvers.SteadyStateSolver}} \\
\hspace{3.0cm} $\bullet$ jmarkov.solvers.JamaSolver {\tiny \refdefined{jmarkov.solvers.JamaSolver}} \\
\hspace{3.0cm} $\bullet$ jmarkov.solvers.MtjSolver {\tiny \refdefined{jmarkov.solvers.MtjSolver}} \\
\hspace{2.0cm} $\bullet$ jmarkov.solvers.TransientSolver {\tiny \refdefined{jmarkov.solvers.TransientSolver}} \\
\hspace{3.0cm} $\bullet$ jmarkov.solvers.JamaTransientSolver {\tiny \refdefined{jmarkov.solvers.JamaTransientSolver}} \\
\hspace{1.0cm} $\bullet$ jphase.AbstractContPhaseVar {\tiny \refdefined{jphase.AbstractContPhaseVar}} \\
\hspace{2.0cm} $\bullet$ jphase.DenseContPhaseVar {\tiny \refdefined{jphase.DenseContPhaseVar}} \\
\hspace{2.0cm} $\bullet$ jphase.ErlangCoxianVar {\tiny \refdefined{jphase.ErlangCoxianVar}} \\
\hspace{2.0cm} $\bullet$ jphase.HyperErlangVar {\tiny \refdefined{jphase.HyperErlangVar}} \\
\hspace{2.0cm} $\bullet$ jphase.SparseContPhaseVar {\tiny \refdefined{jphase.SparseContPhaseVar}} \\
\hspace{1.0cm} $\bullet$ jphase.AbstractDiscPhaseVar {\tiny \refdefined{jphase.AbstractDiscPhaseVar}} \\
\hspace{2.0cm} $\bullet$ jphase.DenseDiscPhaseVar {\tiny \refdefined{jphase.DenseDiscPhaseVar}} \\
\hspace{2.0cm} $\bullet$ jphase.SparseDiscPhaseVar {\tiny \refdefined{jphase.SparseDiscPhaseVar}} \\
\hspace{1.0cm} $\bullet$ jphase.MatrixUtils {\tiny \refdefined{jphase.MatrixUtils}} \\
\hspace{1.0cm} $\bullet$ jphase.PhaseVarSet {\tiny \refdefined{jphase.PhaseVarSet}} \\
\hspace{1.0cm} $\bullet$ jphase.Poly {\tiny \refdefined{jphase.Poly}} \\
\hspace{1.0cm} $\bullet$ jphase.SuperErlang {\tiny \refdefined{jphase.SuperErlang}} \\
\hspace{1.0cm} $\bullet$ jphase.Term {\tiny \refdefined{jphase.Term}} \\
\hspace{1.0cm} $\bullet$ jphase.Utils {\tiny \refdefined{jphase.Utils}} \\
\hspace{1.0cm} $\bullet$ jphase.fit.ContPhaseFitter {\tiny \refdefined{jphase.fit.ContPhaseFitter}} \\
\hspace{2.0cm} $\bullet$ jphase.fit.MLContPhaseFitter {\tiny \refdefined{jphase.fit.MLContPhaseFitter}} \\
\hspace{3.0cm} $\bullet$ jphase.fit.EMHyperErlangFit {\tiny \refdefined{jphase.fit.EMHyperErlangFit}} \\
\hspace{3.0cm} $\bullet$ jphase.fit.EMHyperExpoFit {\tiny \refdefined{jphase.fit.EMHyperExpoFit}} \\
\hspace{3.0cm} $\bullet$ jphase.fit.EMPhaseFit {\tiny \refdefined{jphase.fit.EMPhaseFit}} \\
\hspace{2.0cm} $\bullet$ jphase.fit.MomentsContPhaseFitter {\tiny \refdefined{jphase.fit.MomentsContPhaseFitter}} \\
\hspace{3.0cm} $\bullet$ jphase.fit.MomentsACPH2Fit {\tiny \refdefined{jphase.fit.MomentsACPH2Fit}} \\
\hspace{3.0cm} $\bullet$ jphase.fit.MomentsACPHFit {\tiny \refdefined{jphase.fit.MomentsACPHFit}} \\
\hspace{3.0cm} $\bullet$ jphase.fit.MomentsECCompleteFit {\tiny \refdefined{jphase.fit.MomentsECCompleteFit}} \\
\hspace{3.0cm} $\bullet$ jphase.fit.MomentsECPositiveFit {\tiny \refdefined{jphase.fit.MomentsECPositiveFit}} \\
\hspace{1.0cm} $\bullet$ jphase.fit.DiscPhaseFitter {\tiny \refdefined{jphase.fit.DiscPhaseFitter}} \\
\hspace{2.0cm} $\bullet$ jphase.fit.MLDiscPhaseFitter {\tiny \refdefined{jphase.fit.MLDiscPhaseFitter}} \\
\hspace{2.0cm} $\bullet$ jphase.fit.MomentsDiscPhaseFitter {\tiny \refdefined{jphase.fit.MomentsDiscPhaseFitter}} \\
\hspace{3.0cm} $\bullet$ jphase.fit.MomentsADPH2Fit {\tiny \refdefined{jphase.fit.MomentsADPH2Fit}} \\
\hspace{1.0cm} $\bullet$ jphase.fit.FitterUtils {\tiny \refdefined{jphase.fit.FitterUtils}} \\
\hspace{1.0cm} $\bullet$ jphase.generator.GeneratorUtils {\tiny \refdefined{jphase.generator.GeneratorUtils}} \\
\hspace{1.0cm} $\bullet$ jphase.generator.PhaseGenerator {\tiny \refdefined{jphase.generator.PhaseGenerator}} \\
\hspace{2.0cm} $\bullet$ jphase.generator.NeutsContPHGenerator {\tiny \refdefined{jphase.generator.NeutsContPHGenerator}} \\
\hspace{2.0cm} $\bullet$ jphase.generator.NeutsDiscPHGenerator {\tiny \refdefined{jphase.generator.NeutsDiscPHGenerator}} \\
\section*{Interfaces}
\hspace{0.0cm} $\bullet$ java.lang.Iterable {\tiny \refdefined{java.lang.Iterable}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.Actions {\tiny \refdefined{jmarkov.basic.Actions}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.Events {\tiny \refdefined{jmarkov.basic.Events}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.States {\tiny \refdefined{jmarkov.basic.States}} \\
\hspace{0.0cm} $\bullet$ jmarkov.basic.JMarkovElement {\tiny \refdefined{jmarkov.basic.JMarkovElement}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.PropertiesElement {\tiny \refdefined{jmarkov.basic.PropertiesElement}} \\
\hspace{1.0cm} $\bullet$ jmarkov.basic.Transitions {\tiny \refdefined{jmarkov.basic.Transitions}} \\
\hspace{1.0cm} $\bullet$ jphase.PhaseVar {\tiny \refdefined{jphase.PhaseVar}} \\
\hspace{2.0cm} $\bullet$ jphase.ContPhaseVar {\tiny \refdefined{jphase.ContPhaseVar}} \\
\hspace{2.0cm} $\bullet$ jphase.DiscPhaseVar {\tiny \refdefined{jphase.DiscPhaseVar}} \\
\hspace{0.0cm} $\bullet$ jmarkov.jmdp.solvers.LPSolver {\tiny \refdefined{jmarkov.jmdp.solvers.LPSolver}} \\
\hspace{1.0cm} $\bullet$ jmarkov.jmdp.solvers.MpsLpSolver {\tiny \refdefined{jmarkov.jmdp.solvers.MpsLpSolver}} \\
\hspace{0.0cm} $\bullet$ jphase.fit.PhaseFitter {\tiny \refdefined{jphase.fit.PhaseFitter}} \\
\section*{Exceptions}
\hspace{0.0cm} $\bullet$ java.lang.Object {\tiny \refdefined{java.lang.Object}} \\
\hspace{1.0cm} $\bullet$ java.lang.Throwable {\tiny \refdefined{java.lang.Throwable}} \\
\hspace{2.0cm} $\bullet$ java.lang.Exception {\tiny \refdefined{java.lang.Exception}} \\
\hspace{3.0cm} $\bullet$ java.lang.RuntimeException {\tiny \refdefined{java.lang.RuntimeException}} \\
\hspace{4.0cm} $\bullet$ jmarkov.basic.exceptions.NonStochasticException {\tiny \refdefined{jmarkov.basic.exceptions.NonStochasticException}} \\
\hspace{3.0cm} $\bullet$ jmarkov.basic.exceptions.SolverException {\tiny \refdefined{jmarkov.basic.exceptions.SolverException}} \\
\hspace{4.0cm} $\bullet$ jmarkov.basic.exceptions.NotUnichainException {\tiny \refdefined{jmarkov.basic.exceptions.NotUnichainException}} \\
\hspace{4.0cm} $\bullet$ jmarkov.basic.exceptions.StructureException {\tiny \refdefined{jmarkov.basic.exceptions.StructureException}} \\
}
\gdef\packagename{}
\gdef\classname{}
\newpage
\def\packagename{jmarkov}
\chapter{\bf Package jmarkov}{
\thispagestyle{empty}
\label{jmarkov}\hypertarget{jmarkov}{}
\markboth{\protect\packagename}{\protect\packagename}
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Classes}
\entityintro{DebugReporter}{jmarkov.DebugReporter}{A debug reporter is used to report debug Information from a program.}
\entityintro{GeomProcess}{jmarkov.GeomProcess}{The class GeomProcess represents a continuos or discrete Quasi Birth and Death process.}
\entityintro{GeomRelState}{jmarkov.GeomRelState}{This class is used to build destinations which are relative to a given GeomState.}
\entityintro{GeomState}{jmarkov.GeomState}{The actual Geometric model is build using this class.}
\entityintro{MarkovProcess}{jmarkov.MarkovProcess}{The abstract class SimpleMarkovProcess represents a Continuous or Discrete Time Markov Chain.}
\entityintro{MarkovProcess.Status}{jmarkov.MarkovProcess.Status}{Status variables}
\entityintro{SimpleMarkovProcess}{jmarkov.SimpleMarkovProcess}{}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
Provides the basic elements to model continuous time Markov chains (CTMC). An application should extend the class \hyperlink{jmarkov.MarkovProcess}{}{\small 
\refdefined{jmarkov.MarkovProcess}}, \hyperlink{jmarkov.basic.State}{}{\small 
\refdefined{jmarkov.basic.State}} and, optionaly the class \hyperlink{jmarkov.basic.Event}{}{\small 
\refdefined{jmarkov.basic.Event}}. The package also includes facility to model Matrix Geometrix Systems. For overviews, tutorials, examples, guides, and tool documentation, please see:

\begin{itemize}
\item{\vskip -.8ex \hyperref{../MarkovPack.pdf}{}{}{JMarkov User's Manual} (at ../MarkovPack.pdf). }
\item{\vskip -.8ex \hyperref{http://copa.uniandes.edu.co}{}{}{COPA group WEB page.} (at http://copa.uniandes.edu.co) }
\end{itemize}
\mbox{}\\ \rule{\hsize}{.7mm}
\vskip .1in
\newpage
\markboth{\protect\packagename \hspace{.02in} -- \protect\classname}{\protect\packagename \hspace{.02in} -- \protect\classname}
\section{Classes}{
\gdef\classname{DebugReporter}
\subsection{\label{jmarkov.DebugReporter}\index{DebugReporter}{\bf {\it Class} DebugReporter}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.DebugReporter}{}\vskip .1in 
A debug reporter is used to report debug Information from a program. It has an internal integer number, called the Debuglevel, where 0 means no debug information will be reporter and 5 a lot of verbose information will be reported. The information is reported to standard output, to a PrintWriter (which can be associated with a file), or to a TextPanel which can be included in a graphic user interface.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class DebugReporter
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.DebugReporter(int)}{{\bf DebugReporter(int)}} Creates a debug reporter that will report to standard I/O.\\
\hyperlink{jmarkov.DebugReporter(java.io.PrintWriter)}{{\bf DebugReporter(PrintWriter)}} Creates a debug reporter that will send its output to the given PrintWriter.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.DebugReporter.debug(int, java.lang.String)}{{\bf debug(int, String)}} Reports this debug information.\\
\hyperlink{jmarkov.DebugReporter.debug(int, java.lang.String, boolean)}{{\bf debug(int, String, boolean)}} Reports this debug information.\\
\hyperlink{jmarkov.DebugReporter.debug(int, java.lang.String, boolean, boolean)}{{\bf debug(int, String, boolean, boolean)}} Reports this debug information.\\
\hyperlink{jmarkov.DebugReporter.getCurLevel()}{{\bf getCurLevel()}} \\
\hyperlink{jmarkov.DebugReporter.getDebugLevel()}{{\bf getDebugLevel()}} \\
\hyperlink{jmarkov.DebugReporter.setCurLevel(int)}{{\bf setCurLevel(int)}} Sets the debug level, where level=0 means no debug info, level = 5 verbose info.\\
\hyperlink{jmarkov.DebugReporter.setDebugLevel(int)}{{\bf setDebugLevel(int)}} Sets the debug level, where level=0 means no debug info, level = 5 verbose info.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{DebugReporter(int)}
\hypertarget{jmarkov.DebugReporter(int)}{\membername{DebugReporter}}
{\tt public\ {\bf DebugReporter}( {\tt int} {\bf initDebugLevel} )
\label{jmarkov.DebugReporter(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a debug reporter that will report to standard I/O.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initDebugLevel} -- Initial debug level}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{DebugReporter}
\item{\vskip -1.9ex 
\index{DebugReporter(PrintWriter)}
\hypertarget{jmarkov.DebugReporter(java.io.PrintWriter)}{\membername{DebugReporter}}
{\tt public\ {\bf DebugReporter}( {\tt java.io.PrintWriter} {\bf dbgWt} )
\label{jmarkov.DebugReporter(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a debug reporter that will send its output to the given PrintWriter.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt dbgWt} -- the PrintWriter where the debug information will be sent.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{debug(int, String)}
\hypertarget{jmarkov.DebugReporter.debug(int, java.lang.String)}{\membername{debug}}
{\tt public void\ {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s} )
\label{jmarkov.DebugReporter.debug(int, java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Reports this debug information. Newline and indent are true.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- Use level=0 for very important things, level=5 less important.}
   \item{
\sld
{\tt s} -- The String to report}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.DebugReporter.debug(int, java.lang.String, boolean, boolean)}{DebugReporter.debug(int,\allowbreak String,\allowbreak boolean,\allowbreak boolean)}} {\small 
\refdefined{jmarkov.DebugReporter.debug(int, java.lang.String, boolean, boolean)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{debug}
\item{\vskip -1.9ex 
\index{debug(int, String, boolean)}
\hypertarget{jmarkov.DebugReporter.debug(int, java.lang.String, boolean)}{\membername{debug}}
{\tt public void\ {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
\label{jmarkov.DebugReporter.debug(int, java.lang.String, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Reports this debug information. Info is indented if newline is selected.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- Use level=0 for very important things, level=5 less important.}
   \item{
\sld
{\tt s} -- The String to report}
   \item{
\sld
{\tt newline} -- whether newline is added at the end.}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.DebugReporter.debug(int, java.lang.String, boolean, boolean)}{DebugReporter.debug(int,\allowbreak String,\allowbreak boolean,\allowbreak boolean)}} {\small 
\refdefined{jmarkov.DebugReporter.debug(int, java.lang.String, boolean, boolean)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{debug}
\item{\vskip -1.9ex 
\index{debug(int, String, boolean, boolean)}
\hypertarget{jmarkov.DebugReporter.debug(int, java.lang.String, boolean, boolean)}{\membername{debug}}
{\tt public void\ {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
\label{jmarkov.DebugReporter.debug(int, java.lang.String, boolean, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Reports this debug information.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- Use level=0 for very important things, level=5 less important.}
   \item{
\sld
{\tt s} -- The String to report}
   \item{
\sld
{\tt newline} -- whether newline is added at the end.}
   \item{
\sld
{\tt indent} -- whwether information should go indented according to debug level.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getCurLevel}
\item{\vskip -1.9ex 
\index{getCurLevel()}
\hypertarget{jmarkov.DebugReporter.getCurLevel()}{\membername{getCurLevel}}
{\tt public final int\ {\bf getCurLevel}(  )
\label{jmarkov.DebugReporter.getCurLevel()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the curLevel. 
}%end item
\end{itemize}
}%end item
\divideents{getDebugLevel}
\item{\vskip -1.9ex 
\index{getDebugLevel()}
\hypertarget{jmarkov.DebugReporter.getDebugLevel()}{\membername{getDebugLevel}}
{\tt public synchronized int\ {\bf getDebugLevel}(  )
\label{jmarkov.DebugReporter.getDebugLevel()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
current debug level, where level=0 means no debug info and level = 5 verbose info. 
}%end item
\end{itemize}
}%end item
\divideents{setCurLevel}
\item{\vskip -1.9ex 
\index{setCurLevel(int)}
\hypertarget{jmarkov.DebugReporter.setCurLevel(int)}{\membername{setCurLevel}}
{\tt public final void\ {\bf setCurLevel}( {\tt int} {\bf curLevel} )
\label{jmarkov.DebugReporter.setCurLevel(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the debug level, where level=0 means no debug info, level = 5 verbose info.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt curLevel} -- The curLevel to set to.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setDebugLevel}
\item{\vskip -1.9ex 
\index{setDebugLevel(int)}
\hypertarget{jmarkov.DebugReporter.setDebugLevel(int)}{\membername{setDebugLevel}}
{\tt public synchronized void\ {\bf setDebugLevel}( {\tt int} {\bf level} )
\label{jmarkov.DebugReporter.setDebugLevel(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the debug level, where level=0 means no debug info, level = 5 verbose info.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- debug level}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{GeomProcess}
\subsection{\label{jmarkov.GeomProcess}\index{GeomProcess}{\bf {\it Class} GeomProcess}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.GeomProcess}{}\vskip .1in 
The class GeomProcess represents a continuos or discrete Quasi Birth and Death process. This class extends the class SimpleMarkovProcess. The class generate the G matrix through the Logarithmic Reduction algorithm. The user should extend State to generate Sub-States.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class GeomProcess
\\ {\bf extends} jmarkov.SimpleMarkovProcess
\refdefined{jmarkov.SimpleMarkovProcess}}}}
\subsubsection{Version}{1.0}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.GeomProcess.defaultGeometrixSolver}{{\bf defaultGeometrixSolver}} Default Solver\\
\hyperlink{jmarkov.GeomProcess.GeometrixSolver}{{\bf GeometrixSolver}} Current Solver\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.GeomProcess(Sub, jmarkov.basic.EventsSet)}{{\bf GeomProcess(Sub, EventsSet)}} Builds a GeomProcess\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.GeomProcess.active(jmarkov.GeomState, E)}{{\bf active(GeomState, E)}} The user cannot extend this method.\\
\hyperlink{jmarkov.GeomProcess.active(Sub, int, E)}{{\bf active(Sub, int, E)}} The user must extend this method to determine which events are active.\\
\hyperlink{jmarkov.GeomProcess.dests(jmarkov.GeomState, E)}{{\bf dests(GeomState, E)}} Overrides SimpleMarkovProcess' method\\
\hyperlink{jmarkov.GeomProcess.dests(Sub, int, E)}{{\bf dests(Sub, int, E)}} Determines the destination set of States when events e occurs.\\
\hyperlink{jmarkov.GeomProcess.getAMatrices()}{{\bf getAMatrices()}} Returns the matrices of the repeating levels, A0, A1, and A2.\\
\hyperlink{jmarkov.GeomProcess.getBMatrices()}{{\bf getBMatrices()}} Returns the matrices B00, B01 and B10.\\
\hyperlink{jmarkov.GeomProcess.getBoundaryStates()}{{\bf getBoundaryStates()}} Returns an array with the States in the boundary level.\\
\hyperlink{jmarkov.GeomProcess.getDefaultGeometrixSolver()}{{\bf getDefaultGeometrixSolver()}} Returns the default GeometrixSolver.\\
\hyperlink{jmarkov.GeomProcess.getEventRate(int)}{{\bf getEventRate(int)}} \\
\hyperlink{jmarkov.GeomProcess.getExpectedLevel()}{{\bf getExpectedLevel()}} Returns the Expected Value for the Level.\\
\hyperlink{jmarkov.GeomProcess.getGeometrixSolver()}{{\bf getGeometrixSolver()}} The currently defined solver.\\
\hyperlink{jmarkov.GeomProcess.getInitialSol()}{{\bf getInitialSol()}} Computes and returns the initial solution \lbrack\ pi(0), pi(1) \rbrack .\\
\hyperlink{jmarkov.GeomProcess.getMOPsMoment(int, int)}{{\bf getMOPsMoment(int, int)}} \\
\hyperlink{jmarkov.GeomProcess.getNumBoundaryStates()}{{\bf getNumBoundaryStates()}} The Number of States in the boundary level.\\
\hyperlink{jmarkov.GeomProcess.getNumTypicalStates()}{{\bf getNumTypicalStates()}} The number of states in the typical levels.\\
\hyperlink{jmarkov.GeomProcess.getRmatrix()}{{\bf getRmatrix()}} The R Matrix of the Geometric solution.\\
\hyperlink{jmarkov.GeomProcess.getStateClass()}{{\bf getStateClass()}} This return the Sub-States class, rather than GeomState.\\
\hyperlink{jmarkov.GeomProcess.getStates()}{{\bf getStates()}} \\
\hyperlink{jmarkov.GeomProcess.getSteadyState(int)}{{\bf getSteadyState(int)}} Return an array with the probabilities for the given level.\\
\hyperlink{jmarkov.GeomProcess.getSubMatrices(int, int, int, int)}{{\bf getSubMatrices(int, int, int, int)}} This method constructs any A\_n or B\_ij matrix existing in the process and that are necessary to calculated R matrix.\\
\hyperlink{jmarkov.GeomProcess.getTypicalStates()}{{\bf getTypicalStates()}} Returns an array with the States in the typical levels.\\
\hyperlink{jmarkov.GeomProcess.getVectorPi0()}{{\bf getVectorPi0()}} Returns the steady State probabilities for boundary level.\\
\hyperlink{jmarkov.GeomProcess.getVectorPi1()}{{\bf getVectorPi1()}} Returns the steady State probabilities for level 1.\\
\hyperlink{jmarkov.GeomProcess.getVectorPi1Mod()}{{\bf getVectorPi1Mod()}} Returns the steady State probabilities for level 1.\\
\hyperlink{jmarkov.GeomProcess.isStable()}{{\bf isStable()}} Determines if the system is stable.\\
\hyperlink{jmarkov.GeomProcess.matrixRtoArray()}{{\bf matrixRtoArray()}} \\
\hyperlink{jmarkov.GeomProcess.printAll(java.io.PrintWriter)}{{\bf printAll(PrintWriter)}} \\
\hyperlink{jmarkov.GeomProcess.printStates(java.io.PrintWriter, int, int)}{{\bf printStates(PrintWriter, int, int)}} \\
\hyperlink{jmarkov.GeomProcess.rate(jmarkov.GeomState, jmarkov.GeomState, E)}{{\bf rate(GeomState, GeomState, E)}} \\
\hyperlink{jmarkov.GeomProcess.rate(Sub, int, Sub, int, E)}{{\bf rate(Sub, int, Sub, int, E)}} \\
\hyperlink{jmarkov.GeomProcess.reset()}{{\bf reset()}} \\
\hyperlink{jmarkov.GeomProcess.setGeometrixSolver(jmarkov.solvers.GeometricSolver)}{{\bf setGeometrixSolver(GeometricSolver)}} Allows the user to set an alternate solver.\\
\hyperlink{jmarkov.GeomProcess.steadyProbabilities()}{{\bf steadyProbabilities()}} Computes the steady state probabilities for the generated States (up to level 2).\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{GeometrixSolver}
\label{jmarkov.GeomProcess.GeometrixSolver}\hypertarget{jmarkov.GeomProcess.GeometrixSolver}{protected solvers.GeometricSolver {\bf GeometrixSolver}}
\begin{itemize}
\item{\vskip -.9ex 
Current Solver}
\end{itemize}
}
\item{
\index{defaultGeometrixSolver}
\label{jmarkov.GeomProcess.defaultGeometrixSolver}\hypertarget{jmarkov.GeomProcess.defaultGeometrixSolver}{protected solvers.GeometricSolver {\bf defaultGeometrixSolver}}
\begin{itemize}
\item{\vskip -.9ex 
Default Solver}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{GeomProcess(Sub, EventsSet)}
\hypertarget{jmarkov.GeomProcess(Sub, jmarkov.basic.EventsSet)}{\membername{GeomProcess}}
{\tt public\ {\bf GeomProcess}( {\tt basic.State} {\bf i0},
{\tt basic.EventsSet} {\bf eSet} )
\label{jmarkov.GeomProcess(Sub, jmarkov.basic.EventsSet)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Builds a GeomProcess
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i0} -- Initial state. MUST be a boundary state!}
   \item{
\sld
{\tt eSet} -- the event set.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{active(GeomState, E)}
\hypertarget{jmarkov.GeomProcess.active(jmarkov.GeomState, E)}{\membername{active}}
{\tt public final boolean\ {\bf active}( {\tt GeomState} {\bf i},
{\tt basic.Event} {\bf e} )
\label{jmarkov.GeomProcess.active(jmarkov.GeomState, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The user cannot extend this method. GeomProcess detemines this based on {\tt\small active}
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.GeomProcess.active(Sub, int, E)}{GeomProcess.active(State,\allowbreak int,\allowbreak Event)}} {\small 
\refdefined{jmarkov.GeomProcess.active(Sub, int, E)}}%end
}
\item{ {\tt \hyperlink{jmarkov.SimpleMarkovProcess.active(S, E)}{SimpleMarkovProcess.active(State,\allowbreak Event)}} {\small 
\refdefined{jmarkov.SimpleMarkovProcess.active(S, E)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{active}
\item{\vskip -1.9ex 
\index{active(Sub, int, E)}
\hypertarget{jmarkov.GeomProcess.active(Sub, int, E)}{\membername{active}}
{\tt public abstract boolean\ {\bf active}( {\tt basic.State} {\bf substate},
{\tt int} {\bf iLevel},
{\tt basic.Event} {\bf e} )
\label{jmarkov.GeomProcess.active(Sub, int, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The user must extend this method to determine which events are active.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt substate} -- the current sub state}
   \item{
\sld
{\tt iLevel} -- Absolute level of current State i. You should test only whether it is 0 (boundary), 1 or greater than 1. Your code should not behave any different if the level is 2, or 3, etc}
   \item{
\sld
{\tt e} -- The event being tested.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
tru if this event occurs 
}%end item
\end{itemize}
}%end item
\divideents{dests}
\item{\vskip -1.9ex 
\index{dests(GeomState, E)}
\hypertarget{jmarkov.GeomProcess.dests(jmarkov.GeomState, E)}{\membername{dests}}
{\tt public final basic.States\ {\bf dests}( {\tt GeomState} {\bf i},
{\tt basic.Event} {\bf e} )
\label{jmarkov.GeomProcess.dests(jmarkov.GeomState, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Overrides SimpleMarkovProcess' method
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt e} -- Event}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the destinations states 
}%end item
\end{itemize}
}%end item
\divideents{dests}
\item{\vskip -1.9ex 
\index{dests(Sub, int, E)}
\hypertarget{jmarkov.GeomProcess.dests(Sub, int, E)}{\membername{dests}}
{\tt public abstract GeomRelState\lbrack \rbrack \ {\bf dests}( {\tt basic.State} {\bf i},
{\tt int} {\bf iLevel},
{\tt basic.Event} {\bf e} )
\label{jmarkov.GeomProcess.dests(Sub, int, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Determines the destination set of States when events e occurs. It has to be implemented by the subclass.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current State.}
   \item{
\sld
{\tt iLevel} -- absolute level of current State. For QBD this is 0, 1 or 2. Anything above 2 should report the same result.}
   \item{
\sld
{\tt e} -- The Event that ocurred.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The destination States 
}%end item
\end{itemize}
}%end item
\divideents{getAMatrices}
\item{\vskip -1.9ex 
\index{getAMatrices()}
\hypertarget{jmarkov.GeomProcess.getAMatrices()}{\membername{getAMatrices}}
{\tt public no.uib.cipr.matrix.Matrix\lbrack \rbrack \ {\bf getAMatrices}(  )
\label{jmarkov.GeomProcess.getAMatrices()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the matrices of the repeating levels, A0, A1, and A2. If the model has not been generated it will be.
}
\item{{\bf Returns} -- 
\lbrack A0, A1, A2\rbrack  
}%end item
\end{itemize}
}%end item
\divideents{getBMatrices}
\item{\vskip -1.9ex 
\index{getBMatrices()}
\hypertarget{jmarkov.GeomProcess.getBMatrices()}{\membername{getBMatrices}}
{\tt public no.uib.cipr.matrix.Matrix\lbrack \rbrack \ {\bf getBMatrices}(  )
\label{jmarkov.GeomProcess.getBMatrices()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the matrices B00, B01 and B10. It causes the generation of the model if it has not been generated.
}
\item{{\bf Returns} -- 
an array with \{B00,B01,B10\}\ in that order. 
}%end item
\end{itemize}
}%end item
\divideents{getBoundaryStates}
\item{\vskip -1.9ex 
\index{getBoundaryStates()}
\hypertarget{jmarkov.GeomProcess.getBoundaryStates()}{\membername{getBoundaryStates}}
{\tt public basic.State\lbrack \rbrack \ {\bf getBoundaryStates}(  )
\label{jmarkov.GeomProcess.getBoundaryStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns an array with the States in the boundary level.
}
\item{{\bf Returns} -- 
an array with the Sub-States 
}%end item
\end{itemize}
}%end item
\divideents{getDefaultGeometrixSolver}
\item{\vskip -1.9ex 
\index{getDefaultGeometrixSolver()}
\hypertarget{jmarkov.GeomProcess.getDefaultGeometrixSolver()}{\membername{getDefaultGeometrixSolver}}
{\tt protected final solvers.GeometricSolver\ {\bf getDefaultGeometrixSolver}(  )
\label{jmarkov.GeomProcess.getDefaultGeometrixSolver()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the default GeometrixSolver.
}
\item{{\bf Returns} -- 
the default GeometrixSolver. 
}%end item
\end{itemize}
}%end item
\divideents{getEventRate}
\item{\vskip -1.9ex 
\index{getEventRate(int)}
\hypertarget{jmarkov.GeomProcess.getEventRate(int)}{\membername{getEventRate}}
{\tt public double\ {\bf getEventRate}( {\tt int} {\bf eNum} ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.GeomProcess.getEventRate(int)}}%end signature
\begin{itemize}
\sld
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getEventRate(int)}{MarkovProcess.getEventRate(int)}} {\small 
\refdefined{jmarkov.MarkovProcess.getEventRate(int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getExpectedLevel}
\item{\vskip -1.9ex 
\index{getExpectedLevel()}
\hypertarget{jmarkov.GeomProcess.getExpectedLevel()}{\membername{getExpectedLevel}}
{\tt public double\ {\bf getExpectedLevel}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.GeomProcess.getExpectedLevel()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the Expected Value for the Level. That is



L ={\bf  (p}$_{1 }$+ 2{\bf p}$_{2}$ +3{\bf p}$_{3}$ + ... ){\bf 1}= {\bf p}$_{1}$({\bf I-R})$^{-2}${\bf 1}, where {\bf 1} is a column vector of ones.
}
\item{{\bf Returns} -- 
L. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getGeometrixSolver}
\item{\vskip -1.9ex 
\index{getGeometrixSolver()}
\hypertarget{jmarkov.GeomProcess.getGeometrixSolver()}{\membername{getGeometrixSolver}}
{\tt public solvers.GeometricSolver\ {\bf getGeometrixSolver}(  )
\label{jmarkov.GeomProcess.getGeometrixSolver()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The currently defined solver.
}
\item{{\bf Returns} -- 
Returns the GeometrixSolver. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.GeometricSolver}{solvers.GeometricSolver}} {\small 
\refdefined{jmarkov.solvers.GeometricSolver}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getInitialSol}
\item{\vskip -1.9ex 
\index{getInitialSol()}
\hypertarget{jmarkov.GeomProcess.getInitialSol()}{\membername{getInitialSol}}
{\tt public double\lbrack \rbrack \ {\bf getInitialSol}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.GeomProcess.getInitialSol()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes and returns the initial solution \lbrack\ pi(0), pi(1) \rbrack .
}
\item{{\bf Returns} -- 
an array with the initial solution \lbrack\ pi(0), pi(1) \rbrack  
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMOPsMoment}
\item{\vskip -1.9ex 
\index{getMOPsMoment(int, int)}
\hypertarget{jmarkov.GeomProcess.getMOPsMoment(int, int)}{\membername{getMOPsMoment}}
{\tt public double\ {\bf getMOPsMoment}( {\tt int} {\bf mopNum},
{\tt int} {\bf m} ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.GeomProcess.getMOPsMoment(int, int)}}%end signature
\begin{itemize}
\sld
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getMOPsMoment(int, int)}{MarkovProcess.getMOPsMoment(int,\allowbreak int)}} {\small 
\refdefined{jmarkov.MarkovProcess.getMOPsMoment(int, int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getNumBoundaryStates}
\item{\vskip -1.9ex 
\index{getNumBoundaryStates()}
\hypertarget{jmarkov.GeomProcess.getNumBoundaryStates()}{\membername{getNumBoundaryStates}}
{\tt public int\ {\bf getNumBoundaryStates}(  )
\label{jmarkov.GeomProcess.getNumBoundaryStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The Number of States in the boundary level.
}
\item{{\bf Returns} -- 
the Number of States in the boundary level. 
}%end item
\end{itemize}
}%end item
\divideents{getNumTypicalStates}
\item{\vskip -1.9ex 
\index{getNumTypicalStates()}
\hypertarget{jmarkov.GeomProcess.getNumTypicalStates()}{\membername{getNumTypicalStates}}
{\tt public int\ {\bf getNumTypicalStates}(  )
\label{jmarkov.GeomProcess.getNumTypicalStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The number of states in the typical levels.
}
\item{{\bf Returns} -- 
the number of states in the typical levels. 
}%end item
\end{itemize}
}%end item
\divideents{getRmatrix}
\item{\vskip -1.9ex 
\index{getRmatrix()}
\hypertarget{jmarkov.GeomProcess.getRmatrix()}{\membername{getRmatrix}}
{\tt public no.uib.cipr.matrix.Matrix\ {\bf getRmatrix}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.GeomProcess.getRmatrix()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The R Matrix of the Geometric solution. This matrix solves

{\bf A$_{0}$+RA$_{1}$ + R$^{2}$A$_{2}$ = 0}
}
\item{{\bf Returns} -- 
The {\bf R} Matrix of the Geometric solution. If the system is not stable it returns a zero matrix. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getStateClass}
\item{\vskip -1.9ex 
\index{getStateClass()}
\hypertarget{jmarkov.GeomProcess.getStateClass()}{\membername{getStateClass}}
{\tt public java.lang.Class\ {\bf getStateClass}(  )
\label{jmarkov.GeomProcess.getStateClass()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This return the Sub-States class, rather than GeomState.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getStateClass()}{MarkovProcess.getStateClass()}} {\small 
\refdefined{jmarkov.MarkovProcess.getStateClass()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getStates}
\item{\vskip -1.9ex 
\index{getStates()}
\hypertarget{jmarkov.GeomProcess.getStates()}{\membername{getStates}}
{\tt public basic.StatesSet\ {\bf getStates}(  )
\label{jmarkov.GeomProcess.getStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.MarkovProcess}{MarkovProcess}{\small \refdefined{jmarkov.MarkovProcess}} }

Returns an array with all the States in the model. It generates the model if it has not been generated.
}
\item{{\bf Returns} -- 
The States 
}%end item
\end{itemize}
}%end item
\divideents{getSteadyState}
\item{\vskip -1.9ex 
\index{getSteadyState(int)}
\hypertarget{jmarkov.GeomProcess.getSteadyState(int)}{\membername{getSteadyState}}
{\tt public double\lbrack \rbrack \ {\bf getSteadyState}( {\tt int} {\bf level} ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.GeomProcess.getSteadyState(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return an array with the probabilities for the given level.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
probabilities array pi(k). 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getSubMatrices}
\item{\vskip -1.9ex 
\index{getSubMatrices(int, int, int, int)}
\hypertarget{jmarkov.GeomProcess.getSubMatrices(int, int, int, int)}{\membername{getSubMatrices}}
{\tt public no.uib.cipr.matrix.Matrix\ {\bf getSubMatrices}( {\tt int} {\bf rowMin},
{\tt int} {\bf rowMax},
{\tt int} {\bf colMin},
{\tt int} {\bf colMax} )
\label{jmarkov.GeomProcess.getSubMatrices(int, int, int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method constructs any A\_n or B\_ij matrix existing in the process and that are necessary to calculated R matrix.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt rowMax} -- The upper limit row index.}
   \item{
\sld
{\tt rowMin} -- The lower limit row index.}
   \item{
\sld
{\tt colMax} -- The upper limit column index.}
   \item{
\sld
{\tt colMin} -- The lower limit column index.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
any A matrix in the process. 
}%end item
\end{itemize}
}%end item
\divideents{getTypicalStates}
\item{\vskip -1.9ex 
\index{getTypicalStates()}
\hypertarget{jmarkov.GeomProcess.getTypicalStates()}{\membername{getTypicalStates}}
{\tt public basic.State\lbrack \rbrack \ {\bf getTypicalStates}(  )
\label{jmarkov.GeomProcess.getTypicalStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns an array with the States in the typical levels.
}
\item{{\bf Returns} -- 
an array with the Sub-States 
}%end item
\end{itemize}
}%end item
\divideents{getVectorPi0}
\item{\vskip -1.9ex 
\index{getVectorPi0()}
\hypertarget{jmarkov.GeomProcess.getVectorPi0()}{\membername{getVectorPi0}}
{\tt public double\lbrack \rbrack \ {\bf getVectorPi0}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.GeomProcess.getVectorPi0()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the steady State probabilities for boundary level.
}
\item{{\bf Returns} -- 
the array pi(0) 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getVectorPi1}
\item{\vskip -1.9ex 
\index{getVectorPi1()}
\hypertarget{jmarkov.GeomProcess.getVectorPi1()}{\membername{getVectorPi1}}
{\tt public double\lbrack \rbrack \ {\bf getVectorPi1}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.GeomProcess.getVectorPi1()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the steady State probabilities for level 1.
}
\item{{\bf Returns} -- 
the array pi(1) 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getVectorPi1Mod}
\item{\vskip -1.9ex 
\index{getVectorPi1Mod()}
\hypertarget{jmarkov.GeomProcess.getVectorPi1Mod()}{\membername{getVectorPi1Mod}}
{\tt public double\lbrack \rbrack \ {\bf getVectorPi1Mod}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.GeomProcess.getVectorPi1Mod()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the steady State probabilities for level 1.
}
\item{{\bf Returns} -- 
the array pi(1)(I-R)$\wedge$(-1) 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{isStable}
\item{\vskip -1.9ex 
\index{isStable()}
\hypertarget{jmarkov.GeomProcess.isStable()}{\membername{isStable}}
{\tt public boolean\ {\bf isStable}(  )
\label{jmarkov.GeomProcess.isStable()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Determines if the system is stable.
}
\item{{\bf Returns} -- 
true if the system is stable. 
}%end item
\end{itemize}
}%end item
\divideents{matrixRtoArray}
\item{\vskip -1.9ex 
\index{matrixRtoArray()}
\hypertarget{jmarkov.GeomProcess.matrixRtoArray()}{\membername{matrixRtoArray}}
{\tt public double\lbrack \rbrack \lbrack \rbrack \ {\bf matrixRtoArray}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.GeomProcess.matrixRtoArray()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Matrix R in an array of doubles. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printAll}
\item{\vskip -1.9ex 
\index{printAll(PrintWriter)}
\hypertarget{jmarkov.GeomProcess.printAll(java.io.PrintWriter)}{\membername{printAll}}
{\tt public void\ {\bf printAll}( {\tt java.io.PrintWriter} {\bf out} )
\label{jmarkov.GeomProcess.printAll(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.MarkovProcess}{MarkovProcess}{\small \refdefined{jmarkov.MarkovProcess}} }

Prints to the given PrintWriter a summary of the information related to this MarkovChain. The information is the same as as in the method {\tt\small printAll()}.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt out} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.toString()}{MarkovProcess.toString()}} {\small 
\refdefined{jmarkov.MarkovProcess.toString()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.printAll()}{MarkovProcess.printAll()}} {\small 
\refdefined{jmarkov.MarkovProcess.printAll()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printStates}
\item{\vskip -1.9ex 
\index{printStates(PrintWriter, int, int)}
\hypertarget{jmarkov.GeomProcess.printStates(java.io.PrintWriter, int, int)}{\membername{printStates}}
{\tt public void\ {\bf printStates}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf probDecimals} )
\label{jmarkov.GeomProcess.printStates(java.io.PrintWriter, int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.MarkovProcess}{MarkovProcess}{\small \refdefined{jmarkov.MarkovProcess}} }

Prints a description of the States and the Equilibrium Probabilities.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt out} -- The writer to write to.}
   \item{
\sld
{\tt width} -- The width of each column.}
   \item{
\sld
{\tt probDecimals} -- The number of decimals for the probabilities.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{rate}
\item{\vskip -1.9ex 
\index{rate(GeomState, GeomState, E)}
\hypertarget{jmarkov.GeomProcess.rate(jmarkov.GeomState, jmarkov.GeomState, E)}{\membername{rate}}
{\tt public double\ {\bf rate}( {\tt GeomState} {\bf i},
{\tt GeomState} {\bf j},
{\tt basic.Event} {\bf e} )
\label{jmarkov.GeomProcess.rate(jmarkov.GeomState, jmarkov.GeomState, E)}}%end signature
}%end item
\divideents{rate}
\item{\vskip -1.9ex 
\index{rate(Sub, int, Sub, int, E)}
\hypertarget{jmarkov.GeomProcess.rate(Sub, int, Sub, int, E)}{\membername{rate}}
{\tt public abstract double\ {\bf rate}( {\tt basic.State} {\bf i},
{\tt int} {\bf ilevel},
{\tt basic.State} {\bf j},
{\tt int} {\bf jLevel},
{\tt basic.Event} {\bf e} )
\label{jmarkov.GeomProcess.rate(Sub, int, Sub, int, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current sub state}
   \item{
\sld
{\tt ilevel} -- current state's absolute level}
   \item{
\sld
{\tt j} -- destination sub state}
   \item{
\sld
{\tt jLevel} -- destination level}
   \item{
\sld
{\tt e} -- Event}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
rate of occurrance 
}%end item
\end{itemize}
}%end item
\divideents{reset}
\item{\vskip -1.9ex 
\index{reset()}
\hypertarget{jmarkov.GeomProcess.reset()}{\membername{reset}}
{\tt public synchronized void\ {\bf reset}(  )
\label{jmarkov.GeomProcess.reset()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.MarkovProcess}{MarkovProcess}{\small \refdefined{jmarkov.MarkovProcess}} }

Resets the Model. It erases all found states and transition rates. Keeps the initial state and Events set.
}
\end{itemize}
}%end item
\divideents{setGeometrixSolver}
\item{\vskip -1.9ex 
\index{setGeometrixSolver(GeometricSolver)}
\hypertarget{jmarkov.GeomProcess.setGeometrixSolver(jmarkov.solvers.GeometricSolver)}{\membername{setGeometrixSolver}}
{\tt public void\ {\bf setGeometrixSolver}( {\tt solvers.GeometricSolver} {\bf geometrixSolver} )
\label{jmarkov.GeomProcess.setGeometrixSolver(jmarkov.solvers.GeometricSolver)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Allows the user to set an alternate solver.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt geometrixSolver} -- The GeometrixSolver to set.}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.GeometricSolver}{solvers.GeometricSolver}} {\small 
\refdefined{jmarkov.solvers.GeometricSolver}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{steadyProbabilities}
\item{\vskip -1.9ex 
\index{steadyProbabilities()}
\hypertarget{jmarkov.GeomProcess.steadyProbabilities()}{\membername{steadyProbabilities}}
{\tt public double\lbrack \rbrack \ {\bf steadyProbabilities}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.GeomProcess.steadyProbabilities()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the steady state probabilities for the generated States (up to level 2).
}
\item{{\bf Returns} -- 
(pi(0), pi(1), pi(2)). 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.SimpleMarkovProcess} \textnormal{\small\refdefined{jmarkov.SimpleMarkovProcess}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract boolean {\bf active}( {\tt basic.State} {\bf i},
{\tt basic.Event} {\bf e} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Transitions {\bf activeTransitions}( {\tt basic.State} {\bf i},
{\tt basic.Event} {\bf e} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract States {\bf dests}( {\tt basic.State} {\bf i},
{\tt basic.Event} {\bf e} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf rate}( {\tt basic.State} {\bf i},
{\tt basic.State} {\bf j},
{\tt basic.Event} {\bf e} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.MarkovProcess} \textnormal{\small\refdefined{jmarkov.MarkovProcess}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract Transitions {\bf activeTransitions}( {\tt basic.State} {\bf i},
{\tt basic.Event} {\bf e} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public boolean {\bf addMOP}( {\tt java.lang.String} {\bf mopName} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf allToString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public boolean {\bf canGo}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf clearMOPs}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf cnt}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf defaultSteadyStateSolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf defaultTransientSolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf denseMatrixToString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf denseMatrixToString}( {\tt int} {\bf width},
{\tt int} {\bf rateDecimals},
{\tt boolean} {\bf printZeros},
{\tt boolean} {\bf useGenerator} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf eventRatesToString}( {\tt int} {\bf width},
{\tt int} {\bf decimals} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf eventsRatesToString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf finalize}(  ) throws java.lang.Throwable
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getDebugReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final SteadyStateSolver {\bf getDefaultSteadyStateSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected TransientSolver {\bf getDefaultTransientSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Class {\bf getEventClass}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getEventNames}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getEventRate}( {\tt int} {\bf eNum} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Event {\bf getEvents}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getEventsRates}(  ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized double {\bf getFinalRate}( {\tt basic.State} {\bf i},
{\tt basic.State} {\bf j} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getGenerator}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected State {\bf getInitialState}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public long {\bf getMaxStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getMOPIndex}( {\tt java.lang.String} {\bf name} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getMOPNames}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getMOPNames}( {\tt int} {\bf mopNum} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsAvg}(  ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsAvg}( {\tt int} {\bf mopNum} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsAvg}( {\tt java.lang.String} {\bf mopName} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsMoment}( {\tt int} {\bf m} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsMoment}( {\tt int} {\bf mopNum},
{\tt int} {\bf m} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsMoment}( {\tt java.lang.String} {\bf mopName},
{\tt int} {\bf m} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf getMtjGenerator}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized Matrix {\bf getMtjRates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getNumStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public long {\bf getProgress}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized double {\bf getRate}( {\tt basic.State} {\bf i},
{\tt basic.State} {\bf j} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized double {\bf getRates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized Transitions {\bf getRates}( {\tt basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Class {\bf getStateClass}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getStates}( {\tt boolean} {\bf causesGeneration} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MarkovProcess.Status {\bf getStatus}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getStatusMsg}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getSteadyState}(  ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public SteadyStateSolver {\bf getSteadyStateSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public TransientSolver {\bf getTransientSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized void {\bf go}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized void {\bf goStep}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf hideGUI}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf hLine}( {\tt int} {\bf length} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public boolean {\bf isGenerated}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf killGUI}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf loadGUI}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf MOPsToString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf MOPsToString}( {\tt int} {\bf width},
{\tt int} {\bf decimals} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf name}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf numMOPs}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w},
{\tt boolean} {\bf right} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w},
{\tt int} {\bf d} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w},
{\tt int} {\bf d},
{\tt boolean} {\bf right} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt java.lang.String} {\bf s},
{\tt int} {\bf w} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt java.lang.String} {\bf s},
{\tt int} {\bf w},
{\tt boolean} {\bf right} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf pause}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printAll}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printAll}( {\tt java.io.PrintWriter} {\bf out} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printDenseMatrix}( {\tt java.io.PrintWriter} {\bf out} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printDenseMatrix}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf rateDecimals},
{\tt boolean} {\bf printZeros},
{\tt boolean} {\bf useGenerator} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf printDenseMatrix}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf rateDecimals},
{\tt boolean} {\bf printZeros},
{\tt boolean} {\bf useGenerator},
{\tt int\lbrack \rbrack } {\bf idx} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printEventsRates}( {\tt java.io.PrintWriter} {\bf out} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printEventsRates}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf decimals} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf printMOPs}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf printMOPs}( {\tt java.io.PrintWriter} {\bf out} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf printMOPs}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf decimals} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStates}( {\tt java.io.PrintWriter} {\bf out} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStates}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf probDecimals} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized void {\bf reset}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected synchronized void {\bf reset}( {\tt boolean} {\bf resetEvents} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized void {\bf resetResults}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugReporter}( {\tt DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setEventSet}( {\tt basic.EventsSet} {\bf eSet} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setInitialState}( {\tt basic.State} {\bf i0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setMaxStates}( {\tt long} {\bf num} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setMOPs}( {\tt java.lang.String\lbrack \rbrack } {\bf mopNames} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSteadyStateSolver}( {\tt solvers.SteadyStateSolver} {\bf steadyStateSolver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setTransientSolver}( {\tt solvers.TransientSolver} {\bf transientSolver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf showGUI}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf statesLableMaxWidth}( {\tt int} {\bf width} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf statesToString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf theStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf vLine}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{GeomRelState}
\subsection{\label{jmarkov.GeomRelState}\index{GeomRelState}{\bf {\it Class} GeomRelState}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.GeomRelState}{}\vskip .1in 
This class is used to build destinations which are relative to a given GeomState. The user shoulld not extend this class, but rather use it when building destination states.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public final class GeomRelState
\\ {\bf extends} jmarkov.basic.State
\refdefined{jmarkov.basic.State}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.GeomRelState.boundary}{{\bf boundary}} Whether it is boundary\\
\hyperlink{jmarkov.GeomRelState.rLevel}{{\bf rLevel}} Relitive Level\\
\hyperlink{jmarkov.GeomRelState.subState}{{\bf subState}} subState represnts the background states in every rLevel.\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.GeomRelState(Sub)}{{\bf GeomRelState(Sub)}} Creates a boundary GeomState with the given relative level rLevel, and subState.\\
\hyperlink{jmarkov.GeomRelState(Sub, int)}{{\bf GeomRelState(Sub, int)}} Creates a Non boundary GeomState with the given relative level rLevel, and subState.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.GeomRelState.compareTo(jmarkov.basic.State)}{{\bf compareTo(State)}} Compares GeomStates according to rLevel first and then according to the subStates comparator.\\
\hyperlink{jmarkov.GeomRelState.computeMOPs(jmarkov.MarkovProcess)}{{\bf computeMOPs(MarkovProcess)}} \\
\hyperlink{jmarkov.GeomRelState.getRelLevel()}{{\bf getRelLevel()}} \\
\hyperlink{jmarkov.GeomRelState.getSubState()}{{\bf getSubState()}} \\
\hyperlink{jmarkov.GeomRelState.isBoundary()}{{\bf isBoundary()}} This method determines fi the State is a boundary state.\\
\hyperlink{jmarkov.GeomRelState.isConsistent()}{{\bf isConsistent()}} \\
\hyperlink{jmarkov.GeomRelState.label()}{{\bf label()}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{rLevel}
\label{jmarkov.GeomRelState.rLevel}\hypertarget{jmarkov.GeomRelState.rLevel}{protected int {\bf rLevel}}
\begin{itemize}
\item{\vskip -.9ex 
Relitive Level}
\end{itemize}
}
\item{
\index{boundary}
\label{jmarkov.GeomRelState.boundary}\hypertarget{jmarkov.GeomRelState.boundary}{protected boolean {\bf boundary}}
\begin{itemize}
\item{\vskip -.9ex 
Whether it is boundary}
\end{itemize}
}
\item{
\index{subState}
\label{jmarkov.GeomRelState.subState}\hypertarget{jmarkov.GeomRelState.subState}{protected basic.State {\bf subState}}
\begin{itemize}
\item{\vskip -.9ex 
subState represnts the background states in every rLevel.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{GeomRelState(Sub)}
\hypertarget{jmarkov.GeomRelState(Sub)}{\membername{GeomRelState}}
{\tt public\ {\bf GeomRelState}( {\tt basic.State} {\bf subState} )
\label{jmarkov.GeomRelState(Sub)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a boundary GeomState with the given relative level rLevel, and subState.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt subState} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{GeomRelState}
\item{\vskip -1.9ex 
\index{GeomRelState(Sub, int)}
\hypertarget{jmarkov.GeomRelState(Sub, int)}{\membername{GeomRelState}}
{\tt public\ {\bf GeomRelState}( {\tt basic.State} {\bf subState},
{\tt int} {\bf rLevel} )
\label{jmarkov.GeomRelState(Sub, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a Non boundary GeomState with the given relative level rLevel, and subState.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt rLevel} -- }
   \item{
\sld
{\tt subState} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{compareTo(State)}
\hypertarget{jmarkov.GeomRelState.compareTo(jmarkov.basic.State)}{\membername{compareTo}}
{\tt public int\ {\bf compareTo}( {\tt basic.State} {\bf s} )
\label{jmarkov.GeomRelState.compareTo(jmarkov.basic.State)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Compares GeomStates according to rLevel first and then according to the subStates comparator.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- state to compare to.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{computeMOPs}
\item{\vskip -1.9ex 
\index{computeMOPs(MarkovProcess)}
\hypertarget{jmarkov.GeomRelState.computeMOPs(jmarkov.MarkovProcess)}{\membername{computeMOPs}}
{\tt public void\ {\bf computeMOPs}( {\tt MarkovProcess} {\bf mp} )
\label{jmarkov.GeomRelState.computeMOPs(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.computeMOPs(jmarkov.MarkovProcess)}{basic.State.computeMOPs(MarkovProcess)}} {\small 
\refdefined{jmarkov.basic.State.computeMOPs(jmarkov.MarkovProcess)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getRelLevel}
\item{\vskip -1.9ex 
\index{getRelLevel()}
\hypertarget{jmarkov.GeomRelState.getRelLevel()}{\membername{getRelLevel}}
{\tt public int\ {\bf getRelLevel}(  )
\label{jmarkov.GeomRelState.getRelLevel()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the rLevel. 
}%end item
\end{itemize}
}%end item
\divideents{getSubState}
\item{\vskip -1.9ex 
\index{getSubState()}
\hypertarget{jmarkov.GeomRelState.getSubState()}{\membername{getSubState}}
{\tt public basic.State\ {\bf getSubState}(  )
\label{jmarkov.GeomRelState.getSubState()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the subState. 
}%end item
\end{itemize}
}%end item
\divideents{isBoundary}
\item{\vskip -1.9ex 
\index{isBoundary()}
\hypertarget{jmarkov.GeomRelState.isBoundary()}{\membername{isBoundary}}
{\tt public boolean\ {\bf isBoundary}(  )
\label{jmarkov.GeomRelState.isBoundary()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method determines fi the State is a boundary state.
}
\item{{\bf Returns} -- 
Whether it is Boundary 
}%end item
\end{itemize}
}%end item
\divideents{isConsistent}
\item{\vskip -1.9ex 
\index{isConsistent()}
\hypertarget{jmarkov.GeomRelState.isConsistent()}{\membername{isConsistent}}
{\tt public boolean\ {\bf isConsistent}(  )
\label{jmarkov.GeomRelState.isConsistent()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.isConsistent()}{basic.State.isConsistent()}} {\small 
\refdefined{jmarkov.basic.State.isConsistent()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.GeomRelState.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.GeomRelState.label()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.label()}{basic.State.label()}} {\small 
\refdefined{jmarkov.basic.State.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.basic.State} \textnormal{\small\refdefined{jmarkov.basic.State}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract int {\bf compareTo}( {\tt State} {\bf j} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract void {\bf computeMOPs}( {\tt jmarkov.MarkovProcess} {\bf model} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf equals}( {\tt java.lang.Object} {\bf o} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getIndex}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOP}( {\tt int} {\bf index} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final double {\bf getMOP}( {\tt java.lang.String} {\bf mopName},
{\tt jmarkov.MarkovProcess} {\bf model} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract boolean {\bf isConsistent}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf setMOP}( {\tt int} {\bf index},
{\tt double} {\bf value} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf setMOP}( {\tt jmarkov.MarkovProcess} {\bf model},
{\tt java.lang.String} {\bf mopName},
{\tt double} {\bf value} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{GeomState}
\subsection{\label{jmarkov.GeomState}\index{GeomState}{\bf {\it Class} GeomState}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.GeomState}{}\vskip .1in 
The actual Geometric model is build using this class. The user normally does not have to manipulate this class.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public final class GeomState
\\ {\bf extends} jmarkov.basic.State
\refdefined{jmarkov.basic.State}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.GeomState.level}{{\bf level}} This represents the relative level.\\
\hyperlink{jmarkov.GeomState.subState}{{\bf subState}} subState represnts the background states in every level.\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.GeomState(Sub, int)}{{\bf GeomState(Sub, int)}} Creates a GeomState with the given level, ans subState.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.GeomState.compareTo(jmarkov.basic.State)}{{\bf compareTo(State)}} Compares GeomStates according to level first and then according to the subStates comparator.\\
\hyperlink{jmarkov.GeomState.computeMOPs(jmarkov.MarkovProcess)}{{\bf computeMOPs(MarkovProcess)}} \\
\hyperlink{jmarkov.GeomState.description()}{{\bf description()}} \\
\hyperlink{jmarkov.GeomState.getLevel()}{{\bf getLevel()}} \\
\hyperlink{jmarkov.GeomState.getMOP(int)}{{\bf getMOP(int)}} \\
\hyperlink{jmarkov.GeomState.getSubState()}{{\bf getSubState()}} \\
\hyperlink{jmarkov.GeomState.isBoundary()}{{\bf isBoundary()}} \\
\hyperlink{jmarkov.GeomState.isConsistent()}{{\bf isConsistent()}} \\
\hyperlink{jmarkov.GeomState.label()}{{\bf label()}} \\
\hyperlink{jmarkov.GeomState.setMOP(jmarkov.MarkovProcess, java.lang.String, double)}{{\bf setMOP(MarkovProcess, String, double)}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{level}
\label{jmarkov.GeomState.level}\hypertarget{jmarkov.GeomState.level}{protected int {\bf level}}
\begin{itemize}
\item{\vskip -.9ex 
This represents the relative level.}
\end{itemize}
}
\item{
\index{subState}
\label{jmarkov.GeomState.subState}\hypertarget{jmarkov.GeomState.subState}{protected basic.State {\bf subState}}
\begin{itemize}
\item{\vskip -.9ex 
subState represnts the background states in every level.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{GeomState(Sub, int)}
\hypertarget{jmarkov.GeomState(Sub, int)}{\membername{GeomState}}
{\tt public\ {\bf GeomState}( {\tt basic.State} {\bf subState},
{\tt int} {\bf level} )
\label{jmarkov.GeomState(Sub, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a GeomState with the given level, ans subState.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- }
   \item{
\sld
{\tt subState} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{compareTo(State)}
\hypertarget{jmarkov.GeomState.compareTo(jmarkov.basic.State)}{\membername{compareTo}}
{\tt public int\ {\bf compareTo}( {\tt basic.State} {\bf s} )
\label{jmarkov.GeomState.compareTo(jmarkov.basic.State)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Compares GeomStates according to level first and then according to the subStates comparator.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- state to compare to.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{computeMOPs}
\item{\vskip -1.9ex 
\index{computeMOPs(MarkovProcess)}
\hypertarget{jmarkov.GeomState.computeMOPs(jmarkov.MarkovProcess)}{\membername{computeMOPs}}
{\tt public void\ {\bf computeMOPs}( {\tt MarkovProcess} {\bf mp} )
\label{jmarkov.GeomState.computeMOPs(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.computeMOPs(jmarkov.MarkovProcess)}{basic.State.computeMOPs(MarkovProcess)}} {\small 
\refdefined{jmarkov.basic.State.computeMOPs(jmarkov.MarkovProcess)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.GeomState.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jmarkov.GeomState.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.State}{basic.State}{\small \refdefined{jmarkov.basic.State}} }

Returns a String that describes the State. By default it is an empty string, but you should implement it in order to get a meaningful description.
}
\item{{\bf Returns} -- 
A String description of the State 
}%end item
\end{itemize}
}%end item
\divideents{getLevel}
\item{\vskip -1.9ex 
\index{getLevel()}
\hypertarget{jmarkov.GeomState.getLevel()}{\membername{getLevel}}
{\tt public int\ {\bf getLevel}(  )
\label{jmarkov.GeomState.getLevel()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the level. 
}%end item
\end{itemize}
}%end item
\divideents{getMOP}
\item{\vskip -1.9ex 
\index{getMOP(int)}
\hypertarget{jmarkov.GeomState.getMOP(int)}{\membername{getMOP}}
{\tt public double\ {\bf getMOP}( {\tt int} {\bf index} )
\label{jmarkov.GeomState.getMOP(int)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.getMOP(int)}{basic.State.getMOP(int)}} {\small 
\refdefined{jmarkov.basic.State.getMOP(int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getSubState}
\item{\vskip -1.9ex 
\index{getSubState()}
\hypertarget{jmarkov.GeomState.getSubState()}{\membername{getSubState}}
{\tt public basic.State\ {\bf getSubState}(  )
\label{jmarkov.GeomState.getSubState()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the subState. 
}%end item
\end{itemize}
}%end item
\divideents{isBoundary}
\item{\vskip -1.9ex 
\index{isBoundary()}
\hypertarget{jmarkov.GeomState.isBoundary()}{\membername{isBoundary}}
{\tt public boolean\ {\bf isBoundary}(  )
\label{jmarkov.GeomState.isBoundary()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
tru if this state is level 0. 
}%end item
\end{itemize}
}%end item
\divideents{isConsistent}
\item{\vskip -1.9ex 
\index{isConsistent()}
\hypertarget{jmarkov.GeomState.isConsistent()}{\membername{isConsistent}}
{\tt public boolean\ {\bf isConsistent}(  )
\label{jmarkov.GeomState.isConsistent()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.isConsistent()}{basic.State.isConsistent()}} {\small 
\refdefined{jmarkov.basic.State.isConsistent()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.GeomState.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.GeomState.label()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.label()}{basic.State.label()}} {\small 
\refdefined{jmarkov.basic.State.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setMOP}
\item{\vskip -1.9ex 
\index{setMOP(MarkovProcess, String, double)}
\hypertarget{jmarkov.GeomState.setMOP(jmarkov.MarkovProcess, java.lang.String, double)}{\membername{setMOP}}
{\tt public int\ {\bf setMOP}( {\tt MarkovProcess} {\bf mp},
{\tt java.lang.String} {\bf mopName},
{\tt double} {\bf value} )
\label{jmarkov.GeomState.setMOP(jmarkov.MarkovProcess, java.lang.String, double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.setMOP(jmarkov.MarkovProcess, java.lang.String, double)}{basic.State.setMOP(MarkovProcess,\allowbreak String,\allowbreak double)}} {\small 
\refdefined{jmarkov.basic.State.setMOP(jmarkov.MarkovProcess, java.lang.String, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.basic.State} \textnormal{\small\refdefined{jmarkov.basic.State}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract int {\bf compareTo}( {\tt State} {\bf j} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract void {\bf computeMOPs}( {\tt jmarkov.MarkovProcess} {\bf model} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf equals}( {\tt java.lang.Object} {\bf o} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getIndex}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOP}( {\tt int} {\bf index} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final double {\bf getMOP}( {\tt java.lang.String} {\bf mopName},
{\tt jmarkov.MarkovProcess} {\bf model} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract boolean {\bf isConsistent}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf setMOP}( {\tt int} {\bf index},
{\tt double} {\bf value} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf setMOP}( {\tt jmarkov.MarkovProcess} {\bf model},
{\tt java.lang.String} {\bf mopName},
{\tt double} {\bf value} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MarkovProcess}
\subsection{\label{jmarkov.MarkovProcess}\index{MarkovProcess}{\bf {\it Class} MarkovProcess}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.MarkovProcess}{}\vskip .1in 
The abstract class SimpleMarkovProcess represents a Continuous or Discrete Time Markov Chain. In order to model a particular problem the user has to extend this class. The class can generate the model through the buildRS algorithm. This enables it to generate all states and the transition matrix, from behavior rule given by the user. These rules are determined by implementing the methods, {\tt\small active},{\tt\small dests} and {\tt\small rate}. The user should also determine how to code the space state. This is accomplished by implementing the State class. A particular implementation of State is provided where each state is coded with k integer properties. Examples are included in this release.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.SimpleMarkovProcess.dests(S, E)}{SimpleMarkovProcess.dests(State,\allowbreak Event)}} {\small 
\refdefined{jmarkov.SimpleMarkovProcess.dests(S, E)}}%end
} 
\item{ {\tt \hyperlink{jmarkov.SimpleMarkovProcess.active(S, E)}{SimpleMarkovProcess.active(State,\allowbreak Event)}} {\small 
\refdefined{jmarkov.SimpleMarkovProcess.active(S, E)}}%end
} 
\item{ {\tt \hyperlink{jmarkov.SimpleMarkovProcess.rate(S, S, E)}{SimpleMarkovProcess.rate(State,\allowbreak State,\allowbreak Event)}} {\small 
\refdefined{jmarkov.SimpleMarkovProcess.rate(S, S, E)}}%end
} 
\item{ {\tt \hyperlink{jmarkov.basic.State}{basic.State}} {\small 
\refdefined{jmarkov.basic.State}}%end
} 
\item{ {\tt \hyperlink{jmarkov.basic.Event}{basic.Event}} {\small 
\refdefined{jmarkov.basic.Event}}%end
} 
\item{ {\tt \hyperlink{jmarkov.basic.PropertiesState}{basic.PropertiesState}} {\small 
\refdefined{jmarkov.basic.PropertiesState}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class MarkovProcess
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
jmarkov.basic.JMarkovElement}}}
\subsubsection{Version}{1.0a}
\subsubsection{All known subclasses}{SimpleMarkovProcess\small{\refdefined{jmarkov.SimpleMarkovProcess}}, GeomProcess\small{\refdefined{jmarkov.GeomProcess}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.MarkovProcess.cnt}{{\bf cnt}} Number of completed states.\\
\hyperlink{jmarkov.MarkovProcess.defaultSteadyStateSolver}{{\bf defaultSteadyStateSolver}} Default Transient Solver\\
\hyperlink{jmarkov.MarkovProcess.defaultTransientSolver}{{\bf defaultTransientSolver}} Deafualt Transient solver\\
\hyperlink{jmarkov.MarkovProcess.name}{{\bf name}} The name of the model.\\
\hyperlink{jmarkov.MarkovProcess.theStates}{{\bf theStates}} Set of fully analyzed States\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.MarkovProcess()}{{\bf MarkovProcess()}} If a constructor calls this constructor then it MUST call setEvents and setInitialState afterwards.\\
\hyperlink{jmarkov.MarkovProcess(S, jmarkov.basic.EventsSet)}{{\bf MarkovProcess(S, EventsSet)}} Builds a SimpleMarkovProcess that contains all states reachable from i0, and with E being the set of all possible events.\\
\hyperlink{jmarkov.MarkovProcess(S, jmarkov.basic.EventsSet, java.lang.String)}{{\bf MarkovProcess(S, EventsSet, String)}} Builds a SimpleMarkovProcess that contains all states reachable from i0, and with E being the set of all possible events.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.MarkovProcess.activeTransitions(S, E)}{{\bf activeTransitions(S, E)}} The user MUST implement this Function in order to describe the dynamics of the model.\\
\hyperlink{jmarkov.MarkovProcess.addMOP(java.lang.String)}{{\bf addMOP(String)}} This method declares the existance of a measure of performance (MOP).\\
\hyperlink{jmarkov.MarkovProcess.allToString()}{{\bf allToString()}} Retuns a String description of the model and solution.\\
\hyperlink{jmarkov.MarkovProcess.canGo()}{{\bf canGo()}} Allos to stop model execution by graphica user interface.\\
\hyperlink{jmarkov.MarkovProcess.clearMOPs()}{{\bf clearMOPs()}} Clear all MOPs defined in the system.\\
\hyperlink{jmarkov.MarkovProcess.debug(int, java.lang.String)}{{\bf debug(int, String)}} Prints debug information with this importance level\\
\hyperlink{jmarkov.MarkovProcess.debug(int, java.lang.String, boolean)}{{\bf debug(int, String, boolean)}} Prints debug information with this importance level\\
\hyperlink{jmarkov.MarkovProcess.debug(int, java.lang.String, boolean, boolean)}{{\bf debug(int, String, boolean, boolean)}} Prints debug information with this importance level\\
\hyperlink{jmarkov.MarkovProcess.denseMatrixToString()}{{\bf denseMatrixToString()}} Returns a String with a description of the Model: the States and the Transition Matrix.\\
\hyperlink{jmarkov.MarkovProcess.denseMatrixToString(int, int, boolean, boolean)}{{\bf denseMatrixToString(int, int, boolean, boolean)}} Returns the Transition Matrix as a String.\\
\hyperlink{jmarkov.MarkovProcess.description()}{{\bf description()}} This method should be implemented by the subclass to give word description of the model.\\
\hyperlink{jmarkov.MarkovProcess.eventRatesToString(int, int)}{{\bf eventRatesToString(int, int)}} Return a String as printed by printEventsrates\\
\hyperlink{jmarkov.MarkovProcess.eventsRatesToString()}{{\bf eventsRatesToString()}} Return a string as eventsRatesToString, with width 8 and 4 decimals\\
\hyperlink{jmarkov.MarkovProcess.finalize()}{{\bf finalize()}} \\
\hyperlink{jmarkov.MarkovProcess.generate()}{{\bf generate()}} generate() builds the space state and rate matrix using the algorithm BuildsSR.\\
\hyperlink{jmarkov.MarkovProcess.getDebugLevel()}{{\bf getDebugLevel()}} \\
\hyperlink{jmarkov.MarkovProcess.getDebugReporter()}{{\bf getDebugReporter()}} Gets the DebugReporter currently in use.\\
\hyperlink{jmarkov.MarkovProcess.getDefaultSteadyStateSolver()}{{\bf getDefaultSteadyStateSolver()}} Returns the default SteadyStateSolver.\\
\hyperlink{jmarkov.MarkovProcess.getDefaultTransientSolver()}{{\bf getDefaultTransientSolver()}} The default solver for transient state.\\
\hyperlink{jmarkov.MarkovProcess.getEventClass()}{{\bf getEventClass()}} The Class for the Events in the system.\\
\hyperlink{jmarkov.MarkovProcess.getEventNames()}{{\bf getEventNames()}} Returns the defined events\\
\hyperlink{jmarkov.MarkovProcess.getEventRate(int)}{{\bf getEventRate(int)}} Return the steadystate rate of occurrance of the Events number eNum.\\
\hyperlink{jmarkov.MarkovProcess.getEvents()}{{\bf getEvents()}} Returns all The events defined in the model.\\
\hyperlink{jmarkov.MarkovProcess.getEventsRates()}{{\bf getEventsRates()}} Return an array with the steadystate rate of occurrance of all the Events.\\
\hyperlink{jmarkov.MarkovProcess.getFinalRate(S, S)}{{\bf getFinalRate(S, S)}} Gets the total rate form State number i to j.\\
\hyperlink{jmarkov.MarkovProcess.getGenerator()}{{\bf getGenerator()}} Returns the infinitesimal generator matrix {\bf Q }, in dense format.\\
\hyperlink{jmarkov.MarkovProcess.getInitialState()}{{\bf getInitialState()}} returns the initial state.\\
\hyperlink{jmarkov.MarkovProcess.getMaxStates()}{{\bf getMaxStates()}} \\
\hyperlink{jmarkov.MarkovProcess.getMOPIndex(java.lang.String)}{{\bf getMOPIndex(String)}} Gets the index that correspond to this MOP.\\
\hyperlink{jmarkov.MarkovProcess.getMOPNames()}{{\bf getMOPNames()}} Return all the names of defined MOPs.\\
\hyperlink{jmarkov.MarkovProcess.getMOPNames(int)}{{\bf getMOPNames(int)}} Return the names of the i-th MOP.\\
\hyperlink{jmarkov.MarkovProcess.getMOPsAvg()}{{\bf getMOPsAvg()}} Returns an array with the average of all the steady state measures of performance.\\
\hyperlink{jmarkov.MarkovProcess.getMOPsAvg(int)}{{\bf getMOPsAvg(int)}} Returns the steady state measures average of the MOP numbre mopNum.\\
\hyperlink{jmarkov.MarkovProcess.getMOPsAvg(java.lang.String)}{{\bf getMOPsAvg(String)}} Returns the steady state measures average of the MOP with name mopName.\\
\hyperlink{jmarkov.MarkovProcess.getMOPsMoment(int)}{{\bf getMOPsMoment(int)}} Returns an array with the m-th moment of all the steady state measures of performance.\\
\hyperlink{jmarkov.MarkovProcess.getMOPsMoment(int, int)}{{\bf getMOPsMoment(int, int)}} Returns the steady state measures m-th moment of the MOP number mopNum.\\
\hyperlink{jmarkov.MarkovProcess.getMOPsMoment(java.lang.String, int)}{{\bf getMOPsMoment(String, int)}} Returns the steady state measures m-th moment of the MOP with name mopName.\\
\hyperlink{jmarkov.MarkovProcess.getMtjGenerator()}{{\bf getMtjGenerator()}} The generator {\bf Q} as an MTJ Matrix\\
\hyperlink{jmarkov.MarkovProcess.getMtjRates()}{{\bf getMtjRates()}} Returns the transition rates matrix {\bf R} in MTJ format.\\
\hyperlink{jmarkov.MarkovProcess.getNumStates()}{{\bf getNumStates()}} Return the number of States in the model.\\
\hyperlink{jmarkov.MarkovProcess.getProgress()}{{\bf getProgress()}} Return the number of states processed so far in the current process.\\
\hyperlink{jmarkov.MarkovProcess.getRate(S, S)}{{\bf getRate(S, S)}} Gets the current total rate form i to j.\\
\hyperlink{jmarkov.MarkovProcess.getRates()}{{\bf getRates()}} Returns the transition rates matrix {\bf R} in dense format.\\
\hyperlink{jmarkov.MarkovProcess.getRates(S)}{{\bf getRates(S)}} This method returns a dynamic data structure with the rate from State i to all reachable states.\\
\hyperlink{jmarkov.MarkovProcess.getStateClass()}{{\bf getStateClass()}} The Class for the states in this model.\\
\hyperlink{jmarkov.MarkovProcess.getStates()}{{\bf getStates()}} Returns an array with all the States in the model.\\
\hyperlink{jmarkov.MarkovProcess.getStates(boolean)}{{\bf getStates(boolean)}} Returns an array with the States in the model that have been checked so far.\\
\hyperlink{jmarkov.MarkovProcess.getStatus()}{{\bf getStatus()}} Returns the current status of the model.\\
\hyperlink{jmarkov.MarkovProcess.getStatusMsg()}{{\bf getStatusMsg()}} Returns a String describing the current status of the model.\\
\hyperlink{jmarkov.MarkovProcess.getSteadyState()}{{\bf getSteadyState()}} Returns the steady state probabilities for this model.\\
\hyperlink{jmarkov.MarkovProcess.getSteadyStateSolver()}{{\bf getSteadyStateSolver()}} The currently defined solver.\\
\hyperlink{jmarkov.MarkovProcess.getTransientSolver()}{{\bf getTransientSolver()}} The currently defined solver for transient state.\\
\hyperlink{jmarkov.MarkovProcess.go()}{{\bf go()}} Runs the model, or resumes execution if it had been suspended.\\
\hyperlink{jmarkov.MarkovProcess.goStep()}{{\bf goStep()}} Runs the model for a single step.\\
\hyperlink{jmarkov.MarkovProcess.hideGUI()}{{\bf hideGUI()}} Hides the Graphic User Interface (GUI) that represent this Markov Chain if one is defined.\\
\hyperlink{jmarkov.MarkovProcess.hLine(int)}{{\bf hLine(int)}} Retuns an horizontal text line of the given length.\\
\hyperlink{jmarkov.MarkovProcess.isGenerated()}{{\bf isGenerated()}} \\
\hyperlink{jmarkov.MarkovProcess.killGUI()}{{\bf killGUI()}} Destroys the Graphic User Interface (GUI) that represent this Markov Chain if one is defined.\\
\hyperlink{jmarkov.MarkovProcess.label()}{{\bf label()}} Returns the name of the model.\\
\hyperlink{jmarkov.MarkovProcess.loadGUI()}{{\bf loadGUI()}} Loads the Graphic User Interface (GUI) that represent this Markov Chain.\\
\hyperlink{jmarkov.MarkovProcess.MOPsToString()}{{\bf MOPsToString()}} Return a String description of all MOPs in steady state (it reports mean and standard deviation).\\
\hyperlink{jmarkov.MarkovProcess.MOPsToString(int, int)}{{\bf MOPsToString(int, int)}} Return a String description of all MOPs in steady state (it reports mean and standard deviation).\\
\hyperlink{jmarkov.MarkovProcess.numMOPs()}{{\bf numMOPs()}} Returns the number of defined Measures of performance (MOPs).\\
\hyperlink{jmarkov.MarkovProcess.pad(double, int)}{{\bf pad(double, int)}} pad generates a string representing the double v, padded with spaces up to width w.\\
\hyperlink{jmarkov.MarkovProcess.pad(double, int, boolean)}{{\bf pad(double, int, boolean)}} pad generates a string representing the double v, padded with spaces up to width w.\\
\hyperlink{jmarkov.MarkovProcess.pad(double, int, int)}{{\bf pad(double, int, int)}} pad fills with blanks up to width w.\\
\hyperlink{jmarkov.MarkovProcess.pad(double, int, int, boolean)}{{\bf pad(double, int, int, boolean)}} pad fills with blanks up to width w\\
\hyperlink{jmarkov.MarkovProcess.pad(java.lang.String, int)}{{\bf pad(String, int)}} pad fills with blanks up to width w\\
\hyperlink{jmarkov.MarkovProcess.pad(java.lang.String, int, boolean)}{{\bf pad(String, int, boolean)}} pad fills with blanks up to width w\\
\hyperlink{jmarkov.MarkovProcess.pause()}{{\bf pause()}} Pauses the current execution of the model.\\
\hyperlink{jmarkov.MarkovProcess.printAll()}{{\bf printAll()}} Prints a description of the Model: the States and the Transition Matrix.\\
\hyperlink{jmarkov.MarkovProcess.printAll(java.io.PrintWriter)}{{\bf printAll(PrintWriter)}} Prints to the given PrintWriter a summary of the information related to this MarkovChain.\\
\hyperlink{jmarkov.MarkovProcess.printDenseMatrix(java.io.PrintWriter)}{{\bf printDenseMatrix(PrintWriter)}} Prints a the Transition Matrix.\\
\hyperlink{jmarkov.MarkovProcess.printDenseMatrix(java.io.PrintWriter, int, int, boolean, boolean)}{{\bf printDenseMatrix(PrintWriter, int, int, boolean, boolean)}} Prints a description of the Model using the given PrintWriter: the States and the Transition Matrix.\\
\hyperlink{jmarkov.MarkovProcess.printDenseMatrix(java.io.PrintWriter, int, int, boolean, boolean, int[])}{{\bf printDenseMatrix(PrintWriter, int, int, boolean, boolean, int\lbrack \rbrack )}} Prints a description of the Model using the given PrintWriter: the States and the Transition Matrix.\\
\hyperlink{jmarkov.MarkovProcess.printEventsRates(java.io.PrintWriter)}{{\bf printEventsRates(PrintWriter)}} Prints a table reporting the steadystate occurrance of all events.\\
\hyperlink{jmarkov.MarkovProcess.printEventsRates(java.io.PrintWriter, int, int)}{{\bf printEventsRates(PrintWriter, int, int)}} Prints a table reporting the steadystate occurrance of all events.\\
\hyperlink{jmarkov.MarkovProcess.printMOPs()}{{\bf printMOPs()}} Prints the Measures of performance (MOPS) on standard output.\\
\hyperlink{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter)}{{\bf printMOPs(PrintWriter)}} Prints a String description of all MOPs in steady state (it reports mean and standard deviation), with a width of 10 and 5 decimal figures.\\
\hyperlink{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter, int, int)}{{\bf printMOPs(PrintWriter, int, int)}} Prints a String description of all MOPs in steady state (it reports mean and standard deviation).\\
\hyperlink{jmarkov.MarkovProcess.printStates(java.io.PrintWriter)}{{\bf printStates(PrintWriter)}} Prints a description of the States and the Equilibrium Probabilities.\\
\hyperlink{jmarkov.MarkovProcess.printStates(java.io.PrintWriter, int, int)}{{\bf printStates(PrintWriter, int, int)}} Prints a description of the States and the Equilibrium Probabilities.\\
\hyperlink{jmarkov.MarkovProcess.reset()}{{\bf reset()}} Resets the Model.\\
\hyperlink{jmarkov.MarkovProcess.reset(boolean)}{{\bf reset(boolean)}} Resets the Model.\\
\hyperlink{jmarkov.MarkovProcess.resetResults()}{{\bf resetResults()}} Resets the result of the model.\\
\hyperlink{jmarkov.MarkovProcess.setDebugLevel(int)}{{\bf setDebugLevel(int)}} Sets the debug level, where level=0 means no debug info, level = 5 verbose info.\\
\hyperlink{jmarkov.MarkovProcess.setDebugReporter(jmarkov.DebugReporter)}{{\bf setDebugReporter(DebugReporter)}} Sets the DebugReporter to use.\\
\hyperlink{jmarkov.MarkovProcess.setEventSet(jmarkov.basic.EventsSet)}{{\bf setEventSet(EventsSet)}} Sets the Events set.\\
\hyperlink{jmarkov.MarkovProcess.setInitialState(S)}{{\bf setInitialState(S)}} Sets the initial state.\\
\hyperlink{jmarkov.MarkovProcess.setMaxStates(long)}{{\bf setMaxStates(long)}} Sets the maximum number of states to generate.\\
\hyperlink{jmarkov.MarkovProcess.setMOPs(java.lang.String[])}{{\bf setMOPs(String\lbrack \rbrack )}} Sets the names of all MOPs (measures of performance).\\
\hyperlink{jmarkov.MarkovProcess.setSteadyStateSolver(jmarkov.solvers.SteadyStateSolver)}{{\bf setSteadyStateSolver(SteadyStateSolver)}} Allows the user to set an alternate solver.\\
\hyperlink{jmarkov.MarkovProcess.setTransientSolver(jmarkov.solvers.TransientSolver)}{{\bf setTransientSolver(TransientSolver)}} Allows the user to set an alternate solver.\\
\hyperlink{jmarkov.MarkovProcess.showGUI()}{{\bf showGUI()}} Shows the Graphic User Interface (GUI) that represent this Markov Chain.\\
\hyperlink{jmarkov.MarkovProcess.statesLableMaxWidth(int)}{{\bf statesLableMaxWidth(int)}} Computes the maximum used by the state's labels.\\
\hyperlink{jmarkov.MarkovProcess.statesToString()}{{\bf statesToString()}} Prints a description of the States and the Equilibrium Probabilities.\\
\hyperlink{jmarkov.MarkovProcess.toString()}{{\bf toString()}} \\
\hyperlink{jmarkov.MarkovProcess.vLine()}{{\bf vLine()}} Returns a text vertical line.\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{cnt}
\label{jmarkov.MarkovProcess.cnt}\hypertarget{jmarkov.MarkovProcess.cnt}{protected int {\bf cnt}}
\begin{itemize}
\item{\vskip -.9ex 
Number of completed states. Use this counter so that GUI updates correctly.}
\end{itemize}
}
\item{
\index{theStates}
\label{jmarkov.MarkovProcess.theStates}\hypertarget{jmarkov.MarkovProcess.theStates}{protected basic.StatesSet {\bf theStates}}
\begin{itemize}
\item{\vskip -.9ex 
Set of fully analyzed States}
\end{itemize}
}
\item{
\index{name}
\label{jmarkov.MarkovProcess.name}\hypertarget{jmarkov.MarkovProcess.name}{protected java.lang.String {\bf name}}
\begin{itemize}
\item{\vskip -.9ex 
The name of the model. For a long description override {\tt\small description(){\tt\small .}}}
\item{{ See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.description()}{MarkovProcess.description()}} {\small 
\refdefined{jmarkov.MarkovProcess.description()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}
\item{
\index{defaultSteadyStateSolver}
\label{jmarkov.MarkovProcess.defaultSteadyStateSolver}\hypertarget{jmarkov.MarkovProcess.defaultSteadyStateSolver}{protected solvers.SteadyStateSolver {\bf defaultSteadyStateSolver}}
\begin{itemize}
\item{\vskip -.9ex 
Default Transient Solver}
\end{itemize}
}
\item{
\index{defaultTransientSolver}
\label{jmarkov.MarkovProcess.defaultTransientSolver}\hypertarget{jmarkov.MarkovProcess.defaultTransientSolver}{protected solvers.TransientSolver {\bf defaultTransientSolver}}
\begin{itemize}
\item{\vskip -.9ex 
Deafualt Transient solver}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MarkovProcess()}
\hypertarget{jmarkov.MarkovProcess()}{\membername{MarkovProcess}}
{\tt protected\ {\bf MarkovProcess}(  )
\label{jmarkov.MarkovProcess()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

If a constructor calls this constructor then it MUST call setEvents and setInitialState afterwards.
}
\end{itemize}
}%end item
\divideents{MarkovProcess}
\item{\vskip -1.9ex 
\index{MarkovProcess(S, EventsSet)}
\hypertarget{jmarkov.MarkovProcess(S, jmarkov.basic.EventsSet)}{\membername{MarkovProcess}}
{\tt public\ {\bf MarkovProcess}( {\tt basic.State} {\bf i0},
{\tt basic.EventsSet} {\bf eSet} )
\label{jmarkov.MarkovProcess(S, jmarkov.basic.EventsSet)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Builds a SimpleMarkovProcess that contains all states reachable from i0, and with E being the set of all possible events.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i0} -- The initial State.}
   \item{
\sld
{\tt eSet} -- The set of all Events.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MarkovProcess}
\item{\vskip -1.9ex 
\index{MarkovProcess(S, EventsSet, String)}
\hypertarget{jmarkov.MarkovProcess(S, jmarkov.basic.EventsSet, java.lang.String)}{\membername{MarkovProcess}}
{\tt public\ {\bf MarkovProcess}( {\tt basic.State} {\bf i0},
{\tt basic.EventsSet} {\bf eSet},
{\tt java.lang.String} {\bf name} )
\label{jmarkov.MarkovProcess(S, jmarkov.basic.EventsSet, java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Builds a SimpleMarkovProcess that contains all states reachable from i0, and with E being the set of all possible events.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i0} -- The initial State.}
   \item{
\sld
{\tt eSet} -- The set of all Events.}
   \item{
\sld
{\tt name} -- The name of the Model.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{activeTransitions(S, E)}
\hypertarget{jmarkov.MarkovProcess.activeTransitions(S, E)}{\membername{activeTransitions}}
{\tt public abstract basic.Transitions\ {\bf activeTransitions}( {\tt basic.State} {\bf i},
{\tt basic.Event} {\bf e} )
\label{jmarkov.MarkovProcess.activeTransitions(S, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The user MUST implement this Function in order to describe the dynamics of the model. For the current state i, and on action e, the user has to describe the transtions that can occur. This implies finding all destination states and the rate at which the transtions occur. There is no guarantee that the event is active, so the user should check for this. If the event is not active an empty Transition element should be returned. A typical code for a queuing system should look like this: {\tt\small public abstract Transitions activeTransitions(MyState i, MyEvent e)\{\ TransitionsSet trans = new TransitionsSet(); case (ARRIVAL) if (i.size() capacity) trans.add(i.doArrival(), arrRate); break; case(DEPARTURE) if (i.size() \textgreater =1) trans.add(i.doDeparture, serviceRate); break; \}\ return trans; \}\ }
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- The current State.}
   \item{
\sld
{\tt e} -- The ocurring event.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The transitions that occur at this state when (and if) this events occurs. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.Transitions}{basic.Transitions}} {\small 
\refdefined{jmarkov.basic.Transitions}}%end
}
\item{ {\tt \hyperlink{jmarkov.basic.TransitionsSet}{basic.TransitionsSet}} {\small 
\refdefined{jmarkov.basic.TransitionsSet}}%end
}
\item{ {\tt \hyperlink{jmarkov.basic.Transitions}{basic.Transitions}} {\small 
\refdefined{jmarkov.basic.Transitions}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{addMOP}
\item{\vskip -1.9ex 
\index{addMOP(String)}
\hypertarget{jmarkov.MarkovProcess.addMOP(java.lang.String)}{\membername{addMOP}}
{\tt public boolean\ {\bf addMOP}( {\tt java.lang.String} {\bf mopName} )
\label{jmarkov.MarkovProcess.addMOP(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method declares the existance of a measure of performance (MOP). The MOP for every state is calculated in the class that extends the State class.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mopName} -- The name of the new MOP.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
true if the name already existed. 
}%end item
\end{itemize}
}%end item
\divideents{allToString}
\item{\vskip -1.9ex 
\index{allToString()}
\hypertarget{jmarkov.MarkovProcess.allToString()}{\membername{allToString}}
{\tt public java.lang.String\ {\bf allToString}(  )
\label{jmarkov.MarkovProcess.allToString()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Retuns a String description of the model and solution.
}
\item{{\bf Returns} -- 
a String wit the information of printAll. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.printAll()}{MarkovProcess.printAll()}} {\small 
\refdefined{jmarkov.MarkovProcess.printAll()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{canGo}
\item{\vskip -1.9ex 
\index{canGo()}
\hypertarget{jmarkov.MarkovProcess.canGo()}{\membername{canGo}}
{\tt public boolean\ {\bf canGo}(  )
\label{jmarkov.MarkovProcess.canGo()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Allos to stop model execution by graphica user interface.
}
\item{{\bf Returns} -- 
Used to check with the GUI if the user has requested to stop. 
}%end item
\end{itemize}
}%end item
\divideents{clearMOPs}
\item{\vskip -1.9ex 
\index{clearMOPs()}
\hypertarget{jmarkov.MarkovProcess.clearMOPs()}{\membername{clearMOPs}}
{\tt public void\ {\bf clearMOPs}(  )
\label{jmarkov.MarkovProcess.clearMOPs()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Clear all MOPs defined in the system.
}
\end{itemize}
}%end item
\divideents{debug}
\item{\vskip -1.9ex 
\index{debug(int, String)}
\hypertarget{jmarkov.MarkovProcess.debug(int, java.lang.String)}{\membername{debug}}
{\tt public void\ {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s} )
\label{jmarkov.MarkovProcess.debug(int, java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints debug information with this importance level
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- }
   \item{
\sld
{\tt s} -- The message to send.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{debug}
\item{\vskip -1.9ex 
\index{debug(int, String, boolean)}
\hypertarget{jmarkov.MarkovProcess.debug(int, java.lang.String, boolean)}{\membername{debug}}
{\tt public void\ {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
\label{jmarkov.MarkovProcess.debug(int, java.lang.String, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints debug information with this importance level
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- The level of importance (0=show always, 5= show on debug level is 5).}
   \item{
\sld
{\tt s} -- The message}
   \item{
\sld
{\tt newline} -- Whether a new line should be written.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{debug}
\item{\vskip -1.9ex 
\index{debug(int, String, boolean, boolean)}
\hypertarget{jmarkov.MarkovProcess.debug(int, java.lang.String, boolean, boolean)}{\membername{debug}}
{\tt public void\ {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
\label{jmarkov.MarkovProcess.debug(int, java.lang.String, boolean, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints debug information with this importance level
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- The level of importance (0=show always, 5= show on debug level is 5).}
   \item{
\sld
{\tt s} -- The string to write.}
   \item{
\sld
{\tt newline} -- Whether to use a new line.}
   \item{
\sld
{\tt indent} -- Whether it should indent according to level.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{denseMatrixToString}
\item{\vskip -1.9ex 
\index{denseMatrixToString()}
\hypertarget{jmarkov.MarkovProcess.denseMatrixToString()}{\membername{denseMatrixToString}}
{\tt public java.lang.String\ {\bf denseMatrixToString}(  )
\label{jmarkov.MarkovProcess.denseMatrixToString()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a String with a description of the Model: the States and the Transition Matrix. Its use is not recommended for large models.
}
\item{{\bf Returns} -- 
A string with the Matrix 
}%end item
\end{itemize}
}%end item
\divideents{denseMatrixToString}
\item{\vskip -1.9ex 
\index{denseMatrixToString(int, int, boolean, boolean)}
\hypertarget{jmarkov.MarkovProcess.denseMatrixToString(int, int, boolean, boolean)}{\membername{denseMatrixToString}}
{\tt public java.lang.String\ {\bf denseMatrixToString}( {\tt int} {\bf width},
{\tt int} {\bf rateDecimals},
{\tt boolean} {\bf printZeros},
{\tt boolean} {\bf useGenerator} )
\label{jmarkov.MarkovProcess.denseMatrixToString(int, int, boolean, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the Transition Matrix as a String. Its use is not recommended for large models.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt width} -- The width of each column.}
   \item{
\sld
{\tt rateDecimals} -- The number of decimals for the rates.}
   \item{
\sld
{\tt printZeros} -- Whether zeros or blanks should be printed.}
   \item{
\sld
{\tt useGenerator} -- whether the generator matrix {\bf Q}, rather than the rates matrix should be printed.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
A String description of the rates or generator matrix. 
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.MarkovProcess.description()}{\membername{description}}
{\tt public abstract java.lang.String\ {\bf description}(  )
\label{jmarkov.MarkovProcess.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method should be implemented by the subclass to give word description of the model. For example it should say: Queueing system with 2 servers and exponential arrivals with rate 50 per hour.
}
\item{{\bf Returns} -- 
A description of the Model 
}%end item
\end{itemize}
}%end item
\divideents{eventRatesToString}
\item{\vskip -1.9ex 
\index{eventRatesToString(int, int)}
\hypertarget{jmarkov.MarkovProcess.eventRatesToString(int, int)}{\membername{eventRatesToString}}
{\tt public java.lang.String\ {\bf eventRatesToString}( {\tt int} {\bf width},
{\tt int} {\bf decimals} )
\label{jmarkov.MarkovProcess.eventRatesToString(int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return a String as printed by printEventsrates
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt width} -- Maximum width for each number}
   \item{
\sld
{\tt decimals} -- Number of decimals}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
A string with the valus of all Rates 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.printEventsRates(java.io.PrintWriter, int, int)}{MarkovProcess.printEventsRates(PrintWriter,\allowbreak int,\allowbreak int)}} {\small 
\refdefined{jmarkov.MarkovProcess.printEventsRates(java.io.PrintWriter, int, int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{eventsRatesToString}
\item{\vskip -1.9ex 
\index{eventsRatesToString()}
\hypertarget{jmarkov.MarkovProcess.eventsRatesToString()}{\membername{eventsRatesToString}}
{\tt public java.lang.String\ {\bf eventsRatesToString}(  )
\label{jmarkov.MarkovProcess.eventsRatesToString()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return a string as eventsRatesToString, with width 8 and 4 decimals
}
\item{{\bf Returns} -- 
A string with the information. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.eventRatesToString(int, int)}{MarkovProcess.eventRatesToString(int,\allowbreak int)}} {\small 
\refdefined{jmarkov.MarkovProcess.eventRatesToString(int, int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{finalize}
\item{\vskip -1.9ex 
\index{finalize()}
\hypertarget{jmarkov.MarkovProcess.finalize()}{\membername{finalize}}
{\tt protected void\ {\bf finalize}(  ) throws java.lang.Throwable
\label{jmarkov.MarkovProcess.finalize()}}%end signature
}%end item
\divideents{generate}
\item{\vskip -1.9ex 
\index{generate()}
\hypertarget{jmarkov.MarkovProcess.generate()}{\membername{generate}}
{\tt public void\ {\bf generate}(  )
\label{jmarkov.MarkovProcess.generate()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

generate() builds the space state and rate matrix using the algorithm BuildsSR. (See Ciardo, G. "Tools for formulating Markov Processes", chapter 2 in Grassman W. "Computational Probability". Kluwer). The states can be collected later with getStates and the rates can be accessed in disperse form with the method {\tt\small getRate(j)} of every state. Alternatively the method {\tt\small getGenerator()} and {\tt\small getRates()} access the generator matriz or rate matrix in compact form.
}
\end{itemize}
}%end item
\divideents{getDebugLevel}
\item{\vskip -1.9ex 
\index{getDebugLevel()}
\hypertarget{jmarkov.MarkovProcess.getDebugLevel()}{\membername{getDebugLevel}}
{\tt public int\ {\bf getDebugLevel}(  )
\label{jmarkov.MarkovProcess.getDebugLevel()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
current debug level, where level=0 means no debug info and level = 4 verbose info. 
}%end item
\end{itemize}
}%end item
\divideents{getDebugReporter}
\item{\vskip -1.9ex 
\index{getDebugReporter()}
\hypertarget{jmarkov.MarkovProcess.getDebugReporter()}{\membername{getDebugReporter}}
{\tt public DebugReporter\ {\bf getDebugReporter}(  )
\label{jmarkov.MarkovProcess.getDebugReporter()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the DebugReporter currently in use.
}
\item{{\bf Returns} -- 
a DebugReporter where debug information is sent. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.DebugReporter}{DebugReporter}} {\small 
\refdefined{jmarkov.DebugReporter}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getDefaultSteadyStateSolver}
\item{\vskip -1.9ex 
\index{getDefaultSteadyStateSolver()}
\hypertarget{jmarkov.MarkovProcess.getDefaultSteadyStateSolver()}{\membername{getDefaultSteadyStateSolver}}
{\tt protected final solvers.SteadyStateSolver\ {\bf getDefaultSteadyStateSolver}(  )
\label{jmarkov.MarkovProcess.getDefaultSteadyStateSolver()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the default SteadyStateSolver.
}
\item{{\bf Returns} -- 
the default SteadyStateSolver. 
}%end item
\end{itemize}
}%end item
\divideents{getDefaultTransientSolver}
\item{\vskip -1.9ex 
\index{getDefaultTransientSolver()}
\hypertarget{jmarkov.MarkovProcess.getDefaultTransientSolver()}{\membername{getDefaultTransientSolver}}
{\tt protected solvers.TransientSolver\ {\bf getDefaultTransientSolver}(  )
\label{jmarkov.MarkovProcess.getDefaultTransientSolver()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The default solver for transient state.
}
\item{{\bf Returns} -- 
Returns the default transientSolver. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.TransientSolver}{solvers.TransientSolver}} {\small 
\refdefined{jmarkov.solvers.TransientSolver}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getEventClass}
\item{\vskip -1.9ex 
\index{getEventClass()}
\hypertarget{jmarkov.MarkovProcess.getEventClass()}{\membername{getEventClass}}
{\tt public java.lang.Class\ {\bf getEventClass}(  )
\label{jmarkov.MarkovProcess.getEventClass()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The Class for the Events in the system.
}
\item{{\bf Returns} -- 
The event Class in the model 
}%end item
\end{itemize}
}%end item
\divideents{getEventNames}
\item{\vskip -1.9ex 
\index{getEventNames()}
\hypertarget{jmarkov.MarkovProcess.getEventNames()}{\membername{getEventNames}}
{\tt public java.lang.String\lbrack \rbrack \ {\bf getEventNames}(  )
\label{jmarkov.MarkovProcess.getEventNames()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the defined events
}
\item{{\bf Returns} -- 
aan array with the names of all Events 
}%end item
\end{itemize}
}%end item
\divideents{getEventRate}
\item{\vskip -1.9ex 
\index{getEventRate(int)}
\hypertarget{jmarkov.MarkovProcess.getEventRate(int)}{\membername{getEventRate}}
{\tt public double\ {\bf getEventRate}( {\tt int} {\bf eNum} ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.MarkovProcess.getEventRate(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the steadystate rate of occurrance of the Events number eNum.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt eNum} -- The even number in the event set.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
an array for all the steady state rates. The order is that of the events set. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getEvents}
\item{\vskip -1.9ex 
\index{getEvents()}
\hypertarget{jmarkov.MarkovProcess.getEvents()}{\membername{getEvents}}
{\tt public basic.Event\lbrack \rbrack \ {\bf getEvents}(  )
\label{jmarkov.MarkovProcess.getEvents()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns all The events defined in the model.
}
\item{{\bf Returns} -- 
Events array 
}%end item
\end{itemize}
}%end item
\divideents{getEventsRates}
\item{\vskip -1.9ex 
\index{getEventsRates()}
\hypertarget{jmarkov.MarkovProcess.getEventsRates()}{\membername{getEventsRates}}
{\tt public double\lbrack \rbrack \ {\bf getEventsRates}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.MarkovProcess.getEventsRates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return an array with the steadystate rate of occurrance of all the Events.
}
\item{{\bf Returns} -- 
an array for all the steady state rates. The order is that of the events set. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getFinalRate}
\item{\vskip -1.9ex 
\index{getFinalRate(S, S)}
\hypertarget{jmarkov.MarkovProcess.getFinalRate(S, S)}{\membername{getFinalRate}}
{\tt public synchronized double\ {\bf getFinalRate}( {\tt basic.State} {\bf i},
{\tt basic.State} {\bf j} )
\label{jmarkov.MarkovProcess.getFinalRate(S, S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the total rate form State number i to j. The number is relative to the ordered set of all states, therefore this method causes the model to be generated if it has not been generated.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- origin State}
   \item{
\sld
{\tt j} -- destination state}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
total rate 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRate(S, S)}{MarkovProcess.getRate(State,\allowbreak State)}} {\small 
\refdefined{jmarkov.MarkovProcess.getRate(S, S)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getGenerator}
\item{\vskip -1.9ex 
\index{getGenerator()}
\hypertarget{jmarkov.MarkovProcess.getGenerator()}{\membername{getGenerator}}
{\tt public double\lbrack \rbrack \lbrack \rbrack \ {\bf getGenerator}(  )
\label{jmarkov.MarkovProcess.getGenerator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the infinitesimal generator matrix {\bf Q }, in dense format. It generates the model if it has not been generated.
}
\item{{\bf Returns} -- 
The generator Matrix. 
}%end item
\end{itemize}
}%end item
\divideents{getInitialState}
\item{\vskip -1.9ex 
\index{getInitialState()}
\hypertarget{jmarkov.MarkovProcess.getInitialState()}{\membername{getInitialState}}
{\tt protected basic.State\ {\bf getInitialState}(  )
\label{jmarkov.MarkovProcess.getInitialState()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

returns the initial state.
}
\item{{\bf Returns} -- 
The initial state. 
}%end item
\end{itemize}
}%end item
\divideents{getMaxStates}
\item{\vskip -1.9ex 
\index{getMaxStates()}
\hypertarget{jmarkov.MarkovProcess.getMaxStates()}{\membername{getMaxStates}}
{\tt public long\ {\bf getMaxStates}(  )
\label{jmarkov.MarkovProcess.getMaxStates()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
the Maximum number of states to generate. 
}%end item
\end{itemize}
}%end item
\divideents{getMOPIndex}
\item{\vskip -1.9ex 
\index{getMOPIndex(String)}
\hypertarget{jmarkov.MarkovProcess.getMOPIndex(java.lang.String)}{\membername{getMOPIndex}}
{\tt public int\ {\bf getMOPIndex}( {\tt java.lang.String} {\bf name} )
\label{jmarkov.MarkovProcess.getMOPIndex(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the index that correspond to this MOP.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt name} -- MOP name}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The index of the MOP with this name 
}%end item
\end{itemize}
}%end item
\divideents{getMOPNames}
\item{\vskip -1.9ex 
\index{getMOPNames()}
\hypertarget{jmarkov.MarkovProcess.getMOPNames()}{\membername{getMOPNames}}
{\tt public java.lang.String\lbrack \rbrack \ {\bf getMOPNames}(  )
\label{jmarkov.MarkovProcess.getMOPNames()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return all the names of defined MOPs.
}
\item{{\bf Returns} -- 
an array with all the MOP's defined. 
}%end item
\end{itemize}
}%end item
\divideents{getMOPNames}
\item{\vskip -1.9ex 
\index{getMOPNames(int)}
\hypertarget{jmarkov.MarkovProcess.getMOPNames(int)}{\membername{getMOPNames}}
{\tt public java.lang.String\ {\bf getMOPNames}( {\tt int} {\bf mopNum} )
\label{jmarkov.MarkovProcess.getMOPNames(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the names of the i-th MOP.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mopNum} -- The number i of the MOP}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The name of the i-th MOP. 
}%end item
\end{itemize}
}%end item
\divideents{getMOPsAvg}
\item{\vskip -1.9ex 
\index{getMOPsAvg()}
\hypertarget{jmarkov.MarkovProcess.getMOPsAvg()}{\membername{getMOPsAvg}}
{\tt public double\lbrack \rbrack \ {\bf getMOPsAvg}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.MarkovProcess.getMOPsAvg()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns an array with the average of all the steady state measures of performance. The order is the same as in getMOPNames.
}
\item{{\bf Returns} -- 
An array containing the values of all MOPs averages. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getMOPsMoment(int)}{MarkovProcess.getMOPsMoment(int)}} {\small 
\refdefined{jmarkov.MarkovProcess.getMOPsMoment(int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMOPsAvg}
\item{\vskip -1.9ex 
\index{getMOPsAvg(int)}
\hypertarget{jmarkov.MarkovProcess.getMOPsAvg(int)}{\membername{getMOPsAvg}}
{\tt public double\ {\bf getMOPsAvg}( {\tt int} {\bf mopNum} ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.MarkovProcess.getMOPsAvg(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the steady state measures average of the MOP numbre mopNum.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mopNum} -- The Number of the MOP of the which the average is to be computed.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The long run averagefor this MOP. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMOPsAvg}
\item{\vskip -1.9ex 
\index{getMOPsAvg(String)}
\hypertarget{jmarkov.MarkovProcess.getMOPsAvg(java.lang.String)}{\membername{getMOPsAvg}}
{\tt public double\ {\bf getMOPsAvg}( {\tt java.lang.String} {\bf mopName} ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.MarkovProcess.getMOPsAvg(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the steady state measures average of the MOP with name mopName.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mopName} -- The name whose Averga is to be computed.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The long run averagefor this MOP. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMOPsMoment}
\item{\vskip -1.9ex 
\index{getMOPsMoment(int)}
\hypertarget{jmarkov.MarkovProcess.getMOPsMoment(int)}{\membername{getMOPsMoment}}
{\tt public double\lbrack \rbrack \ {\bf getMOPsMoment}( {\tt int} {\bf m} ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.MarkovProcess.getMOPsMoment(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns an array with the m-th moment of all the steady state measures of performance. The order is the same as in getMOPNames.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt m} -- the order of the moment desired. m=1 is the expected value.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
An array containing the values of all MOPs m-th moments. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMOPsMoment}
\item{\vskip -1.9ex 
\index{getMOPsMoment(int, int)}
\hypertarget{jmarkov.MarkovProcess.getMOPsMoment(int, int)}{\membername{getMOPsMoment}}
{\tt public double\ {\bf getMOPsMoment}( {\tt int} {\bf mopNum},
{\tt int} {\bf m} ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.MarkovProcess.getMOPsMoment(int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the steady state measures m-th moment of the MOP number mopNum. m=1 is the long-run expected value, m=2 expected value of the square, etc.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mopNum} -- The number for the MOP}
   \item{
\sld
{\tt m} -- The value of m.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The m-th moments for this MOP. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMOPsMoment}
\item{\vskip -1.9ex 
\index{getMOPsMoment(String, int)}
\hypertarget{jmarkov.MarkovProcess.getMOPsMoment(java.lang.String, int)}{\membername{getMOPsMoment}}
{\tt public double\ {\bf getMOPsMoment}( {\tt java.lang.String} {\bf mopName},
{\tt int} {\bf m} ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.MarkovProcess.getMOPsMoment(java.lang.String, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the steady state measures m-th moment of the MOP with name mopName. m=1 is the long-run expected value.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mopName} -- The name of the MOP that is to be computed}
   \item{
\sld
{\tt m} -- Valu of the moment}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The m-th moments for this MOP. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMtjGenerator}
\item{\vskip -1.9ex 
\index{getMtjGenerator()}
\hypertarget{jmarkov.MarkovProcess.getMtjGenerator()}{\membername{getMtjGenerator}}
{\tt public no.uib.cipr.matrix.Matrix\ {\bf getMtjGenerator}(  )
\label{jmarkov.MarkovProcess.getMtjGenerator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The generator {\bf Q} as an MTJ Matrix
}
\item{{\bf Returns} -- 
The matrix Q. 
}%end item
\end{itemize}
}%end item
\divideents{getMtjRates}
\item{\vskip -1.9ex 
\index{getMtjRates()}
\hypertarget{jmarkov.MarkovProcess.getMtjRates()}{\membername{getMtjRates}}
{\tt public synchronized no.uib.cipr.matrix.Matrix\ {\bf getMtjRates}(  )
\label{jmarkov.MarkovProcess.getMtjRates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the transition rates matrix {\bf R} in MTJ format. It generates the model if it has not been generated.
}
\item{{\bf Returns} -- 
an mt.Matrix with the matrix. 
}%end item
\end{itemize}
}%end item
\divideents{getNumStates}
\item{\vskip -1.9ex 
\index{getNumStates()}
\hypertarget{jmarkov.MarkovProcess.getNumStates()}{\membername{getNumStates}}
{\tt public int\ {\bf getNumStates}(  )
\label{jmarkov.MarkovProcess.getNumStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the number of States in the model. If the model has not been generated, then it will be automatically generated.
}
\item{{\bf Returns} -- 
the number of States in the model. 
}%end item
\end{itemize}
}%end item
\divideents{getProgress}
\item{\vskip -1.9ex 
\index{getProgress()}
\hypertarget{jmarkov.MarkovProcess.getProgress()}{\membername{getProgress}}
{\tt public long\ {\bf getProgress}(  )
\label{jmarkov.MarkovProcess.getProgress()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the number of states processed so far in the current process.
}
\item{{\bf Returns} -- 
the number of states processed so far. 
}%end item
\end{itemize}
}%end item
\divideents{getRate}
\item{\vskip -1.9ex 
\index{getRate(S, S)}
\hypertarget{jmarkov.MarkovProcess.getRate(S, S)}{\membername{getRate}}
{\tt public synchronized double\ {\bf getRate}( {\tt basic.State} {\bf i},
{\tt basic.State} {\bf j} )
\label{jmarkov.MarkovProcess.getRate(S, S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the current total rate form i to j. {\bf Warnning:} If the model has not been generated id returns the current total rate, it does not causes the generation of the model. Run {\tt\small generate()} first.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- origin State}
   \item{
\sld
{\tt j} -- destination state}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
total rate 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.generate()}{MarkovProcess.generate()}} {\small 
\refdefined{jmarkov.MarkovProcess.generate()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getRates}
\item{\vskip -1.9ex 
\index{getRates()}
\hypertarget{jmarkov.MarkovProcess.getRates()}{\membername{getRates}}
{\tt public synchronized double\lbrack \rbrack \lbrack \rbrack \ {\bf getRates}(  )
\label{jmarkov.MarkovProcess.getRates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the transition rates matrix {\bf R} in dense format. It generates the model if it has not been generated.
}
\item{{\bf Returns} -- 
an array with the matrix. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRate(S, S)}{MarkovProcess.getRate(State,\allowbreak State)}} {\small 
\refdefined{jmarkov.MarkovProcess.getRate(S, S)}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRates(S)}{MarkovProcess.getRates(State)}} {\small 
\refdefined{jmarkov.MarkovProcess.getRates(S)}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getMtjRates()}{MarkovProcess.getMtjRates()}} {\small 
\refdefined{jmarkov.MarkovProcess.getMtjRates()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getRates}
\item{\vskip -1.9ex 
\index{getRates(S)}
\hypertarget{jmarkov.MarkovProcess.getRates(S)}{\membername{getRates}}
{\tt public synchronized basic.Transitions\ {\bf getRates}( {\tt basic.State} {\bf i} )
\label{jmarkov.MarkovProcess.getRates(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method returns a dynamic data structure with the rate from State i to all reachable states.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- State}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Rates to reachable states 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.Transitions}{basic.Transitions}} {\small 
\refdefined{jmarkov.basic.Transitions}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getStateClass}
\item{\vskip -1.9ex 
\index{getStateClass()}
\hypertarget{jmarkov.MarkovProcess.getStateClass()}{\membername{getStateClass}}
{\tt public java.lang.Class\ {\bf getStateClass}(  )
\label{jmarkov.MarkovProcess.getStateClass()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The Class for the states in this model.
}
\item{{\bf Returns} -- 
The class for the states 
}%end item
\end{itemize}
}%end item
\divideents{getStates}
\item{\vskip -1.9ex 
\index{getStates()}
\hypertarget{jmarkov.MarkovProcess.getStates()}{\membername{getStates}}
{\tt public basic.StatesSet\ {\bf getStates}(  )
\label{jmarkov.MarkovProcess.getStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns an array with all the States in the model. It generates the model if it has not been generated.
}
\item{{\bf Returns} -- 
The States 
}%end item
\end{itemize}
}%end item
\divideents{getStates}
\item{\vskip -1.9ex 
\index{getStates(boolean)}
\hypertarget{jmarkov.MarkovProcess.getStates(boolean)}{\membername{getStates}}
{\tt public basic.StatesSet\ {\bf getStates}( {\tt boolean} {\bf causesGeneration} )
\label{jmarkov.MarkovProcess.getStates(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns an array with the States in the model that have been checked so far. If {\tt\small generate} is true it generates the model if it has not been generated. If no states have been generates it returns null.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt causesGeneration} -- whether the model should be generated.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
ann array with the states found and checked so far. 
}%end item
\end{itemize}
}%end item
\divideents{getStatus}
\item{\vskip -1.9ex 
\index{getStatus()}
\hypertarget{jmarkov.MarkovProcess.getStatus()}{\membername{getStatus}}
{\tt public MarkovProcess.Status\ {\bf getStatus}(  )
\label{jmarkov.MarkovProcess.getStatus()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the current status of the model.
}
\item{{\bf Returns} -- 
One of the constants IDLE, RUNNING, GENERATED, SUSPENDED, ERROR 
}%end item
\end{itemize}
}%end item
\divideents{getStatusMsg}
\item{\vskip -1.9ex 
\index{getStatusMsg()}
\hypertarget{jmarkov.MarkovProcess.getStatusMsg()}{\membername{getStatusMsg}}
{\tt public java.lang.String\ {\bf getStatusMsg}(  )
\label{jmarkov.MarkovProcess.getStatusMsg()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a String describing the current status of the model.
}
\item{{\bf Returns} -- 
a String describing the current status of the model. 
}%end item
\end{itemize}
}%end item
\divideents{getSteadyState}
\item{\vskip -1.9ex 
\index{getSteadyState()}
\hypertarget{jmarkov.MarkovProcess.getSteadyState()}{\membername{getSteadyState}}
{\tt public double\lbrack \rbrack \ {\bf getSteadyState}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.MarkovProcess.getSteadyState()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the steady state probabilities for this model. Theat is, it solves the balance equations. It returns an array of zeros if there is no unique solution.
}
\item{{\bf Returns} -- 
An array with the steady-state probabilities. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getSteadyStateSolver}
\item{\vskip -1.9ex 
\index{getSteadyStateSolver()}
\hypertarget{jmarkov.MarkovProcess.getSteadyStateSolver()}{\membername{getSteadyStateSolver}}
{\tt public solvers.SteadyStateSolver\ {\bf getSteadyStateSolver}(  )
\label{jmarkov.MarkovProcess.getSteadyStateSolver()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The currently defined solver.
}
\item{{\bf Returns} -- 
Returns the steadyStateSolver. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.SteadyStateSolver}{solvers.SteadyStateSolver}} {\small 
\refdefined{jmarkov.solvers.SteadyStateSolver}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getTransientSolver}
\item{\vskip -1.9ex 
\index{getTransientSolver()}
\hypertarget{jmarkov.MarkovProcess.getTransientSolver()}{\membername{getTransientSolver}}
{\tt public solvers.TransientSolver\ {\bf getTransientSolver}(  )
\label{jmarkov.MarkovProcess.getTransientSolver()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The currently defined solver for transient state.
}
\item{{\bf Returns} -- 
Returns the transientSolver. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.TransientSolver}{solvers.TransientSolver}} {\small 
\refdefined{jmarkov.solvers.TransientSolver}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{go}
\item{\vskip -1.9ex 
\index{go()}
\hypertarget{jmarkov.MarkovProcess.go()}{\membername{go}}
{\tt public synchronized void\ {\bf go}(  )
\label{jmarkov.MarkovProcess.go()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Runs the model, or resumes execution if it had been suspended. Its use is intended for Graphical User Interface(GUI). A standard user should use {\tt\small generate()} instead.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.generate()}{MarkovProcess.generate()}} {\small 
\refdefined{jmarkov.MarkovProcess.generate()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{goStep}
\item{\vskip -1.9ex 
\index{goStep()}
\hypertarget{jmarkov.MarkovProcess.goStep()}{\membername{goStep}}
{\tt public synchronized void\ {\bf goStep}(  )
\label{jmarkov.MarkovProcess.goStep()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Runs the model for a single step. Its use is intended for Graphical User Interface(GUI). A standard user should use {\tt\small generate()} instead.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.generate()}{MarkovProcess.generate()}} {\small 
\refdefined{jmarkov.MarkovProcess.generate()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.go()}{MarkovProcess.go()}} {\small 
\refdefined{jmarkov.MarkovProcess.go()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{hideGUI}
\item{\vskip -1.9ex 
\index{hideGUI()}
\hypertarget{jmarkov.MarkovProcess.hideGUI()}{\membername{hideGUI}}
{\tt public void\ {\bf hideGUI}(  )
\label{jmarkov.MarkovProcess.hideGUI()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Hides the Graphic User Interface (GUI) that represent this Markov Chain if one is defined.
}
\end{itemize}
}%end item
\divideents{hLine}
\item{\vskip -1.9ex 
\index{hLine(int)}
\hypertarget{jmarkov.MarkovProcess.hLine(int)}{\membername{hLine}}
{\tt protected java.lang.String\ {\bf hLine}( {\tt int} {\bf length} )
\label{jmarkov.MarkovProcess.hLine(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Retuns an horizontal text line of the given length.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt length} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
a horizontal line. 
}%end item
\end{itemize}
}%end item
\divideents{isGenerated}
\item{\vskip -1.9ex 
\index{isGenerated()}
\hypertarget{jmarkov.MarkovProcess.isGenerated()}{\membername{isGenerated}}
{\tt public boolean\ {\bf isGenerated}(  )
\label{jmarkov.MarkovProcess.isGenerated()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
true if the model has been completely generated 
}%end item
\end{itemize}
}%end item
\divideents{killGUI}
\item{\vskip -1.9ex 
\index{killGUI()}
\hypertarget{jmarkov.MarkovProcess.killGUI()}{\membername{killGUI}}
{\tt public void\ {\bf killGUI}(  )
\label{jmarkov.MarkovProcess.killGUI()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Destroys the Graphic User Interface (GUI) that represent this Markov Chain if one is defined.
}
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.MarkovProcess.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.MarkovProcess.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the name of the model.
}
\item{{\bf Returns} -- 
The Name of this model. 
}%end item
\end{itemize}
}%end item
\divideents{loadGUI}
\item{\vskip -1.9ex 
\index{loadGUI()}
\hypertarget{jmarkov.MarkovProcess.loadGUI()}{\membername{loadGUI}}
{\tt public void\ {\bf loadGUI}(  )
\label{jmarkov.MarkovProcess.loadGUI()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Loads the Graphic User Interface (GUI) that represent this Markov Chain.
}
\end{itemize}
}%end item
\divideents{MOPsToString}
\item{\vskip -1.9ex 
\index{MOPsToString()}
\hypertarget{jmarkov.MarkovProcess.MOPsToString()}{\membername{MOPsToString}}
{\tt public java.lang.String\ {\bf MOPsToString}(  )
\label{jmarkov.MarkovProcess.MOPsToString()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return a String description of all MOPs in steady state (it reports mean and standard deviation).
}
\item{{\bf Returns} -- 
A String description of all MOPs. 
}%end item
\end{itemize}
}%end item
\divideents{MOPsToString}
\item{\vskip -1.9ex 
\index{MOPsToString(int, int)}
\hypertarget{jmarkov.MarkovProcess.MOPsToString(int, int)}{\membername{MOPsToString}}
{\tt public java.lang.String\ {\bf MOPsToString}( {\tt int} {\bf width},
{\tt int} {\bf decimals} )
\label{jmarkov.MarkovProcess.MOPsToString(int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return a String description of all MOPs in steady state (it reports mean and standard deviation).
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt width} -- the columns width}
   \item{
\sld
{\tt decimals} -- the number of decimals to use.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
String with a table representing MOPs names, means and standard deviations. 
}%end item
\end{itemize}
}%end item
\divideents{numMOPs}
\item{\vskip -1.9ex 
\index{numMOPs()}
\hypertarget{jmarkov.MarkovProcess.numMOPs()}{\membername{numMOPs}}
{\tt public int\ {\bf numMOPs}(  )
\label{jmarkov.MarkovProcess.numMOPs()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of defined Measures of performance (MOPs).
}
\item{{\bf Returns} -- 
the number of MOPs defined so far. 
}%end item
\end{itemize}
}%end item
\divideents{pad}
\item{\vskip -1.9ex 
\index{pad(double, int)}
\hypertarget{jmarkov.MarkovProcess.pad(double, int)}{\membername{pad}}
{\tt protected java.lang.String\ {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w} )
\label{jmarkov.MarkovProcess.pad(double, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

pad generates a string representing the double v, padded with spaces up to width w. *
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt v} -- The double to print.}
   \item{
\sld
{\tt w} -- The width to pad up to.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pad}
\item{\vskip -1.9ex 
\index{pad(double, int, boolean)}
\hypertarget{jmarkov.MarkovProcess.pad(double, int, boolean)}{\membername{pad}}
{\tt protected java.lang.String\ {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w},
{\tt boolean} {\bf right} )
\label{jmarkov.MarkovProcess.pad(double, int, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

pad generates a string representing the double v, padded with spaces up to width w.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt v} -- The double to print to print.}
   \item{
\sld
{\tt w} -- The width to pad up to.}
   \item{
\sld
{\tt right} -- whether the string should be eligned to the right.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pad}
\item{\vskip -1.9ex 
\index{pad(double, int, int)}
\hypertarget{jmarkov.MarkovProcess.pad(double, int, int)}{\membername{pad}}
{\tt protected java.lang.String\ {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w},
{\tt int} {\bf d} )
\label{jmarkov.MarkovProcess.pad(double, int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

pad fills with blanks up to width w. Alignment is to the right.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt v} -- The number to print.}
   \item{
\sld
{\tt w} -- The width to pad up to.}
   \item{
\sld
{\tt d} -- number of decimals.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pad}
\item{\vskip -1.9ex 
\index{pad(double, int, int, boolean)}
\hypertarget{jmarkov.MarkovProcess.pad(double, int, int, boolean)}{\membername{pad}}
{\tt protected java.lang.String\ {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w},
{\tt int} {\bf d},
{\tt boolean} {\bf right} )
\label{jmarkov.MarkovProcess.pad(double, int, int, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

pad fills with blanks up to width w
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt v} -- The number to print.}
   \item{
\sld
{\tt w} -- The width to pad up to.}
   \item{
\sld
{\tt d} -- number of decimals.}
   \item{
\sld
{\tt right} -- whether the string should be eligned to the right.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pad}
\item{\vskip -1.9ex 
\index{pad(String, int)}
\hypertarget{jmarkov.MarkovProcess.pad(java.lang.String, int)}{\membername{pad}}
{\tt protected java.lang.String\ {\bf pad}( {\tt java.lang.String} {\bf s},
{\tt int} {\bf w} )
\label{jmarkov.MarkovProcess.pad(java.lang.String, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

pad fills with blanks up to width w
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- The String to print.}
   \item{
\sld
{\tt w} -- The width to pad up to.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pad}
\item{\vskip -1.9ex 
\index{pad(String, int, boolean)}
\hypertarget{jmarkov.MarkovProcess.pad(java.lang.String, int, boolean)}{\membername{pad}}
{\tt protected java.lang.String\ {\bf pad}( {\tt java.lang.String} {\bf s},
{\tt int} {\bf w},
{\tt boolean} {\bf right} )
\label{jmarkov.MarkovProcess.pad(java.lang.String, int, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

pad fills with blanks up to width w
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- The String to print.}
   \item{
\sld
{\tt w} -- The width to pad up to.}
   \item{
\sld
{\tt right} -- whether the string should be eligned to the right.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pause}
\item{\vskip -1.9ex 
\index{pause()}
\hypertarget{jmarkov.MarkovProcess.pause()}{\membername{pause}}
{\tt public void\ {\bf pause}(  )
\label{jmarkov.MarkovProcess.pause()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Pauses the current execution of the model. This is called by the GUI.
}
\end{itemize}
}%end item
\divideents{printAll}
\item{\vskip -1.9ex 
\index{printAll()}
\hypertarget{jmarkov.MarkovProcess.printAll()}{\membername{printAll}}
{\tt public void\ {\bf printAll}(  )
\label{jmarkov.MarkovProcess.printAll()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a description of the Model: the States and the Transition Matrix. If the model has less than 100 states it shows all states and transition matrix and steady state probabilities. Otherwise only the description, measures of performance and events rates are shown.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.allToString()}{MarkovProcess.allToString()}} {\small 
\refdefined{jmarkov.MarkovProcess.allToString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printAll}
\item{\vskip -1.9ex 
\index{printAll(PrintWriter)}
\hypertarget{jmarkov.MarkovProcess.printAll(java.io.PrintWriter)}{\membername{printAll}}
{\tt public void\ {\bf printAll}( {\tt java.io.PrintWriter} {\bf out} )
\label{jmarkov.MarkovProcess.printAll(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints to the given PrintWriter a summary of the information related to this MarkovChain. The information is the same as as in the method {\tt\small printAll()}.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt out} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.toString()}{MarkovProcess.toString()}} {\small 
\refdefined{jmarkov.MarkovProcess.toString()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.printAll()}{MarkovProcess.printAll()}} {\small 
\refdefined{jmarkov.MarkovProcess.printAll()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printDenseMatrix}
\item{\vskip -1.9ex 
\index{printDenseMatrix(PrintWriter)}
\hypertarget{jmarkov.MarkovProcess.printDenseMatrix(java.io.PrintWriter)}{\membername{printDenseMatrix}}
{\tt public void\ {\bf printDenseMatrix}( {\tt java.io.PrintWriter} {\bf out} )
\label{jmarkov.MarkovProcess.printDenseMatrix(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a the Transition Matrix. It will use default values for width and decimals. Its use is not recommended for large models.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt out} -- The writer to write to.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printDenseMatrix}
\item{\vskip -1.9ex 
\index{printDenseMatrix(PrintWriter, int, int, boolean, boolean)}
\hypertarget{jmarkov.MarkovProcess.printDenseMatrix(java.io.PrintWriter, int, int, boolean, boolean)}{\membername{printDenseMatrix}}
{\tt public void\ {\bf printDenseMatrix}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf rateDecimals},
{\tt boolean} {\bf printZeros},
{\tt boolean} {\bf useGenerator} )
\label{jmarkov.MarkovProcess.printDenseMatrix(java.io.PrintWriter, int, int, boolean, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a description of the Model using the given PrintWriter: the States and the Transition Matrix. Its use is not recommended for large models.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt out} -- The writer to write to.}
   \item{
\sld
{\tt width} -- The width of each column.}
   \item{
\sld
{\tt rateDecimals} -- The number of decimals for the rates.}
   \item{
\sld
{\tt printZeros} -- Whether zeros or blanks should be printed.}
   \item{
\sld
{\tt useGenerator} -- whether the generator matrix {\bf Q}, rather than the rates matrix should be printed.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printDenseMatrix}
\item{\vskip -1.9ex 
\index{printDenseMatrix(PrintWriter, int, int, boolean, boolean, int\lbrack \rbrack )}
\hypertarget{jmarkov.MarkovProcess.printDenseMatrix(java.io.PrintWriter, int, int, boolean, boolean, int[])}{\membername{printDenseMatrix}}
{\tt protected void\ {\bf printDenseMatrix}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf rateDecimals},
{\tt boolean} {\bf printZeros},
{\tt boolean} {\bf useGenerator},
{\tt int\lbrack \rbrack } {\bf idx} )
\label{jmarkov.MarkovProcess.printDenseMatrix(java.io.PrintWriter, int, int, boolean, boolean, int[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a description of the Model using the given PrintWriter: the States and the Transition Matrix. Its use is not recommended for large models.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt width} -- The width of each column.}
   \item{
\sld
{\tt rateDecimals} -- The number of decimals for the rates.}
   \item{
\sld
{\tt printZeros} -- Whether zeros or blanks should be printed.}
   \item{
\sld
{\tt useGenerator} -- whether the generator matrix {\bf Q}, rather than the rates matrix should be printed.}
   \item{
\sld
{\tt idx} -- the indices of separators.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printEventsRates}
\item{\vskip -1.9ex 
\index{printEventsRates(PrintWriter)}
\hypertarget{jmarkov.MarkovProcess.printEventsRates(java.io.PrintWriter)}{\membername{printEventsRates}}
{\tt public void\ {\bf printEventsRates}( {\tt java.io.PrintWriter} {\bf out} )
\label{jmarkov.MarkovProcess.printEventsRates(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a table reporting the steadystate occurrance of all events.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt out} -- where the table will be printed.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printEventsRates}
\item{\vskip -1.9ex 
\index{printEventsRates(PrintWriter, int, int)}
\hypertarget{jmarkov.MarkovProcess.printEventsRates(java.io.PrintWriter, int, int)}{\membername{printEventsRates}}
{\tt public void\ {\bf printEventsRates}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf decimals} )
\label{jmarkov.MarkovProcess.printEventsRates(java.io.PrintWriter, int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a table reporting the steadystate occurrance of all events.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt out} -- where the table will be printed.}
   \item{
\sld
{\tt width} -- The column width}
   \item{
\sld
{\tt decimals} -- The number of decimals to use.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printMOPs}
\item{\vskip -1.9ex 
\index{printMOPs()}
\hypertarget{jmarkov.MarkovProcess.printMOPs()}{\membername{printMOPs}}
{\tt public final void\ {\bf printMOPs}(  )
\label{jmarkov.MarkovProcess.printMOPs()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the Measures of performance (MOPS) on standard output.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter)}{MarkovProcess.printMOPs(PrintWriter)}} {\small 
\refdefined{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter)}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter, int, int)}{MarkovProcess.printMOPs(PrintWriter,\allowbreak int,\allowbreak int)}} {\small 
\refdefined{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter, int, int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printMOPs}
\item{\vskip -1.9ex 
\index{printMOPs(PrintWriter)}
\hypertarget{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter)}{\membername{printMOPs}}
{\tt public final void\ {\bf printMOPs}( {\tt java.io.PrintWriter} {\bf out} )
\label{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a String description of all MOPs in steady state (it reports mean and standard deviation), with a width of 10 and 5 decimal figures.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt out} -- The printer where the MOPS will be printed.}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.printMOPs()}{MarkovProcess.printMOPs()}} {\small 
\refdefined{jmarkov.MarkovProcess.printMOPs()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter, int, int)}{MarkovProcess.printMOPs(PrintWriter,\allowbreak int,\allowbreak int)}} {\small 
\refdefined{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter, int, int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printMOPs}
\item{\vskip -1.9ex 
\index{printMOPs(PrintWriter, int, int)}
\hypertarget{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter, int, int)}{\membername{printMOPs}}
{\tt public int\ {\bf printMOPs}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf decimals} )
\label{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter, int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a String description of all MOPs in steady state (it reports mean and standard deviation). You can override this method to print your own MOPs. You can call it in the first line like this {\tt\small public void printMOPs(PrintWriter out, int width, int decimals) \{\ int namesWidth = super.printMOPs(out,width, decimals); // your oun code here: out.println(pad("Another MOP", namesWidth, false) + pad(Value, width, decimals); \}\ }
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt out} -- The printer where the MOPS will be printed.}
   \item{
\sld
{\tt width} -- the columns width}
   \item{
\sld
{\tt decimals} -- the number of decimals to use.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The max width among the declared MOPs. You can use this to align nicely your own MOPs. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter)}{MarkovProcess.printMOPs(PrintWriter)}} {\small 
\refdefined{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter)}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter, int, int)}{MarkovProcess.printMOPs(PrintWriter,\allowbreak int,\allowbreak int)}} {\small 
\refdefined{jmarkov.MarkovProcess.printMOPs(java.io.PrintWriter, int, int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printStates}
\item{\vskip -1.9ex 
\index{printStates(PrintWriter)}
\hypertarget{jmarkov.MarkovProcess.printStates(java.io.PrintWriter)}{\membername{printStates}}
{\tt public void\ {\bf printStates}( {\tt java.io.PrintWriter} {\bf out} )
\label{jmarkov.MarkovProcess.printStates(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a description of the States and the Equilibrium Probabilities.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt out} -- The writer to write to.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printStates}
\item{\vskip -1.9ex 
\index{printStates(PrintWriter, int, int)}
\hypertarget{jmarkov.MarkovProcess.printStates(java.io.PrintWriter, int, int)}{\membername{printStates}}
{\tt public void\ {\bf printStates}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf probDecimals} )
\label{jmarkov.MarkovProcess.printStates(java.io.PrintWriter, int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a description of the States and the Equilibrium Probabilities.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt out} -- The writer to write to.}
   \item{
\sld
{\tt width} -- The width of each column.}
   \item{
\sld
{\tt probDecimals} -- The number of decimals for the probabilities.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{reset}
\item{\vskip -1.9ex 
\index{reset()}
\hypertarget{jmarkov.MarkovProcess.reset()}{\membername{reset}}
{\tt public synchronized void\ {\bf reset}(  )
\label{jmarkov.MarkovProcess.reset()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Resets the Model. It erases all found states and transition rates. Keeps the initial state and Events set.
}
\end{itemize}
}%end item
\divideents{reset}
\item{\vskip -1.9ex 
\index{reset(boolean)}
\hypertarget{jmarkov.MarkovProcess.reset(boolean)}{\membername{reset}}
{\tt protected synchronized void\ {\bf reset}( {\tt boolean} {\bf resetEvents} )
\label{jmarkov.MarkovProcess.reset(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Resets the Model. It erases all found states and transition rates.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt resetEvents} -- whether the Events are deleted. WARNNING! if this is true you must call setEventSet.}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.setInitialState(S)}{MarkovProcess.setInitialState(State)}} {\small 
\refdefined{jmarkov.MarkovProcess.setInitialState(S)}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.setEventSet(jmarkov.basic.EventsSet)}{MarkovProcess.setEventSet(basic.EventsSet)}} {\small 
\refdefined{jmarkov.MarkovProcess.setEventSet(jmarkov.basic.EventsSet)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{resetResults}
\item{\vskip -1.9ex 
\index{resetResults()}
\hypertarget{jmarkov.MarkovProcess.resetResults()}{\membername{resetResults}}
{\tt public synchronized void\ {\bf resetResults}(  )
\label{jmarkov.MarkovProcess.resetResults()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Resets the result of the model. If it has been generated this method keeps the Graph, but erases steady state, and transient probabilities.
}
\end{itemize}
}%end item
\divideents{setDebugLevel}
\item{\vskip -1.9ex 
\index{setDebugLevel(int)}
\hypertarget{jmarkov.MarkovProcess.setDebugLevel(int)}{\membername{setDebugLevel}}
{\tt public void\ {\bf setDebugLevel}( {\tt int} {\bf level} )
\label{jmarkov.MarkovProcess.setDebugLevel(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the debug level, where level=0 means no debug info, level = 5 verbose info.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- New debug level}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setDebugReporter}
\item{\vskip -1.9ex 
\index{setDebugReporter(DebugReporter)}
\hypertarget{jmarkov.MarkovProcess.setDebugReporter(jmarkov.DebugReporter)}{\membername{setDebugReporter}}
{\tt public void\ {\bf setDebugReporter}( {\tt DebugReporter} {\bf reporter} )
\label{jmarkov.MarkovProcess.setDebugReporter(jmarkov.DebugReporter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the DebugReporter to use.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt reporter} -- The reporter tah will capture the debug information.}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.DebugReporter}{DebugReporter}} {\small 
\refdefined{jmarkov.DebugReporter}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setEventSet}
\item{\vskip -1.9ex 
\index{setEventSet(EventsSet)}
\hypertarget{jmarkov.MarkovProcess.setEventSet(jmarkov.basic.EventsSet)}{\membername{setEventSet}}
{\tt protected void\ {\bf setEventSet}( {\tt basic.EventsSet} {\bf eSet} )
\label{jmarkov.MarkovProcess.setEventSet(jmarkov.basic.EventsSet)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the Events set. It causes the model to be reset. This method should be called only in a constructor.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt eSet} -- the Events set.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setInitialState}
\item{\vskip -1.9ex 
\index{setInitialState(S)}
\hypertarget{jmarkov.MarkovProcess.setInitialState(S)}{\membername{setInitialState}}
{\tt protected void\ {\bf setInitialState}( {\tt basic.State} {\bf i0} )
\label{jmarkov.MarkovProcess.setInitialState(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the initial state. It casues the model to be reset. This method should be called only in a constructor.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i0} -- The initial state.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setMaxStates}
\item{\vskip -1.9ex 
\index{setMaxStates(long)}
\hypertarget{jmarkov.MarkovProcess.setMaxStates(long)}{\membername{setMaxStates}}
{\tt public void\ {\bf setMaxStates}( {\tt long} {\bf num} )
\label{jmarkov.MarkovProcess.setMaxStates(long)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the maximum number of states to generate. Increase this only if you are sure that your model has a big number od states. Your current License may prevent you from setting this number.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt num} -- Maximum Number of States to generate.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setMOPs}
\item{\vskip -1.9ex 
\index{setMOPs(String\lbrack \rbrack )}
\hypertarget{jmarkov.MarkovProcess.setMOPs(java.lang.String[])}{\membername{setMOPs}}
{\tt public void\ {\bf setMOPs}( {\tt java.lang.String\lbrack \rbrack } {\bf mopNames} )
\label{jmarkov.MarkovProcess.setMOPs(java.lang.String[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the names of all MOPs (measures of performance).
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mopNames} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setSteadyStateSolver}
\item{\vskip -1.9ex 
\index{setSteadyStateSolver(SteadyStateSolver)}
\hypertarget{jmarkov.MarkovProcess.setSteadyStateSolver(jmarkov.solvers.SteadyStateSolver)}{\membername{setSteadyStateSolver}}
{\tt public void\ {\bf setSteadyStateSolver}( {\tt solvers.SteadyStateSolver} {\bf steadyStateSolver} )
\label{jmarkov.MarkovProcess.setSteadyStateSolver(jmarkov.solvers.SteadyStateSolver)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Allows the user to set an alternate solver.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt steadyStateSolver} -- The steadyStateSolver to set.}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.SteadyStateSolver}{solvers.SteadyStateSolver}} {\small 
\refdefined{jmarkov.solvers.SteadyStateSolver}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setTransientSolver}
\item{\vskip -1.9ex 
\index{setTransientSolver(TransientSolver)}
\hypertarget{jmarkov.MarkovProcess.setTransientSolver(jmarkov.solvers.TransientSolver)}{\membername{setTransientSolver}}
{\tt public void\ {\bf setTransientSolver}( {\tt solvers.TransientSolver} {\bf transientSolver} )
\label{jmarkov.MarkovProcess.setTransientSolver(jmarkov.solvers.TransientSolver)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Allows the user to set an alternate solver.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt transientSolver} -- The transientSolver to set.}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.TransientSolver}{solvers.TransientSolver}} {\small 
\refdefined{jmarkov.solvers.TransientSolver}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{showGUI}
\item{\vskip -1.9ex 
\index{showGUI()}
\hypertarget{jmarkov.MarkovProcess.showGUI()}{\membername{showGUI}}
{\tt public void\ {\bf showGUI}(  )
\label{jmarkov.MarkovProcess.showGUI()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Shows the Graphic User Interface (GUI) that represent this Markov Chain. It loads one if none has been defined.
}
\end{itemize}
}%end item
\divideents{statesLableMaxWidth}
\item{\vskip -1.9ex 
\index{statesLableMaxWidth(int)}
\hypertarget{jmarkov.MarkovProcess.statesLableMaxWidth(int)}{\membername{statesLableMaxWidth}}
{\tt public int\ {\bf statesLableMaxWidth}( {\tt int} {\bf width} )
\label{jmarkov.MarkovProcess.statesLableMaxWidth(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the maximum used by the state's labels.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt width} -- minimum width acceptable.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Max(width, max label). 
}%end item
\end{itemize}
}%end item
\divideents{statesToString}
\item{\vskip -1.9ex 
\index{statesToString()}
\hypertarget{jmarkov.MarkovProcess.statesToString()}{\membername{statesToString}}
{\tt public java.lang.String\ {\bf statesToString}(  )
\label{jmarkov.MarkovProcess.statesToString()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a description of the States and the Equilibrium Probabilities.
}
\item{{\bf Returns} -- 
A String description of the States. 
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.MarkovProcess.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jmarkov.MarkovProcess.toString()}}%end signature
}%end item
\divideents{vLine}
\item{\vskip -1.9ex 
\index{vLine()}
\hypertarget{jmarkov.MarkovProcess.vLine()}{\membername{vLine}}
{\tt protected java.lang.String\ {\bf vLine}(  )
\label{jmarkov.MarkovProcess.vLine()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a text vertical line.
}
\item{{\bf Returns} -- 
vertical line. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{MarkovProcess.Status}
\subsection{\label{jmarkov.MarkovProcess.Status}\index{MarkovProcess.Status}{\bf {\it Class} MarkovProcess.Status}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.MarkovProcess.Status}{}\vskip .1in 
Status variables\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public static final class MarkovProcess.Status
\\ {\bf extends} java.lang.Enum
\refdefined{java.lang.Enum}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.MarkovProcess.Status.ERROR}{{\bf ERROR}} Model execution generated an error\\
\hyperlink{jmarkov.MarkovProcess.Status.GENERATED}{{\bf GENERATED}} Model has been generated\\
\hyperlink{jmarkov.MarkovProcess.Status.IDLE}{{\bf IDLE}} Model has not been generated\\
\hyperlink{jmarkov.MarkovProcess.Status.NoModel}{{\bf NoModel}} No Model loaded.\\
\hyperlink{jmarkov.MarkovProcess.Status.RUNNING}{{\bf RUNNING}} Model is being generated\\
\hyperlink{jmarkov.MarkovProcess.Status.SUSPENDED}{{\bf SUSPENDED}} Model execution has been suspended\\
\hyperlink{jmarkov.MarkovProcess.Status.WRITING}{{\bf WRITING}} Model generated, writing matrix\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.MarkovProcess.Status.valueOf(java.lang.String)}{{\bf valueOf(String)}} \\
\hyperlink{jmarkov.MarkovProcess.Status.values()}{{\bf values()}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{IDLE}
\label{jmarkov.MarkovProcess.Status.IDLE}\hypertarget{jmarkov.MarkovProcess.Status.IDLE}{public static final MarkovProcess.Status {\bf IDLE}}
\begin{itemize}
\item{\vskip -.9ex 
Model has not been generated}
\end{itemize}
}
\item{
\index{RUNNING}
\label{jmarkov.MarkovProcess.Status.RUNNING}\hypertarget{jmarkov.MarkovProcess.Status.RUNNING}{public static final MarkovProcess.Status {\bf RUNNING}}
\begin{itemize}
\item{\vskip -.9ex 
Model is being generated}
\end{itemize}
}
\item{
\index{GENERATED}
\label{jmarkov.MarkovProcess.Status.GENERATED}\hypertarget{jmarkov.MarkovProcess.Status.GENERATED}{public static final MarkovProcess.Status {\bf GENERATED}}
\begin{itemize}
\item{\vskip -.9ex 
Model has been generated}
\end{itemize}
}
\item{
\index{SUSPENDED}
\label{jmarkov.MarkovProcess.Status.SUSPENDED}\hypertarget{jmarkov.MarkovProcess.Status.SUSPENDED}{public static final MarkovProcess.Status {\bf SUSPENDED}}
\begin{itemize}
\item{\vskip -.9ex 
Model execution has been suspended}
\end{itemize}
}
\item{
\index{WRITING}
\label{jmarkov.MarkovProcess.Status.WRITING}\hypertarget{jmarkov.MarkovProcess.Status.WRITING}{public static final MarkovProcess.Status {\bf WRITING}}
\begin{itemize}
\item{\vskip -.9ex 
Model generated, writing matrix}
\end{itemize}
}
\item{
\index{ERROR}
\label{jmarkov.MarkovProcess.Status.ERROR}\hypertarget{jmarkov.MarkovProcess.Status.ERROR}{public static final MarkovProcess.Status {\bf ERROR}}
\begin{itemize}
\item{\vskip -.9ex 
Model execution generated an error}
\end{itemize}
}
\item{
\index{NoModel}
\label{jmarkov.MarkovProcess.Status.NoModel}\hypertarget{jmarkov.MarkovProcess.Status.NoModel}{public static final MarkovProcess.Status {\bf NoModel}}
\begin{itemize}
\item{\vskip -.9ex 
No Model loaded. (used by GUI)}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{valueOf(String)}
\hypertarget{jmarkov.MarkovProcess.Status.valueOf(java.lang.String)}{\membername{valueOf}}
{\tt public static MarkovProcess.Status\ {\bf valueOf}( {\tt java.lang.String} {\bf name} )
\label{jmarkov.MarkovProcess.Status.valueOf(java.lang.String)}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\index{values()}
\hypertarget{jmarkov.MarkovProcess.Status.values()}{\membername{values}}
{\tt public static final MarkovProcess.Status\lbrack \rbrack \ {\bf values}(  )
\label{jmarkov.MarkovProcess.Status.values()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt java.lang.Enum} \textnormal{\small\refdefined{java.lang.Enum}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected final Object {\bf clone}(  ) throws CloneNotSupportedException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf compareTo}( {\tt Enum} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf equals}( {\tt Object} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public static Enum {\bf valueOf}( {\tt Class} {\bf arg0},
{\tt String} {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{SimpleMarkovProcess}
\subsection{\label{jmarkov.SimpleMarkovProcess}\index{SimpleMarkovProcess}{\bf {\it Class} SimpleMarkovProcess}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.SimpleMarkovProcess}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class SimpleMarkovProcess
\\ {\bf extends} jmarkov.MarkovProcess
\refdefined{jmarkov.MarkovProcess}}}}
\subsubsection{All known subclasses}{GeomProcess\small{\refdefined{jmarkov.GeomProcess}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.SimpleMarkovProcess()}{{\bf SimpleMarkovProcess()}} \\
\hyperlink{jmarkov.SimpleMarkovProcess(S, jmarkov.basic.EventsSet)}{{\bf SimpleMarkovProcess(S, EventsSet)}} \\
\hyperlink{jmarkov.SimpleMarkovProcess(S, jmarkov.basic.EventsSet, java.lang.String)}{{\bf SimpleMarkovProcess(S, EventsSet, String)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.SimpleMarkovProcess.active(S, E)}{{\bf active(S, E)}} Determines if event e is active when the system is in state i.\\
\hyperlink{jmarkov.SimpleMarkovProcess.activeTransitions(S, E)}{{\bf activeTransitions(S, E)}} This method calls active, dests and rate to create the set of transitions.\\
\hyperlink{jmarkov.SimpleMarkovProcess.dests(S, E)}{{\bf dests(S, E)}} Determines the destination set of States when events e occurs.\\
\hyperlink{jmarkov.SimpleMarkovProcess.rate(S, S, E)}{{\bf rate(S, S, E)}} Returns the rate to go from State i to j when Event e occurs.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{SimpleMarkovProcess()}
\hypertarget{jmarkov.SimpleMarkovProcess()}{\membername{SimpleMarkovProcess}}
{\tt public\ {\bf SimpleMarkovProcess}(  )
\label{jmarkov.SimpleMarkovProcess()}}%end signature
}%end item
\divideents{SimpleMarkovProcess}
\item{\vskip -1.9ex 
\index{SimpleMarkovProcess(S, EventsSet)}
\hypertarget{jmarkov.SimpleMarkovProcess(S, jmarkov.basic.EventsSet)}{\membername{SimpleMarkovProcess}}
{\tt public\ {\bf SimpleMarkovProcess}( {\tt basic.State} {\bf i0},
{\tt basic.EventsSet} {\bf eSet} )
\label{jmarkov.SimpleMarkovProcess(S, jmarkov.basic.EventsSet)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i0} -- }
   \item{
\sld
{\tt eSet} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{SimpleMarkovProcess}
\item{\vskip -1.9ex 
\index{SimpleMarkovProcess(S, EventsSet, String)}
\hypertarget{jmarkov.SimpleMarkovProcess(S, jmarkov.basic.EventsSet, java.lang.String)}{\membername{SimpleMarkovProcess}}
{\tt public\ {\bf SimpleMarkovProcess}( {\tt basic.State} {\bf i0},
{\tt basic.EventsSet} {\bf eSet},
{\tt java.lang.String} {\bf name} )
\label{jmarkov.SimpleMarkovProcess(S, jmarkov.basic.EventsSet, java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i0} -- }
   \item{
\sld
{\tt eSet} -- }
   \item{
\sld
{\tt name} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{active(S, E)}
\hypertarget{jmarkov.SimpleMarkovProcess.active(S, E)}{\membername{active}}
{\tt public abstract boolean\ {\bf active}( {\tt basic.State} {\bf i},
{\tt basic.Event} {\bf e} )
\label{jmarkov.SimpleMarkovProcess.active(S, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Determines if event e is active when the system is in state i. It has to be implemented by a subclass.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- The current State}
   \item{
\sld
{\tt e} -- The current Event.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
True if the Event is Active. 
}%end item
\end{itemize}
}%end item
\divideents{activeTransitions}
\item{\vskip -1.9ex 
\index{activeTransitions(S, E)}
\hypertarget{jmarkov.SimpleMarkovProcess.activeTransitions(S, E)}{\membername{activeTransitions}}
{\tt public final basic.Transitions\ {\bf activeTransitions}( {\tt basic.State} {\bf i},
{\tt basic.Event} {\bf e} )
\label{jmarkov.SimpleMarkovProcess.activeTransitions(S, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method calls active, dests and rate to create the set of transitions. The user cannot override this method and would rarely call it.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.activeTransitions(S, E)}{MarkovProcess.activeTransitions(State,\allowbreak Event)}} {\small 
\refdefined{jmarkov.MarkovProcess.activeTransitions(S, E)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{dests}
\item{\vskip -1.9ex 
\index{dests(S, E)}
\hypertarget{jmarkov.SimpleMarkovProcess.dests(S, E)}{\membername{dests}}
{\tt public abstract basic.States\ {\bf dests}( {\tt basic.State} {\bf i},
{\tt basic.Event} {\bf e} )
\label{jmarkov.SimpleMarkovProcess.dests(S, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Determines the destination set of States when events e occurs. It has to be implemented by the subclass.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current State.}
   \item{
\sld
{\tt e} -- The Event that ocurred.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The destination States 
}%end item
\end{itemize}
}%end item
\divideents{rate}
\item{\vskip -1.9ex 
\index{rate(S, S, E)}
\hypertarget{jmarkov.SimpleMarkovProcess.rate(S, S, E)}{\membername{rate}}
{\tt public abstract double\ {\bf rate}( {\tt basic.State} {\bf i},
{\tt basic.State} {\bf j},
{\tt basic.Event} {\bf e} )
\label{jmarkov.SimpleMarkovProcess.rate(S, S, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the rate to go from State i to j when Event e occurs. This is called only if Event {\tt\small e} is indeed active and j is a valid destination.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current state}
   \item{
\sld
{\tt j} -- Destination State}
   \item{
\sld
{\tt e} -- The occuring event}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The rate at which the system goes from i to j when e occurs. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.SimpleMarkovProcess.dests(S, E)}{SimpleMarkovProcess.dests(State,\allowbreak Event)}} {\small 
\refdefined{jmarkov.SimpleMarkovProcess.dests(S, E)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.MarkovProcess} \textnormal{\small\refdefined{jmarkov.MarkovProcess}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract Transitions {\bf activeTransitions}( {\tt basic.State} {\bf i},
{\tt basic.Event} {\bf e} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public boolean {\bf addMOP}( {\tt java.lang.String} {\bf mopName} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf allToString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public boolean {\bf canGo}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf clearMOPs}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf cnt}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf defaultSteadyStateSolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf defaultTransientSolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf denseMatrixToString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf denseMatrixToString}( {\tt int} {\bf width},
{\tt int} {\bf rateDecimals},
{\tt boolean} {\bf printZeros},
{\tt boolean} {\bf useGenerator} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf eventRatesToString}( {\tt int} {\bf width},
{\tt int} {\bf decimals} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf eventsRatesToString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf finalize}(  ) throws java.lang.Throwable
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getDebugReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final SteadyStateSolver {\bf getDefaultSteadyStateSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected TransientSolver {\bf getDefaultTransientSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Class {\bf getEventClass}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getEventNames}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getEventRate}( {\tt int} {\bf eNum} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Event {\bf getEvents}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getEventsRates}(  ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized double {\bf getFinalRate}( {\tt basic.State} {\bf i},
{\tt basic.State} {\bf j} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getGenerator}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected State {\bf getInitialState}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public long {\bf getMaxStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getMOPIndex}( {\tt java.lang.String} {\bf name} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getMOPNames}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getMOPNames}( {\tt int} {\bf mopNum} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsAvg}(  ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsAvg}( {\tt int} {\bf mopNum} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsAvg}( {\tt java.lang.String} {\bf mopName} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsMoment}( {\tt int} {\bf m} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsMoment}( {\tt int} {\bf mopNum},
{\tt int} {\bf m} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOPsMoment}( {\tt java.lang.String} {\bf mopName},
{\tt int} {\bf m} ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf getMtjGenerator}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized Matrix {\bf getMtjRates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getNumStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public long {\bf getProgress}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized double {\bf getRate}( {\tt basic.State} {\bf i},
{\tt basic.State} {\bf j} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized double {\bf getRates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized Transitions {\bf getRates}( {\tt basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Class {\bf getStateClass}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getStates}( {\tt boolean} {\bf causesGeneration} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MarkovProcess.Status {\bf getStatus}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getStatusMsg}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getSteadyState}(  ) throws basic.exceptions.NotUnichainException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public SteadyStateSolver {\bf getSteadyStateSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public TransientSolver {\bf getTransientSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized void {\bf go}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized void {\bf goStep}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf hideGUI}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf hLine}( {\tt int} {\bf length} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public boolean {\bf isGenerated}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf killGUI}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf loadGUI}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf MOPsToString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf MOPsToString}( {\tt int} {\bf width},
{\tt int} {\bf decimals} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf name}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf numMOPs}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w},
{\tt boolean} {\bf right} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w},
{\tt int} {\bf d} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt double} {\bf v},
{\tt int} {\bf w},
{\tt int} {\bf d},
{\tt boolean} {\bf right} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt java.lang.String} {\bf s},
{\tt int} {\bf w} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf pad}( {\tt java.lang.String} {\bf s},
{\tt int} {\bf w},
{\tt boolean} {\bf right} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf pause}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printAll}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printAll}( {\tt java.io.PrintWriter} {\bf out} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printDenseMatrix}( {\tt java.io.PrintWriter} {\bf out} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printDenseMatrix}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf rateDecimals},
{\tt boolean} {\bf printZeros},
{\tt boolean} {\bf useGenerator} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf printDenseMatrix}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf rateDecimals},
{\tt boolean} {\bf printZeros},
{\tt boolean} {\bf useGenerator},
{\tt int\lbrack \rbrack } {\bf idx} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printEventsRates}( {\tt java.io.PrintWriter} {\bf out} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printEventsRates}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf decimals} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf printMOPs}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf printMOPs}( {\tt java.io.PrintWriter} {\bf out} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf printMOPs}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf decimals} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStates}( {\tt java.io.PrintWriter} {\bf out} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStates}( {\tt java.io.PrintWriter} {\bf out},
{\tt int} {\bf width},
{\tt int} {\bf probDecimals} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized void {\bf reset}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected synchronized void {\bf reset}( {\tt boolean} {\bf resetEvents} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized void {\bf resetResults}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugReporter}( {\tt DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setEventSet}( {\tt basic.EventsSet} {\bf eSet} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setInitialState}( {\tt basic.State} {\bf i0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setMaxStates}( {\tt long} {\bf num} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setMOPs}( {\tt java.lang.String\lbrack \rbrack } {\bf mopNames} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSteadyStateSolver}( {\tt solvers.SteadyStateSolver} {\bf steadyStateSolver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setTransientSolver}( {\tt solvers.TransientSolver} {\bf transientSolver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf showGUI}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf statesLableMaxWidth}( {\tt int} {\bf width} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf statesToString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf theStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected String {\bf vLine}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage}
}
\newpage
\def\packagename{jmarkov.basic}
\chapter{\bf Package jmarkov.basic}{
\thispagestyle{empty}
\label{jmarkov.basic}\hypertarget{jmarkov.basic}{}
\markboth{\protect\packagename}{\protect\packagename}
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Interfaces}
\entityintro{Actions}{jmarkov.basic.Actions}{This interface represents a set of objects Action.}
\entityintro{Events}{jmarkov.basic.Events}{This class represents a set of objects Event.}
\entityintro{JMarkovElement}{jmarkov.basic.JMarkovElement}{All the elements in JMarkov implement this interface, so they can be easily described in the interface.}
\entityintro{PropertiesElement}{jmarkov.basic.PropertiesElement}{This interface is a wrapper for elements (States, Actions Events) that can be represented by an arry of integers.}
\entityintro{States}{jmarkov.basic.States}{This interface represents a set of objects State.}
\entityintro{Transitions}{jmarkov.basic.Transitions}{}
\vskip .13in
\hbox{\bf Classes}
\entityintro{Action}{jmarkov.basic.Action}{This class represents a single Action in Markov Decision Process (MDP).}
\entityintro{ActionsSet}{jmarkov.basic.ActionsSet}{This class represents a set of objects Action.}
\entityintro{DecisionRule}{jmarkov.basic.DecisionRule}{This class represents a deterministic decision rule which assigns an action to every state.}
\entityintro{Event}{jmarkov.basic.Event}{The class Event allows the user to define the implementation of the Events that can alter the States of the Markov Chain.}
\entityintro{EventsSet}{jmarkov.basic.EventsSet}{This class represent a set of Events.}
\entityintro{Policy}{jmarkov.basic.Policy}{Policy is a set of "Decision Rules".}
\entityintro{PropertiesAction}{jmarkov.basic.PropertiesAction}{This class is an easy way to use a Action that is represented by an integer valued array.}
\entityintro{PropertiesEvent}{jmarkov.basic.PropertiesEvent}{This class is an easy way to use an event that is represented by an array of int.}
\entityintro{PropertiesState}{jmarkov.basic.PropertiesState}{The states are characterized by an array of integer-valued properties, whose meaning will change from implementation to implementation.}
\entityintro{Solution}{jmarkov.basic.Solution}{This class represents the joint information of a value function and a policy which summarizes the solution to a problem.}
\entityintro{State}{jmarkov.basic.State}{The Class State represent a state in a MarkovProcess or MDP.}
\entityintro{StateC}{jmarkov.basic.StateC}{State to model shortest path problems.}
\entityintro{StateEvent}{jmarkov.basic.StateEvent}{This class represents a state compounded of a state and an event.}
\entityintro{StatesSet}{jmarkov.basic.StatesSet}{This class represent a set of States.}
\entityintro{Transition}{jmarkov.basic.Transition}{This class represent a transition to a given state.}
\entityintro{TransitionsSet}{jmarkov.basic.TransitionsSet}{}
\entityintro{ValueFunction}{jmarkov.basic.ValueFunction}{This structure matches each state with a double number representing its value function, or in some cases the steady state probabilities.}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
This package contains basic elements such as State, Event, Action that are used in jMarkov and jMDP.\mbox{}\\ \rule{\hsize}{.7mm}
\vskip .1in
\newpage
\markboth{\protect\packagename \hspace{.02in} -- \protect\classname}{\protect\packagename \hspace{.02in} -- \protect\classname}
\section{Interfaces}{
\gdef\classname{Actions}
\subsection{\label{jmarkov.basic.Actions}\index{Actions@{\it Actions}}{\bf {\it Interface} Actions}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.Actions}{}\vskip .1in 
This interface represents a set of objects Action. The user must choose his own data structure and define the constuctors. Its recommended to use the Set structure to avoid repeated actions. The ActionsSet class extends this class and explotes the goodnesses of Collections. It is recommended to use that class instead of this one for beginner users.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{java.lang.Iterable}{java.lang.Iterable}} {\small 
\refdefined{java.lang.Iterable}}%end
} 
\item{ {\tt \hyperlink{jmarkov.basic.ActionsSet}{ActionsSet}} {\small 
\refdefined{jmarkov.basic.ActionsSet}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface Actions
\\ {\bf implements} 
java.lang.Iterable}}}
\subsubsection{All known subclasses}{ActionsSet\small{\refdefined{jmarkov.basic.ActionsSet}}}
\subsubsection{All classes known to implement interface}{ActionsSet\small{\refdefined{jmarkov.basic.ActionsSet}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Actions.iterator()}{{\bf iterator()}} This function must be implemented.\\
\hyperlink{jmarkov.basic.Actions.size()}{{\bf size()}} Returns the number of elements.\\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{iterator()}
\hypertarget{jmarkov.basic.Actions.iterator()}{\membername{iterator}}
{\tt  java.util.Iterator\ {\bf iterator}(  )
\label{jmarkov.basic.Actions.iterator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This function must be implemented. Must return an iterator over the Actions.
}
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\index{size()}
\hypertarget{jmarkov.basic.Actions.size()}{\membername{size}}
{\tt  int\ {\bf size}(  )
\label{jmarkov.basic.Actions.size()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of elements.
}
\item{{\bf Returns} -- 
the number of elements. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{Events}
\subsection{\label{jmarkov.basic.Events}\index{Events@{\it Events}}{\bf {\it Interface} Events}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.Events}{}\vskip .1in 
This class represents a set of objects Event. The user must choose his own data structure and define the constuctors. For an easy way to declare and use a set of events see \bslash c\textgreater EventsCollection\bslash c\textgreater , which is an extension of Events.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface Events
\\ {\bf implements} 
java.lang.Iterable}}}
\subsubsection{All known subclasses}{EventsSet\small{\refdefined{jmarkov.basic.EventsSet}}}
\subsubsection{All classes known to implement interface}{EventsSet\small{\refdefined{jmarkov.basic.EventsSet}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Events.add(E)}{{\bf add(E)}} This method adds an object to the set of events.\\
\hyperlink{jmarkov.basic.Events.iterator()}{{\bf iterator()}} This function must be implemented.\\
\hyperlink{jmarkov.basic.Events.size()}{{\bf size()}} Returns the number of elements.\\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{add(E)}
\hypertarget{jmarkov.basic.Events.add(E)}{\membername{add}}
{\tt  boolean\ {\bf add}( {\tt Event} {\bf s} )
\label{jmarkov.basic.Events.add(E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method adds an object to the set of events.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- object to be added.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
True if the set did not contained this element. 
}%end item
\end{itemize}
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\index{iterator()}
\hypertarget{jmarkov.basic.Events.iterator()}{\membername{iterator}}
{\tt  java.util.Iterator\ {\bf iterator}(  )
\label{jmarkov.basic.Events.iterator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This function must be implemented. Must return an iterator over the events.
}
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\index{size()}
\hypertarget{jmarkov.basic.Events.size()}{\membername{size}}
{\tt  int\ {\bf size}(  )
\label{jmarkov.basic.Events.size()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of elements.
}
\item{{\bf Returns} -- 
the number of Event elements. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{JMarkovElement}
\subsection{\label{jmarkov.basic.JMarkovElement}\index{JMarkovElement@{\it JMarkovElement}}{\bf {\it Interface} JMarkovElement}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.JMarkovElement}{}\vskip .1in 
All the elements in JMarkov implement this interface, so they can be easily described in the interface. It is recommended that the method {\tt\small toString()} is implemented as final, and calling {\tt\small label()}.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface JMarkovElement
}}}
\subsubsection{All known subclasses}{SimpleMarkovProcess\small{\refdefined{jmarkov.SimpleMarkovProcess}}, MarkovProcess\small{\refdefined{jmarkov.MarkovProcess}}, GeomState\small{\refdefined{jmarkov.GeomState}}, GeomRelState\small{\refdefined{jmarkov.GeomRelState}}, GeomProcess\small{\refdefined{jmarkov.GeomProcess}}, ValueFunction\small{\refdefined{jmarkov.basic.ValueFunction}}, TransitionsSet\small{\refdefined{jmarkov.basic.TransitionsSet}}, Transitions\small{\refdefined{jmarkov.basic.Transitions}}, Transition\small{\refdefined{jmarkov.basic.Transition}}, StateEvent\small{\refdefined{jmarkov.basic.StateEvent}}, StateC\small{\refdefined{jmarkov.basic.StateC}}, State\small{\refdefined{jmarkov.basic.State}}, PropertiesState\small{\refdefined{jmarkov.basic.PropertiesState}}, PropertiesEvent\small{\refdefined{jmarkov.basic.PropertiesEvent}}, PropertiesElement\small{\refdefined{jmarkov.basic.PropertiesElement}}, PropertiesAction\small{\refdefined{jmarkov.basic.PropertiesAction}}, Event\small{\refdefined{jmarkov.basic.Event}}, DecisionRule\small{\refdefined{jmarkov.basic.DecisionRule}}, Action\small{\refdefined{jmarkov.basic.Action}}, ValueIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.ValueIterationSolver}}, StochasticShortestPathSolver\small{\refdefined{jmarkov.jmdp.solvers.StochasticShortestPathSolver}}, Solver\small{\refdefined{jmarkov.jmdp.solvers.Solver}}, RelativeValueIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.RelativeValueIterationSolver}}, PolicyIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.PolicyIterationSolver}}, MpsLpDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpDiscountedSolver}}, MpsLpAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpAverageSolver}}, LPBCLDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.LPBCLDiscountedSolver}}, LPBCLAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.LPBCLAverageSolver}}, FiniteSolver\small{\refdefined{jmarkov.jmdp.solvers.FiniteSolver}}, AbstractTotalSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractTotalSolver}}, AbstractInfiniteSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}, AbstractFiniteSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractFiniteSolver}}, AbstractDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}}, AbstractAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractAverageSolver}}, TransientSolver\small{\refdefined{jmarkov.solvers.TransientSolver}}, SteadyStateSolver\small{\refdefined{jmarkov.solvers.SteadyStateSolver}}, Solver\small{\refdefined{jmarkov.solvers.Solver}}, MtjSolver\small{\refdefined{jmarkov.solvers.MtjSolver}}, MtjLogRedSolver\small{\refdefined{jmarkov.solvers.MtjLogRedSolver}}, JamaTransientSolver\small{\refdefined{jmarkov.solvers.JamaTransientSolver}}, JamaSolver\small{\refdefined{jmarkov.solvers.JamaSolver}}, GeometrixSolver\small{\refdefined{jmarkov.solvers.GeometrixSolver}}, GeometricSolver\small{\refdefined{jmarkov.solvers.GeometricSolver}}, SparseDiscPhaseVar\small{\refdefined{jphase.SparseDiscPhaseVar}}, SparseContPhaseVar\small{\refdefined{jphase.SparseContPhaseVar}}, PhaseVar\small{\refdefined{jphase.PhaseVar}}, HyperErlangVar\small{\refdefined{jphase.HyperErlangVar}}, ErlangCoxianVar\small{\refdefined{jphase.ErlangCoxianVar}}, DiscPhaseVar\small{\refdefined{jphase.DiscPhaseVar}}, DenseDiscPhaseVar\small{\refdefined{jphase.DenseDiscPhaseVar}}, DenseContPhaseVar\small{\refdefined{jphase.DenseContPhaseVar}}, ContPhaseVar\small{\refdefined{jphase.ContPhaseVar}}, AbstractDiscPhaseVar\small{\refdefined{jphase.AbstractDiscPhaseVar}}, AbstractContPhaseVar\small{\refdefined{jphase.AbstractContPhaseVar}}}
\subsubsection{All known subinterfaces}{Transitions\small{\refdefined{jmarkov.basic.Transitions}}, PropertiesElement\small{\refdefined{jmarkov.basic.PropertiesElement}}, PhaseVar\small{\refdefined{jphase.PhaseVar}}}
\subsubsection{All classes known to implement interface}{MarkovProcess\small{\refdefined{jmarkov.MarkovProcess}}, ValueFunction\small{\refdefined{jmarkov.basic.ValueFunction}}, TransitionsSet\small{\refdefined{jmarkov.basic.TransitionsSet}}, Transition\small{\refdefined{jmarkov.basic.Transition}}, State\small{\refdefined{jmarkov.basic.State}}, Event\small{\refdefined{jmarkov.basic.Event}}, DecisionRule\small{\refdefined{jmarkov.basic.DecisionRule}}, Action\small{\refdefined{jmarkov.basic.Action}}, Solver\small{\refdefined{jmarkov.jmdp.solvers.Solver}}, Solver\small{\refdefined{jmarkov.solvers.Solver}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.JMarkovElement.description()}{{\bf description()}} This method return a complete verbal describtion of this element.\\
\hyperlink{jmarkov.basic.JMarkovElement.equals(java.lang.Object)}{{\bf equals(Object)}} Returns true if these two elements are equal.\\
\hyperlink{jmarkov.basic.JMarkovElement.label()}{{\bf label()}} This method returns a short String used in the user interface to describe this element.\\
\hyperlink{jmarkov.basic.JMarkovElement.toString()}{{\bf toString()}} This method returns a short String used in the user interface to describe this element.\\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.basic.JMarkovElement.description()}{\membername{description}}
{\tt  java.lang.String\ {\bf description}(  )
\label{jmarkov.basic.JMarkovElement.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method return a complete verbal describtion of this element. This description may contain multiple text rows.
}
\item{{\bf Returns} -- 
A String describing this element. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.label()}{JMarkovElement.label()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\index{equals(Object)}
\hypertarget{jmarkov.basic.JMarkovElement.equals(java.lang.Object)}{\membername{equals}}
{\tt  boolean\ {\bf equals}( {\tt java.lang.Object} {\bf e} )
\label{jmarkov.basic.JMarkovElement.equals(java.lang.Object)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns true if these two elements are equal. If this element implementa a compareTo() method it is recommended that this method returns compareTo(o)==0.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt e} -- The Object to compare to.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
True if the elements are equal. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Object.equals(java.lang.Object)}{java.lang.Object.equals(Object)}} {\small 
\refdefined{java.lang.Object.equals(java.lang.Object)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.JMarkovElement.label()}{\membername{label}}
{\tt  java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.JMarkovElement.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method returns a short String used in the user interface to describe this element.
}
\item{{\bf Returns} -- 
A String label. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.description()}{JMarkovElement.description()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.description()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.basic.JMarkovElement.toString()}{\membername{toString}}
{\tt  java.lang.String\ {\bf toString}(  )
\label{jmarkov.basic.JMarkovElement.toString()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method returns a short String used in the user interface to describe this element. It is highly recommended that every class calls label(), using the following code:{\tt\small
\mbox{}\newline \phantom{ }public\phantom{ }final\phantom{ }String\phantom{ }toString()\phantom{ }\{}\mbox{}\newline
{\tt\small \phantom{ }\phantom{ }\phantom{ }\phantom{ }\phantom{ }return\phantom{ }label();}\mbox{}\newline
{\tt\small \phantom{ }\}}\mbox{}\newline
{\tt\small \phantom{ }}

}
\item{{\bf Returns} -- 
A String label. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.label()}{JMarkovElement.label()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{PropertiesElement}
\subsection{\label{jmarkov.basic.PropertiesElement}\index{PropertiesElement@{\it PropertiesElement}}{\bf {\it Interface} PropertiesElement}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.PropertiesElement}{}\vskip .1in 
This interface is a wrapper for elements (States, Actions Events) that can be represented by an arry of integers. Known implentations include PropertiesState, Propertiesevent and PropertiesAction. Basic methods are provided to access the internal array.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.basic.PropertiesState}{PropertiesState}} {\small 
\refdefined{jmarkov.basic.PropertiesState}}%end
} 
\item{ {\tt \hyperlink{jmarkov.basic.PropertiesAction}{PropertiesAction}} {\small 
\refdefined{jmarkov.basic.PropertiesAction}}%end
} 
\item{ {\tt \hyperlink{jmarkov.basic.PropertiesEvent}{PropertiesEvent}} {\small 
\refdefined{jmarkov.basic.PropertiesEvent}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface PropertiesElement
\\ {\bf implements} 
JMarkovElement}}}
\subsubsection{All known subclasses}{PropertiesState\small{\refdefined{jmarkov.basic.PropertiesState}}, PropertiesEvent\small{\refdefined{jmarkov.basic.PropertiesEvent}}, PropertiesAction\small{\refdefined{jmarkov.basic.PropertiesAction}}}
\subsubsection{All classes known to implement interface}{PropertiesState\small{\refdefined{jmarkov.basic.PropertiesState}}, PropertiesEvent\small{\refdefined{jmarkov.basic.PropertiesEvent}}, PropertiesAction\small{\refdefined{jmarkov.basic.PropertiesAction}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.PropertiesElement.clone()}{{\bf clone()}} \\
\hyperlink{jmarkov.basic.PropertiesElement.getNumProps()}{{\bf getNumProps()}} Returns the number of properties in the array that characterize this element.\\
\hyperlink{jmarkov.basic.PropertiesElement.getProperties()}{{\bf getProperties()}} Gets the array of properties.\\
\hyperlink{jmarkov.basic.PropertiesElement.getProperty(int)}{{\bf getProperty(int)}} Gets the value of this property at this index.\\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{clone()}
\hypertarget{jmarkov.basic.PropertiesElement.clone()}{\membername{clone}}
{\tt  PropertiesElement\ {\bf clone}(  )
\label{jmarkov.basic.PropertiesElement.clone()}}%end signature
}%end item
\divideents{getNumProps}
\item{\vskip -1.9ex 
\index{getNumProps()}
\hypertarget{jmarkov.basic.PropertiesElement.getNumProps()}{\membername{getNumProps}}
{\tt  int\ {\bf getNumProps}(  )
\label{jmarkov.basic.PropertiesElement.getNumProps()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of properties in the array that characterize this element.
}
\item{{\bf Returns} -- 
The number of properties. 
}%end item
\end{itemize}
}%end item
\divideents{getProperties}
\item{\vskip -1.9ex 
\index{getProperties()}
\hypertarget{jmarkov.basic.PropertiesElement.getProperties()}{\membername{getProperties}}
{\tt  int\lbrack \rbrack \ {\bf getProperties}(  )
\label{jmarkov.basic.PropertiesElement.getProperties()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the array of properties.
}
\item{{\bf Returns} -- 
Returns the properties array. 
}%end item
\end{itemize}
}%end item
\divideents{getProperty}
\item{\vskip -1.9ex 
\index{getProperty(int)}
\hypertarget{jmarkov.basic.PropertiesElement.getProperty(int)}{\membername{getProperty}}
{\tt  int\ {\bf getProperty}( {\tt int} {\bf index} )
\label{jmarkov.basic.PropertiesElement.getProperty(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the value of this property at this index.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the property at the given index 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{States}
\subsection{\label{jmarkov.basic.States}\index{States@{\it States}}{\bf {\it Interface} States}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.States}{}\vskip .1in 
This interface represents a set of objects State. The user must choose his own data structure and define the constuctors, or provide a mechanism to generate the sates on-the-fly. A convinience class, StatesSet, is provided if the states are to be stored.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.basic.StatesSet}{StatesSet}} {\small 
\refdefined{jmarkov.basic.StatesSet}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface States
\\ {\bf implements} 
java.lang.Iterable}}}
\subsubsection{All known subclasses}{StatesSet\small{\refdefined{jmarkov.basic.StatesSet}}}
\subsubsection{All classes known to implement interface}{StatesSet\small{\refdefined{jmarkov.basic.StatesSet}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.States.isClosed()}{{\bf isClosed()}} The set is closed if all elements have been added.\\
\hyperlink{jmarkov.basic.States.iterator()}{{\bf iterator()}} This function must be implemented.\\
\hyperlink{jmarkov.basic.States.numerateStates()}{{\bf numerateStates()}} This method numerates all states and returns the number of states found.\\
\hyperlink{jmarkov.basic.States.size()}{{\bf size()}} Returns the number of elements.\\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{isClosed()}
\hypertarget{jmarkov.basic.States.isClosed()}{\membername{isClosed}}
{\tt  boolean\ {\bf isClosed}(  )
\label{jmarkov.basic.States.isClosed()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The set is closed if all elements have been added.
}
\item{{\bf Returns} -- 
true if the set is closed. 
}%end item
\end{itemize}
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\index{iterator()}
\hypertarget{jmarkov.basic.States.iterator()}{\membername{iterator}}
{\tt  java.util.Iterator\ {\bf iterator}(  )
\label{jmarkov.basic.States.iterator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This function must be implemented. Must return an iterator over the states.
}
\end{itemize}
}%end item
\divideents{numerateStates}
\item{\vskip -1.9ex 
\index{numerateStates()}
\hypertarget{jmarkov.basic.States.numerateStates()}{\membername{numerateStates}}
{\tt  int\ {\bf numerateStates}(  )
\label{jmarkov.basic.States.numerateStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method numerates all states and returns the number of states found. Afther this method is called it is illegal to add more states to the set.
}
\item{{\bf Returns} -- 
The number of states. 
}%end item
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\index{size()}
\hypertarget{jmarkov.basic.States.size()}{\membername{size}}
{\tt  int\ {\bf size}(  )
\label{jmarkov.basic.States.size()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of elements.
}
\item{{\bf Returns} -- 
the number of State elements. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{Transitions}
\subsection{\label{jmarkov.basic.Transitions}\index{Transitions@{\it Transitions}}{\bf {\it Interface} Transitions}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.Transitions}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface Transitions
\\ {\bf implements} 
JMarkovElement, java.lang.Iterable}}}
\subsubsection{All known subclasses}{TransitionsSet\small{\refdefined{jmarkov.basic.TransitionsSet}}}
\subsubsection{All classes known to implement interface}{TransitionsSet\small{\refdefined{jmarkov.basic.TransitionsSet}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Transitions.add(S, double)}{{\bf add(S, double)}} Adds a ne transition to the given state\\
\hyperlink{jmarkov.basic.Transitions.add(jmarkov.basic.Transition)}{{\bf add(Transition)}} \\
\hyperlink{jmarkov.basic.Transitions.addRate(S, double)}{{\bf addRate(S, double)}} Adds the given rate to the transition to this state.\\
\hyperlink{jmarkov.basic.Transitions.getRate(S)}{{\bf getRate(S)}} Gets the rate for this state.\\
\hyperlink{jmarkov.basic.Transitions.size()}{{\bf size()}} Returns the number of Transtions represented by this object.\\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{add(S, double)}
\hypertarget{jmarkov.basic.Transitions.add(S, double)}{\membername{add}}
{\tt  boolean\ {\bf add}( {\tt State} {\bf state},
{\tt double} {\bf rate} )
\label{jmarkov.basic.Transitions.add(S, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Adds a ne transition to the given state
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt state} -- State the transition goes to}
   \item{
\sld
{\tt rate} -- The rate at which this transition occurs.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
true if the state was already on the set. 
}%end item
\end{itemize}
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\index{add(Transition)}
\hypertarget{jmarkov.basic.Transitions.add(jmarkov.basic.Transition)}{\membername{add}}
{\tt  boolean\ {\bf add}( {\tt Transition} {\bf t} )
\label{jmarkov.basic.Transitions.add(jmarkov.basic.Transition)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt t} -- The trenasition to add.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
true of the element was already in the set. 
}%end item
\end{itemize}
}%end item
\divideents{addRate}
\item{\vskip -1.9ex 
\index{addRate(S, double)}
\hypertarget{jmarkov.basic.Transitions.addRate(S, double)}{\membername{addRate}}
{\tt  double\ {\bf addRate}( {\tt State} {\bf state},
{\tt double} {\bf rate} )
\label{jmarkov.basic.Transitions.addRate(S, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Adds the given rate to the transition to this state.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt state} -- }
   \item{
\sld
{\tt rate} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The old value associated with this state. 
}%end item
\end{itemize}
}%end item
\divideents{getRate}
\item{\vskip -1.9ex 
\index{getRate(S)}
\hypertarget{jmarkov.basic.Transitions.getRate(S)}{\membername{getRate}}
{\tt  double\ {\bf getRate}( {\tt State} {\bf state} )
\label{jmarkov.basic.Transitions.getRate(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the rate for this state. It returns 0.0 if this state is not in the Transitions.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt state} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The rate for this state 
}%end item
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\index{size()}
\hypertarget{jmarkov.basic.Transitions.size()}{\membername{size}}
{\tt  int\ {\bf size}(  )
\label{jmarkov.basic.Transitions.size()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of Transtions represented by this object.
}
\item{{\bf Returns} -- 
The number of Transitions. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.util.Set.size()}{java.util.Set.size()}} {\small 
\refdefined{java.util.Set.size()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage}
\section{Classes}{
\gdef\classname{Action}
\subsection{\label{jmarkov.basic.Action}\index{Action}{\bf {\it Class} Action}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.Action}{}\vskip .1in 
This class represents a single Action in Markov Decision Process (MDP). It implements Comparable in order to be easily organized and searched.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{java.lang.Comparable}{java.lang.Comparable}} {\small 
\refdefined{java.lang.Comparable}}%end
} 
\item{ {\tt \hyperlink{jmarkov.jmdp}{jmarkov.jmdp}} {\small 
\refdefined{jmarkov.jmdp}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class Action
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
java.lang.Comparable, JMarkovElement}}}
\subsubsection{All known subclasses}{PropertiesAction\small{\refdefined{jmarkov.basic.PropertiesAction}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Action()}{{\bf Action()}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Action.description()}{{\bf description()}} The user SHOULD override this method to give a complete description for the action.\\
\hyperlink{jmarkov.basic.Action.equals(java.lang.Object)}{{\bf equals(Object)}} This method calls compareTo to check if the Action are equal.\\
\hyperlink{jmarkov.basic.Action.label()}{{\bf label()}} The user MUST override this method to give a (hopefully short) label for the Action.\\
\hyperlink{jmarkov.basic.Action.toString()}{{\bf toString()}} This calls label().\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{Action()}
\hypertarget{jmarkov.basic.Action()}{\membername{Action}}
{\tt public\ {\bf Action}(  )
\label{jmarkov.basic.Action()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.basic.Action.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jmarkov.basic.Action.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The user SHOULD override this method to give a complete description for the action.
}
\item{{\bf Returns} -- 
short description of the state. 
}%end item
\end{itemize}
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\index{equals(Object)}
\hypertarget{jmarkov.basic.Action.equals(java.lang.Object)}{\membername{equals}}
{\tt public final boolean\ {\bf equals}( {\tt java.lang.Object} {\bf o} )
\label{jmarkov.basic.Action.equals(java.lang.Object)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method calls compareTo to check if the Action are equal.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Object.equals(java.lang.Object)}{java.lang.Object.equals(Object)}} {\small 
\refdefined{java.lang.Object.equals(java.lang.Object)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.Action.label()}{\membername{label}}
{\tt public abstract java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.Action.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The user MUST override this method to give a (hopefully short) label for the Action.
}
\item{{\bf Returns} -- 
short description of the Action. 
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.basic.Action.toString()}{\membername{toString}}
{\tt public final java.lang.String\ {\bf toString}(  )
\label{jmarkov.basic.Action.toString()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This calls label().
}
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{ActionsSet}
\subsection{\label{jmarkov.basic.ActionsSet}\index{ActionsSet}{\bf {\it Class} ActionsSet}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.ActionsSet}{}\vskip .1in 
This class represents a set of objects Action. It uses the TreeSet structure to avoid repeated actions. This class extends the Actions class.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{java.util.Collection}{java.util.Collection}} {\small 
\refdefined{java.util.Collection}}%end
} 
\item{ {\tt \hyperlink{jmarkov.basic.Actions}{Actions}} {\small 
\refdefined{jmarkov.basic.Actions}}%end
} 
\item{ {\tt \hyperlink{jmarkov.basic.Action}{Action}} {\small 
\refdefined{jmarkov.basic.Action}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class ActionsSet
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
Actions}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.ActionsSet()}{{\bf ActionsSet()}} Creates an empty set of Actions.\\
\hyperlink{jmarkov.basic.ActionsSet(A)}{{\bf ActionsSet(A)}} Creates a set of Actions from a given Action.\\
\hyperlink{jmarkov.basic.ActionsSet(A[])}{{\bf ActionsSet(A\lbrack \rbrack )}} Creates a set of Actions from a given array of Actions.\\
\hyperlink{jmarkov.basic.ActionsSet(jmarkov.basic.Actions)}{{\bf ActionsSet(Actions)}} Creates a set of Actions from a given set of Actions.\\
\hyperlink{jmarkov.basic.ActionsSet(java.lang.Iterable)}{{\bf ActionsSet(Iterable)}} Creates a set of actions from any iterable object over actions.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.ActionsSet.add(A)}{{\bf add(A)}} This method adds a new action to the set.\\
\hyperlink{jmarkov.basic.ActionsSet.iterator()}{{\bf iterator()}} This method returns a safe way to walk along the actions in a particular set.\\
\hyperlink{jmarkov.basic.ActionsSet.size()}{{\bf size()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{ActionsSet()}
\hypertarget{jmarkov.basic.ActionsSet()}{\membername{ActionsSet}}
{\tt public\ {\bf ActionsSet}(  )
\label{jmarkov.basic.ActionsSet()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates an empty set of Actions.
}
\end{itemize}
}%end item
\divideents{ActionsSet}
\item{\vskip -1.9ex 
\index{ActionsSet(A)}
\hypertarget{jmarkov.basic.ActionsSet(A)}{\membername{ActionsSet}}
{\tt public\ {\bf ActionsSet}( {\tt Action} {\bf ac} )
\label{jmarkov.basic.ActionsSet(A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a set of Actions from a given Action. This constructor organizes the actions in a TreeSet.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt ac} -- an Action.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{ActionsSet}
\item{\vskip -1.9ex 
\index{ActionsSet(A\lbrack \rbrack )}
\hypertarget{jmarkov.basic.ActionsSet(A[])}{\membername{ActionsSet}}
{\tt public\ {\bf ActionsSet}( {\tt Action\lbrack \rbrack } {\bf acArray} )
\label{jmarkov.basic.ActionsSet(A[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a set of Actions from a given array of Actions. This constructor organizes the actions in a TreeSet.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt acArray} -- set of Actions of type Actions.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{ActionsSet}
\item{\vskip -1.9ex 
\index{ActionsSet(Actions)}
\hypertarget{jmarkov.basic.ActionsSet(jmarkov.basic.Actions)}{\membername{ActionsSet}}
{\tt public\ {\bf ActionsSet}( {\tt Actions} {\bf ac} )
\label{jmarkov.basic.ActionsSet(jmarkov.basic.Actions)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a set of Actions from a given set of Actions.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt ac} -- set of Actions of type Actions.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{ActionsSet}
\item{\vskip -1.9ex 
\index{ActionsSet(Iterable)}
\hypertarget{jmarkov.basic.ActionsSet(java.lang.Iterable)}{\membername{ActionsSet}}
{\tt public\ {\bf ActionsSet}( {\tt java.lang.Iterable} {\bf actIter} )
\label{jmarkov.basic.ActionsSet(java.lang.Iterable)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a set of actions from any iterable object over actions.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt actIter} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{add(A)}
\hypertarget{jmarkov.basic.ActionsSet.add(A)}{\membername{add}}
{\tt public void\ {\bf add}( {\tt Action} {\bf a} )
\label{jmarkov.basic.ActionsSet.add(A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method adds a new action to the set.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt a} -- The action to be added.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\index{iterator()}
\hypertarget{jmarkov.basic.ActionsSet.iterator()}{\membername{iterator}}
{\tt public final java.util.Iterator\ {\bf iterator}(  )
\label{jmarkov.basic.ActionsSet.iterator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method returns a safe way to walk along the actions in a particular set. Collections and their implementations (Set, List, and Map) have iterators defined by default.
}
\item{{\bf Returns} -- 
iterator over the states. 
}%end item
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\index{size()}
\hypertarget{jmarkov.basic.ActionsSet.size()}{\membername{size}}
{\tt  int\ {\bf size}(  )
\label{jmarkov.basic.ActionsSet.size()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.Actions}{Actions}{\small \refdefined{jmarkov.basic.Actions}} }

Returns the number of elements.
}
\item{{\bf Returns} -- 
the number of elements. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{DecisionRule}
\subsection{\label{jmarkov.basic.DecisionRule}\index{DecisionRule}{\bf {\it Class} DecisionRule}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.DecisionRule}{}\vskip .1in 
This class represents a deterministic decision rule which assigns an action to every state.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public final class DecisionRule
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
JMarkovElement, java.lang.Iterable}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.DecisionRule()}{{\bf DecisionRule()}} Creates a new empty decision rule\\
\hyperlink{jmarkov.basic.DecisionRule(jmarkov.basic.DecisionRule)}{{\bf DecisionRule(DecisionRule)}} Creates a decision rule from a given one\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.DecisionRule.description()}{{\bf description()}} Gives the sting representation of this Rule\\
\hyperlink{jmarkov.basic.DecisionRule.equals(java.lang.Object)}{{\bf equals(Object)}} Determines if the given decision rules are equal.\\
\hyperlink{jmarkov.basic.DecisionRule.getAction(S)}{{\bf getAction(S)}} Gets the prescribed action for the given State.\\
\hyperlink{jmarkov.basic.DecisionRule.iterator()}{{\bf iterator()}} Return an iterator over the State-Action pairs.\\
\hyperlink{jmarkov.basic.DecisionRule.label()}{{\bf label()}} \\
\hyperlink{jmarkov.basic.DecisionRule.print()}{{\bf print()}} Prints the Rule to the sandard output\\
\hyperlink{jmarkov.basic.DecisionRule.print(java.io.PrintWriter)}{{\bf print(PrintWriter)}} Prints the policiy to the given PrintWriter.\\
\hyperlink{jmarkov.basic.DecisionRule.print(java.io.PrintWriter, java.lang.String, java.lang.String)}{{\bf print(PrintWriter, String, String)}} Prints the policiy to the given PrintWriter.\\
\hyperlink{jmarkov.basic.DecisionRule.set(S, A)}{{\bf set(S, A)}} Maps a given action to a given state\\
\hyperlink{jmarkov.basic.DecisionRule.size()}{{\bf size()}} Returns the amount of states linked to actions in the decision rule.\\
\hyperlink{jmarkov.basic.DecisionRule.toString()}{{\bf toString()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{DecisionRule()}
\hypertarget{jmarkov.basic.DecisionRule()}{\membername{DecisionRule}}
{\tt public\ {\bf DecisionRule}(  )
\label{jmarkov.basic.DecisionRule()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new empty decision rule
}
\end{itemize}
}%end item
\divideents{DecisionRule}
\item{\vskip -1.9ex 
\index{DecisionRule(DecisionRule)}
\hypertarget{jmarkov.basic.DecisionRule(jmarkov.basic.DecisionRule)}{\membername{DecisionRule}}
{\tt public\ {\bf DecisionRule}( {\tt DecisionRule} {\bf dr} )
\label{jmarkov.basic.DecisionRule(jmarkov.basic.DecisionRule)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a decision rule from a given one
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt dr} -- decision rule}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.basic.DecisionRule.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jmarkov.basic.DecisionRule.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gives the sting representation of this Rule
}
\end{itemize}
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\index{equals(Object)}
\hypertarget{jmarkov.basic.DecisionRule.equals(java.lang.Object)}{\membername{equals}}
{\tt public boolean\ {\bf equals}( {\tt java.lang.Object} {\bf o} )
\label{jmarkov.basic.DecisionRule.equals(java.lang.Object)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Determines if the given decision rules are equal.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt o} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
True, if the decision rules are equal. 
}%end item
\end{itemize}
}%end item
\divideents{getAction}
\item{\vskip -1.9ex 
\index{getAction(S)}
\hypertarget{jmarkov.basic.DecisionRule.getAction(S)}{\membername{getAction}}
{\tt public Action\ {\bf getAction}( {\tt State} {\bf s} )
\label{jmarkov.basic.DecisionRule.getAction(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the prescribed action for the given State.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- state}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the action corresponding to the given state 
}%end item
\end{itemize}
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\index{iterator()}
\hypertarget{jmarkov.basic.DecisionRule.iterator()}{\membername{iterator}}
{\tt public java.util.Iterator\ {\bf iterator}(  )
\label{jmarkov.basic.DecisionRule.iterator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return an iterator over the State-Action pairs.
}
\item{{\bf Returns} -- 
iterator over the entries 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.DecisionRule.label()}{\membername{label}}
{\tt  java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.DecisionRule.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.JMarkovElement}{JMarkovElement}{\small \refdefined{jmarkov.basic.JMarkovElement}} }

This method returns a short String used in the user interface to describe this element.
}
\item{{\bf Returns} -- 
A String label. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.description()}{JMarkovElement.description()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.description()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{print}
\item{\vskip -1.9ex 
\index{print()}
\hypertarget{jmarkov.basic.DecisionRule.print()}{\membername{print}}
{\tt public void\ {\bf print}(  )
\label{jmarkov.basic.DecisionRule.print()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the Rule to the sandard output
}
\end{itemize}
}%end item
\divideents{print}
\item{\vskip -1.9ex 
\index{print(PrintWriter)}
\hypertarget{jmarkov.basic.DecisionRule.print(java.io.PrintWriter)}{\membername{print}}
{\tt public void\ {\bf print}( {\tt java.io.PrintWriter} {\bf pw} )
\label{jmarkov.basic.DecisionRule.print(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the policiy to the given PrintWriter.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pw} -- PrintWriter to use}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{print}
\item{\vskip -1.9ex 
\index{print(PrintWriter, String, String)}
\hypertarget{jmarkov.basic.DecisionRule.print(java.io.PrintWriter, java.lang.String, java.lang.String)}{\membername{print}}
{\tt public void\ {\bf print}( {\tt java.io.PrintWriter} {\bf pw},
{\tt java.lang.String} {\bf statesFormat},
{\tt java.lang.String} {\bf actionFormat} )
\label{jmarkov.basic.DecisionRule.print(java.io.PrintWriter, java.lang.String, java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the policiy to the given PrintWriter.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pw} -- PrintWriter to use}
   \item{
\sld
{\tt statesFormat} -- format for the states , for example "\%-10S" to have 10 width left aligned states.}
   \item{
\sld
{\tt actionFormat} -- format for the actions , for example "\%-10S" to have 10 width left aligned actions.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{set}
\item{\vskip -1.9ex 
\index{set(S, A)}
\hypertarget{jmarkov.basic.DecisionRule.set(S, A)}{\membername{set}}
{\tt public void\ {\bf set}( {\tt State} {\bf s},
{\tt Action} {\bf a} )
\label{jmarkov.basic.DecisionRule.set(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Maps a given action to a given state
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- state}
   \item{
\sld
{\tt a} -- action}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\index{size()}
\hypertarget{jmarkov.basic.DecisionRule.size()}{\membername{size}}
{\tt public int\ {\bf size}(  )
\label{jmarkov.basic.DecisionRule.size()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the amount of states linked to actions in the decision rule.
}
\item{{\bf Returns} -- 
Amount of states linked to actions in the decision rule. 
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.basic.DecisionRule.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jmarkov.basic.DecisionRule.toString()}}%end signature
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{Event}
\subsection{\label{jmarkov.basic.Event}\index{Event}{\bf {\it Class} Event}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.Event}{}\vskip .1in 
The class Event allows the user to define the implementation of the Events that can alter the States of the Markov Chain.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class Event
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
java.lang.Comparable, JMarkovElement}}}
\subsubsection{All known subclasses}{PropertiesEvent\small{\refdefined{jmarkov.basic.PropertiesEvent}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Event()}{{\bf Event()}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Event.compareTo(jmarkov.basic.Event)}{{\bf compareTo(Event)}} Returns positive if this Event has a higher number then the given event.\\
\hyperlink{jmarkov.basic.Event.description()}{{\bf description()}} It is highly recommended that the user overrides it to give a description to be used when reporting the occurrance rates of the events, and GUI.\\
\hyperlink{jmarkov.basic.Event.equals(java.lang.Object)}{{\bf equals(Object)}} This method calls compareTo to check if the Action are equal.\\
\hyperlink{jmarkov.basic.Event.getIndex()}{{\bf getIndex()}} Gives the position of the Event in the Events set.\\
\hyperlink{jmarkov.basic.Event.getSet()}{{\bf getSet()}} Returns the set of Events to which this event belongs.\\
\hyperlink{jmarkov.basic.Event.label()}{{\bf label()}} If this function is not overriden by the user it returns the Event number.\\
\hyperlink{jmarkov.basic.Event.toString()}{{\bf toString()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{Event()}
\hypertarget{jmarkov.basic.Event()}{\membername{Event}}
{\tt public\ {\bf Event}(  )
\label{jmarkov.basic.Event()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{compareTo(Event)}
\hypertarget{jmarkov.basic.Event.compareTo(jmarkov.basic.Event)}{\membername{compareTo}}
{\tt public int\ {\bf compareTo}( {\tt Event} {\bf ev} )
\label{jmarkov.basic.Event.compareTo(jmarkov.basic.Event)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns positive if this Event has a higher number then the given event.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Comparable.compareTo(T)}{java.lang.Comparable.compareTo(Object)}} {\small 
\refdefined{java.lang.Comparable.compareTo(T)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.basic.Event.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jmarkov.basic.Event.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

It is highly recommended that the user overrides it to give a description to be used when reporting the occurrance rates of the events, and GUI.
}
\item{{\bf Returns} -- 
a String description 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.Event.label()}{Event.label()}} {\small 
\refdefined{jmarkov.basic.Event.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\index{equals(Object)}
\hypertarget{jmarkov.basic.Event.equals(java.lang.Object)}{\membername{equals}}
{\tt public final boolean\ {\bf equals}( {\tt java.lang.Object} {\bf o} )
\label{jmarkov.basic.Event.equals(java.lang.Object)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method calls compareTo to check if the Action are equal.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Object.equals(java.lang.Object)}{java.lang.Object.equals(Object)}} {\small 
\refdefined{java.lang.Object.equals(java.lang.Object)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getIndex}
\item{\vskip -1.9ex 
\index{getIndex()}
\hypertarget{jmarkov.basic.Event.getIndex()}{\membername{getIndex}}
{\tt public int\ {\bf getIndex}(  )
\label{jmarkov.basic.Event.getIndex()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gives the position of the Event in the Events set. Returns -1 if this events has not yet been added to the set.
}
\item{{\bf Returns} -- 
The position of the Event in the Events set. Returns -1 if this events has not yet been added to the set. 
}%end item
\end{itemize}
}%end item
\divideents{getSet}
\item{\vskip -1.9ex 
\index{getSet()}
\hypertarget{jmarkov.basic.Event.getSet()}{\membername{getSet}}
{\tt public EventsSet\ {\bf getSet}(  )
\label{jmarkov.basic.Event.getSet()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the set of Events to which this event belongs.
}
\item{{\bf Returns} -- 
the set to which this event belongs. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.Event.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.Event.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

If this function is not overriden by the user it returns the Event number. The user should override to give a short label description of the Event. It is highly recommended that the user overrides it to give a more descriptive label to be used when reporting the occurrance rates of the events.
}
\item{{\bf Returns} -- 
A short string description of the Event. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.Event.description()}{Event.description()}} {\small 
\refdefined{jmarkov.basic.Event.description()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.basic.Event.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jmarkov.basic.Event.toString()}}%end signature
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{EventsSet}
\subsection{\label{jmarkov.basic.EventsSet}\index{EventsSet}{\bf {\it Class} EventsSet}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.EventsSet}{}\vskip .1in 
This class represent a set of Events. The set should be build at the beggining and should not be changed in any way afterwards.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class EventsSet
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
Events}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.EventsSet()}{{\bf EventsSet()}} Creates an empty set of Events;\\
\hyperlink{jmarkov.basic.EventsSet(E[])}{{\bf EventsSet(E\lbrack \rbrack )}} Creates an empty set of Events;\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.EventsSet.add(E)}{{\bf add(E)}} Adds the Event e to the set.\\
\hyperlink{jmarkov.basic.EventsSet.contains(jmarkov.basic.Event)}{{\bf contains(Event)}} Returns true if the set contains this Event.\\
\hyperlink{jmarkov.basic.EventsSet.iterator()}{{\bf iterator()}} This method returns a safe way to walk through the events in a particular set.\\
\hyperlink{jmarkov.basic.EventsSet.size()}{{\bf size()}} \\
\hyperlink{jmarkov.basic.EventsSet.toEventArray()}{{\bf toEventArray()}} Returns an array with the Events in the set.\\
\hyperlink{jmarkov.basic.EventsSet.toString()}{{\bf toString()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{EventsSet()}
\hypertarget{jmarkov.basic.EventsSet()}{\membername{EventsSet}}
{\tt public\ {\bf EventsSet}(  )
\label{jmarkov.basic.EventsSet()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates an empty set of Events;
}
\end{itemize}
}%end item
\divideents{EventsSet}
\item{\vskip -1.9ex 
\index{EventsSet(E\lbrack \rbrack )}
\hypertarget{jmarkov.basic.EventsSet(E[])}{\membername{EventsSet}}
{\tt public\ {\bf EventsSet}( {\tt Event\lbrack \rbrack } {\bf eventArray} )
\label{jmarkov.basic.EventsSet(E[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates an empty set of Events;
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt eventArray} -- an array representation of the set.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{add(E)}
\hypertarget{jmarkov.basic.EventsSet.add(E)}{\membername{add}}
{\tt public boolean\ {\bf add}( {\tt Event} {\bf e} )
\label{jmarkov.basic.EventsSet.add(E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Adds the Event e to the set.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt e} -- The event to be added.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
True if the set did not already contained this event. 
}%end item
\end{itemize}
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\index{contains(Event)}
\hypertarget{jmarkov.basic.EventsSet.contains(jmarkov.basic.Event)}{\membername{contains}}
{\tt public boolean\ {\bf contains}( {\tt Event} {\bf e} )
\label{jmarkov.basic.EventsSet.contains(jmarkov.basic.Event)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns true if the set contains this Event.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt e} -- The event.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
whether the set contains this event. 
}%end item
\end{itemize}
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\index{iterator()}
\hypertarget{jmarkov.basic.EventsSet.iterator()}{\membername{iterator}}
{\tt public final java.util.Iterator\ {\bf iterator}(  )
\label{jmarkov.basic.EventsSet.iterator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method returns a safe way to walk through the events in a particular set. Collections and their implementations (Set, List, and Map) have iterators defined by default.
}
\item{{\bf Returns} -- 
iterator over the events. 
}%end item
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\index{size()}
\hypertarget{jmarkov.basic.EventsSet.size()}{\membername{size}}
{\tt  int\ {\bf size}(  )
\label{jmarkov.basic.EventsSet.size()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.Events}{Events}{\small \refdefined{jmarkov.basic.Events}} }

Returns the number of elements.
}
\item{{\bf Returns} -- 
the number of Event elements. 
}%end item
\end{itemize}
}%end item
\divideents{toEventArray}
\item{\vskip -1.9ex 
\index{toEventArray()}
\hypertarget{jmarkov.basic.EventsSet.toEventArray()}{\membername{toEventArray}}
{\tt public Event\lbrack \rbrack \ {\bf toEventArray}(  )
\label{jmarkov.basic.EventsSet.toEventArray()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns an array with the Events in the set.
}
\item{{\bf Returns} -- 
array representation of the set. 
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.basic.EventsSet.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jmarkov.basic.EventsSet.toString()}}%end signature
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{Policy}
\subsection{\label{jmarkov.basic.Policy}\index{Policy}{\bf {\it Class} Policy}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.Policy}{}\vskip .1in 
Policy is a set of "Decision Rules". It contains the Decision Rule for every stage t. When the problem has infinite horizon, only one decision rule is stored.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public final class Policy
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Policy(jmarkov.basic.DecisionRule)}{{\bf Policy(DecisionRule)}} Creates a stationary policy with the given decition rule\\
\hyperlink{jmarkov.basic.Policy(int)}{{\bf Policy(int)}} Creates a set with the given horizon.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Policy.getAction(S, int)}{{\bf getAction(S, int)}} Gets the action to be taken in state i at this stage t\\
\hyperlink{jmarkov.basic.Policy.getDecisionRule()}{{\bf getDecisionRule()}} \\
\hyperlink{jmarkov.basic.Policy.getDecisionRule(int)}{{\bf getDecisionRule(int)}} Returns the decision rule for statge t\\
\hyperlink{jmarkov.basic.Policy.getHorizon()}{{\bf getHorizon()}} Return the time horizon for this Ploicy.\\
\hyperlink{jmarkov.basic.Policy.print()}{{\bf print()}} Prints the policy to the standard output\\
\hyperlink{jmarkov.basic.Policy.print(java.io.PrintWriter)}{{\bf print(PrintWriter)}} Prints the policy to the given PrintWriter.\\
\hyperlink{jmarkov.basic.Policy.setDecisionRule(jmarkov.basic.DecisionRule)}{{\bf setDecisionRule(DecisionRule)}} Sets a unique decision rule for the policy, for infinite horizon problems.\\
\hyperlink{jmarkov.basic.Policy.setDecisionRule(jmarkov.basic.DecisionRule, int)}{{\bf setDecisionRule(DecisionRule, int)}} Sets a decision rule for stage t in the policy\\
\hyperlink{jmarkov.basic.Policy.toString()}{{\bf toString()}} Gives the sting representation of this Policy\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{Policy(DecisionRule)}
\hypertarget{jmarkov.basic.Policy(jmarkov.basic.DecisionRule)}{\membername{Policy}}
{\tt public\ {\bf Policy}( {\tt DecisionRule} {\bf d} )
\label{jmarkov.basic.Policy(jmarkov.basic.DecisionRule)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a stationary policy with the given decition rule
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt d} -- The rule}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{Policy}
\item{\vskip -1.9ex 
\index{Policy(int)}
\hypertarget{jmarkov.basic.Policy(int)}{\membername{Policy}}
{\tt public\ {\bf Policy}( {\tt int} {\bf stages} )
\label{jmarkov.basic.Policy(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a set with the given horizon.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt stages} -- The number of stages}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getAction(S, int)}
\hypertarget{jmarkov.basic.Policy.getAction(S, int)}{\membername{getAction}}
{\tt public Action\ {\bf getAction}( {\tt State} {\bf i},
{\tt int} {\bf t} )
\label{jmarkov.basic.Policy.getAction(S, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the action to be taken in state i at this stage t
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- The state}
   \item{
\sld
{\tt t} -- The stage (time) at which action is to be taken.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The action. 
}%end item
\end{itemize}
}%end item
\divideents{getDecisionRule}
\item{\vskip -1.9ex 
\index{getDecisionRule()}
\hypertarget{jmarkov.basic.Policy.getDecisionRule()}{\membername{getDecisionRule}}
{\tt public DecisionRule\ {\bf getDecisionRule}(  )
\label{jmarkov.basic.Policy.getDecisionRule()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
the unique decision rule, for infinite horizon problems. 
}%end item
\end{itemize}
}%end item
\divideents{getDecisionRule}
\item{\vskip -1.9ex 
\index{getDecisionRule(int)}
\hypertarget{jmarkov.basic.Policy.getDecisionRule(int)}{\membername{getDecisionRule}}
{\tt public DecisionRule\ {\bf getDecisionRule}( {\tt int} {\bf t} )
\label{jmarkov.basic.Policy.getDecisionRule(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the decision rule for statge t
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt t} -- stage.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The decision rule for stage t. 
}%end item
\end{itemize}
}%end item
\divideents{getHorizon}
\item{\vskip -1.9ex 
\index{getHorizon()}
\hypertarget{jmarkov.basic.Policy.getHorizon()}{\membername{getHorizon}}
{\tt public int\ {\bf getHorizon}(  )
\label{jmarkov.basic.Policy.getHorizon()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the time horizon for this Ploicy.
}
\item{{\bf Returns} -- 
last stage where actions can be taken 
}%end item
\end{itemize}
}%end item
\divideents{print}
\item{\vskip -1.9ex 
\index{print()}
\hypertarget{jmarkov.basic.Policy.print()}{\membername{print}}
{\tt public void\ {\bf print}(  )
\label{jmarkov.basic.Policy.print()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the policy to the standard output
}
\end{itemize}
}%end item
\divideents{print}
\item{\vskip -1.9ex 
\index{print(PrintWriter)}
\hypertarget{jmarkov.basic.Policy.print(java.io.PrintWriter)}{\membername{print}}
{\tt public void\ {\bf print}( {\tt java.io.PrintWriter} {\bf pw} )
\label{jmarkov.basic.Policy.print(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the policy to the given PrintWriter.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pw} -- print writer}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setDecisionRule}
\item{\vskip -1.9ex 
\index{setDecisionRule(DecisionRule)}
\hypertarget{jmarkov.basic.Policy.setDecisionRule(jmarkov.basic.DecisionRule)}{\membername{setDecisionRule}}
{\tt public void\ {\bf setDecisionRule}( {\tt DecisionRule} {\bf pol} )
\label{jmarkov.basic.Policy.setDecisionRule(jmarkov.basic.DecisionRule)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets a unique decision rule for the policy, for infinite horizon problems.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pol} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setDecisionRule}
\item{\vskip -1.9ex 
\index{setDecisionRule(DecisionRule, int)}
\hypertarget{jmarkov.basic.Policy.setDecisionRule(jmarkov.basic.DecisionRule, int)}{\membername{setDecisionRule}}
{\tt public void\ {\bf setDecisionRule}( {\tt DecisionRule} {\bf dr},
{\tt int} {\bf t} )
\label{jmarkov.basic.Policy.setDecisionRule(jmarkov.basic.DecisionRule, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets a decision rule for stage t in the policy
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt dr} -- decision rule}
   \item{
\sld
{\tt t} -- stage}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.basic.Policy.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jmarkov.basic.Policy.toString()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gives the sting representation of this Policy
}
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{PropertiesAction}
\subsection{\label{jmarkov.basic.PropertiesAction}\index{PropertiesAction}{\bf {\it Class} PropertiesAction}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.PropertiesAction}{}\vskip .1in 
This class is an easy way to use a Action that is represented by an integer valued array.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class PropertiesAction
\\ {\bf extends} jmarkov.basic.Action
\refdefined{jmarkov.basic.Action}\\ {\bf implements} 
PropertiesElement}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.PropertiesAction(int)}{{\bf PropertiesAction(int)}} Creates an Action Object wit an array of the given size.\\
\hyperlink{jmarkov.basic.PropertiesAction(int[])}{{\bf PropertiesAction(int\lbrack \rbrack )}} Builds an object with the given array.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.PropertiesAction.clone()}{{\bf clone()}} \\
\hyperlink{jmarkov.basic.PropertiesAction.compareTo(jmarkov.basic.Action)}{{\bf compareTo(Action)}} \\
\hyperlink{jmarkov.basic.PropertiesAction.compareTo(jmarkov.basic.PropertiesAction)}{{\bf compareTo(PropertiesAction)}} \\
\hyperlink{jmarkov.basic.PropertiesAction.getNumProps()}{{\bf getNumProps()}} Returns the number of properties in the array that characterize this element.\\
\hyperlink{jmarkov.basic.PropertiesAction.getProperties()}{{\bf getProperties()}} Gets thae array of properties.\\
\hyperlink{jmarkov.basic.PropertiesAction.getProperty(int)}{{\bf getProperty(int)}} Gets the value of this property.\\
\hyperlink{jmarkov.basic.PropertiesAction.label()}{{\bf label()}} \\
\hyperlink{jmarkov.basic.PropertiesAction.setProperty(int, int)}{{\bf setProperty(int, int)}} Sets the value of the property at the given index\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{PropertiesAction(int)}
\hypertarget{jmarkov.basic.PropertiesAction(int)}{\membername{PropertiesAction}}
{\tt public\ {\bf PropertiesAction}( {\tt int} {\bf size} )
\label{jmarkov.basic.PropertiesAction(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates an Action Object wit an array of the given size.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt size} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{PropertiesAction}
\item{\vskip -1.9ex 
\index{PropertiesAction(int\lbrack \rbrack )}
\hypertarget{jmarkov.basic.PropertiesAction(int[])}{\membername{PropertiesAction}}
{\tt public\ {\bf PropertiesAction}( {\tt int\lbrack \rbrack } {\bf properties} )
\label{jmarkov.basic.PropertiesAction(int[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Builds an object with the given array.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt properties} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{clone()}
\hypertarget{jmarkov.basic.PropertiesAction.clone()}{\membername{clone}}
{\tt protected native java.lang.Object\ {\bf clone}(  ) throws java.lang.CloneNotSupportedException
\label{jmarkov.basic.PropertiesAction.clone()}}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\index{compareTo(Action)}
\hypertarget{jmarkov.basic.PropertiesAction.compareTo(jmarkov.basic.Action)}{\membername{compareTo}}
{\tt public final int\ {\bf compareTo}( {\tt Action} {\bf a} )
\label{jmarkov.basic.PropertiesAction.compareTo(jmarkov.basic.Action)}}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\index{compareTo(PropertiesAction)}
\hypertarget{jmarkov.basic.PropertiesAction.compareTo(jmarkov.basic.PropertiesAction)}{\membername{compareTo}}
{\tt public final int\ {\bf compareTo}( {\tt PropertiesAction} {\bf a} )
\label{jmarkov.basic.PropertiesAction.compareTo(jmarkov.basic.PropertiesAction)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt a} -- The action array to compare to}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
+1, -1 or 0. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Comparable.compareTo(T)}{java.lang.Comparable.compareTo(Object)}} {\small 
\refdefined{java.lang.Comparable.compareTo(T)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getNumProps}
\item{\vskip -1.9ex 
\index{getNumProps()}
\hypertarget{jmarkov.basic.PropertiesAction.getNumProps()}{\membername{getNumProps}}
{\tt public int\ {\bf getNumProps}(  )
\label{jmarkov.basic.PropertiesAction.getNumProps()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of properties in the array that characterize this element.
}
\item{{\bf Returns} -- 
The number of properties. 
}%end item
\end{itemize}
}%end item
\divideents{getProperties}
\item{\vskip -1.9ex 
\index{getProperties()}
\hypertarget{jmarkov.basic.PropertiesAction.getProperties()}{\membername{getProperties}}
{\tt public final int\lbrack \rbrack \ {\bf getProperties}(  )
\label{jmarkov.basic.PropertiesAction.getProperties()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets thae array of properties.
}
\item{{\bf Returns} -- 
Returns the properties array. 
}%end item
\end{itemize}
}%end item
\divideents{getProperty}
\item{\vskip -1.9ex 
\index{getProperty(int)}
\hypertarget{jmarkov.basic.PropertiesAction.getProperty(int)}{\membername{getProperty}}
{\tt public int\ {\bf getProperty}( {\tt int} {\bf index} )
\label{jmarkov.basic.PropertiesAction.getProperty(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the value of this property.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the property at the given index 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.PropertiesAction.label()}{\membername{label}}
{\tt public abstract java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.PropertiesAction.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.Action}{Action}{\small \refdefined{jmarkov.basic.Action}} }

The user MUST override this method to give a (hopefully short) label for the Action.
}
\item{{\bf Returns} -- 
short description of the Action. 
}%end item
\end{itemize}
}%end item
\divideents{setProperty}
\item{\vskip -1.9ex 
\index{setProperty(int, int)}
\hypertarget{jmarkov.basic.PropertiesAction.setProperty(int, int)}{\membername{setProperty}}
{\tt protected void\ {\bf setProperty}( {\tt int} {\bf index},
{\tt int} {\bf value} )
\label{jmarkov.basic.PropertiesAction.setProperty(int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the value of the property at the given index
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} -- }
   \item{
\sld
{\tt value} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.basic.Action} \textnormal{\small\refdefined{jmarkov.basic.Action}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf equals}( {\tt java.lang.Object} {\bf o} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{PropertiesEvent}
\subsection{\label{jmarkov.basic.PropertiesEvent}\index{PropertiesEvent}{\bf {\it Class} PropertiesEvent}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.PropertiesEvent}{}\vskip .1in 
This class is an easy way to use an event that is represented by an array of int.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class PropertiesEvent
\\ {\bf extends} jmarkov.basic.Event
\refdefined{jmarkov.basic.Event}\\ {\bf implements} 
PropertiesElement}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.PropertiesEvent(int)}{{\bf PropertiesEvent(int)}} Creates a new PropertiesEvent with an array of the size indicated filled with zeros.\\
\hyperlink{jmarkov.basic.PropertiesEvent(int[])}{{\bf PropertiesEvent(int\lbrack \rbrack )}} Builds a new event with characteristic array as a paramenter.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.PropertiesEvent.clone()}{{\bf clone()}} \\
\hyperlink{jmarkov.basic.PropertiesEvent.compareTo(jmarkov.basic.Event)}{{\bf compareTo(Event)}} \\
\hyperlink{jmarkov.basic.PropertiesEvent.compareTo(jmarkov.basic.PropertiesEvent)}{{\bf compareTo(PropertiesEvent)}} Compares the properties in order.\\
\hyperlink{jmarkov.basic.PropertiesEvent.equals(jmarkov.basic.PropertiesEvent)}{{\bf equals(PropertiesEvent)}} \\
\hyperlink{jmarkov.basic.PropertiesEvent.getNumProps()}{{\bf getNumProps()}} Returns the number of properties in the array that characterize this element.\\
\hyperlink{jmarkov.basic.PropertiesEvent.getProperties()}{{\bf getProperties()}} Gets the array of properties.\\
\hyperlink{jmarkov.basic.PropertiesEvent.getProperty(int)}{{\bf getProperty(int)}} Gets the value of this property.\\
\hyperlink{jmarkov.basic.PropertiesEvent.label()}{{\bf label()}} \\
\hyperlink{jmarkov.basic.PropertiesEvent.setProperty(int, int)}{{\bf setProperty(int, int)}} Sets the value of the property at the given index\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{PropertiesEvent(int)}
\hypertarget{jmarkov.basic.PropertiesEvent(int)}{\membername{PropertiesEvent}}
{\tt public\ {\bf PropertiesEvent}( {\tt int} {\bf size} )
\label{jmarkov.basic.PropertiesEvent(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new PropertiesEvent with an array of the size indicated filled with zeros.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt size} -- size of the characteristic array.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{PropertiesEvent}
\item{\vskip -1.9ex 
\index{PropertiesEvent(int\lbrack \rbrack )}
\hypertarget{jmarkov.basic.PropertiesEvent(int[])}{\membername{PropertiesEvent}}
{\tt public\ {\bf PropertiesEvent}( {\tt int\lbrack \rbrack } {\bf status} )
\label{jmarkov.basic.PropertiesEvent(int[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Builds a new event with characteristic array as a paramenter.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt status} -- characteristic array of the event.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{clone()}
\hypertarget{jmarkov.basic.PropertiesEvent.clone()}{\membername{clone}}
{\tt protected native java.lang.Object\ {\bf clone}(  ) throws java.lang.CloneNotSupportedException
\label{jmarkov.basic.PropertiesEvent.clone()}}%end signature
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\index{compareTo(Event)}
\hypertarget{jmarkov.basic.PropertiesEvent.compareTo(jmarkov.basic.Event)}{\membername{compareTo}}
{\tt public int\ {\bf compareTo}( {\tt Event} {\bf ev} )
\label{jmarkov.basic.PropertiesEvent.compareTo(jmarkov.basic.Event)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.Event}{Event}{\small \refdefined{jmarkov.basic.Event}} }

Returns positive if this Event has a higher number then the given event.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Comparable.compareTo(T)}{java.lang.Comparable.compareTo(Object)}} {\small 
\refdefined{java.lang.Comparable.compareTo(T)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\index{compareTo(PropertiesEvent)}
\hypertarget{jmarkov.basic.PropertiesEvent.compareTo(jmarkov.basic.PropertiesEvent)}{\membername{compareTo}}
{\tt public final int\ {\bf compareTo}( {\tt PropertiesEvent} {\bf e1} )
\label{jmarkov.basic.PropertiesEvent.compareTo(jmarkov.basic.PropertiesEvent)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Compares the properties in order.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt e1} -- The PropertiesEvent to compare to.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
+1, 0 or -1, according to whether this states dominates e1. 
}%end item
\end{itemize}
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\index{equals(PropertiesEvent)}
\hypertarget{jmarkov.basic.PropertiesEvent.equals(jmarkov.basic.PropertiesEvent)}{\membername{equals}}
{\tt public final boolean\ {\bf equals}( {\tt PropertiesEvent} {\bf e} )
\label{jmarkov.basic.PropertiesEvent.equals(jmarkov.basic.PropertiesEvent)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt e} -- teh PropertiesEvent to compare To}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
true if Events are equal 
}%end item
\end{itemize}
}%end item
\divideents{getNumProps}
\item{\vskip -1.9ex 
\index{getNumProps()}
\hypertarget{jmarkov.basic.PropertiesEvent.getNumProps()}{\membername{getNumProps}}
{\tt public int\ {\bf getNumProps}(  )
\label{jmarkov.basic.PropertiesEvent.getNumProps()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of properties in the array that characterize this element.
}
\item{{\bf Returns} -- 
The number of properties. 
}%end item
\end{itemize}
}%end item
\divideents{getProperties}
\item{\vskip -1.9ex 
\index{getProperties()}
\hypertarget{jmarkov.basic.PropertiesEvent.getProperties()}{\membername{getProperties}}
{\tt public final int\lbrack \rbrack \ {\bf getProperties}(  )
\label{jmarkov.basic.PropertiesEvent.getProperties()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the array of properties.
}
\item{{\bf Returns} -- 
Returns the properties array. 
}%end item
\end{itemize}
}%end item
\divideents{getProperty}
\item{\vskip -1.9ex 
\index{getProperty(int)}
\hypertarget{jmarkov.basic.PropertiesEvent.getProperty(int)}{\membername{getProperty}}
{\tt public int\ {\bf getProperty}( {\tt int} {\bf index} )
\label{jmarkov.basic.PropertiesEvent.getProperty(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the value of this property.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the property at the given index 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.PropertiesEvent.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.PropertiesEvent.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.Event}{Event}{\small \refdefined{jmarkov.basic.Event}} }

If this function is not overriden by the user it returns the Event number. The user should override to give a short label description of the Event. It is highly recommended that the user overrides it to give a more descriptive label to be used when reporting the occurrance rates of the events.
}
\item{{\bf Returns} -- 
A short string description of the Event. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.Event.description()}{Event.description()}} {\small 
\refdefined{jmarkov.basic.Event.description()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setProperty}
\item{\vskip -1.9ex 
\index{setProperty(int, int)}
\hypertarget{jmarkov.basic.PropertiesEvent.setProperty(int, int)}{\membername{setProperty}}
{\tt protected void\ {\bf setProperty}( {\tt int} {\bf index},
{\tt int} {\bf value} )
\label{jmarkov.basic.PropertiesEvent.setProperty(int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the value of the property at the given index
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} -- }
   \item{
\sld
{\tt value} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.basic.Event} \textnormal{\small\refdefined{jmarkov.basic.Event}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public int {\bf compareTo}( {\tt Event} {\bf ev} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf equals}( {\tt java.lang.Object} {\bf o} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getIndex}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public EventsSet {\bf getSet}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{PropertiesState}
\subsection{\label{jmarkov.basic.PropertiesState}\index{PropertiesState}{\bf {\it Class} PropertiesState}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.PropertiesState}{}\vskip .1in 
The states are characterized by an array of integer-valued properties, whose meaning will change from implementation to implementation. The class must be extended.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class PropertiesState
\\ {\bf extends} jmarkov.basic.State
\refdefined{jmarkov.basic.State}\\ {\bf implements} 
PropertiesElement}}}
\subsubsection{Version}{1.0a}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.basic.PropertiesState.prop}{{\bf prop}} This array contains the properties that characterize the state.\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.PropertiesState(int)}{{\bf PropertiesState(int)}} Constructs a State charcterized by K properties.\\
\hyperlink{jmarkov.basic.PropertiesState(int[])}{{\bf PropertiesState(int\lbrack \rbrack )}} This creates a PropertiesState with the given array.\\
\hyperlink{jmarkov.basic.PropertiesState(int[], boolean)}{{\bf PropertiesState(int\lbrack \rbrack , boolean)}} This creates a PropertiesState with the given array.\\
\hyperlink{jmarkov.basic.PropertiesState(jmarkov.basic.PropertiesState)}{{\bf PropertiesState(PropertiesState)}} Constructs a new State by cloning the given State.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.PropertiesState.clone()}{{\bf clone()}} \\
\hyperlink{jmarkov.basic.PropertiesState.compareTo(jmarkov.basic.PropertiesState)}{{\bf compareTo(PropertiesState)}} Compares according to the internal properties in lexicographic order.\\
\hyperlink{jmarkov.basic.PropertiesState.compareTo(jmarkov.basic.State)}{{\bf compareTo(State)}} \\
\hyperlink{jmarkov.basic.PropertiesState.computeMOPs(jmarkov.MarkovProcess)}{{\bf computeMOPs(MarkovProcess)}} By default it computes the long run average for each property.\\
\hyperlink{jmarkov.basic.PropertiesState.getNumProps()}{{\bf getNumProps()}} \\
\hyperlink{jmarkov.basic.PropertiesState.getProperties()}{{\bf getProperties()}} Crates a copy of the properties array.\\
\hyperlink{jmarkov.basic.PropertiesState.getProperty(int)}{{\bf getProperty(int)}} \\
\hyperlink{jmarkov.basic.PropertiesState.isConsistent()}{{\bf isConsistent()}} It is strongly recommended that the user implements this method.\\
\hyperlink{jmarkov.basic.PropertiesState.label()}{{\bf label()}} Returns a string representation of this state in vector form.\\
\hyperlink{jmarkov.basic.PropertiesState.setProperty(int, int)}{{\bf setProperty(int, int)}} Sets the value of the property at the given index\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{prop}
\label{jmarkov.basic.PropertiesState.prop}\hypertarget{jmarkov.basic.PropertiesState.prop}{protected final int {\bf prop}}
\begin{itemize}
\item{\vskip -.9ex 
This array contains the properties that characterize the state.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{PropertiesState(int)}
\hypertarget{jmarkov.basic.PropertiesState(int)}{\membername{PropertiesState}}
{\tt public\ {\bf PropertiesState}( {\tt int} {\bf K} )
\label{jmarkov.basic.PropertiesState(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs a State charcterized by K properties. The original values of all the properties is 0.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt K} -- Number of Properties}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{PropertiesState}
\item{\vskip -1.9ex 
\index{PropertiesState(int\lbrack \rbrack )}
\hypertarget{jmarkov.basic.PropertiesState(int[])}{\membername{PropertiesState}}
{\tt public\ {\bf PropertiesState}( {\tt int\lbrack \rbrack } {\bf properties} )
\label{jmarkov.basic.PropertiesState(int[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This creates a PropertiesState with the given array. WARNNING: the array is NOT internally copied, so it is assumed then NO changes are made to this array after it is given to the constructor.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt properties} -- An integer valued array with the proerties that characterize this state.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{PropertiesState}
\item{\vskip -1.9ex 
\index{PropertiesState(int\lbrack \rbrack , boolean)}
\hypertarget{jmarkov.basic.PropertiesState(int[], boolean)}{\membername{PropertiesState}}
{\tt public\ {\bf PropertiesState}( {\tt int\lbrack \rbrack } {\bf properties},
{\tt boolean} {\bf deepCopy} )
\label{jmarkov.basic.PropertiesState(int[], boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This creates a PropertiesState with the given array.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt properties} -- An integer valued array with the proerties that characterize this state.}
   \item{
\sld
{\tt deepCopy} -- true if the constructor should make a deep copy of the array. This causes some overhead but increased security.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{PropertiesState}
\item{\vskip -1.9ex 
\index{PropertiesState(PropertiesState)}
\hypertarget{jmarkov.basic.PropertiesState(jmarkov.basic.PropertiesState)}{\membername{PropertiesState}}
{\tt public\ {\bf PropertiesState}( {\tt PropertiesState} {\bf s} )
\label{jmarkov.basic.PropertiesState(jmarkov.basic.PropertiesState)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs a new State by cloning the given State. If you are extending PropertiesState you may want to include a code like:{\tt\small
\mbox{}\newline \phantom{ }public\phantom{ }YourState\phantom{ }clone()\phantom{ }\{}\mbox{}\newline
{\tt\small \phantom{ }\phantom{ }\phantom{ }\phantom{ }\phantom{ }return\phantom{ }new\phantom{ }PropertiesState(this);}\mbox{}\newline
{\tt\small \phantom{ }\}}\mbox{}\newline
{\tt\small \phantom{ }}

}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- A given State.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{clone()}
\hypertarget{jmarkov.basic.PropertiesState.clone()}{\membername{clone}}
{\tt public PropertiesElement\ {\bf clone}(  )
\label{jmarkov.basic.PropertiesState.clone()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.PropertiesElement.clone()}{PropertiesElement.clone()}} {\small 
\refdefined{jmarkov.basic.PropertiesElement.clone()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\index{compareTo(PropertiesState)}
\hypertarget{jmarkov.basic.PropertiesState.compareTo(jmarkov.basic.PropertiesState)}{\membername{compareTo}}
{\tt public final int\ {\bf compareTo}( {\tt PropertiesState} {\bf ps} )
\label{jmarkov.basic.PropertiesState.compareTo(jmarkov.basic.PropertiesState)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Compares according to the internal properties in lexicographic order.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt ps} -- The state to compare to}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
+1,-1,0 depending on relative ordering. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.compareTo(jmarkov.basic.State)}{State.compareTo(State)}} {\small 
\refdefined{jmarkov.basic.State.compareTo(jmarkov.basic.State)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\index{compareTo(State)}
\hypertarget{jmarkov.basic.PropertiesState.compareTo(jmarkov.basic.State)}{\membername{compareTo}}
{\tt public abstract int\ {\bf compareTo}( {\tt State} {\bf j} )
\label{jmarkov.basic.PropertiesState.compareTo(jmarkov.basic.State)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.State}{State}{\small \refdefined{jmarkov.basic.State}} }

The method compareTo should be implemented in order to establish a total ordering among the States.
}
\item{{\bf Returns} -- 
A positive integer if this is grater then j, negative if this is less then j and 0 if this == j. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Comparable.compareTo(T)}{java.lang.Comparable.compareTo(Object)}} {\small 
\refdefined{java.lang.Comparable.compareTo(T)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{computeMOPs}
\item{\vskip -1.9ex 
\index{computeMOPs(MarkovProcess)}
\hypertarget{jmarkov.basic.PropertiesState.computeMOPs(jmarkov.MarkovProcess)}{\membername{computeMOPs}}
{\tt public void\ {\bf computeMOPs}( {\tt jmarkov.MarkovProcess} {\bf mp} )
\label{jmarkov.basic.PropertiesState.computeMOPs(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

By default it computes the long run average for each property. the user should override this method in order to compute more meaningful measures of performance.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.computeMOPs(jmarkov.MarkovProcess)}{State.computeMOPs(jmarkov.MarkovProcess)}} {\small 
\refdefined{jmarkov.basic.State.computeMOPs(jmarkov.MarkovProcess)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getNumProps}
\item{\vskip -1.9ex 
\index{getNumProps()}
\hypertarget{jmarkov.basic.PropertiesState.getNumProps()}{\membername{getNumProps}}
{\tt public int\ {\bf getNumProps}(  )
\label{jmarkov.basic.PropertiesState.getNumProps()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.PropertiesElement.getNumProps()}{PropertiesElement.getNumProps()}} {\small 
\refdefined{jmarkov.basic.PropertiesElement.getNumProps()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getProperties}
\item{\vskip -1.9ex 
\index{getProperties()}
\hypertarget{jmarkov.basic.PropertiesState.getProperties()}{\membername{getProperties}}
{\tt public final int\lbrack \rbrack \ {\bf getProperties}(  )
\label{jmarkov.basic.PropertiesState.getProperties()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Crates a copy of the properties array.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.PropertiesElement.getProperties()}{PropertiesElement.getProperties()}} {\small 
\refdefined{jmarkov.basic.PropertiesElement.getProperties()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getProperty}
\item{\vskip -1.9ex 
\index{getProperty(int)}
\hypertarget{jmarkov.basic.PropertiesState.getProperty(int)}{\membername{getProperty}}
{\tt public int\ {\bf getProperty}( {\tt int} {\bf index} )
\label{jmarkov.basic.PropertiesState.getProperty(int)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.PropertiesElement.getProperty(int)}{PropertiesElement.getProperty(int)}} {\small 
\refdefined{jmarkov.basic.PropertiesElement.getProperty(int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{isConsistent}
\item{\vskip -1.9ex 
\index{isConsistent()}
\hypertarget{jmarkov.basic.PropertiesState.isConsistent()}{\membername{isConsistent}}
{\tt public boolean\ {\bf isConsistent}(  )
\label{jmarkov.basic.PropertiesState.isConsistent()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

It is strongly recommended that the user implements this method. If left unimplemented this method returns true.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.isConsistent()}{State.isConsistent()}} {\small 
\refdefined{jmarkov.basic.State.isConsistent()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.PropertiesState.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.PropertiesState.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a string representation of this state in vector form. The String will be in the form (p1,p2,..,pK). A Class implementing this Class could give a more meaningful description.
}
\end{itemize}
}%end item
\divideents{setProperty}
\item{\vskip -1.9ex 
\index{setProperty(int, int)}
\hypertarget{jmarkov.basic.PropertiesState.setProperty(int, int)}{\membername{setProperty}}
{\tt protected void\ {\bf setProperty}( {\tt int} {\bf index},
{\tt int} {\bf value} )
\label{jmarkov.basic.PropertiesState.setProperty(int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the value of the property at the given index
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} -- }
   \item{
\sld
{\tt value} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.basic.State} \textnormal{\small\refdefined{jmarkov.basic.State}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract int {\bf compareTo}( {\tt State} {\bf j} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract void {\bf computeMOPs}( {\tt jmarkov.MarkovProcess} {\bf model} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf equals}( {\tt java.lang.Object} {\bf o} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getIndex}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOP}( {\tt int} {\bf index} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final double {\bf getMOP}( {\tt java.lang.String} {\bf mopName},
{\tt jmarkov.MarkovProcess} {\bf model} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract boolean {\bf isConsistent}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf setMOP}( {\tt int} {\bf index},
{\tt double} {\bf value} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf setMOP}( {\tt jmarkov.MarkovProcess} {\bf model},
{\tt java.lang.String} {\bf mopName},
{\tt double} {\bf value} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{Solution}
\subsection{\label{jmarkov.basic.Solution}\index{Solution}{\bf {\it Class} Solution}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.Solution}{}\vskip .1in 
This class represents the joint information of a value function and a policy which summarizes the solution to a problem.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class Solution
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Solution(jmarkov.basic.ValueFunction, jmarkov.basic.Policy)}{{\bf Solution(ValueFunction, Policy)}} Builds a solution given a value funtcion and a policy\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Solution.getPolicy()}{{\bf getPolicy()}} Returns the Policy.\\
\hyperlink{jmarkov.basic.Solution.getValueFunction()}{{\bf getValueFunction()}} Returns the valueFunction.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{Solution(ValueFunction, Policy)}
\hypertarget{jmarkov.basic.Solution(jmarkov.basic.ValueFunction, jmarkov.basic.Policy)}{\membername{Solution}}
{\tt public\ {\bf Solution}( {\tt ValueFunction} {\bf valueFunction},
{\tt Policy} {\bf policy} )
\label{jmarkov.basic.Solution(jmarkov.basic.ValueFunction, jmarkov.basic.Policy)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Builds a solution given a value funtcion and a policy
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt valueFunction} -- value function}
   \item{
\sld
{\tt policy} -- policy}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getPolicy()}
\hypertarget{jmarkov.basic.Solution.getPolicy()}{\membername{getPolicy}}
{\tt public Policy\ {\bf getPolicy}(  )
\label{jmarkov.basic.Solution.getPolicy()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the Policy.
}
\item{{\bf Returns} -- 
Returns the policy. 
}%end item
\end{itemize}
}%end item
\divideents{getValueFunction}
\item{\vskip -1.9ex 
\index{getValueFunction()}
\hypertarget{jmarkov.basic.Solution.getValueFunction()}{\membername{getValueFunction}}
{\tt public ValueFunction\ {\bf getValueFunction}(  )
\label{jmarkov.basic.Solution.getValueFunction()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the valueFunction.
}
\item{{\bf Returns} -- 
Returns the valueFunction. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{State}
\subsection{\label{jmarkov.basic.State}\index{State}{\bf {\it Class} State}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.State}{}\vskip .1in 
The Class State represent a state in a MarkovProcess or MDP. The user of the class should estiblish her own coding convention AND code the compareTo method. If the State can be represented with a vector of integers describing its properties, then it might be easier to implement PropertiesState rather than State.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.basic.PropertiesState}{PropertiesState}} {\small 
\refdefined{jmarkov.basic.PropertiesState}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class State
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
java.lang.Comparable, JMarkovElement}}}
\subsubsection{Version}{1.0a}
\subsubsection{All known subclasses}{GeomState\small{\refdefined{jmarkov.GeomState}}, GeomRelState\small{\refdefined{jmarkov.GeomRelState}}, StateEvent\small{\refdefined{jmarkov.basic.StateEvent}}, StateC\small{\refdefined{jmarkov.basic.StateC}}, PropertiesState\small{\refdefined{jmarkov.basic.PropertiesState}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.State()}{{\bf State()}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.State.compareTo(jmarkov.basic.State)}{{\bf compareTo(State)}} The method compareTo should be implemented in order to establish a total ordering among the States.\\
\hyperlink{jmarkov.basic.State.computeMOPs(jmarkov.MarkovProcess)}{{\bf computeMOPs(MarkovProcess)}} This method should be implemented in order to compute all the measures of performance MOPs.\\
\hyperlink{jmarkov.basic.State.description()}{{\bf description()}} Returns a String that describes the State.\\
\hyperlink{jmarkov.basic.State.equals(java.lang.Object)}{{\bf equals(Object)}} If Object is not State it returns false.\\
\hyperlink{jmarkov.basic.State.getIndex()}{{\bf getIndex()}} \\
\hyperlink{jmarkov.basic.State.getMOP(int)}{{\bf getMOP(int)}} Gets the value of this MOP.\\
\hyperlink{jmarkov.basic.State.getMOP(java.lang.String, jmarkov.MarkovProcess)}{{\bf getMOP(String, MarkovProcess)}} Gets the value of the MOP with this name, by calling {\tt\small getMOP(int){\tt\small }}\\
\hyperlink{jmarkov.basic.State.isConsistent()}{{\bf isConsistent()}} This method is called when a state is added to a set, if assertions are enabled.\\
\hyperlink{jmarkov.basic.State.label()}{{\bf label()}} Returns a (hopefully short) label that descibes the State.\\
\hyperlink{jmarkov.basic.State.setMOP(int, double)}{{\bf setMOP(int, double)}} Sets the value of this MOP.\\
\hyperlink{jmarkov.basic.State.setMOP(jmarkov.MarkovProcess, java.lang.String, double)}{{\bf setMOP(MarkovProcess, String, double)}} Sets the value of the MOP with this name.\\
\hyperlink{jmarkov.basic.State.toString()}{{\bf toString()}} Returns the label.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{State()}
\hypertarget{jmarkov.basic.State()}{\membername{State}}
{\tt public\ {\bf State}(  )
\label{jmarkov.basic.State()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{compareTo(State)}
\hypertarget{jmarkov.basic.State.compareTo(jmarkov.basic.State)}{\membername{compareTo}}
{\tt public abstract int\ {\bf compareTo}( {\tt State} {\bf j} )
\label{jmarkov.basic.State.compareTo(jmarkov.basic.State)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The method compareTo should be implemented in order to establish a total ordering among the States.
}
\item{{\bf Returns} -- 
A positive integer if this is grater then j, negative if this is less then j and 0 if this == j. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Comparable.compareTo(T)}{java.lang.Comparable.compareTo(Object)}} {\small 
\refdefined{java.lang.Comparable.compareTo(T)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{computeMOPs}
\item{\vskip -1.9ex 
\index{computeMOPs(MarkovProcess)}
\hypertarget{jmarkov.basic.State.computeMOPs(jmarkov.MarkovProcess)}{\membername{computeMOPs}}
{\tt public abstract void\ {\bf computeMOPs}( {\tt jmarkov.MarkovProcess} {\bf model} )
\label{jmarkov.basic.State.computeMOPs(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method should be implemented in order to compute all the measures of performance MOPs. Inside it you should issue commands like {\tt\small setMop("Utilization server 1", x, model);}. * For large models override this method as empty and rather override getMOP(int). Do NOT mix both approaches!!
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt model} -- The model being solved.}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.getMOP(int)}{State.getMOP(int)}} {\small 
\refdefined{jmarkov.basic.State.getMOP(int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.basic.State.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jmarkov.basic.State.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a String that describes the State. By default it is an empty string, but you should implement it in order to get a meaningful description.
}
\item{{\bf Returns} -- 
A String description of the State 
}%end item
\end{itemize}
}%end item
\divideents{equals}
\item{\vskip -1.9ex 
\index{equals(Object)}
\hypertarget{jmarkov.basic.State.equals(java.lang.Object)}{\membername{equals}}
{\tt public final boolean\ {\bf equals}( {\tt java.lang.Object} {\bf o} )
\label{jmarkov.basic.State.equals(java.lang.Object)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

If Object is not State it returns false. Otherwise equals := (compareTo(o)==0)
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Object.equals(java.lang.Object)}{java.lang.Object.equals(Object)}} {\small 
\refdefined{java.lang.Object.equals(java.lang.Object)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getIndex}
\item{\vskip -1.9ex 
\index{getIndex()}
\hypertarget{jmarkov.basic.State.getIndex()}{\membername{getIndex}}
{\tt public final int\ {\bf getIndex}(  )
\label{jmarkov.basic.State.getIndex()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
The index in the State set 
}%end item
\end{itemize}
}%end item
\divideents{getMOP}
\item{\vskip -1.9ex 
\index{getMOP(int)}
\hypertarget{jmarkov.basic.State.getMOP(int)}{\membername{getMOP}}
{\tt public double\ {\bf getMOP}( {\tt int} {\bf index} )
\label{jmarkov.basic.State.getMOP(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the value of this MOP. The value should had been set via the setMOP method. Alternatively, for better performance define the MOP Names when implementing the MarkovProcess class and override this method. To define the names in the constructor call the method setMOPs(String\lbrack \rbrack ). The index is the same as the one used in the array in the aforementioned method.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The value of this MOP. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.setMOPs(java.lang.String[])}{jmarkov.MarkovProcess.setMOPs(java.lang.String\lbrack \rbrack )}} {\small 
\refdefined{jmarkov.MarkovProcess.setMOPs(java.lang.String[])}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMOP}
\item{\vskip -1.9ex 
\index{getMOP(String, MarkovProcess)}
\hypertarget{jmarkov.basic.State.getMOP(java.lang.String, jmarkov.MarkovProcess)}{\membername{getMOP}}
{\tt public final double\ {\bf getMOP}( {\tt java.lang.String} {\bf mopName},
{\tt jmarkov.MarkovProcess} {\bf model} )
\label{jmarkov.basic.State.getMOP(java.lang.String, jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the value of the MOP with this name, by calling {\tt\small getMOP(int){\tt\small }}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mopName} -- The name of the MOP.}
   \item{
\sld
{\tt model} -- Model being solved.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
current MOP value 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.getMOP(int)}{State.getMOP(int)}} {\small 
\refdefined{jmarkov.basic.State.getMOP(int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{isConsistent}
\item{\vskip -1.9ex 
\index{isConsistent()}
\hypertarget{jmarkov.basic.State.isConsistent()}{\membername{isConsistent}}
{\tt public abstract boolean\ {\bf isConsistent}(  )
\label{jmarkov.basic.State.isConsistent()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method is called when a state is added to a set, if assertions are enabled. You should include code that checks the consistency of the paprameters entered. It is very helpful during depelopment. Once assertions are disabled, this will not reduce the speed of your program.
}
\item{{\bf Returns} -- 
true if the state is consistent. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.State.label()}{\membername{label}}
{\tt public abstract java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.State.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a (hopefully short) label that descibes the State. It is used by all print methods and in the GUI.
}
\item{{\bf Returns} -- 
A shor String label that identifies the state. 
}%end item
\end{itemize}
}%end item
\divideents{setMOP}
\item{\vskip -1.9ex 
\index{setMOP(int, double)}
\hypertarget{jmarkov.basic.State.setMOP(int, double)}{\membername{setMOP}}
{\tt public final int\ {\bf setMOP}( {\tt int} {\bf index},
{\tt double} {\bf value} )
\label{jmarkov.basic.State.setMOP(int, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the value of this MOP.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt index} -- }
   \item{
\sld
{\tt value} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the index where it was added. 
}%end item
\end{itemize}
}%end item
\divideents{setMOP}
\item{\vskip -1.9ex 
\index{setMOP(MarkovProcess, String, double)}
\hypertarget{jmarkov.basic.State.setMOP(jmarkov.MarkovProcess, java.lang.String, double)}{\membername{setMOP}}
{\tt public int\ {\bf setMOP}( {\tt jmarkov.MarkovProcess} {\bf model},
{\tt java.lang.String} {\bf mopName},
{\tt double} {\bf value} )
\label{jmarkov.basic.State.setMOP(jmarkov.MarkovProcess, java.lang.String, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the value of the MOP with this name. If no MOP with this name exists a new one is declared.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mopName} -- }
   \item{
\sld
{\tt model} -- The model being solved.}
   \item{
\sld
{\tt value} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the index where it was added. 
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.basic.State.toString()}{\membername{toString}}
{\tt public final java.lang.String\ {\bf toString}(  )
\label{jmarkov.basic.State.toString()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the label.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.label()}{State.label()}} {\small 
\refdefined{jmarkov.basic.State.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{StateC}
\subsection{\label{jmarkov.basic.StateC}\index{StateC}{\bf {\it Class} StateC}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.StateC}{}\vskip .1in 
State to model shortest path problems.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class StateC
\\ {\bf extends} jmarkov.basic.State
\refdefined{jmarkov.basic.State}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.StateC()}{{\bf StateC()}} Default constructor\\
\hyperlink{jmarkov.basic.StateC(boolean)}{{\bf StateC(boolean)}} General constructor.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.StateC.isTerminal()}{{\bf isTerminal()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{StateC()}
\hypertarget{jmarkov.basic.StateC()}{\membername{StateC}}
{\tt public\ {\bf StateC}(  )
\label{jmarkov.basic.StateC()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default constructor
}
\end{itemize}
}%end item
\divideents{StateC}
\item{\vskip -1.9ex 
\index{StateC(boolean)}
\hypertarget{jmarkov.basic.StateC(boolean)}{\membername{StateC}}
{\tt public\ {\bf StateC}( {\tt boolean} {\bf t} )
\label{jmarkov.basic.StateC(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

General constructor.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt t} -- Whether it is a terminal state or not.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{isTerminal()}
\hypertarget{jmarkov.basic.StateC.isTerminal()}{\membername{isTerminal}}
{\tt public final boolean\ {\bf isTerminal}(  )
\label{jmarkov.basic.StateC.isTerminal()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns true if this a terminal state. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.basic.State} \textnormal{\small\refdefined{jmarkov.basic.State}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract int {\bf compareTo}( {\tt State} {\bf j} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract void {\bf computeMOPs}( {\tt jmarkov.MarkovProcess} {\bf model} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf equals}( {\tt java.lang.Object} {\bf o} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getIndex}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOP}( {\tt int} {\bf index} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final double {\bf getMOP}( {\tt java.lang.String} {\bf mopName},
{\tt jmarkov.MarkovProcess} {\bf model} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract boolean {\bf isConsistent}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf setMOP}( {\tt int} {\bf index},
{\tt double} {\bf value} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf setMOP}( {\tt jmarkov.MarkovProcess} {\bf model},
{\tt java.lang.String} {\bf mopName},
{\tt double} {\bf value} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{StateEvent}
\subsection{\label{jmarkov.basic.StateEvent}\index{StateEvent}{\bf {\it Class} StateEvent}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.StateEvent}{}\vskip .1in 
This class represents a state compounded of a state and an event. It is used for state expansion for the problems where actions can depend on the event that happens in a transition. Only future events that can occur from the state state should be allowed as events event.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class StateEvent
\\ {\bf extends} jmarkov.basic.State
\refdefined{jmarkov.basic.State}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.StateEvent(S, E)}{{\bf StateEvent(S, E)}} Builds a new state with the event information\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.StateEvent.compareTo(jmarkov.basic.State)}{{\bf compareTo(State)}} \\
\hyperlink{jmarkov.basic.StateEvent.computeMOPs(jmarkov.MarkovProcess)}{{\bf computeMOPs(MarkovProcess)}} \\
\hyperlink{jmarkov.basic.StateEvent.getEvent()}{{\bf getEvent()}} Gets the event.\\
\hyperlink{jmarkov.basic.StateEvent.getState()}{{\bf getState()}} Gets the state.\\
\hyperlink{jmarkov.basic.StateEvent.isConsistent()}{{\bf isConsistent()}} \\
\hyperlink{jmarkov.basic.StateEvent.label()}{{\bf label()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{StateEvent(S, E)}
\hypertarget{jmarkov.basic.StateEvent(S, E)}{\membername{StateEvent}}
{\tt public\ {\bf StateEvent}( {\tt State} {\bf state},
{\tt Event} {\bf event} )
\label{jmarkov.basic.StateEvent(S, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Builds a new state with the event information
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt state} -- state}
   \item{
\sld
{\tt event} -- event}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{compareTo(State)}
\hypertarget{jmarkov.basic.StateEvent.compareTo(jmarkov.basic.State)}{\membername{compareTo}}
{\tt public abstract int\ {\bf compareTo}( {\tt State} {\bf j} )
\label{jmarkov.basic.StateEvent.compareTo(jmarkov.basic.State)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.State}{State}{\small \refdefined{jmarkov.basic.State}} }

The method compareTo should be implemented in order to establish a total ordering among the States.
}
\item{{\bf Returns} -- 
A positive integer if this is grater then j, negative if this is less then j and 0 if this == j. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Comparable.compareTo(T)}{java.lang.Comparable.compareTo(Object)}} {\small 
\refdefined{java.lang.Comparable.compareTo(T)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{computeMOPs}
\item{\vskip -1.9ex 
\index{computeMOPs(MarkovProcess)}
\hypertarget{jmarkov.basic.StateEvent.computeMOPs(jmarkov.MarkovProcess)}{\membername{computeMOPs}}
{\tt public void\ {\bf computeMOPs}( {\tt jmarkov.MarkovProcess} {\bf model} )
\label{jmarkov.basic.StateEvent.computeMOPs(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.computeMOPs(jmarkov.MarkovProcess)}{State.computeMOPs(jmarkov.MarkovProcess)}} {\small 
\refdefined{jmarkov.basic.State.computeMOPs(jmarkov.MarkovProcess)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getEvent}
\item{\vskip -1.9ex 
\index{getEvent()}
\hypertarget{jmarkov.basic.StateEvent.getEvent()}{\membername{getEvent}}
{\tt public Event\ {\bf getEvent}(  )
\label{jmarkov.basic.StateEvent.getEvent()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the event.
}
\item{{\bf Returns} -- 
the original event from the state 
}%end item
\end{itemize}
}%end item
\divideents{getState}
\item{\vskip -1.9ex 
\index{getState()}
\hypertarget{jmarkov.basic.StateEvent.getState()}{\membername{getState}}
{\tt public State\ {\bf getState}(  )
\label{jmarkov.basic.StateEvent.getState()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the state.
}
\item{{\bf Returns} -- 
the original state from the state 
}%end item
\end{itemize}
}%end item
\divideents{isConsistent}
\item{\vskip -1.9ex 
\index{isConsistent()}
\hypertarget{jmarkov.basic.StateEvent.isConsistent()}{\membername{isConsistent}}
{\tt public boolean\ {\bf isConsistent}(  )
\label{jmarkov.basic.StateEvent.isConsistent()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.State.isConsistent()}{State.isConsistent()}} {\small 
\refdefined{jmarkov.basic.State.isConsistent()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.StateEvent.label()}{\membername{label}}
{\tt public abstract java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.StateEvent.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.State}{State}{\small \refdefined{jmarkov.basic.State}} }

Returns a (hopefully short) label that descibes the State. It is used by all print methods and in the GUI.
}
\item{{\bf Returns} -- 
A shor String label that identifies the state. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.basic.State} \textnormal{\small\refdefined{jmarkov.basic.State}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract int {\bf compareTo}( {\tt State} {\bf j} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract void {\bf computeMOPs}( {\tt jmarkov.MarkovProcess} {\bf model} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf equals}( {\tt java.lang.Object} {\bf o} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getIndex}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMOP}( {\tt int} {\bf index} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final double {\bf getMOP}( {\tt java.lang.String} {\bf mopName},
{\tt jmarkov.MarkovProcess} {\bf model} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract boolean {\bf isConsistent}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf setMOP}( {\tt int} {\bf index},
{\tt double} {\bf value} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf setMOP}( {\tt jmarkov.MarkovProcess} {\bf model},
{\tt java.lang.String} {\bf mopName},
{\tt double} {\bf value} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{StatesSet}
\subsection{\label{jmarkov.basic.StatesSet}\index{StatesSet}{\bf {\it Class} StatesSet}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.StatesSet}{}\vskip .1in 
This class represent a set of States. It is used as a convinence to build multiple destinations in the method {\tt\small reachable}.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.jmdp.DTMDP.reachable(S, A)}{jmarkov.jmdp.DTMDP.reachable(State,\allowbreak Action)}} {\small 
\refdefined{jmarkov.jmdp.DTMDP.reachable(S, A)}}%end
} 
\item{ {\tt \hyperlink{jmarkov.jmdp.CTMDP.reachable(S, A)}{jmarkov.jmdp.CTMDP.reachable(State,\allowbreak Action)}} {\small 
\refdefined{jmarkov.jmdp.CTMDP.reachable(S, A)}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class StatesSet
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
States}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.StatesSet()}{{\bf StatesSet()}} Creates an empty set of States;\\
\hyperlink{jmarkov.basic.StatesSet(java.lang.Iterable)}{{\bf StatesSet(Iterable)}} Creates a set of objects S from the given States.\\
\hyperlink{jmarkov.basic.StatesSet(S)}{{\bf StatesSet(S)}} Creates set of States with only this State;\\
\hyperlink{jmarkov.basic.StatesSet(S[])}{{\bf StatesSet(S\lbrack \rbrack )}} Creates a set of objects S from a given set of States.\\
\hyperlink{jmarkov.basic.StatesSet(jmarkov.basic.States)}{{\bf StatesSet(States)}} Creates a set of objects S from the given States .\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.StatesSet.add(java.lang.Iterable)}{{\bf add(Iterable)}} Adds the States in the iterator to the set.\\
\hyperlink{jmarkov.basic.StatesSet.add(S)}{{\bf add(S)}} Adds the State s to the set.\\
\hyperlink{jmarkov.basic.StatesSet.add(jmarkov.basic.States)}{{\bf add(States)}} Adds the States in the iterator to the set.\\
\hyperlink{jmarkov.basic.StatesSet.contains(S)}{{\bf contains(S)}} Returns true if the set contains this State.\\
\hyperlink{jmarkov.basic.StatesSet.get(S)}{{\bf get(S)}} Returns the element that is equal (according to equals() ) to the given element.\\
\hyperlink{jmarkov.basic.StatesSet.isClosed()}{{\bf isClosed()}} \\
\hyperlink{jmarkov.basic.StatesSet.iterator()}{{\bf iterator()}} This method returns a safe way to walk through the states in a particular set.\\
\hyperlink{jmarkov.basic.StatesSet.numerateStates()}{{\bf numerateStates()}} This method numerates all states and returns the number of states found.\\
\hyperlink{jmarkov.basic.StatesSet.remove(S)}{{\bf remove(S)}} Removes an object from the set.\\
\hyperlink{jmarkov.basic.StatesSet.size()}{{\bf size()}} \\
\hyperlink{jmarkov.basic.StatesSet.toStateArray()}{{\bf toStateArray()}} Returns an array with the States in the set.\\
\hyperlink{jmarkov.basic.StatesSet.toString()}{{\bf toString()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{StatesSet()}
\hypertarget{jmarkov.basic.StatesSet()}{\membername{StatesSet}}
{\tt public\ {\bf StatesSet}(  )
\label{jmarkov.basic.StatesSet()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates an empty set of States;
}
\end{itemize}
}%end item
\divideents{StatesSet}
\item{\vskip -1.9ex 
\index{StatesSet(Iterable)}
\hypertarget{jmarkov.basic.StatesSet(java.lang.Iterable)}{\membername{StatesSet}}
{\tt public\ {\bf StatesSet}( {\tt java.lang.Iterable} {\bf states} )
\label{jmarkov.basic.StatesSet(java.lang.Iterable)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a set of objects S from the given States.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt states} -- a set of States of type States.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{StatesSet}
\item{\vskip -1.9ex 
\index{StatesSet(S)}
\hypertarget{jmarkov.basic.StatesSet(S)}{\membername{StatesSet}}
{\tt public\ {\bf StatesSet}( {\tt State} {\bf s} )
\label{jmarkov.basic.StatesSet(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates set of States with only this State;
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- The state to include in the set.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{StatesSet}
\item{\vskip -1.9ex 
\index{StatesSet(S\lbrack \rbrack )}
\hypertarget{jmarkov.basic.StatesSet(S[])}{\membername{StatesSet}}
{\tt public\ {\bf StatesSet}( {\tt State\lbrack \rbrack } {\bf states} )
\label{jmarkov.basic.StatesSet(S[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a set of objects S from a given set of States.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt states} -- a set of States of type States.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{StatesSet}
\item{\vskip -1.9ex 
\index{StatesSet(States)}
\hypertarget{jmarkov.basic.StatesSet(jmarkov.basic.States)}{\membername{StatesSet}}
{\tt public\ {\bf StatesSet}( {\tt States} {\bf states} )
\label{jmarkov.basic.StatesSet(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a set of objects S from the given States .
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt states} -- a set of States of type States.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{add(Iterable)}
\hypertarget{jmarkov.basic.StatesSet.add(java.lang.Iterable)}{\membername{add}}
{\tt public boolean\ {\bf add}( {\tt java.lang.Iterable} {\bf states} )
\label{jmarkov.basic.StatesSet.add(java.lang.Iterable)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Adds the States in the iterator to the set.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt states} -- a set of States of type States.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
True if the set did not contain ANY of the elements. 
}%end item
\end{itemize}
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\index{add(S)}
\hypertarget{jmarkov.basic.StatesSet.add(S)}{\membername{add}}
{\tt public boolean\ {\bf add}( {\tt State} {\bf s} )
\label{jmarkov.basic.StatesSet.add(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Adds the State s to the set.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- The State to be added.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
True if the set did not already contained this event. 
}%end item
\end{itemize}
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\index{add(States)}
\hypertarget{jmarkov.basic.StatesSet.add(jmarkov.basic.States)}{\membername{add}}
{\tt public boolean\ {\bf add}( {\tt States} {\bf states} )
\label{jmarkov.basic.StatesSet.add(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Adds the States in the iterator to the set.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt states} -- a set of States of type States.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
True if the set did not contain ANY of the elements. 
}%end item
\end{itemize}
}%end item
\divideents{contains}
\item{\vskip -1.9ex 
\index{contains(S)}
\hypertarget{jmarkov.basic.StatesSet.contains(S)}{\membername{contains}}
{\tt public boolean\ {\bf contains}( {\tt State} {\bf s} )
\label{jmarkov.basic.StatesSet.contains(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns true if the set contains this State.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- A State}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
true if the state is contained in the set. 
}%end item
\end{itemize}
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\index{get(S)}
\hypertarget{jmarkov.basic.StatesSet.get(S)}{\membername{get}}
{\tt public State\ {\bf get}( {\tt State} {\bf state} )
\label{jmarkov.basic.StatesSet.get(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the element that is equal (according to equals() ) to the given element.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt state} -- The given state}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The state in the set, or null if it was not defined in the set. 
}%end item
\end{itemize}
}%end item
\divideents{isClosed}
\item{\vskip -1.9ex 
\index{isClosed()}
\hypertarget{jmarkov.basic.StatesSet.isClosed()}{\membername{isClosed}}
{\tt  boolean\ {\bf isClosed}(  )
\label{jmarkov.basic.StatesSet.isClosed()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.States}{States}{\small \refdefined{jmarkov.basic.States}} }

The set is closed if all elements have been added.
}
\item{{\bf Returns} -- 
true if the set is closed. 
}%end item
\end{itemize}
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\index{iterator()}
\hypertarget{jmarkov.basic.StatesSet.iterator()}{\membername{iterator}}
{\tt public final java.util.Iterator\ {\bf iterator}(  )
\label{jmarkov.basic.StatesSet.iterator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method returns a safe way to walk through the states in a particular set. Collections and their implementations (Set, List, and Map) have iterators defined by default.
}
\item{{\bf Returns} -- 
iterator over the states. 
}%end item
\end{itemize}
}%end item
\divideents{numerateStates}
\item{\vskip -1.9ex 
\index{numerateStates()}
\hypertarget{jmarkov.basic.StatesSet.numerateStates()}{\membername{numerateStates}}
{\tt public int\ {\bf numerateStates}(  )
\label{jmarkov.basic.StatesSet.numerateStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method numerates all states and returns the number of states found. Afther this method is called it is illegal to add more states to the set.
}
\item{{\bf Returns} -- 
The number of states. 
}%end item
\end{itemize}
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\index{remove(S)}
\hypertarget{jmarkov.basic.StatesSet.remove(S)}{\membername{remove}}
{\tt public boolean\ {\bf remove}( {\tt State} {\bf s} )
\label{jmarkov.basic.StatesSet.remove(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Removes an object from the set.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- The element to remove.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
If the remove was successful (i.e. the element was in the set). 
}%end item
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\index{size()}
\hypertarget{jmarkov.basic.StatesSet.size()}{\membername{size}}
{\tt  int\ {\bf size}(  )
\label{jmarkov.basic.StatesSet.size()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.States}{States}{\small \refdefined{jmarkov.basic.States}} }

Returns the number of elements.
}
\item{{\bf Returns} -- 
the number of State elements. 
}%end item
\end{itemize}
}%end item
\divideents{toStateArray}
\item{\vskip -1.9ex 
\index{toStateArray()}
\hypertarget{jmarkov.basic.StatesSet.toStateArray()}{\membername{toStateArray}}
{\tt public State\lbrack \rbrack \ {\bf toStateArray}(  )
\label{jmarkov.basic.StatesSet.toStateArray()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns an array with the States in the set.
}
\item{{\bf Returns} -- 
An array representation of the states. 
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.basic.StatesSet.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jmarkov.basic.StatesSet.toString()}}%end signature
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{Transition}
\subsection{\label{jmarkov.basic.Transition}\index{Transition}{\bf {\it Class} Transition}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.Transition}{}\vskip .1in 
This class represent a transition to a given state. It has an associated rate and state.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public final class Transition
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
JMarkovElement}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Transition(S, double)}{{\bf Transition(S, double)}} Basic constructor.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.Transition.description()}{{\bf description()}} \\
\hyperlink{jmarkov.basic.Transition.getRate()}{{\bf getRate()}} Returns the rate.\\
\hyperlink{jmarkov.basic.Transition.getState()}{{\bf getState()}} Returns the state.\\
\hyperlink{jmarkov.basic.Transition.label()}{{\bf label()}} \\
\hyperlink{jmarkov.basic.Transition.toString()}{{\bf toString()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{Transition(S, double)}
\hypertarget{jmarkov.basic.Transition(S, double)}{\membername{Transition}}
{\tt public\ {\bf Transition}( {\tt State} {\bf state},
{\tt double} {\bf rate} )
\label{jmarkov.basic.Transition(S, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Basic constructor.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt state} -- }
   \item{
\sld
{\tt rate} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.basic.Transition.description()}{\membername{description}}
{\tt  java.lang.String\ {\bf description}(  )
\label{jmarkov.basic.Transition.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.JMarkovElement}{JMarkovElement}{\small \refdefined{jmarkov.basic.JMarkovElement}} }

This method return a complete verbal describtion of this element. This description may contain multiple text rows.
}
\item{{\bf Returns} -- 
A String describing this element. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.label()}{JMarkovElement.label()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getRate}
\item{\vskip -1.9ex 
\index{getRate()}
\hypertarget{jmarkov.basic.Transition.getRate()}{\membername{getRate}}
{\tt public final double\ {\bf getRate}(  )
\label{jmarkov.basic.Transition.getRate()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the rate.
}
\item{{\bf Returns} -- 
Returns the rate. 
}%end item
\end{itemize}
}%end item
\divideents{getState}
\item{\vskip -1.9ex 
\index{getState()}
\hypertarget{jmarkov.basic.Transition.getState()}{\membername{getState}}
{\tt public final State\ {\bf getState}(  )
\label{jmarkov.basic.Transition.getState()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the state.
}
\item{{\bf Returns} -- 
Returns the state. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.Transition.label()}{\membername{label}}
{\tt  java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.Transition.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.JMarkovElement}{JMarkovElement}{\small \refdefined{jmarkov.basic.JMarkovElement}} }

This method returns a short String used in the user interface to describe this element.
}
\item{{\bf Returns} -- 
A String label. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.description()}{JMarkovElement.description()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.description()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.basic.Transition.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jmarkov.basic.Transition.toString()}}%end signature
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{TransitionsSet}
\subsection{\label{jmarkov.basic.TransitionsSet}\index{TransitionsSet}{\bf {\it Class} TransitionsSet}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.TransitionsSet}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public final class TransitionsSet
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
JMarkovElement, Transitions}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.TransitionsSet()}{{\bf TransitionsSet()}} Default Constructor.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.TransitionsSet.add(S, double)}{{\bf add(S, double)}} Adds a transition with the given state and rate.\\
\hyperlink{jmarkov.basic.TransitionsSet.add(jmarkov.basic.Transition)}{{\bf add(Transition)}} \\
\hyperlink{jmarkov.basic.TransitionsSet.add(jmarkov.basic.Transitions)}{{\bf add(Transitions)}} Adds all the given Transtions to the current set.\\
\hyperlink{jmarkov.basic.TransitionsSet.addRate(S, double)}{{\bf addRate(S, double)}} Adds the given rate to the transition to this state.\\
\hyperlink{jmarkov.basic.TransitionsSet.description()}{{\bf description()}} \\
\hyperlink{jmarkov.basic.TransitionsSet.getRate(S)}{{\bf getRate(S)}} Gets the rate for this state.\\
\hyperlink{jmarkov.basic.TransitionsSet.iterator()}{{\bf iterator()}} Returns an iterator used to walk through the Transitions.\\
\hyperlink{jmarkov.basic.TransitionsSet.label()}{{\bf label()}} \\
\hyperlink{jmarkov.basic.TransitionsSet.size()}{{\bf size()}} \\
\hyperlink{jmarkov.basic.TransitionsSet.toString()}{{\bf toString()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{TransitionsSet()}
\hypertarget{jmarkov.basic.TransitionsSet()}{\membername{TransitionsSet}}
{\tt public\ {\bf TransitionsSet}(  )
\label{jmarkov.basic.TransitionsSet()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default Constructor.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{add(S, double)}
\hypertarget{jmarkov.basic.TransitionsSet.add(S, double)}{\membername{add}}
{\tt public boolean\ {\bf add}( {\tt State} {\bf state},
{\tt double} {\bf rate} )
\label{jmarkov.basic.TransitionsSet.add(S, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Adds a transition with the given state and rate.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.Transitions.add(S, double)}{Transitions.add(State,\allowbreak double)}} {\small 
\refdefined{jmarkov.basic.Transitions.add(S, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\index{add(Transition)}
\hypertarget{jmarkov.basic.TransitionsSet.add(jmarkov.basic.Transition)}{\membername{add}}
{\tt public boolean\ {\bf add}( {\tt Transition} {\bf t} )
\label{jmarkov.basic.TransitionsSet.add(jmarkov.basic.Transition)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.Transitions.add(jmarkov.basic.Transition)}{Transitions.add(Transition)}} {\small 
\refdefined{jmarkov.basic.Transitions.add(jmarkov.basic.Transition)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{add}
\item{\vskip -1.9ex 
\index{add(Transitions)}
\hypertarget{jmarkov.basic.TransitionsSet.add(jmarkov.basic.Transitions)}{\membername{add}}
{\tt public boolean\ {\bf add}( {\tt Transitions} {\bf trans} )
\label{jmarkov.basic.TransitionsSet.add(jmarkov.basic.Transitions)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Adds all the given Transtions to the current set.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt trans} -- A collection of Transitions}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
true if none of the elements was in the set. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.util.Set.addAll(java.util.Collection)}{java.util.Set.addAll(java.util.Collection)}} {\small 
\refdefined{java.util.Set.addAll(java.util.Collection)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{addRate}
\item{\vskip -1.9ex 
\index{addRate(S, double)}
\hypertarget{jmarkov.basic.TransitionsSet.addRate(S, double)}{\membername{addRate}}
{\tt public double\ {\bf addRate}( {\tt State} {\bf state},
{\tt double} {\bf rate} )
\label{jmarkov.basic.TransitionsSet.addRate(S, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Adds the given rate to the transition to this state.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt state} -- }
   \item{
\sld
{\tt rate} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The old value associated with this state. 
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.basic.TransitionsSet.description()}{\membername{description}}
{\tt  java.lang.String\ {\bf description}(  )
\label{jmarkov.basic.TransitionsSet.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.JMarkovElement}{JMarkovElement}{\small \refdefined{jmarkov.basic.JMarkovElement}} }

This method return a complete verbal describtion of this element. This description may contain multiple text rows.
}
\item{{\bf Returns} -- 
A String describing this element. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.label()}{JMarkovElement.label()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getRate}
\item{\vskip -1.9ex 
\index{getRate(S)}
\hypertarget{jmarkov.basic.TransitionsSet.getRate(S)}{\membername{getRate}}
{\tt public double\ {\bf getRate}( {\tt State} {\bf state} )
\label{jmarkov.basic.TransitionsSet.getRate(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the rate for this state. It returns 0.0 if this state is not in the Transitions.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt state} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The rate for this state 
}%end item
\end{itemize}
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\index{iterator()}
\hypertarget{jmarkov.basic.TransitionsSet.iterator()}{\membername{iterator}}
{\tt public java.util.Iterator\ {\bf iterator}(  )
\label{jmarkov.basic.TransitionsSet.iterator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns an iterator used to walk through the Transitions.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Iterable.iterator()}{java.lang.Iterable.iterator()}} {\small 
\refdefined{java.lang.Iterable.iterator()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.TransitionsSet.label()}{\membername{label}}
{\tt  java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.TransitionsSet.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.JMarkovElement}{JMarkovElement}{\small \refdefined{jmarkov.basic.JMarkovElement}} }

This method returns a short String used in the user interface to describe this element.
}
\item{{\bf Returns} -- 
A String label. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.description()}{JMarkovElement.description()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.description()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\index{size()}
\hypertarget{jmarkov.basic.TransitionsSet.size()}{\membername{size}}
{\tt  int\ {\bf size}(  )
\label{jmarkov.basic.TransitionsSet.size()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.Transitions}{Transitions}{\small \refdefined{jmarkov.basic.Transitions}} }

Returns the number of Transtions represented by this object.
}
\item{{\bf Returns} -- 
The number of Transitions. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.util.Set.size()}{java.util.Set.size()}} {\small 
\refdefined{java.util.Set.size()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.basic.TransitionsSet.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jmarkov.basic.TransitionsSet.toString()}}%end signature
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{ValueFunction}
\subsection{\label{jmarkov.basic.ValueFunction}\index{ValueFunction}{\bf {\it Class} ValueFunction}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.ValueFunction}{}\vskip .1in 
This structure matches each state with a double number representing its value function, or in some cases the steady state probabilities.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class ValueFunction
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
JMarkovElement}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.ValueFunction()}{{\bf ValueFunction()}} Creates a new empty value function.\\
\hyperlink{jmarkov.basic.ValueFunction(java.lang.String)}{{\bf ValueFunction(String)}} Creates a new empty value function.\\
\hyperlink{jmarkov.basic.ValueFunction(jmarkov.basic.ValueFunction)}{{\bf ValueFunction(ValueFunction)}} Creates a value function from another given value function\\
\hyperlink{jmarkov.basic.ValueFunction(jmarkov.basic.ValueFunction, java.lang.String)}{{\bf ValueFunction(ValueFunction, String)}} Creates a value function from another given value function\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.basic.ValueFunction.description()}{{\bf description()}} \\
\hyperlink{jmarkov.basic.ValueFunction.get()}{{\bf get()}} Gets an array with all the values represented in this value function.\\
\hyperlink{jmarkov.basic.ValueFunction.get(S)}{{\bf get(S)}} Gets the Value associted with this State.\\
\hyperlink{jmarkov.basic.ValueFunction.iterator()}{{\bf iterator()}} Return an iterator used to wakl through the Value Function.\\
\hyperlink{jmarkov.basic.ValueFunction.label()}{{\bf label()}} \\
\hyperlink{jmarkov.basic.ValueFunction.print(java.io.PrintWriter)}{{\bf print(PrintWriter)}} Prints the Value Function.\\
\hyperlink{jmarkov.basic.ValueFunction.print(java.io.PrintWriter, java.lang.String, java.lang.String)}{{\bf print(PrintWriter, String, String)}} Prints the Value function with the given state format , and values format according to the Format String Syntax.\\
\hyperlink{jmarkov.basic.ValueFunction.set(S, double)}{{\bf set(S, double)}} Associates a state and a double value\\
\hyperlink{jmarkov.basic.ValueFunction.toString()}{{\bf toString()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{ValueFunction()}
\hypertarget{jmarkov.basic.ValueFunction()}{\membername{ValueFunction}}
{\tt public\ {\bf ValueFunction}(  )
\label{jmarkov.basic.ValueFunction()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new empty value function.
}
\end{itemize}
}%end item
\divideents{ValueFunction}
\item{\vskip -1.9ex 
\index{ValueFunction(String)}
\hypertarget{jmarkov.basic.ValueFunction(java.lang.String)}{\membername{ValueFunction}}
{\tt public\ {\bf ValueFunction}( {\tt java.lang.String} {\bf name} )
\label{jmarkov.basic.ValueFunction(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new empty value function.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt name} -- The name for thei value function}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{ValueFunction}
\item{\vskip -1.9ex 
\index{ValueFunction(ValueFunction)}
\hypertarget{jmarkov.basic.ValueFunction(jmarkov.basic.ValueFunction)}{\membername{ValueFunction}}
{\tt public\ {\bf ValueFunction}( {\tt ValueFunction} {\bf vf} )
\label{jmarkov.basic.ValueFunction(jmarkov.basic.ValueFunction)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a value function from another given value function
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt vf} -- value function}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{ValueFunction}
\item{\vskip -1.9ex 
\index{ValueFunction(ValueFunction, String)}
\hypertarget{jmarkov.basic.ValueFunction(jmarkov.basic.ValueFunction, java.lang.String)}{\membername{ValueFunction}}
{\tt public\ {\bf ValueFunction}( {\tt ValueFunction} {\bf vf},
{\tt java.lang.String} {\bf name} )
\label{jmarkov.basic.ValueFunction(jmarkov.basic.ValueFunction, java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a value function from another given value function
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt vf} -- value function}
   \item{
\sld
{\tt name} -- The name for this value function.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.basic.ValueFunction.description()}{\membername{description}}
{\tt  java.lang.String\ {\bf description}(  )
\label{jmarkov.basic.ValueFunction.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.JMarkovElement}{JMarkovElement}{\small \refdefined{jmarkov.basic.JMarkovElement}} }

This method return a complete verbal describtion of this element. This description may contain multiple text rows.
}
\item{{\bf Returns} -- 
A String describing this element. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.label()}{JMarkovElement.label()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\index{get()}
\hypertarget{jmarkov.basic.ValueFunction.get()}{\membername{get}}
{\tt public double\lbrack \rbrack \ {\bf get}(  )
\label{jmarkov.basic.ValueFunction.get()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets an array with all the values represented in this value function.
}
\item{{\bf Returns} -- 
an array with the values 
}%end item
\end{itemize}
}%end item
\divideents{get}
\item{\vskip -1.9ex 
\index{get(S)}
\hypertarget{jmarkov.basic.ValueFunction.get(S)}{\membername{get}}
{\tt public double\ {\bf get}( {\tt State} {\bf s} )
\label{jmarkov.basic.ValueFunction.get(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the Value associted with this State.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- given state}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the double value corresponding to the state 
}%end item
\end{itemize}
}%end item
\divideents{iterator}
\item{\vskip -1.9ex 
\index{iterator()}
\hypertarget{jmarkov.basic.ValueFunction.iterator()}{\membername{iterator}}
{\tt public java.util.Iterator\ {\bf iterator}(  )
\label{jmarkov.basic.ValueFunction.iterator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return an iterator used to wakl through the Value Function.
}
\item{{\bf Returns} -- 
iterator over the entries of the map 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.basic.ValueFunction.label()}{\membername{label}}
{\tt  java.lang.String\ {\bf label}(  )
\label{jmarkov.basic.ValueFunction.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.JMarkovElement}{JMarkovElement}{\small \refdefined{jmarkov.basic.JMarkovElement}} }

This method returns a short String used in the user interface to describe this element.
}
\item{{\bf Returns} -- 
A String label. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.description()}{JMarkovElement.description()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.description()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{print}
\item{\vskip -1.9ex 
\index{print(PrintWriter)}
\hypertarget{jmarkov.basic.ValueFunction.print(java.io.PrintWriter)}{\membername{print}}
{\tt public void\ {\bf print}( {\tt java.io.PrintWriter} {\bf pw} )
\label{jmarkov.basic.ValueFunction.print(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the Value Function. It uses default states and values format.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pw} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{print}
\item{\vskip -1.9ex 
\index{print(PrintWriter, String, String)}
\hypertarget{jmarkov.basic.ValueFunction.print(java.io.PrintWriter, java.lang.String, java.lang.String)}{\membername{print}}
{\tt public void\ {\bf print}( {\tt java.io.PrintWriter} {\bf pw},
{\tt java.lang.String} {\bf statesFormat},
{\tt java.lang.String} {\bf valuesFormat} )
\label{jmarkov.basic.ValueFunction.print(java.io.PrintWriter, java.lang.String, java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the Value function with the given state format , and values format according to the Format String Syntax.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pw} -- }
   \item{
\sld
{\tt statesFormat} -- format for the states , for example "\%-10S" to have 10 width left aligned states.}
   \item{
\sld
{\tt valuesFormat} -- format to use for values. For example us "\%6.2" to have 6 width and 2 decimals.}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.util.Formatter}{java.util.Formatter}} {\small 
\refdefined{java.util.Formatter}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{set}
\item{\vskip -1.9ex 
\index{set(S, double)}
\hypertarget{jmarkov.basic.ValueFunction.set(S, double)}{\membername{set}}
{\tt public void\ {\bf set}( {\tt State} {\bf s},
{\tt double} {\bf val} )
\label{jmarkov.basic.ValueFunction.set(S, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Associates a state and a double value
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- state}
   \item{
\sld
{\tt val} -- value}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.basic.ValueFunction.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jmarkov.basic.ValueFunction.toString()}}%end signature
}%end item
\end{itemize}
}
}
\newpage}
}
\newpage
\def\packagename{jmarkov.basic.exceptions}
\chapter{\bf Package jmarkov.basic.exceptions}{
\thispagestyle{empty}
\label{jmarkov.basic.exceptions}\hypertarget{jmarkov.basic.exceptions}{}
\markboth{\protect\packagename}{\protect\packagename}
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
This package contains the definition od the Exceptions thrown by jMarkov.\mbox{}\\ \rule{\hsize}{.7mm}
\vskip .1in
\newpage
\markboth{\protect\packagename \hspace{.02in} -- \protect\classname}{\protect\packagename \hspace{.02in} -- \protect\classname}
\section{Exceptions}{
\gdef\classname{NonStochasticException}
\subsection{\label{jmarkov.basic.exceptions.NonStochasticException}\index{NonStochasticException}{\bf {\it Class} NonStochasticException}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.exceptions.NonStochasticException}{}\vskip .1in 
This Exception indicates that the transition probability matrix is not stochastic for the state and action computed. The matrix is not stochastic when the sum of the transition probabilities (row) is not 1.0.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class NonStochasticException
\\ {\bf extends} java.lang.RuntimeException
\refdefined{java.lang.RuntimeException}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.exceptions.NonStochasticException(java.lang.String)}{{\bf NonStochasticException(String)}} Default constructor.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{NonStochasticException(String)}
\hypertarget{jmarkov.basic.exceptions.NonStochasticException(java.lang.String)}{\membername{NonStochasticException}}
{\tt public\ {\bf NonStochasticException}( {\tt java.lang.String} {\bf message} )
\label{jmarkov.basic.exceptions.NonStochasticException(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default constructor.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt message} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt java.lang.RuntimeException} \textnormal{\small\refdefined{java.lang.RuntimeException}}}{
{\small 
}}
\subsubsection{Members inherited from class {\tt java.lang.Exception} \textnormal{\small\refdefined{java.lang.Exception}}}{
{\small 
}}
\subsubsection{Members inherited from class {\tt java.lang.Throwable} \textnormal{\small\refdefined{java.lang.Throwable}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public synchronized native Throwable {\bf fillInStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Throwable {\bf getCause}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getLocalizedMessage}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getMessage}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StackTraceElement {\bf getStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized Throwable {\bf initCause}( {\tt Throwable} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}( {\tt java.io.PrintStream} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}( {\tt java.io.PrintWriter} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setStackTrace}( {\tt StackTraceElement\lbrack \rbrack } {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{NotUnichainException}
\subsection{\label{jmarkov.basic.exceptions.NotUnichainException}\index{NotUnichainException}{\bf {\it Class} NotUnichainException}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.exceptions.NotUnichainException}{}\vskip .1in 
This Exception should be thrown by the SteadyStateSolver if it detects that there is not a unique solution to the stationary probabilities. This occurs when there are multiple closed communicating classes in the system, and therefore the corresponding linear system has multiple solutions.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.solvers.SteadyStateSolver}{jmarkov.solvers.SteadyStateSolver}} {\small 
\refdefined{jmarkov.solvers.SteadyStateSolver}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class NotUnichainException
\\ {\bf extends} jmarkov.basic.exceptions.SolverException
\refdefined{jmarkov.basic.exceptions.SolverException}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.exceptions.NotUnichainException(java.lang.String)}{{\bf NotUnichainException(String)}} Default constructor.\\
\hyperlink{jmarkov.basic.exceptions.NotUnichainException(java.lang.String, java.lang.Throwable)}{{\bf NotUnichainException(String, Throwable)}} Constructor with cause.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{NotUnichainException(String)}
\hypertarget{jmarkov.basic.exceptions.NotUnichainException(java.lang.String)}{\membername{NotUnichainException}}
{\tt public\ {\bf NotUnichainException}( {\tt java.lang.String} {\bf message} )
\label{jmarkov.basic.exceptions.NotUnichainException(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default constructor.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt message} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{NotUnichainException}
\item{\vskip -1.9ex 
\index{NotUnichainException(String, Throwable)}
\hypertarget{jmarkov.basic.exceptions.NotUnichainException(java.lang.String, java.lang.Throwable)}{\membername{NotUnichainException}}
{\tt public\ {\bf NotUnichainException}( {\tt java.lang.String} {\bf message},
{\tt java.lang.Throwable} {\bf cause} )
\label{jmarkov.basic.exceptions.NotUnichainException(java.lang.String, java.lang.Throwable)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructor with cause.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt message} -- }
   \item{
\sld
{\tt cause} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.basic.exceptions.SolverException} \textnormal{\small\refdefined{jmarkov.basic.exceptions.SolverException}}}{
{\small 
}}
\subsubsection{Members inherited from class {\tt java.lang.Exception} \textnormal{\small\refdefined{java.lang.Exception}}}{
{\small 
}}
\subsubsection{Members inherited from class {\tt java.lang.Throwable} \textnormal{\small\refdefined{java.lang.Throwable}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public synchronized native Throwable {\bf fillInStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Throwable {\bf getCause}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getLocalizedMessage}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getMessage}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StackTraceElement {\bf getStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized Throwable {\bf initCause}( {\tt Throwable} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}( {\tt java.io.PrintStream} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}( {\tt java.io.PrintWriter} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setStackTrace}( {\tt StackTraceElement\lbrack \rbrack } {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{SolverException}
\subsection{\label{jmarkov.basic.exceptions.SolverException}\index{SolverException}{\bf {\it Class} SolverException}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.exceptions.SolverException}{}\vskip .1in 
This exception is thrown by solve methods.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class SolverException
\\ {\bf extends} java.lang.Exception
\refdefined{java.lang.Exception}}}}
\subsubsection{All known subclasses}{StructureException\small{\refdefined{jmarkov.basic.exceptions.StructureException}}, NotUnichainException\small{\refdefined{jmarkov.basic.exceptions.NotUnichainException}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.exceptions.SolverException(java.lang.String)}{{\bf SolverException(String)}} \\
\hyperlink{jmarkov.basic.exceptions.SolverException(java.lang.String, java.lang.Throwable)}{{\bf SolverException(String, Throwable)}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{SolverException(String)}
\hypertarget{jmarkov.basic.exceptions.SolverException(java.lang.String)}{\membername{SolverException}}
{\tt public\ {\bf SolverException}( {\tt java.lang.String} {\bf message} )
\label{jmarkov.basic.exceptions.SolverException(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt message} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{SolverException}
\item{\vskip -1.9ex 
\index{SolverException(String, Throwable)}
\hypertarget{jmarkov.basic.exceptions.SolverException(java.lang.String, java.lang.Throwable)}{\membername{SolverException}}
{\tt public\ {\bf SolverException}( {\tt java.lang.String} {\bf message},
{\tt java.lang.Throwable} {\bf cause} )
\label{jmarkov.basic.exceptions.SolverException(java.lang.String, java.lang.Throwable)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt message} -- }
   \item{
\sld
{\tt cause} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt java.lang.Exception} \textnormal{\small\refdefined{java.lang.Exception}}}{
{\small 
}}
\subsubsection{Members inherited from class {\tt java.lang.Throwable} \textnormal{\small\refdefined{java.lang.Throwable}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public synchronized native Throwable {\bf fillInStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Throwable {\bf getCause}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getLocalizedMessage}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getMessage}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StackTraceElement {\bf getStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized Throwable {\bf initCause}( {\tt Throwable} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}( {\tt java.io.PrintStream} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}( {\tt java.io.PrintWriter} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setStackTrace}( {\tt StackTraceElement\lbrack \rbrack } {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{StructureException}
\subsection{\label{jmarkov.basic.exceptions.StructureException}\index{StructureException}{\bf {\it Class} StructureException}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.basic.exceptions.StructureException}{}\vskip .1in 
This exception is produced in shortest path problems if the conditions for convergence are not met.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class StructureException
\\ {\bf extends} jmarkov.basic.exceptions.SolverException
\refdefined{jmarkov.basic.exceptions.SolverException}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.basic.exceptions.StructureException(java.lang.String)}{{\bf StructureException(String)}} Default constructor.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{StructureException(String)}
\hypertarget{jmarkov.basic.exceptions.StructureException(java.lang.String)}{\membername{StructureException}}
{\tt public\ {\bf StructureException}( {\tt java.lang.String} {\bf message} )
\label{jmarkov.basic.exceptions.StructureException(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default constructor.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt message} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.basic.exceptions.SolverException} \textnormal{\small\refdefined{jmarkov.basic.exceptions.SolverException}}}{
{\small 
}}
\subsubsection{Members inherited from class {\tt java.lang.Exception} \textnormal{\small\refdefined{java.lang.Exception}}}{
{\small 
}}
\subsubsection{Members inherited from class {\tt java.lang.Throwable} \textnormal{\small\refdefined{java.lang.Throwable}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public synchronized native Throwable {\bf fillInStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Throwable {\bf getCause}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getLocalizedMessage}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf getMessage}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StackTraceElement {\bf getStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public synchronized Throwable {\bf initCause}( {\tt Throwable} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}( {\tt java.io.PrintStream} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printStackTrace}( {\tt java.io.PrintWriter} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setStackTrace}( {\tt StackTraceElement\lbrack \rbrack } {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage}
}
\newpage
\def\packagename{jmarkov.jmdp}
\chapter{\bf Package jmarkov.jmdp}{
\thispagestyle{empty}
\label{jmarkov.jmdp}\hypertarget{jmarkov.jmdp}{}
\markboth{\protect\packagename}{\protect\packagename}
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Classes}
\entityintro{CT2DTConverter}{jmarkov.jmdp.CT2DTConverter}{This class formulates a DTMDP equivalent to a CTMDP.}
\entityintro{CTMDP}{jmarkov.jmdp.CTMDP}{This class represents a continuous time MDP.}
\entityintro{CTMDPEv}{jmarkov.jmdp.CTMDPEv}{This class represents an Infinite horizon, continuous time Markov Decision Process with events.}
\entityintro{CTMDPEvA}{jmarkov.jmdp.CTMDPEvA}{This class represents an Infinite horizon, continuous time Markov Decision Process with events where actions depend on events.}
\entityintro{DTMDP}{jmarkov.jmdp.DTMDP}{This class represents a discrete time infnite horizon MDP problem.}
\entityintro{DTMDPEv}{jmarkov.jmdp.DTMDPEv}{This class represents an infinite horizon, discrete time, Markov Decision Process with events.}
\entityintro{DTMDPEvA}{jmarkov.jmdp.DTMDPEvA}{This class represents an infinite horizon, discrete time, Markov Decision Process with events, where actions depend on events.}
\entityintro{FiniteDP}{jmarkov.jmdp.FiniteDP}{This class should ONLY be used in FINITE horizondeterministic problems.}
\entityintro{FiniteMDP}{jmarkov.jmdp.FiniteMDP}{This class should ONLY be used in FINITE horizon problems.}
\entityintro{FiniteMDPEv}{jmarkov.jmdp.FiniteMDPEv}{This class represents a finite horizon discrete time MDP with events.}
\entityintro{InfiniteMDP}{jmarkov.jmdp.InfiniteMDP}{This class is a structural class and is.}
\entityintro{MDP}{jmarkov.jmdp.MDP}{This class is the main framework to build a Dynamic Programming Problem.}
\entityintro{StochasticShortestPath}{jmarkov.jmdp.StochasticShortestPath}{This class represents an infinite horizon shortest path problem.}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
jMDP is used to solve Markov Decision Processes. See the jMDP manual for details.\mbox{}\\ \rule{\hsize}{.7mm}
\vskip .1in
\newpage
\markboth{\protect\packagename \hspace{.02in} -- \protect\classname}{\protect\packagename \hspace{.02in} -- \protect\classname}
\section{Classes}{
\gdef\classname{CT2DTConverter}
\subsection{\label{jmarkov.jmdp.CT2DTConverter}\index{CT2DTConverter}{\bf {\it Class} CT2DTConverter}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.CT2DTConverter}{}\vskip .1in 
This class formulates a DTMDP equivalent to a CTMDP.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class CT2DTConverter
\\ {\bf extends} jmarkov.jmdp.DTMDP
\refdefined{jmarkov.jmdp.DTMDP}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.CT2DTConverter(jmarkov.jmdp.CTMDP)}{{\bf CT2DTConverter(CTMDP)}} Constructor is not public because it should only be invoked by CTMDP in this same package.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.CT2DTConverter.exitRate(S, A)}{{\bf exitRate(S, A)}} This method calculates the exit rate for a given state and action.\\
\hyperlink{jmarkov.jmdp.CT2DTConverter.feasibleActions(S)}{{\bf feasibleActions(S)}} \\
\hyperlink{jmarkov.jmdp.CT2DTConverter.immediateCost(S, A)}{{\bf immediateCost(S, A)}} \\
\hyperlink{jmarkov.jmdp.CT2DTConverter.prob(S, S, A)}{{\bf prob(S, S, A)}} \\
\hyperlink{jmarkov.jmdp.CT2DTConverter.reachable(S, A)}{{\bf reachable(S, A)}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{CT2DTConverter(CTMDP)}
\hypertarget{jmarkov.jmdp.CT2DTConverter(jmarkov.jmdp.CTMDP)}{\membername{CT2DTConverter}}
{\tt public\ {\bf CT2DTConverter}( {\tt CTMDP} {\bf problem} )
\label{jmarkov.jmdp.CT2DTConverter(jmarkov.jmdp.CTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructor is not public because it should only be invoked by CTMDP in this same package.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- an infinite horizon continuous time problem}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{exitRate(S, A)}
\hypertarget{jmarkov.jmdp.CT2DTConverter.exitRate(S, A)}{\membername{exitRate}}
{\tt public double\ {\bf exitRate}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CT2DTConverter.exitRate(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method calculates the exit rate for a given state and action. It sums all rates for all reachable states under that action.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- current action}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The soujurn rate for a given state and action 
}%end item
\end{itemize}
}%end item
\divideents{feasibleActions}
\item{\vskip -1.9ex 
\index{feasibleActions(S)}
\hypertarget{jmarkov.jmdp.CT2DTConverter.feasibleActions(S)}{\membername{feasibleActions}}
{\tt public abstract jmarkov.basic.Actions\ {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i} )
\label{jmarkov.jmdp.CT2DTConverter.feasibleActions(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.InfiniteMDP}{InfiniteMDP}{\small \refdefined{jmarkov.jmdp.InfiniteMDP}} }

Returns the set of actions available at this state.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current State}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of Actions that can be taken at this state. 
}%end item
\end{itemize}
}%end item
\divideents{immediateCost}
\item{\vskip -1.9ex 
\index{immediateCost(S, A)}
\hypertarget{jmarkov.jmdp.CT2DTConverter.immediateCost(S, A)}{\membername{immediateCost}}
{\tt public abstract double\ {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CT2DTConverter.immediateCost(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.DTMDP}{DTMDP}{\small \refdefined{jmarkov.jmdp.DTMDP}} }

Cost incurred when taking action a from state i
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current State}
   \item{
\sld
{\tt a} -- Current Action}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The cost incurred per transition 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, S, A)}
\hypertarget{jmarkov.jmdp.CT2DTConverter.prob(S, S, A)}{\membername{prob}}
{\tt public abstract double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CT2DTConverter.prob(S, S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.DTMDP}{DTMDP}{\small \refdefined{jmarkov.jmdp.DTMDP}} }

Probability of going from state i to state j by taking the action a
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current state.}
   \item{
\sld
{\tt j} -- Destination State}
   \item{
\sld
{\tt a} -- Action}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The probability. 
}%end item
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A)}
\hypertarget{jmarkov.jmdp.CT2DTConverter.reachable(S, A)}{\membername{reachable}}
{\tt public abstract jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CT2DTConverter.reachable(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.DTMDP}{DTMDP}{\small \refdefined{jmarkov.jmdp.DTMDP}} }

Set of states that can be reached from this state i, after taking the action a.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current State}
   \item{
\sld
{\tt a} -- Action taken}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The reachable states. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.DTMDP} \textnormal{\small\refdefined{jmarkov.jmdp.DTMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getSteadyStateProbabilities}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf oneStageReachable}( {\tt jmarkov.basic.States} {\bf initSet} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract States {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setProbabilitySolver}( {\tt solvers.ProbabilitySolver} {\bf solv} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Solution {\bf solve}( {\tt double} {\bf interestRate} ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.InfiniteMDP} \textnormal{\small\refdefined{jmarkov.jmdp.InfiniteMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf absorbingStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf explorationTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Actions {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getAllStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractAverageSolver {\bf getDefaultAverageSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractDiscountedSolver {\bf getDefaultDiscountedSolver}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractInfiniteSolver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getNumStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public AbstractInfiniteSolver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf hasAbsorbingState}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf numStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probability}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probabilitySolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf states}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{CTMDP}
\subsection{\label{jmarkov.jmdp.CTMDP}\index{CTMDP}{\bf {\it Class} CTMDP}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.CTMDP}{}\vskip .1in 
This class represents a continuous time MDP. It should ONLY be used in INFINITE horizon Problems. It must be extended in order to represent the appropriate structure for each INFINITE horizon MDP problem. The user must implement at least the functions that have been declared abstract. It is also necessary to create one of the extensions of the class Solver. By default, the program includes PolicyIterationSolver and ValueIterationSolver classes to solve infinite horizon problems. The FiniteSolver class is only for finite horizon problems. To solve the problem follow the instructions in each of the solvers's instructions.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver}{solvers.PolicyIterationSolver}} {\small 
\refdefined{jmarkov.jmdp.solvers.PolicyIterationSolver}}%end
} 
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver}{solvers.ValueIterationSolver}} {\small 
\refdefined{jmarkov.jmdp.solvers.ValueIterationSolver}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class CTMDP
\\ {\bf extends} jmarkov.jmdp.InfiniteMDP
\refdefined{jmarkov.jmdp.InfiniteMDP}}}}
\subsubsection{All known subclasses}{CTMDPEvA\small{\refdefined{jmarkov.jmdp.CTMDPEvA}}, CTMDPEv\small{\refdefined{jmarkov.jmdp.CTMDPEv}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.CTMDP.activeState}{{\bf activeState}} No earthly idea what this is for..\\
\hyperlink{jmarkov.jmdp.CTMDP.converter}{{\bf converter}} The converter used to map the problem to a DTMDP.\\
\hyperlink{jmarkov.jmdp.CTMDP.maxRate}{{\bf maxRate}} Tha maxRate used for uniformization\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.CTMDP(jmarkov.basic.States)}{{\bf CTMDP(States)}} Creates a new continuous time infinite horizon MDP Problem.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.CTMDP.continuousCost(S, A)}{{\bf continuousCost(S, A)}} Cost incurred continuously in time until the next transition from state i given that action a is taken.\\
\hyperlink{jmarkov.jmdp.CTMDP.generate()}{{\bf generate()}} \\
\hyperlink{jmarkov.jmdp.CTMDP.getAllStates()}{{\bf getAllStates()}} Complete set of states explored\\
\hyperlink{jmarkov.jmdp.CTMDP.getMaxRate()}{{\bf getMaxRate()}} \\
\hyperlink{jmarkov.jmdp.CTMDP.getSteadyStateProbabilities()}{{\bf getSteadyStateProbabilities()}} \\
\hyperlink{jmarkov.jmdp.CTMDP.lumpCost(S, A)}{{\bf lumpCost(S, A)}} Cost incurred instantaneously in the moment when action a is taken from state i.\\
\hyperlink{jmarkov.jmdp.CTMDP.oneStageReachable(jmarkov.basic.States)}{{\bf oneStageReachable(States)}} Finds the states reachable in one step.\\
\hyperlink{jmarkov.jmdp.CTMDP.rate(S, S, A)}{{\bf rate(S, S, A)}} Rate of going from state i to state j by taking the action a\\
\hyperlink{jmarkov.jmdp.CTMDP.reachable(S, A)}{{\bf reachable(S, A)}} Set of States that can be reached from this state i, after taking the action a.\\
\hyperlink{jmarkov.jmdp.CTMDP.setConverter(jmarkov.jmdp.CT2DTConverter)}{{\bf setConverter(CT2DTConverter)}} Sets the class in charge of making a DTMDP equivalent to the CTMDP\\
\hyperlink{jmarkov.jmdp.CTMDP.solve(double)}{{\bf solve(double)}} Solves the problem with the given interest rate\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{maxRate}
\label{jmarkov.jmdp.CTMDP.maxRate}\hypertarget{jmarkov.jmdp.CTMDP.maxRate}{protected double {\bf maxRate}}
\begin{itemize}
\item{\vskip -.9ex 
Tha maxRate used for uniformization}
\end{itemize}
}
\item{
\index{activeState}
\label{jmarkov.jmdp.CTMDP.activeState}\hypertarget{jmarkov.jmdp.CTMDP.activeState}{protected jmarkov.basic.State {\bf activeState}}
\begin{itemize}
\item{\vskip -.9ex 
No earthly idea what this is for..}
\end{itemize}
}
\item{
\index{converter}
\label{jmarkov.jmdp.CTMDP.converter}\hypertarget{jmarkov.jmdp.CTMDP.converter}{protected CT2DTConverter {\bf converter}}
\begin{itemize}
\item{\vskip -.9ex 
The converter used to map the problem to a DTMDP.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{CTMDP(States)}
\hypertarget{jmarkov.jmdp.CTMDP(jmarkov.basic.States)}{\membername{CTMDP}}
{\tt public\ {\bf CTMDP}( {\tt jmarkov.basic.States} {\bf initial} )
\label{jmarkov.jmdp.CTMDP(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new continuous time infinite horizon MDP Problem.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- set of initial states for the exploration algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{continuousCost(S, A)}
\hypertarget{jmarkov.jmdp.CTMDP.continuousCost(S, A)}{\membername{continuousCost}}
{\tt public abstract double\ {\bf continuousCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDP.continuousCost(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Cost incurred continuously in time until the next transition from state i given that action a is taken.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- State}
   \item{
\sld
{\tt a} -- Action}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Rate at which cost is incurred when action a is taken. 
}%end item
\end{itemize}
}%end item
\divideents{generate}
\item{\vskip -1.9ex 
\index{generate()}
\hypertarget{jmarkov.jmdp.CTMDP.generate()}{\membername{generate}}
{\tt protected abstract jmarkov.basic.StatesSet\ {\bf generate}(  )
\label{jmarkov.jmdp.CTMDP.generate()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
The set of states found. 
}%end item
\end{itemize}
}%end item
\divideents{getAllStates}
\item{\vskip -1.9ex 
\index{getAllStates()}
\hypertarget{jmarkov.jmdp.CTMDP.getAllStates()}{\membername{getAllStates}}
{\tt public jmarkov.basic.StatesSet\ {\bf getAllStates}(  )
\label{jmarkov.jmdp.CTMDP.getAllStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Complete set of states explored
}
\item{{\bf Returns} -- 
set of states explored 
}%end item
\end{itemize}
}%end item
\divideents{getMaxRate}
\item{\vskip -1.9ex 
\index{getMaxRate()}
\hypertarget{jmarkov.jmdp.CTMDP.getMaxRate()}{\membername{getMaxRate}}
{\tt public double\ {\bf getMaxRate}(  )
\label{jmarkov.jmdp.CTMDP.getMaxRate()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
maximum exit rate for all states and all actions 
}%end item
\end{itemize}
}%end item
\divideents{getSteadyStateProbabilities}
\item{\vskip -1.9ex 
\index{getSteadyStateProbabilities()}
\hypertarget{jmarkov.jmdp.CTMDP.getSteadyStateProbabilities()}{\membername{getSteadyStateProbabilities}}
{\tt public jmarkov.basic.ValueFunction\ {\bf getSteadyStateProbabilities}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.CTMDP.getSteadyStateProbabilities()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
The steady state probability for each state 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{lumpCost}
\item{\vskip -1.9ex 
\index{lumpCost(S, A)}
\hypertarget{jmarkov.jmdp.CTMDP.lumpCost(S, A)}{\membername{lumpCost}}
{\tt public abstract double\ {\bf lumpCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDP.lumpCost(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Cost incurred instantaneously in the moment when action a is taken from state i.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- State}
   \item{
\sld
{\tt a} -- Action}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Lump cost received. 
}%end item
\end{itemize}
}%end item
\divideents{oneStageReachable}
\item{\vskip -1.9ex 
\index{oneStageReachable(States)}
\hypertarget{jmarkov.jmdp.CTMDP.oneStageReachable(jmarkov.basic.States)}{\membername{oneStageReachable}}
{\tt protected jmarkov.basic.StatesSet\ {\bf oneStageReachable}( {\tt jmarkov.basic.States} {\bf initSet} )
\label{jmarkov.jmdp.CTMDP.oneStageReachable(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Finds the states reachable in one step.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initSet} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
States reachable from this set 
}%end item
\end{itemize}
}%end item
\divideents{rate}
\item{\vskip -1.9ex 
\index{rate(S, S, A)}
\hypertarget{jmarkov.jmdp.CTMDP.rate(S, S, A)}{\membername{rate}}
{\tt public abstract double\ {\bf rate}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDP.rate(S, S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Rate of going from state i to state j by taking the action a
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt j} -- Destination state.}
   \item{
\sld
{\tt a} -- Action taken}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The rate 
}%end item
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A)}
\hypertarget{jmarkov.jmdp.CTMDP.reachable(S, A)}{\membername{reachable}}
{\tt public abstract jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDP.reachable(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of States that can be reached from this state i, after taking the action a.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current State}
   \item{
\sld
{\tt a} -- action taken}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the reachable states. 
}%end item
\end{itemize}
}%end item
\divideents{setConverter}
\item{\vskip -1.9ex 
\index{setConverter(CT2DTConverter)}
\hypertarget{jmarkov.jmdp.CTMDP.setConverter(jmarkov.jmdp.CT2DTConverter)}{\membername{setConverter}}
{\tt public void\ {\bf setConverter}( {\tt CT2DTConverter} {\bf converter} )
\label{jmarkov.jmdp.CTMDP.setConverter(jmarkov.jmdp.CT2DTConverter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the class in charge of making a DTMDP equivalent to the CTMDP
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt converter} -- class that makes a DTMDP equivalent to the CTMDP}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve(double)}
\hypertarget{jmarkov.jmdp.CTMDP.solve(double)}{\membername{solve}}
{\tt public jmarkov.basic.Solution\ {\bf solve}( {\tt double} {\bf interestRate} ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.CTMDP.solve(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Solves the problem with the given interest rate
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt interestRate} -- the interest rate parameter to solve the problem.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The Optimal solution. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.InfiniteMDP} \textnormal{\small\refdefined{jmarkov.jmdp.InfiniteMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf absorbingStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf explorationTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Actions {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getAllStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractAverageSolver {\bf getDefaultAverageSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractDiscountedSolver {\bf getDefaultDiscountedSolver}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractInfiniteSolver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getNumStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public AbstractInfiniteSolver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf hasAbsorbingState}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf numStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probability}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probabilitySolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf states}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{CTMDPEv}
\subsection{\label{jmarkov.jmdp.CTMDPEv}\index{CTMDPEv}{\bf {\it Class} CTMDPEv}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.CTMDPEv}{}\vskip .1in 
This class represents an Infinite horizon, continuous time Markov Decision Process with events. It allows the definition of events that can occur in a given state and this makes the reward and probability definition easier than in the cases where no events are defined.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class CTMDPEv
\\ {\bf extends} jmarkov.jmdp.CTMDP
\refdefined{jmarkov.jmdp.CTMDP}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.CTMDPEv(jmarkov.basic.States)}{{\bf CTMDPEv(States)}} This constructor builds a continuous time MDP with events.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.CTMDPEv.activeEvents(S, A)}{{\bf activeEvents(S, A)}} Set of events that are active from state i given that action a is taken.\\
\hyperlink{jmarkov.jmdp.CTMDPEv.continuousCost(S, A)}{{\bf continuousCost(S, A)}} \\
\hyperlink{jmarkov.jmdp.CTMDPEv.continuousCost(S, A, E)}{{\bf continuousCost(S, A, E)}} Reward obtained continuously in time during the sojourn time in state i until an action a is taken and a transition is triggered.\\
\hyperlink{jmarkov.jmdp.CTMDPEv.lumpCost(S, A)}{{\bf lumpCost(S, A)}} \\
\hyperlink{jmarkov.jmdp.CTMDPEv.lumpCost(S, A, E)}{{\bf lumpCost(S, A, E)}} Reward instantaneously gained in the moment when action a is taken from state i.\\
\hyperlink{jmarkov.jmdp.CTMDPEv.rate(S, S, A)}{{\bf rate(S, S, A)}} \\
\hyperlink{jmarkov.jmdp.CTMDPEv.rate(S, S, A, E)}{{\bf rate(S, S, A, E)}} Rate.\\
\hyperlink{jmarkov.jmdp.CTMDPEv.reachable(S, A)}{{\bf reachable(S, A)}} \\
\hyperlink{jmarkov.jmdp.CTMDPEv.reachable(S, A, E)}{{\bf reachable(S, A, E)}} Set of reachable states from state i given that action a is taken and event e occurs.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{CTMDPEv(States)}
\hypertarget{jmarkov.jmdp.CTMDPEv(jmarkov.basic.States)}{\membername{CTMDPEv}}
{\tt public\ {\bf CTMDPEv}( {\tt jmarkov.basic.States} {\bf initial} )
\label{jmarkov.jmdp.CTMDPEv(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This constructor builds a continuous time MDP with events.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- set of initial states for the exploration algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{activeEvents(S, A)}
\hypertarget{jmarkov.jmdp.CTMDPEv.activeEvents(S, A)}{\membername{activeEvents}}
{\tt public abstract jmarkov.basic.Events\ {\bf activeEvents}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDPEv.activeEvents(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of events that are active from state i given that action a is taken.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of events that can occur 
}%end item
\end{itemize}
}%end item
\divideents{continuousCost}
\item{\vskip -1.9ex 
\index{continuousCost(S, A)}
\hypertarget{jmarkov.jmdp.CTMDPEv.continuousCost(S, A)}{\membername{continuousCost}}
{\tt public abstract double\ {\bf continuousCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDPEv.continuousCost(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.CTMDP}{CTMDP}{\small \refdefined{jmarkov.jmdp.CTMDP}} }

Cost incurred continuously in time until the next transition from state i given that action a is taken.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- State}
   \item{
\sld
{\tt a} -- Action}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Rate at which cost is incurred when action a is taken. 
}%end item
\end{itemize}
}%end item
\divideents{continuousCost}
\item{\vskip -1.9ex 
\index{continuousCost(S, A, E)}
\hypertarget{jmarkov.jmdp.CTMDPEv.continuousCost(S, A, E)}{\membername{continuousCost}}
{\tt public abstract double\ {\bf continuousCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.CTMDPEv.continuousCost(S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Reward obtained continuously in time during the sojourn time in state i until an action a is taken and a transition is triggered.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
instanteneous reward. 
}%end item
\end{itemize}
}%end item
\divideents{lumpCost}
\item{\vskip -1.9ex 
\index{lumpCost(S, A)}
\hypertarget{jmarkov.jmdp.CTMDPEv.lumpCost(S, A)}{\membername{lumpCost}}
{\tt public abstract double\ {\bf lumpCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDPEv.lumpCost(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.CTMDP}{CTMDP}{\small \refdefined{jmarkov.jmdp.CTMDP}} }

Cost incurred instantaneously in the moment when action a is taken from state i.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- State}
   \item{
\sld
{\tt a} -- Action}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Lump cost received. 
}%end item
\end{itemize}
}%end item
\divideents{lumpCost}
\item{\vskip -1.9ex 
\index{lumpCost(S, A, E)}
\hypertarget{jmarkov.jmdp.CTMDPEv.lumpCost(S, A, E)}{\membername{lumpCost}}
{\tt public abstract double\ {\bf lumpCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.CTMDPEv.lumpCost(S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Reward instantaneously gained in the moment when action a is taken from state i.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
instanteneous reward. 
}%end item
\end{itemize}
}%end item
\divideents{rate}
\item{\vskip -1.9ex 
\index{rate(S, S, A)}
\hypertarget{jmarkov.jmdp.CTMDPEv.rate(S, S, A)}{\membername{rate}}
{\tt public abstract double\ {\bf rate}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDPEv.rate(S, S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.CTMDP}{CTMDP}{\small \refdefined{jmarkov.jmdp.CTMDP}} }

Rate of going from state i to state j by taking the action a
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt j} -- Destination state.}
   \item{
\sld
{\tt a} -- Action taken}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The rate 
}%end item
\end{itemize}
}%end item
\divideents{rate}
\item{\vskip -1.9ex 
\index{rate(S, S, A, E)}
\hypertarget{jmarkov.jmdp.CTMDPEv.rate(S, S, A, E)}{\membername{rate}}
{\tt public abstract double\ {\bf rate}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.CTMDPEv.rate(S, S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Rate. Rate of going of reaching state j given that the current state is i, the action taken is a and the event that occurs is e.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt j} -- state to reach}
   \item{
\sld
{\tt a} -- action taken (given)}
   \item{
\sld
{\tt e} -- event that occurs (given)}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Rate 
}%end item
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A)}
\hypertarget{jmarkov.jmdp.CTMDPEv.reachable(S, A)}{\membername{reachable}}
{\tt public abstract jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDPEv.reachable(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.CTMDP}{CTMDP}{\small \refdefined{jmarkov.jmdp.CTMDP}} }

Set of States that can be reached from this state i, after taking the action a.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current State}
   \item{
\sld
{\tt a} -- action taken}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the reachable states. 
}%end item
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A, E)}
\hypertarget{jmarkov.jmdp.CTMDPEv.reachable(S, A, E)}{\membername{reachable}}
{\tt public abstract jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.CTMDPEv.reachable(S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of reachable states from state i given that action a is taken and event e occurs.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of reachable states. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.CTMDP} \textnormal{\small\refdefined{jmarkov.jmdp.CTMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf activeState}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf continuousCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf converter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getAllStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMaxRate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getSteadyStateProbabilities}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf lumpCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf maxRate}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf oneStageReachable}( {\tt jmarkov.basic.States} {\bf initSet} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf rate}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract States {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setConverter}( {\tt CT2DTConverter} {\bf converter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solution {\bf solve}( {\tt double} {\bf interestRate} ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.InfiniteMDP} \textnormal{\small\refdefined{jmarkov.jmdp.InfiniteMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf absorbingStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf explorationTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Actions {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getAllStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractAverageSolver {\bf getDefaultAverageSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractDiscountedSolver {\bf getDefaultDiscountedSolver}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractInfiniteSolver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getNumStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public AbstractInfiniteSolver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf hasAbsorbingState}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf numStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probability}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probabilitySolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf states}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{CTMDPEvA}
\subsection{\label{jmarkov.jmdp.CTMDPEvA}\index{CTMDPEvA}{\bf {\it Class} CTMDPEvA}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.CTMDPEvA}{}\vskip .1in 
This class represents an Infinite horizon, continuous time Markov Decision Process with events where actions depend on events. It allows the definition of events that can occur in a given state and this makes the cost and probability definition easier than in the cases where no events are defined.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class CTMDPEvA
\\ {\bf extends} jmarkov.jmdp.CTMDP
\refdefined{jmarkov.jmdp.CTMDP}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.CTMDPEvA.initSet}{{\bf initSet}} Initail set od States.\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.CTMDPEvA(jmarkov.basic.States)}{{\bf CTMDPEvA(States)}} Creates a new continuous time infinite horizon MDP Problem with events\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.CTMDPEvA.activeEvents(S)}{{\bf activeEvents(S)}} Set of events that are active from state i given that action a is taken.\\
\hyperlink{jmarkov.jmdp.CTMDPEvA.continuousCost(S, A, E)}{{\bf continuousCost(S, A, E)}} Reward obtained continuously in time during the sojourn time in state i until an action a is taken and a transition is triggered.\\
\hyperlink{jmarkov.jmdp.CTMDPEvA.continuousCost(jmarkov.basic.StateEvent, A)}{{\bf continuousCost(StateEvent, A)}} \\
\hyperlink{jmarkov.jmdp.CTMDPEvA.feasibleAct(S)}{{\bf feasibleAct(S)}} Returns the set of actions available at this state.\\
\hyperlink{jmarkov.jmdp.CTMDPEvA.feasibleActions(jmarkov.basic.StateEvent)}{{\bf feasibleActions(StateEvent)}} \\
\hyperlink{jmarkov.jmdp.CTMDPEvA.generate()}{{\bf generate()}} \\
\hyperlink{jmarkov.jmdp.CTMDPEvA.lumpCost(S, A, E)}{{\bf lumpCost(S, A, E)}} Reward instantaneously gained in the moment when action a is taken from state i.\\
\hyperlink{jmarkov.jmdp.CTMDPEvA.lumpCost(jmarkov.basic.StateEvent, A)}{{\bf lumpCost(StateEvent, A)}} \\
\hyperlink{jmarkov.jmdp.CTMDPEvA.rate(S, S, A, E)}{{\bf rate(S, S, A, E)}} Rate.\\
\hyperlink{jmarkov.jmdp.CTMDPEvA.rate(jmarkov.basic.StateEvent, jmarkov.basic.StateEvent, A)}{{\bf rate(StateEvent, StateEvent, A)}} \\
\hyperlink{jmarkov.jmdp.CTMDPEvA.reachable(jmarkov.basic.StateEvent, A)}{{\bf reachable(StateEvent, A)}} \\
\hyperlink{jmarkov.jmdp.CTMDPEvA.reached(S, A, E)}{{\bf reached(S, A, E)}} Set of reachable states from state i given that action a is taken and event e occurs.\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{initSet}
\label{jmarkov.jmdp.CTMDPEvA.initSet}\hypertarget{jmarkov.jmdp.CTMDPEvA.initSet}{protected jmarkov.basic.States {\bf initSet}}
\begin{itemize}
\item{\vskip -.9ex 
Initail set od States.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{CTMDPEvA(States)}
\hypertarget{jmarkov.jmdp.CTMDPEvA(jmarkov.basic.States)}{\membername{CTMDPEvA}}
{\tt public\ {\bf CTMDPEvA}( {\tt jmarkov.basic.States} {\bf initial} )
\label{jmarkov.jmdp.CTMDPEvA(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new continuous time infinite horizon MDP Problem with events
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- set of initial states for the exploration algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{activeEvents(S)}
\hypertarget{jmarkov.jmdp.CTMDPEvA.activeEvents(S)}{\membername{activeEvents}}
{\tt public abstract jmarkov.basic.Events\ {\bf activeEvents}( {\tt jmarkov.basic.State} {\bf i} )
\label{jmarkov.jmdp.CTMDPEvA.activeEvents(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of events that are active from state i given that action a is taken.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of events that can occur 
}%end item
\end{itemize}
}%end item
\divideents{continuousCost}
\item{\vskip -1.9ex 
\index{continuousCost(S, A, E)}
\hypertarget{jmarkov.jmdp.CTMDPEvA.continuousCost(S, A, E)}{\membername{continuousCost}}
{\tt public abstract double\ {\bf continuousCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.CTMDPEvA.continuousCost(S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Reward obtained continuously in time during the sojourn time in state i until an action a is taken and a transition is triggered.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
instanteneous reward. 
}%end item
\end{itemize}
}%end item
\divideents{continuousCost}
\item{\vskip -1.9ex 
\index{continuousCost(StateEvent, A)}
\hypertarget{jmarkov.jmdp.CTMDPEvA.continuousCost(jmarkov.basic.StateEvent, A)}{\membername{continuousCost}}
{\tt public double\ {\bf continuousCost}( {\tt jmarkov.basic.StateEvent} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDPEvA.continuousCost(jmarkov.basic.StateEvent, A)}}%end signature
}%end item
\divideents{feasibleAct}
\item{\vskip -1.9ex 
\index{feasibleAct(S)}
\hypertarget{jmarkov.jmdp.CTMDPEvA.feasibleAct(S)}{\membername{feasibleAct}}
{\tt public abstract jmarkov.basic.Actions\ {\bf feasibleAct}( {\tt jmarkov.basic.State} {\bf i} )
\label{jmarkov.jmdp.CTMDPEvA.feasibleAct(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the set of actions available at this state. The user must implement this method.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of feasible actions 
}%end item
\end{itemize}
}%end item
\divideents{feasibleActions}
\item{\vskip -1.9ex 
\index{feasibleActions(StateEvent)}
\hypertarget{jmarkov.jmdp.CTMDPEvA.feasibleActions(jmarkov.basic.StateEvent)}{\membername{feasibleActions}}
{\tt public jmarkov.basic.Actions\ {\bf feasibleActions}( {\tt jmarkov.basic.StateEvent} {\bf s} )
\label{jmarkov.jmdp.CTMDPEvA.feasibleActions(jmarkov.basic.StateEvent)}}%end signature
}%end item
\divideents{generate}
\item{\vskip -1.9ex 
\index{generate()}
\hypertarget{jmarkov.jmdp.CTMDPEvA.generate()}{\membername{generate}}
{\tt protected abstract jmarkov.basic.StatesSet\ {\bf generate}(  )
\label{jmarkov.jmdp.CTMDPEvA.generate()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
The set of states found. 
}%end item
\end{itemize}
}%end item
\divideents{lumpCost}
\item{\vskip -1.9ex 
\index{lumpCost(S, A, E)}
\hypertarget{jmarkov.jmdp.CTMDPEvA.lumpCost(S, A, E)}{\membername{lumpCost}}
{\tt public abstract double\ {\bf lumpCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.CTMDPEvA.lumpCost(S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Reward instantaneously gained in the moment when action a is taken from state i.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
instanteneous reward. 
}%end item
\end{itemize}
}%end item
\divideents{lumpCost}
\item{\vskip -1.9ex 
\index{lumpCost(StateEvent, A)}
\hypertarget{jmarkov.jmdp.CTMDPEvA.lumpCost(jmarkov.basic.StateEvent, A)}{\membername{lumpCost}}
{\tt public double\ {\bf lumpCost}( {\tt jmarkov.basic.StateEvent} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDPEvA.lumpCost(jmarkov.basic.StateEvent, A)}}%end signature
}%end item
\divideents{rate}
\item{\vskip -1.9ex 
\index{rate(S, S, A, E)}
\hypertarget{jmarkov.jmdp.CTMDPEvA.rate(S, S, A, E)}{\membername{rate}}
{\tt public abstract double\ {\bf rate}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.CTMDPEvA.rate(S, S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Rate. Rate of going of reaching state j given that the current state is i, the action taken is a and the event that occurs is e.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt j} -- state to reach}
   \item{
\sld
{\tt a} -- action taken (given)}
   \item{
\sld
{\tt e} -- event that occurs (given)}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Rate 
}%end item
\end{itemize}
}%end item
\divideents{rate}
\item{\vskip -1.9ex 
\index{rate(StateEvent, StateEvent, A)}
\hypertarget{jmarkov.jmdp.CTMDPEvA.rate(jmarkov.basic.StateEvent, jmarkov.basic.StateEvent, A)}{\membername{rate}}
{\tt public double\ {\bf rate}( {\tt jmarkov.basic.StateEvent} {\bf i},
{\tt jmarkov.basic.StateEvent} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDPEvA.rate(jmarkov.basic.StateEvent, jmarkov.basic.StateEvent, A)}}%end signature
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(StateEvent, A)}
\hypertarget{jmarkov.jmdp.CTMDPEvA.reachable(jmarkov.basic.StateEvent, A)}{\membername{reachable}}
{\tt public jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.StateEvent} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.CTMDPEvA.reachable(jmarkov.basic.StateEvent, A)}}%end signature
}%end item
\divideents{reached}
\item{\vskip -1.9ex 
\index{reached(S, A, E)}
\hypertarget{jmarkov.jmdp.CTMDPEvA.reached(S, A, E)}{\membername{reached}}
{\tt public abstract jmarkov.basic.States\ {\bf reached}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.CTMDPEvA.reached(S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of reachable states from state i given that action a is taken and event e occurs.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of reachable states. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.CTMDP} \textnormal{\small\refdefined{jmarkov.jmdp.CTMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf activeState}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf continuousCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf converter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getAllStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMaxRate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getSteadyStateProbabilities}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf lumpCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf maxRate}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf oneStageReachable}( {\tt jmarkov.basic.States} {\bf initSet} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf rate}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract States {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setConverter}( {\tt CT2DTConverter} {\bf converter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solution {\bf solve}( {\tt double} {\bf interestRate} ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.InfiniteMDP} \textnormal{\small\refdefined{jmarkov.jmdp.InfiniteMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf absorbingStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf explorationTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Actions {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getAllStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractAverageSolver {\bf getDefaultAverageSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractDiscountedSolver {\bf getDefaultDiscountedSolver}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractInfiniteSolver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getNumStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public AbstractInfiniteSolver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf hasAbsorbingState}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf numStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probability}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probabilitySolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf states}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{DTMDP}
\subsection{\label{jmarkov.jmdp.DTMDP}\index{DTMDP}{\bf {\it Class} DTMDP}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.DTMDP}{}\vskip .1in 
This class represents a discrete time infnite horizon MDP problem. It must be extended in order to represent the appropriate structure for each problem. The user must implement at least the functions that have been declared abstract.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver}{solvers.PolicyIterationSolver}} {\small 
\refdefined{jmarkov.jmdp.solvers.PolicyIterationSolver}}%end
} 
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver}{solvers.ValueIterationSolver}} {\small 
\refdefined{jmarkov.jmdp.solvers.ValueIterationSolver}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class DTMDP
\\ {\bf extends} jmarkov.jmdp.InfiniteMDP
\refdefined{jmarkov.jmdp.InfiniteMDP}}}}
\subsubsection{All known subclasses}{StochasticShortestPath\small{\refdefined{jmarkov.jmdp.StochasticShortestPath}}, DTMDPEvA\small{\refdefined{jmarkov.jmdp.DTMDPEvA}}, DTMDPEv\small{\refdefined{jmarkov.jmdp.DTMDPEv}}, CT2DTConverter\small{\refdefined{jmarkov.jmdp.CT2DTConverter}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.DTMDP(S)}{{\bf DTMDP(S)}} Creates a new infinite horizon discrete time (MDP) Problem.\\
\hyperlink{jmarkov.jmdp.DTMDP(jmarkov.basic.States)}{{\bf DTMDP(States)}} Creates a new infinite horizon discrete time (MDP) Problem.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.DTMDP.generate()}{{\bf generate()}} \\
\hyperlink{jmarkov.jmdp.DTMDP.getSteadyStateProbabilities()}{{\bf getSteadyStateProbabilities()}} \\
\hyperlink{jmarkov.jmdp.DTMDP.immediateCost(S, A)}{{\bf immediateCost(S, A)}} Cost incurred when taking action a from state i\\
\hyperlink{jmarkov.jmdp.DTMDP.oneStageReachable(jmarkov.basic.States)}{{\bf oneStageReachable(States)}} TFinds the states reached in one step.\\
\hyperlink{jmarkov.jmdp.DTMDP.prob(S, S, A)}{{\bf prob(S, S, A)}} Probability of going from state i to state j by taking the action a\\
\hyperlink{jmarkov.jmdp.DTMDP.reachable(S, A)}{{\bf reachable(S, A)}} Set of states that can be reached from this state i, after taking the action a.\\
\hyperlink{jmarkov.jmdp.DTMDP.setProbabilitySolver(jmarkov.jmdp.solvers.ProbabilitySolver)}{{\bf setProbabilitySolver(ProbabilitySolver)}} \\
\hyperlink{jmarkov.jmdp.DTMDP.solve(double)}{{\bf solve(double)}} Solves the problem with the given interest rate\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{DTMDP(S)}
\hypertarget{jmarkov.jmdp.DTMDP(S)}{\membername{DTMDP}}
{\tt public\ {\bf DTMDP}( {\tt jmarkov.basic.State} {\bf initial} )
\label{jmarkov.jmdp.DTMDP(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new infinite horizon discrete time (MDP) Problem.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- An initial state for the exploration algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{DTMDP}
\item{\vskip -1.9ex 
\index{DTMDP(States)}
\hypertarget{jmarkov.jmdp.DTMDP(jmarkov.basic.States)}{\membername{DTMDP}}
{\tt public\ {\bf DTMDP}( {\tt jmarkov.basic.States} {\bf initial} )
\label{jmarkov.jmdp.DTMDP(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new infinite horizon discrete time (MDP) Problem.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- set of initial states for the exploration algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{generate()}
\hypertarget{jmarkov.jmdp.DTMDP.generate()}{\membername{generate}}
{\tt protected abstract jmarkov.basic.StatesSet\ {\bf generate}(  )
\label{jmarkov.jmdp.DTMDP.generate()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
The set of states found. 
}%end item
\end{itemize}
}%end item
\divideents{getSteadyStateProbabilities}
\item{\vskip -1.9ex 
\index{getSteadyStateProbabilities()}
\hypertarget{jmarkov.jmdp.DTMDP.getSteadyStateProbabilities()}{\membername{getSteadyStateProbabilities}}
{\tt public jmarkov.basic.ValueFunction\ {\bf getSteadyStateProbabilities}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.DTMDP.getSteadyStateProbabilities()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
a map with the probability for each state. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{immediateCost}
\item{\vskip -1.9ex 
\index{immediateCost(S, A)}
\hypertarget{jmarkov.jmdp.DTMDP.immediateCost(S, A)}{\membername{immediateCost}}
{\tt public abstract double\ {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.DTMDP.immediateCost(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Cost incurred when taking action a from state i
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current State}
   \item{
\sld
{\tt a} -- Current Action}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The cost incurred per transition 
}%end item
\end{itemize}
}%end item
\divideents{oneStageReachable}
\item{\vskip -1.9ex 
\index{oneStageReachable(States)}
\hypertarget{jmarkov.jmdp.DTMDP.oneStageReachable(jmarkov.basic.States)}{\membername{oneStageReachable}}
{\tt protected jmarkov.basic.StatesSet\ {\bf oneStageReachable}( {\tt jmarkov.basic.States} {\bf initSet} )
\label{jmarkov.jmdp.DTMDP.oneStageReachable(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

TFinds the states reached in one step.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initSet} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Set of states reached in one step. 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, S, A)}
\hypertarget{jmarkov.jmdp.DTMDP.prob(S, S, A)}{\membername{prob}}
{\tt public abstract double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.DTMDP.prob(S, S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Probability of going from state i to state j by taking the action a
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current state.}
   \item{
\sld
{\tt j} -- Destination State}
   \item{
\sld
{\tt a} -- Action}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The probability. 
}%end item
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A)}
\hypertarget{jmarkov.jmdp.DTMDP.reachable(S, A)}{\membername{reachable}}
{\tt public abstract jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.DTMDP.reachable(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of states that can be reached from this state i, after taking the action a.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current State}
   \item{
\sld
{\tt a} -- Action taken}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The reachable states. 
}%end item
\end{itemize}
}%end item
\divideents{setProbabilitySolver}
\item{\vskip -1.9ex 
\index{setProbabilitySolver(ProbabilitySolver)}
\hypertarget{jmarkov.jmdp.DTMDP.setProbabilitySolver(jmarkov.jmdp.solvers.ProbabilitySolver)}{\membername{setProbabilitySolver}}
{\tt public void\ {\bf setProbabilitySolver}( {\tt solvers.ProbabilitySolver} {\bf solv} )
\label{jmarkov.jmdp.DTMDP.setProbabilitySolver(jmarkov.jmdp.solvers.ProbabilitySolver)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt solv} -- Sets the solver that solves the steady state probabilities.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve(double)}
\hypertarget{jmarkov.jmdp.DTMDP.solve(double)}{\membername{solve}}
{\tt public final jmarkov.basic.Solution\ {\bf solve}( {\tt double} {\bf interestRate} ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.DTMDP.solve(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Solves the problem with the given interest rate
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt interestRate} -- the interest rate parameter to solve the problem.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The soultion to the problem. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.InfiniteMDP} \textnormal{\small\refdefined{jmarkov.jmdp.InfiniteMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf absorbingStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf explorationTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Actions {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getAllStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractAverageSolver {\bf getDefaultAverageSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractDiscountedSolver {\bf getDefaultDiscountedSolver}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractInfiniteSolver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getNumStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public AbstractInfiniteSolver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf hasAbsorbingState}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf numStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probability}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probabilitySolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf states}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{DTMDPEv}
\subsection{\label{jmarkov.jmdp.DTMDPEv}\index{DTMDPEv}{\bf {\it Class} DTMDPEv}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.DTMDPEv}{}\vskip .1in 
This class represents an infinite horizon, discrete time, Markov Decision Process with events. It allows the definition of events that can occur in a given state and this makes the cost and probability definition easier to define than in the cases where no events are defined.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class DTMDPEv
\\ {\bf extends} jmarkov.jmdp.DTMDP
\refdefined{jmarkov.jmdp.DTMDP}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.DTMDPEv(jmarkov.basic.States)}{{\bf DTMDPEv(States)}} Creates a new infinite horizon discrete time (MDP) Problem with events\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.DTMDPEv.activeEvents(S, A)}{{\bf activeEvents(S, A)}} Set of events that are active from state i given that action a is taken.\\
\hyperlink{jmarkov.jmdp.DTMDPEv.immediateCost(S, A)}{{\bf immediateCost(S, A)}} \\
\hyperlink{jmarkov.jmdp.DTMDPEv.immediateCost(S, A, E)}{{\bf immediateCost(S, A, E)}} Cost incurred received when the current state is i, the action taken is a and event e occurs.\\
\hyperlink{jmarkov.jmdp.DTMDPEv.prob(S, E)}{{\bf prob(S, E)}} Conditional Event probability.\\
\hyperlink{jmarkov.jmdp.DTMDPEv.prob(S, S, A)}{{\bf prob(S, S, A)}} \\
\hyperlink{jmarkov.jmdp.DTMDPEv.prob(S, S, A, E)}{{\bf prob(S, S, A, E)}} Conditional destination probability.\\
\hyperlink{jmarkov.jmdp.DTMDPEv.reachable(S, A)}{{\bf reachable(S, A)}} \\
\hyperlink{jmarkov.jmdp.DTMDPEv.reachable(S, A, E)}{{\bf reachable(S, A, E)}} Set of reachable states from state i given that action a is taken and event e occurs.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{DTMDPEv(States)}
\hypertarget{jmarkov.jmdp.DTMDPEv(jmarkov.basic.States)}{\membername{DTMDPEv}}
{\tt public\ {\bf DTMDPEv}( {\tt jmarkov.basic.States} {\bf initial} )
\label{jmarkov.jmdp.DTMDPEv(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new infinite horizon discrete time (MDP) Problem with events
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- set of initial states for the exploration algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{activeEvents(S, A)}
\hypertarget{jmarkov.jmdp.DTMDPEv.activeEvents(S, A)}{\membername{activeEvents}}
{\tt public abstract jmarkov.basic.Events\ {\bf activeEvents}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.DTMDPEv.activeEvents(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of events that are active from state i given that action a is taken.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of events that can occur 
}%end item
\end{itemize}
}%end item
\divideents{immediateCost}
\item{\vskip -1.9ex 
\index{immediateCost(S, A)}
\hypertarget{jmarkov.jmdp.DTMDPEv.immediateCost(S, A)}{\membername{immediateCost}}
{\tt public abstract double\ {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.DTMDPEv.immediateCost(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.DTMDP}{DTMDP}{\small \refdefined{jmarkov.jmdp.DTMDP}} }

Cost incurred when taking action a from state i
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current State}
   \item{
\sld
{\tt a} -- Current Action}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The cost incurred per transition 
}%end item
\end{itemize}
}%end item
\divideents{immediateCost}
\item{\vskip -1.9ex 
\index{immediateCost(S, A, E)}
\hypertarget{jmarkov.jmdp.DTMDPEv.immediateCost(S, A, E)}{\membername{immediateCost}}
{\tt public abstract double\ {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.DTMDPEv.immediateCost(S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Cost incurred received when the current state is i, the action taken is a and event e occurs.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
reward 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, E)}
\hypertarget{jmarkov.jmdp.DTMDPEv.prob(S, E)}{\membername{prob}}
{\tt public abstract double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.DTMDPEv.prob(S, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Conditional Event probability. Probability that event e occurs given that the current state is i.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Conditional probability 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, S, A)}
\hypertarget{jmarkov.jmdp.DTMDPEv.prob(S, S, A)}{\membername{prob}}
{\tt public abstract double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.DTMDPEv.prob(S, S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.DTMDP}{DTMDP}{\small \refdefined{jmarkov.jmdp.DTMDP}} }

Probability of going from state i to state j by taking the action a
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current state.}
   \item{
\sld
{\tt j} -- Destination State}
   \item{
\sld
{\tt a} -- Action}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The probability. 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, S, A, E)}
\hypertarget{jmarkov.jmdp.DTMDPEv.prob(S, S, A, E)}{\membername{prob}}
{\tt public abstract double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.DTMDPEv.prob(S, S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Conditional destination probability. Probability of reaching state j given that the current state is i, the action taken is a and the event that occurs is e.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt j} -- state to reach}
   \item{
\sld
{\tt a} -- action taken (given)}
   \item{
\sld
{\tt e} -- event that occurs (given)}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Conditional probability 
}%end item
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A)}
\hypertarget{jmarkov.jmdp.DTMDPEv.reachable(S, A)}{\membername{reachable}}
{\tt public abstract jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.DTMDPEv.reachable(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.DTMDP}{DTMDP}{\small \refdefined{jmarkov.jmdp.DTMDP}} }

Set of states that can be reached from this state i, after taking the action a.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current State}
   \item{
\sld
{\tt a} -- Action taken}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The reachable states. 
}%end item
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A, E)}
\hypertarget{jmarkov.jmdp.DTMDPEv.reachable(S, A, E)}{\membername{reachable}}
{\tt public abstract jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.DTMDPEv.reachable(S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of reachable states from state i given that action a is taken and event e occurs.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of reachable states. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.DTMDP} \textnormal{\small\refdefined{jmarkov.jmdp.DTMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getSteadyStateProbabilities}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf oneStageReachable}( {\tt jmarkov.basic.States} {\bf initSet} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract States {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setProbabilitySolver}( {\tt solvers.ProbabilitySolver} {\bf solv} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Solution {\bf solve}( {\tt double} {\bf interestRate} ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.InfiniteMDP} \textnormal{\small\refdefined{jmarkov.jmdp.InfiniteMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf absorbingStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf explorationTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Actions {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getAllStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractAverageSolver {\bf getDefaultAverageSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractDiscountedSolver {\bf getDefaultDiscountedSolver}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractInfiniteSolver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getNumStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public AbstractInfiniteSolver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf hasAbsorbingState}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf numStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probability}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probabilitySolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf states}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{DTMDPEvA}
\subsection{\label{jmarkov.jmdp.DTMDPEvA}\index{DTMDPEvA}{\bf {\it Class} DTMDPEvA}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.DTMDPEvA}{}\vskip .1in 
This class represents an infinite horizon, discrete time, Markov Decision Process with events, where actions depend on events. It allows the definition of events that can occur in a given state and this makes the cost and probability definition easier to define than in the cases where no events are defined.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class DTMDPEvA
\\ {\bf extends} jmarkov.jmdp.DTMDP
\refdefined{jmarkov.jmdp.DTMDP}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.DTMDPEvA(jmarkov.basic.States)}{{\bf DTMDPEvA(States)}} Creates a new infinite horizon discrete time (MDP) Problem with events\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.DTMDPEvA.activeEvents(S, A)}{{\bf activeEvents(S, A)}} Set of events that are active from state i given that action a is taken.\\
\hyperlink{jmarkov.jmdp.DTMDPEvA.feasibleAct(S)}{{\bf feasibleAct(S)}} Returns the set of actions available at this state.\\
\hyperlink{jmarkov.jmdp.DTMDPEvA.feasibleActions(jmarkov.basic.StateEvent)}{{\bf feasibleActions(StateEvent)}} \\
\hyperlink{jmarkov.jmdp.DTMDPEvA.immediateCost(S, A, E)}{{\bf immediateCost(S, A, E)}} Reward received when the current state is i, the action taken is a and event e occurs.\\
\hyperlink{jmarkov.jmdp.DTMDPEvA.immediateCost(jmarkov.basic.StateEvent, A)}{{\bf immediateCost(StateEvent, A)}} \\
\hyperlink{jmarkov.jmdp.DTMDPEvA.prob(S, E)}{{\bf prob(S, E)}} Conditional event probability.\\
\hyperlink{jmarkov.jmdp.DTMDPEvA.prob(S, S, A, E)}{{\bf prob(S, S, A, E)}} Conditional destination probability.\\
\hyperlink{jmarkov.jmdp.DTMDPEvA.prob(jmarkov.basic.StateEvent, jmarkov.basic.StateEvent, A)}{{\bf prob(StateEvent, StateEvent, A)}} \\
\hyperlink{jmarkov.jmdp.DTMDPEvA.reachable(S, A, E)}{{\bf reachable(S, A, E)}} Set of reachable states from state i given that action a is taken and event e occurs.\\
\hyperlink{jmarkov.jmdp.DTMDPEvA.reachable(jmarkov.basic.StateEvent, A)}{{\bf reachable(StateEvent, A)}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{DTMDPEvA(States)}
\hypertarget{jmarkov.jmdp.DTMDPEvA(jmarkov.basic.States)}{\membername{DTMDPEvA}}
{\tt public\ {\bf DTMDPEvA}( {\tt jmarkov.basic.States} {\bf initial} )
\label{jmarkov.jmdp.DTMDPEvA(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new infinite horizon discrete time (MDP) Problem with events
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- set of initial states for the exploration algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{activeEvents(S, A)}
\hypertarget{jmarkov.jmdp.DTMDPEvA.activeEvents(S, A)}{\membername{activeEvents}}
{\tt public abstract jmarkov.basic.Events\ {\bf activeEvents}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.DTMDPEvA.activeEvents(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of events that are active from state i given that action a is taken.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of events that can occur 
}%end item
\end{itemize}
}%end item
\divideents{feasibleAct}
\item{\vskip -1.9ex 
\index{feasibleAct(S)}
\hypertarget{jmarkov.jmdp.DTMDPEvA.feasibleAct(S)}{\membername{feasibleAct}}
{\tt public abstract jmarkov.basic.Actions\ {\bf feasibleAct}( {\tt jmarkov.basic.State} {\bf i} )
\label{jmarkov.jmdp.DTMDPEvA.feasibleAct(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the set of actions available at this state. The user must implement this method.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of feasible actions 
}%end item
\end{itemize}
}%end item
\divideents{feasibleActions}
\item{\vskip -1.9ex 
\index{feasibleActions(StateEvent)}
\hypertarget{jmarkov.jmdp.DTMDPEvA.feasibleActions(jmarkov.basic.StateEvent)}{\membername{feasibleActions}}
{\tt public final jmarkov.basic.Actions\ {\bf feasibleActions}( {\tt jmarkov.basic.StateEvent} {\bf i} )
\label{jmarkov.jmdp.DTMDPEvA.feasibleActions(jmarkov.basic.StateEvent)}}%end signature
}%end item
\divideents{immediateCost}
\item{\vskip -1.9ex 
\index{immediateCost(S, A, E)}
\hypertarget{jmarkov.jmdp.DTMDPEvA.immediateCost(S, A, E)}{\membername{immediateCost}}
{\tt public abstract double\ {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.DTMDPEvA.immediateCost(S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Reward received when the current state is i, the action taken is a and event e occurs.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
reward 
}%end item
\end{itemize}
}%end item
\divideents{immediateCost}
\item{\vskip -1.9ex 
\index{immediateCost(StateEvent, A)}
\hypertarget{jmarkov.jmdp.DTMDPEvA.immediateCost(jmarkov.basic.StateEvent, A)}{\membername{immediateCost}}
{\tt public final double\ {\bf immediateCost}( {\tt jmarkov.basic.StateEvent} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.DTMDPEvA.immediateCost(jmarkov.basic.StateEvent, A)}}%end signature
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, E)}
\hypertarget{jmarkov.jmdp.DTMDPEvA.prob(S, E)}{\membername{prob}}
{\tt public abstract double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.DTMDPEvA.prob(S, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Conditional event probability. Probability that event e occurs given that the current state is i.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Conditional probability 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, S, A, E)}
\hypertarget{jmarkov.jmdp.DTMDPEvA.prob(S, S, A, E)}{\membername{prob}}
{\tt public abstract double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.DTMDPEvA.prob(S, S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Conditional destination probability. Probability of reaching state j given that the current state is i, the action taken is a and the event that occurs is e.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt j} -- state to reach}
   \item{
\sld
{\tt a} -- action taken (given)}
   \item{
\sld
{\tt e} -- event that occurs (given)}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Conditional probability 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(StateEvent, StateEvent, A)}
\hypertarget{jmarkov.jmdp.DTMDPEvA.prob(jmarkov.basic.StateEvent, jmarkov.basic.StateEvent, A)}{\membername{prob}}
{\tt public final double\ {\bf prob}( {\tt jmarkov.basic.StateEvent} {\bf i},
{\tt jmarkov.basic.StateEvent} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.DTMDPEvA.prob(jmarkov.basic.StateEvent, jmarkov.basic.StateEvent, A)}}%end signature
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A, E)}
\hypertarget{jmarkov.jmdp.DTMDPEvA.reachable(S, A, E)}{\membername{reachable}}
{\tt public abstract jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e} )
\label{jmarkov.jmdp.DTMDPEvA.reachable(S, A, E)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of reachable states from state i given that action a is taken and event e occurs.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of reachable states. 
}%end item
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(StateEvent, A)}
\hypertarget{jmarkov.jmdp.DTMDPEvA.reachable(jmarkov.basic.StateEvent, A)}{\membername{reachable}}
{\tt public final jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.StateEvent} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
\label{jmarkov.jmdp.DTMDPEvA.reachable(jmarkov.basic.StateEvent, A)}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.DTMDP} \textnormal{\small\refdefined{jmarkov.jmdp.DTMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getSteadyStateProbabilities}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf oneStageReachable}( {\tt jmarkov.basic.States} {\bf initSet} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract States {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setProbabilitySolver}( {\tt solvers.ProbabilitySolver} {\bf solv} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Solution {\bf solve}( {\tt double} {\bf interestRate} ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.InfiniteMDP} \textnormal{\small\refdefined{jmarkov.jmdp.InfiniteMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf absorbingStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf explorationTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Actions {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getAllStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractAverageSolver {\bf getDefaultAverageSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractDiscountedSolver {\bf getDefaultDiscountedSolver}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractInfiniteSolver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getNumStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public AbstractInfiniteSolver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf hasAbsorbingState}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf numStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probability}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probabilitySolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf states}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{FiniteDP}
\subsection{\label{jmarkov.jmdp.FiniteDP}\index{FiniteDP}{\bf {\it Class} FiniteDP}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.FiniteDP}{}\vskip .1in 
This class should ONLY be used in FINITE horizondeterministic problems. It must be extended in order to represent the appropriate structure for each FINITE Dynamic Programming problem. The user must implement at least the functions that have been declared abstract. Its also necessary to create one of the extensions of the class Solver. By default, the program includes the FiniteSolver class to solve finite horizon problems. PolicyIterationSolver and ValueIterationSolver are only for infinite horizon problems. To solve the problem follow the instructions in each of the solvers instructions.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.FiniteSolver}{solvers.FiniteSolver}} {\small 
\refdefined{jmarkov.jmdp.solvers.FiniteSolver}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class FiniteDP
\\ {\bf extends} jmarkov.jmdp.FiniteMDP
\refdefined{jmarkov.jmdp.FiniteMDP}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.FiniteDP(jmarkov.basic.States, int)}{{\bf FiniteDP(States, int)}} Creates a new FINITE Dynamic Programming (DP) Problem.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.FiniteDP.destination(S, A, int)}{{\bf destination(S, A, int)}} State where the system will end up if action a is taken from state i at time t.\\
\hyperlink{jmarkov.jmdp.FiniteDP.prob(S, S, A, int)}{{\bf prob(S, S, A, int)}} Final function must not be extended or implementes by any user.\\
\hyperlink{jmarkov.jmdp.FiniteDP.reachable(S, A, int)}{{\bf reachable(S, A, int)}} Final function must not be extended by any user.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{FiniteDP(States, int)}
\hypertarget{jmarkov.jmdp.FiniteDP(jmarkov.basic.States, int)}{\membername{FiniteDP}}
{\tt public\ {\bf FiniteDP}( {\tt jmarkov.basic.States} {\bf initial},
{\tt int} {\bf lastStage} )
\label{jmarkov.jmdp.FiniteDP(jmarkov.basic.States, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new FINITE Dynamic Programming (DP) Problem.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- initial set of known states.}
   \item{
\sld
{\tt lastStage} -- number of the last stage.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{destination(S, A, int)}
\hypertarget{jmarkov.jmdp.FiniteDP.destination(S, A, int)}{\membername{destination}}
{\tt public abstract jmarkov.basic.State\ {\bf destination}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteDP.destination(S, A, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

State where the system will end up if action a is taken from state i at time t. The user must implement this method.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current state}
   \item{
\sld
{\tt a} -- Current action}
   \item{
\sld
{\tt t} -- Time stage.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Destination states 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, S, A, int)}
\hypertarget{jmarkov.jmdp.FiniteDP.prob(S, S, A, int)}{\membername{prob}}
{\tt public final double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteDP.prob(S, S, A, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Final function must not be extended or implementes by any user.
}
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A, int)}
\hypertarget{jmarkov.jmdp.FiniteDP.reachable(S, A, int)}{\membername{reachable}}
{\tt public final jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteDP.reachable(S, A, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Final function must not be extended by any user.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.FiniteMDP} \textnormal{\small\refdefined{jmarkov.jmdp.FiniteMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract Actions {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i},
{\tt int} {\bf t} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf finalCost}( {\tt jmarkov.basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getHorizon}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public States {\bf getStates}( {\tt int} {\bf t} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf horizon}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract States {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setHorizon}( {\tt int} {\bf T} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{FiniteMDP}
\subsection{\label{jmarkov.jmdp.FiniteMDP}\index{FiniteMDP}{\bf {\it Class} FiniteMDP}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.FiniteMDP}{}\vskip .1in 
This class should ONLY be used in FINITE horizon problems. It must be extended in order to represent the appropriate structure for each FINITE Dynamic Programming problem. The user must implement at least the functions that have been declared abstract. Its also necessary to create one of the extensions of the class Solver. By default, the program includes the FiniteSolver class to solve finite horizon problems. PolicyIterationSolver and ValueIterationSolver are only for infinite horizon problems. To solve the problem follow the instructions in each of the solvers instructions.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.FiniteSolver}{solvers.FiniteSolver}} {\small 
\refdefined{jmarkov.jmdp.solvers.FiniteSolver}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class FiniteMDP
\\ {\bf extends} jmarkov.jmdp.MDP
\refdefined{jmarkov.jmdp.MDP}}}}
\subsubsection{All known subclasses}{FiniteMDPEv\small{\refdefined{jmarkov.jmdp.FiniteMDPEv}}, FiniteDP\small{\refdefined{jmarkov.jmdp.FiniteDP}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.FiniteMDP.horizon}{{\bf horizon}} Time horizon.\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.FiniteMDP(S, int)}{{\bf FiniteMDP(S, int)}} Creates a finite horizon MDP.\\
\hyperlink{jmarkov.jmdp.FiniteMDP(jmarkov.basic.States, int)}{{\bf FiniteMDP(States, int)}} Creates a new FINITE horizon (MDP) Problem.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.FiniteMDP.feasibleActions(S, int)}{{\bf feasibleActions(S, int)}} Returns the actions available at this state i and at this stage t .\\
\hyperlink{jmarkov.jmdp.FiniteMDP.finalCost(S)}{{\bf finalCost(S)}} This function returns the cost incurred if the last stage ends with the system at state i.\\
\hyperlink{jmarkov.jmdp.FiniteMDP.getDefaultSolver()}{{\bf getDefaultSolver()}} \\
\hyperlink{jmarkov.jmdp.FiniteMDP.getHorizon()}{{\bf getHorizon()}} Returns the time lastStage\\
\hyperlink{jmarkov.jmdp.FiniteMDP.getStates(int)}{{\bf getStates(int)}} All the states that are available at stage t.\\
\hyperlink{jmarkov.jmdp.FiniteMDP.immediateCost(S, A, int)}{{\bf immediateCost(S, A, int)}} This funtion must return the Immediate cost incurred when taking action a from state i\\
\hyperlink{jmarkov.jmdp.FiniteMDP.prob(S, S, A, int)}{{\bf prob(S, S, A, int)}} This is the probability of going from state i to state j by taking the action a at stage t.\\
\hyperlink{jmarkov.jmdp.FiniteMDP.reachable(S, A, int)}{{\bf reachable(S, A, int)}} Set of States that can be reached from this state i, at this stage t, after taking the acton a.\\
\hyperlink{jmarkov.jmdp.FiniteMDP.setHorizon(int)}{{\bf setHorizon(int)}} Sets the time lastStage at which decisions can be taken\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{horizon}
\label{jmarkov.jmdp.FiniteMDP.horizon}\hypertarget{jmarkov.jmdp.FiniteMDP.horizon}{protected int {\bf horizon}}
\begin{itemize}
\item{\vskip -.9ex 
Time horizon. The last stage in the problem.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{FiniteMDP(S, int)}
\hypertarget{jmarkov.jmdp.FiniteMDP(S, int)}{\membername{FiniteMDP}}
{\tt public\ {\bf FiniteMDP}( {\tt jmarkov.basic.State} {\bf initial},
{\tt int} {\bf horizon} )
\label{jmarkov.jmdp.FiniteMDP(S, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a finite horizon MDP.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- a initial state}
   \item{
\sld
{\tt horizon} -- horizon.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{FiniteMDP}
\item{\vskip -1.9ex 
\index{FiniteMDP(States, int)}
\hypertarget{jmarkov.jmdp.FiniteMDP(jmarkov.basic.States, int)}{\membername{FiniteMDP}}
{\tt public\ {\bf FiniteMDP}( {\tt jmarkov.basic.States} {\bf initial},
{\tt int} {\bf horizon} )
\label{jmarkov.jmdp.FiniteMDP(jmarkov.basic.States, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new FINITE horizon (MDP) Problem.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- set of initial states}
   \item{
\sld
{\tt horizon} -- last stage at which actions can be taken}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{feasibleActions(S, int)}
\hypertarget{jmarkov.jmdp.FiniteMDP.feasibleActions(S, int)}{\membername{feasibleActions}}
{\tt public abstract jmarkov.basic.Actions\ {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDP.feasibleActions(S, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the actions available at this state i and at this stage t . The user must implement this method.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current State}
   \item{
\sld
{\tt t} -- Time stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Set of feasible actions. 
}%end item
\end{itemize}
}%end item
\divideents{finalCost}
\item{\vskip -1.9ex 
\index{finalCost(S)}
\hypertarget{jmarkov.jmdp.FiniteMDP.finalCost(S)}{\membername{finalCost}}
{\tt public double\ {\bf finalCost}( {\tt jmarkov.basic.State} {\bf i} )
\label{jmarkov.jmdp.FiniteMDP.finalCost(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This function returns the cost incurred if the last stage ends with the system at state i. The user may extend this method.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Ending state}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Cost. 
}%end item
\end{itemize}
}%end item
\divideents{getDefaultSolver}
\item{\vskip -1.9ex 
\index{getDefaultSolver()}
\hypertarget{jmarkov.jmdp.FiniteMDP.getDefaultSolver()}{\membername{getDefaultSolver}}
{\tt protected abstract solvers.Solver\ {\bf getDefaultSolver}(  )
\label{jmarkov.jmdp.FiniteMDP.getDefaultSolver()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.MDP}{MDP}{\small \refdefined{jmarkov.jmdp.MDP}} }

The class that extends MDP must define the default solver to use.
}
\item{{\bf Returns} -- 
the solver to use for this problem. 
}%end item
\end{itemize}
}%end item
\divideents{getHorizon}
\item{\vskip -1.9ex 
\index{getHorizon()}
\hypertarget{jmarkov.jmdp.FiniteMDP.getHorizon()}{\membername{getHorizon}}
{\tt public int\ {\bf getHorizon}(  )
\label{jmarkov.jmdp.FiniteMDP.getHorizon()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the time lastStage
}
\item{{\bf Returns} -- 
Time horizon 
}%end item
\end{itemize}
}%end item
\divideents{getStates}
\item{\vskip -1.9ex 
\index{getStates(int)}
\hypertarget{jmarkov.jmdp.FiniteMDP.getStates(int)}{\membername{getStates}}
{\tt public jmarkov.basic.States\ {\bf getStates}( {\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDP.getStates(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

All the states that are available at stage t.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt t} -- time stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
States available at stage t. 
}%end item
\end{itemize}
}%end item
\divideents{immediateCost}
\item{\vskip -1.9ex 
\index{immediateCost(S, A, int)}
\hypertarget{jmarkov.jmdp.FiniteMDP.immediateCost(S, A, int)}{\membername{immediateCost}}
{\tt public abstract double\ {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDP.immediateCost(S, A, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This funtion must return the Immediate cost incurred when taking action a from state i
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current state}
   \item{
\sld
{\tt a} -- Action}
   \item{
\sld
{\tt t} -- Current time stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Cost value 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, S, A, int)}
\hypertarget{jmarkov.jmdp.FiniteMDP.prob(S, S, A, int)}{\membername{prob}}
{\tt public abstract double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDP.prob(S, S, A, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This is the probability of going from state i to state j by taking the action a at stage t.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current state}
   \item{
\sld
{\tt j} -- Destination state}
   \item{
\sld
{\tt a} -- Action taken}
   \item{
\sld
{\tt t} -- Current time stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Probability 
}%end item
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A, int)}
\hypertarget{jmarkov.jmdp.FiniteMDP.reachable(S, A, int)}{\membername{reachable}}
{\tt public abstract jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDP.reachable(S, A, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of States that can be reached from this state i, at this stage t, after taking the acton a. The user must implement this method.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current state}
   \item{
\sld
{\tt a} -- Action taken}
   \item{
\sld
{\tt t} -- Time stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Set of reachable states. 
}%end item
\end{itemize}
}%end item
\divideents{setHorizon}
\item{\vskip -1.9ex 
\index{setHorizon(int)}
\hypertarget{jmarkov.jmdp.FiniteMDP.setHorizon(int)}{\membername{setHorizon}}
{\tt protected void\ {\bf setHorizon}( {\tt int} {\bf T} )
\label{jmarkov.jmdp.FiniteMDP.setHorizon(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the time lastStage at which decisions can be taken
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{FiniteMDPEv}
\subsection{\label{jmarkov.jmdp.FiniteMDPEv}\index{FiniteMDPEv}{\bf {\it Class} FiniteMDPEv}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.FiniteMDPEv}{}\vskip .1in 
This class represents a finite horizon discrete time MDP with events.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class FiniteMDPEv
\\ {\bf extends} jmarkov.jmdp.FiniteMDP
\refdefined{jmarkov.jmdp.FiniteMDP}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.FiniteMDPEv(jmarkov.basic.States, int)}{{\bf FiniteMDPEv(States, int)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.FiniteMDPEv.activeEvents(S, A, int)}{{\bf activeEvents(S, A, int)}} Set of events that are active from state i given that action a is taken.\\
\hyperlink{jmarkov.jmdp.FiniteMDPEv.immediateCost(S, A, E, int)}{{\bf immediateCost(S, A, E, int)}} Reward received when the current state is i, the action taken is a and event e occurs.\\
\hyperlink{jmarkov.jmdp.FiniteMDPEv.immediateCost(S, A, int)}{{\bf immediateCost(S, A, int)}} \\
\hyperlink{jmarkov.jmdp.FiniteMDPEv.prob(S, E, int)}{{\bf prob(S, E, int)}} Conditional probability.\\
\hyperlink{jmarkov.jmdp.FiniteMDPEv.prob(S, S, A, E, int)}{{\bf prob(S, S, A, E, int)}} Conditional probability.\\
\hyperlink{jmarkov.jmdp.FiniteMDPEv.prob(S, S, A, int)}{{\bf prob(S, S, A, int)}} \\
\hyperlink{jmarkov.jmdp.FiniteMDPEv.reachable(S, A, E, int)}{{\bf reachable(S, A, E, int)}} Set of reachable states from state i given that action a is taken and event e occurs.\\
\hyperlink{jmarkov.jmdp.FiniteMDPEv.reachable(S, A, int)}{{\bf reachable(S, A, int)}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{FiniteMDPEv(States, int)}
\hypertarget{jmarkov.jmdp.FiniteMDPEv(jmarkov.basic.States, int)}{\membername{FiniteMDPEv}}
{\tt public\ {\bf FiniteMDPEv}( {\tt jmarkov.basic.States} {\bf initial},
{\tt int} {\bf horizon} )
\label{jmarkov.jmdp.FiniteMDPEv(jmarkov.basic.States, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- }
   \item{
\sld
{\tt horizon} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{activeEvents(S, A, int)}
\hypertarget{jmarkov.jmdp.FiniteMDPEv.activeEvents(S, A, int)}{\membername{activeEvents}}
{\tt public abstract jmarkov.basic.Events\ {\bf activeEvents}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDPEv.activeEvents(S, A, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of events that are active from state i given that action a is taken.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt t} -- current stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of events that can occur 
}%end item
\end{itemize}
}%end item
\divideents{immediateCost}
\item{\vskip -1.9ex 
\index{immediateCost(S, A, E, int)}
\hypertarget{jmarkov.jmdp.FiniteMDPEv.immediateCost(S, A, E, int)}{\membername{immediateCost}}
{\tt public abstract double\ {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDPEv.immediateCost(S, A, E, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Reward received when the current state is i, the action taken is a and event e occurs.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
   \item{
\sld
{\tt t} -- current stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
reward 
}%end item
\end{itemize}
}%end item
\divideents{immediateCost}
\item{\vskip -1.9ex 
\index{immediateCost(S, A, int)}
\hypertarget{jmarkov.jmdp.FiniteMDPEv.immediateCost(S, A, int)}{\membername{immediateCost}}
{\tt public abstract double\ {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDPEv.immediateCost(S, A, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.FiniteMDP}{FiniteMDP}{\small \refdefined{jmarkov.jmdp.FiniteMDP}} }

This funtion must return the Immediate cost incurred when taking action a from state i
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current state}
   \item{
\sld
{\tt a} -- Action}
   \item{
\sld
{\tt t} -- Current time stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Cost value 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, E, int)}
\hypertarget{jmarkov.jmdp.FiniteMDPEv.prob(S, E, int)}{\membername{prob}}
{\tt public abstract double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Event} {\bf e},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDPEv.prob(S, E, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Conditional probability. Probability that event e occurs given that the current state is i.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt e} -- event that occurs}
   \item{
\sld
{\tt t} -- current stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Conditional probability 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, S, A, E, int)}
\hypertarget{jmarkov.jmdp.FiniteMDPEv.prob(S, S, A, E, int)}{\membername{prob}}
{\tt public abstract double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDPEv.prob(S, S, A, E, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Conditional probability. Probability of reaching state j given that the current state is i, the action taken is a and the event that occurs is e.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt j} -- state to reach}
   \item{
\sld
{\tt a} -- action taken (given)}
   \item{
\sld
{\tt e} -- event that occurs (given)}
   \item{
\sld
{\tt t} -- current stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
conditional probability 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(S, S, A, int)}
\hypertarget{jmarkov.jmdp.FiniteMDPEv.prob(S, S, A, int)}{\membername{prob}}
{\tt public abstract double\ {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDPEv.prob(S, S, A, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.FiniteMDP}{FiniteMDP}{\small \refdefined{jmarkov.jmdp.FiniteMDP}} }

This is the probability of going from state i to state j by taking the action a at stage t.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current state}
   \item{
\sld
{\tt j} -- Destination state}
   \item{
\sld
{\tt a} -- Action taken}
   \item{
\sld
{\tt t} -- Current time stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Probability 
}%end item
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A, E, int)}
\hypertarget{jmarkov.jmdp.FiniteMDPEv.reachable(S, A, E, int)}{\membername{reachable}}
{\tt public abstract jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt jmarkov.basic.Event} {\bf e},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDPEv.reachable(S, A, E, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Set of reachable states from state i given that action a is taken and event e occurs.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- current state}
   \item{
\sld
{\tt a} -- action taken}
   \item{
\sld
{\tt e} -- event that occurs}
   \item{
\sld
{\tt t} -- current stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of reachable states. 
}%end item
\end{itemize}
}%end item
\divideents{reachable}
\item{\vskip -1.9ex 
\index{reachable(S, A, int)}
\hypertarget{jmarkov.jmdp.FiniteMDPEv.reachable(S, A, int)}{\membername{reachable}}
{\tt public abstract jmarkov.basic.States\ {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
\label{jmarkov.jmdp.FiniteMDPEv.reachable(S, A, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.FiniteMDP}{FiniteMDP}{\small \refdefined{jmarkov.jmdp.FiniteMDP}} }

Set of States that can be reached from this state i, at this stage t, after taking the acton a. The user must implement this method.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current state}
   \item{
\sld
{\tt a} -- Action taken}
   \item{
\sld
{\tt t} -- Time stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Set of reachable states. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.FiniteMDP} \textnormal{\small\refdefined{jmarkov.jmdp.FiniteMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract Actions {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i},
{\tt int} {\bf t} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf finalCost}( {\tt jmarkov.basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getHorizon}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public States {\bf getStates}( {\tt int} {\bf t} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf horizon}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract States {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setHorizon}( {\tt int} {\bf T} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{InfiniteMDP}
\subsection{\label{jmarkov.jmdp.InfiniteMDP}\index{InfiniteMDP}{\bf {\it Class} InfiniteMDP}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.InfiniteMDP}{}\vskip .1in 
This class is a structural class and is. It represents a general Infinite horizon MDP problem. It is extended for discrte and continuous problems.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver}{solvers.PolicyIterationSolver}} {\small 
\refdefined{jmarkov.jmdp.solvers.PolicyIterationSolver}}%end
} 
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver}{solvers.ValueIterationSolver}} {\small 
\refdefined{jmarkov.jmdp.solvers.ValueIterationSolver}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class InfiniteMDP
\\ {\bf extends} jmarkov.jmdp.MDP
\refdefined{jmarkov.jmdp.MDP}}}}
\subsubsection{All known subclasses}{StochasticShortestPath\small{\refdefined{jmarkov.jmdp.StochasticShortestPath}}, DTMDPEvA\small{\refdefined{jmarkov.jmdp.DTMDPEvA}}, DTMDPEv\small{\refdefined{jmarkov.jmdp.DTMDPEv}}, DTMDP\small{\refdefined{jmarkov.jmdp.DTMDP}}, CTMDPEvA\small{\refdefined{jmarkov.jmdp.CTMDPEvA}}, CTMDPEv\small{\refdefined{jmarkov.jmdp.CTMDPEv}}, CTMDP\small{\refdefined{jmarkov.jmdp.CTMDP}}, CT2DTConverter\small{\refdefined{jmarkov.jmdp.CT2DTConverter}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.InfiniteMDP.absorbingStates}{{\bf absorbingStates}} Set of absorving states.\\
\hyperlink{jmarkov.jmdp.InfiniteMDP.explorationTime}{{\bf explorationTime}} Time used to explore the system.\\
\hyperlink{jmarkov.jmdp.InfiniteMDP.hasAbsorbingState}{{\bf hasAbsorbingState}} Whether an absorving state was found\\
\hyperlink{jmarkov.jmdp.InfiniteMDP.numStates}{{\bf numStates}} Number of states.\\
\hyperlink{jmarkov.jmdp.InfiniteMDP.probability}{{\bf probability}} The value function\\
\hyperlink{jmarkov.jmdp.InfiniteMDP.probabilitySolver}{{\bf probabilitySolver}} Idiotic solver that was of course not needed since JMarkov can handle the job\\
\hyperlink{jmarkov.jmdp.InfiniteMDP.states}{{\bf states}} set of states\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.InfiniteMDP(jmarkov.basic.States)}{{\bf InfiniteMDP(States)}} Creates a new INFINITE Dynamic Programming (DP) Problem.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.InfiniteMDP.feasibleActions(S)}{{\bf feasibleActions(S)}} Returns the set of actions available at this state.\\
\hyperlink{jmarkov.jmdp.InfiniteMDP.generate()}{{\bf generate()}} \\
\hyperlink{jmarkov.jmdp.InfiniteMDP.getAllStates()}{{\bf getAllStates()}} Complete set of states explored\\
\hyperlink{jmarkov.jmdp.InfiniteMDP.getDefaultAverageSolver()}{{\bf getDefaultAverageSolver()}} \\
\hyperlink{jmarkov.jmdp.InfiniteMDP.getDefaultDiscountedSolver(double)}{{\bf getDefaultDiscountedSolver(double)}} \\
\hyperlink{jmarkov.jmdp.InfiniteMDP.getDefaultSolver()}{{\bf getDefaultSolver()}} \\
\hyperlink{jmarkov.jmdp.InfiniteMDP.getNumStates()}{{\bf getNumStates()}} Returns the number of states in the model.\\
\hyperlink{jmarkov.jmdp.InfiniteMDP.getSolver()}{{\bf getSolver()}} \\
\hyperlink{jmarkov.jmdp.InfiniteMDP.setInterestRate(double)}{{\bf setInterestRate(double)}} Sets the interest rate to be used in the problem solving if the objective is to minimze the discounted cost.\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{states}
\label{jmarkov.jmdp.InfiniteMDP.states}\hypertarget{jmarkov.jmdp.InfiniteMDP.states}{protected jmarkov.basic.StatesSet {\bf states}}
\begin{itemize}
\item{\vskip -.9ex 
set of states}
\end{itemize}
}
\item{
\index{probability}
\label{jmarkov.jmdp.InfiniteMDP.probability}\hypertarget{jmarkov.jmdp.InfiniteMDP.probability}{protected jmarkov.basic.ValueFunction {\bf probability}}
\begin{itemize}
\item{\vskip -.9ex 
The value function}
\end{itemize}
}
\item{
\index{probabilitySolver}
\label{jmarkov.jmdp.InfiniteMDP.probabilitySolver}\hypertarget{jmarkov.jmdp.InfiniteMDP.probabilitySolver}{protected solvers.ProbabilitySolver {\bf probabilitySolver}}
\begin{itemize}
\item{\vskip -.9ex 
Idiotic solver that was of course not needed since JMarkov can handle the job}
\end{itemize}
}
\item{
\index{hasAbsorbingState}
\label{jmarkov.jmdp.InfiniteMDP.hasAbsorbingState}\hypertarget{jmarkov.jmdp.InfiniteMDP.hasAbsorbingState}{protected boolean {\bf hasAbsorbingState}}
\begin{itemize}
\item{\vskip -.9ex 
Whether an absorving state was found}
\end{itemize}
}
\item{
\index{absorbingStates}
\label{jmarkov.jmdp.InfiniteMDP.absorbingStates}\hypertarget{jmarkov.jmdp.InfiniteMDP.absorbingStates}{protected jmarkov.basic.States {\bf absorbingStates}}
\begin{itemize}
\item{\vskip -.9ex 
Set of absorving states.}
\end{itemize}
}
\item{
\index{explorationTime}
\label{jmarkov.jmdp.InfiniteMDP.explorationTime}\hypertarget{jmarkov.jmdp.InfiniteMDP.explorationTime}{protected long {\bf explorationTime}}
\begin{itemize}
\item{\vskip -.9ex 
Time used to explore the system.}
\end{itemize}
}
\item{
\index{numStates}
\label{jmarkov.jmdp.InfiniteMDP.numStates}\hypertarget{jmarkov.jmdp.InfiniteMDP.numStates}{protected int {\bf numStates}}
\begin{itemize}
\item{\vskip -.9ex 
Number of states. Set when calling generate.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{InfiniteMDP(States)}
\hypertarget{jmarkov.jmdp.InfiniteMDP(jmarkov.basic.States)}{\membername{InfiniteMDP}}
{\tt public\ {\bf InfiniteMDP}( {\tt jmarkov.basic.States} {\bf initial} )
\label{jmarkov.jmdp.InfiniteMDP(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new INFINITE Dynamic Programming (DP) Problem.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- set of initial states for the exploration algorithm}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{feasibleActions(S)}
\hypertarget{jmarkov.jmdp.InfiniteMDP.feasibleActions(S)}{\membername{feasibleActions}}
{\tt public abstract jmarkov.basic.Actions\ {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i} )
\label{jmarkov.jmdp.InfiniteMDP.feasibleActions(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the set of actions available at this state.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current State}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
set of Actions that can be taken at this state. 
}%end item
\end{itemize}
}%end item
\divideents{generate}
\item{\vskip -1.9ex 
\index{generate()}
\hypertarget{jmarkov.jmdp.InfiniteMDP.generate()}{\membername{generate}}
{\tt protected abstract jmarkov.basic.StatesSet\ {\bf generate}(  )
\label{jmarkov.jmdp.InfiniteMDP.generate()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
The set of states found. 
}%end item
\end{itemize}
}%end item
\divideents{getAllStates}
\item{\vskip -1.9ex 
\index{getAllStates()}
\hypertarget{jmarkov.jmdp.InfiniteMDP.getAllStates()}{\membername{getAllStates}}
{\tt public jmarkov.basic.StatesSet\ {\bf getAllStates}(  )
\label{jmarkov.jmdp.InfiniteMDP.getAllStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Complete set of states explored
}
\item{{\bf Returns} -- 
set of states explored 
}%end item
\end{itemize}
}%end item
\divideents{getDefaultAverageSolver}
\item{\vskip -1.9ex 
\index{getDefaultAverageSolver()}
\hypertarget{jmarkov.jmdp.InfiniteMDP.getDefaultAverageSolver()}{\membername{getDefaultAverageSolver}}
{\tt protected solvers.AbstractAverageSolver\ {\bf getDefaultAverageSolver}(  )
\label{jmarkov.jmdp.InfiniteMDP.getDefaultAverageSolver()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.MDP.getDefaultSolver()}{MDP.getDefaultSolver()}} {\small 
\refdefined{jmarkov.jmdp.MDP.getDefaultSolver()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getDefaultDiscountedSolver}
\item{\vskip -1.9ex 
\index{getDefaultDiscountedSolver(double)}
\hypertarget{jmarkov.jmdp.InfiniteMDP.getDefaultDiscountedSolver(double)}{\membername{getDefaultDiscountedSolver}}
{\tt protected solvers.AbstractDiscountedSolver\ {\bf getDefaultDiscountedSolver}( {\tt double} {\bf interestRate} )
\label{jmarkov.jmdp.InfiniteMDP.getDefaultDiscountedSolver(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.MDP.getDefaultSolver()}{MDP.getDefaultSolver()}} {\small 
\refdefined{jmarkov.jmdp.MDP.getDefaultSolver()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getDefaultSolver}
\item{\vskip -1.9ex 
\index{getDefaultSolver()}
\hypertarget{jmarkov.jmdp.InfiniteMDP.getDefaultSolver()}{\membername{getDefaultSolver}}
{\tt protected abstract solvers.Solver\ {\bf getDefaultSolver}(  )
\label{jmarkov.jmdp.InfiniteMDP.getDefaultSolver()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.MDP}{MDP}{\small \refdefined{jmarkov.jmdp.MDP}} }

The class that extends MDP must define the default solver to use.
}
\item{{\bf Returns} -- 
the solver to use for this problem. 
}%end item
\end{itemize}
}%end item
\divideents{getNumStates}
\item{\vskip -1.9ex 
\index{getNumStates()}
\hypertarget{jmarkov.jmdp.InfiniteMDP.getNumStates()}{\membername{getNumStates}}
{\tt public final int\ {\bf getNumStates}(  )
\label{jmarkov.jmdp.InfiniteMDP.getNumStates()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of states in the model. It causes the model to be generated.
}
\item{{\bf Returns} -- 
The number of ststes in the system. 
}%end item
\end{itemize}
}%end item
\divideents{getSolver}
\item{\vskip -1.9ex 
\index{getSolver()}
\hypertarget{jmarkov.jmdp.InfiniteMDP.getSolver()}{\membername{getSolver}}
{\tt public solvers.Solver\ {\bf getSolver}(  )
\label{jmarkov.jmdp.InfiniteMDP.getSolver()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the solver. 
}%end item
\end{itemize}
}%end item
\divideents{setInterestRate}
\item{\vskip -1.9ex 
\index{setInterestRate(double)}
\hypertarget{jmarkov.jmdp.InfiniteMDP.setInterestRate(double)}{\membername{setInterestRate}}
{\tt protected void\ {\bf setInterestRate}( {\tt double} {\bf interestRate} )
\label{jmarkov.jmdp.InfiniteMDP.setInterestRate(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the interest rate to be used in the problem solving if the objective is to minimze the discounted cost.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt interestRate} -- effective interest rate}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MDP}
\subsection{\label{jmarkov.jmdp.MDP}\index{MDP}{\bf {\it Class} MDP}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.MDP}{}\vskip .1in 
This class is the main framework to build a Dynamic Programming Problem. Its initially created to work over Markov Decision Problems which imply random probabilities but can easily be worked out for deterministic problems if the probabilities are set to one. This class should not me extended directly on problems. The default package has FiniteMDP and InfiniteMDP classes that are intended to be extended on problems. See the examples for a clearer reference.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.jmdp.FiniteMDP}{FiniteMDP}} {\small 
\refdefined{jmarkov.jmdp.FiniteMDP}}%end
} 
\item{ {\tt \hyperlink{jmarkov.jmdp.DTMDP}{DTMDP}} {\small 
\refdefined{jmarkov.jmdp.DTMDP}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class MDP
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}}}}
\subsubsection{All known subclasses}{StochasticShortestPath\small{\refdefined{jmarkov.jmdp.StochasticShortestPath}}, InfiniteMDP\small{\refdefined{jmarkov.jmdp.InfiniteMDP}}, FiniteMDPEv\small{\refdefined{jmarkov.jmdp.FiniteMDPEv}}, FiniteMDP\small{\refdefined{jmarkov.jmdp.FiniteMDP}}, FiniteDP\small{\refdefined{jmarkov.jmdp.FiniteDP}}, DTMDPEvA\small{\refdefined{jmarkov.jmdp.DTMDPEvA}}, DTMDPEv\small{\refdefined{jmarkov.jmdp.DTMDPEv}}, DTMDP\small{\refdefined{jmarkov.jmdp.DTMDP}}, CTMDPEvA\small{\refdefined{jmarkov.jmdp.CTMDPEvA}}, CTMDPEv\small{\refdefined{jmarkov.jmdp.CTMDPEv}}, CTMDP\small{\refdefined{jmarkov.jmdp.CTMDP}}, CT2DTConverter\small{\refdefined{jmarkov.jmdp.CT2DTConverter}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.MDP.finite}{{\bf finite}} States whether the problem is a finite horizon problem or not.\\
\hyperlink{jmarkov.jmdp.MDP.initial}{{\bf initial}} Set of initial states.\\
\hyperlink{jmarkov.jmdp.MDP.reporter}{{\bf reporter}} Reporter used for debug information.\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.MDP()}{{\bf MDP()}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.MDP.debug(int, java.lang.String)}{{\bf debug(int, String)}} Prints a message in the reporter.\\
\hyperlink{jmarkov.jmdp.MDP.debug(int, java.lang.String, boolean)}{{\bf debug(int, String, boolean)}} Prints debug information in the reporter.\\
\hyperlink{jmarkov.jmdp.MDP.debug(int, java.lang.String, boolean, boolean)}{{\bf debug(int, String, boolean, boolean)}} Prints debug information in the reporter.\\
\hyperlink{jmarkov.jmdp.MDP.getDebugLevel()}{{\bf getDebugLevel()}} Gets the current debug level.\\
\hyperlink{jmarkov.jmdp.MDP.getDefaultSolver()}{{\bf getDefaultSolver()}} The class that extends MDP must define the default solver to use.\\
\hyperlink{jmarkov.jmdp.MDP.getOptimalPolicy()}{{\bf getOptimalPolicy()}} Returns the optimal policy.\\
\hyperlink{jmarkov.jmdp.MDP.getOptimalValueFunction()}{{\bf getOptimalValueFunction()}} Returns the optimal ValueFunction.\\
\hyperlink{jmarkov.jmdp.MDP.getReporter()}{{\bf getReporter()}} \\
\hyperlink{jmarkov.jmdp.MDP.getSolver()}{{\bf getSolver()}} \\
\hyperlink{jmarkov.jmdp.MDP.isFinite()}{{\bf isFinite()}} \\
\hyperlink{jmarkov.jmdp.MDP.isSolved()}{{\bf isSolved()}} Indicates if the problems has been solved\\
\hyperlink{jmarkov.jmdp.MDP.operation(double, double)}{{\bf operation(double, double)}} The Operator between present and future costs.\\
\hyperlink{jmarkov.jmdp.MDP.printSolution()}{{\bf printSolution()}} Prints the solution to Standard output.\\
\hyperlink{jmarkov.jmdp.MDP.printSolution(java.io.PrintWriter)}{{\bf printSolution(PrintWriter)}} Prints the solution to the given PrintWriter\\
\hyperlink{jmarkov.jmdp.MDP.setDebugLevel(int)}{{\bf setDebugLevel(int)}} Sets teh current level\\
\hyperlink{jmarkov.jmdp.MDP.setReporter(jmarkov.DebugReporter)}{{\bf setReporter(DebugReporter)}} \\
\hyperlink{jmarkov.jmdp.MDP.setSolver(jmarkov.jmdp.solvers.Solver)}{{\bf setSolver(Solver)}} \\
\hyperlink{jmarkov.jmdp.MDP.solve()}{{\bf solve()}} Solves the problem.\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{finite}
\label{jmarkov.jmdp.MDP.finite}\hypertarget{jmarkov.jmdp.MDP.finite}{protected boolean {\bf finite}}
\begin{itemize}
\item{\vskip -.9ex 
States whether the problem is a finite horizon problem or not.}
\end{itemize}
}
\item{
\index{initial}
\label{jmarkov.jmdp.MDP.initial}\hypertarget{jmarkov.jmdp.MDP.initial}{protected jmarkov.basic.States {\bf initial}}
\begin{itemize}
\item{\vskip -.9ex 
Set of initial states.}
\end{itemize}
}
\item{
\index{reporter}
\label{jmarkov.jmdp.MDP.reporter}\hypertarget{jmarkov.jmdp.MDP.reporter}{protected jmarkov.DebugReporter {\bf reporter}}
\begin{itemize}
\item{\vskip -.9ex 
Reporter used for debug information.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MDP()}
\hypertarget{jmarkov.jmdp.MDP()}{\membername{MDP}}
{\tt public\ {\bf MDP}(  )
\label{jmarkov.jmdp.MDP()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{debug(int, String)}
\hypertarget{jmarkov.jmdp.MDP.debug(int, java.lang.String)}{\membername{debug}}
{\tt public void\ {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
\label{jmarkov.jmdp.MDP.debug(int, java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints a message in the reporter.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- maximum debug level at which to show message}
   \item{
\sld
{\tt message} -- message}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.DebugReporter}{jmarkov.DebugReporter}} {\small 
\refdefined{jmarkov.DebugReporter}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{debug}
\item{\vskip -1.9ex 
\index{debug(int, String, boolean)}
\hypertarget{jmarkov.jmdp.MDP.debug(int, java.lang.String, boolean)}{\membername{debug}}
{\tt public void\ {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
\label{jmarkov.jmdp.MDP.debug(int, java.lang.String, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints debug information in the reporter.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- the level for the info}
   \item{
\sld
{\tt s} -- Message}
   \item{
\sld
{\tt newline} -- true if a new line is to be inserted}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.DebugReporter}{jmarkov.DebugReporter}} {\small 
\refdefined{jmarkov.DebugReporter}}%end
}
\item{ {\tt \hyperlink{jmarkov.DebugReporter.debug(int, java.lang.String, boolean)}{jmarkov.DebugReporter.debug(int,\allowbreak String,\allowbreak boolean)}} {\small 
\refdefined{jmarkov.DebugReporter.debug(int, java.lang.String, boolean)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{debug}
\item{\vskip -1.9ex 
\index{debug(int, String, boolean, boolean)}
\hypertarget{jmarkov.jmdp.MDP.debug(int, java.lang.String, boolean, boolean)}{\membername{debug}}
{\tt public void\ {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
\label{jmarkov.jmdp.MDP.debug(int, java.lang.String, boolean, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints debug information in the reporter.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- the level for the info}
   \item{
\sld
{\tt s} -- Message}
   \item{
\sld
{\tt newline} -- true if a new line is to be inserted}
   \item{
\sld
{\tt indent} -- true if the info is indented according to level}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.DebugReporter}{jmarkov.DebugReporter}} {\small 
\refdefined{jmarkov.DebugReporter}}%end
}
\item{ {\tt \hyperlink{jmarkov.DebugReporter.debug(int, java.lang.String, boolean, boolean)}{jmarkov.DebugReporter.debug(int,\allowbreak String,\allowbreak boolean,\allowbreak boolean)}} {\small 
\refdefined{jmarkov.DebugReporter.debug(int, java.lang.String, boolean, boolean)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getDebugLevel}
\item{\vskip -1.9ex 
\index{getDebugLevel()}
\hypertarget{jmarkov.jmdp.MDP.getDebugLevel()}{\membername{getDebugLevel}}
{\tt public int\ {\bf getDebugLevel}(  )
\label{jmarkov.jmdp.MDP.getDebugLevel()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the current debug level.
}
\item{{\bf Returns} -- 
The current debug level 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.DebugReporter}{jmarkov.DebugReporter}} {\small 
\refdefined{jmarkov.DebugReporter}}%end
}
\item{ {\tt \hyperlink{jmarkov.DebugReporter.getDebugLevel()}{jmarkov.DebugReporter.getDebugLevel()}} {\small 
\refdefined{jmarkov.DebugReporter.getDebugLevel()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getDefaultSolver}
\item{\vskip -1.9ex 
\index{getDefaultSolver()}
\hypertarget{jmarkov.jmdp.MDP.getDefaultSolver()}{\membername{getDefaultSolver}}
{\tt protected abstract solvers.Solver\ {\bf getDefaultSolver}(  )
\label{jmarkov.jmdp.MDP.getDefaultSolver()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The class that extends MDP must define the default solver to use.
}
\item{{\bf Returns} -- 
the solver to use for this problem. 
}%end item
\end{itemize}
}%end item
\divideents{getOptimalPolicy}
\item{\vskip -1.9ex 
\index{getOptimalPolicy()}
\hypertarget{jmarkov.jmdp.MDP.getOptimalPolicy()}{\membername{getOptimalPolicy}}
{\tt public final jmarkov.basic.Policy\ {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.MDP.getOptimalPolicy()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the optimal policy. This function should be called only AFTER solve has been called.
}
\item{{\bf Returns} -- 
The optimal policy. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- Exception thrown if a solution cannot be found}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getOptimalValueFunction}
\item{\vskip -1.9ex 
\index{getOptimalValueFunction()}
\hypertarget{jmarkov.jmdp.MDP.getOptimalValueFunction()}{\membername{getOptimalValueFunction}}
{\tt public jmarkov.basic.ValueFunction\ {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.MDP.getOptimalValueFunction()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the optimal ValueFunction. This causes the problem to be solved if it has not been solved.
}
\item{{\bf Returns} -- 
Returns the valueFunction. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- This exception is thrown if a solution cannot be found.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getReporter}
\item{\vskip -1.9ex 
\index{getReporter()}
\hypertarget{jmarkov.jmdp.MDP.getReporter()}{\membername{getReporter}}
{\tt public jmarkov.DebugReporter\ {\bf getReporter}(  )
\label{jmarkov.jmdp.MDP.getReporter()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the reporter. 
}%end item
\end{itemize}
}%end item
\divideents{getSolver}
\item{\vskip -1.9ex 
\index{getSolver()}
\hypertarget{jmarkov.jmdp.MDP.getSolver()}{\membername{getSolver}}
{\tt public solvers.Solver\ {\bf getSolver}(  )
\label{jmarkov.jmdp.MDP.getSolver()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the solver. 
}%end item
\end{itemize}
}%end item
\divideents{isFinite}
\item{\vskip -1.9ex 
\index{isFinite()}
\hypertarget{jmarkov.jmdp.MDP.isFinite()}{\membername{isFinite}}
{\tt public final boolean\ {\bf isFinite}(  )
\label{jmarkov.jmdp.MDP.isFinite()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns true if the problem's horizon is finite. 
}%end item
\end{itemize}
}%end item
\divideents{isSolved}
\item{\vskip -1.9ex 
\index{isSolved()}
\hypertarget{jmarkov.jmdp.MDP.isSolved()}{\membername{isSolved}}
{\tt public final boolean\ {\bf isSolved}(  )
\label{jmarkov.jmdp.MDP.isSolved()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Indicates if the problems has been solved
}
\item{{\bf Returns} -- 
true if solved 
}%end item
\end{itemize}
}%end item
\divideents{operation}
\item{\vskip -1.9ex 
\index{operation(double, double)}
\hypertarget{jmarkov.jmdp.MDP.operation(double, double)}{\membername{operation}}
{\tt public double\ {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
\label{jmarkov.jmdp.MDP.operation(double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The Operator between present and future costs. By default is sum, but can be changed by the user, by overriding this method.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt present} -- Cost of current transition}
   \item{
\sld
{\tt future} -- Cost of future transitions.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
By default it returns present + future. 
}%end item
\end{itemize}
}%end item
\divideents{printSolution}
\item{\vskip -1.9ex 
\index{printSolution()}
\hypertarget{jmarkov.jmdp.MDP.printSolution()}{\membername{printSolution}}
{\tt public void\ {\bf printSolution}(  )
\label{jmarkov.jmdp.MDP.printSolution()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the solution to Standard output.
}
\end{itemize}
}%end item
\divideents{printSolution}
\item{\vskip -1.9ex 
\index{printSolution(PrintWriter)}
\hypertarget{jmarkov.jmdp.MDP.printSolution(java.io.PrintWriter)}{\membername{printSolution}}
{\tt public void\ {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
\label{jmarkov.jmdp.MDP.printSolution(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the solution to the given PrintWriter
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pw} -- The PrintWriter where the solution will be printed. It must have been initialized.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setDebugLevel}
\item{\vskip -1.9ex 
\index{setDebugLevel(int)}
\hypertarget{jmarkov.jmdp.MDP.setDebugLevel(int)}{\membername{setDebugLevel}}
{\tt public void\ {\bf setDebugLevel}( {\tt int} {\bf level} )
\label{jmarkov.jmdp.MDP.setDebugLevel(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets teh current level
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt level} -- The new level to level}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.DebugReporter}{jmarkov.DebugReporter}} {\small 
\refdefined{jmarkov.DebugReporter}}%end
}
\item{ {\tt \hyperlink{jmarkov.DebugReporter.setDebugLevel(int)}{jmarkov.DebugReporter.setDebugLevel(int)}} {\small 
\refdefined{jmarkov.DebugReporter.setDebugLevel(int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setReporter}
\item{\vskip -1.9ex 
\index{setReporter(DebugReporter)}
\hypertarget{jmarkov.jmdp.MDP.setReporter(jmarkov.DebugReporter)}{\membername{setReporter}}
{\tt public void\ {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
\label{jmarkov.jmdp.MDP.setReporter(jmarkov.DebugReporter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt reporter} -- The reporter to set.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setSolver}
\item{\vskip -1.9ex 
\index{setSolver(Solver)}
\hypertarget{jmarkov.jmdp.MDP.setSolver(jmarkov.jmdp.solvers.Solver)}{\membername{setSolver}}
{\tt public void\ {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
\label{jmarkov.jmdp.MDP.setSolver(jmarkov.jmdp.solvers.Solver)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt solver} -- The solver to set.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.MDP.solve()}{\membername{solve}}
{\tt public final void\ {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.MDP.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Solves the problem. If no solver has been defined, this used the default solver.
}
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- This Exception is thrown if a solution cannot be found.}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.MDP.getDefaultSolver()}{MDP.getDefaultSolver()}} {\small 
\refdefined{jmarkov.jmdp.MDP.getDefaultSolver()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{StochasticShortestPath}
\subsection{\label{jmarkov.jmdp.StochasticShortestPath}\index{StochasticShortestPath}{\bf {\it Class} StochasticShortestPath}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.StochasticShortestPath}{}\vskip .1in 
This class represents an infinite horizon shortest path problem.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class StochasticShortestPath
\\ {\bf extends} jmarkov.jmdp.DTMDP
\refdefined{jmarkov.jmdp.DTMDP}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.StochasticShortestPath(jmarkov.basic.States)}{{\bf StochasticShortestPath(States)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.StochasticShortestPath.modifiedProb(S, S, A)}{{\bf modifiedProb(S, S, A)}} This method was specially created to eliminate in a existent graph the self-transition probabilities.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{StochasticShortestPath(States)}
\hypertarget{jmarkov.jmdp.StochasticShortestPath(jmarkov.basic.States)}{\membername{StochasticShortestPath}}
{\tt public\ {\bf StochasticShortestPath}( {\tt jmarkov.basic.States} {\bf states} )
\label{jmarkov.jmdp.StochasticShortestPath(jmarkov.basic.States)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt states} -- Constructor}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{modifiedProb(S, S, A)}
\hypertarget{jmarkov.jmdp.StochasticShortestPath.modifiedProb(S, S, A)}{\membername{modifiedProb}}
{\tt public double\ {\bf modifiedProb}( {\tt jmarkov.basic.StateC} {\bf i},
{\tt jmarkov.basic.StateC} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} ) throws jmarkov.basic.exceptions.StructureException
\label{jmarkov.jmdp.StochasticShortestPath.modifiedProb(S, S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method was specially created to eliminate in a existent graph the self-transition probabilities.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- }
   \item{
\sld
{\tt j} -- }
   \item{
\sld
{\tt a} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the modified probability 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.StructureException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.DTMDP} \textnormal{\small\refdefined{jmarkov.jmdp.DTMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getSteadyStateProbabilities}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf immediateCost}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected StatesSet {\bf oneStageReachable}( {\tt jmarkov.basic.States} {\bf initSet} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf prob}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.State} {\bf j},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract States {\bf reachable}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setProbabilitySolver}( {\tt solvers.ProbabilitySolver} {\bf solv} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Solution {\bf solve}( {\tt double} {\bf interestRate} ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.InfiniteMDP} \textnormal{\small\refdefined{jmarkov.jmdp.InfiniteMDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf absorbingStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf explorationTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Actions {\bf feasibleActions}( {\tt jmarkov.basic.State} {\bf i} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract StatesSet {\bf generate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public StatesSet {\bf getAllStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractAverageSolver {\bf getDefaultAverageSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractDiscountedSolver {\bf getDefaultDiscountedSolver}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected AbstractInfiniteSolver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf getNumStates}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public AbstractInfiniteSolver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf hasAbsorbingState}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf numStates}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probability}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf probabilitySolver}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf states}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.MDP} \textnormal{\small\refdefined{jmarkov.jmdp.MDP}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf message} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf debug}( {\tt int} {\bf level},
{\tt java.lang.String} {\bf s},
{\tt boolean} {\bf newline},
{\tt boolean} {\bf indent} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf finite}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getDebugLevel}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract Solver {\bf getDefaultSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DebugReporter {\bf getReporter}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Solver {\bf getSolver}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf initial}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isFinite}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf operation}( {\tt double} {\bf present},
{\tt double} {\bf future} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf reporter}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setDebugLevel}( {\tt int} {\bf level} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setReporter}( {\tt jmarkov.DebugReporter} {\bf reporter} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setSolver}( {\tt solvers.Solver} {\bf solver} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\end{itemize}
}}
}
\newpage}
}
\newpage
\def\packagename{jmarkov.jmdp.solvers}
\chapter{\bf Package jmarkov.jmdp.solvers}{
\thispagestyle{empty}
\label{jmarkov.jmdp.solvers}\hypertarget{jmarkov.jmdp.solvers}{}
\markboth{\protect\packagename}{\protect\packagename}
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Interfaces}
\entityintro{LPSolver}{jmarkov.jmdp.solvers.LPSolver}{}
\entityintro{MpsLpSolver}{jmarkov.jmdp.solvers.MpsLpSolver}{This interface define the minimium elements for creating a MPS file.}
\vskip .13in
\hbox{\bf Classes}
\entityintro{AbstractAverageSolver}{jmarkov.jmdp.solvers.AbstractAverageSolver}{Structural class for average cost solvers to extend.}
\entityintro{AbstractDiscountedSolver}{jmarkov.jmdp.solvers.AbstractDiscountedSolver}{This is a structural class that must be extended by classes solving the dicounted cost minimization problem.}
\entityintro{AbstractFiniteSolver}{jmarkov.jmdp.solvers.AbstractFiniteSolver}{Structural class for solvers to extend in order to solve finite horizon problems.}
\entityintro{AbstractInfiniteSolver}{jmarkov.jmdp.solvers.AbstractInfiniteSolver}{Structural class to be extended by solvers in order to solve infinite horizon problems}
\entityintro{AbstractTotalSolver}{jmarkov.jmdp.solvers.AbstractTotalSolver}{Structural class to be extended by solvers in order to solve the total cost criteria for an infinite horizon problem}
\entityintro{FiniteSolver}{jmarkov.jmdp.solvers.FiniteSolver}{This class belongs to the set of default solvers included in the jmdp package.}
\entityintro{LPBCLAverageSolver}{jmarkov.jmdp.solvers.LPBCLAverageSolver}{This solver solves a average-cost infinite horizon MDP by building and solving a linear problem using as interface Xpress BCL.}
\entityintro{LPBCLDiscountedSolver}{jmarkov.jmdp.solvers.LPBCLDiscountedSolver}{This solver solves a discounted infinite horizon MDP by building and solving a linear problem using as interface Xpress BCL.}
\entityintro{MpsLpAverageSolver}{jmarkov.jmdp.solvers.MpsLpAverageSolver}{This class builds the Dual Linear Program for an average infinite horizon MDP in a MPS file.}
\entityintro{MpsLpDiscountedSolver}{jmarkov.jmdp.solvers.MpsLpDiscountedSolver}{This class builds a Linear Program for a discounted infinite horizon MDP in a MPS file.}
\entityintro{PolicyIterationSolver}{jmarkov.jmdp.solvers.PolicyIterationSolver}{This class solves infinite horizon discounted problems using the policy iteration algorithm.}
\entityintro{ProbabilitySolver}{jmarkov.jmdp.solvers.ProbabilitySolver}{This class is designed to calculate the long run probabilities of infinite horizon problem.}
\entityintro{RelativeValueIterationSolver}{jmarkov.jmdp.solvers.RelativeValueIterationSolver}{This class solves the average cost criteria for infinite horizon problems}
\entityintro{Solver}{jmarkov.jmdp.solvers.Solver}{Structural class for every solver.}
\entityintro{StochasticShortestPathSolver}{jmarkov.jmdp.solvers.StochasticShortestPathSolver}{This solver gives a solution for the minimization of the total cost criterion for an infinite horizon MDP.}
\entityintro{ValueIterationSolver}{jmarkov.jmdp.solvers.ValueIterationSolver}{This class belongs to the set of default solvers included in the jmdp package.}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
This package contins the framwork of solvers used by jMDP to solve Markov Decision Processes. See the jMDP manual for details.\mbox{}\\ \rule{\hsize}{.7mm}
\vskip .1in
\newpage
\markboth{\protect\packagename \hspace{.02in} -- \protect\classname}{\protect\packagename \hspace{.02in} -- \protect\classname}
\section{Interfaces}{
\gdef\classname{LPSolver}
\subsection{\label{jmarkov.jmdp.solvers.LPSolver}\index{LPSolver@{\it LPSolver}}{\bf {\it Interface} LPSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.LPSolver}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface LPSolver
}}}
\subsubsection{All known subclasses}{MpsLpSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpSolver}}, MpsLpDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpDiscountedSolver}}, MpsLpAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpAverageSolver}}, LPBCLDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.LPBCLDiscountedSolver}}}
\subsubsection{All known subinterfaces}{MpsLpSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpSolver}}}
\subsubsection{All classes known to implement interface}{LPBCLDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.LPBCLDiscountedSolver}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.LPSolver.buildSolution()}{{\bf buildSolution()}} The implementator classes should override this class to build the solution after the model has been solved.\\
\hyperlink{jmarkov.jmdp.solvers.LPSolver.getBuildTime()}{{\bf getBuildTime()}} Returns the time taken to build and write the MPS file.\\
\hyperlink{jmarkov.jmdp.solvers.LPSolver.getLpSolveTime()}{{\bf getLpSolveTime()}} Return the time taken to solve the LP model.\\
\hyperlink{jmarkov.jmdp.solvers.LPSolver.getSolBuildTime()}{{\bf getSolBuildTime()}} Returns the time needed to build the Solution after the LP was solved.\\
\hyperlink{jmarkov.jmdp.solvers.LPSolver.solveLP()}{{\bf solveLP()}} The implementator classes should override this class to solve the problem using the mpsFile that has been created.\\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{buildSolution()}
\hypertarget{jmarkov.jmdp.solvers.LPSolver.buildSolution()}{\membername{buildSolution}}
{\tt  jmarkov.basic.Solution\ {\bf buildSolution}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.LPSolver.buildSolution()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The implementator classes should override this class to build the solution after the model has been solved.
}
\item{{\bf Returns} -- 
The solution to the problem. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getBuildTime}
\item{\vskip -1.9ex 
\index{getBuildTime()}
\hypertarget{jmarkov.jmdp.solvers.LPSolver.getBuildTime()}{\membername{getBuildTime}}
{\tt  long\ {\bf getBuildTime}(  )
\label{jmarkov.jmdp.solvers.LPSolver.getBuildTime()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the time taken to build and write the MPS file.
}
\item{{\bf Returns} -- 
Returns the buildTime. 
}%end item
\end{itemize}
}%end item
\divideents{getLpSolveTime}
\item{\vskip -1.9ex 
\index{getLpSolveTime()}
\hypertarget{jmarkov.jmdp.solvers.LPSolver.getLpSolveTime()}{\membername{getLpSolveTime}}
{\tt  long\ {\bf getLpSolveTime}(  )
\label{jmarkov.jmdp.solvers.LPSolver.getLpSolveTime()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the time taken to solve the LP model.
}
\item{{\bf Returns} -- 
Returns the lpSolveTime. 
}%end item
\end{itemize}
}%end item
\divideents{getSolBuildTime}
\item{\vskip -1.9ex 
\index{getSolBuildTime()}
\hypertarget{jmarkov.jmdp.solvers.LPSolver.getSolBuildTime()}{\membername{getSolBuildTime}}
{\tt  long\ {\bf getSolBuildTime}(  )
\label{jmarkov.jmdp.solvers.LPSolver.getSolBuildTime()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the time needed to build the Solution after the LP was solved.
}
\item{{\bf Returns} -- 
Returns the solBuildTime. 
}%end item
\end{itemize}
}%end item
\divideents{solveLP}
\item{\vskip -1.9ex 
\index{solveLP()}
\hypertarget{jmarkov.jmdp.solvers.LPSolver.solveLP()}{\membername{solveLP}}
{\tt  void\ {\bf solveLP}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.LPSolver.solveLP()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The implementator classes should override this class to solve the problem using the mpsFile that has been created.
}
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{MpsLpSolver}
\subsection{\label{jmarkov.jmdp.solvers.MpsLpSolver}\index{MpsLpSolver@{\it MpsLpSolver}}{\bf {\it Interface} MpsLpSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.MpsLpSolver}{}\vskip .1in 
This interface define the minimium elements for creating a MPS file.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface MpsLpSolver
\\ {\bf implements} 
LPSolver}}}
\subsubsection{All known subclasses}{MpsLpDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpDiscountedSolver}}, MpsLpAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpAverageSolver}}}
\subsubsection{All classes known to implement interface}{MpsLpDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpDiscountedSolver}}, MpsLpAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpAverageSolver}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.MpsLpSolver.getMpsFile()}{{\bf getMpsFile()}} Returns the MPS file name.\\
\hyperlink{jmarkov.jmdp.solvers.MpsLpSolver.getMpsFileName()}{{\bf getMpsFileName()}} Returns the MPS file name.\\
\hyperlink{jmarkov.jmdp.solvers.MpsLpSolver.getWorkingDir()}{{\bf getWorkingDir()}} Returns the working directory (where the MPS file is located).\\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getMpsFile()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpSolver.getMpsFile()}{\membername{getMpsFile}}
{\tt  java.io.File\ {\bf getMpsFile}(  )
\label{jmarkov.jmdp.solvers.MpsLpSolver.getMpsFile()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the MPS file name.
}
\item{{\bf Returns} -- 
Returns the MPS generated file. 
}%end item
\end{itemize}
}%end item
\divideents{getMpsFileName}
\item{\vskip -1.9ex 
\index{getMpsFileName()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpSolver.getMpsFileName()}{\membername{getMpsFileName}}
{\tt  java.lang.String\ {\bf getMpsFileName}(  )
\label{jmarkov.jmdp.solvers.MpsLpSolver.getMpsFileName()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the MPS file name.
}
\item{{\bf Returns} -- 
Returns the fileName. 
}%end item
\end{itemize}
}%end item
\divideents{getWorkingDir}
\item{\vskip -1.9ex 
\index{getWorkingDir()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpSolver.getWorkingDir()}{\membername{getWorkingDir}}
{\tt  java.io.File\ {\bf getWorkingDir}(  )
\label{jmarkov.jmdp.solvers.MpsLpSolver.getWorkingDir()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the working directory (where the MPS file is located).
}
\item{{\bf Returns} -- 
Returns the MPS File folder. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage}
\section{Classes}{
\gdef\classname{AbstractAverageSolver}
\subsection{\label{jmarkov.jmdp.solvers.AbstractAverageSolver}\index{AbstractAverageSolver}{\bf {\it Class} AbstractAverageSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.AbstractAverageSolver}{}\vskip .1in 
Structural class for average cost solvers to extend.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class AbstractAverageSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractInfiniteSolver
\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}}
\subsubsection{All known subclasses}{RelativeValueIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.RelativeValueIterationSolver}}, MpsLpAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpAverageSolver}}, LPBCLAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.LPBCLAverageSolver}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.AbstractAverageSolver(jmarkov.jmdp.CTMDP)}{{\bf AbstractAverageSolver(CTMDP)}} Creates a solver for an infinite horizon continuous time MDP\\
\hyperlink{jmarkov.jmdp.solvers.AbstractAverageSolver(jmarkov.jmdp.DTMDP)}{{\bf AbstractAverageSolver(DTMDP)}} Creates a solver for an infinite horizon discrete time MDP\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{AbstractAverageSolver(CTMDP)}
\hypertarget{jmarkov.jmdp.solvers.AbstractAverageSolver(jmarkov.jmdp.CTMDP)}{\membername{AbstractAverageSolver}}
{\tt protected\ {\bf AbstractAverageSolver}( {\tt jmarkov.jmdp.CTMDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.AbstractAverageSolver(jmarkov.jmdp.CTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a solver for an infinite horizon continuous time MDP
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- continuous time problem}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{AbstractAverageSolver}
\item{\vskip -1.9ex 
\index{AbstractAverageSolver(DTMDP)}
\hypertarget{jmarkov.jmdp.solvers.AbstractAverageSolver(jmarkov.jmdp.DTMDP)}{\membername{AbstractAverageSolver}}
{\tt protected\ {\bf AbstractAverageSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.AbstractAverageSolver(jmarkov.jmdp.DTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a solver for an infinite horizon discrete time MDP
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- discrete time problem}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractInfiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected DTMDP {\bf getDiscreteProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getIterations}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public InfiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{AbstractDiscountedSolver}
\subsection{\label{jmarkov.jmdp.solvers.AbstractDiscountedSolver}\index{AbstractDiscountedSolver}{\bf {\it Class} AbstractDiscountedSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.AbstractDiscountedSolver}{}\vskip .1in 
This is a structural class that must be extended by classes solving the dicounted cost minimization problem.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class AbstractDiscountedSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractInfiniteSolver
\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}}
\subsubsection{All known subclasses}{ValueIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.ValueIterationSolver}}, PolicyIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.PolicyIterationSolver}}, MpsLpDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpDiscountedSolver}}, LPBCLDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.LPBCLDiscountedSolver}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.AbstractDiscountedSolver.discountFactor}{{\bf discountFactor}} The discount factor used to bring to present value from next period.\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.AbstractDiscountedSolver(jmarkov.jmdp.CTMDP, double)}{{\bf AbstractDiscountedSolver(CTMDP, double)}} \\
\hyperlink{jmarkov.jmdp.solvers.AbstractDiscountedSolver(jmarkov.jmdp.DTMDP, double)}{{\bf AbstractDiscountedSolver(DTMDP, double)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.AbstractDiscountedSolver.future(S, A, double)}{{\bf future(S, A, double)}} Expected value of valueFunction for the current state and a specified action.\\
\hyperlink{jmarkov.jmdp.solvers.AbstractDiscountedSolver.future(S, A, double, jmarkov.basic.ValueFunction)}{{\bf future(S, A, double, ValueFunction)}} Expected value of valueFunction for the current state and a specified action.\\
\hyperlink{jmarkov.jmdp.solvers.AbstractDiscountedSolver.getInterestRate()}{{\bf getInterestRate()}} Returns the current value of the discount factor.\\
\hyperlink{jmarkov.jmdp.solvers.AbstractDiscountedSolver.setDiscountFactor(double)}{{\bf setDiscountFactor(double)}} \\
\hyperlink{jmarkov.jmdp.solvers.AbstractDiscountedSolver.setInterestRate(double)}{{\bf setInterestRate(double)}} Sets a new Interest Rate\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{discountFactor}
\label{jmarkov.jmdp.solvers.AbstractDiscountedSolver.discountFactor}\hypertarget{jmarkov.jmdp.solvers.AbstractDiscountedSolver.discountFactor}{protected double {\bf discountFactor}}
\begin{itemize}
\item{\vskip -.9ex 
The discount factor used to bring to present value from next period.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{AbstractDiscountedSolver(CTMDP, double)}
\hypertarget{jmarkov.jmdp.solvers.AbstractDiscountedSolver(jmarkov.jmdp.CTMDP, double)}{\membername{AbstractDiscountedSolver}}
{\tt protected\ {\bf AbstractDiscountedSolver}( {\tt jmarkov.jmdp.CTMDP} {\bf problem},
{\tt double} {\bf interestRate} )
\label{jmarkov.jmdp.solvers.AbstractDiscountedSolver(jmarkov.jmdp.CTMDP, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- The problem associated with this solver.}
   \item{
\sld
{\tt interestRate} -- The interest rate (nominal compunded continuously). For example, if you measure time in months, and the APR is A, then this rate satisfies exp(i/12) = 1 + A. Therefore i=12*ln(1+A).}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{AbstractDiscountedSolver}
\item{\vskip -1.9ex 
\index{AbstractDiscountedSolver(DTMDP, double)}
\hypertarget{jmarkov.jmdp.solvers.AbstractDiscountedSolver(jmarkov.jmdp.DTMDP, double)}{\membername{AbstractDiscountedSolver}}
{\tt protected\ {\bf AbstractDiscountedSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt double} {\bf interestRate} )
\label{jmarkov.jmdp.solvers.AbstractDiscountedSolver(jmarkov.jmdp.DTMDP, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- The problem associated with this solver.}
   \item{
\sld
{\tt interestRate} -- The interest rate per period}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{future(S, A, double)}
\hypertarget{jmarkov.jmdp.solvers.AbstractDiscountedSolver.future(S, A, double)}{\membername{future}}
{\tt protected final double\ {\bf future}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt double} {\bf discountF} )
\label{jmarkov.jmdp.solvers.AbstractDiscountedSolver.future(S, A, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Expected value of valueFunction for the current state and a specified action.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Ths State}
   \item{
\sld
{\tt a} -- Action taken}
   \item{
\sld
{\tt discountF} -- is the rate for discounting from one period to another. It means how much less it would represent to receive one unit of the reward in the next period instead of receiving it in the present period.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Expected value of valueFunction. 
}%end item
\end{itemize}
}%end item
\divideents{future}
\item{\vskip -1.9ex 
\index{future(S, A, double, ValueFunction)}
\hypertarget{jmarkov.jmdp.solvers.AbstractDiscountedSolver.future(S, A, double, jmarkov.basic.ValueFunction)}{\membername{future}}
{\tt protected final double\ {\bf future}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt double} {\bf discountF},
{\tt jmarkov.basic.ValueFunction} {\bf vf} )
\label{jmarkov.jmdp.solvers.AbstractDiscountedSolver.future(S, A, double, jmarkov.basic.ValueFunction)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Expected value of valueFunction for the current state and a specified action.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt discountF} -- is the rate for discounting from one period to another. It means how much less it would represent to receive one unit of the reward in the next period instead of receiving it in the present period.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getInterestRate}
\item{\vskip -1.9ex 
\index{getInterestRate()}
\hypertarget{jmarkov.jmdp.solvers.AbstractDiscountedSolver.getInterestRate()}{\membername{getInterestRate}}
{\tt public double\ {\bf getInterestRate}(  )
\label{jmarkov.jmdp.solvers.AbstractDiscountedSolver.getInterestRate()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the current value of the discount factor.
}
\item{{\bf Returns} -- 
The current value of the discount factor. 
}%end item
\end{itemize}
}%end item
\divideents{setDiscountFactor}
\item{\vskip -1.9ex 
\index{setDiscountFactor(double)}
\hypertarget{jmarkov.jmdp.solvers.AbstractDiscountedSolver.setDiscountFactor(double)}{\membername{setDiscountFactor}}
{\tt protected final void\ {\bf setDiscountFactor}( {\tt double} {\bf discountFactor} )
\label{jmarkov.jmdp.solvers.AbstractDiscountedSolver.setDiscountFactor(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt discountFactor} -- The discountFactor to set.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setInterestRate}
\item{\vskip -1.9ex 
\index{setInterestRate(double)}
\hypertarget{jmarkov.jmdp.solvers.AbstractDiscountedSolver.setInterestRate(double)}{\membername{setInterestRate}}
{\tt public final void\ {\bf setInterestRate}( {\tt double} {\bf interestRate} )
\label{jmarkov.jmdp.solvers.AbstractDiscountedSolver.setInterestRate(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets a new Interest Rate
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt interestRate} -- set.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractInfiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected DTMDP {\bf getDiscreteProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getIterations}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public InfiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{AbstractFiniteSolver}
\subsection{\label{jmarkov.jmdp.solvers.AbstractFiniteSolver}\index{AbstractFiniteSolver}{\bf {\it Class} AbstractFiniteSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.AbstractFiniteSolver}{}\vskip .1in 
Structural class for solvers to extend in order to solve finite horizon problems.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class AbstractFiniteSolver
\\ {\bf extends} jmarkov.jmdp.solvers.Solver
\refdefined{jmarkov.jmdp.solvers.Solver}}}}
\subsubsection{All known subclasses}{FiniteSolver\small{\refdefined{jmarkov.jmdp.solvers.FiniteSolver}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.AbstractFiniteSolver(jmarkov.jmdp.FiniteMDP)}{{\bf AbstractFiniteSolver(FiniteMDP)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.AbstractFiniteSolver.getProblem()}{{\bf getProblem()}} Returns the problem associated wit this solver.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{AbstractFiniteSolver(FiniteMDP)}
\hypertarget{jmarkov.jmdp.solvers.AbstractFiniteSolver(jmarkov.jmdp.FiniteMDP)}{\membername{AbstractFiniteSolver}}
{\tt protected\ {\bf AbstractFiniteSolver}( {\tt jmarkov.jmdp.FiniteMDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.AbstractFiniteSolver(jmarkov.jmdp.FiniteMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- finite horizon problem to be solved}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getProblem()}
\hypertarget{jmarkov.jmdp.solvers.AbstractFiniteSolver.getProblem()}{\membername{getProblem}}
{\tt public jmarkov.jmdp.FiniteMDP\ {\bf getProblem}(  )
\label{jmarkov.jmdp.solvers.AbstractFiniteSolver.getProblem()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the problem associated wit this solver.
}
\item{{\bf Returns} -- 
the problem associated wit this solver. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{AbstractInfiniteSolver}
\subsection{\label{jmarkov.jmdp.solvers.AbstractInfiniteSolver}\index{AbstractInfiniteSolver}{\bf {\it Class} AbstractInfiniteSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.AbstractInfiniteSolver}{}\vskip .1in 
Structural class to be extended by solvers in order to solve infinite horizon problems\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class AbstractInfiniteSolver
\\ {\bf extends} jmarkov.jmdp.solvers.Solver
\refdefined{jmarkov.jmdp.solvers.Solver}}}}
\subsubsection{All known subclasses}{ValueIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.ValueIterationSolver}}, StochasticShortestPathSolver\small{\refdefined{jmarkov.jmdp.solvers.StochasticShortestPathSolver}}, RelativeValueIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.RelativeValueIterationSolver}}, PolicyIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.PolicyIterationSolver}}, MpsLpDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpDiscountedSolver}}, MpsLpAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpAverageSolver}}, LPBCLDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.LPBCLDiscountedSolver}}, LPBCLAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.LPBCLAverageSolver}}, AbstractTotalSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractTotalSolver}}, AbstractDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}}, AbstractAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractAverageSolver}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.AbstractInfiniteSolver(jmarkov.jmdp.CTMDP)}{{\bf AbstractInfiniteSolver(CTMDP)}} Creates a solver for an infinite horizon continuous time problem\\
\hyperlink{jmarkov.jmdp.solvers.AbstractInfiniteSolver(jmarkov.jmdp.DTMDP)}{{\bf AbstractInfiniteSolver(DTMDP)}} Constructor method for Discrete Time Markov Decision Processes to be solved for discounted cost.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.AbstractInfiniteSolver.getDiscreteProblem()}{{\bf getDiscreteProblem()}} \\
\hyperlink{jmarkov.jmdp.solvers.AbstractInfiniteSolver.getIterations()}{{\bf getIterations()}} \\
\hyperlink{jmarkov.jmdp.solvers.AbstractInfiniteSolver.getProblem()}{{\bf getProblem()}} Returns the problem associated with this solver.\\
\hyperlink{jmarkov.jmdp.solvers.AbstractInfiniteSolver.printSolution(java.io.PrintWriter)}{{\bf printSolution(PrintWriter)}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{AbstractInfiniteSolver(CTMDP)}
\hypertarget{jmarkov.jmdp.solvers.AbstractInfiniteSolver(jmarkov.jmdp.CTMDP)}{\membername{AbstractInfiniteSolver}}
{\tt protected\ {\bf AbstractInfiniteSolver}( {\tt jmarkov.jmdp.CTMDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.AbstractInfiniteSolver(jmarkov.jmdp.CTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a solver for an infinite horizon continuous time problem
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- continuous time problem}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{AbstractInfiniteSolver}
\item{\vskip -1.9ex 
\index{AbstractInfiniteSolver(DTMDP)}
\hypertarget{jmarkov.jmdp.solvers.AbstractInfiniteSolver(jmarkov.jmdp.DTMDP)}{\membername{AbstractInfiniteSolver}}
{\tt protected\ {\bf AbstractInfiniteSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.AbstractInfiniteSolver(jmarkov.jmdp.DTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructor method for Discrete Time Markov Decision Processes to be solved for discounted cost.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- Discrete Time Markov Decision Process of type DTMDP}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getDiscreteProblem()}
\hypertarget{jmarkov.jmdp.solvers.AbstractInfiniteSolver.getDiscreteProblem()}{\membername{getDiscreteProblem}}
{\tt protected jmarkov.jmdp.DTMDP\ {\bf getDiscreteProblem}(  )
\label{jmarkov.jmdp.solvers.AbstractInfiniteSolver.getDiscreteProblem()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
discrete time problem 
}%end item
\end{itemize}
}%end item
\divideents{getIterations}
\item{\vskip -1.9ex 
\index{getIterations()}
\hypertarget{jmarkov.jmdp.solvers.AbstractInfiniteSolver.getIterations()}{\membername{getIterations}}
{\tt public abstract long\ {\bf getIterations}(  )
\label{jmarkov.jmdp.solvers.AbstractInfiniteSolver.getIterations()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the iterations in the last solve. 
}%end item
\end{itemize}
}%end item
\divideents{getProblem}
\item{\vskip -1.9ex 
\index{getProblem()}
\hypertarget{jmarkov.jmdp.solvers.AbstractInfiniteSolver.getProblem()}{\membername{getProblem}}
{\tt public jmarkov.jmdp.InfiniteMDP\ {\bf getProblem}(  )
\label{jmarkov.jmdp.solvers.AbstractInfiniteSolver.getProblem()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the problem associated with this solver.
}
\item{{\bf Returns} -- 
the problem associated with this solver. 
}%end item
\end{itemize}
}%end item
\divideents{printSolution}
\item{\vskip -1.9ex 
\index{printSolution(PrintWriter)}
\hypertarget{jmarkov.jmdp.solvers.AbstractInfiniteSolver.printSolution(java.io.PrintWriter)}{\membername{printSolution}}
{\tt public void\ {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
\label{jmarkov.jmdp.solvers.AbstractInfiniteSolver.printSolution(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

Prints the solution on a given PrintWriter.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pw} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.io.PrintWriter}{java.io.PrintWriter}} {\small 
\refdefined{java.io.PrintWriter}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{AbstractTotalSolver}
\subsection{\label{jmarkov.jmdp.solvers.AbstractTotalSolver}\index{AbstractTotalSolver}{\bf {\it Class} AbstractTotalSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.AbstractTotalSolver}{}\vskip .1in 
Structural class to be extended by solvers in order to solve the total cost criteria for an infinite horizon problem\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class AbstractTotalSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractInfiniteSolver
\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}}
\subsubsection{All known subclasses}{StochasticShortestPathSolver\small{\refdefined{jmarkov.jmdp.solvers.StochasticShortestPathSolver}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.AbstractTotalSolver(jmarkov.jmdp.DTMDP)}{{\bf AbstractTotalSolver(DTMDP)}} Creates a solver for a discrete time problem\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{AbstractTotalSolver(DTMDP)}
\hypertarget{jmarkov.jmdp.solvers.AbstractTotalSolver(jmarkov.jmdp.DTMDP)}{\membername{AbstractTotalSolver}}
{\tt public\ {\bf AbstractTotalSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.AbstractTotalSolver(jmarkov.jmdp.DTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a solver for a discrete time problem
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- discrete time problem}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractInfiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected DTMDP {\bf getDiscreteProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getIterations}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public InfiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{FiniteSolver}
\subsection{\label{jmarkov.jmdp.solvers.FiniteSolver}\index{FiniteSolver}{\bf {\it Class} FiniteSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.FiniteSolver}{}\vskip .1in 
This class belongs to the set of default solvers included in the jmdp package. It extends Solver and should only be used on FINITE horizon problems. The objective function of the solver is to minimize the the total cost. The result is a deterministic optimal policy for the given structure.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class FiniteSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractFiniteSolver
\refdefined{jmarkov.jmdp.solvers.AbstractFiniteSolver}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.FiniteSolver(jmarkov.jmdp.FiniteMDP)}{{\bf FiniteSolver(FiniteMDP)}} Initialized the solver with the given getProblem().\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.FiniteSolver.bestPolicy(S)}{{\bf bestPolicy(S)}} Prints out the policy\\
\hyperlink{jmarkov.jmdp.solvers.FiniteSolver.future(S, A, int)}{{\bf future(S, A, int)}} This method calculates the expected value of valueFunction for the current state i and a specified action a at the given stage t.\\
\hyperlink{jmarkov.jmdp.solvers.FiniteSolver.getProcessTime()}{{\bf getProcessTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.FiniteSolver.label()}{{\bf label()}} \\
\hyperlink{jmarkov.jmdp.solvers.FiniteSolver.solve()}{{\bf solve()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{FiniteSolver(FiniteMDP)}
\hypertarget{jmarkov.jmdp.solvers.FiniteSolver(jmarkov.jmdp.FiniteMDP)}{\membername{FiniteSolver}}
{\tt public\ {\bf FiniteSolver}( {\tt jmarkov.jmdp.FiniteMDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.FiniteSolver(jmarkov.jmdp.FiniteMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Initialized the solver with the given getProblem().
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- The problem to be solved.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{bestPolicy(S)}
\hypertarget{jmarkov.jmdp.solvers.FiniteSolver.bestPolicy(S)}{\membername{bestPolicy}}
{\tt public java.lang.String\ {\bf bestPolicy}( {\tt jmarkov.basic.State} {\bf initial} ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.FiniteSolver.bestPolicy(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints out the policy
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initial} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
a string with the optimal policy 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{future}
\item{\vskip -1.9ex 
\index{future(S, A, int)}
\hypertarget{jmarkov.jmdp.solvers.FiniteSolver.future(S, A, int)}{\membername{future}}
{\tt protected final double\ {\bf future}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt int} {\bf t} ) throws java.lang.NullPointerException
\label{jmarkov.jmdp.solvers.FiniteSolver.future(S, A, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method calculates the expected value of valueFunction for the current state i and a specified action a at the given stage t.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current State}
   \item{
\sld
{\tt a} -- Action taken}
   \item{
\sld
{\tt t} -- Time stage}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The value. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.lang.NullPointerException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getProcessTime}
\item{\vskip -1.9ex 
\index{getProcessTime()}
\hypertarget{jmarkov.jmdp.solvers.FiniteSolver.getProcessTime()}{\membername{getProcessTime}}
{\tt public abstract long\ {\bf getProcessTime}(  )
\label{jmarkov.jmdp.solvers.FiniteSolver.getProcessTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the processTime of the last solve. Use {\tt\small System.currentTimeMillis()} to get the current time. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.jmdp.solvers.FiniteSolver.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.jmdp.solvers.FiniteSolver.label()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.Solver.toString()}{Solver.toString()}} {\small 
\refdefined{jmarkov.jmdp.solvers.Solver.toString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.solvers.FiniteSolver.solve()}{\membername{solve}}
{\tt public abstract jmarkov.basic.Solution\ {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.FiniteSolver.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

Called to solve the problem. This method MUST write the local variable policy and valueFunction.
}
\item{{\bf Returns} -- 
The solution Object taht contains the plicy and value fuenction. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- This exception is thrown if the solver cannot find a solution for some reason.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractFiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractFiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public FiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{LPBCLAverageSolver}
\subsection{\label{jmarkov.jmdp.solvers.LPBCLAverageSolver}\index{LPBCLAverageSolver}{\bf {\it Class} LPBCLAverageSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.LPBCLAverageSolver}{}\vskip .1in 
This solver solves a average-cost infinite horizon MDP by building and solving a linear problem using as interface Xpress BCL. It requires the professional version of XpressMP and the JAVA build path must include the xprb.jar libray, for running the applications.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class LPBCLAverageSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractAverageSolver
\refdefined{jmarkov.jmdp.solvers.AbstractAverageSolver}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.LPBCLAverageSolver.lpSolveTime}{{\bf lpSolveTime}} Used to store the Linear Programming solve time\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.LPBCLAverageSolver(jmarkov.jmdp.DTMDP)}{{\bf LPBCLAverageSolver(DTMDP)}} The constructor method exclusively receives a problem of the type DTMDP because this solver is only designed to work on infinite discrete horizon problems.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.LPBCLAverageSolver.getBuildTime()}{{\bf getBuildTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLAverageSolver.getIterations()}{{\bf getIterations()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLAverageSolver.getLpSolveTime()}{{\bf getLpSolveTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLAverageSolver.getProcessTime()}{{\bf getProcessTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLAverageSolver.getSolBuildTime()}{{\bf getSolBuildTime()}} Returns the time needed to build the Solution after the LP was solved.\\
\hyperlink{jmarkov.jmdp.solvers.LPBCLAverageSolver.label()}{{\bf label()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLAverageSolver.solve()}{{\bf solve()}} Linear Programming Average Solver is a tool that builds the solution based on the MDP's mathematical background given by Puterman and the software provided by XpressMP (BCL libraries).\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{lpSolveTime}
\label{jmarkov.jmdp.solvers.LPBCLAverageSolver.lpSolveTime}\hypertarget{jmarkov.jmdp.solvers.LPBCLAverageSolver.lpSolveTime}{protected long {\bf lpSolveTime}}
\begin{itemize}
\item{\vskip -.9ex 
Used to store the Linear Programming solve time}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{LPBCLAverageSolver(DTMDP)}
\hypertarget{jmarkov.jmdp.solvers.LPBCLAverageSolver(jmarkov.jmdp.DTMDP)}{\membername{LPBCLAverageSolver}}
{\tt public\ {\bf LPBCLAverageSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.LPBCLAverageSolver(jmarkov.jmdp.DTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The constructor method exclusively receives a problem of the type DTMDP because this solver is only designed to work on infinite discrete horizon problems. This solver solves an average DTMDP.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- the structure of the problem of type DTMDP}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getBuildTime()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLAverageSolver.getBuildTime()}{\membername{getBuildTime}}
{\tt public long\ {\bf getBuildTime}(  )
\label{jmarkov.jmdp.solvers.LPBCLAverageSolver.getBuildTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the build time. 
}%end item
\end{itemize}
}%end item
\divideents{getIterations}
\item{\vskip -1.9ex 
\index{getIterations()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLAverageSolver.getIterations()}{\membername{getIterations}}
{\tt public abstract long\ {\bf getIterations}(  )
\label{jmarkov.jmdp.solvers.LPBCLAverageSolver.getIterations()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the iterations in the last solve. 
}%end item
\end{itemize}
}%end item
\divideents{getLpSolveTime}
\item{\vskip -1.9ex 
\index{getLpSolveTime()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLAverageSolver.getLpSolveTime()}{\membername{getLpSolveTime}}
{\tt public long\ {\bf getLpSolveTime}(  )
\label{jmarkov.jmdp.solvers.LPBCLAverageSolver.getLpSolveTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the Linear Programming Solve Time 
}%end item
\end{itemize}
}%end item
\divideents{getProcessTime}
\item{\vskip -1.9ex 
\index{getProcessTime()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLAverageSolver.getProcessTime()}{\membername{getProcessTime}}
{\tt public abstract long\ {\bf getProcessTime}(  )
\label{jmarkov.jmdp.solvers.LPBCLAverageSolver.getProcessTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the processTime of the last solve. Use {\tt\small System.currentTimeMillis()} to get the current time. 
}%end item
\end{itemize}
}%end item
\divideents{getSolBuildTime}
\item{\vskip -1.9ex 
\index{getSolBuildTime()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLAverageSolver.getSolBuildTime()}{\membername{getSolBuildTime}}
{\tt public long\ {\bf getSolBuildTime}(  )
\label{jmarkov.jmdp.solvers.LPBCLAverageSolver.getSolBuildTime()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the time needed to build the Solution after the LP was solved.
}
\item{{\bf Returns} -- 
Returns the solBuildTime. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLAverageSolver.label()}{\membername{label}}
{\tt public abstract java.lang.String\ {\bf label}(  )
\label{jmarkov.jmdp.solvers.LPBCLAverageSolver.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

The sub classes must return the Solver name.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.Solver.toString()}{Solver.toString()}} {\small 
\refdefined{jmarkov.jmdp.solvers.Solver.toString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLAverageSolver.solve()}{\membername{solve}}
{\tt public jmarkov.basic.Solution\ {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.LPBCLAverageSolver.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Linear Programming Average Solver is a tool that builds the solution based on the MDP's mathematical background given by Puterman and the software provided by XpressMP (BCL libraries). Is mandatory for the use to have a Xpress professional version.
}
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractAverageSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractAverageSolver}}}{
{\small 
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractInfiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected DTMDP {\bf getDiscreteProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getIterations}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public InfiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{LPBCLDiscountedSolver}
\subsection{\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver}\index{LPBCLDiscountedSolver}{\bf {\it Class} LPBCLDiscountedSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver}{}\vskip .1in 
This solver solves a discounted infinite horizon MDP by building and solving a linear problem using as interface Xpress BCL. It requires the professional version of XpressMP and the JAVA build path must include the xprb.jar libray, for running the applications.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class LPBCLDiscountedSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractDiscountedSolver
\refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}\\ {\bf implements} 
LPSolver}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.LPBCLDiscountedSolver(jmarkov.jmdp.DTMDP, double)}{{\bf LPBCLDiscountedSolver(DTMDP, double)}} The constructor method receives a problem of the type infinite DTMDP and an interest rate that is modified for being used as discount factor.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.buildSolution()}{{\bf buildSolution()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.description()}{{\bf description()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getBuildTime()}{{\bf getBuildTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getIterations()}{{\bf getIterations()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getLpSolveTime()}{{\bf getLpSolveTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getProcessTime()}{{\bf getProcessTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getSolBuildTime()}{{\bf getSolBuildTime()}} Returns the time needed to build the Solution after the LP was solved.\\
\hyperlink{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.label()}{{\bf label()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.solve()}{{\bf solve()}} \\
\hyperlink{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.solveLP()}{{\bf solveLP()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{LPBCLDiscountedSolver(DTMDP, double)}
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver(jmarkov.jmdp.DTMDP, double)}{\membername{LPBCLDiscountedSolver}}
{\tt public\ {\bf LPBCLDiscountedSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt double} {\bf interestRate} )
\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver(jmarkov.jmdp.DTMDP, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The constructor method receives a problem of the type infinite DTMDP and an interest rate that is modified for being used as discount factor. The discount factor and the problem gives necesary information for solving a discounted MDP.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- the structure of the problem of type infinite DTMDP.}
   \item{
\sld
{\tt interestRate} -- A rate which is paid for the use of a resource.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{buildSolution()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.buildSolution()}{\membername{buildSolution}}
{\tt public jmarkov.basic.Solution\ {\bf buildSolution}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.buildSolution()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.LPSolver.buildSolution()}{LPSolver.buildSolution()}} {\small 
\refdefined{jmarkov.jmdp.solvers.LPSolver.buildSolution()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.description()}{\membername{description}}
{\tt  java.lang.String\ {\bf description}(  )
\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.JMarkovElement}{jmarkov.basic.JMarkovElement}{\small \refdefined{jmarkov.basic.JMarkovElement}} }

This method return a complete verbal describtion of this element. This description may contain multiple text rows.
}
\item{{\bf Returns} -- 
A String describing this element. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.label()}{jmarkov.basic.JMarkovElement.label()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getBuildTime}
\item{\vskip -1.9ex 
\index{getBuildTime()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getBuildTime()}{\membername{getBuildTime}}
{\tt  long\ {\bf getBuildTime}(  )
\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getBuildTime()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.LPSolver}{LPSolver}{\small \refdefined{jmarkov.jmdp.solvers.LPSolver}} }

Returns the time taken to build and write the MPS file.
}
\item{{\bf Returns} -- 
Returns the buildTime. 
}%end item
\end{itemize}
}%end item
\divideents{getIterations}
\item{\vskip -1.9ex 
\index{getIterations()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getIterations()}{\membername{getIterations}}
{\tt public abstract long\ {\bf getIterations}(  )
\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getIterations()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the iterations in the last solve. 
}%end item
\end{itemize}
}%end item
\divideents{getLpSolveTime}
\item{\vskip -1.9ex 
\index{getLpSolveTime()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getLpSolveTime()}{\membername{getLpSolveTime}}
{\tt  long\ {\bf getLpSolveTime}(  )
\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getLpSolveTime()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.LPSolver}{LPSolver}{\small \refdefined{jmarkov.jmdp.solvers.LPSolver}} }

Return the time taken to solve the LP model.
}
\item{{\bf Returns} -- 
Returns the lpSolveTime. 
}%end item
\end{itemize}
}%end item
\divideents{getProcessTime}
\item{\vskip -1.9ex 
\index{getProcessTime()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getProcessTime()}{\membername{getProcessTime}}
{\tt public abstract long\ {\bf getProcessTime}(  )
\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getProcessTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the processTime of the last solve. Use {\tt\small System.currentTimeMillis()} to get the current time. 
}%end item
\end{itemize}
}%end item
\divideents{getSolBuildTime}
\item{\vskip -1.9ex 
\index{getSolBuildTime()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getSolBuildTime()}{\membername{getSolBuildTime}}
{\tt public long\ {\bf getSolBuildTime}(  )
\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.getSolBuildTime()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the time needed to build the Solution after the LP was solved.
}
\item{{\bf Returns} -- 
Returns the solBuildTime. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.label()}{\membername{label}}
{\tt public abstract java.lang.String\ {\bf label}(  )
\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

The sub classes must return the Solver name.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.Solver.toString()}{Solver.toString()}} {\small 
\refdefined{jmarkov.jmdp.solvers.Solver.toString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.solve()}{\membername{solve}}
{\tt public abstract jmarkov.basic.Solution\ {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

Called to solve the problem. This method MUST write the local variable policy and valueFunction.
}
\item{{\bf Returns} -- 
The solution Object taht contains the plicy and value fuenction. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- This exception is thrown if the solver cannot find a solution for some reason.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solveLP}
\item{\vskip -1.9ex 
\index{solveLP()}
\hypertarget{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.solveLP()}{\membername{solveLP}}
{\tt public void\ {\bf solveLP}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.LPBCLDiscountedSolver.solveLP()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.LPSolver.solveLP()}{LPSolver.solveLP()}} {\small 
\refdefined{jmarkov.jmdp.solvers.LPSolver.solveLP()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractDiscountedSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf discountFactor}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final double {\bf future}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt double} {\bf discountF} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final double {\bf future}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt double} {\bf discountF},
{\tt jmarkov.basic.ValueFunction} {\bf vf} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getInterestRate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final void {\bf setDiscountFactor}( {\tt double} {\bf discountFactor} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractInfiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected DTMDP {\bf getDiscreteProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getIterations}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public InfiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MpsLpAverageSolver}
\subsection{\label{jmarkov.jmdp.solvers.MpsLpAverageSolver}\index{MpsLpAverageSolver}{\bf {\it Class} MpsLpAverageSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver}{}\vskip .1in 
This class builds the Dual Linear Program for an average infinite horizon MDP in a MPS file.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class MpsLpAverageSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractAverageSolver
\refdefined{jmarkov.jmdp.solvers.AbstractAverageSolver}\\ {\bf implements} 
MpsLpSolver}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver(jmarkov.jmdp.DTMDP)}{{\bf MpsLpAverageSolver(DTMDP)}} This cosntructor creates a solver for this problem.\\
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver(jmarkov.jmdp.DTMDP, java.lang.String, java.lang.String)}{{\bf MpsLpAverageSolver(DTMDP, String, String)}} The constructor method receives a problem of the type infinite DTMDP, the working directory where the MPS file will be stored, and the name that the user wants for the MPS File.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver.getBuildTime()}{{\bf getBuildTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver.getDiscSolver()}{{\bf getDiscSolver()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver.getIterations()}{{\bf getIterations()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver.getLpSolveTime()}{{\bf getLpSolveTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver.getMpsFile()}{{\bf getMpsFile()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver.getMpsFileName()}{{\bf getMpsFileName()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver.getProcessTime()}{{\bf getProcessTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver.getSolBuildTime()}{{\bf getSolBuildTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver.getWorkingDir()}{{\bf getWorkingDir()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpAverageSolver.solve()}{{\bf solve()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MpsLpAverageSolver(DTMDP)}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver(jmarkov.jmdp.DTMDP)}{\membername{MpsLpAverageSolver}}
{\tt public\ {\bf MpsLpAverageSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver(jmarkov.jmdp.DTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This cosntructor creates a solver for this problem. The created mps file is stored in a temp folder.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- The structure of the problem of type infinite DTMDP.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MpsLpAverageSolver}
\item{\vskip -1.9ex 
\index{MpsLpAverageSolver(DTMDP, String, String)}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver(jmarkov.jmdp.DTMDP, java.lang.String, java.lang.String)}{\membername{MpsLpAverageSolver}}
{\tt public\ {\bf MpsLpAverageSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt java.lang.String} {\bf workingDir},
{\tt java.lang.String} {\bf fileName} )
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver(jmarkov.jmdp.DTMDP, java.lang.String, java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The constructor method receives a problem of the type infinite DTMDP, the working directory where the MPS file will be stored, and the name that the user wants for the MPS File.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- The problem to be solved.}
   \item{
\sld
{\tt workingDir} -- Where the file will be created.}
   \item{
\sld
{\tt fileName} -- Label for the MPS File.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getBuildTime()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver.getBuildTime()}{\membername{getBuildTime}}
{\tt public long\ {\bf getBuildTime}(  )
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver.getBuildTime()}}%end signature
}%end item
\divideents{getDiscSolver}
\item{\vskip -1.9ex 
\index{getDiscSolver()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver.getDiscSolver()}{\membername{getDiscSolver}}
{\tt protected MpsLpDiscountedSolver\ {\bf getDiscSolver}(  )
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver.getDiscSolver()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the discSolver. 
}%end item
\end{itemize}
}%end item
\divideents{getIterations}
\item{\vskip -1.9ex 
\index{getIterations()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver.getIterations()}{\membername{getIterations}}
{\tt public abstract long\ {\bf getIterations}(  )
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver.getIterations()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the iterations in the last solve. 
}%end item
\end{itemize}
}%end item
\divideents{getLpSolveTime}
\item{\vskip -1.9ex 
\index{getLpSolveTime()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver.getLpSolveTime()}{\membername{getLpSolveTime}}
{\tt public long\ {\bf getLpSolveTime}(  )
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver.getLpSolveTime()}}%end signature
}%end item
\divideents{getMpsFile}
\item{\vskip -1.9ex 
\index{getMpsFile()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver.getMpsFile()}{\membername{getMpsFile}}
{\tt  java.io.File\ {\bf getMpsFile}(  )
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver.getMpsFile()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.MpsLpSolver}{MpsLpSolver}{\small \refdefined{jmarkov.jmdp.solvers.MpsLpSolver}} }

Returns the MPS file name.
}
\item{{\bf Returns} -- 
Returns the MPS generated file. 
}%end item
\end{itemize}
}%end item
\divideents{getMpsFileName}
\item{\vskip -1.9ex 
\index{getMpsFileName()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver.getMpsFileName()}{\membername{getMpsFileName}}
{\tt  java.lang.String\ {\bf getMpsFileName}(  )
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver.getMpsFileName()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.MpsLpSolver}{MpsLpSolver}{\small \refdefined{jmarkov.jmdp.solvers.MpsLpSolver}} }

Returns the MPS file name.
}
\item{{\bf Returns} -- 
Returns the fileName. 
}%end item
\end{itemize}
}%end item
\divideents{getProcessTime}
\item{\vskip -1.9ex 
\index{getProcessTime()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver.getProcessTime()}{\membername{getProcessTime}}
{\tt public abstract long\ {\bf getProcessTime}(  )
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver.getProcessTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the processTime of the last solve. Use {\tt\small System.currentTimeMillis()} to get the current time. 
}%end item
\end{itemize}
}%end item
\divideents{getSolBuildTime}
\item{\vskip -1.9ex 
\index{getSolBuildTime()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver.getSolBuildTime()}{\membername{getSolBuildTime}}
{\tt public long\ {\bf getSolBuildTime}(  )
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver.getSolBuildTime()}}%end signature
}%end item
\divideents{getWorkingDir}
\item{\vskip -1.9ex 
\index{getWorkingDir()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver.getWorkingDir()}{\membername{getWorkingDir}}
{\tt public final java.io.File\ {\bf getWorkingDir}(  )
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver.getWorkingDir()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.MpsLpSolver.getWorkingDir()}{MpsLpSolver.getWorkingDir()}} {\small 
\refdefined{jmarkov.jmdp.solvers.MpsLpSolver.getWorkingDir()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpAverageSolver.solve()}{\membername{solve}}
{\tt public abstract jmarkov.basic.Solution\ {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.MpsLpAverageSolver.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

Called to solve the problem. This method MUST write the local variable policy and valueFunction.
}
\item{{\bf Returns} -- 
The solution Object taht contains the plicy and value fuenction. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- This exception is thrown if the solver cannot find a solution for some reason.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractAverageSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractAverageSolver}}}{
{\small 
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractInfiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected DTMDP {\bf getDiscreteProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getIterations}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public InfiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MpsLpDiscountedSolver}
\subsection{\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver}\index{MpsLpDiscountedSolver}{\bf {\it Class} MpsLpDiscountedSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver}{}\vskip .1in 
This class builds a Linear Program for a discounted infinite horizon MDP in a MPS file. A extending class must code solveLP method in order to solve the problem.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.solveLP()}{MpsLpDiscountedSolver.solveLP()}} {\small 
\refdefined{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.solveLP()}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class MpsLpDiscountedSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractDiscountedSolver
\refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}\\ {\bf implements} 
MpsLpSolver}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double)}{{\bf MpsLpDiscountedSolver(DTMDP, double)}} This is the default constructor for MpsLpDiscountedSolver class, and defines the label MDP for the MPS File.\\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double, boolean)}{{\bf MpsLpDiscountedSolver(DTMDP, double, boolean)}} The constructor is used by the partner average solver.\\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double, java.lang.String, java.lang.String)}{{\bf MpsLpDiscountedSolver(DTMDP, double, String, String)}} The constructor method exclusively receives a problem of the type infinite DTMDP , an interest rate that is modified for being used as discount factor and the name that the user wants for the MPS File.\\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double, java.lang.String, java.lang.String, boolean)}{{\bf MpsLpDiscountedSolver(DTMDP, double, String, String, boolean)}} The constructor is used by the partenr average solver.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.buildSolution()}{{\bf buildSolution()}} The implementator classes should override this class to build the solution after the model has been solved.\\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getBuildTime()}{{\bf getBuildTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getLpSolveTime()}{{\bf getLpSolveTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getMpsFile()}{{\bf getMpsFile()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getMpsFileName()}{{\bf getMpsFileName()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getProcessTime()}{{\bf getProcessTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getSolBuildTime()}{{\bf getSolBuildTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getWorkingDir()}{{\bf getWorkingDir()}} Returns the working directory (where the MPS file is located)\\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.isAvg()}{{\bf isAvg()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.solve()}{{\bf solve()}} \\
\hyperlink{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.solveLP()}{{\bf solveLP()}} The implementator classes should override this class to solve the problem using the mpsFile that has been created.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MpsLpDiscountedSolver(DTMDP, double)}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double)}{\membername{MpsLpDiscountedSolver}}
{\tt public\ {\bf MpsLpDiscountedSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt double} {\bf interestRate} )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This is the default constructor for MpsLpDiscountedSolver class, and defines the label MDP for the MPS File. The constructor method exclusively receives a problem of the type infinite DTMDP , an interest rate that is modified for being used as discount factor.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- The structure of the problem of type infinite DTMDP.}
   \item{
\sld
{\tt interestRate} -- A rate which is paid for the use of a resource.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MpsLpDiscountedSolver}
\item{\vskip -1.9ex 
\index{MpsLpDiscountedSolver(DTMDP, double, boolean)}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double, boolean)}{\membername{MpsLpDiscountedSolver}}
{\tt protected\ {\bf MpsLpDiscountedSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt double} {\bf interestRate},
{\tt boolean} {\bf isAverage} )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The constructor is used by the partner average solver.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- The structure of the problem of type infinite DTMDP.}
   \item{
\sld
{\tt interestRate} -- A rate which is paid for the use of a resource.}
   \item{
\sld
{\tt isAverage} -- True if an average model is being built.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MpsLpDiscountedSolver}
\item{\vskip -1.9ex 
\index{MpsLpDiscountedSolver(DTMDP, double, String, String)}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double, java.lang.String, java.lang.String)}{\membername{MpsLpDiscountedSolver}}
{\tt public\ {\bf MpsLpDiscountedSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt double} {\bf interestRate},
{\tt java.lang.String} {\bf workingDir},
{\tt java.lang.String} {\bf fileName} )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double, java.lang.String, java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The constructor method exclusively receives a problem of the type infinite DTMDP , an interest rate that is modified for being used as discount factor and the name that the user wants for the MPS File.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- The structure of the problem of type infinite DTMDP.}
   \item{
\sld
{\tt interestRate} -- A rate which is paid for the use of a resource.}
   \item{
\sld
{\tt workingDir} -- Where the MPS file will be created.}
   \item{
\sld
{\tt fileName} -- Name for the MPS File (with no path).}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MpsLpDiscountedSolver}
\item{\vskip -1.9ex 
\index{MpsLpDiscountedSolver(DTMDP, double, String, String, boolean)}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double, java.lang.String, java.lang.String, boolean)}{\membername{MpsLpDiscountedSolver}}
{\tt protected\ {\bf MpsLpDiscountedSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt double} {\bf interestRate},
{\tt java.lang.String} {\bf workingDir},
{\tt java.lang.String} {\bf fileName},
{\tt boolean} {\bf isAverage} )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver(jmarkov.jmdp.DTMDP, double, java.lang.String, java.lang.String, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The constructor is used by the partenr average solver.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- The structure of the problem of type infinite DTMDP.}
   \item{
\sld
{\tt interestRate} -- A rate which is paid for the use of a resource.}
   \item{
\sld
{\tt workingDir} -- Where the MPS file will be created.}
   \item{
\sld
{\tt fileName} -- Name for the MPS File (with no path).}
   \item{
\sld
{\tt isAverage} -- True if an average model is being built.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{buildSolution()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.buildSolution()}{\membername{buildSolution}}
{\tt public abstract jmarkov.basic.Solution\ {\bf buildSolution}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.buildSolution()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The implementator classes should override this class to build the solution after the model has been solved.
}
\item{{\bf Returns} -- 
The solution to the problem. 
}%end item
\end{itemize}
}%end item
\divideents{getBuildTime}
\item{\vskip -1.9ex 
\index{getBuildTime()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getBuildTime()}{\membername{getBuildTime}}
{\tt public final long\ {\bf getBuildTime}(  )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getBuildTime()}}%end signature
}%end item
\divideents{getLpSolveTime}
\item{\vskip -1.9ex 
\index{getLpSolveTime()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getLpSolveTime()}{\membername{getLpSolveTime}}
{\tt public final long\ {\bf getLpSolveTime}(  )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getLpSolveTime()}}%end signature
}%end item
\divideents{getMpsFile}
\item{\vskip -1.9ex 
\index{getMpsFile()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getMpsFile()}{\membername{getMpsFile}}
{\tt  java.io.File\ {\bf getMpsFile}(  )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getMpsFile()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.MpsLpSolver}{MpsLpSolver}{\small \refdefined{jmarkov.jmdp.solvers.MpsLpSolver}} }

Returns the MPS file name.
}
\item{{\bf Returns} -- 
Returns the MPS generated file. 
}%end item
\end{itemize}
}%end item
\divideents{getMpsFileName}
\item{\vskip -1.9ex 
\index{getMpsFileName()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getMpsFileName()}{\membername{getMpsFileName}}
{\tt  java.lang.String\ {\bf getMpsFileName}(  )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getMpsFileName()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.MpsLpSolver}{MpsLpSolver}{\small \refdefined{jmarkov.jmdp.solvers.MpsLpSolver}} }

Returns the MPS file name.
}
\item{{\bf Returns} -- 
Returns the fileName. 
}%end item
\end{itemize}
}%end item
\divideents{getProcessTime}
\item{\vskip -1.9ex 
\index{getProcessTime()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getProcessTime()}{\membername{getProcessTime}}
{\tt public abstract long\ {\bf getProcessTime}(  )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getProcessTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the processTime of the last solve. Use {\tt\small System.currentTimeMillis()} to get the current time. 
}%end item
\end{itemize}
}%end item
\divideents{getSolBuildTime}
\item{\vskip -1.9ex 
\index{getSolBuildTime()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getSolBuildTime()}{\membername{getSolBuildTime}}
{\tt public final long\ {\bf getSolBuildTime}(  )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getSolBuildTime()}}%end signature
}%end item
\divideents{getWorkingDir}
\item{\vskip -1.9ex 
\index{getWorkingDir()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getWorkingDir()}{\membername{getWorkingDir}}
{\tt public final java.io.File\ {\bf getWorkingDir}(  )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.getWorkingDir()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the working directory (where the MPS file is located)
}
\item{{\bf Returns} -- 
Returns the MPS File folder. 
}%end item
\end{itemize}
}%end item
\divideents{isAvg}
\item{\vskip -1.9ex 
\index{isAvg()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.isAvg()}{\membername{isAvg}}
{\tt public final boolean\ {\bf isAvg}(  )
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.isAvg()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the true if an Average problem is being solved. 
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.solve()}{\membername{solve}}
{\tt public abstract jmarkov.basic.Solution\ {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

Called to solve the problem. This method MUST write the local variable policy and valueFunction.
}
\item{{\bf Returns} -- 
The solution Object taht contains the plicy and value fuenction. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- This exception is thrown if the solver cannot find a solution for some reason.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solveLP}
\item{\vskip -1.9ex 
\index{solveLP()}
\hypertarget{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.solveLP()}{\membername{solveLP}}
{\tt public abstract void\ {\bf solveLP}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.MpsLpDiscountedSolver.solveLP()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The implementator classes should override this class to solve the problem using the mpsFile that has been created.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractDiscountedSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf discountFactor}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final double {\bf future}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt double} {\bf discountF} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final double {\bf future}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt double} {\bf discountF},
{\tt jmarkov.basic.ValueFunction} {\bf vf} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getInterestRate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final void {\bf setDiscountFactor}( {\tt double} {\bf discountFactor} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractInfiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected DTMDP {\bf getDiscreteProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getIterations}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public InfiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{PolicyIterationSolver}
\subsection{\label{jmarkov.jmdp.solvers.PolicyIterationSolver}\index{PolicyIterationSolver}{\bf {\it Class} PolicyIterationSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver}{}\vskip .1in 
This class solves infinite horizon discounted problems using the policy iteration algorithm. It extends Solver and should only be used on infinite horizon problems. The objective function the solver uses is the discounted cost. The result is a deterministic optimal policy for the given structure. Policy Iteration is a solver method this is always convergent in a finite number of iterations. The algorithm has to solve a linear system of equations as big as the amount of states. When there are too many states, it is recommendable to use other solvers, or using the modified policy iteration (by using the second constructor). Policy Iteration is a solver method this is always convergent in a finite number of iterations. The algorithm has to solve a linear system of equations as big as the amount of states. When there are too many states, it is recommendable to use other solvers. The advantage of using Policy Iteration is that the result is the true optimal solution and not an aproximation as in other common methods. The method starts with a policy. It solves the system of linear equations for the value functions for that policy. With this values it looks for a better policy. It then solves the value functions again and looks for a better policy. If this policy is equal to the last policy tried, it stops, in any other case it keeps improving the policy and updating the value functions.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class PolicyIterationSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractDiscountedSolver
\refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.iterations}{{\bf iterations}} Used to store the number of iterations\\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.processTime}{{\bf processTime}} Used to store process time\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver(jmarkov.jmdp.DTMDP, double)}{{\bf PolicyIterationSolver(DTMDP, double)}} The constructor method exclusively receives a problem of the type InfiniteMDP because this solver is only designed to work on infinite horizon problems.\\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver(jmarkov.jmdp.DTMDP, double, boolean)}{{\bf PolicyIterationSolver(DTMDP, double, boolean)}} The constructor method exclusively receives a problem of the type InfiniteMDP because this solver is only designed to work on infinite horizon problems.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.description()}{{\bf description()}} \\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.getIncreasingFactor()}{{\bf getIncreasingFactor()}} \\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.getInitialIterations()}{{\bf getInitialIterations()}} \\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.getIterations()}{{\bf getIterations()}} \\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.getProcessTime()}{{\bf getProcessTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.label()}{{\bf label()}} \\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.setIncreasingFactor(double)}{{\bf setIncreasingFactor(double)}} Sets the increasing factor of the maximum iterations of the Modified policy iteration method.\\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.setInitialIterations(int)}{{\bf setInitialIterations(int)}} Sets maximum iterations for the first run of the modified policy iteration.\\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.setModifiedPolicy(boolean)}{{\bf setModifiedPolicy(boolean)}} Activates the modified policy iteration algorithm.\\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.solve()}{{\bf solve()}} \\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.solveMatrix()}{{\bf solveMatrix()}} This method is used by the PolicyIterationSolver to solve the linear system of equations to determine the value functions of each state for a given policy.\\
\hyperlink{jmarkov.jmdp.solvers.PolicyIterationSolver.solveMatrixModified(jmarkov.basic.DecisionRule)}{{\bf solveMatrixModified(DecisionRule)}} This method is used by the PolicyIterationSolver to solve the linear system of equations to determine the value functions of each state for a given policy.\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{iterations}
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.iterations}\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.iterations}{protected long {\bf iterations}}
\begin{itemize}
\item{\vskip -.9ex 
Used to store the number of iterations}
\end{itemize}
}
\item{
\index{processTime}
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.processTime}\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.processTime}{protected long {\bf processTime}}
\begin{itemize}
\item{\vskip -.9ex 
Used to store process time}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{PolicyIterationSolver(DTMDP, double)}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver(jmarkov.jmdp.DTMDP, double)}{\membername{PolicyIterationSolver}}
{\tt public\ {\bf PolicyIterationSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt double} {\bf discountFactor} )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver(jmarkov.jmdp.DTMDP, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The constructor method exclusively receives a problem of the type InfiniteMDP because this solver is only designed to work on infinite horizon problems. This solver solves the discounted objective function problem.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- the structure of the problem of type InfiniteMDP}
   \item{
\sld
{\tt discountFactor} -- represents how much less is the reward received in the next period instead of receiving it in the present period.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{PolicyIterationSolver}
\item{\vskip -1.9ex 
\index{PolicyIterationSolver(DTMDP, double, boolean)}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver(jmarkov.jmdp.DTMDP, double, boolean)}{\membername{PolicyIterationSolver}}
{\tt public\ {\bf PolicyIterationSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt double} {\bf discountFactor},
{\tt boolean} {\bf setModifiedPolicy} )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver(jmarkov.jmdp.DTMDP, double, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The constructor method exclusively receives a problem of the type InfiniteMDP because this solver is only designed to work on infinite horizon problems. This solver solves the discounted objective function problem.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- the structure of the problem of type InfiniteMDP}
   \item{
\sld
{\tt discountFactor} -- represents how much less is the reward received in the next period instead of receiving it in the present period.}
   \item{
\sld
{\tt setModifiedPolicy} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.description()}{\membername{description}}
{\tt  java.lang.String\ {\bf description}(  )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.JMarkovElement}{jmarkov.basic.JMarkovElement}{\small \refdefined{jmarkov.basic.JMarkovElement}} }

This method return a complete verbal describtion of this element. This description may contain multiple text rows.
}
\item{{\bf Returns} -- 
A String describing this element. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.label()}{jmarkov.basic.JMarkovElement.label()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getIncreasingFactor}
\item{\vskip -1.9ex 
\index{getIncreasingFactor()}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.getIncreasingFactor()}{\membername{getIncreasingFactor}}
{\tt public double\ {\bf getIncreasingFactor}(  )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.getIncreasingFactor()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
increasing factor of the maximum iterations. 
}%end item
\end{itemize}
}%end item
\divideents{getInitialIterations}
\item{\vskip -1.9ex 
\index{getInitialIterations()}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.getInitialIterations()}{\membername{getInitialIterations}}
{\tt public double\ {\bf getInitialIterations}(  )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.getInitialIterations()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
initial maximum iterations of the modified policy iteration algorithm. 
}%end item
\end{itemize}
}%end item
\divideents{getIterations}
\item{\vskip -1.9ex 
\index{getIterations()}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.getIterations()}{\membername{getIterations}}
{\tt public abstract long\ {\bf getIterations}(  )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.getIterations()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the iterations in the last solve. 
}%end item
\end{itemize}
}%end item
\divideents{getProcessTime}
\item{\vskip -1.9ex 
\index{getProcessTime()}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.getProcessTime()}{\membername{getProcessTime}}
{\tt public abstract long\ {\bf getProcessTime}(  )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.getProcessTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the processTime of the last solve. Use {\tt\small System.currentTimeMillis()} to get the current time. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.label()}{\membername{label}}
{\tt public abstract java.lang.String\ {\bf label}(  )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

The sub classes must return the Solver name.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.Solver.toString()}{Solver.toString()}} {\small 
\refdefined{jmarkov.jmdp.solvers.Solver.toString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setIncreasingFactor}
\item{\vskip -1.9ex 
\index{setIncreasingFactor(double)}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.setIncreasingFactor(double)}{\membername{setIncreasingFactor}}
{\tt public void\ {\bf setIncreasingFactor}( {\tt double} {\bf increasingFactor} )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.setIncreasingFactor(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the increasing factor of the maximum iterations of the Modified policy iteration method. The first iterations are a vague aproximation to the real value functions and need not be exhaustive. But the last iterations must refine the value functions in order to get better precision. The increasing factor determines how many iteratinos are to be done in each iteration. Faster growth will be more precise but computationaly more expensive.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt increasingFactor} -- greater that 1. Determines max iterations growth.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setInitialIterations}
\item{\vskip -1.9ex 
\index{setInitialIterations(int)}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.setInitialIterations(int)}{\membername{setInitialIterations}}
{\tt public void\ {\bf setInitialIterations}( {\tt int} {\bf initialIterations} )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.setInitialIterations(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets maximum iterations for the first run of the modified policy iteration.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt initialIterations} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setModifiedPolicy}
\item{\vskip -1.9ex 
\index{setModifiedPolicy(boolean)}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.setModifiedPolicy(boolean)}{\membername{setModifiedPolicy}}
{\tt public void\ {\bf setModifiedPolicy}( {\tt boolean} {\bf val} )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.setModifiedPolicy(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Activates the modified policy iteration algorithm.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt val} -- True if the modified policy iteration is to be used.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.solve()}{\membername{solve}}
{\tt public abstract jmarkov.basic.Solution\ {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

Called to solve the problem. This method MUST write the local variable policy and valueFunction.
}
\item{{\bf Returns} -- 
The solution Object taht contains the plicy and value fuenction. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- This exception is thrown if the solver cannot find a solution for some reason.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solveMatrix}
\item{\vskip -1.9ex 
\index{solveMatrix()}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.solveMatrix()}{\membername{solveMatrix}}
{\tt protected jmarkov.basic.ValueFunction\ {\bf solveMatrix}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.solveMatrix()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method is used by the PolicyIterationSolver to solve the linear system of equations to determine the value functions of each state for a given policy.
}
\item{{\bf Returns} -- 
a DenseVector (type defined in the JMP package documentation) with the value functions for each state. The index for each state are the same ones determined in the localStates ArrayList 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solveMatrixModified}
\item{\vskip -1.9ex 
\index{solveMatrixModified(DecisionRule)}
\hypertarget{jmarkov.jmdp.solvers.PolicyIterationSolver.solveMatrixModified(jmarkov.basic.DecisionRule)}{\membername{solveMatrixModified}}
{\tt protected jmarkov.basic.ValueFunction\ {\bf solveMatrixModified}( {\tt jmarkov.basic.DecisionRule} {\bf localDecisionRule} )
\label{jmarkov.jmdp.solvers.PolicyIterationSolver.solveMatrixModified(jmarkov.basic.DecisionRule)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method is used by the PolicyIterationSolver to solve the linear system of equations to determine the value functions of each state for a given policy.
}
\item{{\bf Returns} -- 
a DenseVector (type defined in the JMP package documentation) with the value functions for each state. The index for each state are the same ones determined in the localStates ArrayList declared as static. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractDiscountedSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf discountFactor}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final double {\bf future}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt double} {\bf discountF} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final double {\bf future}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt double} {\bf discountF},
{\tt jmarkov.basic.ValueFunction} {\bf vf} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getInterestRate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final void {\bf setDiscountFactor}( {\tt double} {\bf discountFactor} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractInfiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected DTMDP {\bf getDiscreteProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getIterations}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public InfiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{ProbabilitySolver}
\subsection{\label{jmarkov.jmdp.solvers.ProbabilitySolver}\index{ProbabilitySolver}{\bf {\it Class} ProbabilitySolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.ProbabilitySolver}{}\vskip .1in 
This class is designed to calculate the long run probabilities of infinite horizon problem. It uses Jacobi and Power methods for sparse matrixes. Of course this class is not needed, and it is here for idiotic reasons and the extreme arrogance of Mr. Sarmiento. To do this jmdp should pass the problem to JMarkov\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class ProbabilitySolver
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.CTMDP)}{{\bf ProbabilitySolver(CTMDP)}} Initializes a new solver for continuous chains and solves the probabilities for the optimal policy.\\
\hyperlink{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.CTMDP, jmarkov.basic.DecisionRule)}{{\bf ProbabilitySolver(CTMDP, DecisionRule)}} Initializes a new solver for continuous chains and solves the probabilities for a particular decision rule.\\
\hyperlink{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.DTMDP)}{{\bf ProbabilitySolver(DTMDP)}} Initializes a new solver for discrete chains and solves the probabilities for the optimal policy.\\
\hyperlink{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.DTMDP, jmarkov.basic.DecisionRule)}{{\bf ProbabilitySolver(DTMDP, DecisionRule)}} Initializes a new solver for discrete chains\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.ProbabilitySolver.getProbability()}{{\bf getProbability()}} \\
\hyperlink{jmarkov.jmdp.solvers.ProbabilitySolver.isSolved()}{{\bf isSolved()}} \\
\hyperlink{jmarkov.jmdp.solvers.ProbabilitySolver.setGaussSeidel(boolean)}{{\bf setGaussSeidel(boolean)}} The GaussSeidel modification of the ValueIteration method is a change that is garanteed to have a performance at least as good as the methods without the modifications.\\
\hyperlink{jmarkov.jmdp.solvers.ProbabilitySolver.setJacobi(boolean)}{{\bf setJacobi(boolean)}} \\
\hyperlink{jmarkov.jmdp.solvers.ProbabilitySolver.solve()}{{\bf solve()}} Solves the probabilities\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{ProbabilitySolver(CTMDP)}
\hypertarget{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.CTMDP)}{\membername{ProbabilitySolver}}
{\tt public\ {\bf ProbabilitySolver}( {\tt jmarkov.jmdp.CTMDP} {\bf problem} ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.CTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Initializes a new solver for continuous chains and solves the probabilities for the optimal policy.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- continuous time , infinite horizon problem}
  \end{itemize}
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{ProbabilitySolver}
\item{\vskip -1.9ex 
\index{ProbabilitySolver(CTMDP, DecisionRule)}
\hypertarget{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.CTMDP, jmarkov.basic.DecisionRule)}{\membername{ProbabilitySolver}}
{\tt public\ {\bf ProbabilitySolver}( {\tt jmarkov.jmdp.CTMDP} {\bf problem},
{\tt jmarkov.basic.DecisionRule} {\bf dr} )
\label{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.CTMDP, jmarkov.basic.DecisionRule)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Initializes a new solver for continuous chains and solves the probabilities for a particular decision rule.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- continuous time , infinite horizon problem}
   \item{
\sld
{\tt dr} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{ProbabilitySolver}
\item{\vskip -1.9ex 
\index{ProbabilitySolver(DTMDP)}
\hypertarget{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.DTMDP)}{\membername{ProbabilitySolver}}
{\tt public\ {\bf ProbabilitySolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem} ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.DTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Initializes a new solver for discrete chains and solves the probabilities for the optimal policy.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- discrete time , infinite horizon problem}
  \end{itemize}
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{ProbabilitySolver}
\item{\vskip -1.9ex 
\index{ProbabilitySolver(DTMDP, DecisionRule)}
\hypertarget{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.DTMDP, jmarkov.basic.DecisionRule)}{\membername{ProbabilitySolver}}
{\tt public\ {\bf ProbabilitySolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt jmarkov.basic.DecisionRule} {\bf dr} )
\label{jmarkov.jmdp.solvers.ProbabilitySolver(jmarkov.jmdp.DTMDP, jmarkov.basic.DecisionRule)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Initializes a new solver for discrete chains
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- discrete time , infinite horizon problem}
   \item{
\sld
{\tt dr} -- decision rule to be evaluated}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getProbability()}
\hypertarget{jmarkov.jmdp.solvers.ProbabilitySolver.getProbability()}{\membername{getProbability}}
{\tt public jmarkov.basic.ValueFunction\ {\bf getProbability}(  )
\label{jmarkov.jmdp.solvers.ProbabilitySolver.getProbability()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the probability. 
}%end item
\end{itemize}
}%end item
\divideents{isSolved}
\item{\vskip -1.9ex 
\index{isSolved()}
\hypertarget{jmarkov.jmdp.solvers.ProbabilitySolver.isSolved()}{\membername{isSolved}}
{\tt public boolean\ {\bf isSolved}(  )
\label{jmarkov.jmdp.solvers.ProbabilitySolver.isSolved()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
true if the probabilities were calculated. 
}%end item
\end{itemize}
}%end item
\divideents{setGaussSeidel}
\item{\vskip -1.9ex 
\index{setGaussSeidel(boolean)}
\hypertarget{jmarkov.jmdp.solvers.ProbabilitySolver.setGaussSeidel(boolean)}{\membername{setGaussSeidel}}
{\tt public void\ {\bf setGaussSeidel}( {\tt boolean} {\bf val} )
\label{jmarkov.jmdp.solvers.ProbabilitySolver.setGaussSeidel(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The GaussSeidel modification of the ValueIteration method is a change that is garanteed to have a performance at least as good as the methods without the modifications. In many problems, specially the ones with many states, the modification can imply a significant improvement. By default it set to true. It provides no significant improvement if used jointly with the ErrorBounds modification.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt val} -- sets whether or not the GaussSeidel modification will be used.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setJacobi}
\item{\vskip -1.9ex 
\index{setJacobi(boolean)}
\hypertarget{jmarkov.jmdp.solvers.ProbabilitySolver.setJacobi(boolean)}{\membername{setJacobi}}
{\tt public void\ {\bf setJacobi}( {\tt boolean} {\bf val} )
\label{jmarkov.jmdp.solvers.ProbabilitySolver.setJacobi(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt val} -- true to use jacobi methods}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.solvers.ProbabilitySolver.solve()}{\membername{solve}}
{\tt public void\ {\bf solve}(  )
\label{jmarkov.jmdp.solvers.ProbabilitySolver.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Solves the probabilities
}
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{RelativeValueIterationSolver}
\subsection{\label{jmarkov.jmdp.solvers.RelativeValueIterationSolver}\index{RelativeValueIterationSolver}{\bf {\it Class} RelativeValueIterationSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.RelativeValueIterationSolver}{}\vskip .1in 
This class solves the average cost criteria for infinite horizon problems\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class RelativeValueIterationSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractAverageSolver
\refdefined{jmarkov.jmdp.solvers.AbstractAverageSolver}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.CTMDP)}{{\bf RelativeValueIterationSolver(CTMDP)}} Creates a new solver for a continuous time, infinite horizon problem.\\
\hyperlink{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.CTMDP, double)}{{\bf RelativeValueIterationSolver(CTMDP, double)}} Creates a new solver for a continuous time, infinite horizon problem to be solved with the modified relative value iteration method.\\
\hyperlink{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.DTMDP)}{{\bf RelativeValueIterationSolver(DTMDP)}} The constructor method exclusively receives a discrte time infinite horizon problem of the type DTMDP.\\
\hyperlink{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.DTMDP, double)}{{\bf RelativeValueIterationSolver(DTMDP, double)}} Creates a new solver for the given discrete time, infinite horizon problem.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.RelativeValueIterationSolver.getIterations()}{{\bf getIterations()}} \\
\hyperlink{jmarkov.jmdp.solvers.RelativeValueIterationSolver.getProcessTime()}{{\bf getProcessTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.RelativeValueIterationSolver.label()}{{\bf label()}} \\
\hyperlink{jmarkov.jmdp.solvers.RelativeValueIterationSolver.setFactor(double)}{{\bf setFactor(double)}} Sets the factor for the modified relative value iteration method.\\
\hyperlink{jmarkov.jmdp.solvers.RelativeValueIterationSolver.setPrintValueFunction(boolean)}{{\bf setPrintValueFunction(boolean)}} \\
\hyperlink{jmarkov.jmdp.solvers.RelativeValueIterationSolver.solve()}{{\bf solve()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{RelativeValueIterationSolver(CTMDP)}
\hypertarget{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.CTMDP)}{\membername{RelativeValueIterationSolver}}
{\tt public\ {\bf RelativeValueIterationSolver}( {\tt jmarkov.jmdp.CTMDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.CTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new solver for a continuous time, infinite horizon problem.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- continuous time, infinite horizon problem}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{RelativeValueIterationSolver}
\item{\vskip -1.9ex 
\index{RelativeValueIterationSolver(CTMDP, double)}
\hypertarget{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.CTMDP, double)}{\membername{RelativeValueIterationSolver}}
{\tt public\ {\bf RelativeValueIterationSolver}( {\tt jmarkov.jmdp.CTMDP} {\bf problem},
{\tt double} {\bf factor} )
\label{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.CTMDP, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new solver for a continuous time, infinite horizon problem to be solved with the modified relative value iteration method.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- continuous time, infinite horizon problem}
   \item{
\sld
{\tt factor} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{RelativeValueIterationSolver}
\item{\vskip -1.9ex 
\index{RelativeValueIterationSolver(DTMDP)}
\hypertarget{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.DTMDP)}{\membername{RelativeValueIterationSolver}}
{\tt public\ {\bf RelativeValueIterationSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.DTMDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The constructor method exclusively receives a discrte time infinite horizon problem of the type DTMDP.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- the structure of the problem of type InfiniteMDP}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{RelativeValueIterationSolver}
\item{\vskip -1.9ex 
\index{RelativeValueIterationSolver(DTMDP, double)}
\hypertarget{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.DTMDP, double)}{\membername{RelativeValueIterationSolver}}
{\tt public\ {\bf RelativeValueIterationSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt double} {\bf factor} )
\label{jmarkov.jmdp.solvers.RelativeValueIterationSolver(jmarkov.jmdp.DTMDP, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new solver for the given discrete time, infinite horizon problem. It uses the modified relative value iteration method. For details, consult the User's Manual. The factor helps avoiding periodicity in the chain.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- problem}
   \item{
\sld
{\tt factor} -- factor}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getIterations()}
\hypertarget{jmarkov.jmdp.solvers.RelativeValueIterationSolver.getIterations()}{\membername{getIterations}}
{\tt public abstract long\ {\bf getIterations}(  )
\label{jmarkov.jmdp.solvers.RelativeValueIterationSolver.getIterations()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the iterations in the last solve. 
}%end item
\end{itemize}
}%end item
\divideents{getProcessTime}
\item{\vskip -1.9ex 
\index{getProcessTime()}
\hypertarget{jmarkov.jmdp.solvers.RelativeValueIterationSolver.getProcessTime()}{\membername{getProcessTime}}
{\tt public abstract long\ {\bf getProcessTime}(  )
\label{jmarkov.jmdp.solvers.RelativeValueIterationSolver.getProcessTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the processTime of the last solve. Use {\tt\small System.currentTimeMillis()} to get the current time. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.jmdp.solvers.RelativeValueIterationSolver.label()}{\membername{label}}
{\tt public abstract java.lang.String\ {\bf label}(  )
\label{jmarkov.jmdp.solvers.RelativeValueIterationSolver.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

The sub classes must return the Solver name.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.Solver.toString()}{Solver.toString()}} {\small 
\refdefined{jmarkov.jmdp.solvers.Solver.toString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setFactor}
\item{\vskip -1.9ex 
\index{setFactor(double)}
\hypertarget{jmarkov.jmdp.solvers.RelativeValueIterationSolver.setFactor(double)}{\membername{setFactor}}
{\tt public void\ {\bf setFactor}( {\tt double} {\bf factor} )
\label{jmarkov.jmdp.solvers.RelativeValueIterationSolver.setFactor(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the factor for the modified relative value iteration method.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt factor} -- A number between 0 and 1.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setPrintValueFunction}
\item{\vskip -1.9ex 
\index{setPrintValueFunction(boolean)}
\hypertarget{jmarkov.jmdp.solvers.RelativeValueIterationSolver.setPrintValueFunction(boolean)}{\membername{setPrintValueFunction}}
{\tt public void\ {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
\label{jmarkov.jmdp.solvers.RelativeValueIterationSolver.setPrintValueFunction(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

Option to print the final value function for each state. It is set to false by default.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt val} -- True if the value function is to be reported.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.solvers.RelativeValueIterationSolver.solve()}{\membername{solve}}
{\tt public abstract jmarkov.basic.Solution\ {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.RelativeValueIterationSolver.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

Called to solve the problem. This method MUST write the local variable policy and valueFunction.
}
\item{{\bf Returns} -- 
The solution Object taht contains the plicy and value fuenction. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- This exception is thrown if the solver cannot find a solution for some reason.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractAverageSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractAverageSolver}}}{
{\small 
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractInfiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected DTMDP {\bf getDiscreteProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getIterations}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public InfiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{Solver}
\subsection{\label{jmarkov.jmdp.solvers.Solver}\index{Solver}{\bf {\it Class} Solver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.Solver}{}\vskip .1in 
Structural class for every solver. Any solver that a user implements must extend this class.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class Solver
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
jmarkov.basic.JMarkovElement}}}
\subsubsection{All known subclasses}{ValueIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.ValueIterationSolver}}, StochasticShortestPathSolver\small{\refdefined{jmarkov.jmdp.solvers.StochasticShortestPathSolver}}, RelativeValueIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.RelativeValueIterationSolver}}, PolicyIterationSolver\small{\refdefined{jmarkov.jmdp.solvers.PolicyIterationSolver}}, MpsLpDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpDiscountedSolver}}, MpsLpAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.MpsLpAverageSolver}}, LPBCLDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.LPBCLDiscountedSolver}}, LPBCLAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.LPBCLAverageSolver}}, FiniteSolver\small{\refdefined{jmarkov.jmdp.solvers.FiniteSolver}}, AbstractTotalSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractTotalSolver}}, AbstractInfiniteSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}, AbstractFiniteSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractFiniteSolver}}, AbstractDiscountedSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}}, AbstractAverageSolver\small{\refdefined{jmarkov.jmdp.solvers.AbstractAverageSolver}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.Solver.policy}{{\bf policy}} The policy Object.\\
\hyperlink{jmarkov.jmdp.solvers.Solver.printProcessTime}{{\bf printProcessTime}} True if the process time is to be reported\\
\hyperlink{jmarkov.jmdp.solvers.Solver.printValueFunction}{{\bf printValueFunction}} true if the value function is to be reported\\
\hyperlink{jmarkov.jmdp.solvers.Solver.problem}{{\bf problem}} The problem to be solved\\
\hyperlink{jmarkov.jmdp.solvers.Solver.solved}{{\bf solved}} Marker to indicate that the problem has been solved\\
\hyperlink{jmarkov.jmdp.solvers.Solver.valueFunction}{{\bf valueFunction}} The value function, to be written by the solver\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.Solver(jmarkov.jmdp.MDP)}{{\bf Solver(MDP)}} Default constructor.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.Solver.description()}{{\bf description()}} \\
\hyperlink{jmarkov.jmdp.solvers.Solver.getOptimalPolicy()}{{\bf getOptimalPolicy()}} Gets the optimal policy.\\
\hyperlink{jmarkov.jmdp.solvers.Solver.getOptimalValueFunction()}{{\bf getOptimalValueFunction()}} Gets the optimal ValueFunction.\\
\hyperlink{jmarkov.jmdp.solvers.Solver.getProblem()}{{\bf getProblem()}} Returns the problem associated wit this solver.\\
\hyperlink{jmarkov.jmdp.solvers.Solver.getProcessTime()}{{\bf getProcessTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.Solver.getValueFunction()}{{\bf getValueFunction()}} If the problem is solved, it will return the optimal value function.\\
\hyperlink{jmarkov.jmdp.solvers.Solver.isSolved()}{{\bf isSolved()}} Tells whether the problem has been solved.\\
\hyperlink{jmarkov.jmdp.solvers.Solver.label()}{{\bf label()}} The sub classes must return the Solver name.\\
\hyperlink{jmarkov.jmdp.solvers.Solver.printSolution()}{{\bf printSolution()}} Prints the solution in the default PrintWriter (System.out)\\
\hyperlink{jmarkov.jmdp.solvers.Solver.printSolution(java.io.PrintWriter)}{{\bf printSolution(PrintWriter)}} Prints the solution on a given PrintWriter.\\
\hyperlink{jmarkov.jmdp.solvers.Solver.setPrintProcessTime(boolean)}{{\bf setPrintProcessTime(boolean)}} Option to print the time spent solving the problem.\\
\hyperlink{jmarkov.jmdp.solvers.Solver.setPrintValueFunction(boolean)}{{\bf setPrintValueFunction(boolean)}} Option to print the final value function for each state.\\
\hyperlink{jmarkov.jmdp.solvers.Solver.solve()}{{\bf solve()}} Called to solve the problem.\\
\hyperlink{jmarkov.jmdp.solvers.Solver.toString()}{{\bf toString()}} This calls label().\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{policy}
\label{jmarkov.jmdp.solvers.Solver.policy}\hypertarget{jmarkov.jmdp.solvers.Solver.policy}{protected jmarkov.basic.Policy {\bf policy}}
\begin{itemize}
\item{\vskip -.9ex 
The policy Object. This should be written by the solver.}
\end{itemize}
}
\item{
\index{valueFunction}
\label{jmarkov.jmdp.solvers.Solver.valueFunction}\hypertarget{jmarkov.jmdp.solvers.Solver.valueFunction}{protected jmarkov.basic.ValueFunction {\bf valueFunction}}
\begin{itemize}
\item{\vskip -.9ex 
The value function, to be written by the solver}
\end{itemize}
}
\item{
\index{solved}
\label{jmarkov.jmdp.solvers.Solver.solved}\hypertarget{jmarkov.jmdp.solvers.Solver.solved}{protected boolean {\bf solved}}
\begin{itemize}
\item{\vskip -.9ex 
Marker to indicate that the problem has been solved}
\end{itemize}
}
\item{
\index{problem}
\label{jmarkov.jmdp.solvers.Solver.problem}\hypertarget{jmarkov.jmdp.solvers.Solver.problem}{protected jmarkov.jmdp.MDP {\bf problem}}
\begin{itemize}
\item{\vskip -.9ex 
The problem to be solved}
\end{itemize}
}
\item{
\index{printProcessTime}
\label{jmarkov.jmdp.solvers.Solver.printProcessTime}\hypertarget{jmarkov.jmdp.solvers.Solver.printProcessTime}{protected boolean {\bf printProcessTime}}
\begin{itemize}
\item{\vskip -.9ex 
True if the process time is to be reported}
\end{itemize}
}
\item{
\index{printValueFunction}
\label{jmarkov.jmdp.solvers.Solver.printValueFunction}\hypertarget{jmarkov.jmdp.solvers.Solver.printValueFunction}{protected boolean {\bf printValueFunction}}
\begin{itemize}
\item{\vskip -.9ex 
true if the value function is to be reported}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{Solver(MDP)}
\hypertarget{jmarkov.jmdp.solvers.Solver(jmarkov.jmdp.MDP)}{\membername{Solver}}
{\tt protected\ {\bf Solver}( {\tt jmarkov.jmdp.MDP} {\bf problem} )
\label{jmarkov.jmdp.solvers.Solver(jmarkov.jmdp.MDP)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default constructor. Receives the problem to solve. All sub classes MUST call this constructor.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- to be solved.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.jmdp.solvers.Solver.description()}{\membername{description}}
{\tt  java.lang.String\ {\bf description}(  )
\label{jmarkov.jmdp.solvers.Solver.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.JMarkovElement}{jmarkov.basic.JMarkovElement}{\small \refdefined{jmarkov.basic.JMarkovElement}} }

This method return a complete verbal describtion of this element. This description may contain multiple text rows.
}
\item{{\bf Returns} -- 
A String describing this element. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.label()}{jmarkov.basic.JMarkovElement.label()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getOptimalPolicy}
\item{\vskip -1.9ex 
\index{getOptimalPolicy()}
\hypertarget{jmarkov.jmdp.solvers.Solver.getOptimalPolicy()}{\membername{getOptimalPolicy}}
{\tt public final jmarkov.basic.Policy\ {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.Solver.getOptimalPolicy()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the optimal policy. It solves the problem if it has not been solved.
}
\item{{\bf Returns} -- 
the optimal Policy. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.Policy}{jmarkov.basic.Policy}} {\small 
\refdefined{jmarkov.basic.Policy}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getOptimalValueFunction}
\item{\vskip -1.9ex 
\index{getOptimalValueFunction()}
\hypertarget{jmarkov.jmdp.solvers.Solver.getOptimalValueFunction()}{\membername{getOptimalValueFunction}}
{\tt public final jmarkov.basic.ValueFunction\ {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.Solver.getOptimalValueFunction()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Gets the optimal ValueFunction.
}
\item{{\bf Returns} -- 
the optimal ValueFunction. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.ValueFunction}{jmarkov.basic.ValueFunction}} {\small 
\refdefined{jmarkov.basic.ValueFunction}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getProblem}
\item{\vskip -1.9ex 
\index{getProblem()}
\hypertarget{jmarkov.jmdp.solvers.Solver.getProblem()}{\membername{getProblem}}
{\tt public jmarkov.jmdp.MDP\ {\bf getProblem}(  )
\label{jmarkov.jmdp.solvers.Solver.getProblem()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the problem associated wit this solver.
}
\item{{\bf Returns} -- 
the problem associated with this solver. 
}%end item
\end{itemize}
}%end item
\divideents{getProcessTime}
\item{\vskip -1.9ex 
\index{getProcessTime()}
\hypertarget{jmarkov.jmdp.solvers.Solver.getProcessTime()}{\membername{getProcessTime}}
{\tt public abstract long\ {\bf getProcessTime}(  )
\label{jmarkov.jmdp.solvers.Solver.getProcessTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the processTime of the last solve. Use {\tt\small System.currentTimeMillis()} to get the current time. 
}%end item
\end{itemize}
}%end item
\divideents{getValueFunction}
\item{\vskip -1.9ex 
\index{getValueFunction()}
\hypertarget{jmarkov.jmdp.solvers.Solver.getValueFunction()}{\membername{getValueFunction}}
{\tt public final jmarkov.basic.ValueFunction\ {\bf getValueFunction}(  )
\label{jmarkov.jmdp.solvers.Solver.getValueFunction()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

If the problem is solved, it will return the optimal value function. Otherwise it returns the current valueFunction
}
\item{{\bf Returns} -- 
the value function in the solver. 
}%end item
\end{itemize}
}%end item
\divideents{isSolved}
\item{\vskip -1.9ex 
\index{isSolved()}
\hypertarget{jmarkov.jmdp.solvers.Solver.isSolved()}{\membername{isSolved}}
{\tt public final boolean\ {\bf isSolved}(  )
\label{jmarkov.jmdp.solvers.Solver.isSolved()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Tells whether the problem has been solved.
}
\item{{\bf Returns} -- 
true if the problem has been solved 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.jmdp.solvers.Solver.label()}{\membername{label}}
{\tt public abstract java.lang.String\ {\bf label}(  )
\label{jmarkov.jmdp.solvers.Solver.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The sub classes must return the Solver name.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.Solver.toString()}{Solver.toString()}} {\small 
\refdefined{jmarkov.jmdp.solvers.Solver.toString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printSolution}
\item{\vskip -1.9ex 
\index{printSolution()}
\hypertarget{jmarkov.jmdp.solvers.Solver.printSolution()}{\membername{printSolution}}
{\tt public void\ {\bf printSolution}(  ) throws java.lang.Exception
\label{jmarkov.jmdp.solvers.Solver.printSolution()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the solution in the default PrintWriter (System.out)
}
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.lang.Exception} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{printSolution}
\item{\vskip -1.9ex 
\index{printSolution(PrintWriter)}
\hypertarget{jmarkov.jmdp.solvers.Solver.printSolution(java.io.PrintWriter)}{\membername{printSolution}}
{\tt public void\ {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
\label{jmarkov.jmdp.solvers.Solver.printSolution(java.io.PrintWriter)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Prints the solution on a given PrintWriter.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pw} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.io.PrintWriter}{java.io.PrintWriter}} {\small 
\refdefined{java.io.PrintWriter}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setPrintProcessTime}
\item{\vskip -1.9ex 
\index{setPrintProcessTime(boolean)}
\hypertarget{jmarkov.jmdp.solvers.Solver.setPrintProcessTime(boolean)}{\membername{setPrintProcessTime}}
{\tt public void\ {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
\label{jmarkov.jmdp.solvers.Solver.setPrintProcessTime(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Option to print the time spent solving the problem. It is set to false by default.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt val} -- True if the Process tiem is to be reported, false otherwise.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setPrintValueFunction}
\item{\vskip -1.9ex 
\index{setPrintValueFunction(boolean)}
\hypertarget{jmarkov.jmdp.solvers.Solver.setPrintValueFunction(boolean)}{\membername{setPrintValueFunction}}
{\tt public void\ {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
\label{jmarkov.jmdp.solvers.Solver.setPrintValueFunction(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Option to print the final value function for each state. It is set to false by default.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt val} -- True if the value function is to be reported.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.solvers.Solver.solve()}{\membername{solve}}
{\tt public abstract jmarkov.basic.Solution\ {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.Solver.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Called to solve the problem. This method MUST write the local variable policy and valueFunction.
}
\item{{\bf Returns} -- 
The solution Object taht contains the plicy and value fuenction. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- This exception is thrown if the solver cannot find a solution for some reason.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.jmdp.solvers.Solver.toString()}{\membername{toString}}
{\tt public final java.lang.String\ {\bf toString}(  )
\label{jmarkov.jmdp.solvers.Solver.toString()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This calls label().
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.Solver.toString()}{Solver.toString()}} {\small 
\refdefined{jmarkov.jmdp.solvers.Solver.toString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{StochasticShortestPathSolver}
\subsection{\label{jmarkov.jmdp.solvers.StochasticShortestPathSolver}\index{StochasticShortestPathSolver}{\bf {\it Class} StochasticShortestPathSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.StochasticShortestPathSolver}{}\vskip .1in 
This solver gives a solution for the minimization of the total cost criterion for an infinite horizon MDP.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class StochasticShortestPathSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractTotalSolver
\refdefined{jmarkov.jmdp.solvers.AbstractTotalSolver}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.StochasticShortestPathSolver(jmarkov.jmdp.StochasticShortestPath)}{{\bf StochasticShortestPathSolver(StochasticShortestPath)}} Default contructor.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.StochasticShortestPathSolver.bestAction(S)}{{\bf bestAction(S)}} Sets the best action to take in state i, in the variable bestAction.\\
\hyperlink{jmarkov.jmdp.solvers.StochasticShortestPathSolver.description()}{{\bf description()}} \\
\hyperlink{jmarkov.jmdp.solvers.StochasticShortestPathSolver.future(S, A)}{{\bf future(S, A)}} This method calculates the expected value of valueFunction for the current state and a specified action.\\
\hyperlink{jmarkov.jmdp.solvers.StochasticShortestPathSolver.getIterations()}{{\bf getIterations()}} \\
\hyperlink{jmarkov.jmdp.solvers.StochasticShortestPathSolver.getProblem()}{{\bf getProblem()}} \\
\hyperlink{jmarkov.jmdp.solvers.StochasticShortestPathSolver.getProcessTime()}{{\bf getProcessTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.StochasticShortestPathSolver.label()}{{\bf label()}} \\
\hyperlink{jmarkov.jmdp.solvers.StochasticShortestPathSolver.solve()}{{\bf solve()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{StochasticShortestPathSolver(StochasticShortestPath)}
\hypertarget{jmarkov.jmdp.solvers.StochasticShortestPathSolver(jmarkov.jmdp.StochasticShortestPath)}{\membername{StochasticShortestPathSolver}}
{\tt public\ {\bf StochasticShortestPathSolver}( {\tt jmarkov.jmdp.StochasticShortestPath} {\bf problem} )
\label{jmarkov.jmdp.solvers.StochasticShortestPathSolver(jmarkov.jmdp.StochasticShortestPath)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default contructor.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- the structure of the problem of type StochasticShortestPath}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{bestAction(S)}
\hypertarget{jmarkov.jmdp.solvers.StochasticShortestPathSolver.bestAction(S)}{\membername{bestAction}}
{\tt protected double\ {\bf bestAction}( {\tt jmarkov.basic.StateC} {\bf i} ) throws jmarkov.basic.exceptions.StructureException
\label{jmarkov.jmdp.solvers.StochasticShortestPathSolver.bestAction(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the best action to take in state i, in the variable bestAction. Note that in this case StochasticShortestPathProblem Bertsekas expose a transformation for the graph which modify the inmediate reward function and the transition probability, only to make a graph without self-transition states. This will increase the finite termination probability for the algorithm.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- state for which the best action is being determined}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the new ValueFunction for this state. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.StructureException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.jmdp.solvers.StochasticShortestPathSolver.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jmarkov.jmdp.solvers.StochasticShortestPathSolver.description()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{java.lang.Object.toString()}{java.lang.Object.toString()}} {\small 
\refdefined{java.lang.Object.toString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{future}
\item{\vskip -1.9ex 
\index{future(S, A)}
\hypertarget{jmarkov.jmdp.solvers.StochasticShortestPathSolver.future(S, A)}{\membername{future}}
{\tt public final double\ {\bf future}( {\tt jmarkov.basic.StateC} {\bf i},
{\tt jmarkov.basic.Action} {\bf a} ) throws jmarkov.basic.exceptions.StructureException
\label{jmarkov.jmdp.solvers.StochasticShortestPathSolver.future(S, A)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method calculates the expected value of valueFunction for the current state and a specified action.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Current State}
   \item{
\sld
{\tt a} -- Action taken}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Future value from this state. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.StructureException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getIterations}
\item{\vskip -1.9ex 
\index{getIterations()}
\hypertarget{jmarkov.jmdp.solvers.StochasticShortestPathSolver.getIterations()}{\membername{getIterations}}
{\tt public abstract long\ {\bf getIterations}(  )
\label{jmarkov.jmdp.solvers.StochasticShortestPathSolver.getIterations()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the iterations in the last solve. 
}%end item
\end{itemize}
}%end item
\divideents{getProblem}
\item{\vskip -1.9ex 
\index{getProblem()}
\hypertarget{jmarkov.jmdp.solvers.StochasticShortestPathSolver.getProblem()}{\membername{getProblem}}
{\tt public jmarkov.jmdp.StochasticShortestPath\ {\bf getProblem}(  )
\label{jmarkov.jmdp.solvers.StochasticShortestPathSolver.getProblem()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.Solver.getProblem()}{Solver.getProblem()}} {\small 
\refdefined{jmarkov.jmdp.solvers.Solver.getProblem()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getProcessTime}
\item{\vskip -1.9ex 
\index{getProcessTime()}
\hypertarget{jmarkov.jmdp.solvers.StochasticShortestPathSolver.getProcessTime()}{\membername{getProcessTime}}
{\tt public abstract long\ {\bf getProcessTime}(  )
\label{jmarkov.jmdp.solvers.StochasticShortestPathSolver.getProcessTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the processTime of the last solve. Use {\tt\small System.currentTimeMillis()} to get the current time. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.jmdp.solvers.StochasticShortestPathSolver.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.jmdp.solvers.StochasticShortestPathSolver.label()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.Solver.label()}{Solver.label()}} {\small 
\refdefined{jmarkov.jmdp.solvers.Solver.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.solvers.StochasticShortestPathSolver.solve()}{\membername{solve}}
{\tt public abstract jmarkov.basic.Solution\ {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
\label{jmarkov.jmdp.solvers.StochasticShortestPathSolver.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

Called to solve the problem. This method MUST write the local variable policy and valueFunction.
}
\item{{\bf Returns} -- 
The solution Object taht contains the plicy and value fuenction. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.SolverException} -- This exception is thrown if the solver cannot find a solution for some reason.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractTotalSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractTotalSolver}}}{
{\small 
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractInfiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected DTMDP {\bf getDiscreteProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getIterations}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public InfiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{ValueIterationSolver}
\subsection{\label{jmarkov.jmdp.solvers.ValueIterationSolver}\index{ValueIterationSolver}{\bf {\it Class} ValueIterationSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver}{}\vskip .1in 
This class belongs to the set of default solvers included in the jmdp package. It extends Solver and should only be used on INFINITE horizon problems. The objective is to be able to return an optimal policy given a problem structure.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class ValueIterationSolver
\\ {\bf extends} jmarkov.jmdp.solvers.AbstractDiscountedSolver
\refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.iterations}{{\bf iterations}} Used to store the number of iterations\\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.processTime}{{\bf processTime}} stores the process time\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver(jmarkov.jmdp.CTMDP, double)}{{\bf ValueIterationSolver(CTMDP, double)}} Default Constructor for continuous time problems.\\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver(jmarkov.jmdp.DTMDP, double)}{{\bf ValueIterationSolver(DTMDP, double)}} Default Constructor for Discrte time problems.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.bestAction(S)}{{\bf bestAction(S)}} Find the minimal value function for this state and sets the best action to take in state i, in the variable bestAction.\\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.computeNoErrorBounds()}{{\bf computeNoErrorBounds()}} Computes an iteration of the Value Iteration Algorithm without the use of error bounds.\\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.computeWithErrorBounds()}{{\bf computeWithErrorBounds()}} Computes an iteration of the Value Iteration Algorithm with the use of error bounds.\\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.description()}{{\bf description()}} \\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.getEpsilon()}{{\bf getEpsilon()}} \\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.getIterations()}{{\bf getIterations()}} \\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.getProcessTime()}{{\bf getProcessTime()}} \\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.init()}{{\bf init()}} Initializes the valueFunction for all the states.\\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.isAverage()}{{\bf isAverage()}} \\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.label()}{{\bf label()}} \\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.setEpsilon(double)}{{\bf setEpsilon(double)}} Value Iteration is a solver method this is theoretically convergent only after infinite iterations.\\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.solve()}{{\bf solve()}} Solves the problem.\\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.useErrorBounds(boolean)}{{\bf useErrorBounds(boolean)}} The ErrorBounds modification to the ValueIteration method is a change that is garanteed to have a performance at least as good as the methos without the modifications.\\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.useGaussSeidel(boolean)}{{\bf useGaussSeidel(boolean)}} The GaussSeidel modification of the ValueIteration method is a change that is garanteed to have a performance at least as good as the methos without the modifications.\\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.usesErrorBounds()}{{\bf usesErrorBounds()}} \\
\hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.usesGaussSeidel()}{{\bf usesGaussSeidel()}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{processTime}
\label{jmarkov.jmdp.solvers.ValueIterationSolver.processTime}\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.processTime}{protected long {\bf processTime}}
\begin{itemize}
\item{\vskip -.9ex 
stores the process time}
\end{itemize}
}
\item{
\index{iterations}
\label{jmarkov.jmdp.solvers.ValueIterationSolver.iterations}\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.iterations}{protected long {\bf iterations}}
\begin{itemize}
\item{\vskip -.9ex 
Used to store the number of iterations}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{ValueIterationSolver(CTMDP, double)}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver(jmarkov.jmdp.CTMDP, double)}{\membername{ValueIterationSolver}}
{\tt public\ {\bf ValueIterationSolver}( {\tt jmarkov.jmdp.CTMDP} {\bf problem},
{\tt double} {\bf interestRate} )
\label{jmarkov.jmdp.solvers.ValueIterationSolver(jmarkov.jmdp.CTMDP, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default Constructor for continuous time problems.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- the structure of the problem of type CTMDP}
   \item{
\sld
{\tt interestRate} -- represents how much less is the reward received in the next period instead of receiving it in the present period.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{ValueIterationSolver}
\item{\vskip -1.9ex 
\index{ValueIterationSolver(DTMDP, double)}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver(jmarkov.jmdp.DTMDP, double)}{\membername{ValueIterationSolver}}
{\tt public\ {\bf ValueIterationSolver}( {\tt jmarkov.jmdp.DTMDP} {\bf problem},
{\tt double} {\bf interestRate} )
\label{jmarkov.jmdp.solvers.ValueIterationSolver(jmarkov.jmdp.DTMDP, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default Constructor for Discrte time problems.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt problem} -- the structure of the problem of type DTMDP}
   \item{
\sld
{\tt interestRate} -- represents how much less is the reward received in the next period instead of receiving it in the present period.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{bestAction(S)}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.bestAction(S)}{\membername{bestAction}}
{\tt protected double\ {\bf bestAction}( {\tt jmarkov.basic.State} {\bf i} )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.bestAction(S)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Find the minimal value function for this state and sets the best action to take in state i, in the variable bestAction.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- state for which the best action is being determined}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
the new ValueFunction for this state. 
}%end item
\end{itemize}
}%end item
\divideents{computeNoErrorBounds}
\item{\vskip -1.9ex 
\index{computeNoErrorBounds()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.computeNoErrorBounds()}{\membername{computeNoErrorBounds}}
{\tt protected double\ {\bf computeNoErrorBounds}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.computeNoErrorBounds()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes an iteration of the Value Iteration Algorithm without the use of error bounds.
}
\item{{\bf Returns} -- 
maximum change in value function due to this iteration. 
}%end item
\end{itemize}
}%end item
\divideents{computeWithErrorBounds}
\item{\vskip -1.9ex 
\index{computeWithErrorBounds()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.computeWithErrorBounds()}{\membername{computeWithErrorBounds}}
{\tt protected double\ {\bf computeWithErrorBounds}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.computeWithErrorBounds()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes an iteration of the Value Iteration Algorithm with the use of error bounds.
}
\item{{\bf Returns} -- 
maximum change in value function due to this iteration. 
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.description()}{\membername{description}}
{\tt  java.lang.String\ {\bf description}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.description()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.basic.JMarkovElement}{jmarkov.basic.JMarkovElement}{\small \refdefined{jmarkov.basic.JMarkovElement}} }

This method return a complete verbal describtion of this element. This description may contain multiple text rows.
}
\item{{\bf Returns} -- 
A String describing this element. 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.basic.JMarkovElement.label()}{jmarkov.basic.JMarkovElement.label()}} {\small 
\refdefined{jmarkov.basic.JMarkovElement.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getEpsilon}
\item{\vskip -1.9ex 
\index{getEpsilon()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.getEpsilon()}{\membername{getEpsilon}}
{\tt public final double\ {\bf getEpsilon}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.getEpsilon()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the epsilon. 
}%end item
\end{itemize}
}%end item
\divideents{getIterations}
\item{\vskip -1.9ex 
\index{getIterations()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.getIterations()}{\membername{getIterations}}
{\tt public abstract long\ {\bf getIterations}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.getIterations()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the iterations in the last solve. 
}%end item
\end{itemize}
}%end item
\divideents{getProcessTime}
\item{\vskip -1.9ex 
\index{getProcessTime()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.getProcessTime()}{\membername{getProcessTime}}
{\tt public abstract long\ {\bf getProcessTime}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.getProcessTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the processTime of the last solve. Use {\tt\small System.currentTimeMillis()} to get the current time. 
}%end item
\end{itemize}
}%end item
\divideents{init}
\item{\vskip -1.9ex 
\index{init()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.init()}{\membername{init}}
{\tt protected void\ {\bf init}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.init()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Initializes the valueFunction for all the states.
}
\end{itemize}
}%end item
\divideents{isAverage}
\item{\vskip -1.9ex 
\index{isAverage()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.isAverage()}{\membername{isAverage}}
{\tt public final boolean\ {\bf isAverage}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.isAverage()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the isAverage. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.label()}{\membername{label}}
{\tt public abstract java.lang.String\ {\bf label}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.jmdp.solvers.Solver}{Solver}{\small \refdefined{jmarkov.jmdp.solvers.Solver}} }

The sub classes must return the Solver name.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.Solver.toString()}{Solver.toString()}} {\small 
\refdefined{jmarkov.jmdp.solvers.Solver.toString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setEpsilon}
\item{\vskip -1.9ex 
\index{setEpsilon(double)}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.setEpsilon(double)}{\membername{setEpsilon}}
{\tt public synchronized void\ {\bf setEpsilon}( {\tt double} {\bf epsilon} )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.setEpsilon(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Value Iteration is a solver method this is theoretically convergent only after infinite iterations. Because of the practical impossibility to do this, the solver is designed to stop when the difference between iterations is as much as epsilon. The smaller epsilon is, the closer the result will be to the actual optimum but it will take a longer time to solve the problem. The default value of epsilon is 0.0001.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt epsilon} -- maximum difference between iterations.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{solve}
\item{\vskip -1.9ex 
\index{solve()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.solve()}{\membername{solve}}
{\tt public jmarkov.basic.Solution\ {\bf solve}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.solve()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Solves the problem.
}
\item{{\bf Returns} -- 
returns a Solution with the optimal policy and value funtion. 
}%end item
\end{itemize}
}%end item
\divideents{useErrorBounds}
\item{\vskip -1.9ex 
\index{useErrorBounds(boolean)}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.useErrorBounds(boolean)}{\membername{useErrorBounds}}
{\tt public synchronized void\ {\bf useErrorBounds}( {\tt boolean} {\bf val} )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.useErrorBounds(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The ErrorBounds modification to the ValueIteration method is a change that is garanteed to have a performance at least as good as the methos without the modifications. In many problems, specially the ones with many states, the modification can imply a significant improvement. This method modifies the iteratios and the stopping criterion. It builds upper and lower bounds for the optimal in each iteration and stops when the bounds are only delta apart or less ignoring where the actual valueFunction is. The bounds converge faster than the actual valueFunction. By default it set to false.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt val} -- sets whether or not to use the ErrorBounds modification.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{useGaussSeidel}
\item{\vskip -1.9ex 
\index{useGaussSeidel(boolean)}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.useGaussSeidel(boolean)}{\membername{useGaussSeidel}}
{\tt public synchronized void\ {\bf useGaussSeidel}( {\tt boolean} {\bf val} )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.useGaussSeidel(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The GaussSeidel modification of the ValueIteration method is a change that is garanteed to have a performance at least as good as the methos without the modifications. In many problems, specially the ones with many states, the modification can imply a significant improvement. By default it set to true. It provides no significant improvement if used jointly with the ErrorBounds modification.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt val} -- sets whether or not the GaussSeidel modification will be used.}
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.jmdp.solvers.ValueIterationSolver.useErrorBounds(boolean)}{ValueIterationSolver.useErrorBounds(boolean)}} {\small 
\refdefined{jmarkov.jmdp.solvers.ValueIterationSolver.useErrorBounds(boolean)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{usesErrorBounds}
\item{\vskip -1.9ex 
\index{usesErrorBounds()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.usesErrorBounds()}{\membername{usesErrorBounds}}
{\tt public final boolean\ {\bf usesErrorBounds}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.usesErrorBounds()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns true if uses Error Bounds. 
}%end item
\end{itemize}
}%end item
\divideents{usesGaussSeidel}
\item{\vskip -1.9ex 
\index{usesGaussSeidel()}
\hypertarget{jmarkov.jmdp.solvers.ValueIterationSolver.usesGaussSeidel()}{\membername{usesGaussSeidel}}
{\tt public final boolean\ {\bf usesGaussSeidel}(  )
\label{jmarkov.jmdp.solvers.ValueIterationSolver.usesGaussSeidel()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns true if Gauss Seidel is active. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractDiscountedSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractDiscountedSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf discountFactor}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final double {\bf future}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt double} {\bf discountF} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final double {\bf future}( {\tt jmarkov.basic.State} {\bf i},
{\tt jmarkov.basic.Action} {\bf a},
{\tt double} {\bf discountF},
{\tt jmarkov.basic.ValueFunction} {\bf vf} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getInterestRate}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected final void {\bf setDiscountFactor}( {\tt double} {\bf discountFactor} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final void {\bf setInterestRate}( {\tt double} {\bf interestRate} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.AbstractInfiniteSolver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.AbstractInfiniteSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected DTMDP {\bf getDiscreteProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getIterations}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public InfiniteMDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.jmdp.solvers.Solver} \textnormal{\small\refdefined{jmarkov.jmdp.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Policy {\bf getOptimalPolicy}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getOptimalValueFunction}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public MDP {\bf getProblem}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract long {\bf getProcessTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final ValueFunction {\bf getValueFunction}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf isSolved}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf policy}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printProcessTime}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}(  ) throws java.lang.Exception
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf printSolution}( {\tt java.io.PrintWriter} {\bf pw} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf printValueFunction}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf problem}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintProcessTime}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setPrintValueFunction}( {\tt boolean} {\bf val} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract Solution {\bf solve}(  ) throws jmarkov.basic.exceptions.SolverException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf solved}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf valueFunction}}%end signature
}%end item
\end{itemize}
}}
}
\newpage}
}
\newpage
\def\packagename{jmarkov.solvers}
\chapter{\bf Package jmarkov.solvers}{
\thispagestyle{empty}
\label{jmarkov.solvers}\hypertarget{jmarkov.solvers}{}
\markboth{\protect\packagename}{\protect\packagename}
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Classes}
\entityintro{GeometricSolver}{jmarkov.solvers.GeometricSolver}{}
\entityintro{GeometrixSolver}{jmarkov.solvers.GeometrixSolver}{}
\entityintro{JamaSolver}{jmarkov.solvers.JamaSolver}{Solver implementation for steady state, using JAMA}
\entityintro{JamaTransientSolver}{jmarkov.solvers.JamaTransientSolver}{This class claculate the transient probabilities.}
\entityintro{MtjLogRedSolver}{jmarkov.solvers.MtjLogRedSolver}{}
\entityintro{MtjSolver}{jmarkov.solvers.MtjSolver}{This class uses MTJ to solve Steady State probabilities.}
\entityintro{MtjSolver.EnumPrecond}{jmarkov.solvers.MtjSolver.EnumPrecond}{This is the list of preconditioner offered in MTJ.}
\entityintro{MtjSolver.EnumSolver}{jmarkov.solvers.MtjSolver.EnumSolver}{This is the list of solvers provided by MTJ.}
\entityintro{Solver}{jmarkov.solvers.Solver}{This abstract class has to be extended in order to implement solvers for Steady State and Transient probabilities.}
\entityintro{SteadyStateSolver}{jmarkov.solvers.SteadyStateSolver}{An abstract clas for steady state solver.}
\entityintro{TransientSolver}{jmarkov.solvers.TransientSolver}{An abstract class for Transient solvers.}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
Provides classes for customizing a solver used by JMarkov to solve transient and steady state probabilities in different models. The bacis classes are @code SteadyStateSolver and @TransientSolver. Implementation of these classes is provided, that rely on \hyperref{http://math.nist.gov/javanumerics/jama/}{}{}{Java Matrix Package (Jama)} (at http://math.nist.gov/javanumerics/jama/) and \hyperref{https://mtj.dev.java.net/}{}{}{Matrix Toolkits for Java (MTJ)} (at https://mtj.dev.java.net/). For overviews, tutorials, examples, guides, and tool documentation, please see:

\hyperref{http://copa.uniandes.edu.co}{}{}{Copa Group WEB page.} (at http://copa.uniandes.edu.co)\mbox{}\\ \rule{\hsize}{.7mm}
\vskip .1in
\newpage
\markboth{\protect\packagename \hspace{.02in} -- \protect\classname}{\protect\packagename \hspace{.02in} -- \protect\classname}
\section{Classes}{
\gdef\classname{GeometricSolver}
\subsection{\label{jmarkov.solvers.GeometricSolver}\index{GeometricSolver}{\bf {\it Class} GeometricSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.solvers.GeometricSolver}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class GeometricSolver
\\ {\bf extends} jmarkov.solvers.Solver
\refdefined{jmarkov.solvers.Solver}}}}
\subsubsection{All known subclasses}{MtjLogRedSolver\small{\refdefined{jmarkov.solvers.MtjLogRedSolver}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.GeometricSolver(jmarkov.MarkovProcess)}{{\bf GeometricSolver(MarkovProcess)}} Builds a Geometrix Solver with the given SimpleMarkovProcess.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.GeometricSolver.getRmatrix()}{{\bf getRmatrix()}} This process should be extended in order to compute the R matrix of the QBD.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{GeometricSolver(MarkovProcess)}
\hypertarget{jmarkov.solvers.GeometricSolver(jmarkov.MarkovProcess)}{\membername{GeometricSolver}}
{\tt public\ {\bf GeometricSolver}( {\tt jmarkov.MarkovProcess} {\bf mp} )
\label{jmarkov.solvers.GeometricSolver(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Builds a Geometrix Solver with the given SimpleMarkovProcess.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mp} -- The Markov Process for which the steady state probabilities are sought.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getRmatrix()}
\hypertarget{jmarkov.solvers.GeometricSolver.getRmatrix()}{\membername{getRmatrix}}
{\tt public abstract double\lbrack \rbrack \lbrack \rbrack \ {\bf getRmatrix}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.solvers.GeometricSolver.getRmatrix()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This process should be extended in order to compute the R matrix of the QBD. The user can get information of the SimpleMarkovProcess associated with this solver though the methods {\tt\small getRates(), getGenerator, and getRate(State,State)}
}
\item{{\bf Returns} -- 
a Matrix with the R matrix for the given QBD. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getGenerator()}{jmarkov.MarkovProcess.getGenerator()}} {\small 
\refdefined{jmarkov.MarkovProcess.getGenerator()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRates()}{jmarkov.MarkovProcess.getRates()}} {\small 
\refdefined{jmarkov.MarkovProcess.getRates()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRate(S, S)}{jmarkov.MarkovProcess.getRate(State,\allowbreak State)}} {\small 
\refdefined{jmarkov.MarkovProcess.getRate(S, S)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.Solver} \textnormal{\small\refdefined{jmarkov.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public final MarkovProcess {\bf getMP}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf mp}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{GeometrixSolver}
\subsection{\label{jmarkov.solvers.GeometrixSolver}\index{GeometrixSolver}{\bf {\it Class} GeometrixSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.solvers.GeometrixSolver}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class GeometrixSolver
\\ {\bf extends} jmarkov.solvers.Solver
\refdefined{jmarkov.solvers.Solver}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.GeometrixSolver(jmarkov.MarkovProcess)}{{\bf GeometrixSolver(MarkovProcess)}} Builds a Geometrix Solver with the given SimpleMarkovProcess.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.GeometrixSolver.getRmatrix()}{{\bf getRmatrix()}} This process should be extended in order to compute the R matrix of the QBD.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{GeometrixSolver(MarkovProcess)}
\hypertarget{jmarkov.solvers.GeometrixSolver(jmarkov.MarkovProcess)}{\membername{GeometrixSolver}}
{\tt public\ {\bf GeometrixSolver}( {\tt jmarkov.MarkovProcess} {\bf mp} )
\label{jmarkov.solvers.GeometrixSolver(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Builds a Geometrix Solver with the given SimpleMarkovProcess.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mp} -- The Markov Process for which the steady state probabilities are sought.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getRmatrix()}
\hypertarget{jmarkov.solvers.GeometrixSolver.getRmatrix()}{\membername{getRmatrix}}
{\tt public abstract double\lbrack \rbrack \lbrack \rbrack \ {\bf getRmatrix}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.solvers.GeometrixSolver.getRmatrix()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This process should be extended in order to compute the R matrix of the QBD. The user can get information of the SimpleMarkovProcess associated with this solver though the methods {\tt\small getRates(), getGenerator, and getRate(State,State)}
}
\item{{\bf Returns} -- 
a Matrix with the R matrix for the given QBD. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getGenerator()}{jmarkov.MarkovProcess.getGenerator()}} {\small 
\refdefined{jmarkov.MarkovProcess.getGenerator()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRates()}{jmarkov.MarkovProcess.getRates()}} {\small 
\refdefined{jmarkov.MarkovProcess.getRates()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRate(S, S)}{jmarkov.MarkovProcess.getRate(State,\allowbreak State)}} {\small 
\refdefined{jmarkov.MarkovProcess.getRate(S, S)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.Solver} \textnormal{\small\refdefined{jmarkov.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public final MarkovProcess {\bf getMP}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf mp}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{JamaSolver}
\subsection{\label{jmarkov.solvers.JamaSolver}\index{JamaSolver}{\bf {\it Class} JamaSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.solvers.JamaSolver}{}\vskip .1in 
Solver implementation for steady state, using JAMA\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public final class JamaSolver
\\ {\bf extends} jmarkov.solvers.SteadyStateSolver
\refdefined{jmarkov.solvers.SteadyStateSolver}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.JamaSolver(jmarkov.MarkovProcess)}{{\bf JamaSolver(MarkovProcess)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.JamaSolver.description()}{{\bf description()}} \\
\hyperlink{jmarkov.solvers.JamaSolver.getSteadyState()}{{\bf getSteadyState()}} It find the steady state probabilities.\\
\hyperlink{jmarkov.solvers.JamaSolver.label()}{{\bf label()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{JamaSolver(MarkovProcess)}
\hypertarget{jmarkov.solvers.JamaSolver(jmarkov.MarkovProcess)}{\membername{JamaSolver}}
{\tt public\ {\bf JamaSolver}( {\tt jmarkov.MarkovProcess} {\bf mp} )
\label{jmarkov.solvers.JamaSolver(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mp} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.solvers.JamaSolver.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jmarkov.solvers.JamaSolver.description()}}%end signature
}%end item
\divideents{getSteadyState}
\item{\vskip -1.9ex 
\index{getSteadyState()}
\hypertarget{jmarkov.solvers.JamaSolver.getSteadyState()}{\membername{getSteadyState}}
{\tt public double\lbrack \rbrack \ {\bf getSteadyState}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.solvers.JamaSolver.getSteadyState()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

It find the steady state probabilities. If no Solution is found an array of 0's is returned
}
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.solvers.JamaSolver.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.solvers.JamaSolver.label()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.Solver.label()}{Solver.label()}} {\small 
\refdefined{jmarkov.solvers.Solver.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.SteadyStateSolver} \textnormal{\small\refdefined{jmarkov.solvers.SteadyStateSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract double {\bf getSteadyState}(  ) throws jmarkov.basic.exceptions.NotUnichainException
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.Solver} \textnormal{\small\refdefined{jmarkov.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public final MarkovProcess {\bf getMP}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf mp}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{JamaTransientSolver}
\subsection{\label{jmarkov.solvers.JamaTransientSolver}\index{JamaTransientSolver}{\bf {\it Class} JamaTransientSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.solvers.JamaTransientSolver}{}\vskip .1in 
This class claculate the transient probabilities. It uses uniformization, and basically it is a wrapper for the 'expUnif' methods in jphase.MarkovMatrix.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jphase.MarkovMatrix}{jphase.MarkovMatrix}} {\small 
\refdefined{jphase.MarkovMatrix}}%end
} 
\item{ {\tt \hyperlink{jmarkov.MarkovProcess}{jmarkov.MarkovProcess}} {\small 
\refdefined{jmarkov.MarkovProcess}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class JamaTransientSolver
\\ {\bf extends} jmarkov.solvers.TransientSolver
\refdefined{jmarkov.solvers.TransientSolver}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.JamaTransientSolver(jmarkov.MarkovProcess)}{{\bf JamaTransientSolver(MarkovProcess)}} Default constructor\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.JamaTransientSolver.description()}{{\bf description()}} \\
\hyperlink{jmarkov.solvers.JamaTransientSolver.getTransientProbs(double[], jmarkov.basic.State)}{{\bf getTransientProbs(double\lbrack \rbrack , State)}} \\
\hyperlink{jmarkov.solvers.JamaTransientSolver.getTransientProbs(double, jmarkov.basic.State)}{{\bf getTransientProbs(double, State)}} \\
\hyperlink{jmarkov.solvers.JamaTransientSolver.getTransientProbs(int, double, jmarkov.basic.State)}{{\bf getTransientProbs(int, double, State)}} \\
\hyperlink{jmarkov.solvers.JamaTransientSolver.label()}{{\bf label()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{JamaTransientSolver(MarkovProcess)}
\hypertarget{jmarkov.solvers.JamaTransientSolver(jmarkov.MarkovProcess)}{\membername{JamaTransientSolver}}
{\tt public\ {\bf JamaTransientSolver}( {\tt jmarkov.MarkovProcess} {\bf mp} )
\label{jmarkov.solvers.JamaTransientSolver(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default constructor
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mp} -- the Markov Process}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.solvers.JamaTransientSolver.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jmarkov.solvers.JamaTransientSolver.description()}}%end signature
}%end item
\divideents{getTransientProbs}
\item{\vskip -1.9ex 
\index{getTransientProbs(double\lbrack \rbrack , State)}
\hypertarget{jmarkov.solvers.JamaTransientSolver.getTransientProbs(double[], jmarkov.basic.State)}{\membername{getTransientProbs}}
{\tt public double\lbrack \rbrack \lbrack \rbrack \ {\bf getTransientProbs}( {\tt double\lbrack \rbrack } {\bf times},
{\tt jmarkov.basic.State} {\bf i0} )
\label{jmarkov.solvers.JamaTransientSolver.getTransientProbs(double[], jmarkov.basic.State)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.TransientSolver.getTransientProbs(double[], jmarkov.basic.State)}{TransientSolver.getTransientProbs(double\lbrack \rbrack ,\allowbreak State)}} {\small 
\refdefined{jmarkov.solvers.TransientSolver.getTransientProbs(double[], jmarkov.basic.State)}}%end
}
\item{ {\tt \hyperlink{jphase.MarkovMatrix.expUnif(double[], Jama.Matrix, Jama.Matrix)}{jphase.MarkovMatrix.expUnif(double\lbrack \rbrack ,\allowbreak Matrix,\allowbreak Matrix)}} {\small 
\refdefined{jphase.MarkovMatrix.expUnif(double[], Jama.Matrix, Jama.Matrix)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getTransientProbs}
\item{\vskip -1.9ex 
\index{getTransientProbs(double, State)}
\hypertarget{jmarkov.solvers.JamaTransientSolver.getTransientProbs(double, jmarkov.basic.State)}{\membername{getTransientProbs}}
{\tt public double\lbrack \rbrack \ {\bf getTransientProbs}( {\tt double} {\bf time},
{\tt jmarkov.basic.State} {\bf i0} )
\label{jmarkov.solvers.JamaTransientSolver.getTransientProbs(double, jmarkov.basic.State)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.TransientSolver.getTransientProbs(double, jmarkov.basic.State)}{TransientSolver.getTransientProbs(double,\allowbreak State)}} {\small 
\refdefined{jmarkov.solvers.TransientSolver.getTransientProbs(double, jmarkov.basic.State)}}%end
}
\item{ {\tt \hyperlink{jphase.MarkovMatrix.expUnif(double, Jama.Matrix, Jama.Matrix)}{jphase.MarkovMatrix.expUnif(double,\allowbreak Matrix,\allowbreak Matrix)}} {\small 
\refdefined{jphase.MarkovMatrix.expUnif(double, Jama.Matrix, Jama.Matrix)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getTransientProbs}
\item{\vskip -1.9ex 
\index{getTransientProbs(int, double, State)}
\hypertarget{jmarkov.solvers.JamaTransientSolver.getTransientProbs(int, double, jmarkov.basic.State)}{\membername{getTransientProbs}}
{\tt public double\lbrack \rbrack \lbrack \rbrack \ {\bf getTransientProbs}( {\tt int} {\bf NumberPoints},
{\tt double} {\bf delta},
{\tt jmarkov.basic.State} {\bf i0} )
\label{jmarkov.solvers.JamaTransientSolver.getTransientProbs(int, double, jmarkov.basic.State)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.TransientSolver.getTransientProbs(int, double, jmarkov.basic.State)}{TransientSolver.getTransientProbs(int,\allowbreak double,\allowbreak State)}} {\small 
\refdefined{jmarkov.solvers.TransientSolver.getTransientProbs(int, double, jmarkov.basic.State)}}%end
}
\item{ {\tt \hyperlink{jphase.MarkovMatrix.expUnif(int, double, Jama.Matrix, Jama.Matrix)}{jphase.MarkovMatrix.expUnif(int,\allowbreak double,\allowbreak Matrix,\allowbreak Matrix)}} {\small 
\refdefined{jphase.MarkovMatrix.expUnif(int, double, Jama.Matrix, Jama.Matrix)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.solvers.JamaTransientSolver.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.solvers.JamaTransientSolver.label()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.Solver.label()}{Solver.label()}} {\small 
\refdefined{jmarkov.solvers.Solver.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.TransientSolver} \textnormal{\small\refdefined{jmarkov.solvers.TransientSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public double {\bf getTransientProbs}( {\tt double\lbrack \rbrack } {\bf times},
{\tt jmarkov.basic.State} {\bf i0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf getTransientProbs}( {\tt double} {\bf time},
{\tt jmarkov.basic.State} {\bf i0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getTransientProbs}( {\tt int} {\bf NumberPoints},
{\tt double} {\bf delta},
{\tt jmarkov.basic.State} {\bf i0} )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.Solver} \textnormal{\small\refdefined{jmarkov.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public final MarkovProcess {\bf getMP}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf mp}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MtjLogRedSolver}
\subsection{\label{jmarkov.solvers.MtjLogRedSolver}\index{MtjLogRedSolver}{\bf {\it Class} MtjLogRedSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.solvers.MtjLogRedSolver}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class MtjLogRedSolver
\\ {\bf extends} jmarkov.solvers.GeometricSolver
\refdefined{jmarkov.solvers.GeometricSolver}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.MtjLogRedSolver(jmarkov.GeomProcess)}{{\bf MtjLogRedSolver(GeomProcess)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.MtjLogRedSolver.description()}{{\bf description()}} \\
\hyperlink{jmarkov.solvers.MtjLogRedSolver.getRmatrix()}{{\bf getRmatrix()}} \\
\hyperlink{jmarkov.solvers.MtjLogRedSolver.label()}{{\bf label()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MtjLogRedSolver(GeomProcess)}
\hypertarget{jmarkov.solvers.MtjLogRedSolver(jmarkov.GeomProcess)}{\membername{MtjLogRedSolver}}
{\tt public\ {\bf MtjLogRedSolver}( {\tt jmarkov.GeomProcess} {\bf mp} )
\label{jmarkov.solvers.MtjLogRedSolver(jmarkov.GeomProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mp} -- The given QBD}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.solvers.MtjLogRedSolver.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jmarkov.solvers.MtjLogRedSolver.description()}}%end signature
}%end item
\divideents{getRmatrix}
\item{\vskip -1.9ex 
\index{getRmatrix()}
\hypertarget{jmarkov.solvers.MtjLogRedSolver.getRmatrix()}{\membername{getRmatrix}}
{\tt public abstract double\lbrack \rbrack \lbrack \rbrack \ {\bf getRmatrix}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.solvers.MtjLogRedSolver.getRmatrix()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.solvers.GeometricSolver}{GeometricSolver}{\small \refdefined{jmarkov.solvers.GeometricSolver}} }

This process should be extended in order to compute the R matrix of the QBD. The user can get information of the SimpleMarkovProcess associated with this solver though the methods {\tt\small getRates(), getGenerator, and getRate(State,State)}
}
\item{{\bf Returns} -- 
a Matrix with the R matrix for the given QBD. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getGenerator()}{jmarkov.MarkovProcess.getGenerator()}} {\small 
\refdefined{jmarkov.MarkovProcess.getGenerator()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRates()}{jmarkov.MarkovProcess.getRates()}} {\small 
\refdefined{jmarkov.MarkovProcess.getRates()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRate(S, S)}{jmarkov.MarkovProcess.getRate(State,\allowbreak State)}} {\small 
\refdefined{jmarkov.MarkovProcess.getRate(S, S)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.solvers.MtjLogRedSolver.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.solvers.MtjLogRedSolver.label()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.Solver.label()}{Solver.label()}} {\small 
\refdefined{jmarkov.solvers.Solver.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.GeometricSolver} \textnormal{\small\refdefined{jmarkov.solvers.GeometricSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract double {\bf getRmatrix}(  ) throws jmarkov.basic.exceptions.NotUnichainException
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.Solver} \textnormal{\small\refdefined{jmarkov.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public final MarkovProcess {\bf getMP}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf mp}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MtjSolver}
\subsection{\label{jmarkov.solvers.MtjSolver}\index{MtjSolver}{\bf {\it Class} MtjSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.solvers.MtjSolver}{}\vskip .1in 
This class uses MTJ to solve Steady State probabilities.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class MtjSolver
\\ {\bf extends} jmarkov.solvers.SteadyStateSolver
\refdefined{jmarkov.solvers.SteadyStateSolver}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.MtjSolver(jmarkov.MarkovProcess)}{{\bf MtjSolver(MarkovProcess)}} Default constructor.\\
\hyperlink{jmarkov.solvers.MtjSolver(jmarkov.MarkovProcess, jmarkov.solvers.MtjSolver.EnumSolver)}{{\bf MtjSolver(MarkovProcess, MtjSolver.EnumSolver)}} Construct a solver for the given SimpleMarkovProcess.\\
\hyperlink{jmarkov.solvers.MtjSolver(jmarkov.MarkovProcess, jmarkov.solvers.MtjSolver.EnumSolver, boolean)}{{\bf MtjSolver(MarkovProcess, MtjSolver.EnumSolver, boolean)}} Construct a solver for the given SimpleMarkovProcess.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.MtjSolver.description()}{{\bf description()}} \\
\hyperlink{jmarkov.solvers.MtjSolver.getCurrentIterSolver()}{{\bf getCurrentIterSolver()}} \\
\hyperlink{jmarkov.solvers.MtjSolver.getCurrentPreConditioner()}{{\bf getCurrentPreConditioner()}} \\
\hyperlink{jmarkov.solvers.MtjSolver.getGenerator()}{{\bf getGenerator()}} Returns the Generator matrix.\\
\hyperlink{jmarkov.solvers.MtjSolver.getGenMatrix()}{{\bf getGenMatrix()}} \\
\hyperlink{jmarkov.solvers.MtjSolver.getIteartiveSolver(no.uib.cipr.matrix.Vector)}{{\bf getIteartiveSolver(Vector)}} \\
\hyperlink{jmarkov.solvers.MtjSolver.getIterativeSolver(no.uib.cipr.matrix.Vector, jmarkov.solvers.MtjSolver.EnumSolver)}{{\bf getIterativeSolver(Vector, MtjSolver.EnumSolver)}} \\
\hyperlink{jmarkov.solvers.MtjSolver.getProcessTime()}{{\bf getProcessTime()}} \\
\hyperlink{jmarkov.solvers.MtjSolver.getSteadyState()}{{\bf getSteadyState()}} \\
\hyperlink{jmarkov.solvers.MtjSolver.isTryOthers()}{{\bf isTryOthers()}} \\
\hyperlink{jmarkov.solvers.MtjSolver.label()}{{\bf label()}} \\
\hyperlink{jmarkov.solvers.MtjSolver.setCurrentIterSolver(jmarkov.solvers.MtjSolver.EnumSolver)}{{\bf setCurrentIterSolver(MtjSolver.EnumSolver)}} Sets the solver to use.\\
\hyperlink{jmarkov.solvers.MtjSolver.setCurrentPreConditioner(jmarkov.solvers.MtjSolver.EnumPrecond)}{{\bf setCurrentPreConditioner(MtjSolver.EnumPrecond)}} \\
\hyperlink{jmarkov.solvers.MtjSolver.setIterSolver(jmarkov.solvers.MtjSolver.EnumSolver, boolean)}{{\bf setIterSolver(MtjSolver.EnumSolver, boolean)}} Sets the solver to use.\\
\hyperlink{jmarkov.solvers.MtjSolver.setTryOthers(boolean)}{{\bf setTryOthers(boolean)}} Sets whether the solver shall try other solvers when it fails.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MtjSolver(MarkovProcess)}
\hypertarget{jmarkov.solvers.MtjSolver(jmarkov.MarkovProcess)}{\membername{MtjSolver}}
{\tt public\ {\bf MtjSolver}( {\tt jmarkov.MarkovProcess} {\bf mp} )
\label{jmarkov.solvers.MtjSolver(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default constructor. Uses as default solver BiCGStab first. If it fails, it tries other solvers.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mp} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MtjSolver}
\item{\vskip -1.9ex 
\index{MtjSolver(MarkovProcess, MtjSolver.EnumSolver)}
\hypertarget{jmarkov.solvers.MtjSolver(jmarkov.MarkovProcess, jmarkov.solvers.MtjSolver.EnumSolver)}{\membername{MtjSolver}}
{\tt public\ {\bf MtjSolver}( {\tt jmarkov.MarkovProcess} {\bf mp},
{\tt MtjSolver.EnumSolver} {\bf solver} )
\label{jmarkov.solvers.MtjSolver(jmarkov.MarkovProcess, jmarkov.solvers.MtjSolver.EnumSolver)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construct a solver for the given SimpleMarkovProcess. It uses the given solver enumeration to determine what solver to use.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mp} -- Tha Markov process solved}
   \item{
\sld
{\tt solver} -- The solver to use.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MtjSolver}
\item{\vskip -1.9ex 
\index{MtjSolver(MarkovProcess, MtjSolver.EnumSolver, boolean)}
\hypertarget{jmarkov.solvers.MtjSolver(jmarkov.MarkovProcess, jmarkov.solvers.MtjSolver.EnumSolver, boolean)}{\membername{MtjSolver}}
{\tt public\ {\bf MtjSolver}( {\tt jmarkov.MarkovProcess} {\bf mp},
{\tt MtjSolver.EnumSolver} {\bf solver},
{\tt boolean} {\bf tryOthers} )
\label{jmarkov.solvers.MtjSolver(jmarkov.MarkovProcess, jmarkov.solvers.MtjSolver.EnumSolver, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construct a solver for the given SimpleMarkovProcess. It uses the given solver enumeration to determine what solver to use. If it fails it tries other solvers.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mp} -- the Markov Process to solve.}
   \item{
\sld
{\tt solver} -- the iterative solver form the enumeration IterSolver.}
   \item{
\sld
{\tt tryOthers} -- whether a different solver should be tried if the first one fails.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jmarkov.solvers.MtjSolver.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jmarkov.solvers.MtjSolver.description()}}%end signature
}%end item
\divideents{getCurrentIterSolver}
\item{\vskip -1.9ex 
\index{getCurrentIterSolver()}
\hypertarget{jmarkov.solvers.MtjSolver.getCurrentIterSolver()}{\membername{getCurrentIterSolver}}
{\tt public MtjSolver.EnumSolver\ {\bf getCurrentIterSolver}(  )
\label{jmarkov.solvers.MtjSolver.getCurrentIterSolver()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the currentIterSolver. 
}%end item
\end{itemize}
}%end item
\divideents{getCurrentPreConditioner}
\item{\vskip -1.9ex 
\index{getCurrentPreConditioner()}
\hypertarget{jmarkov.solvers.MtjSolver.getCurrentPreConditioner()}{\membername{getCurrentPreConditioner}}
{\tt public MtjSolver.EnumPrecond\ {\bf getCurrentPreConditioner}(  )
\label{jmarkov.solvers.MtjSolver.getCurrentPreConditioner()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the currentPreConditioner. 
}%end item
\end{itemize}
}%end item
\divideents{getGenerator}
\item{\vskip -1.9ex 
\index{getGenerator()}
\hypertarget{jmarkov.solvers.MtjSolver.getGenerator()}{\membername{getGenerator}}
{\tt public no.uib.cipr.matrix.Matrix\ {\bf getGenerator}(  )
\label{jmarkov.solvers.MtjSolver.getGenerator()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the Generator matrix.
}
\item{{\bf Returns} -- 
the Generator Matrix {\bf G}. 
}%end item
\end{itemize}
}%end item
\divideents{getGenMatrix}
\item{\vskip -1.9ex 
\index{getGenMatrix()}
\hypertarget{jmarkov.solvers.MtjSolver.getGenMatrix()}{\membername{getGenMatrix}}
{\tt public final no.uib.cipr.matrix.Matrix\ {\bf getGenMatrix}(  )
\label{jmarkov.solvers.MtjSolver.getGenMatrix()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the generator Matrix. 
}%end item
\end{itemize}
}%end item
\divideents{getIteartiveSolver}
\item{\vskip -1.9ex 
\index{getIteartiveSolver(Vector)}
\hypertarget{jmarkov.solvers.MtjSolver.getIteartiveSolver(no.uib.cipr.matrix.Vector)}{\membername{getIteartiveSolver}}
{\tt public no.uib.cipr.matrix.sparse.IterativeSolver\ {\bf getIteartiveSolver}( {\tt no.uib.cipr.matrix.Vector} {\bf pi} )
\label{jmarkov.solvers.MtjSolver.getIteartiveSolver(no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pi} -- The probability vector.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Returns the iteartiveSolver. 
}%end item
\end{itemize}
}%end item
\divideents{getIterativeSolver}
\item{\vskip -1.9ex 
\index{getIterativeSolver(Vector, MtjSolver.EnumSolver)}
\hypertarget{jmarkov.solvers.MtjSolver.getIterativeSolver(no.uib.cipr.matrix.Vector, jmarkov.solvers.MtjSolver.EnumSolver)}{\membername{getIterativeSolver}}
{\tt public no.uib.cipr.matrix.sparse.IterativeSolver\ {\bf getIterativeSolver}( {\tt no.uib.cipr.matrix.Vector} {\bf pi0},
{\tt MtjSolver.EnumSolver} {\bf solver} )
\label{jmarkov.solvers.MtjSolver.getIterativeSolver(no.uib.cipr.matrix.Vector, jmarkov.solvers.MtjSolver.EnumSolver)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt pi0} -- Initial guess value.}
   \item{
\sld
{\tt solver} -- The solver used.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Returns the iterativeSolver. 
}%end item
\end{itemize}
}%end item
\divideents{getProcessTime}
\item{\vskip -1.9ex 
\index{getProcessTime()}
\hypertarget{jmarkov.solvers.MtjSolver.getProcessTime()}{\membername{getProcessTime}}
{\tt public final long\ {\bf getProcessTime}(  )
\label{jmarkov.solvers.MtjSolver.getProcessTime()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns the Process Time of the last solved problem. 
}%end item
\end{itemize}
}%end item
\divideents{getSteadyState}
\item{\vskip -1.9ex 
\index{getSteadyState()}
\hypertarget{jmarkov.solvers.MtjSolver.getSteadyState()}{\membername{getSteadyState}}
{\tt public abstract double\lbrack \rbrack \ {\bf getSteadyState}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.solvers.MtjSolver.getSteadyState()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jmarkov.solvers.SteadyStateSolver}{SteadyStateSolver}{\small \refdefined{jmarkov.solvers.SteadyStateSolver}} }

This process should be extended in order to compute the steady State probabilities of the MarkovChain. The user can get information of the SimpleMarkovProcess associated with this solver though the methods {\tt\small getRates(), getGenerator, and getRate(State,State)}
}
\item{{\bf Returns} -- 
an array with the Steady state probabilities for the given problem. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getGenerator()}{jmarkov.MarkovProcess.getGenerator()}} {\small 
\refdefined{jmarkov.MarkovProcess.getGenerator()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRates()}{jmarkov.MarkovProcess.getRates()}} {\small 
\refdefined{jmarkov.MarkovProcess.getRates()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRate(S, S)}{jmarkov.MarkovProcess.getRate(State,\allowbreak State)}} {\small 
\refdefined{jmarkov.MarkovProcess.getRate(S, S)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{isTryOthers}
\item{\vskip -1.9ex 
\index{isTryOthers()}
\hypertarget{jmarkov.solvers.MtjSolver.isTryOthers()}{\membername{isTryOthers}}
{\tt public final boolean\ {\bf isTryOthers}(  )
\label{jmarkov.solvers.MtjSolver.isTryOthers()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Returns true if the solver shall try other solvers when it fails. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.solvers.MtjSolver.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.solvers.MtjSolver.label()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.Solver.label()}{Solver.label()}} {\small 
\refdefined{jmarkov.solvers.Solver.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setCurrentIterSolver}
\item{\vskip -1.9ex 
\index{setCurrentIterSolver(MtjSolver.EnumSolver)}
\hypertarget{jmarkov.solvers.MtjSolver.setCurrentIterSolver(jmarkov.solvers.MtjSolver.EnumSolver)}{\membername{setCurrentIterSolver}}
{\tt public void\ {\bf setCurrentIterSolver}( {\tt MtjSolver.EnumSolver} {\bf iterSolver} )
\label{jmarkov.solvers.MtjSolver.setCurrentIterSolver(jmarkov.solvers.MtjSolver.EnumSolver)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the solver to use. It will not try other solvers if this one fails.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt iterSolver} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setCurrentPreConditioner}
\item{\vskip -1.9ex 
\index{setCurrentPreConditioner(MtjSolver.EnumPrecond)}
\hypertarget{jmarkov.solvers.MtjSolver.setCurrentPreConditioner(jmarkov.solvers.MtjSolver.EnumPrecond)}{\membername{setCurrentPreConditioner}}
{\tt public void\ {\bf setCurrentPreConditioner}( {\tt MtjSolver.EnumPrecond} {\bf preConditioner} )
\label{jmarkov.solvers.MtjSolver.setCurrentPreConditioner(jmarkov.solvers.MtjSolver.EnumPrecond)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt preConditioner} -- The currentPreConditioner to set.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setIterSolver}
\item{\vskip -1.9ex 
\index{setIterSolver(MtjSolver.EnumSolver, boolean)}
\hypertarget{jmarkov.solvers.MtjSolver.setIterSolver(jmarkov.solvers.MtjSolver.EnumSolver, boolean)}{\membername{setIterSolver}}
{\tt public void\ {\bf setIterSolver}( {\tt MtjSolver.EnumSolver} {\bf iterSolver},
{\tt boolean} {\bf tryOthers} )
\label{jmarkov.solvers.MtjSolver.setIterSolver(jmarkov.solvers.MtjSolver.EnumSolver, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the solver to use.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt iterSolver} -- The currentIterSolver to set.}
   \item{
\sld
{\tt tryOthers} -- whether other solvers should be tryed if this fails.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setTryOthers}
\item{\vskip -1.9ex 
\index{setTryOthers(boolean)}
\hypertarget{jmarkov.solvers.MtjSolver.setTryOthers(boolean)}{\membername{setTryOthers}}
{\tt public final void\ {\bf setTryOthers}( {\tt boolean} {\bf tryOthers} )
\label{jmarkov.solvers.MtjSolver.setTryOthers(boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets whether the solver shall try other solvers when it fails.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt tryOthers} -- true if the solver shall try other solvers when it fails.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.SteadyStateSolver} \textnormal{\small\refdefined{jmarkov.solvers.SteadyStateSolver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract double {\bf getSteadyState}(  ) throws jmarkov.basic.exceptions.NotUnichainException
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.Solver} \textnormal{\small\refdefined{jmarkov.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public final MarkovProcess {\bf getMP}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf mp}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MtjSolver.EnumPrecond}
\subsection{\label{jmarkov.solvers.MtjSolver.EnumPrecond}\index{MtjSolver.EnumPrecond}{\bf {\it Class} MtjSolver.EnumPrecond}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.solvers.MtjSolver.EnumPrecond}{}\vskip .1in 
This is the list of preconditioner offered in MTJ.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public static final class MtjSolver.EnumPrecond
\\ {\bf extends} java.lang.Enum
\refdefined{java.lang.Enum}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.MtjSolver.EnumPrecond.DIA}{{\bf DIA}} \\
\hyperlink{jmarkov.solvers.MtjSolver.EnumPrecond.IDEN}{{\bf IDEN}} \\
\hyperlink{jmarkov.solvers.MtjSolver.EnumPrecond.ILU}{{\bf ILU}} \\
\hyperlink{jmarkov.solvers.MtjSolver.EnumPrecond.SSOR}{{\bf SSOR}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.MtjSolver.EnumPrecond.label()}{{\bf label()}} Returns a label with the solver name.\\
\hyperlink{jmarkov.solvers.MtjSolver.EnumPrecond.valueOf(java.lang.String)}{{\bf valueOf(String)}} \\
\hyperlink{jmarkov.solvers.MtjSolver.EnumPrecond.values()}{{\bf values()}} \\
\end{verse}
}
\subsubsection{Serializable Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{name}
private java.lang.String {\bf name}}
\end{itemize}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{IDEN}
\label{jmarkov.solvers.MtjSolver.EnumPrecond.IDEN}\hypertarget{jmarkov.solvers.MtjSolver.EnumPrecond.IDEN}{public static final MtjSolver.EnumPrecond {\bf IDEN}}
}
\item{
\index{SSOR}
\label{jmarkov.solvers.MtjSolver.EnumPrecond.SSOR}\hypertarget{jmarkov.solvers.MtjSolver.EnumPrecond.SSOR}{public static final MtjSolver.EnumPrecond {\bf SSOR}}
}
\item{
\index{DIA}
\label{jmarkov.solvers.MtjSolver.EnumPrecond.DIA}\hypertarget{jmarkov.solvers.MtjSolver.EnumPrecond.DIA}{public static final MtjSolver.EnumPrecond {\bf DIA}}
}
\item{
\index{ILU}
\label{jmarkov.solvers.MtjSolver.EnumPrecond.ILU}\hypertarget{jmarkov.solvers.MtjSolver.EnumPrecond.ILU}{public static final MtjSolver.EnumPrecond {\bf ILU}}
}
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.solvers.MtjSolver.EnumPrecond.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jmarkov.solvers.MtjSolver.EnumPrecond.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a label with the solver name.
}
\item{{\bf Returns} -- 
The solver name 
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.Solver.label()}{Solver.label()}} {\small 
\refdefined{jmarkov.solvers.Solver.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\index{valueOf(String)}
\hypertarget{jmarkov.solvers.MtjSolver.EnumPrecond.valueOf(java.lang.String)}{\membername{valueOf}}
{\tt public static MtjSolver.EnumPrecond\ {\bf valueOf}( {\tt java.lang.String} {\bf name} )
\label{jmarkov.solvers.MtjSolver.EnumPrecond.valueOf(java.lang.String)}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\index{values()}
\hypertarget{jmarkov.solvers.MtjSolver.EnumPrecond.values()}{\membername{values}}
{\tt public static final MtjSolver.EnumPrecond\lbrack \rbrack \ {\bf values}(  )
\label{jmarkov.solvers.MtjSolver.EnumPrecond.values()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt java.lang.Enum} \textnormal{\small\refdefined{java.lang.Enum}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected final Object {\bf clone}(  ) throws CloneNotSupportedException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf compareTo}( {\tt Enum} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf equals}( {\tt Object} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public static Enum {\bf valueOf}( {\tt Class} {\bf arg0},
{\tt String} {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MtjSolver.EnumSolver}
\subsection{\label{jmarkov.solvers.MtjSolver.EnumSolver}\index{MtjSolver.EnumSolver}{\bf {\it Class} MtjSolver.EnumSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.solvers.MtjSolver.EnumSolver}{}\vskip .1in 
This is the list of solvers provided by MTJ.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public static final class MtjSolver.EnumSolver
\\ {\bf extends} java.lang.Enum
\refdefined{java.lang.Enum}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.MtjSolver.EnumSolver.BiCG}{{\bf BiCG}} \\
\hyperlink{jmarkov.solvers.MtjSolver.EnumSolver.BiCGstab}{{\bf BiCGstab}} \\
\hyperlink{jmarkov.solvers.MtjSolver.EnumSolver.CGS}{{\bf CGS}} \\
\hyperlink{jmarkov.solvers.MtjSolver.EnumSolver.GMRES}{{\bf GMRES}} \\
\hyperlink{jmarkov.solvers.MtjSolver.EnumSolver.QMR}{{\bf QMR}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.MtjSolver.EnumSolver.getName()}{{\bf getName()}} \\
\hyperlink{jmarkov.solvers.MtjSolver.EnumSolver.valueOf(java.lang.String)}{{\bf valueOf(String)}} \\
\hyperlink{jmarkov.solvers.MtjSolver.EnumSolver.values()}{{\bf values()}} \\
\end{verse}
}
\subsubsection{Serializable Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{name}
private java.lang.String {\bf name}}
\end{itemize}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{BiCG}
\label{jmarkov.solvers.MtjSolver.EnumSolver.BiCG}\hypertarget{jmarkov.solvers.MtjSolver.EnumSolver.BiCG}{public static final MtjSolver.EnumSolver {\bf BiCG}}
}
\item{
\index{BiCGstab}
\label{jmarkov.solvers.MtjSolver.EnumSolver.BiCGstab}\hypertarget{jmarkov.solvers.MtjSolver.EnumSolver.BiCGstab}{public static final MtjSolver.EnumSolver {\bf BiCGstab}}
}
\item{
\index{CGS}
\label{jmarkov.solvers.MtjSolver.EnumSolver.CGS}\hypertarget{jmarkov.solvers.MtjSolver.EnumSolver.CGS}{public static final MtjSolver.EnumSolver {\bf CGS}}
}
\item{
\index{GMRES}
\label{jmarkov.solvers.MtjSolver.EnumSolver.GMRES}\hypertarget{jmarkov.solvers.MtjSolver.EnumSolver.GMRES}{public static final MtjSolver.EnumSolver {\bf GMRES}}
}
\item{
\index{QMR}
\label{jmarkov.solvers.MtjSolver.EnumSolver.QMR}\hypertarget{jmarkov.solvers.MtjSolver.EnumSolver.QMR}{public static final MtjSolver.EnumSolver {\bf QMR}}
}
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getName()}
\hypertarget{jmarkov.solvers.MtjSolver.EnumSolver.getName()}{\membername{getName}}
{\tt public java.lang.String\ {\bf getName}(  )
\label{jmarkov.solvers.MtjSolver.EnumSolver.getName()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
The name. 
}%end item
\end{itemize}
}%end item
\divideents{valueOf}
\item{\vskip -1.9ex 
\index{valueOf(String)}
\hypertarget{jmarkov.solvers.MtjSolver.EnumSolver.valueOf(java.lang.String)}{\membername{valueOf}}
{\tt public static MtjSolver.EnumSolver\ {\bf valueOf}( {\tt java.lang.String} {\bf name} )
\label{jmarkov.solvers.MtjSolver.EnumSolver.valueOf(java.lang.String)}}%end signature
}%end item
\divideents{values}
\item{\vskip -1.9ex 
\index{values()}
\hypertarget{jmarkov.solvers.MtjSolver.EnumSolver.values()}{\membername{values}}
{\tt public static final MtjSolver.EnumSolver\lbrack \rbrack \ {\bf values}(  )
\label{jmarkov.solvers.MtjSolver.EnumSolver.values()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt java.lang.Enum} \textnormal{\small\refdefined{java.lang.Enum}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected final Object {\bf clone}(  ) throws CloneNotSupportedException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf compareTo}( {\tt Enum} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final boolean {\bf equals}( {\tt Object} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final Class {\bf getDeclaringClass}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf hashCode}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf name}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final int {\bf ordinal}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public static Enum {\bf valueOf}( {\tt Class} {\bf arg0},
{\tt String} {\bf arg1} )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{Solver}
\subsection{\label{jmarkov.solvers.Solver}\index{Solver}{\bf {\it Class} Solver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.solvers.Solver}{}\vskip .1in 
This abstract class has to be extended in order to implement solvers for Steady State and Transient probabilities. Most users do not need to implement this class since a default solver is provided.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.solvers.SteadyStateSolver}{SteadyStateSolver}} {\small 
\refdefined{jmarkov.solvers.SteadyStateSolver}}%end
} 
\item{ {\tt \hyperlink{jmarkov.solvers.TransientSolver}{TransientSolver}} {\small 
\refdefined{jmarkov.solvers.TransientSolver}}%end
} 
\item{ {\tt \hyperlink{jmarkov.solvers.JamaSolver}{JamaSolver}} {\small 
\refdefined{jmarkov.solvers.JamaSolver}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class Solver
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
jmarkov.basic.JMarkovElement}}}
\subsubsection{All known subclasses}{TransientSolver\small{\refdefined{jmarkov.solvers.TransientSolver}}, SteadyStateSolver\small{\refdefined{jmarkov.solvers.SteadyStateSolver}}, MtjSolver\small{\refdefined{jmarkov.solvers.MtjSolver}}, MtjLogRedSolver\small{\refdefined{jmarkov.solvers.MtjLogRedSolver}}, JamaTransientSolver\small{\refdefined{jmarkov.solvers.JamaTransientSolver}}, JamaSolver\small{\refdefined{jmarkov.solvers.JamaSolver}}, GeometrixSolver\small{\refdefined{jmarkov.solvers.GeometrixSolver}}, GeometricSolver\small{\refdefined{jmarkov.solvers.GeometricSolver}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.Solver.mp}{{\bf mp}} The Markovprocess being solved\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.Solver(jmarkov.MarkovProcess)}{{\bf Solver(MarkovProcess)}} Build a solver for the given SimpleMarkovProcess\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.Solver.getMP()}{{\bf getMP()}} Returns the Markov process currently being solved by this solver.\\
\hyperlink{jmarkov.solvers.Solver.label()}{{\bf label()}} The name of this solver.\\
\hyperlink{jmarkov.solvers.Solver.toString()}{{\bf toString()}} Return the name of the Solver.\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{mp}
\label{jmarkov.solvers.Solver.mp}\hypertarget{jmarkov.solvers.Solver.mp}{protected jmarkov.MarkovProcess {\bf mp}}
\begin{itemize}
\item{\vskip -.9ex 
The Markovprocess being solved}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{Solver(MarkovProcess)}
\hypertarget{jmarkov.solvers.Solver(jmarkov.MarkovProcess)}{\membername{Solver}}
{\tt public\ {\bf Solver}( {\tt jmarkov.MarkovProcess} {\bf mp} )
\label{jmarkov.solvers.Solver(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Build a solver for the given SimpleMarkovProcess
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mp} -- Markov Process to be solved.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getMP()}
\hypertarget{jmarkov.solvers.Solver.getMP()}{\membername{getMP}}
{\tt public final jmarkov.MarkovProcess\ {\bf getMP}(  )
\label{jmarkov.solvers.Solver.getMP()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the Markov process currently being solved by this solver.
}
\item{{\bf Returns} -- 
the current Markov Process associated with this solver. 
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jmarkov.solvers.Solver.label()}{\membername{label}}
{\tt public abstract java.lang.String\ {\bf label}(  )
\label{jmarkov.solvers.Solver.label()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

The name of this solver. This should be implemented by the extending classes..
}
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jmarkov.solvers.Solver.toString()}{\membername{toString}}
{\tt public final java.lang.String\ {\bf toString}(  )
\label{jmarkov.solvers.Solver.toString()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the name of the Solver.
}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.solvers.Solver.label()}{Solver.label()}} {\small 
\refdefined{jmarkov.solvers.Solver.label()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{SteadyStateSolver}
\subsection{\label{jmarkov.solvers.SteadyStateSolver}\index{SteadyStateSolver}{\bf {\it Class} SteadyStateSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.solvers.SteadyStateSolver}{}\vskip .1in 
An abstract clas for steady state solver. Any solver for steady state should extend this class.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class SteadyStateSolver
\\ {\bf extends} jmarkov.solvers.Solver
\refdefined{jmarkov.solvers.Solver}}}}
\subsubsection{All known subclasses}{MtjSolver\small{\refdefined{jmarkov.solvers.MtjSolver}}, JamaSolver\small{\refdefined{jmarkov.solvers.JamaSolver}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.SteadyStateSolver(jmarkov.MarkovProcess)}{{\bf SteadyStateSolver(MarkovProcess)}} Builds a Steady State Solver with the given SimpleMarkovProcess.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.SteadyStateSolver.getSteadyState()}{{\bf getSteadyState()}} This process should be extended in order to compute the steady State probabilities of the MarkovChain.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{SteadyStateSolver(MarkovProcess)}
\hypertarget{jmarkov.solvers.SteadyStateSolver(jmarkov.MarkovProcess)}{\membername{SteadyStateSolver}}
{\tt public\ {\bf SteadyStateSolver}( {\tt jmarkov.MarkovProcess} {\bf mp} )
\label{jmarkov.solvers.SteadyStateSolver(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Builds a Steady State Solver with the given SimpleMarkovProcess.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mp} -- The Markov Process for which the steady state probabilities are sought.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getSteadyState()}
\hypertarget{jmarkov.solvers.SteadyStateSolver.getSteadyState()}{\membername{getSteadyState}}
{\tt public abstract double\lbrack \rbrack \ {\bf getSteadyState}(  ) throws jmarkov.basic.exceptions.NotUnichainException
\label{jmarkov.solvers.SteadyStateSolver.getSteadyState()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This process should be extended in order to compute the steady State probabilities of the MarkovChain. The user can get information of the SimpleMarkovProcess associated with this solver though the methods {\tt\small getRates(), getGenerator, and getRate(State,State)}
}
\item{{\bf Returns} -- 
an array with the Steady state probabilities for the given problem. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt jmarkov.basic.exceptions.NotUnichainException} -- }
  \end{itemize}
}%end item
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getGenerator()}{jmarkov.MarkovProcess.getGenerator()}} {\small 
\refdefined{jmarkov.MarkovProcess.getGenerator()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRates()}{jmarkov.MarkovProcess.getRates()}} {\small 
\refdefined{jmarkov.MarkovProcess.getRates()}}%end
}
\item{ {\tt \hyperlink{jmarkov.MarkovProcess.getRate(S, S)}{jmarkov.MarkovProcess.getRate(State,\allowbreak State)}} {\small 
\refdefined{jmarkov.MarkovProcess.getRate(S, S)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.Solver} \textnormal{\small\refdefined{jmarkov.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public final MarkovProcess {\bf getMP}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf mp}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{TransientSolver}
\subsection{\label{jmarkov.solvers.TransientSolver}\index{TransientSolver}{\bf {\it Class} TransientSolver}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jmarkov.solvers.TransientSolver}{}\vskip .1in 
An abstract class for Transient solvers. At least the method getTransientProbs(double time, State i0) has to be implemented. All others call this method, but the user can provide more efficient implementations.\vskip .1in 
\subsubsection{See also}{}

  \begin{list}{-- }{\setlength{\itemsep}{0cm}\setlength{\parsep}{0cm}}
\item{ {\tt \hyperlink{jmarkov.solvers.TransientSolver.getTransientProbs(double, jmarkov.basic.State)}{TransientSolver.getTransientProbs(double,\allowbreak State)}} {\small 
\refdefined{jmarkov.solvers.TransientSolver.getTransientProbs(double, jmarkov.basic.State)}}%end
} 
  \end{list}
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class TransientSolver
\\ {\bf extends} jmarkov.solvers.Solver
\refdefined{jmarkov.solvers.Solver}}}}
\subsubsection{All known subclasses}{JamaTransientSolver\small{\refdefined{jmarkov.solvers.JamaTransientSolver}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.TransientSolver(jmarkov.MarkovProcess)}{{\bf TransientSolver(MarkovProcess)}} Build a solver with the asssocieted Markov Process.\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jmarkov.solvers.TransientSolver.getTransientProbs(double[], jmarkov.basic.State)}{{\bf getTransientProbs(double\lbrack \rbrack , State)}} Computes the steady state probabilities at this given times, assuming the Markov Chain starts in the given state i0.\\
\hyperlink{jmarkov.solvers.TransientSolver.getTransientProbs(double, jmarkov.basic.State)}{{\bf getTransientProbs(double, State)}} Computes the steady state probabilities at this given time, assuming the Markov Chain starts in the given state i0.\\
\hyperlink{jmarkov.solvers.TransientSolver.getTransientProbs(int, double, jmarkov.basic.State)}{{\bf getTransientProbs(int, double, State)}} Computes the steady state probabilities at times delta, 2delta, 3delta,..., assuming the Markov Chain starts in the given state i0.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{TransientSolver(MarkovProcess)}
\hypertarget{jmarkov.solvers.TransientSolver(jmarkov.MarkovProcess)}{\membername{TransientSolver}}
{\tt public\ {\bf TransientSolver}( {\tt jmarkov.MarkovProcess} {\bf mp} )
\label{jmarkov.solvers.TransientSolver(jmarkov.MarkovProcess)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Build a solver with the asssocieted Markov Process.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt mp} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getTransientProbs(double\lbrack \rbrack , State)}
\hypertarget{jmarkov.solvers.TransientSolver.getTransientProbs(double[], jmarkov.basic.State)}{\membername{getTransientProbs}}
{\tt public double\lbrack \rbrack \lbrack \rbrack \ {\bf getTransientProbs}( {\tt double\lbrack \rbrack } {\bf times},
{\tt jmarkov.basic.State} {\bf i0} )
\label{jmarkov.solvers.TransientSolver.getTransientProbs(double[], jmarkov.basic.State)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the steady state probabilities at this given times, assuming the Markov Chain starts in the given state i0.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt times} -- An array with the times at which the probabilities are to be evaluated.}
   \item{
\sld
{\tt i0} -- The initial state (at time t=0).}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
probabilities array for each state. The (i,j) entry on the returned state represents the steady state probability for state i at time times\lbrack j\rbrack . 
}%end item
\end{itemize}
}%end item
\divideents{getTransientProbs}
\item{\vskip -1.9ex 
\index{getTransientProbs(double, State)}
\hypertarget{jmarkov.solvers.TransientSolver.getTransientProbs(double, jmarkov.basic.State)}{\membername{getTransientProbs}}
{\tt public abstract double\lbrack \rbrack \ {\bf getTransientProbs}( {\tt double} {\bf time},
{\tt jmarkov.basic.State} {\bf i0} )
\label{jmarkov.solvers.TransientSolver.getTransientProbs(double, jmarkov.basic.State)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the steady state probabilities at this given time, assuming the Markov Chain starts in the given state i0.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt time} -- }
   \item{
\sld
{\tt i0} -- Initial State.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
probabilities array 
}%end item
\end{itemize}
}%end item
\divideents{getTransientProbs}
\item{\vskip -1.9ex 
\index{getTransientProbs(int, double, State)}
\hypertarget{jmarkov.solvers.TransientSolver.getTransientProbs(int, double, jmarkov.basic.State)}{\membername{getTransientProbs}}
{\tt public double\lbrack \rbrack \lbrack \rbrack \ {\bf getTransientProbs}( {\tt int} {\bf NumberPoints},
{\tt double} {\bf delta},
{\tt jmarkov.basic.State} {\bf i0} )
\label{jmarkov.solvers.TransientSolver.getTransientProbs(int, double, jmarkov.basic.State)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the steady state probabilities at times delta, 2delta, 3delta,..., assuming the Markov Chain starts in the given state i0.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt NumberPoints} -- }
   \item{
\sld
{\tt delta} -- the time gap between measurements.}
   \item{
\sld
{\tt i0} -- Initial state.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
probabilities array for each state. The (i,j) entry on the returned state represents the steady state probability for state i at time j * delta. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jmarkov.solvers.Solver} \textnormal{\small\refdefined{jmarkov.solvers.Solver}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public final MarkovProcess {\bf getMP}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf mp}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage}
}
\newpage
\def\packagename{jphase}
\chapter{\bf Package jphase}{
\thispagestyle{empty}
\label{jphase}\hypertarget{jphase}{}
\markboth{\protect\packagename}{\protect\packagename}
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Interfaces}
\entityintro{ContPhaseVar}{jphase.ContPhaseVar}{}
\entityintro{DiscPhaseVar}{jphase.DiscPhaseVar}{}
\entityintro{PhaseVar}{jphase.PhaseVar}{This interface defines the behaviour that any Phase-Type distribution should have}
\vskip .13in
\hbox{\bf Classes}
\entityintro{AbstractContPhaseVar}{jphase.AbstractContPhaseVar}{}
\entityintro{AbstractDiscPhaseVar}{jphase.AbstractDiscPhaseVar}{}
\entityintro{DenseContPhaseVar}{jphase.DenseContPhaseVar}{This class allows the creation and manipulation of Continuous Phase-type distributions represented by dense matrices.}
\entityintro{DenseDiscPhaseVar}{jphase.DenseDiscPhaseVar}{This class allows the creation and manipulation of Discrete Phase-type distributions represented by dense matrices.}
\entityintro{ErlangCoxianVar}{jphase.ErlangCoxianVar}{Phase-Type representation of an ErlangCoxian distribution as defined by Osogami and Harchol in "Closed form solutions for mapping general distributions to quasi-minimal PH distributions", 2005.}
\entityintro{HyperErlangVar}{jphase.HyperErlangVar}{}
\entityintro{MarkovMatrix}{jphase.MarkovMatrix}{}
\entityintro{MatrixUtils}{jphase.MatrixUtils}{}
\entityintro{PhaseVarSet}{jphase.PhaseVarSet}{}
\entityintro{Poly}{jphase.Poly}{This class represents a polynomial.}
\entityintro{SparseContPhaseVar}{jphase.SparseContPhaseVar}{}
\entityintro{SparseDiscPhaseVar}{jphase.SparseDiscPhaseVar}{}
\entityintro{SuperErlang}{jphase.SuperErlang}{}
\entityintro{Term}{jphase.Term}{This class describes a basic term in a super-Erlang function It has the form: alpha lambda$\wedge$n * t$\wedge$(n-1) * exp($\wedge$-m*lambda) / (n-1)! Or alpha * R(n,lambda) where R(n,lambda) is an Erlang pdf.}
\entityintro{Utils}{jphase.Utils}{}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
This package provides capabilities for modeling Phase type distributions. Phase type distributions are a very general family of destribution, which can be shown to be dense. That means that any distribution for a positive random variable can be approximated with a Phase type distribution. Phase type distributions are also useful because of numerous closeure properties. For overviews, tutorials, examples, guides, and tool documentation, please see:

\hyperref{http://copa.uniandes.edu.co}{}{}{Copa Group WEB page.} (at http://copa.uniandes.edu.co)\mbox{}\\ \rule{\hsize}{.7mm}
\vskip .1in
\newpage
\markboth{\protect\packagename \hspace{.02in} -- \protect\classname}{\protect\packagename \hspace{.02in} -- \protect\classname}
\section{Interfaces}{
\gdef\classname{ContPhaseVar}
\subsection{\label{jphase.ContPhaseVar}\index{ContPhaseVar@{\it ContPhaseVar}}{\bf {\it Interface} ContPhaseVar}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.ContPhaseVar}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface ContPhaseVar
\\ {\bf implements} 
PhaseVar}}}
\subsubsection{All known subclasses}{SparseContPhaseVar\small{\refdefined{jphase.SparseContPhaseVar}}, HyperErlangVar\small{\refdefined{jphase.HyperErlangVar}}, ErlangCoxianVar\small{\refdefined{jphase.ErlangCoxianVar}}, DenseContPhaseVar\small{\refdefined{jphase.DenseContPhaseVar}}, AbstractContPhaseVar\small{\refdefined{jphase.AbstractContPhaseVar}}}
\subsubsection{All classes known to implement interface}{AbstractContPhaseVar\small{\refdefined{jphase.AbstractContPhaseVar}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.ContPhaseVar.copy()}{{\bf copy()}} Creates a deep copy of the original Phase-Type Variable\\
\hyperlink{jphase.ContPhaseVar.eqResidualTime()}{{\bf eqResidualTime()}} Computes the Equilibrium Residual Distribution\\
\hyperlink{jphase.ContPhaseVar.max(jphase.ContPhaseVar)}{{\bf max(ContPhaseVar)}} Returns the maximum between the variable B and the original: res = max(A,B)\\
\hyperlink{jphase.ContPhaseVar.max(jphase.ContPhaseVar, jphase.ContPhaseVar)}{{\bf max(ContPhaseVar, ContPhaseVar)}} Returns the maximum between the variable B and the original: res = max(A,B)\\
\hyperlink{jphase.ContPhaseVar.min(jphase.ContPhaseVar)}{{\bf min(ContPhaseVar)}} Returns the minimum between the variable B and the original: res = min(A,B)\\
\hyperlink{jphase.ContPhaseVar.min(jphase.ContPhaseVar, jphase.ContPhaseVar)}{{\bf min(ContPhaseVar, ContPhaseVar)}} Returns the minimum between the variable B and the original: res = min(A,B)\\
\hyperlink{jphase.ContPhaseVar.mix(double, jphase.ContPhaseVar)}{{\bf mix(double, ContPhaseVar)}} Computes the distribution of the mix: res = A*p + B*(1-p)\\
\hyperlink{jphase.ContPhaseVar.mix(double, jphase.ContPhaseVar, jphase.ContPhaseVar)}{{\bf mix(double, ContPhaseVar, ContPhaseVar)}} Computes the distribution of the mix: res = A*p + B*(1-p)\\
\hyperlink{jphase.ContPhaseVar.newVar(int)}{{\bf newVar(int)}} Creates a new variable of the same class of the original Continuous Phase-Type Variable\\
\hyperlink{jphase.ContPhaseVar.pdf(double)}{{\bf pdf(double)}} Evaluates the probability density function at x\\
\hyperlink{jphase.ContPhaseVar.pdf(int, double)}{{\bf pdf(int, double)}} Evaluates the Probability Density Function at n values of x, starting with x=0, step delta\\
\hyperlink{jphase.ContPhaseVar.residualTime(double)}{{\bf residualTime(double)}} Computes the Residual Time Distribution\\
\hyperlink{jphase.ContPhaseVar.residualVar(double)}{{\bf residualVar(double)}} Computes the variable (X-a)+, i.e.\\
\hyperlink{jphase.ContPhaseVar.sum(jphase.ContPhaseVar)}{{\bf sum(ContPhaseVar)}} Computes the sum of variables: res = A +B\\
\hyperlink{jphase.ContPhaseVar.sum(jphase.ContPhaseVar, jphase.ContPhaseVar)}{{\bf sum(ContPhaseVar, ContPhaseVar)}} Computes the sum of variables: res = A +B\\
\hyperlink{jphase.ContPhaseVar.sumGeom(double)}{{\bf sumGeom(double)}} Returns the sum of a geometric number of independent copies of this variable\\
\hyperlink{jphase.ContPhaseVar.sumPH(jphase.DiscPhaseVar)}{{\bf sumPH(DiscPhaseVar)}} Returns the sum of a Phase number of Continuous Phase-type distributions\\
\hyperlink{jphase.ContPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.ContPhaseVar)}{{\bf sumPH(DiscPhaseVar, ContPhaseVar)}} Returns the sum of a Phase number of Continuous Phase-type distributions\\
\hyperlink{jphase.ContPhaseVar.times(double)}{{\bf times(double)}} Returns a Phase continuous variable that is the original one times c\\
\hyperlink{jphase.ContPhaseVar.toString()}{{\bf toString()}} \\
\hyperlink{jphase.ContPhaseVar.waitingQ(double)}{{\bf waitingQ(double)}} Computes the distribution of the waiting time in queue\\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{copy()}
\hypertarget{jphase.ContPhaseVar.copy()}{\membername{copy}}
{\tt  ContPhaseVar\ {\bf copy}(  )
\label{jphase.ContPhaseVar.copy()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a deep copy of the original Phase-Type Variable
}
\item{{\bf Returns} -- 
A deep copy of the original Phase-Type Variable 
}%end item
\end{itemize}
}%end item
\divideents{eqResidualTime}
\item{\vskip -1.9ex 
\index{eqResidualTime()}
\hypertarget{jphase.ContPhaseVar.eqResidualTime()}{\membername{eqResidualTime}}
{\tt  ContPhaseVar\ {\bf eqResidualTime}(  )
\label{jphase.ContPhaseVar.eqResidualTime()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the Equilibrium Residual Distribution
}
\item{{\bf Returns} -- 
Fo(x) = integ(0,t,(1 - F(t))) / E(X) 
}%end item
\end{itemize}
}%end item
\divideents{max}
\item{\vskip -1.9ex 
\index{max(ContPhaseVar)}
\hypertarget{jphase.ContPhaseVar.max(jphase.ContPhaseVar)}{\membername{max}}
{\tt  ContPhaseVar\ {\bf max}( {\tt ContPhaseVar} {\bf B} )
\label{jphase.ContPhaseVar.max(jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the maximum between the variable B and the original: res = max(A,B)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to compare with the original}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
res = max(A,B) 
}%end item
\end{itemize}
}%end item
\divideents{max}
\item{\vskip -1.9ex 
\index{max(ContPhaseVar, ContPhaseVar)}
\hypertarget{jphase.ContPhaseVar.max(jphase.ContPhaseVar, jphase.ContPhaseVar)}{\membername{max}}
{\tt  ContPhaseVar\ {\bf max}( {\tt ContPhaseVar} {\bf B},
{\tt ContPhaseVar} {\bf res} )
\label{jphase.ContPhaseVar.max(jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the maximum between the variable B and the original: res = max(A,B)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to compare with the original}
   \item{
\sld
{\tt res} -- Variable to store the resulting distribution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
res = max(A,B) 
}%end item
\end{itemize}
}%end item
\divideents{min}
\item{\vskip -1.9ex 
\index{min(ContPhaseVar)}
\hypertarget{jphase.ContPhaseVar.min(jphase.ContPhaseVar)}{\membername{min}}
{\tt  ContPhaseVar\ {\bf min}( {\tt ContPhaseVar} {\bf B} )
\label{jphase.ContPhaseVar.min(jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the minimum between the variable B and the original: res = min(A,B)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to compare with the original}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
res = min(A,B) 
}%end item
\end{itemize}
}%end item
\divideents{min}
\item{\vskip -1.9ex 
\index{min(ContPhaseVar, ContPhaseVar)}
\hypertarget{jphase.ContPhaseVar.min(jphase.ContPhaseVar, jphase.ContPhaseVar)}{\membername{min}}
{\tt  ContPhaseVar\ {\bf min}( {\tt ContPhaseVar} {\bf B},
{\tt ContPhaseVar} {\bf res} )
\label{jphase.ContPhaseVar.min(jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the minimum between the variable B and the original: res = min(A,B)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to compare with the original}
   \item{
\sld
{\tt res} -- Variable to store the resulting distribution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
res = min(A,B) 
}%end item
\end{itemize}
}%end item
\divideents{mix}
\item{\vskip -1.9ex 
\index{mix(double, ContPhaseVar)}
\hypertarget{jphase.ContPhaseVar.mix(double, jphase.ContPhaseVar)}{\membername{mix}}
{\tt  ContPhaseVar\ {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf B} )
\label{jphase.ContPhaseVar.mix(double, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the distribution of the mix: res = A*p + B*(1-p)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to mix with the original}
   \item{
\sld
{\tt p} -- Portion of this variable in the mix (0=p=1)}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Distribution of the mix: res = A*p + B*(1-p) 
}%end item
\end{itemize}
}%end item
\divideents{mix}
\item{\vskip -1.9ex 
\index{mix(double, ContPhaseVar, ContPhaseVar)}
\hypertarget{jphase.ContPhaseVar.mix(double, jphase.ContPhaseVar, jphase.ContPhaseVar)}{\membername{mix}}
{\tt  ContPhaseVar\ {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf B},
{\tt ContPhaseVar} {\bf res} )
\label{jphase.ContPhaseVar.mix(double, jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the distribution of the mix: res = A*p + B*(1-p)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to mix with the original}
   \item{
\sld
{\tt p} -- Portion of this variable in the mix (0=p=1)}
   \item{
\sld
{\tt res} -- Variable to store the resulting distribution with the same number of phases of the original distribution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Distribution of the mix: res = A*p + B*(1-p) 
}%end item
\end{itemize}
}%end item
\divideents{newVar}
\item{\vskip -1.9ex 
\index{newVar(int)}
\hypertarget{jphase.ContPhaseVar.newVar(int)}{\membername{newVar}}
{\tt  ContPhaseVar\ {\bf newVar}( {\tt int} {\bf n} )
\label{jphase.ContPhaseVar.newVar(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new variable of the same class of the original Continuous Phase-Type Variable
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- number of Phases of the new Variable}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
A new variable of the same class of the original Continuous Phase-Type Variable 
}%end item
\end{itemize}
}%end item
\divideents{pdf}
\item{\vskip -1.9ex 
\index{pdf(double)}
\hypertarget{jphase.ContPhaseVar.pdf(double)}{\membername{pdf}}
{\tt  double\ {\bf pdf}( {\tt double} {\bf x} )
\label{jphase.ContPhaseVar.pdf(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates the probability density function at x
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- Evaluation point}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Probability density function at x 
}%end item
\end{itemize}
}%end item
\divideents{pdf}
\item{\vskip -1.9ex 
\index{pdf(int, double)}
\hypertarget{jphase.ContPhaseVar.pdf(int, double)}{\membername{pdf}}
{\tt  double\lbrack \rbrack \ {\bf pdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
\label{jphase.ContPhaseVar.pdf(int, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates the Probability Density Function at n values of x, starting with x=0, step delta
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- number of evaluation points}
   \item{
\sld
{\tt delta} -- distance between evaluation points}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Evaluation of the probability density function at x = 0,d,2d,..,(n-1)d 
}%end item
\end{itemize}
}%end item
\divideents{residualTime}
\item{\vskip -1.9ex 
\index{residualTime(double)}
\hypertarget{jphase.ContPhaseVar.residualTime(double)}{\membername{residualTime}}
{\tt  ContPhaseVar\ {\bf residualTime}( {\tt double} {\bf x} )
\label{jphase.ContPhaseVar.residualTime(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the Residual Time Distribution
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- evaluation point}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Distribution of P(X - tau = x | X \textgreater  tau 
}%end item
\end{itemize}
}%end item
\divideents{residualVar}
\item{\vskip -1.9ex 
\index{residualVar(double)}
\hypertarget{jphase.ContPhaseVar.residualVar(double)}{\membername{residualVar}}
{\tt  ContPhaseVar\ {\bf residualVar}( {\tt double} {\bf a} )
\label{jphase.ContPhaseVar.residualVar(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the variable (X-a)+, i.e. the distribution takes the value of the original distribution if it is greater or equal to a. Otherwise, it is equal to null.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt a} -- Parameter for determining loss variable}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Phase Variable that describes (X-a)+ 
}%end item
\end{itemize}
}%end item
\divideents{sum}
\item{\vskip -1.9ex 
\index{sum(ContPhaseVar)}
\hypertarget{jphase.ContPhaseVar.sum(jphase.ContPhaseVar)}{\membername{sum}}
{\tt  ContPhaseVar\ {\bf sum}( {\tt ContPhaseVar} {\bf B} )
\label{jphase.ContPhaseVar.sum(jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the sum of variables: res = A +B
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to sum to the original}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of Variables: res = A +B 
}%end item
\end{itemize}
}%end item
\divideents{sum}
\item{\vskip -1.9ex 
\index{sum(ContPhaseVar, ContPhaseVar)}
\hypertarget{jphase.ContPhaseVar.sum(jphase.ContPhaseVar, jphase.ContPhaseVar)}{\membername{sum}}
{\tt  ContPhaseVar\ {\bf sum}( {\tt ContPhaseVar} {\bf B},
{\tt ContPhaseVar} {\bf res} )
\label{jphase.ContPhaseVar.sum(jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the sum of variables: res = A +B
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to sum to the original}
   \item{
\sld
{\tt res} -- Variable to store the result}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of Variables: res = A +B 
}%end item
\end{itemize}
}%end item
\divideents{sumGeom}
\item{\vskip -1.9ex 
\index{sumGeom(double)}
\hypertarget{jphase.ContPhaseVar.sumGeom(double)}{\membername{sumGeom}}
{\tt  ContPhaseVar\ {\bf sumGeom}( {\tt double} {\bf p} )
\label{jphase.ContPhaseVar.sumGeom(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the sum of a geometric number of independent copies of this variable
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt p} -- Parameter of the geometric variable}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of a geometric number of independent copies of this variable 
}%end item
\end{itemize}
}%end item
\divideents{sumPH}
\item{\vskip -1.9ex 
\index{sumPH(DiscPhaseVar)}
\hypertarget{jphase.ContPhaseVar.sumPH(jphase.DiscPhaseVar)}{\membername{sumPH}}
{\tt  ContPhaseVar\ {\bf sumPH}( {\tt DiscPhaseVar} {\bf B} )
\label{jphase.ContPhaseVar.sumPH(jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the sum of a Phase number of Continuous Phase-type distributions
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Discrete-Phase Type Distribution that determines the number of Continuous Phase-Type Distributions to sum}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of a Phase number of Continuous Phase-type distributions 
}%end item
\end{itemize}
}%end item
\divideents{sumPH}
\item{\vskip -1.9ex 
\index{sumPH(DiscPhaseVar, ContPhaseVar)}
\hypertarget{jphase.ContPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.ContPhaseVar)}{\membername{sumPH}}
{\tt  ContPhaseVar\ {\bf sumPH}( {\tt DiscPhaseVar} {\bf B},
{\tt ContPhaseVar} {\bf res} )
\label{jphase.ContPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the sum of a Phase number of Continuous Phase-type distributions
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Discrete-Phase Type Distribution that determines the number of Continuous Phase-Type Distributions to sum}
   \item{
\sld
{\tt res} -- Continuous Phase Variable to store the resulting distribution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of a Phase number of Continuous Phase-type distributions 
}%end item
\end{itemize}
}%end item
\divideents{times}
\item{\vskip -1.9ex 
\index{times(double)}
\hypertarget{jphase.ContPhaseVar.times(double)}{\membername{times}}
{\tt  ContPhaseVar\ {\bf times}( {\tt double} {\bf c} )
\label{jphase.ContPhaseVar.times(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a Phase continuous variable that is the original one times c
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt c} -- Scale factor to be applied to the original Phase continuous distribution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Phase continuous variable that is the original one times c 
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jphase.ContPhaseVar.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jphase.ContPhaseVar.toString()}}%end signature
}%end item
\divideents{waitingQ}
\item{\vskip -1.9ex 
\index{waitingQ(double)}
\hypertarget{jphase.ContPhaseVar.waitingQ(double)}{\membername{waitingQ}}
{\tt  ContPhaseVar\ {\bf waitingQ}( {\tt double} {\bf rho} )
\label{jphase.ContPhaseVar.waitingQ(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the distribution of the waiting time in queue
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt rho} -- Server utilization}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Phase Variable that describes the waiting time in Queue 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{DiscPhaseVar}
\subsection{\label{jphase.DiscPhaseVar}\index{DiscPhaseVar@{\it DiscPhaseVar}}{\bf {\it Interface} DiscPhaseVar}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.DiscPhaseVar}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface DiscPhaseVar
\\ {\bf implements} 
PhaseVar}}}
\subsubsection{All known subclasses}{SparseDiscPhaseVar\small{\refdefined{jphase.SparseDiscPhaseVar}}, DenseDiscPhaseVar\small{\refdefined{jphase.DenseDiscPhaseVar}}, AbstractDiscPhaseVar\small{\refdefined{jphase.AbstractDiscPhaseVar}}}
\subsubsection{All classes known to implement interface}{DenseDiscPhaseVar\small{\refdefined{jphase.DenseDiscPhaseVar}}, AbstractDiscPhaseVar\small{\refdefined{jphase.AbstractDiscPhaseVar}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.DiscPhaseVar.copy()}{{\bf copy()}} Creates a deep copy of the original Phase-Type Variable\\
\hyperlink{jphase.DiscPhaseVar.max(jphase.DiscPhaseVar)}{{\bf max(DiscPhaseVar)}} Returns the maximum between the variable B and the original: res = max(A,B)\\
\hyperlink{jphase.DiscPhaseVar.max(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{{\bf max(DiscPhaseVar, DiscPhaseVar)}} Returns the maximum between the variable B and the original: res = max(A,B)\\
\hyperlink{jphase.DiscPhaseVar.min(jphase.DiscPhaseVar)}{{\bf min(DiscPhaseVar)}} Returns the minimum between the variable B and the original: res = min(A,B)\\
\hyperlink{jphase.DiscPhaseVar.min(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{{\bf min(DiscPhaseVar, DiscPhaseVar)}} Returns the minimum between the variable B and the original: res = min(A,B)\\
\hyperlink{jphase.DiscPhaseVar.mix(double, jphase.DiscPhaseVar)}{{\bf mix(double, DiscPhaseVar)}} Computes the distribution of the mix: res = A*p + B*(1-p)\\
\hyperlink{jphase.DiscPhaseVar.mix(double, jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{{\bf mix(double, DiscPhaseVar, DiscPhaseVar)}} Computes the distribution of the mix: res = A*p + B*(1-p)\\
\hyperlink{jphase.DiscPhaseVar.newVar(int)}{{\bf newVar(int)}} Creates a new variable of the same class of the original Discrete Phase-Type Variable\\
\hyperlink{jphase.DiscPhaseVar.pmf(int)}{{\bf pmf(int)}} Evaluates the probability mass function at k\\
\hyperlink{jphase.DiscPhaseVar.pmf(int, int)}{{\bf pmf(int, int)}} Evaluates the probability Mass Function at n values of x, from zero to n times delta\\
\hyperlink{jphase.DiscPhaseVar.sum(jphase.DiscPhaseVar)}{{\bf sum(DiscPhaseVar)}} Computes the sum of variables: res = A +B\\
\hyperlink{jphase.DiscPhaseVar.sum(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{{\bf sum(DiscPhaseVar, DiscPhaseVar)}} Computes the sum of variables: res = A +B\\
\hyperlink{jphase.DiscPhaseVar.sumGeom(double)}{{\bf sumGeom(double)}} Returns the sum of a geometric number of independent copies of this variable\\
\hyperlink{jphase.DiscPhaseVar.sumPH(jphase.DiscPhaseVar)}{{\bf sumPH(DiscPhaseVar)}} Returns the sum of a Phase number of Discrete Phase-type distributions\\
\hyperlink{jphase.DiscPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{{\bf sumPH(DiscPhaseVar, DiscPhaseVar)}} Returns the sum of a Phase number of Discrete Phase-type distributions\\
\hyperlink{jphase.DiscPhaseVar.toString()}{{\bf toString()}} \\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{copy()}
\hypertarget{jphase.DiscPhaseVar.copy()}{\membername{copy}}
{\tt  DiscPhaseVar\ {\bf copy}(  )
\label{jphase.DiscPhaseVar.copy()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a deep copy of the original Phase-Type Variable
}
\item{{\bf Returns} -- 
A deep copy of the original Phase-Type Variable 
}%end item
\end{itemize}
}%end item
\divideents{max}
\item{\vskip -1.9ex 
\index{max(DiscPhaseVar)}
\hypertarget{jphase.DiscPhaseVar.max(jphase.DiscPhaseVar)}{\membername{max}}
{\tt  DiscPhaseVar\ {\bf max}( {\tt DiscPhaseVar} {\bf B} )
\label{jphase.DiscPhaseVar.max(jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the maximum between the variable B and the original: res = max(A,B)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to compare with the original}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
res = max(A,B) 
}%end item
\end{itemize}
}%end item
\divideents{max}
\item{\vskip -1.9ex 
\index{max(DiscPhaseVar, DiscPhaseVar)}
\hypertarget{jphase.DiscPhaseVar.max(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{\membername{max}}
{\tt  DiscPhaseVar\ {\bf max}( {\tt DiscPhaseVar} {\bf B},
{\tt DiscPhaseVar} {\bf res} )
\label{jphase.DiscPhaseVar.max(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the maximum between the variable B and the original: res = max(A,B)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to compare with the original}
   \item{
\sld
{\tt res} -- Variable to store the resulting distribution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
res = max(A,B) 
}%end item
\end{itemize}
}%end item
\divideents{min}
\item{\vskip -1.9ex 
\index{min(DiscPhaseVar)}
\hypertarget{jphase.DiscPhaseVar.min(jphase.DiscPhaseVar)}{\membername{min}}
{\tt  DiscPhaseVar\ {\bf min}( {\tt DiscPhaseVar} {\bf B} )
\label{jphase.DiscPhaseVar.min(jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the minimum between the variable B and the original: res = min(A,B)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to compare with the original}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
res = min(A,B) 
}%end item
\end{itemize}
}%end item
\divideents{min}
\item{\vskip -1.9ex 
\index{min(DiscPhaseVar, DiscPhaseVar)}
\hypertarget{jphase.DiscPhaseVar.min(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{\membername{min}}
{\tt  DiscPhaseVar\ {\bf min}( {\tt DiscPhaseVar} {\bf B},
{\tt DiscPhaseVar} {\bf res} )
\label{jphase.DiscPhaseVar.min(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the minimum between the variable B and the original: res = min(A,B)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to compare with the original}
   \item{
\sld
{\tt res} -- Variable to store the resulting distribution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
res = min(A,B) 
}%end item
\end{itemize}
}%end item
\divideents{mix}
\item{\vskip -1.9ex 
\index{mix(double, DiscPhaseVar)}
\hypertarget{jphase.DiscPhaseVar.mix(double, jphase.DiscPhaseVar)}{\membername{mix}}
{\tt  DiscPhaseVar\ {\bf mix}( {\tt double} {\bf p},
{\tt DiscPhaseVar} {\bf B} )
\label{jphase.DiscPhaseVar.mix(double, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the distribution of the mix: res = A*p + B*(1-p)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to mix with the original}
   \item{
\sld
{\tt p} -- Portion of this variable in the mix (0=p=1) with the same number of phases of the original distribution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Distribution of the mix: res = A*p + B*(1-p) 
}%end item
\end{itemize}
}%end item
\divideents{mix}
\item{\vskip -1.9ex 
\index{mix(double, DiscPhaseVar, DiscPhaseVar)}
\hypertarget{jphase.DiscPhaseVar.mix(double, jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{\membername{mix}}
{\tt  DiscPhaseVar\ {\bf mix}( {\tt double} {\bf p},
{\tt DiscPhaseVar} {\bf B},
{\tt DiscPhaseVar} {\bf res} )
\label{jphase.DiscPhaseVar.mix(double, jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the distribution of the mix: res = A*p + B*(1-p)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to mix with the original}
   \item{
\sld
{\tt p} -- Portion of this variable in the mix (0=p=1)}
   \item{
\sld
{\tt res} -- Variable to store the resulting distribution with the same number of phases of the original distribution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Distribution of the mix: res = A*p + B*(1-p) 
}%end item
\end{itemize}
}%end item
\divideents{newVar}
\item{\vskip -1.9ex 
\index{newVar(int)}
\hypertarget{jphase.DiscPhaseVar.newVar(int)}{\membername{newVar}}
{\tt  DiscPhaseVar\ {\bf newVar}( {\tt int} {\bf n} )
\label{jphase.DiscPhaseVar.newVar(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a new variable of the same class of the original Discrete Phase-Type Variable
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- number of Phases of the new Variable}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
A new variable of the same class of the original Discrete Phase-Type Variable 
}%end item
\end{itemize}
}%end item
\divideents{pmf}
\item{\vskip -1.9ex 
\index{pmf(int)}
\hypertarget{jphase.DiscPhaseVar.pmf(int)}{\membername{pmf}}
{\tt  double\ {\bf pmf}( {\tt int} {\bf k} )
\label{jphase.DiscPhaseVar.pmf(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates the probability mass function at k
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt k} -- Evaluation point}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Evaluation of the probaility mass function at k 
}%end item
\end{itemize}
}%end item
\divideents{pmf}
\item{\vskip -1.9ex 
\index{pmf(int, int)}
\hypertarget{jphase.DiscPhaseVar.pmf(int, int)}{\membername{pmf}}
{\tt  double\lbrack \rbrack \ {\bf pmf}( {\tt int} {\bf n},
{\tt int} {\bf delta} )
\label{jphase.DiscPhaseVar.pmf(int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates the probability Mass Function at n values of x, from zero to n times delta
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- number of evaluation points}
   \item{
\sld
{\tt delta} -- distance between evaluation points}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Evaluation of the survival Function at x = 0,d,2d,..,(n-1)d 
}%end item
\end{itemize}
}%end item
\divideents{sum}
\item{\vskip -1.9ex 
\index{sum(DiscPhaseVar)}
\hypertarget{jphase.DiscPhaseVar.sum(jphase.DiscPhaseVar)}{\membername{sum}}
{\tt  DiscPhaseVar\ {\bf sum}( {\tt DiscPhaseVar} {\bf B} )
\label{jphase.DiscPhaseVar.sum(jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the sum of variables: res = A +B
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to sum to the original}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of Variables: res = A +B 
}%end item
\end{itemize}
}%end item
\divideents{sum}
\item{\vskip -1.9ex 
\index{sum(DiscPhaseVar, DiscPhaseVar)}
\hypertarget{jphase.DiscPhaseVar.sum(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{\membername{sum}}
{\tt  DiscPhaseVar\ {\bf sum}( {\tt DiscPhaseVar} {\bf B},
{\tt DiscPhaseVar} {\bf res} )
\label{jphase.DiscPhaseVar.sum(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the sum of variables: res = A +B
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Variable to sum to the original}
   \item{
\sld
{\tt res} -- Variable to store the result}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of Variables: res = A +B 
}%end item
\end{itemize}
}%end item
\divideents{sumGeom}
\item{\vskip -1.9ex 
\index{sumGeom(double)}
\hypertarget{jphase.DiscPhaseVar.sumGeom(double)}{\membername{sumGeom}}
{\tt  DiscPhaseVar\ {\bf sumGeom}( {\tt double} {\bf p} )
\label{jphase.DiscPhaseVar.sumGeom(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the sum of a geometric number of independent copies of this variable
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt p} -- Parameter of the geometric variable}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of a geometric number of independent copies of this variable 
}%end item
\end{itemize}
}%end item
\divideents{sumPH}
\item{\vskip -1.9ex 
\index{sumPH(DiscPhaseVar)}
\hypertarget{jphase.DiscPhaseVar.sumPH(jphase.DiscPhaseVar)}{\membername{sumPH}}
{\tt  DiscPhaseVar\ {\bf sumPH}( {\tt DiscPhaseVar} {\bf B} )
\label{jphase.DiscPhaseVar.sumPH(jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the sum of a Phase number of Discrete Phase-type distributions
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Discrete-Phase Type Distribution that determines the number of Discrete Phase-Type Distributions to sum}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of a Phase number of Discrete Phase-type distributions 
}%end item
\end{itemize}
}%end item
\divideents{sumPH}
\item{\vskip -1.9ex 
\index{sumPH(DiscPhaseVar, DiscPhaseVar)}
\hypertarget{jphase.DiscPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{\membername{sumPH}}
{\tt  DiscPhaseVar\ {\bf sumPH}( {\tt DiscPhaseVar} {\bf B},
{\tt DiscPhaseVar} {\bf res} )
\label{jphase.DiscPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the sum of a Phase number of Discrete Phase-type distributions
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- Discrete-Phase Type Distribution that determines the number of Discrete Phase-Type Distributions to sum}
   \item{
\sld
{\tt res} -- Discrete Phase Variable to store the resulting distribution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of a Phase number of Discrete Phase-type distributions 
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jphase.DiscPhaseVar.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jphase.DiscPhaseVar.toString()}}%end signature
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{PhaseVar}
\subsection{\label{jphase.PhaseVar}\index{PhaseVar@{\it PhaseVar}}{\bf {\it Interface} PhaseVar}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.PhaseVar}{}\vskip .1in 
This interface defines the behaviour that any Phase-Type distribution should have\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface PhaseVar
\\ {\bf implements} 
jmarkov.basic.JMarkovElement}}}
\subsubsection{Version}{0.1}
\subsubsection{All known subclasses}{SparseDiscPhaseVar\small{\refdefined{jphase.SparseDiscPhaseVar}}, SparseContPhaseVar\small{\refdefined{jphase.SparseContPhaseVar}}, HyperErlangVar\small{\refdefined{jphase.HyperErlangVar}}, ErlangCoxianVar\small{\refdefined{jphase.ErlangCoxianVar}}, DiscPhaseVar\small{\refdefined{jphase.DiscPhaseVar}}, DenseDiscPhaseVar\small{\refdefined{jphase.DenseDiscPhaseVar}}, DenseContPhaseVar\small{\refdefined{jphase.DenseContPhaseVar}}, ContPhaseVar\small{\refdefined{jphase.ContPhaseVar}}, AbstractDiscPhaseVar\small{\refdefined{jphase.AbstractDiscPhaseVar}}, AbstractContPhaseVar\small{\refdefined{jphase.AbstractContPhaseVar}}}
\subsubsection{All known subinterfaces}{DiscPhaseVar\small{\refdefined{jphase.DiscPhaseVar}}, ContPhaseVar\small{\refdefined{jphase.ContPhaseVar}}}
\subsubsection{All classes known to implement interface}{HyperErlangVar\small{\refdefined{jphase.HyperErlangVar}}, ErlangCoxianVar\small{\refdefined{jphase.ErlangCoxianVar}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.PhaseVar.cdf(double)}{{\bf cdf(double)}} Evaluates the cumulative density function at x\\
\hyperlink{jphase.PhaseVar.cdf(int, double)}{{\bf cdf(int, double)}} Evaluates the Cumulative Density Function at n values of x, starting with x=0, step delta\\
\hyperlink{jphase.PhaseVar.copy()}{{\bf copy()}} Creates a deep copy of the original Phase-Type Variable\\
\hyperlink{jphase.PhaseVar.CV()}{{\bf CV()}} Computes the Coefficient of Variation of the Phase variable\\
\hyperlink{jphase.PhaseVar.expectedValue()}{{\bf expectedValue()}} Computes the Expected Value of the Phase variable\\
\hyperlink{jphase.PhaseVar.getMat0()}{{\bf getMat0()}} Returns the exit vector from the transient states to absorption\\
\hyperlink{jphase.PhaseVar.getMat0Array()}{{\bf getMat0Array()}} Returns the exit vector in double\lbrack \rbrack\ format\\
\hyperlink{jphase.PhaseVar.getMatrix()}{{\bf getMatrix()}} Returns the transition matrix of the Phase-Type Distribution\\
\hyperlink{jphase.PhaseVar.getMatrixArray()}{{\bf getMatrixArray()}} Returns the transition matrix in double format\\
\hyperlink{jphase.PhaseVar.getNumPhases()}{{\bf getNumPhases()}} Returns the number of Phases of the Phase distribution\\
\hyperlink{jphase.PhaseVar.getVec0()}{{\bf getVec0()}} Returns the probability mass at zero (alpha\_0)\\
\hyperlink{jphase.PhaseVar.getVector()}{{\bf getVector()}} Returns the initial probability mass vector\\
\hyperlink{jphase.PhaseVar.getVectorArray()}{{\bf getVectorArray()}} Returns the initial probability mass vector in double\lbrack \rbrack\ format\\
\hyperlink{jphase.PhaseVar.lossFunction1(double)}{{\bf lossFunction1(double)}} Evaluates the loss function of order 1 at x\\
\hyperlink{jphase.PhaseVar.lossFunction2(double)}{{\bf lossFunction2(double)}} Evaluates the loss function of order 2 at x\\
\hyperlink{jphase.PhaseVar.median()}{{\bf median()}} Compuetes the median of the distribution\\
\hyperlink{jphase.PhaseVar.moment(int)}{{\bf moment(int)}} Compuetes the k-th Moment of the Phase variable\\
\hyperlink{jphase.PhaseVar.prob(double, double)}{{\bf prob(double, double)}} Computes the probability that this variable takes a value between a and b\\
\hyperlink{jphase.PhaseVar.quantil(double)}{{\bf quantil(double)}} Computes the quantile q of the distribution, such that F(q) = p\\
\hyperlink{jphase.PhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{{\bf setMatrix(Matrix)}} Rate Matrix = A\\
\hyperlink{jphase.PhaseVar.setVector(no.uib.cipr.matrix.Vector)}{{\bf setVector(Vector)}} Initial Probability vector = alpha\\
\hyperlink{jphase.PhaseVar.stdDeviation()}{{\bf stdDeviation()}} Computes the Standard deviation of the Phase variable\\
\hyperlink{jphase.PhaseVar.survival(double)}{{\bf survival(double)}} Evaluates the survival function at x\\
\hyperlink{jphase.PhaseVar.survival(int, double)}{{\bf survival(int, double)}} Evaluates the Survival Function at n values of x, starting with x=0, step delta\\
\hyperlink{jphase.PhaseVar.variance()}{{\bf variance()}} Computes the Variance of the Phase variable\\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{cdf(double)}
\hypertarget{jphase.PhaseVar.cdf(double)}{\membername{cdf}}
{\tt  double\ {\bf cdf}( {\tt double} {\bf x} )
\label{jphase.PhaseVar.cdf(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates the cumulative density function at x
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- Evaluation point}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Cumulative density function at x 
}%end item
\end{itemize}
}%end item
\divideents{cdf}
\item{\vskip -1.9ex 
\index{cdf(int, double)}
\hypertarget{jphase.PhaseVar.cdf(int, double)}{\membername{cdf}}
{\tt  double\lbrack \rbrack \ {\bf cdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
\label{jphase.PhaseVar.cdf(int, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates the Cumulative Density Function at n values of x, starting with x=0, step delta
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- number of evaluation points}
   \item{
\sld
{\tt delta} -- distance between evaluation points}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Evaluation of the survival Function at x = 0,d,2d,..,(n-1)d 
}%end item
\end{itemize}
}%end item
\divideents{copy}
\item{\vskip -1.9ex 
\index{copy()}
\hypertarget{jphase.PhaseVar.copy()}{\membername{copy}}
{\tt  PhaseVar\ {\bf copy}(  )
\label{jphase.PhaseVar.copy()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a deep copy of the original Phase-Type Variable
}
\item{{\bf Returns} -- 
A deep copy of the original Phase-Type Variable 
}%end item
\end{itemize}
}%end item
\divideents{CV}
\item{\vskip -1.9ex 
\index{CV()}
\hypertarget{jphase.PhaseVar.CV()}{\membername{CV}}
{\tt  double\ {\bf CV}(  )
\label{jphase.PhaseVar.CV()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the Coefficient of Variation of the Phase variable
}
\item{{\bf Returns} -- 
Coefficient of Variation of the Phase variable 
}%end item
\end{itemize}
}%end item
\divideents{expectedValue}
\item{\vskip -1.9ex 
\index{expectedValue()}
\hypertarget{jphase.PhaseVar.expectedValue()}{\membername{expectedValue}}
{\tt  double\ {\bf expectedValue}(  )
\label{jphase.PhaseVar.expectedValue()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the Expected Value of the Phase variable
}
\item{{\bf Returns} -- 
Expected Value of the Phase variable 
}%end item
\end{itemize}
}%end item
\divideents{getMat0}
\item{\vskip -1.9ex 
\index{getMat0()}
\hypertarget{jphase.PhaseVar.getMat0()}{\membername{getMat0}}
{\tt  no.uib.cipr.matrix.Vector\ {\bf getMat0}(  )
\label{jphase.PhaseVar.getMat0()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the exit vector from the transient states to absorption
}
\item{{\bf Returns} -- 
Exit vector from the transient states to absorption 
}%end item
\end{itemize}
}%end item
\divideents{getMat0Array}
\item{\vskip -1.9ex 
\index{getMat0Array()}
\hypertarget{jphase.PhaseVar.getMat0Array()}{\membername{getMat0Array}}
{\tt  double\lbrack \rbrack \ {\bf getMat0Array}(  )
\label{jphase.PhaseVar.getMat0Array()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the exit vector in double\lbrack \rbrack\ format
}
\item{{\bf Returns} -- 
Exit vector from the transient states to absorption in double\lbrack \rbrack\ format 
}%end item
\end{itemize}
}%end item
\divideents{getMatrix}
\item{\vskip -1.9ex 
\index{getMatrix()}
\hypertarget{jphase.PhaseVar.getMatrix()}{\membername{getMatrix}}
{\tt  no.uib.cipr.matrix.Matrix\ {\bf getMatrix}(  )
\label{jphase.PhaseVar.getMatrix()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the transition matrix of the Phase-Type Distribution
}
\item{{\bf Returns} -- 
Transition matrix for transient states of the Phase-Type Distribution 
}%end item
\end{itemize}
}%end item
\divideents{getMatrixArray}
\item{\vskip -1.9ex 
\index{getMatrixArray()}
\hypertarget{jphase.PhaseVar.getMatrixArray()}{\membername{getMatrixArray}}
{\tt  double\lbrack \rbrack \lbrack \rbrack \ {\bf getMatrixArray}(  )
\label{jphase.PhaseVar.getMatrixArray()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the transition matrix in double format
}
\item{{\bf Returns} -- 
Transition matrix for transient states of the Phase-Type Distribution in double\lbrack \rbrack \lbrack \rbrack\ format 
}%end item
\end{itemize}
}%end item
\divideents{getNumPhases}
\item{\vskip -1.9ex 
\index{getNumPhases()}
\hypertarget{jphase.PhaseVar.getNumPhases()}{\membername{getNumPhases}}
{\tt  int\ {\bf getNumPhases}(  )
\label{jphase.PhaseVar.getNumPhases()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of Phases of the Phase distribution
}
\item{{\bf Returns} -- 
Number of Phases of the Phase distribution 
}%end item
\end{itemize}
}%end item
\divideents{getVec0}
\item{\vskip -1.9ex 
\index{getVec0()}
\hypertarget{jphase.PhaseVar.getVec0()}{\membername{getVec0}}
{\tt  double\ {\bf getVec0}(  )
\label{jphase.PhaseVar.getVec0()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the probability mass at zero (alpha\_0)
}
\item{{\bf Returns} -- 
Probability mass at zero (alpha\_0) 
}%end item
\end{itemize}
}%end item
\divideents{getVector}
\item{\vskip -1.9ex 
\index{getVector()}
\hypertarget{jphase.PhaseVar.getVector()}{\membername{getVector}}
{\tt  no.uib.cipr.matrix.Vector\ {\bf getVector}(  )
\label{jphase.PhaseVar.getVector()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the initial probability mass vector
}
\item{{\bf Returns} -- 
Initial probability mass vector 
}%end item
\end{itemize}
}%end item
\divideents{getVectorArray}
\item{\vskip -1.9ex 
\index{getVectorArray()}
\hypertarget{jphase.PhaseVar.getVectorArray()}{\membername{getVectorArray}}
{\tt  double\lbrack \rbrack \ {\bf getVectorArray}(  )
\label{jphase.PhaseVar.getVectorArray()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the initial probability mass vector in double\lbrack \rbrack\ format
}
\item{{\bf Returns} -- 
Initial probability mass vector in double\lbrack \rbrack\ format 
}%end item
\end{itemize}
}%end item
\divideents{lossFunction1}
\item{\vskip -1.9ex 
\index{lossFunction1(double)}
\hypertarget{jphase.PhaseVar.lossFunction1(double)}{\membername{lossFunction1}}
{\tt  double\ {\bf lossFunction1}( {\tt double} {\bf x} )
\label{jphase.PhaseVar.lossFunction1(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates the loss function of order 1 at x
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- Evaluation point}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Evaluation of the loss function of order 1 
}%end item
\end{itemize}
}%end item
\divideents{lossFunction2}
\item{\vskip -1.9ex 
\index{lossFunction2(double)}
\hypertarget{jphase.PhaseVar.lossFunction2(double)}{\membername{lossFunction2}}
{\tt  double\ {\bf lossFunction2}( {\tt double} {\bf x} )
\label{jphase.PhaseVar.lossFunction2(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates the loss function of order 2 at x
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- Evaluation point}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Evaluation of the loss function of order 2 
}%end item
\end{itemize}
}%end item
\divideents{median}
\item{\vskip -1.9ex 
\index{median()}
\hypertarget{jphase.PhaseVar.median()}{\membername{median}}
{\tt  double\ {\bf median}(  )
\label{jphase.PhaseVar.median()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Compuetes the median of the distribution
}
\item{{\bf Returns} -- 
The median of the distribution 
}%end item
\end{itemize}
}%end item
\divideents{moment}
\item{\vskip -1.9ex 
\index{moment(int)}
\hypertarget{jphase.PhaseVar.moment(int)}{\membername{moment}}
{\tt  double\ {\bf moment}( {\tt int} {\bf k} )
\label{jphase.PhaseVar.moment(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Compuetes the k-th Moment of the Phase variable
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt k} -- Moment}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
k-th Moment of the Phase variable 
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(double, double)}
\hypertarget{jphase.PhaseVar.prob(double, double)}{\membername{prob}}
{\tt  double\ {\bf prob}( {\tt double} {\bf a},
{\tt double} {\bf b} )
\label{jphase.PhaseVar.prob(double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the probability that this variable takes a value between a and b
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt a} -- inferior limit}
   \item{
\sld
{\tt b} -- superior limit}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Probability that this variable takes a value between a and b 
}%end item
\end{itemize}
}%end item
\divideents{quantil}
\item{\vskip -1.9ex 
\index{quantil(double)}
\hypertarget{jphase.PhaseVar.quantil(double)}{\membername{quantil}}
{\tt  double\ {\bf quantil}( {\tt double} {\bf p} )
\label{jphase.PhaseVar.quantil(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the quantile q of the distribution, such that F(q) = p
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt p} -- probability such that F(q) = p}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The quantile q of the distribution, such that F(q) = p 
}%end item
\end{itemize}
}%end item
\divideents{setMatrix}
\item{\vskip -1.9ex 
\index{setMatrix(Matrix)}
\hypertarget{jphase.PhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{\membername{setMatrix}}
{\tt  void\ {\bf setMatrix}( {\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.PhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Rate Matrix = A
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Transition matrix for transient states of the Phase-Type Distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setVector}
\item{\vskip -1.9ex 
\index{setVector(Vector)}
\hypertarget{jphase.PhaseVar.setVector(no.uib.cipr.matrix.Vector)}{\membername{setVector}}
{\tt  void\ {\bf setVector}( {\tt no.uib.cipr.matrix.Vector} {\bf alpha} )
\label{jphase.PhaseVar.setVector(no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Initial Probability vector = alpha
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt alpha} -- Initial probability mass vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{stdDeviation}
\item{\vskip -1.9ex 
\index{stdDeviation()}
\hypertarget{jphase.PhaseVar.stdDeviation()}{\membername{stdDeviation}}
{\tt  double\ {\bf stdDeviation}(  )
\label{jphase.PhaseVar.stdDeviation()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the Standard deviation of the Phase variable
}
\item{{\bf Returns} -- 
Standard deviation of the Phase variable 
}%end item
\end{itemize}
}%end item
\divideents{survival}
\item{\vskip -1.9ex 
\index{survival(double)}
\hypertarget{jphase.PhaseVar.survival(double)}{\membername{survival}}
{\tt  double\ {\bf survival}( {\tt double} {\bf x} )
\label{jphase.PhaseVar.survival(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates the survival function at x
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- Evaluation point}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Evaluation of the survival Function at x = 1-F(x)=P(X\textgreater x) 
}%end item
\end{itemize}
}%end item
\divideents{survival}
\item{\vskip -1.9ex 
\index{survival(int, double)}
\hypertarget{jphase.PhaseVar.survival(int, double)}{\membername{survival}}
{\tt  double\lbrack \rbrack \ {\bf survival}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
\label{jphase.PhaseVar.survival(int, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates the Survival Function at n values of x, starting with x=0, step delta
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- number of evaluation points}
   \item{
\sld
{\tt delta} -- distance between evaluation points}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Evaluation of the survival Function at x = 0,d,2d,..,(n-1)d 
}%end item
\end{itemize}
}%end item
\divideents{variance}
\item{\vskip -1.9ex 
\index{variance()}
\hypertarget{jphase.PhaseVar.variance()}{\membername{variance}}
{\tt  double\ {\bf variance}(  )
\label{jphase.PhaseVar.variance()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the Variance of the Phase variable
}
\item{{\bf Returns} -- 
Variance of the Phase variable 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage}
\section{Classes}{
\gdef\classname{AbstractContPhaseVar}
\subsection{\label{jphase.AbstractContPhaseVar}\index{AbstractContPhaseVar}{\bf {\it Class} AbstractContPhaseVar}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.AbstractContPhaseVar}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class AbstractContPhaseVar
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
ContPhaseVar}}}
\subsubsection{Version}{0.1 Abstract class that defines the behaviour of Continuous Phase-Type Distributions}
\subsubsection{All known subclasses}{SparseContPhaseVar\small{\refdefined{jphase.SparseContPhaseVar}}, HyperErlangVar\small{\refdefined{jphase.HyperErlangVar}}, ErlangCoxianVar\small{\refdefined{jphase.ErlangCoxianVar}}, DenseContPhaseVar\small{\refdefined{jphase.DenseContPhaseVar}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.AbstractContPhaseVar()}{{\bf AbstractContPhaseVar()}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.AbstractContPhaseVar.cdf(double)}{{\bf cdf(double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.cdf(int, double)}{{\bf cdf(int, double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.CV()}{{\bf CV()}} \\
\hyperlink{jphase.AbstractContPhaseVar.description()}{{\bf description()}} \\
\hyperlink{jphase.AbstractContPhaseVar.eqResidualTime()}{{\bf eqResidualTime()}} \\
\hyperlink{jphase.AbstractContPhaseVar.expectedValue()}{{\bf expectedValue()}} \\
\hyperlink{jphase.AbstractContPhaseVar.getMat0()}{{\bf getMat0()}} \\
\hyperlink{jphase.AbstractContPhaseVar.getMat0Array()}{{\bf getMat0Array()}} \\
\hyperlink{jphase.AbstractContPhaseVar.getMatrixArray()}{{\bf getMatrixArray()}} \\
\hyperlink{jphase.AbstractContPhaseVar.getNumPhases()}{{\bf getNumPhases()}} \\
\hyperlink{jphase.AbstractContPhaseVar.getVec0()}{{\bf getVec0()}} \\
\hyperlink{jphase.AbstractContPhaseVar.getVectorArray()}{{\bf getVectorArray()}} \\
\hyperlink{jphase.AbstractContPhaseVar.label()}{{\bf label()}} \\
\hyperlink{jphase.AbstractContPhaseVar.lossFunction1(double)}{{\bf lossFunction1(double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.lossFunction2(double)}{{\bf lossFunction2(double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.max(jphase.ContPhaseVar)}{{\bf max(ContPhaseVar)}} \\
\hyperlink{jphase.AbstractContPhaseVar.max(jphase.ContPhaseVar, jphase.ContPhaseVar)}{{\bf max(ContPhaseVar, ContPhaseVar)}} \\
\hyperlink{jphase.AbstractContPhaseVar.median()}{{\bf median()}} \\
\hyperlink{jphase.AbstractContPhaseVar.min(jphase.ContPhaseVar)}{{\bf min(ContPhaseVar)}} \\
\hyperlink{jphase.AbstractContPhaseVar.min(jphase.ContPhaseVar, jphase.ContPhaseVar)}{{\bf min(ContPhaseVar, ContPhaseVar)}} \\
\hyperlink{jphase.AbstractContPhaseVar.mix(double, jphase.ContPhaseVar)}{{\bf mix(double, ContPhaseVar)}} \\
\hyperlink{jphase.AbstractContPhaseVar.mix(double, jphase.ContPhaseVar, jphase.ContPhaseVar)}{{\bf mix(double, ContPhaseVar, ContPhaseVar)}} \\
\hyperlink{jphase.AbstractContPhaseVar.moment(int)}{{\bf moment(int)}} \\
\hyperlink{jphase.AbstractContPhaseVar.pdf(double)}{{\bf pdf(double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.pdf(int, double)}{{\bf pdf(int, double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.prob(double, double)}{{\bf prob(double, double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.quantil(double)}{{\bf quantil(double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.residualTime(double)}{{\bf residualTime(double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.residualVar(double)}{{\bf residualVar(double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.stdDeviation()}{{\bf stdDeviation()}} \\
\hyperlink{jphase.AbstractContPhaseVar.sum(jphase.ContPhaseVar)}{{\bf sum(ContPhaseVar)}} \\
\hyperlink{jphase.AbstractContPhaseVar.sum(jphase.ContPhaseVar, jphase.ContPhaseVar)}{{\bf sum(ContPhaseVar, ContPhaseVar)}} \\
\hyperlink{jphase.AbstractContPhaseVar.sumGeom(double)}{{\bf sumGeom(double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.sumPH(jphase.DiscPhaseVar)}{{\bf sumPH(DiscPhaseVar)}} \\
\hyperlink{jphase.AbstractContPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.ContPhaseVar)}{{\bf sumPH(DiscPhaseVar, ContPhaseVar)}} \\
\hyperlink{jphase.AbstractContPhaseVar.survival(double)}{{\bf survival(double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.survival(int, double)}{{\bf survival(int, double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.times(double)}{{\bf times(double)}} \\
\hyperlink{jphase.AbstractContPhaseVar.toString()}{{\bf toString()}} \\
\hyperlink{jphase.AbstractContPhaseVar.variance()}{{\bf variance()}} \\
\hyperlink{jphase.AbstractContPhaseVar.waitingQ(double)}{{\bf waitingQ(double)}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{AbstractContPhaseVar()}
\hypertarget{jphase.AbstractContPhaseVar()}{\membername{AbstractContPhaseVar}}
{\tt public\ {\bf AbstractContPhaseVar}(  )
\label{jphase.AbstractContPhaseVar()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{cdf(double)}
\hypertarget{jphase.AbstractContPhaseVar.cdf(double)}{\membername{cdf}}
{\tt public double\ {\bf cdf}( {\tt double} {\bf x} )
\label{jphase.AbstractContPhaseVar.cdf(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.cdf(double)}{PhaseVar.cdf(double)}} {\small 
\refdefined{jphase.PhaseVar.cdf(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{cdf}
\item{\vskip -1.9ex 
\index{cdf(int, double)}
\hypertarget{jphase.AbstractContPhaseVar.cdf(int, double)}{\membername{cdf}}
{\tt public double\lbrack \rbrack \ {\bf cdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
\label{jphase.AbstractContPhaseVar.cdf(int, double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.cdf(int, double)}{PhaseVar.cdf(int,\allowbreak double)}} {\small 
\refdefined{jphase.PhaseVar.cdf(int, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{CV}
\item{\vskip -1.9ex 
\index{CV()}
\hypertarget{jphase.AbstractContPhaseVar.CV()}{\membername{CV}}
{\tt public double\ {\bf CV}(  )
\label{jphase.AbstractContPhaseVar.CV()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.CV()}{PhaseVar.CV()}} {\small 
\refdefined{jphase.PhaseVar.CV()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jphase.AbstractContPhaseVar.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jphase.AbstractContPhaseVar.description()}}%end signature
}%end item
\divideents{eqResidualTime}
\item{\vskip -1.9ex 
\index{eqResidualTime()}
\hypertarget{jphase.AbstractContPhaseVar.eqResidualTime()}{\membername{eqResidualTime}}
{\tt public ContPhaseVar\ {\bf eqResidualTime}(  )
\label{jphase.AbstractContPhaseVar.eqResidualTime()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.eqResidualTime()}{ContPhaseVar.eqResidualTime()}} {\small 
\refdefined{jphase.ContPhaseVar.eqResidualTime()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{expectedValue}
\item{\vskip -1.9ex 
\index{expectedValue()}
\hypertarget{jphase.AbstractContPhaseVar.expectedValue()}{\membername{expectedValue}}
{\tt public double\ {\bf expectedValue}(  )
\label{jphase.AbstractContPhaseVar.expectedValue()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.expectedValue()}{PhaseVar.expectedValue()}} {\small 
\refdefined{jphase.PhaseVar.expectedValue()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMat0}
\item{\vskip -1.9ex 
\index{getMat0()}
\hypertarget{jphase.AbstractContPhaseVar.getMat0()}{\membername{getMat0}}
{\tt public no.uib.cipr.matrix.Vector\ {\bf getMat0}(  )
\label{jphase.AbstractContPhaseVar.getMat0()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getMat0()}{PhaseVar.getMat0()}} {\small 
\refdefined{jphase.PhaseVar.getMat0()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMat0Array}
\item{\vskip -1.9ex 
\index{getMat0Array()}
\hypertarget{jphase.AbstractContPhaseVar.getMat0Array()}{\membername{getMat0Array}}
{\tt public double\lbrack \rbrack \ {\bf getMat0Array}(  )
\label{jphase.AbstractContPhaseVar.getMat0Array()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getMat0Array()}{PhaseVar.getMat0Array()}} {\small 
\refdefined{jphase.PhaseVar.getMat0Array()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMatrixArray}
\item{\vskip -1.9ex 
\index{getMatrixArray()}
\hypertarget{jphase.AbstractContPhaseVar.getMatrixArray()}{\membername{getMatrixArray}}
{\tt public double\lbrack \rbrack \lbrack \rbrack \ {\bf getMatrixArray}(  )
\label{jphase.AbstractContPhaseVar.getMatrixArray()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getMatrixArray()}{PhaseVar.getMatrixArray()}} {\small 
\refdefined{jphase.PhaseVar.getMatrixArray()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getNumPhases}
\item{\vskip -1.9ex 
\index{getNumPhases()}
\hypertarget{jphase.AbstractContPhaseVar.getNumPhases()}{\membername{getNumPhases}}
{\tt public int\ {\bf getNumPhases}(  )
\label{jphase.AbstractContPhaseVar.getNumPhases()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getNumPhases()}{PhaseVar.getNumPhases()}} {\small 
\refdefined{jphase.PhaseVar.getNumPhases()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getVec0}
\item{\vskip -1.9ex 
\index{getVec0()}
\hypertarget{jphase.AbstractContPhaseVar.getVec0()}{\membername{getVec0}}
{\tt public double\ {\bf getVec0}(  )
\label{jphase.AbstractContPhaseVar.getVec0()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getVec0()}{PhaseVar.getVec0()}} {\small 
\refdefined{jphase.PhaseVar.getVec0()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getVectorArray}
\item{\vskip -1.9ex 
\index{getVectorArray()}
\hypertarget{jphase.AbstractContPhaseVar.getVectorArray()}{\membername{getVectorArray}}
{\tt public double\lbrack \rbrack \ {\bf getVectorArray}(  )
\label{jphase.AbstractContPhaseVar.getVectorArray()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getVectorArray()}{PhaseVar.getVectorArray()}} {\small 
\refdefined{jphase.PhaseVar.getVectorArray()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jphase.AbstractContPhaseVar.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jphase.AbstractContPhaseVar.label()}}%end signature
}%end item
\divideents{lossFunction1}
\item{\vskip -1.9ex 
\index{lossFunction1(double)}
\hypertarget{jphase.AbstractContPhaseVar.lossFunction1(double)}{\membername{lossFunction1}}
{\tt public double\ {\bf lossFunction1}( {\tt double} {\bf x} )
\label{jphase.AbstractContPhaseVar.lossFunction1(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.lossFunction1(double)}{PhaseVar.lossFunction1(double)}} {\small 
\refdefined{jphase.PhaseVar.lossFunction1(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{lossFunction2}
\item{\vskip -1.9ex 
\index{lossFunction2(double)}
\hypertarget{jphase.AbstractContPhaseVar.lossFunction2(double)}{\membername{lossFunction2}}
{\tt public double\ {\bf lossFunction2}( {\tt double} {\bf x} )
\label{jphase.AbstractContPhaseVar.lossFunction2(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.lossFunction2(double)}{PhaseVar.lossFunction2(double)}} {\small 
\refdefined{jphase.PhaseVar.lossFunction2(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{max}
\item{\vskip -1.9ex 
\index{max(ContPhaseVar)}
\hypertarget{jphase.AbstractContPhaseVar.max(jphase.ContPhaseVar)}{\membername{max}}
{\tt public ContPhaseVar\ {\bf max}( {\tt ContPhaseVar} {\bf v2} )
\label{jphase.AbstractContPhaseVar.max(jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.max(jphase.ContPhaseVar)}{ContPhaseVar.max(ContPhaseVar)}} {\small 
\refdefined{jphase.ContPhaseVar.max(jphase.ContPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{max}
\item{\vskip -1.9ex 
\index{max(ContPhaseVar, ContPhaseVar)}
\hypertarget{jphase.AbstractContPhaseVar.max(jphase.ContPhaseVar, jphase.ContPhaseVar)}{\membername{max}}
{\tt public ContPhaseVar\ {\bf max}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
\label{jphase.AbstractContPhaseVar.max(jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.max(jphase.ContPhaseVar, jphase.ContPhaseVar)}{ContPhaseVar.max(ContPhaseVar,\allowbreak ContPhaseVar)}} {\small 
\refdefined{jphase.ContPhaseVar.max(jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{median}
\item{\vskip -1.9ex 
\index{median()}
\hypertarget{jphase.AbstractContPhaseVar.median()}{\membername{median}}
{\tt public double\ {\bf median}(  )
\label{jphase.AbstractContPhaseVar.median()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.median()}{PhaseVar.median()}} {\small 
\refdefined{jphase.PhaseVar.median()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{min}
\item{\vskip -1.9ex 
\index{min(ContPhaseVar)}
\hypertarget{jphase.AbstractContPhaseVar.min(jphase.ContPhaseVar)}{\membername{min}}
{\tt public ContPhaseVar\ {\bf min}( {\tt ContPhaseVar} {\bf v2} )
\label{jphase.AbstractContPhaseVar.min(jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.min(jphase.ContPhaseVar)}{ContPhaseVar.min(ContPhaseVar)}} {\small 
\refdefined{jphase.ContPhaseVar.min(jphase.ContPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{min}
\item{\vskip -1.9ex 
\index{min(ContPhaseVar, ContPhaseVar)}
\hypertarget{jphase.AbstractContPhaseVar.min(jphase.ContPhaseVar, jphase.ContPhaseVar)}{\membername{min}}
{\tt public ContPhaseVar\ {\bf min}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
\label{jphase.AbstractContPhaseVar.min(jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.min(jphase.ContPhaseVar, jphase.ContPhaseVar)}{ContPhaseVar.min(ContPhaseVar,\allowbreak ContPhaseVar)}} {\small 
\refdefined{jphase.ContPhaseVar.min(jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{mix}
\item{\vskip -1.9ex 
\index{mix(double, ContPhaseVar)}
\hypertarget{jphase.AbstractContPhaseVar.mix(double, jphase.ContPhaseVar)}{\membername{mix}}
{\tt public ContPhaseVar\ {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf v2} )
\label{jphase.AbstractContPhaseVar.mix(double, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.mix(double, jphase.ContPhaseVar)}{ContPhaseVar.mix(double,\allowbreak ContPhaseVar)}} {\small 
\refdefined{jphase.ContPhaseVar.mix(double, jphase.ContPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{mix}
\item{\vskip -1.9ex 
\index{mix(double, ContPhaseVar, ContPhaseVar)}
\hypertarget{jphase.AbstractContPhaseVar.mix(double, jphase.ContPhaseVar, jphase.ContPhaseVar)}{\membername{mix}}
{\tt public ContPhaseVar\ {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
\label{jphase.AbstractContPhaseVar.mix(double, jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.mix(double, jphase.ContPhaseVar, jphase.ContPhaseVar)}{ContPhaseVar.mix(double,\allowbreak ContPhaseVar,\allowbreak ContPhaseVar)}} {\small 
\refdefined{jphase.ContPhaseVar.mix(double, jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{moment}
\item{\vskip -1.9ex 
\index{moment(int)}
\hypertarget{jphase.AbstractContPhaseVar.moment(int)}{\membername{moment}}
{\tt public double\ {\bf moment}( {\tt int} {\bf k} )
\label{jphase.AbstractContPhaseVar.moment(int)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.moment(int)}{PhaseVar.moment(int)}} {\small 
\refdefined{jphase.PhaseVar.moment(int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pdf}
\item{\vskip -1.9ex 
\index{pdf(double)}
\hypertarget{jphase.AbstractContPhaseVar.pdf(double)}{\membername{pdf}}
{\tt public double\ {\bf pdf}( {\tt double} {\bf x} )
\label{jphase.AbstractContPhaseVar.pdf(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.pdf(double)}{ContPhaseVar.pdf(double)}} {\small 
\refdefined{jphase.ContPhaseVar.pdf(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pdf}
\item{\vskip -1.9ex 
\index{pdf(int, double)}
\hypertarget{jphase.AbstractContPhaseVar.pdf(int, double)}{\membername{pdf}}
{\tt public double\lbrack \rbrack \ {\bf pdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
\label{jphase.AbstractContPhaseVar.pdf(int, double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.pdf(int, double)}{ContPhaseVar.pdf(int,\allowbreak double)}} {\small 
\refdefined{jphase.ContPhaseVar.pdf(int, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(double, double)}
\hypertarget{jphase.AbstractContPhaseVar.prob(double, double)}{\membername{prob}}
{\tt public double\ {\bf prob}( {\tt double} {\bf a},
{\tt double} {\bf b} )
\label{jphase.AbstractContPhaseVar.prob(double, double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.prob(double, double)}{PhaseVar.prob(double,\allowbreak double)}} {\small 
\refdefined{jphase.PhaseVar.prob(double, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{quantil}
\item{\vskip -1.9ex 
\index{quantil(double)}
\hypertarget{jphase.AbstractContPhaseVar.quantil(double)}{\membername{quantil}}
{\tt public double\ {\bf quantil}( {\tt double} {\bf p} )
\label{jphase.AbstractContPhaseVar.quantil(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.quantil(double)}{PhaseVar.quantil(double)}} {\small 
\refdefined{jphase.PhaseVar.quantil(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{residualTime}
\item{\vskip -1.9ex 
\index{residualTime(double)}
\hypertarget{jphase.AbstractContPhaseVar.residualTime(double)}{\membername{residualTime}}
{\tt public ContPhaseVar\ {\bf residualTime}( {\tt double} {\bf x} )
\label{jphase.AbstractContPhaseVar.residualTime(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.residualTime(double)}{ContPhaseVar.residualTime(double)}} {\small 
\refdefined{jphase.ContPhaseVar.residualTime(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{residualVar}
\item{\vskip -1.9ex 
\index{residualVar(double)}
\hypertarget{jphase.AbstractContPhaseVar.residualVar(double)}{\membername{residualVar}}
{\tt public ContPhaseVar\ {\bf residualVar}( {\tt double} {\bf a} )
\label{jphase.AbstractContPhaseVar.residualVar(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.residualVar(double)}{ContPhaseVar.residualVar(double)}} {\small 
\refdefined{jphase.ContPhaseVar.residualVar(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{stdDeviation}
\item{\vskip -1.9ex 
\index{stdDeviation()}
\hypertarget{jphase.AbstractContPhaseVar.stdDeviation()}{\membername{stdDeviation}}
{\tt public double\ {\bf stdDeviation}(  )
\label{jphase.AbstractContPhaseVar.stdDeviation()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.stdDeviation()}{PhaseVar.stdDeviation()}} {\small 
\refdefined{jphase.PhaseVar.stdDeviation()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sum}
\item{\vskip -1.9ex 
\index{sum(ContPhaseVar)}
\hypertarget{jphase.AbstractContPhaseVar.sum(jphase.ContPhaseVar)}{\membername{sum}}
{\tt public ContPhaseVar\ {\bf sum}( {\tt ContPhaseVar} {\bf v2} )
\label{jphase.AbstractContPhaseVar.sum(jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.sum(jphase.ContPhaseVar)}{ContPhaseVar.sum(ContPhaseVar)}} {\small 
\refdefined{jphase.ContPhaseVar.sum(jphase.ContPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sum}
\item{\vskip -1.9ex 
\index{sum(ContPhaseVar, ContPhaseVar)}
\hypertarget{jphase.AbstractContPhaseVar.sum(jphase.ContPhaseVar, jphase.ContPhaseVar)}{\membername{sum}}
{\tt public ContPhaseVar\ {\bf sum}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
\label{jphase.AbstractContPhaseVar.sum(jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.sum(jphase.ContPhaseVar, jphase.ContPhaseVar)}{ContPhaseVar.sum(ContPhaseVar,\allowbreak ContPhaseVar)}} {\small 
\refdefined{jphase.ContPhaseVar.sum(jphase.ContPhaseVar, jphase.ContPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sumGeom}
\item{\vskip -1.9ex 
\index{sumGeom(double)}
\hypertarget{jphase.AbstractContPhaseVar.sumGeom(double)}{\membername{sumGeom}}
{\tt public ContPhaseVar\ {\bf sumGeom}( {\tt double} {\bf p} )
\label{jphase.AbstractContPhaseVar.sumGeom(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.sumGeom(double)}{ContPhaseVar.sumGeom(double)}} {\small 
\refdefined{jphase.ContPhaseVar.sumGeom(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sumPH}
\item{\vskip -1.9ex 
\index{sumPH(DiscPhaseVar)}
\hypertarget{jphase.AbstractContPhaseVar.sumPH(jphase.DiscPhaseVar)}{\membername{sumPH}}
{\tt public ContPhaseVar\ {\bf sumPH}( {\tt DiscPhaseVar} {\bf v2} )
\label{jphase.AbstractContPhaseVar.sumPH(jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.sumPH(jphase.DiscPhaseVar)}{ContPhaseVar.sumPH(DiscPhaseVar)}} {\small 
\refdefined{jphase.ContPhaseVar.sumPH(jphase.DiscPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sumPH}
\item{\vskip -1.9ex 
\index{sumPH(DiscPhaseVar, ContPhaseVar)}
\hypertarget{jphase.AbstractContPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.ContPhaseVar)}{\membername{sumPH}}
{\tt public ContPhaseVar\ {\bf sumPH}( {\tt DiscPhaseVar} {\bf B},
{\tt ContPhaseVar} {\bf res} )
\label{jphase.AbstractContPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.ContPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.ContPhaseVar)}{ContPhaseVar.sumPH(DiscPhaseVar,\allowbreak ContPhaseVar)}} {\small 
\refdefined{jphase.ContPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.ContPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{survival}
\item{\vskip -1.9ex 
\index{survival(double)}
\hypertarget{jphase.AbstractContPhaseVar.survival(double)}{\membername{survival}}
{\tt public double\ {\bf survival}( {\tt double} {\bf x} )
\label{jphase.AbstractContPhaseVar.survival(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.survival(double)}{PhaseVar.survival(double)}} {\small 
\refdefined{jphase.PhaseVar.survival(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{survival}
\item{\vskip -1.9ex 
\index{survival(int, double)}
\hypertarget{jphase.AbstractContPhaseVar.survival(int, double)}{\membername{survival}}
{\tt public double\lbrack \rbrack \ {\bf survival}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
\label{jphase.AbstractContPhaseVar.survival(int, double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.survival(int, double)}{PhaseVar.survival(int,\allowbreak double)}} {\small 
\refdefined{jphase.PhaseVar.survival(int, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{times}
\item{\vskip -1.9ex 
\index{times(double)}
\hypertarget{jphase.AbstractContPhaseVar.times(double)}{\membername{times}}
{\tt public ContPhaseVar\ {\bf times}( {\tt double} {\bf c} )
\label{jphase.AbstractContPhaseVar.times(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.times(double)}{ContPhaseVar.times(double)}} {\small 
\refdefined{jphase.ContPhaseVar.times(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jphase.AbstractContPhaseVar.toString()}{\membername{toString}}
{\tt public final java.lang.String\ {\bf toString}(  )
\label{jphase.AbstractContPhaseVar.toString()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.toString()}{ContPhaseVar.toString()}} {\small 
\refdefined{jphase.ContPhaseVar.toString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{variance}
\item{\vskip -1.9ex 
\index{variance()}
\hypertarget{jphase.AbstractContPhaseVar.variance()}{\membername{variance}}
{\tt public double\ {\bf variance}(  )
\label{jphase.AbstractContPhaseVar.variance()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.variance()}{PhaseVar.variance()}} {\small 
\refdefined{jphase.PhaseVar.variance()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{waitingQ}
\item{\vskip -1.9ex 
\index{waitingQ(double)}
\hypertarget{jphase.AbstractContPhaseVar.waitingQ(double)}{\membername{waitingQ}}
{\tt public ContPhaseVar\ {\bf waitingQ}( {\tt double} {\bf rho} )
\label{jphase.AbstractContPhaseVar.waitingQ(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.waitingQ(double)}{ContPhaseVar.waitingQ(double)}} {\small 
\refdefined{jphase.ContPhaseVar.waitingQ(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{AbstractDiscPhaseVar}
\subsection{\label{jphase.AbstractDiscPhaseVar}\index{AbstractDiscPhaseVar}{\bf {\it Class} AbstractDiscPhaseVar}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.AbstractDiscPhaseVar}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class AbstractDiscPhaseVar
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
DiscPhaseVar}}}
\subsubsection{Version}{0.1 Abstract class that defines the behaviour of the Discrete Phase-Type distributions}
\subsubsection{All known subclasses}{SparseDiscPhaseVar\small{\refdefined{jphase.SparseDiscPhaseVar}}, DenseDiscPhaseVar\small{\refdefined{jphase.DenseDiscPhaseVar}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.AbstractDiscPhaseVar()}{{\bf AbstractDiscPhaseVar()}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.AbstractDiscPhaseVar.cdf(double)}{{\bf cdf(double)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.cdf(int, double)}{{\bf cdf(int, double)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.CV()}{{\bf CV()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.description()}{{\bf description()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.expectedValue()}{{\bf expectedValue()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.getMat0()}{{\bf getMat0()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.getMat0Array()}{{\bf getMat0Array()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.getMatrixArray()}{{\bf getMatrixArray()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.getNumPhases()}{{\bf getNumPhases()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.getVec0()}{{\bf getVec0()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.getVectorArray()}{{\bf getVectorArray()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.label()}{{\bf label()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.lossFunction1(double)}{{\bf lossFunction1(double)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.lossFunction2(double)}{{\bf lossFunction2(double)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.max(jphase.DiscPhaseVar)}{{\bf max(DiscPhaseVar)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.max(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{{\bf max(DiscPhaseVar, DiscPhaseVar)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.median()}{{\bf median()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.min(jphase.DiscPhaseVar)}{{\bf min(DiscPhaseVar)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.min(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{{\bf min(DiscPhaseVar, DiscPhaseVar)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.mix(double, jphase.DiscPhaseVar)}{{\bf mix(double, DiscPhaseVar)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.mix(double, jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{{\bf mix(double, DiscPhaseVar, DiscPhaseVar)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.moment(int)}{{\bf moment(int)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.pmf(int)}{{\bf pmf(int)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.pmf(int, int)}{{\bf pmf(int, int)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.prob(double, double)}{{\bf prob(double, double)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.quantil(double)}{{\bf quantil(double)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.stdDeviation()}{{\bf stdDeviation()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.sum(jphase.DiscPhaseVar)}{{\bf sum(DiscPhaseVar)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.sum(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{{\bf sum(DiscPhaseVar, DiscPhaseVar)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.sumGeom(double)}{{\bf sumGeom(double)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.sumPH(jphase.DiscPhaseVar)}{{\bf sumPH(DiscPhaseVar)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{{\bf sumPH(DiscPhaseVar, DiscPhaseVar)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.survival(double)}{{\bf survival(double)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.survival(int, double)}{{\bf survival(int, double)}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.toString()}{{\bf toString()}} \\
\hyperlink{jphase.AbstractDiscPhaseVar.variance()}{{\bf variance()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{AbstractDiscPhaseVar()}
\hypertarget{jphase.AbstractDiscPhaseVar()}{\membername{AbstractDiscPhaseVar}}
{\tt public\ {\bf AbstractDiscPhaseVar}(  )
\label{jphase.AbstractDiscPhaseVar()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{cdf(double)}
\hypertarget{jphase.AbstractDiscPhaseVar.cdf(double)}{\membername{cdf}}
{\tt public double\ {\bf cdf}( {\tt double} {\bf x} )
\label{jphase.AbstractDiscPhaseVar.cdf(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.cdf(double)}{PhaseVar.cdf(double)}} {\small 
\refdefined{jphase.PhaseVar.cdf(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{cdf}
\item{\vskip -1.9ex 
\index{cdf(int, double)}
\hypertarget{jphase.AbstractDiscPhaseVar.cdf(int, double)}{\membername{cdf}}
{\tt public double\lbrack \rbrack \ {\bf cdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
\label{jphase.AbstractDiscPhaseVar.cdf(int, double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.cdf(int, double)}{PhaseVar.cdf(int,\allowbreak double)}} {\small 
\refdefined{jphase.PhaseVar.cdf(int, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{CV}
\item{\vskip -1.9ex 
\index{CV()}
\hypertarget{jphase.AbstractDiscPhaseVar.CV()}{\membername{CV}}
{\tt public double\ {\bf CV}(  )
\label{jphase.AbstractDiscPhaseVar.CV()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.CV()}{PhaseVar.CV()}} {\small 
\refdefined{jphase.PhaseVar.CV()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jphase.AbstractDiscPhaseVar.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jphase.AbstractDiscPhaseVar.description()}}%end signature
}%end item
\divideents{expectedValue}
\item{\vskip -1.9ex 
\index{expectedValue()}
\hypertarget{jphase.AbstractDiscPhaseVar.expectedValue()}{\membername{expectedValue}}
{\tt public double\ {\bf expectedValue}(  )
\label{jphase.AbstractDiscPhaseVar.expectedValue()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.expectedValue()}{PhaseVar.expectedValue()}} {\small 
\refdefined{jphase.PhaseVar.expectedValue()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMat0}
\item{\vskip -1.9ex 
\index{getMat0()}
\hypertarget{jphase.AbstractDiscPhaseVar.getMat0()}{\membername{getMat0}}
{\tt public no.uib.cipr.matrix.Vector\ {\bf getMat0}(  )
\label{jphase.AbstractDiscPhaseVar.getMat0()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getMat0()}{PhaseVar.getMat0()}} {\small 
\refdefined{jphase.PhaseVar.getMat0()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMat0Array}
\item{\vskip -1.9ex 
\index{getMat0Array()}
\hypertarget{jphase.AbstractDiscPhaseVar.getMat0Array()}{\membername{getMat0Array}}
{\tt public double\lbrack \rbrack \ {\bf getMat0Array}(  )
\label{jphase.AbstractDiscPhaseVar.getMat0Array()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getMat0Array()}{PhaseVar.getMat0Array()}} {\small 
\refdefined{jphase.PhaseVar.getMat0Array()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMatrixArray}
\item{\vskip -1.9ex 
\index{getMatrixArray()}
\hypertarget{jphase.AbstractDiscPhaseVar.getMatrixArray()}{\membername{getMatrixArray}}
{\tt public double\lbrack \rbrack \lbrack \rbrack \ {\bf getMatrixArray}(  )
\label{jphase.AbstractDiscPhaseVar.getMatrixArray()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getMatrixArray()}{PhaseVar.getMatrixArray()}} {\small 
\refdefined{jphase.PhaseVar.getMatrixArray()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getNumPhases}
\item{\vskip -1.9ex 
\index{getNumPhases()}
\hypertarget{jphase.AbstractDiscPhaseVar.getNumPhases()}{\membername{getNumPhases}}
{\tt public int\ {\bf getNumPhases}(  )
\label{jphase.AbstractDiscPhaseVar.getNumPhases()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getNumPhases()}{PhaseVar.getNumPhases()}} {\small 
\refdefined{jphase.PhaseVar.getNumPhases()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getVec0}
\item{\vskip -1.9ex 
\index{getVec0()}
\hypertarget{jphase.AbstractDiscPhaseVar.getVec0()}{\membername{getVec0}}
{\tt public double\ {\bf getVec0}(  )
\label{jphase.AbstractDiscPhaseVar.getVec0()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getVec0()}{PhaseVar.getVec0()}} {\small 
\refdefined{jphase.PhaseVar.getVec0()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getVectorArray}
\item{\vskip -1.9ex 
\index{getVectorArray()}
\hypertarget{jphase.AbstractDiscPhaseVar.getVectorArray()}{\membername{getVectorArray}}
{\tt public double\lbrack \rbrack \ {\bf getVectorArray}(  )
\label{jphase.AbstractDiscPhaseVar.getVectorArray()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getVectorArray()}{PhaseVar.getVectorArray()}} {\small 
\refdefined{jphase.PhaseVar.getVectorArray()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{label}
\item{\vskip -1.9ex 
\index{label()}
\hypertarget{jphase.AbstractDiscPhaseVar.label()}{\membername{label}}
{\tt public java.lang.String\ {\bf label}(  )
\label{jphase.AbstractDiscPhaseVar.label()}}%end signature
}%end item
\divideents{lossFunction1}
\item{\vskip -1.9ex 
\index{lossFunction1(double)}
\hypertarget{jphase.AbstractDiscPhaseVar.lossFunction1(double)}{\membername{lossFunction1}}
{\tt public double\ {\bf lossFunction1}( {\tt double} {\bf x} )
\label{jphase.AbstractDiscPhaseVar.lossFunction1(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.lossFunction1(double)}{PhaseVar.lossFunction1(double)}} {\small 
\refdefined{jphase.PhaseVar.lossFunction1(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{lossFunction2}
\item{\vskip -1.9ex 
\index{lossFunction2(double)}
\hypertarget{jphase.AbstractDiscPhaseVar.lossFunction2(double)}{\membername{lossFunction2}}
{\tt public double\ {\bf lossFunction2}( {\tt double} {\bf x} )
\label{jphase.AbstractDiscPhaseVar.lossFunction2(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.lossFunction2(double)}{PhaseVar.lossFunction2(double)}} {\small 
\refdefined{jphase.PhaseVar.lossFunction2(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{max}
\item{\vskip -1.9ex 
\index{max(DiscPhaseVar)}
\hypertarget{jphase.AbstractDiscPhaseVar.max(jphase.DiscPhaseVar)}{\membername{max}}
{\tt public DiscPhaseVar\ {\bf max}( {\tt DiscPhaseVar} {\bf v2} )
\label{jphase.AbstractDiscPhaseVar.max(jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.max(jphase.DiscPhaseVar)}{DiscPhaseVar.max(DiscPhaseVar)}} {\small 
\refdefined{jphase.DiscPhaseVar.max(jphase.DiscPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{max}
\item{\vskip -1.9ex 
\index{max(DiscPhaseVar, DiscPhaseVar)}
\hypertarget{jphase.AbstractDiscPhaseVar.max(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{\membername{max}}
{\tt public DiscPhaseVar\ {\bf max}( {\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
\label{jphase.AbstractDiscPhaseVar.max(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.max(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{DiscPhaseVar.max(DiscPhaseVar,\allowbreak DiscPhaseVar)}} {\small 
\refdefined{jphase.DiscPhaseVar.max(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{median}
\item{\vskip -1.9ex 
\index{median()}
\hypertarget{jphase.AbstractDiscPhaseVar.median()}{\membername{median}}
{\tt public double\ {\bf median}(  )
\label{jphase.AbstractDiscPhaseVar.median()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.median()}{PhaseVar.median()}} {\small 
\refdefined{jphase.PhaseVar.median()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{min}
\item{\vskip -1.9ex 
\index{min(DiscPhaseVar)}
\hypertarget{jphase.AbstractDiscPhaseVar.min(jphase.DiscPhaseVar)}{\membername{min}}
{\tt public DiscPhaseVar\ {\bf min}( {\tt DiscPhaseVar} {\bf v2} )
\label{jphase.AbstractDiscPhaseVar.min(jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.min(jphase.DiscPhaseVar)}{DiscPhaseVar.min(DiscPhaseVar)}} {\small 
\refdefined{jphase.DiscPhaseVar.min(jphase.DiscPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{min}
\item{\vskip -1.9ex 
\index{min(DiscPhaseVar, DiscPhaseVar)}
\hypertarget{jphase.AbstractDiscPhaseVar.min(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{\membername{min}}
{\tt public DiscPhaseVar\ {\bf min}( {\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
\label{jphase.AbstractDiscPhaseVar.min(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.min(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{DiscPhaseVar.min(DiscPhaseVar,\allowbreak DiscPhaseVar)}} {\small 
\refdefined{jphase.DiscPhaseVar.min(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{mix}
\item{\vskip -1.9ex 
\index{mix(double, DiscPhaseVar)}
\hypertarget{jphase.AbstractDiscPhaseVar.mix(double, jphase.DiscPhaseVar)}{\membername{mix}}
{\tt public DiscPhaseVar\ {\bf mix}( {\tt double} {\bf p},
{\tt DiscPhaseVar} {\bf v2} )
\label{jphase.AbstractDiscPhaseVar.mix(double, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.mix(double, jphase.DiscPhaseVar)}{DiscPhaseVar.mix(double,\allowbreak DiscPhaseVar)}} {\small 
\refdefined{jphase.DiscPhaseVar.mix(double, jphase.DiscPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{mix}
\item{\vskip -1.9ex 
\index{mix(double, DiscPhaseVar, DiscPhaseVar)}
\hypertarget{jphase.AbstractDiscPhaseVar.mix(double, jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{\membername{mix}}
{\tt public DiscPhaseVar\ {\bf mix}( {\tt double} {\bf p},
{\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
\label{jphase.AbstractDiscPhaseVar.mix(double, jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.mix(double, jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{DiscPhaseVar.mix(double,\allowbreak DiscPhaseVar,\allowbreak DiscPhaseVar)}} {\small 
\refdefined{jphase.DiscPhaseVar.mix(double, jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{moment}
\item{\vskip -1.9ex 
\index{moment(int)}
\hypertarget{jphase.AbstractDiscPhaseVar.moment(int)}{\membername{moment}}
{\tt public double\ {\bf moment}( {\tt int} {\bf k} )
\label{jphase.AbstractDiscPhaseVar.moment(int)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.moment(int)}{PhaseVar.moment(int)}} {\small 
\refdefined{jphase.PhaseVar.moment(int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pmf}
\item{\vskip -1.9ex 
\index{pmf(int)}
\hypertarget{jphase.AbstractDiscPhaseVar.pmf(int)}{\membername{pmf}}
{\tt public double\ {\bf pmf}( {\tt int} {\bf k} )
\label{jphase.AbstractDiscPhaseVar.pmf(int)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.pmf(int)}{DiscPhaseVar.pmf(int)}} {\small 
\refdefined{jphase.DiscPhaseVar.pmf(int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pmf}
\item{\vskip -1.9ex 
\index{pmf(int, int)}
\hypertarget{jphase.AbstractDiscPhaseVar.pmf(int, int)}{\membername{pmf}}
{\tt public double\lbrack \rbrack \ {\bf pmf}( {\tt int} {\bf n},
{\tt int} {\bf delta} )
\label{jphase.AbstractDiscPhaseVar.pmf(int, int)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.pmf(int, int)}{DiscPhaseVar.pmf(int,\allowbreak int)}} {\small 
\refdefined{jphase.DiscPhaseVar.pmf(int, int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{prob}
\item{\vskip -1.9ex 
\index{prob(double, double)}
\hypertarget{jphase.AbstractDiscPhaseVar.prob(double, double)}{\membername{prob}}
{\tt public double\ {\bf prob}( {\tt double} {\bf a},
{\tt double} {\bf b} )
\label{jphase.AbstractDiscPhaseVar.prob(double, double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.prob(double, double)}{PhaseVar.prob(double,\allowbreak double)}} {\small 
\refdefined{jphase.PhaseVar.prob(double, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{quantil}
\item{\vskip -1.9ex 
\index{quantil(double)}
\hypertarget{jphase.AbstractDiscPhaseVar.quantil(double)}{\membername{quantil}}
{\tt public double\ {\bf quantil}( {\tt double} {\bf p} )
\label{jphase.AbstractDiscPhaseVar.quantil(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.quantil(double)}{PhaseVar.quantil(double)}} {\small 
\refdefined{jphase.PhaseVar.quantil(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{stdDeviation}
\item{\vskip -1.9ex 
\index{stdDeviation()}
\hypertarget{jphase.AbstractDiscPhaseVar.stdDeviation()}{\membername{stdDeviation}}
{\tt public double\ {\bf stdDeviation}(  )
\label{jphase.AbstractDiscPhaseVar.stdDeviation()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.stdDeviation()}{PhaseVar.stdDeviation()}} {\small 
\refdefined{jphase.PhaseVar.stdDeviation()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sum}
\item{\vskip -1.9ex 
\index{sum(DiscPhaseVar)}
\hypertarget{jphase.AbstractDiscPhaseVar.sum(jphase.DiscPhaseVar)}{\membername{sum}}
{\tt public DiscPhaseVar\ {\bf sum}( {\tt DiscPhaseVar} {\bf v2} )
\label{jphase.AbstractDiscPhaseVar.sum(jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.sum(jphase.DiscPhaseVar)}{DiscPhaseVar.sum(DiscPhaseVar)}} {\small 
\refdefined{jphase.DiscPhaseVar.sum(jphase.DiscPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sum}
\item{\vskip -1.9ex 
\index{sum(DiscPhaseVar, DiscPhaseVar)}
\hypertarget{jphase.AbstractDiscPhaseVar.sum(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{\membername{sum}}
{\tt public DiscPhaseVar\ {\bf sum}( {\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
\label{jphase.AbstractDiscPhaseVar.sum(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.sum(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{DiscPhaseVar.sum(DiscPhaseVar,\allowbreak DiscPhaseVar)}} {\small 
\refdefined{jphase.DiscPhaseVar.sum(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sumGeom}
\item{\vskip -1.9ex 
\index{sumGeom(double)}
\hypertarget{jphase.AbstractDiscPhaseVar.sumGeom(double)}{\membername{sumGeom}}
{\tt public DiscPhaseVar\ {\bf sumGeom}( {\tt double} {\bf p} )
\label{jphase.AbstractDiscPhaseVar.sumGeom(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.sumGeom(double)}{DiscPhaseVar.sumGeom(double)}} {\small 
\refdefined{jphase.DiscPhaseVar.sumGeom(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sumPH}
\item{\vskip -1.9ex 
\index{sumPH(DiscPhaseVar)}
\hypertarget{jphase.AbstractDiscPhaseVar.sumPH(jphase.DiscPhaseVar)}{\membername{sumPH}}
{\tt public DiscPhaseVar\ {\bf sumPH}( {\tt DiscPhaseVar} {\bf v2} )
\label{jphase.AbstractDiscPhaseVar.sumPH(jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.sumPH(jphase.DiscPhaseVar)}{DiscPhaseVar.sumPH(DiscPhaseVar)}} {\small 
\refdefined{jphase.DiscPhaseVar.sumPH(jphase.DiscPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{sumPH}
\item{\vskip -1.9ex 
\index{sumPH(DiscPhaseVar, DiscPhaseVar)}
\hypertarget{jphase.AbstractDiscPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{\membername{sumPH}}
{\tt public DiscPhaseVar\ {\bf sumPH}( {\tt DiscPhaseVar} {\bf B},
{\tt DiscPhaseVar} {\bf res} )
\label{jphase.AbstractDiscPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}{DiscPhaseVar.sumPH(DiscPhaseVar,\allowbreak DiscPhaseVar)}} {\small 
\refdefined{jphase.DiscPhaseVar.sumPH(jphase.DiscPhaseVar, jphase.DiscPhaseVar)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{survival}
\item{\vskip -1.9ex 
\index{survival(double)}
\hypertarget{jphase.AbstractDiscPhaseVar.survival(double)}{\membername{survival}}
{\tt public double\ {\bf survival}( {\tt double} {\bf x} )
\label{jphase.AbstractDiscPhaseVar.survival(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.survival(double)}{PhaseVar.survival(double)}} {\small 
\refdefined{jphase.PhaseVar.survival(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{survival}
\item{\vskip -1.9ex 
\index{survival(int, double)}
\hypertarget{jphase.AbstractDiscPhaseVar.survival(int, double)}{\membername{survival}}
{\tt public double\lbrack \rbrack \ {\bf survival}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
\label{jphase.AbstractDiscPhaseVar.survival(int, double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.survival(int, double)}{PhaseVar.survival(int,\allowbreak double)}} {\small 
\refdefined{jphase.PhaseVar.survival(int, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jphase.AbstractDiscPhaseVar.toString()}{\membername{toString}}
{\tt public final java.lang.String\ {\bf toString}(  )
\label{jphase.AbstractDiscPhaseVar.toString()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.DiscPhaseVar.toString()}{DiscPhaseVar.toString()}} {\small 
\refdefined{jphase.DiscPhaseVar.toString()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{variance}
\item{\vskip -1.9ex 
\index{variance()}
\hypertarget{jphase.AbstractDiscPhaseVar.variance()}{\membername{variance}}
{\tt public double\ {\bf variance}(  )
\label{jphase.AbstractDiscPhaseVar.variance()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.variance()}{PhaseVar.variance()}} {\small 
\refdefined{jphase.PhaseVar.variance()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{DenseContPhaseVar}
\subsection{\label{jphase.DenseContPhaseVar}\index{DenseContPhaseVar}{\bf {\it Class} DenseContPhaseVar}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.DenseContPhaseVar}{}\vskip .1in 
This class allows the creation and manipulation of Continuous Phase-type distributions represented by dense matrices.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class DenseContPhaseVar
\\ {\bf extends} jphase.AbstractContPhaseVar
\refdefined{jphase.AbstractContPhaseVar}}}}
\subsubsection{Version}{0.1 This class allows the creation and manipulation of Continuous Phase-type distributions represented by dense matrices.}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.DenseContPhaseVar.A}{{\bf A}} Rate Matrix\\
\hyperlink{jphase.DenseContPhaseVar.alpha}{{\bf alpha}} Initial Probability distribution vector\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.DenseContPhaseVar()}{{\bf DenseContPhaseVar()}} Constructs an empty continuous Phase-type Distribution with dense representation\\
\hyperlink{jphase.DenseContPhaseVar(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseMatrix)}{{\bf DenseContPhaseVar(DenseVector, DenseMatrix)}} Constructs a continuous Phase-type Distribution with dense representation\\
\hyperlink{jphase.DenseContPhaseVar(double[], double[][])}{{\bf DenseContPhaseVar(double\lbrack \rbrack , double\lbrack \rbrack \lbrack \rbrack )}} Construcs a continuous Phase-type Distribution with dense representation\\
\hyperlink{jphase.DenseContPhaseVar(int)}{{\bf DenseContPhaseVar(int)}} Constructs an empty Continuous Phase-type Distribution of size n with dense representation\\
\hyperlink{jphase.DenseContPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{{\bf DenseContPhaseVar(Vector, Matrix)}} Constructs a continuous Phase-type Distribution with dense representation\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.DenseContPhaseVar.copy()}{{\bf copy()}} \\
\hyperlink{jphase.DenseContPhaseVar.Coxian(int, double[], double[])}{{\bf Coxian(int, double\lbrack \rbrack , double\lbrack \rbrack )}} Construcs a Phase-Type representation of a Coxian distribution with n phases\\
\hyperlink{jphase.DenseContPhaseVar.Erlang(double, int)}{{\bf Erlang(double, int)}} Constructs a Phase-Type representation of an Erlang distribution with rate lambda and n exponential phases\\
\hyperlink{jphase.DenseContPhaseVar.ErlangCoxian(int, double, double, double, double, double)}{{\bf ErlangCoxian(int, double, double, double, double, double)}} Construcs a Phase-Type representation of an ErlangCoxian distribution as defined by Osogami and Harchol in "Closed form solutions for mapping general distributions to quasi-minimal PH distributions", 2005.\\
\hyperlink{jphase.DenseContPhaseVar.expo(double)}{{\bf expo(double)}} Constructs a Phase-Type representation of an Exponential distribution with rate lambda\\
\hyperlink{jphase.DenseContPhaseVar.getMatrix()}{{\bf getMatrix()}} \\
\hyperlink{jphase.DenseContPhaseVar.getVector()}{{\bf getVector()}} \\
\hyperlink{jphase.DenseContPhaseVar.HyperErlang(jphase.HyperErlangVar)}{{\bf HyperErlang(HyperErlangVar)}} Construcs a Phase-Type representation of a Hyper-Erlang distribution from a Dense representation of the same distribution\\
\hyperlink{jphase.DenseContPhaseVar.HyperErlang(int, double[], int[], double[])}{{\bf HyperErlang(int, double\lbrack \rbrack , int\lbrack \rbrack , double\lbrack \rbrack )}} Constructs a Phase-Type representation of a Hyper-Erlang distribution with k erlang branches, its k rates and n number of phases per branch\\
\hyperlink{jphase.DenseContPhaseVar.HyperExpo(double[], double[])}{{\bf HyperExpo(double\lbrack \rbrack , double\lbrack \rbrack )}} Constructs a Phase Distribution that represents a HyperExponential distribution with the especified parameters\\
\hyperlink{jphase.DenseContPhaseVar.newVar(int)}{{\bf newVar(int)}} \\
\hyperlink{jphase.DenseContPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{{\bf setMatrix(Matrix)}} \\
\hyperlink{jphase.DenseContPhaseVar.setVector(no.uib.cipr.matrix.Vector)}{{\bf setVector(Vector)}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{A}
\label{jphase.DenseContPhaseVar.A}\hypertarget{jphase.DenseContPhaseVar.A}{protected no.uib.cipr.matrix.DenseMatrix {\bf A}}
\begin{itemize}
\item{\vskip -.9ex 
Rate Matrix}
\end{itemize}
}
\item{
\index{alpha}
\label{jphase.DenseContPhaseVar.alpha}\hypertarget{jphase.DenseContPhaseVar.alpha}{protected no.uib.cipr.matrix.DenseVector {\bf alpha}}
\begin{itemize}
\item{\vskip -.9ex 
Initial Probability distribution vector}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{DenseContPhaseVar()}
\hypertarget{jphase.DenseContPhaseVar()}{\membername{DenseContPhaseVar}}
{\tt public\ {\bf DenseContPhaseVar}(  )
\label{jphase.DenseContPhaseVar()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs an empty continuous Phase-type Distribution with dense representation
}
\end{itemize}
}%end item
\divideents{DenseContPhaseVar}
\item{\vskip -1.9ex 
\index{DenseContPhaseVar(DenseVector, DenseMatrix)}
\hypertarget{jphase.DenseContPhaseVar(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseMatrix)}{\membername{DenseContPhaseVar}}
{\tt public\ {\bf DenseContPhaseVar}( {\tt no.uib.cipr.matrix.DenseVector} {\bf alpha},
{\tt no.uib.cipr.matrix.DenseMatrix} {\bf A} )
\label{jphase.DenseContPhaseVar(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseMatrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs a continuous Phase-type Distribution with dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- rate matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{DenseContPhaseVar}
\item{\vskip -1.9ex 
\index{DenseContPhaseVar(double\lbrack \rbrack , double\lbrack \rbrack \lbrack \rbrack )}
\hypertarget{jphase.DenseContPhaseVar(double[], double[][])}{\membername{DenseContPhaseVar}}
{\tt public\ {\bf DenseContPhaseVar}( {\tt double\lbrack \rbrack } {\bf alpha},
{\tt double\lbrack \rbrack \lbrack \rbrack } {\bf A} )
\label{jphase.DenseContPhaseVar(double[], double[][])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs a continuous Phase-type Distribution with dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- rate matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{DenseContPhaseVar}
\item{\vskip -1.9ex 
\index{DenseContPhaseVar(int)}
\hypertarget{jphase.DenseContPhaseVar(int)}{\membername{DenseContPhaseVar}}
{\tt public\ {\bf DenseContPhaseVar}( {\tt int} {\bf n} )
\label{jphase.DenseContPhaseVar(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs an empty Continuous Phase-type Distribution of size n with dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- size of the Continuous Phase-type Distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{DenseContPhaseVar}
\item{\vskip -1.9ex 
\index{DenseContPhaseVar(Vector, Matrix)}
\hypertarget{jphase.DenseContPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{\membername{DenseContPhaseVar}}
{\tt public\ {\bf DenseContPhaseVar}( {\tt no.uib.cipr.matrix.Vector} {\bf alpha},
{\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.DenseContPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs a continuous Phase-type Distribution with dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- rate matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{copy()}
\hypertarget{jphase.DenseContPhaseVar.copy()}{\membername{copy}}
{\tt public ContPhaseVar\ {\bf copy}(  )
\label{jphase.DenseContPhaseVar.copy()}}%end signature
}%end item
\divideents{Coxian}
\item{\vskip -1.9ex 
\index{Coxian(int, double\lbrack \rbrack , double\lbrack \rbrack )}
\hypertarget{jphase.DenseContPhaseVar.Coxian(int, double[], double[])}{\membername{Coxian}}
{\tt public static DenseContPhaseVar\ {\bf Coxian}( {\tt int} {\bf n},
{\tt double\lbrack \rbrack } {\bf lambdas},
{\tt double\lbrack \rbrack } {\bf probs} )
\label{jphase.DenseContPhaseVar.Coxian(int, double[], double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs a Phase-Type representation of a Coxian distribution with n phases
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- number of phases}
   \item{
\sld
{\tt lambdas} -- exponential rates of each phase}
   \item{
\sld
{\tt probs} -- probability of going to the next phase (no absorption) in each phase except the last one.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Dense Continuous Phase-Type Distribution 
}%end item
\end{itemize}
}%end item
\divideents{Erlang}
\item{\vskip -1.9ex 
\index{Erlang(double, int)}
\hypertarget{jphase.DenseContPhaseVar.Erlang(double, int)}{\membername{Erlang}}
{\tt public static DenseContPhaseVar\ {\bf Erlang}( {\tt double} {\bf lambda},
{\tt int} {\bf n} )
\label{jphase.DenseContPhaseVar.Erlang(double, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs a Phase-Type representation of an Erlang distribution with rate lambda and n exponential phases
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lambda} -- exponential rate in each phase}
   \item{
\sld
{\tt n} -- number of exponential phases}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Dense Continuous Phase-Type Distribution 
}%end item
\end{itemize}
}%end item
\divideents{ErlangCoxian}
\item{\vskip -1.9ex 
\index{ErlangCoxian(int, double, double, double, double, double)}
\hypertarget{jphase.DenseContPhaseVar.ErlangCoxian(int, double, double, double, double, double)}{\membername{ErlangCoxian}}
{\tt public static DenseContPhaseVar\ {\bf ErlangCoxian}( {\tt int} {\bf n},
{\tt double} {\bf p},
{\tt double} {\bf lambdaY},
{\tt double} {\bf lambdaX1},
{\tt double} {\bf lambdaX2},
{\tt double} {\bf px} )
\label{jphase.DenseContPhaseVar.ErlangCoxian(int, double, double, double, double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs a Phase-Type representation of an ErlangCoxian distribution as defined by Osogami and Harchol in "Closed form solutions for mapping general distributions to quasi-minimal PH distributions", 2005.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- total number of phases (Erlang degree: n-2)}
   \item{
\sld
{\tt p} -- probability of having a positive elapse time in the distribution. 1-p: mass probability at zero}
   \item{
\sld
{\tt lambdaY} -- rate of the Erlang distribution}
   \item{
\sld
{\tt lambdaX1} -- rate of the first stage of the Coxian distribution}
   \item{
\sld
{\tt lambdaX2} -- rate of the second stage of the Coxian distribution}
   \item{
\sld
{\tt px} -- probability of going from the first to the second stage in the Coxian distribution. 1-p: probability of absorption at the first stage of the Coxian distribution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Dense Continuous Phase-Type Distribution 
}%end item
\end{itemize}
}%end item
\divideents{expo}
\item{\vskip -1.9ex 
\index{expo(double)}
\hypertarget{jphase.DenseContPhaseVar.expo(double)}{\membername{expo}}
{\tt public static DenseContPhaseVar\ {\bf expo}( {\tt double} {\bf lambda} )
\label{jphase.DenseContPhaseVar.expo(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs a Phase-Type representation of an Exponential distribution with rate lambda
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lambda} -- exponential distribution rate}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Dense Continuous Phase-Type Distribution 
}%end item
\end{itemize}
}%end item
\divideents{getMatrix}
\item{\vskip -1.9ex 
\index{getMatrix()}
\hypertarget{jphase.DenseContPhaseVar.getMatrix()}{\membername{getMatrix}}
{\tt public no.uib.cipr.matrix.Matrix\ {\bf getMatrix}(  )
\label{jphase.DenseContPhaseVar.getMatrix()}}%end signature
}%end item
\divideents{getVector}
\item{\vskip -1.9ex 
\index{getVector()}
\hypertarget{jphase.DenseContPhaseVar.getVector()}{\membername{getVector}}
{\tt public no.uib.cipr.matrix.Vector\ {\bf getVector}(  )
\label{jphase.DenseContPhaseVar.getVector()}}%end signature
}%end item
\divideents{HyperErlang}
\item{\vskip -1.9ex 
\index{HyperErlang(HyperErlangVar)}
\hypertarget{jphase.DenseContPhaseVar.HyperErlang(jphase.HyperErlangVar)}{\membername{HyperErlang}}
{\tt public static DenseContPhaseVar\ {\bf HyperErlang}( {\tt HyperErlangVar} {\bf var} )
\label{jphase.DenseContPhaseVar.HyperErlang(jphase.HyperErlangVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs a Phase-Type representation of a Hyper-Erlang distribution from a Dense representation of the same distribution
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt var} -- HyperErlang variable from which the Dense Continuous variable must be constructed}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Dense Continuous Phase-Type Distribution 
}%end item
\end{itemize}
}%end item
\divideents{HyperErlang}
\item{\vskip -1.9ex 
\index{HyperErlang(int, double\lbrack \rbrack , int\lbrack \rbrack , double\lbrack \rbrack )}
\hypertarget{jphase.DenseContPhaseVar.HyperErlang(int, double[], int[], double[])}{\membername{HyperErlang}}
{\tt public static DenseContPhaseVar\ {\bf HyperErlang}( {\tt int} {\bf k},
{\tt double\lbrack \rbrack } {\bf lambdas},
{\tt int\lbrack \rbrack } {\bf n},
{\tt double\lbrack \rbrack } {\bf probs} )
\label{jphase.DenseContPhaseVar.HyperErlang(int, double[], int[], double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs a Phase-Type representation of a Hyper-Erlang distribution with k erlang branches, its k rates and n number of phases per branch
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt k} -- number of Erlang branches}
   \item{
\sld
{\tt lambdas} -- exponential rate of each phase in each branch}
   \item{
\sld
{\tt n} -- number of exponential phases in each branch}
   \item{
\sld
{\tt probs} -- probability distribution of taking each one of the branches}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Dense Continuous Phase-Type Distribution 
}%end item
\end{itemize}
}%end item
\divideents{HyperExpo}
\item{\vskip -1.9ex 
\index{HyperExpo(double\lbrack \rbrack , double\lbrack \rbrack )}
\hypertarget{jphase.DenseContPhaseVar.HyperExpo(double[], double[])}{\membername{HyperExpo}}
{\tt public static DenseContPhaseVar\ {\bf HyperExpo}( {\tt double\lbrack \rbrack } {\bf lambdas},
{\tt double\lbrack \rbrack } {\bf probs} )
\label{jphase.DenseContPhaseVar.HyperExpo(double[], double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs a Phase Distribution that represents a HyperExponential distribution with the especified parameters
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lambdas} -- ecah one of the exponential rates}
   \item{
\sld
{\tt probs} -- initial probability vector}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Dense Continuous Phase-Type Distribution 
}%end item
\end{itemize}
}%end item
\divideents{newVar}
\item{\vskip -1.9ex 
\index{newVar(int)}
\hypertarget{jphase.DenseContPhaseVar.newVar(int)}{\membername{newVar}}
{\tt public ContPhaseVar\ {\bf newVar}( {\tt int} {\bf n} )
\label{jphase.DenseContPhaseVar.newVar(int)}}%end signature
}%end item
\divideents{setMatrix}
\item{\vskip -1.9ex 
\index{setMatrix(Matrix)}
\hypertarget{jphase.DenseContPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{\membername{setMatrix}}
{\tt public void\ {\bf setMatrix}( {\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.DenseContPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}}%end signature
}%end item
\divideents{setVector}
\item{\vskip -1.9ex 
\index{setVector(Vector)}
\hypertarget{jphase.DenseContPhaseVar.setVector(no.uib.cipr.matrix.Vector)}{\membername{setVector}}
{\tt public void\ {\bf setVector}( {\tt no.uib.cipr.matrix.Vector} {\bf alpha} )
\label{jphase.DenseContPhaseVar.setVector(no.uib.cipr.matrix.Vector)}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.AbstractContPhaseVar} \textnormal{\small\refdefined{jphase.AbstractContPhaseVar}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf CV}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf eqResidualTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf expectedValue}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Vector {\bf getMat0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMat0Array}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMatrixArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getNumPhases}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVec0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVectorArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction1}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction2}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf max}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf max}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf median}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf min}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf min}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf moment}( {\tt int} {\bf k} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pdf}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf prob}( {\tt double} {\bf a},
{\tt double} {\bf b} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf quantil}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf residualTime}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf residualVar}( {\tt double} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf stdDeviation}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sum}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sum}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumGeom}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf B},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf times}( {\tt double} {\bf c} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf variance}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf waitingQ}( {\tt double} {\bf rho} )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{DenseDiscPhaseVar}
\subsection{\label{jphase.DenseDiscPhaseVar}\index{DenseDiscPhaseVar}{\bf {\it Class} DenseDiscPhaseVar}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.DenseDiscPhaseVar}{}\vskip .1in 
This class allows the creation and manipulation of Discrete Phase-type distributions represented by dense matrices.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class DenseDiscPhaseVar
\\ {\bf extends} jphase.AbstractDiscPhaseVar
\refdefined{jphase.AbstractDiscPhaseVar}\\ {\bf implements} 
DiscPhaseVar}}}
\subsubsection{Version}{0.1 This class allows the creation and manipulation of Discrete Phase-type distributions represented by dense matrices.}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.DenseDiscPhaseVar.A}{{\bf A}} Probability Transition Matrix\\
\hyperlink{jphase.DenseDiscPhaseVar.alpha}{{\bf alpha}} Initial Probability distribution vector\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.DenseDiscPhaseVar()}{{\bf DenseDiscPhaseVar()}} Constructs an empty Discrete Phase-type Distribution with dense representation\\
\hyperlink{jphase.DenseDiscPhaseVar(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseMatrix)}{{\bf DenseDiscPhaseVar(DenseVector, DenseMatrix)}} Constructs a Discrete Phase-type Distribution with dense representation\\
\hyperlink{jphase.DenseDiscPhaseVar(double[], double[][])}{{\bf DenseDiscPhaseVar(double\lbrack \rbrack , double\lbrack \rbrack \lbrack \rbrack )}} Constructs a Discrete Phase-type Distribution with dense representation\\
\hyperlink{jphase.DenseDiscPhaseVar(int)}{{\bf DenseDiscPhaseVar(int)}} Constructs an empty Discrete Phase-type Distribution of size n with dense representation\\
\hyperlink{jphase.DenseDiscPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{{\bf DenseDiscPhaseVar(Vector, Matrix)}} Constructs a Discrete Phase-type Distribution with dense representation\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.DenseDiscPhaseVar.copy()}{{\bf copy()}} \\
\hyperlink{jphase.DenseDiscPhaseVar.Geom(double)}{{\bf Geom(double)}} Discrete Phase distribution that represents a geometric distribution with probability of success p\\
\hyperlink{jphase.DenseDiscPhaseVar.getMatrix()}{{\bf getMatrix()}} \\
\hyperlink{jphase.DenseDiscPhaseVar.getVector()}{{\bf getVector()}} \\
\hyperlink{jphase.DenseDiscPhaseVar.NegativeBinomial(double, int)}{{\bf NegativeBinomial(double, int)}} Discrete Phase Distribution thata represents a Negative Binomial distribution with parameters p and r\\
\hyperlink{jphase.DenseDiscPhaseVar.newVar(int)}{{\bf newVar(int)}} \\
\hyperlink{jphase.DenseDiscPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{{\bf setMatrix(Matrix)}} \\
\hyperlink{jphase.DenseDiscPhaseVar.setVector(no.uib.cipr.matrix.Vector)}{{\bf setVector(Vector)}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{A}
\label{jphase.DenseDiscPhaseVar.A}\hypertarget{jphase.DenseDiscPhaseVar.A}{protected no.uib.cipr.matrix.DenseMatrix {\bf A}}
\begin{itemize}
\item{\vskip -.9ex 
Probability Transition Matrix}
\end{itemize}
}
\item{
\index{alpha}
\label{jphase.DenseDiscPhaseVar.alpha}\hypertarget{jphase.DenseDiscPhaseVar.alpha}{protected no.uib.cipr.matrix.DenseVector {\bf alpha}}
\begin{itemize}
\item{\vskip -.9ex 
Initial Probability distribution vector}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{DenseDiscPhaseVar()}
\hypertarget{jphase.DenseDiscPhaseVar()}{\membername{DenseDiscPhaseVar}}
{\tt public\ {\bf DenseDiscPhaseVar}(  )
\label{jphase.DenseDiscPhaseVar()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs an empty Discrete Phase-type Distribution with dense representation
}
\end{itemize}
}%end item
\divideents{DenseDiscPhaseVar}
\item{\vskip -1.9ex 
\index{DenseDiscPhaseVar(DenseVector, DenseMatrix)}
\hypertarget{jphase.DenseDiscPhaseVar(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseMatrix)}{\membername{DenseDiscPhaseVar}}
{\tt public\ {\bf DenseDiscPhaseVar}( {\tt no.uib.cipr.matrix.DenseVector} {\bf alpha},
{\tt no.uib.cipr.matrix.DenseMatrix} {\bf A} )
\label{jphase.DenseDiscPhaseVar(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseMatrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs a Discrete Phase-type Distribution with dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- transition probability matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{DenseDiscPhaseVar}
\item{\vskip -1.9ex 
\index{DenseDiscPhaseVar(double\lbrack \rbrack , double\lbrack \rbrack \lbrack \rbrack )}
\hypertarget{jphase.DenseDiscPhaseVar(double[], double[][])}{\membername{DenseDiscPhaseVar}}
{\tt public\ {\bf DenseDiscPhaseVar}( {\tt double\lbrack \rbrack } {\bf alpha},
{\tt double\lbrack \rbrack \lbrack \rbrack } {\bf A} )
\label{jphase.DenseDiscPhaseVar(double[], double[][])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs a Discrete Phase-type Distribution with dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- transition probability matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{DenseDiscPhaseVar}
\item{\vskip -1.9ex 
\index{DenseDiscPhaseVar(int)}
\hypertarget{jphase.DenseDiscPhaseVar(int)}{\membername{DenseDiscPhaseVar}}
{\tt public\ {\bf DenseDiscPhaseVar}( {\tt int} {\bf n} )
\label{jphase.DenseDiscPhaseVar(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs an empty Discrete Phase-type Distribution of size n with dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- size of the Discrete Phase-type Distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{DenseDiscPhaseVar}
\item{\vskip -1.9ex 
\index{DenseDiscPhaseVar(Vector, Matrix)}
\hypertarget{jphase.DenseDiscPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{\membername{DenseDiscPhaseVar}}
{\tt public\ {\bf DenseDiscPhaseVar}( {\tt no.uib.cipr.matrix.Vector} {\bf alpha},
{\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.DenseDiscPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructs a Discrete Phase-type Distribution with dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- transition probability matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{copy()}
\hypertarget{jphase.DenseDiscPhaseVar.copy()}{\membername{copy}}
{\tt public DiscPhaseVar\ {\bf copy}(  )
\label{jphase.DenseDiscPhaseVar.copy()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.copy()}{ContPhaseVar.copy()}} {\small 
\refdefined{jphase.ContPhaseVar.copy()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{Geom}
\item{\vskip -1.9ex 
\index{Geom(double)}
\hypertarget{jphase.DenseDiscPhaseVar.Geom(double)}{\membername{Geom}}
{\tt public static DenseDiscPhaseVar\ {\bf Geom}( {\tt double} {\bf p} )
\label{jphase.DenseDiscPhaseVar.Geom(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Discrete Phase distribution that represents a geometric distribution with probability of success p
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt p} -- probability of succes}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Dense Discrete Phase-Type Distribution 
}%end item
\end{itemize}
}%end item
\divideents{getMatrix}
\item{\vskip -1.9ex 
\index{getMatrix()}
\hypertarget{jphase.DenseDiscPhaseVar.getMatrix()}{\membername{getMatrix}}
{\tt public no.uib.cipr.matrix.Matrix\ {\bf getMatrix}(  )
\label{jphase.DenseDiscPhaseVar.getMatrix()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getMatrix()}{PhaseVar.getMatrix()}} {\small 
\refdefined{jphase.PhaseVar.getMatrix()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getVector}
\item{\vskip -1.9ex 
\index{getVector()}
\hypertarget{jphase.DenseDiscPhaseVar.getVector()}{\membername{getVector}}
{\tt public no.uib.cipr.matrix.Vector\ {\bf getVector}(  )
\label{jphase.DenseDiscPhaseVar.getVector()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getVector()}{PhaseVar.getVector()}} {\small 
\refdefined{jphase.PhaseVar.getVector()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{NegativeBinomial}
\item{\vskip -1.9ex 
\index{NegativeBinomial(double, int)}
\hypertarget{jphase.DenseDiscPhaseVar.NegativeBinomial(double, int)}{\membername{NegativeBinomial}}
{\tt public static DenseDiscPhaseVar\ {\bf NegativeBinomial}( {\tt double} {\bf p},
{\tt int} {\bf r} )
\label{jphase.DenseDiscPhaseVar.NegativeBinomial(double, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Discrete Phase Distribution thata represents a Negative Binomial distribution with parameters p and r
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt p} -- probability of success in one trial}
   \item{
\sld
{\tt r} -- number of successes until absorption}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Dense Discrete Phase-Type distribution 
}%end item
\end{itemize}
}%end item
\divideents{newVar}
\item{\vskip -1.9ex 
\index{newVar(int)}
\hypertarget{jphase.DenseDiscPhaseVar.newVar(int)}{\membername{newVar}}
{\tt  DiscPhaseVar\ {\bf newVar}( {\tt int} {\bf n} )
\label{jphase.DenseDiscPhaseVar.newVar(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.DiscPhaseVar}{DiscPhaseVar}{\small \refdefined{jphase.DiscPhaseVar}} }

Creates a new variable of the same class of the original Discrete Phase-Type Variable
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- number of Phases of the new Variable}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
A new variable of the same class of the original Discrete Phase-Type Variable 
}%end item
\end{itemize}
}%end item
\divideents{setMatrix}
\item{\vskip -1.9ex 
\index{setMatrix(Matrix)}
\hypertarget{jphase.DenseDiscPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{\membername{setMatrix}}
{\tt public void\ {\bf setMatrix}( {\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.DenseDiscPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{PhaseVar.setMatrix(Matrix)}} {\small 
\refdefined{jphase.PhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setVector}
\item{\vskip -1.9ex 
\index{setVector(Vector)}
\hypertarget{jphase.DenseDiscPhaseVar.setVector(no.uib.cipr.matrix.Vector)}{\membername{setVector}}
{\tt public void\ {\bf setVector}( {\tt no.uib.cipr.matrix.Vector} {\bf alpha} )
\label{jphase.DenseDiscPhaseVar.setVector(no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.setVector(no.uib.cipr.matrix.Vector)}{PhaseVar.setVector(Vector)}} {\small 
\refdefined{jphase.PhaseVar.setVector(no.uib.cipr.matrix.Vector)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.AbstractDiscPhaseVar} \textnormal{\small\refdefined{jphase.AbstractDiscPhaseVar}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf CV}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf expectedValue}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Vector {\bf getMat0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMat0Array}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMatrixArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getNumPhases}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVec0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVectorArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction1}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction2}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf max}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf max}( {\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf median}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf min}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf min}( {\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf moment}( {\tt int} {\bf k} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pmf}( {\tt int} {\bf k} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pmf}( {\tt int} {\bf n},
{\tt int} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf prob}( {\tt double} {\bf a},
{\tt double} {\bf b} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf quantil}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf stdDeviation}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf sum}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf sum}( {\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf sumGeom}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf B},
{\tt DiscPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf variance}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{ErlangCoxianVar}
\subsection{\label{jphase.ErlangCoxianVar}\index{ErlangCoxianVar}{\bf {\it Class} ErlangCoxianVar}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.ErlangCoxianVar}{}\vskip .1in 
Phase-Type representation of an ErlangCoxian distribution as defined by Osogami and Harchol in "Closed form solutions for mapping general distributions to quasi-minimal PH distributions", 2005.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class ErlangCoxianVar
\\ {\bf extends} jphase.AbstractContPhaseVar
\refdefined{jphase.AbstractContPhaseVar}\\ {\bf implements} 
PhaseVar}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.ErlangCoxianVar()}{{\bf ErlangCoxianVar()}} Constructor of an Erlang Coxian variable in dense representation.\\
\hyperlink{jphase.ErlangCoxianVar(int)}{{\bf ErlangCoxianVar(int)}} Constructor of a ErlangCoxian variable in dense representation\\
\hyperlink{jphase.ErlangCoxianVar(int, double, double, double, double, double)}{{\bf ErlangCoxianVar(int, double, double, double, double, double)}} Constructor of a ErlangCoxian variable in dense representation\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.ErlangCoxianVar.convoExpo(double)}{{\bf convoExpo(double)}} Creates a Dense Continuous Phase Variable that represents the convolution of the original ErlangCoxian distribution and an exponential phase with rate lambda\\
\hyperlink{jphase.ErlangCoxianVar.copy()}{{\bf copy()}} \\
\hyperlink{jphase.ErlangCoxianVar.description()}{{\bf description()}} \\
\hyperlink{jphase.ErlangCoxianVar.getLambdaX1()}{{\bf getLambdaX1()}} \\
\hyperlink{jphase.ErlangCoxianVar.getLambdaX2()}{{\bf getLambdaX2()}} \\
\hyperlink{jphase.ErlangCoxianVar.getLambdaY()}{{\bf getLambdaY()}} \\
\hyperlink{jphase.ErlangCoxianVar.getMatrix()}{{\bf getMatrix()}} \\
\hyperlink{jphase.ErlangCoxianVar.getN()}{{\bf getN()}} \\
\hyperlink{jphase.ErlangCoxianVar.getP()}{{\bf getP()}} \\
\hyperlink{jphase.ErlangCoxianVar.getPx()}{{\bf getPx()}} \\
\hyperlink{jphase.ErlangCoxianVar.getVector()}{{\bf getVector()}} \\
\hyperlink{jphase.ErlangCoxianVar.mixtureExpo(double, double)}{{\bf mixtureExpo(double, double)}} Creates a Dense Continuous Phase Variable that represents the mixture of the original ErlangCoxian distribution (p) and an exponential phase with rate lambda (1-p)\\
\hyperlink{jphase.ErlangCoxianVar.newVar(int)}{{\bf newVar(int)}} \\
\hyperlink{jphase.ErlangCoxianVar.setLambdaX1(double)}{{\bf setLambdaX1(double)}} \\
\hyperlink{jphase.ErlangCoxianVar.setLambdaX2(double)}{{\bf setLambdaX2(double)}} \\
\hyperlink{jphase.ErlangCoxianVar.setLambdaY(double)}{{\bf setLambdaY(double)}} \\
\hyperlink{jphase.ErlangCoxianVar.setMatrix(no.uib.cipr.matrix.Matrix)}{{\bf setMatrix(Matrix)}} \\
\hyperlink{jphase.ErlangCoxianVar.setN(int)}{{\bf setN(int)}} \\
\hyperlink{jphase.ErlangCoxianVar.setP(double)}{{\bf setP(double)}} \\
\hyperlink{jphase.ErlangCoxianVar.setPx(double)}{{\bf setPx(double)}} \\
\hyperlink{jphase.ErlangCoxianVar.setVector(no.uib.cipr.matrix.Vector)}{{\bf setVector(Vector)}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{ErlangCoxianVar()}
\hypertarget{jphase.ErlangCoxianVar()}{\membername{ErlangCoxianVar}}
{\tt public\ {\bf ErlangCoxianVar}(  )
\label{jphase.ErlangCoxianVar()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructor of an Erlang Coxian variable in dense representation. As default it has just one phase in the Erlang that is taken with probability one. This phase and those of the Coxian distribution has rate 1 per time unit.
}
\end{itemize}
}%end item
\divideents{ErlangCoxianVar}
\item{\vskip -1.9ex 
\index{ErlangCoxianVar(int)}
\hypertarget{jphase.ErlangCoxianVar(int)}{\membername{ErlangCoxianVar}}
{\tt public\ {\bf ErlangCoxianVar}( {\tt int} {\bf n} )
\label{jphase.ErlangCoxianVar(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructor of a ErlangCoxian variable in dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- total number of phases (Erlang degree: n-2) absorption at the first stage of the Coxian distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{ErlangCoxianVar}
\item{\vskip -1.9ex 
\index{ErlangCoxianVar(int, double, double, double, double, double)}
\hypertarget{jphase.ErlangCoxianVar(int, double, double, double, double, double)}{\membername{ErlangCoxianVar}}
{\tt public\ {\bf ErlangCoxianVar}( {\tt int} {\bf n},
{\tt double} {\bf p},
{\tt double} {\bf lambdaY},
{\tt double} {\bf lambdaX1},
{\tt double} {\bf lambdaX2},
{\tt double} {\bf px} )
\label{jphase.ErlangCoxianVar(int, double, double, double, double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructor of a ErlangCoxian variable in dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- total number of phases (Erlang degree: n-2)}
   \item{
\sld
{\tt p} -- probability of having a positive elapse time in the distribution. 1-p: mass probability at zero}
   \item{
\sld
{\tt lambdaY} -- rate of the Erlang distribution}
   \item{
\sld
{\tt lambdaX1} -- rate of the first stage of the Coxian distribution}
   \item{
\sld
{\tt lambdaX2} -- rate of the second stage of the Coxian distribution}
   \item{
\sld
{\tt px} -- probability of going from the first to the second stage in the Coxian distribution. 1-p: probability of absorption at the first stage of the Coxian distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{convoExpo(double)}
\hypertarget{jphase.ErlangCoxianVar.convoExpo(double)}{\membername{convoExpo}}
{\tt public PhaseVar\ {\bf convoExpo}( {\tt double} {\bf lambda} )
\label{jphase.ErlangCoxianVar.convoExpo(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a Dense Continuous Phase Variable that represents the convolution of the original ErlangCoxian distribution and an exponential phase with rate lambda
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lambda} -- rate of the exponential phase to be included in the convolution}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Dense Continuous Phase Variable that represents the convolution of the original ErlangCoxian distribution and an exponential phase with rate lambda 
}%end item
\end{itemize}
}%end item
\divideents{copy}
\item{\vskip -1.9ex 
\index{copy()}
\hypertarget{jphase.ErlangCoxianVar.copy()}{\membername{copy}}
{\tt  PhaseVar\ {\bf copy}(  )
\label{jphase.ErlangCoxianVar.copy()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.PhaseVar}{PhaseVar}{\small \refdefined{jphase.PhaseVar}} }

Creates a deep copy of the original Phase-Type Variable
}
\item{{\bf Returns} -- 
A deep copy of the original Phase-Type Variable 
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jphase.ErlangCoxianVar.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jphase.ErlangCoxianVar.description()}}%end signature
}%end item
\divideents{getLambdaX1}
\item{\vskip -1.9ex 
\index{getLambdaX1()}
\hypertarget{jphase.ErlangCoxianVar.getLambdaX1()}{\membername{getLambdaX1}}
{\tt public double\ {\bf getLambdaX1}(  )
\label{jphase.ErlangCoxianVar.getLambdaX1()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Rate of the first stage at the Coxian distribution 
}%end item
\end{itemize}
}%end item
\divideents{getLambdaX2}
\item{\vskip -1.9ex 
\index{getLambdaX2()}
\hypertarget{jphase.ErlangCoxianVar.getLambdaX2()}{\membername{getLambdaX2}}
{\tt public double\ {\bf getLambdaX2}(  )
\label{jphase.ErlangCoxianVar.getLambdaX2()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Rate of the secons stage at the Coxian distribution 
}%end item
\end{itemize}
}%end item
\divideents{getLambdaY}
\item{\vskip -1.9ex 
\index{getLambdaY()}
\hypertarget{jphase.ErlangCoxianVar.getLambdaY()}{\membername{getLambdaY}}
{\tt public double\ {\bf getLambdaY}(  )
\label{jphase.ErlangCoxianVar.getLambdaY()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Erlang distribution rate 
}%end item
\end{itemize}
}%end item
\divideents{getMatrix}
\item{\vskip -1.9ex 
\index{getMatrix()}
\hypertarget{jphase.ErlangCoxianVar.getMatrix()}{\membername{getMatrix}}
{\tt  no.uib.cipr.matrix.Matrix\ {\bf getMatrix}(  )
\label{jphase.ErlangCoxianVar.getMatrix()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.PhaseVar}{PhaseVar}{\small \refdefined{jphase.PhaseVar}} }

Returns the transition matrix of the Phase-Type Distribution
}
\item{{\bf Returns} -- 
Transition matrix for transient states of the Phase-Type Distribution 
}%end item
\end{itemize}
}%end item
\divideents{getN}
\item{\vskip -1.9ex 
\index{getN()}
\hypertarget{jphase.ErlangCoxianVar.getN()}{\membername{getN}}
{\tt public int\ {\bf getN}(  )
\label{jphase.ErlangCoxianVar.getN()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Total number of phases 
}%end item
\end{itemize}
}%end item
\divideents{getP}
\item{\vskip -1.9ex 
\index{getP()}
\hypertarget{jphase.ErlangCoxianVar.getP()}{\membername{getP}}
{\tt public double\ {\bf getP}(  )
\label{jphase.ErlangCoxianVar.getP()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Probability of having a positive elapse time in the distribution. 1-p: mass probability at zero 
}%end item
\end{itemize}
}%end item
\divideents{getPx}
\item{\vskip -1.9ex 
\index{getPx()}
\hypertarget{jphase.ErlangCoxianVar.getPx()}{\membername{getPx}}
{\tt public double\ {\bf getPx}(  )
\label{jphase.ErlangCoxianVar.getPx()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Probability of going from the first to the second stage in the Coxian distribution. 1-p: probability of absorption at the first stage if the Coxian distribution 
}%end item
\end{itemize}
}%end item
\divideents{getVector}
\item{\vskip -1.9ex 
\index{getVector()}
\hypertarget{jphase.ErlangCoxianVar.getVector()}{\membername{getVector}}
{\tt  no.uib.cipr.matrix.Vector\ {\bf getVector}(  )
\label{jphase.ErlangCoxianVar.getVector()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.PhaseVar}{PhaseVar}{\small \refdefined{jphase.PhaseVar}} }

Returns the initial probability mass vector
}
\item{{\bf Returns} -- 
Initial probability mass vector 
}%end item
\end{itemize}
}%end item
\divideents{mixtureExpo}
\item{\vskip -1.9ex 
\index{mixtureExpo(double, double)}
\hypertarget{jphase.ErlangCoxianVar.mixtureExpo(double, double)}{\membername{mixtureExpo}}
{\tt public PhaseVar\ {\bf mixtureExpo}( {\tt double} {\bf lambda},
{\tt double} {\bf p} )
\label{jphase.ErlangCoxianVar.mixtureExpo(double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a Dense Continuous Phase Variable that represents the mixture of the original ErlangCoxian distribution (p) and an exponential phase with rate lambda (1-p)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lambda} -- rate of the exponential phase to be included in the mixture}
   \item{
\sld
{\tt p} -- probability mass of the ErlangCoxian distribution in the mixture}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Dense Continuous Phase Variable that represents the mixture of the original ErlangCoxian distribution (p) and an exponential phase with rate lambda (1-p) 
}%end item
\end{itemize}
}%end item
\divideents{newVar}
\item{\vskip -1.9ex 
\index{newVar(int)}
\hypertarget{jphase.ErlangCoxianVar.newVar(int)}{\membername{newVar}}
{\tt public ContPhaseVar\ {\bf newVar}( {\tt int} {\bf n} )
\label{jphase.ErlangCoxianVar.newVar(int)}}%end signature
}%end item
\divideents{setLambdaX1}
\item{\vskip -1.9ex 
\index{setLambdaX1(double)}
\hypertarget{jphase.ErlangCoxianVar.setLambdaX1(double)}{\membername{setLambdaX1}}
{\tt public void\ {\bf setLambdaX1}( {\tt double} {\bf lambdaX1} )
\label{jphase.ErlangCoxianVar.setLambdaX1(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lambdaX1} -- Rate of the first stage at the Coxian distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setLambdaX2}
\item{\vskip -1.9ex 
\index{setLambdaX2(double)}
\hypertarget{jphase.ErlangCoxianVar.setLambdaX2(double)}{\membername{setLambdaX2}}
{\tt public void\ {\bf setLambdaX2}( {\tt double} {\bf lambdaX2} )
\label{jphase.ErlangCoxianVar.setLambdaX2(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lambdaX2} -- Rate of the second stage at the Coxian distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setLambdaY}
\item{\vskip -1.9ex 
\index{setLambdaY(double)}
\hypertarget{jphase.ErlangCoxianVar.setLambdaY(double)}{\membername{setLambdaY}}
{\tt public void\ {\bf setLambdaY}( {\tt double} {\bf lambdaY} )
\label{jphase.ErlangCoxianVar.setLambdaY(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lambdaY} -- Erlang distribution rate}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setMatrix}
\item{\vskip -1.9ex 
\index{setMatrix(Matrix)}
\hypertarget{jphase.ErlangCoxianVar.setMatrix(no.uib.cipr.matrix.Matrix)}{\membername{setMatrix}}
{\tt  void\ {\bf setMatrix}( {\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.ErlangCoxianVar.setMatrix(no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.PhaseVar}{PhaseVar}{\small \refdefined{jphase.PhaseVar}} }

Rate Matrix = A
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Transition matrix for transient states of the Phase-Type Distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setN}
\item{\vskip -1.9ex 
\index{setN(int)}
\hypertarget{jphase.ErlangCoxianVar.setN(int)}{\membername{setN}}
{\tt public void\ {\bf setN}( {\tt int} {\bf n} )
\label{jphase.ErlangCoxianVar.setN(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- Total number of phases}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setP}
\item{\vskip -1.9ex 
\index{setP(double)}
\hypertarget{jphase.ErlangCoxianVar.setP(double)}{\membername{setP}}
{\tt public void\ {\bf setP}( {\tt double} {\bf p} )
\label{jphase.ErlangCoxianVar.setP(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt p} -- Probability of having a positive elapse time in the distribution. 1-p: mass probability at zero}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setPx}
\item{\vskip -1.9ex 
\index{setPx(double)}
\hypertarget{jphase.ErlangCoxianVar.setPx(double)}{\membername{setPx}}
{\tt public void\ {\bf setPx}( {\tt double} {\bf px} )
\label{jphase.ErlangCoxianVar.setPx(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt px} -- Probability of going from the first to the second stage in the Coxian distribution. 1-p: probability of absorption at the first stage if the Coxian distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setVector}
\item{\vskip -1.9ex 
\index{setVector(Vector)}
\hypertarget{jphase.ErlangCoxianVar.setVector(no.uib.cipr.matrix.Vector)}{\membername{setVector}}
{\tt  void\ {\bf setVector}( {\tt no.uib.cipr.matrix.Vector} {\bf alpha} )
\label{jphase.ErlangCoxianVar.setVector(no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.PhaseVar}{PhaseVar}{\small \refdefined{jphase.PhaseVar}} }

Initial Probability vector = alpha
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt alpha} -- Initial probability mass vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.AbstractContPhaseVar} \textnormal{\small\refdefined{jphase.AbstractContPhaseVar}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf CV}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf eqResidualTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf expectedValue}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Vector {\bf getMat0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMat0Array}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMatrixArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getNumPhases}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVec0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVectorArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction1}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction2}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf max}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf max}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf median}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf min}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf min}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf moment}( {\tt int} {\bf k} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pdf}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf prob}( {\tt double} {\bf a},
{\tt double} {\bf b} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf quantil}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf residualTime}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf residualVar}( {\tt double} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf stdDeviation}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sum}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sum}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumGeom}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf B},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf times}( {\tt double} {\bf c} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf variance}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf waitingQ}( {\tt double} {\bf rho} )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{HyperErlangVar}
\subsection{\label{jphase.HyperErlangVar}\index{HyperErlangVar}{\bf {\it Class} HyperErlangVar}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.HyperErlangVar}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class HyperErlangVar
\\ {\bf extends} jphase.AbstractContPhaseVar
\refdefined{jphase.AbstractContPhaseVar}\\ {\bf implements} 
PhaseVar}}}
\subsubsection{Version}{0.1 This class allows the creation and manipulation of HyperErlang distributions. The associated matrix has dense representation}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.HyperErlangVar()}{{\bf HyperErlangVar()}} Constructor of a Hyper Erlang variable in dense representation.\\
\hyperlink{jphase.HyperErlangVar(int)}{{\bf HyperErlangVar(int)}} Constructor of a Hyper Erlang variable with n phases in dense representation\\
\hyperlink{jphase.HyperErlangVar(int[], double[], double[], boolean)}{{\bf HyperErlangVar(int\lbrack \rbrack , double\lbrack \rbrack , double\lbrack \rbrack , boolean)}} Constructor of a Hyper Erlang variable in dense representation\\
\hyperlink{jphase.HyperErlangVar(int, int, int[], double[], double[], boolean)}{{\bf HyperErlangVar(int, int, int\lbrack \rbrack , double\lbrack \rbrack , double\lbrack \rbrack , boolean)}} Constructor of a Hyper Erlang variable in dense representation\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.HyperErlangVar.cdf(double)}{{\bf cdf(double)}} \\
\hyperlink{jphase.HyperErlangVar.cdf(int, double)}{{\bf cdf(int, double)}} \\
\hyperlink{jphase.HyperErlangVar.copy()}{{\bf copy()}} \\
\hyperlink{jphase.HyperErlangVar.description()}{{\bf description()}} \\
\hyperlink{jphase.HyperErlangVar.expectedValue()}{{\bf expectedValue()}} \\
\hyperlink{jphase.HyperErlangVar.getAlphas()}{{\bf getAlphas()}} \\
\hyperlink{jphase.HyperErlangVar.getLambdas()}{{\bf getLambdas()}} \\
\hyperlink{jphase.HyperErlangVar.getM()}{{\bf getM()}} \\
\hyperlink{jphase.HyperErlangVar.getMatrix()}{{\bf getMatrix()}} \\
\hyperlink{jphase.HyperErlangVar.getN()}{{\bf getN()}} \\
\hyperlink{jphase.HyperErlangVar.getR()}{{\bf getR()}} \\
\hyperlink{jphase.HyperErlangVar.getVector()}{{\bf getVector()}} \\
\hyperlink{jphase.HyperErlangVar.moment(int)}{{\bf moment(int)}} \\
\hyperlink{jphase.HyperErlangVar.newVar(int)}{{\bf newVar(int)}} \\
\hyperlink{jphase.HyperErlangVar.pdf(double)}{{\bf pdf(double)}} \\
\hyperlink{jphase.HyperErlangVar.pdf(int, double)}{{\bf pdf(int, double)}} \\
\hyperlink{jphase.HyperErlangVar.setAlphas(double[])}{{\bf setAlphas(double\lbrack \rbrack )}} \\
\hyperlink{jphase.HyperErlangVar.setLambdas(double[])}{{\bf setLambdas(double\lbrack \rbrack )}} \\
\hyperlink{jphase.HyperErlangVar.setM(int)}{{\bf setM(int)}} \\
\hyperlink{jphase.HyperErlangVar.setMatrix(no.uib.cipr.matrix.Matrix)}{{\bf setMatrix(Matrix)}} \\
\hyperlink{jphase.HyperErlangVar.setN(int)}{{\bf setN(int)}} \\
\hyperlink{jphase.HyperErlangVar.setR(int[])}{{\bf setR(int\lbrack \rbrack )}} \\
\hyperlink{jphase.HyperErlangVar.setVector(no.uib.cipr.matrix.Vector)}{{\bf setVector(Vector)}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{HyperErlangVar()}
\hypertarget{jphase.HyperErlangVar()}{\membername{HyperErlangVar}}
{\tt public\ {\bf HyperErlangVar}(  )
\label{jphase.HyperErlangVar()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructor of a Hyper Erlang variable in dense representation. As default it has just one branch that is taken with probability one. the unique branch has one phase with rate 1 per time unit.
}
\end{itemize}
}%end item
\divideents{HyperErlangVar}
\item{\vskip -1.9ex 
\index{HyperErlangVar(int)}
\hypertarget{jphase.HyperErlangVar(int)}{\membername{HyperErlangVar}}
{\tt public\ {\bf HyperErlangVar}( {\tt int} {\bf n} )
\label{jphase.HyperErlangVar(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructor of a Hyper Erlang variable with n phases in dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- Total number of phases}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{HyperErlangVar}
\item{\vskip -1.9ex 
\index{HyperErlangVar(int\lbrack \rbrack , double\lbrack \rbrack , double\lbrack \rbrack , boolean)}
\hypertarget{jphase.HyperErlangVar(int[], double[], double[], boolean)}{\membername{HyperErlangVar}}
{\tt public\ {\bf HyperErlangVar}( {\tt int\lbrack \rbrack } {\bf r},
{\tt double\lbrack \rbrack } {\bf alphas},
{\tt double\lbrack \rbrack } {\bf lambdas},
{\tt boolean} {\bf deep} )
\label{jphase.HyperErlangVar(int[], double[], double[], boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructor of a Hyper Erlang variable in dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt r} -- Number of phases in each branch}
   \item{
\sld
{\tt alphas} -- Probability associated to each branch}
   \item{
\sld
{\tt lambdas} -- Rate associated to each branch}
   \item{
\sld
{\tt deep} -- True if this is a deep constructor, false if not}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{HyperErlangVar}
\item{\vskip -1.9ex 
\index{HyperErlangVar(int, int, int\lbrack \rbrack , double\lbrack \rbrack , double\lbrack \rbrack , boolean)}
\hypertarget{jphase.HyperErlangVar(int, int, int[], double[], double[], boolean)}{\membername{HyperErlangVar}}
{\tt public\ {\bf HyperErlangVar}( {\tt int} {\bf N},
{\tt int} {\bf M},
{\tt int\lbrack \rbrack } {\bf r},
{\tt double\lbrack \rbrack } {\bf alphas},
{\tt double\lbrack \rbrack } {\bf lambdas},
{\tt boolean} {\bf deep} )
\label{jphase.HyperErlangVar(int, int, int[], double[], double[], boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Constructor of a Hyper Erlang variable in dense representation
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt N} -- Total number of phases}
   \item{
\sld
{\tt M} -- Number of branches}
   \item{
\sld
{\tt r} -- Number of phases in each branch}
   \item{
\sld
{\tt alphas} -- Probability associated to each branch}
   \item{
\sld
{\tt lambdas} -- Rate associated to each branch}
   \item{
\sld
{\tt deep} -- True if this is a deep constructor, false if not}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{cdf(double)}
\hypertarget{jphase.HyperErlangVar.cdf(double)}{\membername{cdf}}
{\tt public double\ {\bf cdf}( {\tt double} {\bf x} )
\label{jphase.HyperErlangVar.cdf(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.cdf(double)}{PhaseVar.cdf(double)}} {\small 
\refdefined{jphase.PhaseVar.cdf(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{cdf}
\item{\vskip -1.9ex 
\index{cdf(int, double)}
\hypertarget{jphase.HyperErlangVar.cdf(int, double)}{\membername{cdf}}
{\tt public double\lbrack \rbrack \ {\bf cdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
\label{jphase.HyperErlangVar.cdf(int, double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.cdf(int, double)}{PhaseVar.cdf(int,\allowbreak double)}} {\small 
\refdefined{jphase.PhaseVar.cdf(int, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{copy}
\item{\vskip -1.9ex 
\index{copy()}
\hypertarget{jphase.HyperErlangVar.copy()}{\membername{copy}}
{\tt  PhaseVar\ {\bf copy}(  )
\label{jphase.HyperErlangVar.copy()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.PhaseVar}{PhaseVar}{\small \refdefined{jphase.PhaseVar}} }

Creates a deep copy of the original Phase-Type Variable
}
\item{{\bf Returns} -- 
A deep copy of the original Phase-Type Variable 
}%end item
\end{itemize}
}%end item
\divideents{description}
\item{\vskip -1.9ex 
\index{description()}
\hypertarget{jphase.HyperErlangVar.description()}{\membername{description}}
{\tt public java.lang.String\ {\bf description}(  )
\label{jphase.HyperErlangVar.description()}}%end signature
}%end item
\divideents{expectedValue}
\item{\vskip -1.9ex 
\index{expectedValue()}
\hypertarget{jphase.HyperErlangVar.expectedValue()}{\membername{expectedValue}}
{\tt public double\ {\bf expectedValue}(  )
\label{jphase.HyperErlangVar.expectedValue()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.expectedValue()}{PhaseVar.expectedValue()}} {\small 
\refdefined{jphase.PhaseVar.expectedValue()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getAlphas}
\item{\vskip -1.9ex 
\index{getAlphas()}
\hypertarget{jphase.HyperErlangVar.getAlphas()}{\membername{getAlphas}}
{\tt public double\lbrack \rbrack \ {\bf getAlphas}(  )
\label{jphase.HyperErlangVar.getAlphas()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Probability associated to each branch 
}%end item
\end{itemize}
}%end item
\divideents{getLambdas}
\item{\vskip -1.9ex 
\index{getLambdas()}
\hypertarget{jphase.HyperErlangVar.getLambdas()}{\membername{getLambdas}}
{\tt public double\lbrack \rbrack \ {\bf getLambdas}(  )
\label{jphase.HyperErlangVar.getLambdas()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Rate associated to each branch 
}%end item
\end{itemize}
}%end item
\divideents{getM}
\item{\vskip -1.9ex 
\index{getM()}
\hypertarget{jphase.HyperErlangVar.getM()}{\membername{getM}}
{\tt public int\ {\bf getM}(  )
\label{jphase.HyperErlangVar.getM()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Nnumber of branches 
}%end item
\end{itemize}
}%end item
\divideents{getMatrix}
\item{\vskip -1.9ex 
\index{getMatrix()}
\hypertarget{jphase.HyperErlangVar.getMatrix()}{\membername{getMatrix}}
{\tt  no.uib.cipr.matrix.Matrix\ {\bf getMatrix}(  )
\label{jphase.HyperErlangVar.getMatrix()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.PhaseVar}{PhaseVar}{\small \refdefined{jphase.PhaseVar}} }

Returns the transition matrix of the Phase-Type Distribution
}
\item{{\bf Returns} -- 
Transition matrix for transient states of the Phase-Type Distribution 
}%end item
\end{itemize}
}%end item
\divideents{getN}
\item{\vskip -1.9ex 
\index{getN()}
\hypertarget{jphase.HyperErlangVar.getN()}{\membername{getN}}
{\tt public int\ {\bf getN}(  )
\label{jphase.HyperErlangVar.getN()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Total number of phases 
}%end item
\end{itemize}
}%end item
\divideents{getR}
\item{\vskip -1.9ex 
\index{getR()}
\hypertarget{jphase.HyperErlangVar.getR()}{\membername{getR}}
{\tt public int\lbrack \rbrack \ {\bf getR}(  )
\label{jphase.HyperErlangVar.getR()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Number of phases in each branch 
}%end item
\end{itemize}
}%end item
\divideents{getVector}
\item{\vskip -1.9ex 
\index{getVector()}
\hypertarget{jphase.HyperErlangVar.getVector()}{\membername{getVector}}
{\tt  no.uib.cipr.matrix.Vector\ {\bf getVector}(  )
\label{jphase.HyperErlangVar.getVector()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.PhaseVar}{PhaseVar}{\small \refdefined{jphase.PhaseVar}} }

Returns the initial probability mass vector
}
\item{{\bf Returns} -- 
Initial probability mass vector 
}%end item
\end{itemize}
}%end item
\divideents{moment}
\item{\vskip -1.9ex 
\index{moment(int)}
\hypertarget{jphase.HyperErlangVar.moment(int)}{\membername{moment}}
{\tt public double\ {\bf moment}( {\tt int} {\bf k} )
\label{jphase.HyperErlangVar.moment(int)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.moment(int)}{PhaseVar.moment(int)}} {\small 
\refdefined{jphase.PhaseVar.moment(int)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{newVar}
\item{\vskip -1.9ex 
\index{newVar(int)}
\hypertarget{jphase.HyperErlangVar.newVar(int)}{\membername{newVar}}
{\tt public ContPhaseVar\ {\bf newVar}( {\tt int} {\bf n} )
\label{jphase.HyperErlangVar.newVar(int)}}%end signature
}%end item
\divideents{pdf}
\item{\vskip -1.9ex 
\index{pdf(double)}
\hypertarget{jphase.HyperErlangVar.pdf(double)}{\membername{pdf}}
{\tt public double\ {\bf pdf}( {\tt double} {\bf x} )
\label{jphase.HyperErlangVar.pdf(double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.pdf(double)}{ContPhaseVar.pdf(double)}} {\small 
\refdefined{jphase.ContPhaseVar.pdf(double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{pdf}
\item{\vskip -1.9ex 
\index{pdf(int, double)}
\hypertarget{jphase.HyperErlangVar.pdf(int, double)}{\membername{pdf}}
{\tt public double\lbrack \rbrack \ {\bf pdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
\label{jphase.HyperErlangVar.pdf(int, double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.pdf(int, double)}{ContPhaseVar.pdf(int,\allowbreak double)}} {\small 
\refdefined{jphase.ContPhaseVar.pdf(int, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setAlphas}
\item{\vskip -1.9ex 
\index{setAlphas(double\lbrack \rbrack )}
\hypertarget{jphase.HyperErlangVar.setAlphas(double[])}{\membername{setAlphas}}
{\tt public void\ {\bf setAlphas}( {\tt double\lbrack \rbrack } {\bf alphas} )
\label{jphase.HyperErlangVar.setAlphas(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt alphas} -- Probability associated to each branch to set}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setLambdas}
\item{\vskip -1.9ex 
\index{setLambdas(double\lbrack \rbrack )}
\hypertarget{jphase.HyperErlangVar.setLambdas(double[])}{\membername{setLambdas}}
{\tt public void\ {\bf setLambdas}( {\tt double\lbrack \rbrack } {\bf lambdas} )
\label{jphase.HyperErlangVar.setLambdas(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lambdas} -- Rates associated to each branch to set}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setM}
\item{\vskip -1.9ex 
\index{setM(int)}
\hypertarget{jphase.HyperErlangVar.setM(int)}{\membername{setM}}
{\tt public void\ {\bf setM}( {\tt int} {\bf M} )
\label{jphase.HyperErlangVar.setM(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt M} -- Number of branches to set}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setMatrix}
\item{\vskip -1.9ex 
\index{setMatrix(Matrix)}
\hypertarget{jphase.HyperErlangVar.setMatrix(no.uib.cipr.matrix.Matrix)}{\membername{setMatrix}}
{\tt  void\ {\bf setMatrix}( {\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.HyperErlangVar.setMatrix(no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.PhaseVar}{PhaseVar}{\small \refdefined{jphase.PhaseVar}} }

Rate Matrix = A
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Transition matrix for transient states of the Phase-Type Distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setN}
\item{\vskip -1.9ex 
\index{setN(int)}
\hypertarget{jphase.HyperErlangVar.setN(int)}{\membername{setN}}
{\tt public void\ {\bf setN}( {\tt int} {\bf N} )
\label{jphase.HyperErlangVar.setN(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt N} -- Total number of phases to set}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setR}
\item{\vskip -1.9ex 
\index{setR(int\lbrack \rbrack )}
\hypertarget{jphase.HyperErlangVar.setR(int[])}{\membername{setR}}
{\tt public void\ {\bf setR}( {\tt int\lbrack \rbrack } {\bf r} )
\label{jphase.HyperErlangVar.setR(int[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt r} -- Number of phases in each branch to set}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setVector}
\item{\vskip -1.9ex 
\index{setVector(Vector)}
\hypertarget{jphase.HyperErlangVar.setVector(no.uib.cipr.matrix.Vector)}{\membername{setVector}}
{\tt  void\ {\bf setVector}( {\tt no.uib.cipr.matrix.Vector} {\bf alpha} )
\label{jphase.HyperErlangVar.setVector(no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.PhaseVar}{PhaseVar}{\small \refdefined{jphase.PhaseVar}} }

Initial Probability vector = alpha
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt alpha} -- Initial probability mass vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.AbstractContPhaseVar} \textnormal{\small\refdefined{jphase.AbstractContPhaseVar}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf CV}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf eqResidualTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf expectedValue}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Vector {\bf getMat0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMat0Array}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMatrixArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getNumPhases}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVec0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVectorArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction1}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction2}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf max}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf max}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf median}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf min}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf min}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf moment}( {\tt int} {\bf k} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pdf}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf prob}( {\tt double} {\bf a},
{\tt double} {\bf b} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf quantil}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf residualTime}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf residualVar}( {\tt double} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf stdDeviation}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sum}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sum}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumGeom}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf B},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf times}( {\tt double} {\bf c} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf variance}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf waitingQ}( {\tt double} {\bf rho} )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MarkovMatrix}
\subsection{\label{jphase.MarkovMatrix}\index{MarkovMatrix}{\bf {\it Class} MarkovMatrix}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.MarkovMatrix}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class MarkovMatrix
\\ {\bf extends} Jama.Matrix
\refdefined{Jama.Matrix}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.MarkovMatrix.useUniformization}{{\bf useUniformization}} \\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.MarkovMatrix(double[][])}{{\bf MarkovMatrix(double\lbrack \rbrack \lbrack \rbrack )}} \\
\hyperlink{jphase.MarkovMatrix(Jama.Matrix)}{{\bf MarkovMatrix(Matrix)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.MarkovMatrix.compExp()}{{\bf compExp()}} \\
\hyperlink{jphase.MarkovMatrix.compLog()}{{\bf compLog()}} \\
\hyperlink{jphase.MarkovMatrix.concatCols(Jama.Matrix, Jama.Matrix)}{{\bf concatCols(Matrix, Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.concatRows(Jama.Matrix, Jama.Matrix)}{{\bf concatRows(Matrix, Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.exp(double)}{{\bf exp(double)}} \\
\hyperlink{jphase.MarkovMatrix.exp(double, Jama.Matrix, Jama.Matrix)}{{\bf exp(double, Matrix, Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.exp(int, double, Jama.Matrix, Jama.Matrix)}{{\bf exp(int, double, Matrix, Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.expRunge(int, double, Jama.Matrix, Jama.Matrix)}{{\bf expRunge(int, double, Matrix, Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.expTimesOnes(double)}{{\bf expTimesOnes(double)}} \\
\hyperlink{jphase.MarkovMatrix.expTimesOnes(double, Jama.Matrix)}{{\bf expTimesOnes(double, Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.expTimesOnes(int, double, Jama.Matrix)}{{\bf expTimesOnes(int, double, Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.expUnif(double[], Jama.Matrix, Jama.Matrix)}{{\bf expUnif(double\lbrack \rbrack , Matrix, Matrix)}} Computes leftMat * exp(A x) * rightMat, for all values x.\\
\hyperlink{jphase.MarkovMatrix.expUnif(double[], Jama.Matrix, Jama.Matrix, int)}{{\bf expUnif(double\lbrack \rbrack , Matrix, Matrix, int)}} Computes leftMat * exp(A x) * rightMat, for all values x.\\
\hyperlink{jphase.MarkovMatrix.expUnif(double, Jama.Matrix, Jama.Matrix)}{{\bf expUnif(double, Matrix, Matrix)}} Computes leftMat * exp(A x) * rightMat, for the value x.\\
\hyperlink{jphase.MarkovMatrix.expUnif(int, double, Jama.Matrix, Jama.Matrix)}{{\bf expUnif(int, double, Matrix, Matrix)}} Computes leftMat * exp(A x) * rightMat, for all values x.\\
\hyperlink{jphase.MarkovMatrix.expUnif(int, double, Jama.Matrix, Jama.Matrix, int)}{{\bf expUnif(int, double, Matrix, Matrix, int)}} Computes leftMat * exp(A x) * rightMat, for all values x= 0, delta, 2delta, 3delta,....\\
\hyperlink{jphase.MarkovMatrix.identity(int)}{{\bf identity(int)}} \\
\hyperlink{jphase.MarkovMatrix.inverse()}{{\bf inverse()}} \\
\hyperlink{jphase.MarkovMatrix.isStochastic()}{{\bf isStochastic()}} Detrmines if the matrix is stochastic.\\
\hyperlink{jphase.MarkovMatrix.kronecker(Jama.Matrix)}{{\bf kronecker(Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.kronecker(Jama.Matrix, Jama.Matrix)}{{\bf kronecker(Matrix, Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.kroneckerSum(Jama.Matrix)}{{\bf kroneckerSum(Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.kroneckerSum(Jama.Matrix, Jama.Matrix)}{{\bf kroneckerSum(Matrix, Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.oldExp(double, Jama.Matrix)}{{\bf oldExp(double, Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.plus(double)}{{\bf plus(double)}} \\
\hyperlink{jphase.MarkovMatrix.pow(int)}{{\bf pow(int)}} \\
\hyperlink{jphase.MarkovMatrix.power(int)}{{\bf power(int)}} Returns A$\wedge$k\\
\hyperlink{jphase.MarkovMatrix.readTxt(java.lang.String)}{{\bf readTxt(String)}} \\
\hyperlink{jphase.MarkovMatrix.scalar()}{{\bf scalar()}} \\
\hyperlink{jphase.MarkovMatrix.size()}{{\bf size()}} \\
\hyperlink{jphase.MarkovMatrix.solveTranspose(Jama.Matrix)}{{\bf solveTranspose(Matrix)}} Solve X*A = B, which is also A'*X' = B'\\
\hyperlink{jphase.MarkovMatrix.times(double)}{{\bf times(double)}} \\
\hyperlink{jphase.MarkovMatrix.times(Jama.Matrix)}{{\bf times(Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.timesOne()}{{\bf timesOne()}} \\
\hyperlink{jphase.MarkovMatrix.toMarkovMatrix(Jama.Matrix)}{{\bf toMarkovMatrix(Matrix)}} \\
\hyperlink{jphase.MarkovMatrix.toString()}{{\bf toString()}} \\
\hyperlink{jphase.MarkovMatrix.toStringRTF()}{{\bf toStringRTF()}} \\
\hyperlink{jphase.MarkovMatrix.toTxt()}{{\bf toTxt()}} \\
\hyperlink{jphase.MarkovMatrix.uminus()}{{\bf uminus()}} \\
\hyperlink{jphase.MarkovMatrix.Zeros(int, int)}{{\bf Zeros(int, int)}} \\
\end{verse}
}
\subsubsection{Serializable Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{powers}
private java.util.List {\bf powers}}
\item{
\index{maxPower}
private int {\bf maxPower}}
\item{
\index{normal}
private MarkovMatrix {\bf normal}}
\item{
\index{ldaMax}
private double {\bf ldaMax}}
\item{
\index{aExpStep}
 MarkovMatrix {\bf aExpStep}}
\end{itemize}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{useUniformization}
\label{jphase.MarkovMatrix.useUniformization}\hypertarget{jphase.MarkovMatrix.useUniformization}{public static boolean {\bf useUniformization}}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MarkovMatrix(double\lbrack \rbrack \lbrack \rbrack )}
\hypertarget{jphase.MarkovMatrix(double[][])}{\membername{MarkovMatrix}}
{\tt public\ {\bf MarkovMatrix}( {\tt double\lbrack \rbrack \lbrack \rbrack } {\bf mat} )
\label{jphase.MarkovMatrix(double[][])}}%end signature
}%end item
\divideents{MarkovMatrix}
\item{\vskip -1.9ex 
\index{MarkovMatrix(Matrix)}
\hypertarget{jphase.MarkovMatrix(Jama.Matrix)}{\membername{MarkovMatrix}}
{\tt public\ {\bf MarkovMatrix}( {\tt Jama.Matrix} {\bf mat} )
\label{jphase.MarkovMatrix(Jama.Matrix)}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{compExp()}
\hypertarget{jphase.MarkovMatrix.compExp()}{\membername{compExp}}
{\tt public MarkovMatrix\ {\bf compExp}(  )
\label{jphase.MarkovMatrix.compExp()}}%end signature
}%end item
\divideents{compLog}
\item{\vskip -1.9ex 
\index{compLog()}
\hypertarget{jphase.MarkovMatrix.compLog()}{\membername{compLog}}
{\tt public MarkovMatrix\ {\bf compLog}(  )
\label{jphase.MarkovMatrix.compLog()}}%end signature
}%end item
\divideents{concatCols}
\item{\vskip -1.9ex 
\index{concatCols(Matrix, Matrix)}
\hypertarget{jphase.MarkovMatrix.concatCols(Jama.Matrix, Jama.Matrix)}{\membername{concatCols}}
{\tt public static Jama.Matrix\ {\bf concatCols}( {\tt Jama.Matrix} {\bf A},
{\tt Jama.Matrix} {\bf B} )
\label{jphase.MarkovMatrix.concatCols(Jama.Matrix, Jama.Matrix)}}%end signature
}%end item
\divideents{concatRows}
\item{\vskip -1.9ex 
\index{concatRows(Matrix, Matrix)}
\hypertarget{jphase.MarkovMatrix.concatRows(Jama.Matrix, Jama.Matrix)}{\membername{concatRows}}
{\tt public static Jama.Matrix\ {\bf concatRows}( {\tt Jama.Matrix} {\bf A},
{\tt Jama.Matrix} {\bf B} )
\label{jphase.MarkovMatrix.concatRows(Jama.Matrix, Jama.Matrix)}}%end signature
}%end item
\divideents{exp}
\item{\vskip -1.9ex 
\index{exp(double)}
\hypertarget{jphase.MarkovMatrix.exp(double)}{\membername{exp}}
{\tt public MarkovMatrix\ {\bf exp}( {\tt double} {\bf x} )
\label{jphase.MarkovMatrix.exp(double)}}%end signature
}%end item
\divideents{exp}
\item{\vskip -1.9ex 
\index{exp(double, Matrix, Matrix)}
\hypertarget{jphase.MarkovMatrix.exp(double, Jama.Matrix, Jama.Matrix)}{\membername{exp}}
{\tt public MarkovMatrix\ {\bf exp}( {\tt double} {\bf x},
{\tt Jama.Matrix} {\bf leftMat},
{\tt Jama.Matrix} {\bf rightMat} )
\label{jphase.MarkovMatrix.exp(double, Jama.Matrix, Jama.Matrix)}}%end signature
}%end item
\divideents{exp}
\item{\vskip -1.9ex 
\index{exp(int, double, Matrix, Matrix)}
\hypertarget{jphase.MarkovMatrix.exp(int, double, Jama.Matrix, Jama.Matrix)}{\membername{exp}}
{\tt public MarkovMatrix\lbrack \rbrack \ {\bf exp}( {\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt Jama.Matrix} {\bf leftMat},
{\tt Jama.Matrix} {\bf rightMat} )
\label{jphase.MarkovMatrix.exp(int, double, Jama.Matrix, Jama.Matrix)}}%end signature
}%end item
\divideents{expRunge}
\item{\vskip -1.9ex 
\index{expRunge(int, double, Matrix, Matrix)}
\hypertarget{jphase.MarkovMatrix.expRunge(int, double, Jama.Matrix, Jama.Matrix)}{\membername{expRunge}}
{\tt public MarkovMatrix\lbrack \rbrack \ {\bf expRunge}( {\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt Jama.Matrix} {\bf leftMat},
{\tt Jama.Matrix} {\bf rightMat} )
\label{jphase.MarkovMatrix.expRunge(int, double, Jama.Matrix, Jama.Matrix)}}%end signature
}%end item
\divideents{expTimesOnes}
\item{\vskip -1.9ex 
\index{expTimesOnes(double)}
\hypertarget{jphase.MarkovMatrix.expTimesOnes(double)}{\membername{expTimesOnes}}
{\tt public MarkovMatrix\ {\bf expTimesOnes}( {\tt double} {\bf x} )
\label{jphase.MarkovMatrix.expTimesOnes(double)}}%end signature
}%end item
\divideents{expTimesOnes}
\item{\vskip -1.9ex 
\index{expTimesOnes(double, Matrix)}
\hypertarget{jphase.MarkovMatrix.expTimesOnes(double, Jama.Matrix)}{\membername{expTimesOnes}}
{\tt public MarkovMatrix\ {\bf expTimesOnes}( {\tt double} {\bf x},
{\tt Jama.Matrix} {\bf leftMatrix} )
\label{jphase.MarkovMatrix.expTimesOnes(double, Jama.Matrix)}}%end signature
}%end item
\divideents{expTimesOnes}
\item{\vskip -1.9ex 
\index{expTimesOnes(int, double, Matrix)}
\hypertarget{jphase.MarkovMatrix.expTimesOnes(int, double, Jama.Matrix)}{\membername{expTimesOnes}}
{\tt public MarkovMatrix\lbrack \rbrack \ {\bf expTimesOnes}( {\tt int} {\bf N},
{\tt double} {\bf delta},
{\tt Jama.Matrix} {\bf leftMatrix} )
\label{jphase.MarkovMatrix.expTimesOnes(int, double, Jama.Matrix)}}%end signature
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(double\lbrack \rbrack , Matrix, Matrix)}
\hypertarget{jphase.MarkovMatrix.expUnif(double[], Jama.Matrix, Jama.Matrix)}{\membername{expUnif}}
{\tt public MarkovMatrix\lbrack \rbrack \ {\bf expUnif}( {\tt double\lbrack \rbrack } {\bf times},
{\tt Jama.Matrix} {\bf leftMat},
{\tt Jama.Matrix} {\bf rightMat} )
\label{jphase.MarkovMatrix.expUnif(double[], Jama.Matrix, Jama.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for all values x. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(double\lbrack \rbrack , Matrix, Matrix, int)}
\hypertarget{jphase.MarkovMatrix.expUnif(double[], Jama.Matrix, Jama.Matrix, int)}{\membername{expUnif}}
{\tt public MarkovMatrix\lbrack \rbrack \ {\bf expUnif}( {\tt double\lbrack \rbrack } {\bf times},
{\tt Jama.Matrix} {\bf leftMat},
{\tt Jama.Matrix} {\bf rightMat},
{\tt int} {\bf truncate} )
\label{jphase.MarkovMatrix.expUnif(double[], Jama.Matrix, Jama.Matrix, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for all values x. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(double, Matrix, Matrix)}
\hypertarget{jphase.MarkovMatrix.expUnif(double, Jama.Matrix, Jama.Matrix)}{\membername{expUnif}}
{\tt public MarkovMatrix\lbrack \rbrack \ {\bf expUnif}( {\tt double} {\bf x},
{\tt Jama.Matrix} {\bf leftMat},
{\tt Jama.Matrix} {\bf rightMat} )
\label{jphase.MarkovMatrix.expUnif(double, Jama.Matrix, Jama.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for the value x. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(int, double, Matrix, Matrix)}
\hypertarget{jphase.MarkovMatrix.expUnif(int, double, Jama.Matrix, Jama.Matrix)}{\membername{expUnif}}
{\tt public MarkovMatrix\lbrack \rbrack \ {\bf expUnif}( {\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt Jama.Matrix} {\bf leftMat},
{\tt Jama.Matrix} {\bf rightMat} )
\label{jphase.MarkovMatrix.expUnif(int, double, Jama.Matrix, Jama.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for all values x. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(int, double, Matrix, Matrix, int)}
\hypertarget{jphase.MarkovMatrix.expUnif(int, double, Jama.Matrix, Jama.Matrix, int)}{\membername{expUnif}}
{\tt public MarkovMatrix\lbrack \rbrack \ {\bf expUnif}( {\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt Jama.Matrix} {\bf leftMat},
{\tt Jama.Matrix} {\bf rightMat},
{\tt int} {\bf truncate} )
\label{jphase.MarkovMatrix.expUnif(int, double, Jama.Matrix, Jama.Matrix, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for all values x= 0, delta, 2delta, 3delta,.... It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\end{itemize}
}%end item
\divideents{identity}
\item{\vskip -1.9ex 
\index{identity(int)}
\hypertarget{jphase.MarkovMatrix.identity(int)}{\membername{identity}}
{\tt public static Jama.Matrix\ {\bf identity}( {\tt int} {\bf n} )
\label{jphase.MarkovMatrix.identity(int)}}%end signature
}%end item
\divideents{inverse}
\item{\vskip -1.9ex 
\index{inverse()}
\hypertarget{jphase.MarkovMatrix.inverse()}{\membername{inverse}}
{\tt public Jama.Matrix\ {\bf inverse}(  )
\label{jphase.MarkovMatrix.inverse()}}%end signature
}%end item
\divideents{isStochastic}
\item{\vskip -1.9ex 
\index{isStochastic()}
\hypertarget{jphase.MarkovMatrix.isStochastic()}{\membername{isStochastic}}
{\tt public boolean\ {\bf isStochastic}(  )
\label{jphase.MarkovMatrix.isStochastic()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Detrmines if the matrix is stochastic.
}
\item{{\bf Returns} -- 
tru if the matrix is stochastic. 
}%end item
\end{itemize}
}%end item
\divideents{kronecker}
\item{\vskip -1.9ex 
\index{kronecker(Matrix)}
\hypertarget{jphase.MarkovMatrix.kronecker(Jama.Matrix)}{\membername{kronecker}}
{\tt public Jama.Matrix\ {\bf kronecker}( {\tt Jama.Matrix} {\bf B} )
\label{jphase.MarkovMatrix.kronecker(Jama.Matrix)}}%end signature
}%end item
\divideents{kronecker}
\item{\vskip -1.9ex 
\index{kronecker(Matrix, Matrix)}
\hypertarget{jphase.MarkovMatrix.kronecker(Jama.Matrix, Jama.Matrix)}{\membername{kronecker}}
{\tt public static Jama.Matrix\ {\bf kronecker}( {\tt Jama.Matrix} {\bf A},
{\tt Jama.Matrix} {\bf B} )
\label{jphase.MarkovMatrix.kronecker(Jama.Matrix, Jama.Matrix)}}%end signature
}%end item
\divideents{kroneckerSum}
\item{\vskip -1.9ex 
\index{kroneckerSum(Matrix)}
\hypertarget{jphase.MarkovMatrix.kroneckerSum(Jama.Matrix)}{\membername{kroneckerSum}}
{\tt public Jama.Matrix\ {\bf kroneckerSum}( {\tt Jama.Matrix} {\bf B} )
\label{jphase.MarkovMatrix.kroneckerSum(Jama.Matrix)}}%end signature
}%end item
\divideents{kroneckerSum}
\item{\vskip -1.9ex 
\index{kroneckerSum(Matrix, Matrix)}
\hypertarget{jphase.MarkovMatrix.kroneckerSum(Jama.Matrix, Jama.Matrix)}{\membername{kroneckerSum}}
{\tt public static Jama.Matrix\ {\bf kroneckerSum}( {\tt Jama.Matrix} {\bf A},
{\tt Jama.Matrix} {\bf B} )
\label{jphase.MarkovMatrix.kroneckerSum(Jama.Matrix, Jama.Matrix)}}%end signature
}%end item
\divideents{oldExp}
\item{\vskip -1.9ex 
\index{oldExp(double, Matrix)}
\hypertarget{jphase.MarkovMatrix.oldExp(double, Jama.Matrix)}{\membername{oldExp}}
{\tt public MarkovMatrix\ {\bf oldExp}( {\tt double} {\bf x},
{\tt Jama.Matrix} {\bf rightMat} )
\label{jphase.MarkovMatrix.oldExp(double, Jama.Matrix)}}%end signature
}%end item
\divideents{plus}
\item{\vskip -1.9ex 
\index{plus(double)}
\hypertarget{jphase.MarkovMatrix.plus(double)}{\membername{plus}}
{\tt public MarkovMatrix\ {\bf plus}( {\tt double} {\bf x} )
\label{jphase.MarkovMatrix.plus(double)}}%end signature
}%end item
\divideents{pow}
\item{\vskip -1.9ex 
\index{pow(int)}
\hypertarget{jphase.MarkovMatrix.pow(int)}{\membername{pow}}
{\tt public Jama.Matrix\ {\bf pow}( {\tt int} {\bf k} )
\label{jphase.MarkovMatrix.pow(int)}}%end signature
}%end item
\divideents{power}
\item{\vskip -1.9ex 
\index{power(int)}
\hypertarget{jphase.MarkovMatrix.power(int)}{\membername{power}}
{\tt public MarkovMatrix\ {\bf power}( {\tt int} {\bf k} )
\label{jphase.MarkovMatrix.power(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns A$\wedge$k
}
\end{itemize}
}%end item
\divideents{readTxt}
\item{\vskip -1.9ex 
\index{readTxt(String)}
\hypertarget{jphase.MarkovMatrix.readTxt(java.lang.String)}{\membername{readTxt}}
{\tt public static MarkovMatrix\ {\bf readTxt}( {\tt java.lang.String} {\bf stg} )
\label{jphase.MarkovMatrix.readTxt(java.lang.String)}}%end signature
}%end item
\divideents{scalar}
\item{\vskip -1.9ex 
\index{scalar()}
\hypertarget{jphase.MarkovMatrix.scalar()}{\membername{scalar}}
{\tt public double\ {\bf scalar}(  )
\label{jphase.MarkovMatrix.scalar()}}%end signature
}%end item
\divideents{size}
\item{\vskip -1.9ex 
\index{size()}
\hypertarget{jphase.MarkovMatrix.size()}{\membername{size}}
{\tt public int\ {\bf size}(  )
\label{jphase.MarkovMatrix.size()}}%end signature
}%end item
\divideents{solveTranspose}
\item{\vskip -1.9ex 
\index{solveTranspose(Matrix)}
\hypertarget{jphase.MarkovMatrix.solveTranspose(Jama.Matrix)}{\membername{solveTranspose}}
{\tt public Jama.Matrix\ {\bf solveTranspose}( {\tt Jama.Matrix} {\bf B} )
\label{jphase.MarkovMatrix.solveTranspose(Jama.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Solve X*A = B, which is also A'*X' = B'
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt B} -- right hand side}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
solution if A is square, least squares solution otherwise. 
}%end item
\end{itemize}
}%end item
\divideents{times}
\item{\vskip -1.9ex 
\index{times(double)}
\hypertarget{jphase.MarkovMatrix.times(double)}{\membername{times}}
{\tt public Jama.Matrix\ {\bf times}( {\tt double} {\bf arg0} )
\label{jphase.MarkovMatrix.times(double)}}%end signature
}%end item
\divideents{times}
\item{\vskip -1.9ex 
\index{times(Matrix)}
\hypertarget{jphase.MarkovMatrix.times(Jama.Matrix)}{\membername{times}}
{\tt public Jama.Matrix\ {\bf times}( {\tt Jama.Matrix} {\bf arg0} )
\label{jphase.MarkovMatrix.times(Jama.Matrix)}}%end signature
}%end item
\divideents{timesOne}
\item{\vskip -1.9ex 
\index{timesOne()}
\hypertarget{jphase.MarkovMatrix.timesOne()}{\membername{timesOne}}
{\tt public MarkovMatrix\ {\bf timesOne}(  )
\label{jphase.MarkovMatrix.timesOne()}}%end signature
}%end item
\divideents{toMarkovMatrix}
\item{\vskip -1.9ex 
\index{toMarkovMatrix(Matrix)}
\hypertarget{jphase.MarkovMatrix.toMarkovMatrix(Jama.Matrix)}{\membername{toMarkovMatrix}}
{\tt public static MarkovMatrix\ {\bf toMarkovMatrix}( {\tt Jama.Matrix} {\bf A} )
\label{jphase.MarkovMatrix.toMarkovMatrix(Jama.Matrix)}}%end signature
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jphase.MarkovMatrix.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jphase.MarkovMatrix.toString()}}%end signature
}%end item
\divideents{toStringRTF}
\item{\vskip -1.9ex 
\index{toStringRTF()}
\hypertarget{jphase.MarkovMatrix.toStringRTF()}{\membername{toStringRTF}}
{\tt public java.lang.String\ {\bf toStringRTF}(  )
\label{jphase.MarkovMatrix.toStringRTF()}}%end signature
}%end item
\divideents{toTxt}
\item{\vskip -1.9ex 
\index{toTxt()}
\hypertarget{jphase.MarkovMatrix.toTxt()}{\membername{toTxt}}
{\tt public java.lang.String\ {\bf toTxt}(  )
\label{jphase.MarkovMatrix.toTxt()}}%end signature
}%end item
\divideents{uminus}
\item{\vskip -1.9ex 
\index{uminus()}
\hypertarget{jphase.MarkovMatrix.uminus()}{\membername{uminus}}
{\tt public Jama.Matrix\ {\bf uminus}(  )
\label{jphase.MarkovMatrix.uminus()}}%end signature
}%end item
\divideents{Zeros}
\item{\vskip -1.9ex 
\index{Zeros(int, int)}
\hypertarget{jphase.MarkovMatrix.Zeros(int, int)}{\membername{Zeros}}
{\tt public static MarkovMatrix\ {\bf Zeros}( {\tt int} {\bf rows},
{\tt int} {\bf cols} )
\label{jphase.MarkovMatrix.Zeros(int, int)}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt Jama.Matrix} \textnormal{\small\refdefined{Jama.Matrix}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public Matrix {\bf arrayLeftDivide}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf arrayLeftDivideEquals}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf arrayRightDivide}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf arrayRightDivideEquals}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf arrayTimes}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf arrayTimesEquals}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public CholeskyDecomposition {\bf chol}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Object {\bf clone}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf cond}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public static Matrix {\bf constructWithCopy}( {\tt double\lbrack \rbrack \lbrack \rbrack } {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf copy}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf det}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public EigenvalueDecomposition {\bf eig}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf get}( {\tt int} {\bf arg0},
{\tt int} {\bf arg1} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getArrayCopy}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getColumnDimension}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getColumnPackedCopy}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf getMatrix}( {\tt int\lbrack \rbrack } {\bf arg0},
{\tt int\lbrack \rbrack } {\bf arg1} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf getMatrix}( {\tt int\lbrack \rbrack } {\bf arg0},
{\tt int} {\bf arg1},
{\tt int} {\bf arg2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf getMatrix}( {\tt int} {\bf arg0},
{\tt int} {\bf arg1},
{\tt int\lbrack \rbrack } {\bf arg2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf getMatrix}( {\tt int} {\bf arg0},
{\tt int} {\bf arg1},
{\tt int} {\bf arg2},
{\tt int} {\bf arg3} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getRowDimension}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getRowPackedCopy}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public static Matrix {\bf identity}( {\tt int} {\bf arg0},
{\tt int} {\bf arg1} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf inverse}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public LUDecomposition {\bf lu}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf minus}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf minusEquals}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf norm1}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf norm2}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf normF}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf normInf}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf plus}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf plusEquals}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf print}( {\tt int} {\bf arg0},
{\tt int} {\bf arg1} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf print}( {\tt java.text.NumberFormat} {\bf arg0},
{\tt int} {\bf arg1} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf print}( {\tt java.io.PrintWriter} {\bf arg0},
{\tt int} {\bf arg1},
{\tt int} {\bf arg2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf print}( {\tt java.io.PrintWriter} {\bf arg0},
{\tt java.text.NumberFormat} {\bf arg1},
{\tt int} {\bf arg2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public QRDecomposition {\bf qr}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public static Matrix {\bf random}( {\tt int} {\bf arg0},
{\tt int} {\bf arg1} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf rank}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public static Matrix {\bf read}( {\tt java.io.BufferedReader} {\bf arg0} ) throws java.io.IOException
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf set}( {\tt int} {\bf arg0},
{\tt int} {\bf arg1},
{\tt double} {\bf arg2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setMatrix}( {\tt int\lbrack \rbrack } {\bf arg0},
{\tt int\lbrack \rbrack } {\bf arg1},
{\tt Matrix} {\bf arg2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setMatrix}( {\tt int\lbrack \rbrack } {\bf arg0},
{\tt int} {\bf arg1},
{\tt int} {\bf arg2},
{\tt Matrix} {\bf arg3} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setMatrix}( {\tt int} {\bf arg0},
{\tt int} {\bf arg1},
{\tt int\lbrack \rbrack } {\bf arg2},
{\tt Matrix} {\bf arg3} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public void {\bf setMatrix}( {\tt int} {\bf arg0},
{\tt int} {\bf arg1},
{\tt int} {\bf arg2},
{\tt int} {\bf arg3},
{\tt Matrix} {\bf arg4} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf solve}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf solveTranspose}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public SingularValueDecomposition {\bf svd}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf times}( {\tt double} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf times}( {\tt Matrix} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf timesEquals}( {\tt double} {\bf arg0} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf trace}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf transpose}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Matrix {\bf uminus}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MatrixUtils}
\subsection{\label{jphase.MatrixUtils}\index{MatrixUtils}{\bf {\it Class} MatrixUtils}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.MatrixUtils}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class MatrixUtils
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}}}}
\subsubsection{Version}{0.1 Utilities class for the jphase package}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.MatrixUtils()}{{\bf MatrixUtils()}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.MatrixUtils.average(double[])}{{\bf average(double\lbrack \rbrack )}} Computes data average\\
\hyperlink{jphase.MatrixUtils.average2(double[])}{{\bf average2(double\lbrack \rbrack )}} Computes the second moment of the data\\
\hyperlink{jphase.MatrixUtils.concatCols(no.uib.cipr.matrix.DenseMatrix, no.uib.cipr.matrix.DenseMatrix)}{{\bf concatCols(DenseMatrix, DenseMatrix)}} Concatenates the columns of the matrices, keeping the same number of rows in dense format\\
\hyperlink{jphase.MatrixUtils.concatCols(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf concatCols(Matrix, Matrix, Matrix)}} Concatenates the columns of the matrices, keeping the same number of rows in the predefined format\\
\hyperlink{jphase.MatrixUtils.concatQuad(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf concatQuad(Matrix, Matrix, Matrix, Matrix, Matrix)}} Concatenates the colums of the left and right upper matrices and the result is concatenated by rows with the concatenation of left and right lower matrices\\
\hyperlink{jphase.MatrixUtils.concatRows(no.uib.cipr.matrix.DenseMatrix, no.uib.cipr.matrix.DenseMatrix)}{{\bf concatRows(DenseMatrix, DenseMatrix)}} Concatenates the rows of the matrices, keeping the same number of colums in dense format\\
\hyperlink{jphase.MatrixUtils.concatRows(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf concatRows(Matrix, Matrix, Matrix)}} Concatenates the rows of the matrices, keeping the same number of colums in the predefined format\\
\hyperlink{jphase.MatrixUtils.concatVectors(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseVector)}{{\bf concatVectors(DenseVector, DenseVector)}} Concatenates the vectors in dense format\\
\hyperlink{jphase.MatrixUtils.concatVectors(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{{\bf concatVectors(Vector, Vector, Vector)}} Concatenates the vectors in the predefined format\\
\hyperlink{jphase.MatrixUtils.CV(double[])}{{\bf CV(double\lbrack \rbrack )}} Return the Coefficient of Variation of the data trace\\
\hyperlink{jphase.MatrixUtils.distance(double[], double[])}{{\bf distance(double\lbrack \rbrack , double\lbrack \rbrack )}} Calculates the distance between two arrays, defined as the maximum euclidean distance between every entry in those arrays\\
\hyperlink{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double)}{{\bf exp(Matrix, double)}} Returns exp(A x), for the value x.\\
\hyperlink{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf exp(Matrix, double, Matrix, Matrix)}} Returns leftMat * exp(A x) * rightMat, for the value x.\\
\hyperlink{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, boolean)}{{\bf exp(Matrix, double, Matrix, Matrix, boolean)}} Returns leftMat * exp(A x) * rightMat, for the value x.\\
\hyperlink{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{{\bf exp(Matrix, double, Vector, Vector)}} Returns leftVec * exp(A x) * rightVec, for the value x.\\
\hyperlink{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, boolean)}{{\bf exp(Matrix, int, double, Matrix, Matrix, boolean)}} Computes leftMat * exp(A x) * rightMat, for all values x = 0 + i*delta, i=0,...,n.\\
\hyperlink{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, boolean)}{{\bf exp(Matrix, int, double, Vector, Vector, boolean)}} Returns leftVec * exp(A x) * rightVec, for all values x = 0 + i*delta, i=0,...,n.\\
\hyperlink{jphase.MatrixUtils.expRunge(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf expRunge(Matrix, int, double, Matrix, Matrix)}} Computes leftMat * exp(A x) * rightMat, for all values x = 0 + i*delta, i=0,...,n.\\
\hyperlink{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, double)}{{\bf expTimesOnes(Matrix, double)}} Returns exp(A x) * Ones, for the value x.\\
\hyperlink{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix)}{{\bf expTimesOnes(Matrix, double, Matrix)}} Returns leftMat * exp(A x) * Ones, for the value x.\\
\hyperlink{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Vector)}{{\bf expTimesOnes(Matrix, double, Vector)}} Returns leftVec * exp(A x) * OnesVector, for the value x.\\
\hyperlink{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix)}{{\bf expTimesOnes(Matrix, int, double, Matrix)}} Returns leftMat * exp(A x) * OnesCol, for all values x = 0 + i*delta, i=0,...,n.\\
\hyperlink{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector)}{{\bf expTimesOnes(Matrix, int, double, Vector)}} Returns leftVec * exp(A x) * OnesVector, for all values x = 0 + i*delta, i=0,...,n.\\
\hyperlink{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double[], no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf expUnif(Matrix, double\lbrack \rbrack , Matrix, Matrix)}} Computes leftMat * exp(A x) * rightMat, for all values x in times.\\
\hyperlink{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double[], no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, int)}{{\bf expUnif(Matrix, double\lbrack \rbrack , Matrix, Matrix, int)}} Computes leftMat * exp(A x) * rightMat, for all values x in times.\\
\hyperlink{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double[], no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, int)}{{\bf expUnif(Matrix, double\lbrack \rbrack , Vector, Vector, int)}} Computes leftVec * exp(A x) * rightVec, for all values x in times.\\
\hyperlink{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf expUnif(Matrix, double, Matrix, Matrix)}} Computes leftMat * exp(A x) * rightMat, for the value x.\\
\hyperlink{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf expUnif(Matrix, int, double, Matrix, Matrix)}} Computes leftMat * exp(A x) * rightMat, for all values x = 0 + i*delta, i=0,...,n.\\
\hyperlink{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, int)}{{\bf expUnif(Matrix, int, double, Matrix, Matrix, int)}} Computes leftMat * exp(A x) * rightMat, for all values x = 0 + i*delta, i=0,...,n.\\
\hyperlink{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{{\bf expUnif(Matrix, int, double, Vector, Vector)}} Computes leftVec * exp(A x) * rightVec, for all values x = 0 + i*delta, i=0,...,n.\\
\hyperlink{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, int)}{{\bf expUnif(Matrix, int, double, Vector, Vector, int)}} Computes leftVec * exp(A x) * rightVec, for all values x = 0 + i*delta, i=0,...,n.\\
\hyperlink{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf kronecker(Matrix, Matrix)}} Returns the kronecker product of two matrices in dense format\\
\hyperlink{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf kronecker(Matrix, Matrix, Matrix)}} Returns the kronecker product of two matrices in the predefined storage format\\
\hyperlink{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{{\bf kronecker(Matrix, Vector, Matrix)}} Returns the kronecker product of one matrix with one vector (Matrix x Vector) in dense format\\
\hyperlink{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf kronecker(Vector, Matrix, Matrix)}} Returns the kronecker product of one vector with one matrix (Vector x Matrix) in dense format\\
\hyperlink{jphase.MatrixUtils.kroneckerSum(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf kroneckerSum(Matrix, Matrix)}} Returns the kronecker sum of two matrices in dense format\\
\hyperlink{jphase.MatrixUtils.kroneckerSum(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{{\bf kroneckerSum(Matrix, Matrix, Matrix)}} Returns the kronecker sum of two matrices and stores it in the predefined format\\
\hyperlink{jphase.MatrixUtils.kroneckerVectors(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseVector)}{{\bf kroneckerVectors(DenseVector, DenseVector)}} Returns the kronecker product of two vectors in dense format\\
\hyperlink{jphase.MatrixUtils.kroneckerVectors(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{{\bf kroneckerVectors(Vector, Vector, Vector)}} Returns the kronecker product of two vectors in ths predefined format\\
\hyperlink{jphase.MatrixUtils.matPower(no.uib.cipr.matrix.Matrix, int)}{{\bf matPower(Matrix, int)}} Computes k power of the matrix A\\
\hyperlink{jphase.MatrixUtils.matPower(no.uib.cipr.matrix.Matrix, int, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{{\bf matPower(Matrix, int, Vector, Vector)}} Computes the kth power of the matrix A premultiplied by leftVec and postmultiplied by rightVec\\
\hyperlink{jphase.MatrixUtils.multVector(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{{\bf multVector(Vector, Vector, Matrix)}} Computes the producto of two vectors A x B$\wedge$T\\
\hyperlink{jphase.MatrixUtils.OnesCol(int)}{{\bf OnesCol(int)}} Returns a one-column matrix in dense format with one in every entry\\
\hyperlink{jphase.MatrixUtils.OnesRow(int)}{{\bf OnesRow(int)}} Returns a one-row matrix in dense format with one in every entry\\
\hyperlink{jphase.MatrixUtils.OnesVector(int)}{{\bf OnesVector(int)}} Returns a DenseVector with one in every entry\\
\hyperlink{jphase.MatrixUtils.OnesVector(no.uib.cipr.matrix.Vector)}{{\bf OnesVector(Vector)}} Returns a Vector with one in every entry in the predefined storage format\\
\hyperlink{jphase.MatrixUtils.pow(double, int)}{{\bf pow(double, int)}} Calculates x$\wedge$n\\
\hyperlink{jphase.MatrixUtils.scalar(no.uib.cipr.matrix.Matrix)}{{\bf scalar(Matrix)}} Returns the value of the position (0,0) in the matrix, if its number of columns is equal to one (1)\\
\hyperlink{jphase.MatrixUtils.sumMatPower(no.uib.cipr.matrix.Matrix, int, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{{\bf sumMatPower(Matrix, int, Vector, Vector)}} Computes the sum of the first k terms of the succesion T$\wedge$(j-1), from j = 1\\
\hyperlink{jphase.MatrixUtils.variance(double[])}{{\bf variance(double\lbrack \rbrack )}} Return the variance of the data\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MatrixUtils()}
\hypertarget{jphase.MatrixUtils()}{\membername{MatrixUtils}}
{\tt public\ {\bf MatrixUtils}(  )
\label{jphase.MatrixUtils()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{average(double\lbrack \rbrack )}
\hypertarget{jphase.MatrixUtils.average(double[])}{\membername{average}}
{\tt public static double\ {\bf average}( {\tt double\lbrack \rbrack } {\bf datos} )
\label{jphase.MatrixUtils.average(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes data average
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt datos} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Data Average 
}%end item
\end{itemize}
}%end item
\divideents{average2}
\item{\vskip -1.9ex 
\index{average2(double\lbrack \rbrack )}
\hypertarget{jphase.MatrixUtils.average2(double[])}{\membername{average2}}
{\tt public static double\ {\bf average2}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.MatrixUtils.average2(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the second moment of the data
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- data trace}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Second data trace moment 
}%end item
\end{itemize}
}%end item
\divideents{concatCols}
\item{\vskip -1.9ex 
\index{concatCols(DenseMatrix, DenseMatrix)}
\hypertarget{jphase.MatrixUtils.concatCols(no.uib.cipr.matrix.DenseMatrix, no.uib.cipr.matrix.DenseMatrix)}{\membername{concatCols}}
{\tt public static no.uib.cipr.matrix.DenseMatrix\ {\bf concatCols}( {\tt no.uib.cipr.matrix.DenseMatrix} {\bf A},
{\tt no.uib.cipr.matrix.DenseMatrix} {\bf B} )
\label{jphase.MatrixUtils.concatCols(no.uib.cipr.matrix.DenseMatrix, no.uib.cipr.matrix.DenseMatrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Concatenates the columns of the matrices, keeping the same number of rows in dense format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- DenseMatrix}
   \item{
\sld
{\tt B} -- DenseMatrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Resulting matrix from cancatenation 
}%end item
\end{itemize}
}%end item
\divideents{concatCols}
\item{\vskip -1.9ex 
\index{concatCols(Matrix, Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.concatCols(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{concatCols}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf concatCols}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt no.uib.cipr.matrix.Matrix} {\bf B},
{\tt no.uib.cipr.matrix.Matrix} {\bf res} )
\label{jphase.MatrixUtils.concatCols(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Concatenates the columns of the matrices, keeping the same number of rows in the predefined format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt B} -- Matrix}
   \item{
\sld
{\tt res} -- Resulting matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Resulting matrix from cancatenation 
}%end item
\end{itemize}
}%end item
\divideents{concatQuad}
\item{\vskip -1.9ex 
\index{concatQuad(Matrix, Matrix, Matrix, Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.concatQuad(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{concatQuad}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf concatQuad}( {\tt no.uib.cipr.matrix.Matrix} {\bf leftUp},
{\tt no.uib.cipr.matrix.Matrix} {\bf rightUp},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftDown},
{\tt no.uib.cipr.matrix.Matrix} {\bf rightDown},
{\tt no.uib.cipr.matrix.Matrix} {\bf res} )
\label{jphase.MatrixUtils.concatQuad(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Concatenates the colums of the left and right upper matrices and the result is concatenated by rows with the concatenation of left and right lower matrices
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt leftUp} -- Left upper Matrix}
   \item{
\sld
{\tt rightUp} -- Right upper Matrix}
   \item{
\sld
{\tt leftDown} -- Left lower Matrix}
   \item{
\sld
{\tt rightDown} -- Right lower matrix}
   \item{
\sld
{\tt res} -- Resulting Matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
resulting matrix from concatenation 
}%end item
\end{itemize}
}%end item
\divideents{concatRows}
\item{\vskip -1.9ex 
\index{concatRows(DenseMatrix, DenseMatrix)}
\hypertarget{jphase.MatrixUtils.concatRows(no.uib.cipr.matrix.DenseMatrix, no.uib.cipr.matrix.DenseMatrix)}{\membername{concatRows}}
{\tt public static no.uib.cipr.matrix.DenseMatrix\ {\bf concatRows}( {\tt no.uib.cipr.matrix.DenseMatrix} {\bf A},
{\tt no.uib.cipr.matrix.DenseMatrix} {\bf B} )
\label{jphase.MatrixUtils.concatRows(no.uib.cipr.matrix.DenseMatrix, no.uib.cipr.matrix.DenseMatrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Concatenates the rows of the matrices, keeping the same number of colums in dense format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- DenseMatrix}
   \item{
\sld
{\tt B} -- DenseMatrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Resulting matrix from cancatenation 
}%end item
\end{itemize}
}%end item
\divideents{concatRows}
\item{\vskip -1.9ex 
\index{concatRows(Matrix, Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.concatRows(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{concatRows}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf concatRows}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt no.uib.cipr.matrix.Matrix} {\bf B},
{\tt no.uib.cipr.matrix.Matrix} {\bf res} )
\label{jphase.MatrixUtils.concatRows(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Concatenates the rows of the matrices, keeping the same number of colums in the predefined format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt B} -- Matrix}
   \item{
\sld
{\tt res} -- Resulting matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Resulting matrix from cancatenation 
}%end item
\end{itemize}
}%end item
\divideents{concatVectors}
\item{\vskip -1.9ex 
\index{concatVectors(DenseVector, DenseVector)}
\hypertarget{jphase.MatrixUtils.concatVectors(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseVector)}{\membername{concatVectors}}
{\tt public static no.uib.cipr.matrix.DenseVector\ {\bf concatVectors}( {\tt no.uib.cipr.matrix.DenseVector} {\bf A},
{\tt no.uib.cipr.matrix.DenseVector} {\bf B} )
\label{jphase.MatrixUtils.concatVectors(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseVector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Concatenates the vectors in dense format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- DenseVector}
   \item{
\sld
{\tt B} -- DenseVector}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Resulting DenseVector from cancatenation 
}%end item
\end{itemize}
}%end item
\divideents{concatVectors}
\item{\vskip -1.9ex 
\index{concatVectors(Vector, Vector, Vector)}
\hypertarget{jphase.MatrixUtils.concatVectors(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{\membername{concatVectors}}
{\tt public static no.uib.cipr.matrix.Vector\ {\bf concatVectors}( {\tt no.uib.cipr.matrix.Vector} {\bf A},
{\tt no.uib.cipr.matrix.Vector} {\bf B},
{\tt no.uib.cipr.matrix.Vector} {\bf res} )
\label{jphase.MatrixUtils.concatVectors(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Concatenates the vectors in the predefined format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Vector}
   \item{
\sld
{\tt B} -- vector}
   \item{
\sld
{\tt res} -- Resulting vector}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Resulting vectormatrix from cancatenation 
}%end item
\end{itemize}
}%end item
\divideents{CV}
\item{\vskip -1.9ex 
\index{CV(double\lbrack \rbrack )}
\hypertarget{jphase.MatrixUtils.CV(double[])}{\membername{CV}}
{\tt public static double\ {\bf CV}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.MatrixUtils.CV(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the Coefficient of Variation of the data trace
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- data trace}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Data Coefficient of Variation 
}%end item
\end{itemize}
}%end item
\divideents{distance}
\item{\vskip -1.9ex 
\index{distance(double\lbrack \rbrack , double\lbrack \rbrack )}
\hypertarget{jphase.MatrixUtils.distance(double[], double[])}{\membername{distance}}
{\tt public static double\ {\bf distance}( {\tt double\lbrack \rbrack } {\bf v1},
{\tt double\lbrack \rbrack } {\bf v2} )
\label{jphase.MatrixUtils.distance(double[], double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Calculates the distance between two arrays, defined as the maximum euclidean distance between every entry in those arrays
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt v1} -- array}
   \item{
\sld
{\tt v2} -- array}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Distance between two arrays 
}%end item
\end{itemize}
}%end item
\divideents{exp}
\item{\vskip -1.9ex 
\index{exp(Matrix, double)}
\hypertarget{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double)}{\membername{exp}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf exp}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt double} {\bf x} )
\label{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns exp(A x), for the value x. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt x} -- evaluation point}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
exp(A x) 
}%end item
\end{itemize}
}%end item
\divideents{exp}
\item{\vskip -1.9ex 
\index{exp(Matrix, double, Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{exp}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf exp}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt double} {\bf x},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftMat},
{\tt no.uib.cipr.matrix.Matrix} {\bf rightMat} )
\label{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns leftMat * exp(A x) * rightMat, for the value x. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt x} -- evaluation point}
   \item{
\sld
{\tt leftMat} -- Matrix}
   \item{
\sld
{\tt rightMat} -- Matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftMat * exp(A x) * rightMat 
}%end item
\end{itemize}
}%end item
\divideents{exp}
\item{\vskip -1.9ex 
\index{exp(Matrix, double, Matrix, Matrix, boolean)}
\hypertarget{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, boolean)}{\membername{exp}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf exp}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt double} {\bf x},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftMat},
{\tt no.uib.cipr.matrix.Matrix} {\bf rightMat},
{\tt boolean} {\bf useUniformization} )
\label{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns leftMat * exp(A x) * rightMat, for the value x. It uses the uniformization algorithm or the RungeKutta method
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt x} -- evaluation point}
   \item{
\sld
{\tt leftMat} -- Matrix}
   \item{
\sld
{\tt rightMat} -- Matrix}
   \item{
\sld
{\tt useUniformization} -- true if the method to use is Uniformization, false if it is RungeKutta}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftMat * exp(A x) * rightMat 
}%end item
\end{itemize}
}%end item
\divideents{exp}
\item{\vskip -1.9ex 
\index{exp(Matrix, double, Vector, Vector)}
\hypertarget{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{\membername{exp}}
{\tt public static double\ {\bf exp}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt double} {\bf x},
{\tt no.uib.cipr.matrix.Vector} {\bf leftVec},
{\tt no.uib.cipr.matrix.Vector} {\bf rightVec} )
\label{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns leftVec * exp(A x) * rightVec, for the value x. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt x} -- evaluation point}
   \item{
\sld
{\tt leftVec} -- Vector}
   \item{
\sld
{\tt rightVec} -- Vector}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftVec * exp(A x) * rightVec 
}%end item
\end{itemize}
}%end item
\divideents{exp}
\item{\vskip -1.9ex 
\index{exp(Matrix, int, double, Matrix, Matrix, boolean)}
\hypertarget{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, boolean)}{\membername{exp}}
{\tt public static no.uib.cipr.matrix.Matrix\lbrack \rbrack \ {\bf exp}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftMat},
{\tt no.uib.cipr.matrix.Matrix} {\bf rightMat},
{\tt boolean} {\bf useUniformization} )
\label{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for all values x = 0 + i*delta, i=0,...,n. It uses the uniformization algorithm or the RungeKutta method
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt n} -- number of evaluation points}
   \item{
\sld
{\tt delta} -- separation between evaluation points}
   \item{
\sld
{\tt leftMat} -- Matrix}
   \item{
\sld
{\tt rightMat} -- Matrix}
   \item{
\sld
{\tt useUniformization} -- true if the method to use is Uniformization, false if it is RungeKutta}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftMat * exp(A x) * rightMat, for x = 0 + i*delta, i=0,...,n 
}%end item
\end{itemize}
}%end item
\divideents{exp}
\item{\vskip -1.9ex 
\index{exp(Matrix, int, double, Vector, Vector, boolean)}
\hypertarget{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, boolean)}{\membername{exp}}
{\tt public static double\lbrack \rbrack \ {\bf exp}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt no.uib.cipr.matrix.Vector} {\bf leftVec},
{\tt no.uib.cipr.matrix.Vector} {\bf rightVec},
{\tt boolean} {\bf useUniformization} )
\label{jphase.MatrixUtils.exp(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, boolean)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns leftVec * exp(A x) * rightVec, for all values x = 0 + i*delta, i=0,...,n. It uses the uniformization algorithm or the RungeKutta method
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt n} -- number of evaluation points}
   \item{
\sld
{\tt delta} -- separation between evaluation points}
   \item{
\sld
{\tt leftVec} -- Vector}
   \item{
\sld
{\tt rightVec} -- Vector}
   \item{
\sld
{\tt useUniformization} -- true if the method to use is Uniformization, false if it is RungeKutta}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftVec * exp(A x) * rightVec 
}%end item
\end{itemize}
}%end item
\divideents{expRunge}
\item{\vskip -1.9ex 
\index{expRunge(Matrix, int, double, Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.expRunge(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{expRunge}}
{\tt public static no.uib.cipr.matrix.Matrix\lbrack \rbrack \ {\bf expRunge}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftMat},
{\tt no.uib.cipr.matrix.Matrix} {\bf rightMat} )
\label{jphase.MatrixUtils.expRunge(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for all values x = 0 + i*delta, i=0,...,n. It uses the RungeKutta method
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt n} -- number of evaluation points}
   \item{
\sld
{\tt delta} -- separation between evaluation points}
   \item{
\sld
{\tt leftMat} -- Matrix}
   \item{
\sld
{\tt rightMat} -- Matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftMat * exp(A x) * rightMat, for x = 0 + i*delta, i=0,...,n 
}%end item
\end{itemize}
}%end item
\divideents{expTimesOnes}
\item{\vskip -1.9ex 
\index{expTimesOnes(Matrix, double)}
\hypertarget{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, double)}{\membername{expTimesOnes}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf expTimesOnes}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt double} {\bf x} )
\label{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns exp(A x) * Ones, for the value x. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt x} -- evaluation point}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
exp(A x) * Ones 
}%end item
\end{itemize}
}%end item
\divideents{expTimesOnes}
\item{\vskip -1.9ex 
\index{expTimesOnes(Matrix, double, Matrix)}
\hypertarget{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix)}{\membername{expTimesOnes}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf expTimesOnes}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt double} {\bf x},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftMat} )
\label{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns leftMat * exp(A x) * Ones, for the value x. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt x} -- evaluation point}
   \item{
\sld
{\tt leftMat} -- Matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftMat * exp(A x) * rightMat 
}%end item
\end{itemize}
}%end item
\divideents{expTimesOnes}
\item{\vskip -1.9ex 
\index{expTimesOnes(Matrix, double, Vector)}
\hypertarget{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Vector)}{\membername{expTimesOnes}}
{\tt public static double\ {\bf expTimesOnes}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt double} {\bf x},
{\tt no.uib.cipr.matrix.Vector} {\bf leftVec} )
\label{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns leftVec * exp(A x) * OnesVector, for the value x. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt x} -- evaluation point}
   \item{
\sld
{\tt leftVec} -- Vector}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftVec * exp(A x) * OnesVector 
}%end item
\end{itemize}
}%end item
\divideents{expTimesOnes}
\item{\vskip -1.9ex 
\index{expTimesOnes(Matrix, int, double, Matrix)}
\hypertarget{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix)}{\membername{expTimesOnes}}
{\tt public static no.uib.cipr.matrix.Matrix\lbrack \rbrack \ {\bf expTimesOnes}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftMat} )
\label{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns leftMat * exp(A x) * OnesCol, for all values x = 0 + i*delta, i=0,...,n. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt n} -- number of evaluation points}
   \item{
\sld
{\tt delta} -- separation between evaluation points}
   \item{
\sld
{\tt leftMat} -- Matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftMat * exp(A x) * OnesCol, for x = 0 + i*delta, i=0,...,n 
}%end item
\end{itemize}
}%end item
\divideents{expTimesOnes}
\item{\vskip -1.9ex 
\index{expTimesOnes(Matrix, int, double, Vector)}
\hypertarget{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector)}{\membername{expTimesOnes}}
{\tt public static double\lbrack \rbrack \ {\bf expTimesOnes}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt no.uib.cipr.matrix.Vector} {\bf leftVec} )
\label{jphase.MatrixUtils.expTimesOnes(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns leftVec * exp(A x) * OnesVector, for all values x = 0 + i*delta, i=0,...,n. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt n} -- number of evaluation points}
   \item{
\sld
{\tt delta} -- separation between evaluation points}
   \item{
\sld
{\tt leftVec} -- Vector}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftVec * exp(A x) * OnesVector, for x = 0 + i*delta, i=0,...,n 
}%end item
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(Matrix, double\lbrack \rbrack , Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double[], no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{expUnif}}
{\tt public static no.uib.cipr.matrix.Matrix\lbrack \rbrack \ {\bf expUnif}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt double\lbrack \rbrack } {\bf times},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftMat},
{\tt no.uib.cipr.matrix.Matrix} {\bf rightMat} )
\label{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double[], no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for all values x in times. It uses the uniformization algorithm
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt times} -- evaluation points}
   \item{
\sld
{\tt leftMat} -- Matrix}
   \item{
\sld
{\tt rightMat} -- Matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftMat * exp(A x) * rightMat 
}%end item
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(Matrix, double\lbrack \rbrack , Matrix, Matrix, int)}
\hypertarget{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double[], no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, int)}{\membername{expUnif}}
{\tt public static no.uib.cipr.matrix.Matrix\lbrack \rbrack \ {\bf expUnif}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt double\lbrack \rbrack } {\bf times},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftMat},
{\tt no.uib.cipr.matrix.Matrix} {\bf rightMat},
{\tt int} {\bf truncate} )
\label{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double[], no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for all values x in times. It uses the uniformization algorithm
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt times} -- evaluation points}
   \item{
\sld
{\tt leftMat} -- Matrix}
   \item{
\sld
{\tt rightMat} -- Matrix}
   \item{
\sld
{\tt truncate} -- upper bound for iterations}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftMat * exp(A x) * rightMat 
}%end item
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(Matrix, double\lbrack \rbrack , Vector, Vector, int)}
\hypertarget{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double[], no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, int)}{\membername{expUnif}}
{\tt public static double\lbrack \rbrack \ {\bf expUnif}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt double\lbrack \rbrack } {\bf times},
{\tt no.uib.cipr.matrix.Vector} {\bf leftVec},
{\tt no.uib.cipr.matrix.Vector} {\bf rightVec},
{\tt int} {\bf truncate} )
\label{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double[], no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftVec * exp(A x) * rightVec, for all values x in times. It uses the uniformization algorithm
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt times} -- evaluation points}
   \item{
\sld
{\tt leftVec} -- Vector}
   \item{
\sld
{\tt rightVec} -- Vector}
   \item{
\sld
{\tt truncate} -- upper bound for iterations}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftVec * exp(A x) * rightVec 
}%end item
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(Matrix, double, Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{expUnif}}
{\tt public static no.uib.cipr.matrix.Matrix\lbrack \rbrack \ {\bf expUnif}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt double} {\bf x},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftMat},
{\tt no.uib.cipr.matrix.Matrix} {\bf rightMat} )
\label{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for the value x. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt x} -- evaluation point}
   \item{
\sld
{\tt leftMat} -- Matrix}
   \item{
\sld
{\tt rightMat} -- Matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftMat * exp(A x) * rightMat 
}%end item
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(Matrix, int, double, Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{expUnif}}
{\tt public static no.uib.cipr.matrix.Matrix\lbrack \rbrack \ {\bf expUnif}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftMat},
{\tt no.uib.cipr.matrix.Matrix} {\bf rightMat} )
\label{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for all values x = 0 + i*delta, i=0,...,n. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt n} -- number of evaluation points}
   \item{
\sld
{\tt delta} -- separation between evaluation points}
   \item{
\sld
{\tt leftMat} -- Matrix}
   \item{
\sld
{\tt rightMat} -- Matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftMat * exp(A x) * rightMat 
}%end item
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(Matrix, int, double, Matrix, Matrix, int)}
\hypertarget{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, int)}{\membername{expUnif}}
{\tt public static no.uib.cipr.matrix.Matrix\lbrack \rbrack \ {\bf expUnif}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt no.uib.cipr.matrix.Matrix} {\bf leftMat},
{\tt no.uib.cipr.matrix.Matrix} {\bf rightMat},
{\tt int} {\bf truncate} )
\label{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftMat * exp(A x) * rightMat, for all values x = 0 + i*delta, i=0,...,n. It uses the uniformization algorithm
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt n} -- num of evaluation points}
   \item{
\sld
{\tt delta} -- evaluation points separation}
   \item{
\sld
{\tt leftMat} -- Matrix}
   \item{
\sld
{\tt rightMat} -- Matrix}
   \item{
\sld
{\tt truncate} -- upper bound for iterations}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftMat * exp(A x) * rightMat 
}%end item
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(Matrix, int, double, Vector, Vector)}
\hypertarget{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{\membername{expUnif}}
{\tt public static double\lbrack \rbrack \ {\bf expUnif}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt no.uib.cipr.matrix.Vector} {\bf leftVec},
{\tt no.uib.cipr.matrix.Vector} {\bf rightVec} )
\label{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftVec * exp(A x) * rightVec, for all values x = 0 + i*delta, i=0,...,n. It uses the uniformization algorithm as described in page 60 of Latouche and Ramaswami
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt n} -- number of evaluation points}
   \item{
\sld
{\tt delta} -- separation between evaluation points}
   \item{
\sld
{\tt leftVec} -- Vector}
   \item{
\sld
{\tt rightVec} -- Vector}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftVec * exp(A x) * rightVec 
}%end item
\end{itemize}
}%end item
\divideents{expUnif}
\item{\vskip -1.9ex 
\index{expUnif(Matrix, int, double, Vector, Vector, int)}
\hypertarget{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, int)}{\membername{expUnif}}
{\tt public static double\lbrack \rbrack \ {\bf expUnif}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf n},
{\tt double} {\bf delta},
{\tt no.uib.cipr.matrix.Vector} {\bf leftVec},
{\tt no.uib.cipr.matrix.Vector} {\bf rightVec},
{\tt int} {\bf truncate} )
\label{jphase.MatrixUtils.expUnif(no.uib.cipr.matrix.Matrix, int, double, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes leftVec * exp(A x) * rightVec, for all values x = 0 + i*delta, i=0,...,n. It uses the uniformization algorithm
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt n} -- num of evaluation points}
   \item{
\sld
{\tt delta} -- evaluation points separation}
   \item{
\sld
{\tt leftVec} -- Vector}
   \item{
\sld
{\tt rightVec} -- Vector}
   \item{
\sld
{\tt truncate} -- upper bound for iterations}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftVec * exp(A x) * rightVec 
}%end item
\end{itemize}
}%end item
\divideents{kronecker}
\item{\vskip -1.9ex 
\index{kronecker(Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{kronecker}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf kronecker}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt no.uib.cipr.matrix.Matrix} {\bf B} )
\label{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the kronecker product of two matrices in dense format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt B} -- Matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Kronecker Product A x B 
}%end item
\end{itemize}
}%end item
\divideents{kronecker}
\item{\vskip -1.9ex 
\index{kronecker(Matrix, Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{kronecker}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf kronecker}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt no.uib.cipr.matrix.Matrix} {\bf B},
{\tt no.uib.cipr.matrix.Matrix} {\bf res} )
\label{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the kronecker product of two matrices in the predefined storage format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt B} -- Matrix}
   \item{
\sld
{\tt res} -- Matrix such that res.numCols = A.numCols * B.numCols and res.numRows = A.numRows * B.numRows}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Kronecker Product A x B 
}%end item
\end{itemize}
}%end item
\divideents{kronecker}
\item{\vskip -1.9ex 
\index{kronecker(Matrix, Vector, Matrix)}
\hypertarget{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{\membername{kronecker}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf kronecker}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt no.uib.cipr.matrix.Vector} {\bf B},
{\tt no.uib.cipr.matrix.Matrix} {\bf res} )
\label{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the kronecker product of one matrix with one vector (Matrix x Vector) in dense format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt B} -- Vector}
   \item{
\sld
{\tt res} -- Matrix such that res.numRows = A.numRows and res.numCols = A.numCols * B.size}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Kronecker Product A x B 
}%end item
\end{itemize}
}%end item
\divideents{kronecker}
\item{\vskip -1.9ex 
\index{kronecker(Vector, Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{kronecker}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf kronecker}( {\tt no.uib.cipr.matrix.Vector} {\bf A},
{\tt no.uib.cipr.matrix.Matrix} {\bf B},
{\tt no.uib.cipr.matrix.Matrix} {\bf res} )
\label{jphase.MatrixUtils.kronecker(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the kronecker product of one vector with one matrix (Vector x Matrix) in dense format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Vector}
   \item{
\sld
{\tt B} -- Matrix}
   \item{
\sld
{\tt res} -- Matrix such that res.numRows = A.size * B.numRows and res.numCols = B.numCols}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Kronecker Product A x B 
}%end item
\end{itemize}
}%end item
\divideents{kroneckerSum}
\item{\vskip -1.9ex 
\index{kroneckerSum(Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.kroneckerSum(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{kroneckerSum}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf kroneckerSum}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt no.uib.cipr.matrix.Matrix} {\bf B} )
\label{jphase.MatrixUtils.kroneckerSum(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the kronecker sum of two matrices in dense format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt B} -- Matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Kronecker Sum A + B 
}%end item
\end{itemize}
}%end item
\divideents{kroneckerSum}
\item{\vskip -1.9ex 
\index{kroneckerSum(Matrix, Matrix, Matrix)}
\hypertarget{jphase.MatrixUtils.kroneckerSum(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}{\membername{kroneckerSum}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf kroneckerSum}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt no.uib.cipr.matrix.Matrix} {\bf B},
{\tt no.uib.cipr.matrix.Matrix} {\bf res} )
\label{jphase.MatrixUtils.kroneckerSum(no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the kronecker sum of two matrices and stores it in the predefined format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix}
   \item{
\sld
{\tt B} -- Matrix}
   \item{
\sld
{\tt res} -- Result Matrix such that res.numRows = A.numRows * B.numRows and res.numCols = A.numCols * B.numCols}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Kronecker Sum A + B 
}%end item
\end{itemize}
}%end item
\divideents{kroneckerVectors}
\item{\vskip -1.9ex 
\index{kroneckerVectors(DenseVector, DenseVector)}
\hypertarget{jphase.MatrixUtils.kroneckerVectors(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseVector)}{\membername{kroneckerVectors}}
{\tt public static no.uib.cipr.matrix.DenseVector\ {\bf kroneckerVectors}( {\tt no.uib.cipr.matrix.DenseVector} {\bf A},
{\tt no.uib.cipr.matrix.DenseVector} {\bf B} )
\label{jphase.MatrixUtils.kroneckerVectors(no.uib.cipr.matrix.DenseVector, no.uib.cipr.matrix.DenseVector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the kronecker product of two vectors in dense format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Vector}
   \item{
\sld
{\tt B} -- Vector}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Kronecker Product A x B 
}%end item
\end{itemize}
}%end item
\divideents{kroneckerVectors}
\item{\vskip -1.9ex 
\index{kroneckerVectors(Vector, Vector, Vector)}
\hypertarget{jphase.MatrixUtils.kroneckerVectors(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{\membername{kroneckerVectors}}
{\tt public static no.uib.cipr.matrix.Vector\ {\bf kroneckerVectors}( {\tt no.uib.cipr.matrix.Vector} {\bf A},
{\tt no.uib.cipr.matrix.Vector} {\bf B},
{\tt no.uib.cipr.matrix.Vector} {\bf res} )
\label{jphase.MatrixUtils.kroneckerVectors(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the kronecker product of two vectors in ths predefined format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Vector}
   \item{
\sld
{\tt B} -- Vector}
   \item{
\sld
{\tt res} -- Vector such that res.size = A.size * B.size}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Kronecker Product A x B 
}%end item
\end{itemize}
}%end item
\divideents{matPower}
\item{\vskip -1.9ex 
\index{matPower(Matrix, int)}
\hypertarget{jphase.MatrixUtils.matPower(no.uib.cipr.matrix.Matrix, int)}{\membername{matPower}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf matPower}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf k} )
\label{jphase.MatrixUtils.matPower(no.uib.cipr.matrix.Matrix, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes k power of the matrix A
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- matrix base}
   \item{
\sld
{\tt k} -- exponent}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
A$\wedge$k 
}%end item
\end{itemize}
}%end item
\divideents{matPower}
\item{\vskip -1.9ex 
\index{matPower(Matrix, int, Vector, Vector)}
\hypertarget{jphase.MatrixUtils.matPower(no.uib.cipr.matrix.Matrix, int, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{\membername{matPower}}
{\tt public static double\ {\bf matPower}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf k},
{\tt no.uib.cipr.matrix.Vector} {\bf leftVec},
{\tt no.uib.cipr.matrix.Vector} {\bf rightVec} )
\label{jphase.MatrixUtils.matPower(no.uib.cipr.matrix.Matrix, int, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the kth power of the matrix A premultiplied by leftVec and postmultiplied by rightVec
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix base}
   \item{
\sld
{\tt k} -- exponent}
   \item{
\sld
{\tt leftVec} -- Vector}
   \item{
\sld
{\tt rightVec} -- Vector}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftVec * A$\wedge$k * rightVec 
}%end item
\end{itemize}
}%end item
\divideents{multVector}
\item{\vskip -1.9ex 
\index{multVector(Vector, Vector, Matrix)}
\hypertarget{jphase.MatrixUtils.multVector(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{\membername{multVector}}
{\tt public static no.uib.cipr.matrix.Matrix\ {\bf multVector}( {\tt no.uib.cipr.matrix.Vector} {\bf A},
{\tt no.uib.cipr.matrix.Vector} {\bf B},
{\tt no.uib.cipr.matrix.Matrix} {\bf res} )
\label{jphase.MatrixUtils.multVector(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the producto of two vectors A x B$\wedge$T
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Vector}
   \item{
\sld
{\tt B} -- Vector}
   \item{
\sld
{\tt res} -- Vector to store the resulting matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
res = A x B$\wedge$T 
}%end item
\end{itemize}
}%end item
\divideents{OnesCol}
\item{\vskip -1.9ex 
\index{OnesCol(int)}
\hypertarget{jphase.MatrixUtils.OnesCol(int)}{\membername{OnesCol}}
{\tt public static no.uib.cipr.matrix.DenseMatrix\ {\bf OnesCol}( {\tt int} {\bf m} )
\label{jphase.MatrixUtils.OnesCol(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a one-column matrix in dense format with one in every entry
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt m} -- size of the matrix (m, 1)}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
One column matrix with one in every entry 
}%end item
\end{itemize}
}%end item
\divideents{OnesRow}
\item{\vskip -1.9ex 
\index{OnesRow(int)}
\hypertarget{jphase.MatrixUtils.OnesRow(int)}{\membername{OnesRow}}
{\tt public static no.uib.cipr.matrix.DenseMatrix\ {\bf OnesRow}( {\tt int} {\bf m} )
\label{jphase.MatrixUtils.OnesRow(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a one-row matrix in dense format with one in every entry
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt m} -- size of the matrix (1, m)}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Row matrix with one in every entry 
}%end item
\end{itemize}
}%end item
\divideents{OnesVector}
\item{\vskip -1.9ex 
\index{OnesVector(int)}
\hypertarget{jphase.MatrixUtils.OnesVector(int)}{\membername{OnesVector}}
{\tt public static no.uib.cipr.matrix.DenseVector\ {\bf OnesVector}( {\tt int} {\bf m} )
\label{jphase.MatrixUtils.OnesVector(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a DenseVector with one in every entry
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt m} -- size of the DenseVector}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
DenseVector with one in every entry 
}%end item
\end{itemize}
}%end item
\divideents{OnesVector}
\item{\vskip -1.9ex 
\index{OnesVector(Vector)}
\hypertarget{jphase.MatrixUtils.OnesVector(no.uib.cipr.matrix.Vector)}{\membername{OnesVector}}
{\tt public static no.uib.cipr.matrix.Vector\ {\bf OnesVector}( {\tt no.uib.cipr.matrix.Vector} {\bf vec} )
\label{jphase.MatrixUtils.OnesVector(no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a Vector with one in every entry in the predefined storage format
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt vec} -- Vector to be modified}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Vector with one in every entry 
}%end item
\end{itemize}
}%end item
\divideents{pow}
\item{\vskip -1.9ex 
\index{pow(double, int)}
\hypertarget{jphase.MatrixUtils.pow(double, int)}{\membername{pow}}
{\tt public static double\ {\bf pow}( {\tt double} {\bf x},
{\tt int} {\bf n} )
\label{jphase.MatrixUtils.pow(double, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Calculates x$\wedge$n
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- base}
   \item{
\sld
{\tt n} -- exponent}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
x$\wedge$n 
}%end item
\end{itemize}
}%end item
\divideents{scalar}
\item{\vskip -1.9ex 
\index{scalar(Matrix)}
\hypertarget{jphase.MatrixUtils.scalar(no.uib.cipr.matrix.Matrix)}{\membername{scalar}}
{\tt public static double\ {\bf scalar}( {\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.MatrixUtils.scalar(no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the value of the position (0,0) in the matrix, if its number of columns is equal to one (1)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- matrix}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Value of the position (0,0) in the matrix 
}%end item
\end{itemize}
}%end item
\divideents{sumMatPower}
\item{\vskip -1.9ex 
\index{sumMatPower(Matrix, int, Vector, Vector)}
\hypertarget{jphase.MatrixUtils.sumMatPower(no.uib.cipr.matrix.Matrix, int, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}{\membername{sumMatPower}}
{\tt public static double\ {\bf sumMatPower}( {\tt no.uib.cipr.matrix.Matrix} {\bf A},
{\tt int} {\bf k},
{\tt no.uib.cipr.matrix.Vector} {\bf leftVec},
{\tt no.uib.cipr.matrix.Vector} {\bf rightVec} )
\label{jphase.MatrixUtils.sumMatPower(no.uib.cipr.matrix.Matrix, int, no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the sum of the first k terms of the succesion T$\wedge$(j-1), from j = 1
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- Matrix base}
   \item{
\sld
{\tt k} -- maximum exponent}
   \item{
\sld
{\tt leftVec} -- }
   \item{
\sld
{\tt rightVec} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
leftVec * sum\_(j=1)$\wedge$k T$\wedge$(j-1) * rightVec 
}%end item
\end{itemize}
}%end item
\divideents{variance}
\item{\vskip -1.9ex 
\index{variance(double\lbrack \rbrack )}
\hypertarget{jphase.MatrixUtils.variance(double[])}{\membername{variance}}
{\tt public static double\ {\bf variance}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.MatrixUtils.variance(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the variance of the data
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- data trace}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Data Variance 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{PhaseVarSet}
\subsection{\label{jphase.PhaseVarSet}\index{PhaseVarSet}{\bf {\it Class} PhaseVarSet}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.PhaseVarSet}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class PhaseVarSet
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
java.io.Serializable}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.PhaseVarSet.fileName}{{\bf fileName}} \\
\hyperlink{jphase.PhaseVarSet.isDirty}{{\bf isDirty}} \\
\hyperlink{jphase.PhaseVarSet.name}{{\bf name}} \\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.PhaseVarSet()}{{\bf PhaseVarSet()}} Default constructor\\
\hyperlink{jphase.PhaseVarSet(jphase.PhaseVar[])}{{\bf PhaseVarSet(PhaseVar\lbrack \rbrack )}} Contructs a new set with specified variables\\
\hyperlink{jphase.PhaseVarSet(java.lang.String)}{{\bf PhaseVarSet(String)}} Contructs a new set with specified name\\
\hyperlink{jphase.PhaseVarSet(java.lang.String, jphase.PhaseVar[])}{{\bf PhaseVarSet(String, PhaseVar\lbrack \rbrack )}} Contructs a new set with specified name and variables\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.PhaseVarSet.add(jphase.PhaseVar)}{{\bf add(PhaseVar)}} \\
\hyperlink{jphase.PhaseVarSet.getMeans()}{{\bf getMeans()}} Returns a vector with the means of all elements\\
\hyperlink{jphase.PhaseVarSet.indexOfName(java.lang.String)}{{\bf indexOfName(String)}} Returns the index in the det of the variables with the specified name\\
\hyperlink{jphase.PhaseVarSet.newUniqueVarName(java.lang.String)}{{\bf newUniqueVarName(String)}} Builds a unique name for a variable from a proposed name\\
\hyperlink{jphase.PhaseVarSet.numVars()}{{\bf numVars()}} Returns the number of variables in the set\\
\hyperlink{jphase.PhaseVarSet.open(java.lang.String)}{{\bf open(String)}} Reads a .sed file with the information of a set\\
\hyperlink{jphase.PhaseVarSet.openTxt(java.lang.String)}{{\bf openTxt(String)}} Reads a .txt file with the information of a set\\
\hyperlink{jphase.PhaseVarSet.remove(jphase.PhaseVar)}{{\bf remove(PhaseVar)}} Remove the specified variable\\
\hyperlink{jphase.PhaseVarSet.remove(java.lang.String)}{{\bf remove(String)}} Removes the variable with specified name\\
\hyperlink{jphase.PhaseVarSet.save()}{{\bf save()}} \\
\hyperlink{jphase.PhaseVarSet.save(java.lang.String)}{{\bf save(String)}} \\
\hyperlink{jphase.PhaseVarSet.saveTxt()}{{\bf saveTxt()}} Saves the set information in a file\\
\hyperlink{jphase.PhaseVarSet.saveTxt(java.lang.String)}{{\bf saveTxt(String)}} Saves the set information in a file\\
\hyperlink{jphase.PhaseVarSet.toString()}{{\bf toString()}} \\
\hyperlink{jphase.PhaseVarSet.varAt(int)}{{\bf varAt(int)}} Returns the variable at index i\\
\end{verse}
}
\subsubsection{Serializable Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{vars}
private java.util.List {\bf vars}\begin{itemize}
\item{\vskip -.9ex 
Variables in the set}
\end{itemize}
}
\item{
\index{names}
private java.util.List {\bf names}\begin{itemize}
\item{\vskip -.9ex 
Vames of the variables in the set}
\end{itemize}
}
\item{
\index{name}
public java.lang.String {\bf name}}
\item{
\index{fileName}
public java.lang.String {\bf fileName}}
\item{
\index{isDirty}
public boolean {\bf isDirty}}
\end{itemize}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{name}
\label{jphase.PhaseVarSet.name}\hypertarget{jphase.PhaseVarSet.name}{public java.lang.String {\bf name}}
}
\item{
\index{fileName}
\label{jphase.PhaseVarSet.fileName}\hypertarget{jphase.PhaseVarSet.fileName}{public java.lang.String {\bf fileName}}
}
\item{
\index{isDirty}
\label{jphase.PhaseVarSet.isDirty}\hypertarget{jphase.PhaseVarSet.isDirty}{public boolean {\bf isDirty}}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{PhaseVarSet()}
\hypertarget{jphase.PhaseVarSet()}{\membername{PhaseVarSet}}
{\tt public\ {\bf PhaseVarSet}(  )
\label{jphase.PhaseVarSet()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Default constructor
}
\end{itemize}
}%end item
\divideents{PhaseVarSet}
\item{\vskip -1.9ex 
\index{PhaseVarSet(PhaseVar\lbrack \rbrack )}
\hypertarget{jphase.PhaseVarSet(jphase.PhaseVar[])}{\membername{PhaseVarSet}}
{\tt public\ {\bf PhaseVarSet}( {\tt PhaseVar\lbrack \rbrack } {\bf vars} )
\label{jphase.PhaseVarSet(jphase.PhaseVar[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Contructs a new set with specified variables
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt vars} -- Set variables}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{PhaseVarSet}
\item{\vskip -1.9ex 
\index{PhaseVarSet(String)}
\hypertarget{jphase.PhaseVarSet(java.lang.String)}{\membername{PhaseVarSet}}
{\tt public\ {\bf PhaseVarSet}( {\tt java.lang.String} {\bf nam} )
\label{jphase.PhaseVarSet(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Contructs a new set with specified name
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt nam} -- Set name}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{PhaseVarSet}
\item{\vskip -1.9ex 
\index{PhaseVarSet(String, PhaseVar\lbrack \rbrack )}
\hypertarget{jphase.PhaseVarSet(java.lang.String, jphase.PhaseVar[])}{\membername{PhaseVarSet}}
{\tt public\ {\bf PhaseVarSet}( {\tt java.lang.String} {\bf nam},
{\tt PhaseVar\lbrack \rbrack } {\bf vars} )
\label{jphase.PhaseVarSet(java.lang.String, jphase.PhaseVar[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Contructs a new set with specified name and variables
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt nam} -- Set name}
   \item{
\sld
{\tt vars} -- Set variables}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{add(PhaseVar)}
\hypertarget{jphase.PhaseVarSet.add(jphase.PhaseVar)}{\membername{add}}
{\tt public void\ {\bf add}( {\tt PhaseVar} {\bf var} )
\label{jphase.PhaseVarSet.add(jphase.PhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt var} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMeans}
\item{\vskip -1.9ex 
\index{getMeans()}
\hypertarget{jphase.PhaseVarSet.getMeans()}{\membername{getMeans}}
{\tt public double\lbrack \rbrack \ {\bf getMeans}(  )
\label{jphase.PhaseVarSet.getMeans()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a vector with the means of all elements
}
\item{{\bf Returns} -- 
Vector with the means of all elements 
}%end item
\end{itemize}
}%end item
\divideents{indexOfName}
\item{\vskip -1.9ex 
\index{indexOfName(String)}
\hypertarget{jphase.PhaseVarSet.indexOfName(java.lang.String)}{\membername{indexOfName}}
{\tt public int\ {\bf indexOfName}( {\tt java.lang.String} {\bf s} )
\label{jphase.PhaseVarSet.indexOfName(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the index in the det of the variables with the specified name
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt s} -- Name to be evaluated}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Index in the det of the variables with the specified name 
}%end item
\end{itemize}
}%end item
\divideents{newUniqueVarName}
\item{\vskip -1.9ex 
\index{newUniqueVarName(String)}
\hypertarget{jphase.PhaseVarSet.newUniqueVarName(java.lang.String)}{\membername{newUniqueVarName}}
{\tt public java.lang.String\ {\bf newUniqueVarName}( {\tt java.lang.String} {\bf proposedName} )
\label{jphase.PhaseVarSet.newUniqueVarName(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Builds a unique name for a variable from a proposed name
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt proposedName} -- proposed name}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Unique name for a variable from a proposed name 
}%end item
\end{itemize}
}%end item
\divideents{numVars}
\item{\vskip -1.9ex 
\index{numVars()}
\hypertarget{jphase.PhaseVarSet.numVars()}{\membername{numVars}}
{\tt public int\ {\bf numVars}(  )
\label{jphase.PhaseVarSet.numVars()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of variables in the set
}
\item{{\bf Returns} -- 
Number of variables in the set 
}%end item
\end{itemize}
}%end item
\divideents{open}
\item{\vskip -1.9ex 
\index{open(String)}
\hypertarget{jphase.PhaseVarSet.open(java.lang.String)}{\membername{open}}
{\tt public static PhaseVarSet\ {\bf open}( {\tt java.lang.String} {\bf fileName} ) throws java.lang.Exception
\label{jphase.PhaseVarSet.open(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Reads a .sed file with the information of a set
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt fileName} -- File with the variable set}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Set of variables in the file 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.lang.Exception} -- IOException}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{openTxt}
\item{\vskip -1.9ex 
\index{openTxt(String)}
\hypertarget{jphase.PhaseVarSet.openTxt(java.lang.String)}{\membername{openTxt}}
{\tt public static PhaseVarSet\ {\bf openTxt}( {\tt java.lang.String} {\bf fileName} ) throws java.lang.Exception
\label{jphase.PhaseVarSet.openTxt(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Reads a .txt file with the information of a set
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt fileName} -- File with the variable set}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Set of variables in the file 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.lang.Exception} -- IOException}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\index{remove(PhaseVar)}
\hypertarget{jphase.PhaseVarSet.remove(jphase.PhaseVar)}{\membername{remove}}
{\tt public void\ {\bf remove}( {\tt PhaseVar} {\bf var} )
\label{jphase.PhaseVarSet.remove(jphase.PhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Remove the specified variable
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt var} -- variable to remove}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{remove}
\item{\vskip -1.9ex 
\index{remove(String)}
\hypertarget{jphase.PhaseVarSet.remove(java.lang.String)}{\membername{remove}}
{\tt public int\ {\bf remove}( {\tt java.lang.String} {\bf varName} )
\label{jphase.PhaseVarSet.remove(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Removes the variable with specified name
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt varName} -- name of the varible to remove}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
index of the removed variable 
}%end item
\end{itemize}
}%end item
\divideents{save}
\item{\vskip -1.9ex 
\index{save()}
\hypertarget{jphase.PhaseVarSet.save()}{\membername{save}}
{\tt public void\ {\bf save}(  ) throws java.io.IOException
\label{jphase.PhaseVarSet.save()}}%end signature
\begin{itemize}
\sld
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.io.IOException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{save}
\item{\vskip -1.9ex 
\index{save(String)}
\hypertarget{jphase.PhaseVarSet.save(java.lang.String)}{\membername{save}}
{\tt public void\ {\bf save}( {\tt java.lang.String} {\bf fileName} ) throws java.io.IOException
\label{jphase.PhaseVarSet.save(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt fileName} -- }
  \end{itemize}
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.io.IOException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{saveTxt}
\item{\vskip -1.9ex 
\index{saveTxt()}
\hypertarget{jphase.PhaseVarSet.saveTxt()}{\membername{saveTxt}}
{\tt public boolean\ {\bf saveTxt}(  ) throws java.io.IOException
\label{jphase.PhaseVarSet.saveTxt()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Saves the set information in a file
}
\item{{\bf Returns} -- 
True if the file could be saved, false elsewhere 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.io.IOException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{saveTxt}
\item{\vskip -1.9ex 
\index{saveTxt(String)}
\hypertarget{jphase.PhaseVarSet.saveTxt(java.lang.String)}{\membername{saveTxt}}
{\tt public boolean\ {\bf saveTxt}( {\tt java.lang.String} {\bf fileName} ) throws java.io.IOException
\label{jphase.PhaseVarSet.saveTxt(java.lang.String)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Saves the set information in a file
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt fileName} -- File name}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
True if the file could be saved, false elsewhere 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.io.IOException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jphase.PhaseVarSet.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jphase.PhaseVarSet.toString()}}%end signature
}%end item
\divideents{varAt}
\item{\vskip -1.9ex 
\index{varAt(int)}
\hypertarget{jphase.PhaseVarSet.varAt(int)}{\membername{varAt}}
{\tt public PhaseVar\ {\bf varAt}( {\tt int} {\bf i} )
\label{jphase.PhaseVarSet.varAt(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the variable at index i
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- Index of the required variables}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Variable at intex i 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{Poly}
\subsection{\label{jphase.Poly}\index{Poly}{\bf {\it Class} Poly}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.Poly}{}\vskip .1in 
This class represents a polynomial.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class Poly
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.Poly()}{{\bf Poly()}} ` * Creates a Polynomial = 0.0.\\
\hyperlink{jphase.Poly(double[])}{{\bf Poly(double\lbrack \rbrack )}} Build a Plynomial with these coefficients\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.Poly.addTerm(double, int)}{{\bf addTerm(double, int)}} Adds this term: cf * t$\wedge$n\\
\hyperlink{jphase.Poly.evaluate(double)}{{\bf evaluate(double)}} Returns the value of this polynomial at x.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{Poly()}
\hypertarget{jphase.Poly()}{\membername{Poly}}
{\tt public\ {\bf Poly}(  )
\label{jphase.Poly()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

` * Creates a Polynomial = 0.0.
}
\end{itemize}
}%end item
\divideents{Poly}
\item{\vskip -1.9ex 
\index{Poly(double\lbrack \rbrack )}
\hypertarget{jphase.Poly(double[])}{\membername{Poly}}
{\tt public\ {\bf Poly}( {\tt double\lbrack \rbrack } {\bf cf} )
\label{jphase.Poly(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Build a Plynomial with these coefficients
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt cf} -- Coefficients}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{addTerm(double, int)}
\hypertarget{jphase.Poly.addTerm(double, int)}{\membername{addTerm}}
{\tt public Poly\ {\bf addTerm}( {\tt double} {\bf coeff},
{\tt int} {\bf n} )
\label{jphase.Poly.addTerm(double, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Adds this term: cf * t$\wedge$n
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt coeff} -- Coefficient of the term to be added}
   \item{
\sld
{\tt n} -- Exponent of the term to be added}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Modified Poynomial 
}%end item
\end{itemize}
}%end item
\divideents{evaluate}
\item{\vskip -1.9ex 
\index{evaluate(double)}
\hypertarget{jphase.Poly.evaluate(double)}{\membername{evaluate}}
{\tt public double\ {\bf evaluate}( {\tt double} {\bf x} )
\label{jphase.Poly.evaluate(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the value of this polynomial at x.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- evaluation point}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Value of this polynomial at x. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{SparseContPhaseVar}
\subsection{\label{jphase.SparseContPhaseVar}\index{SparseContPhaseVar}{\bf {\it Class} SparseContPhaseVar}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.SparseContPhaseVar}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class SparseContPhaseVar
\\ {\bf extends} jphase.AbstractContPhaseVar
\refdefined{jphase.AbstractContPhaseVar}}}}
\subsubsection{Version}{0.1 This class allows the creation and manipulation of Continuous Phase-type distributions represented by sparse (Flexible Compressed Row) matrices.}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.SparseContPhaseVar.A}{{\bf A}} Rate Matrix in Sparse representation (CompRowMatrix)\\
\hyperlink{jphase.SparseContPhaseVar.alpha}{{\bf alpha}} Initial Probability distribution vector\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.SparseContPhaseVar(double[], double[][])}{{\bf SparseContPhaseVar(double\lbrack \rbrack , double\lbrack \rbrack \lbrack \rbrack )}} Construcs a continuous Phase-type Distribution with sparse representation (CompRowMatrix)\\
\hyperlink{jphase.SparseContPhaseVar(int)}{{\bf SparseContPhaseVar(int)}} Construcs an empty Continuous Phase-type Distribution of size n with sparse representation (CompRowMatrix)\\
\hyperlink{jphase.SparseContPhaseVar(no.uib.cipr.matrix.sparse.SparseVector, no.uib.cipr.matrix.sparse.FlexCompRowMatrix)}{{\bf SparseContPhaseVar(SparseVector, FlexCompRowMatrix)}} Construcs a continuous Phase-type Distribution with sparse representation (CompRowMatrix)\\
\hyperlink{jphase.SparseContPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{{\bf SparseContPhaseVar(Vector, Matrix)}} Construcs a continuous Phase-type Distribution with sparse representation (CompRowMatrix)\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.SparseContPhaseVar.copy()}{{\bf copy()}} \\
\hyperlink{jphase.SparseContPhaseVar.getMatrix()}{{\bf getMatrix()}} \\
\hyperlink{jphase.SparseContPhaseVar.getVector()}{{\bf getVector()}} \\
\hyperlink{jphase.SparseContPhaseVar.newVar(int)}{{\bf newVar(int)}} \\
\hyperlink{jphase.SparseContPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{{\bf setMatrix(Matrix)}} \\
\hyperlink{jphase.SparseContPhaseVar.setVector(no.uib.cipr.matrix.Vector)}{{\bf setVector(Vector)}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{A}
\label{jphase.SparseContPhaseVar.A}\hypertarget{jphase.SparseContPhaseVar.A}{protected no.uib.cipr.matrix.sparse.FlexCompRowMatrix {\bf A}}
\begin{itemize}
\item{\vskip -.9ex 
Rate Matrix in Sparse representation (CompRowMatrix)}
\end{itemize}
}
\item{
\index{alpha}
\label{jphase.SparseContPhaseVar.alpha}\hypertarget{jphase.SparseContPhaseVar.alpha}{protected no.uib.cipr.matrix.sparse.SparseVector {\bf alpha}}
\begin{itemize}
\item{\vskip -.9ex 
Initial Probability distribution vector}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{SparseContPhaseVar(double\lbrack \rbrack , double\lbrack \rbrack \lbrack \rbrack )}
\hypertarget{jphase.SparseContPhaseVar(double[], double[][])}{\membername{SparseContPhaseVar}}
{\tt public\ {\bf SparseContPhaseVar}( {\tt double\lbrack \rbrack } {\bf alpha},
{\tt double\lbrack \rbrack \lbrack \rbrack } {\bf A} )
\label{jphase.SparseContPhaseVar(double[], double[][])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs a continuous Phase-type Distribution with sparse representation (CompRowMatrix)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- rate matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{SparseContPhaseVar}
\item{\vskip -1.9ex 
\index{SparseContPhaseVar(int)}
\hypertarget{jphase.SparseContPhaseVar(int)}{\membername{SparseContPhaseVar}}
{\tt public\ {\bf SparseContPhaseVar}( {\tt int} {\bf n} )
\label{jphase.SparseContPhaseVar(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs an empty Continuous Phase-type Distribution of size n with sparse representation (CompRowMatrix)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- size of the Continuous Phase-type Distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{SparseContPhaseVar}
\item{\vskip -1.9ex 
\index{SparseContPhaseVar(SparseVector, FlexCompRowMatrix)}
\hypertarget{jphase.SparseContPhaseVar(no.uib.cipr.matrix.sparse.SparseVector, no.uib.cipr.matrix.sparse.FlexCompRowMatrix)}{\membername{SparseContPhaseVar}}
{\tt public\ {\bf SparseContPhaseVar}( {\tt no.uib.cipr.matrix.sparse.SparseVector} {\bf alpha},
{\tt no.uib.cipr.matrix.sparse.FlexCompRowMatrix} {\bf A} )
\label{jphase.SparseContPhaseVar(no.uib.cipr.matrix.sparse.SparseVector, no.uib.cipr.matrix.sparse.FlexCompRowMatrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs a continuous Phase-type Distribution with sparse representation (CompRowMatrix)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- rate matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{SparseContPhaseVar}
\item{\vskip -1.9ex 
\index{SparseContPhaseVar(Vector, Matrix)}
\hypertarget{jphase.SparseContPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{\membername{SparseContPhaseVar}}
{\tt public\ {\bf SparseContPhaseVar}( {\tt no.uib.cipr.matrix.Vector} {\bf alpha},
{\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.SparseContPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs a continuous Phase-type Distribution with sparse representation (CompRowMatrix)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- rate matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{copy()}
\hypertarget{jphase.SparseContPhaseVar.copy()}{\membername{copy}}
{\tt public ContPhaseVar\ {\bf copy}(  )
\label{jphase.SparseContPhaseVar.copy()}}%end signature
}%end item
\divideents{getMatrix}
\item{\vskip -1.9ex 
\index{getMatrix()}
\hypertarget{jphase.SparseContPhaseVar.getMatrix()}{\membername{getMatrix}}
{\tt public no.uib.cipr.matrix.Matrix\ {\bf getMatrix}(  )
\label{jphase.SparseContPhaseVar.getMatrix()}}%end signature
}%end item
\divideents{getVector}
\item{\vskip -1.9ex 
\index{getVector()}
\hypertarget{jphase.SparseContPhaseVar.getVector()}{\membername{getVector}}
{\tt public no.uib.cipr.matrix.Vector\ {\bf getVector}(  )
\label{jphase.SparseContPhaseVar.getVector()}}%end signature
}%end item
\divideents{newVar}
\item{\vskip -1.9ex 
\index{newVar(int)}
\hypertarget{jphase.SparseContPhaseVar.newVar(int)}{\membername{newVar}}
{\tt public ContPhaseVar\ {\bf newVar}( {\tt int} {\bf n} )
\label{jphase.SparseContPhaseVar.newVar(int)}}%end signature
}%end item
\divideents{setMatrix}
\item{\vskip -1.9ex 
\index{setMatrix(Matrix)}
\hypertarget{jphase.SparseContPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{\membername{setMatrix}}
{\tt public void\ {\bf setMatrix}( {\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.SparseContPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}}%end signature
}%end item
\divideents{setVector}
\item{\vskip -1.9ex 
\index{setVector(Vector)}
\hypertarget{jphase.SparseContPhaseVar.setVector(no.uib.cipr.matrix.Vector)}{\membername{setVector}}
{\tt public void\ {\bf setVector}( {\tt no.uib.cipr.matrix.Vector} {\bf alpha} )
\label{jphase.SparseContPhaseVar.setVector(no.uib.cipr.matrix.Vector)}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.AbstractContPhaseVar} \textnormal{\small\refdefined{jphase.AbstractContPhaseVar}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf CV}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf eqResidualTime}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf expectedValue}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Vector {\bf getMat0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMat0Array}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMatrixArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getNumPhases}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVec0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVectorArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction1}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction2}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf max}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf max}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf median}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf min}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf min}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf moment}( {\tt int} {\bf k} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pdf}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf prob}( {\tt double} {\bf a},
{\tt double} {\bf b} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf quantil}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf residualTime}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf residualVar}( {\tt double} {\bf a} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf stdDeviation}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sum}( {\tt ContPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sum}( {\tt ContPhaseVar} {\bf v2},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumGeom}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf B},
{\tt ContPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf times}( {\tt double} {\bf c} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf variance}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public ContPhaseVar {\bf waitingQ}( {\tt double} {\bf rho} )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{SparseDiscPhaseVar}
\subsection{\label{jphase.SparseDiscPhaseVar}\index{SparseDiscPhaseVar}{\bf {\it Class} SparseDiscPhaseVar}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.SparseDiscPhaseVar}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class SparseDiscPhaseVar
\\ {\bf extends} jphase.AbstractDiscPhaseVar
\refdefined{jphase.AbstractDiscPhaseVar}}}}
\subsubsection{Version}{0.1 This class allows the creation and manipulation of Discrete Phase-type distributions represented by sparse (Flexible Compressed Row) matrices.}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.SparseDiscPhaseVar.A}{{\bf A}} Transition Matrix in Sparse representation (FlexCompRowMatrix)\\
\hyperlink{jphase.SparseDiscPhaseVar.alpha}{{\bf alpha}} Initial Probability distribution vector\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.SparseDiscPhaseVar(double[], double[][])}{{\bf SparseDiscPhaseVar(double\lbrack \rbrack , double\lbrack \rbrack \lbrack \rbrack )}} Construcs a discrete Phase-type Distribution with sparse representation (FlexCompRowMatrix)\\
\hyperlink{jphase.SparseDiscPhaseVar(int)}{{\bf SparseDiscPhaseVar(int)}} Construcs an empty Discrete Phase-type Distribution of size n with sparse representation (FlexCompRowMatrix)\\
\hyperlink{jphase.SparseDiscPhaseVar(no.uib.cipr.matrix.sparse.SparseVector, no.uib.cipr.matrix.sparse.FlexCompRowMatrix)}{{\bf SparseDiscPhaseVar(SparseVector, FlexCompRowMatrix)}} Construcs a discrete Phase-type Distribution with sparse representation (FlexCompRowMatrix)\\
\hyperlink{jphase.SparseDiscPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{{\bf SparseDiscPhaseVar(Vector, Matrix)}} Construcs a discrete Phase-type Distribution with sparse representation (FlexCompRowMatrix)\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.SparseDiscPhaseVar.copy()}{{\bf copy()}} \\
\hyperlink{jphase.SparseDiscPhaseVar.getMatrix()}{{\bf getMatrix()}} \\
\hyperlink{jphase.SparseDiscPhaseVar.getVector()}{{\bf getVector()}} \\
\hyperlink{jphase.SparseDiscPhaseVar.newVar(int)}{{\bf newVar(int)}} \\
\hyperlink{jphase.SparseDiscPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{{\bf setMatrix(Matrix)}} \\
\hyperlink{jphase.SparseDiscPhaseVar.setVector(no.uib.cipr.matrix.Vector)}{{\bf setVector(Vector)}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{A}
\label{jphase.SparseDiscPhaseVar.A}\hypertarget{jphase.SparseDiscPhaseVar.A}{protected no.uib.cipr.matrix.sparse.FlexCompRowMatrix {\bf A}}
\begin{itemize}
\item{\vskip -.9ex 
Transition Matrix in Sparse representation (FlexCompRowMatrix)}
\end{itemize}
}
\item{
\index{alpha}
\label{jphase.SparseDiscPhaseVar.alpha}\hypertarget{jphase.SparseDiscPhaseVar.alpha}{protected no.uib.cipr.matrix.sparse.SparseVector {\bf alpha}}
\begin{itemize}
\item{\vskip -.9ex 
Initial Probability distribution vector}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{SparseDiscPhaseVar(double\lbrack \rbrack , double\lbrack \rbrack \lbrack \rbrack )}
\hypertarget{jphase.SparseDiscPhaseVar(double[], double[][])}{\membername{SparseDiscPhaseVar}}
{\tt public\ {\bf SparseDiscPhaseVar}( {\tt double\lbrack \rbrack } {\bf alpha},
{\tt double\lbrack \rbrack \lbrack \rbrack } {\bf A} )
\label{jphase.SparseDiscPhaseVar(double[], double[][])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs a discrete Phase-type Distribution with sparse representation (FlexCompRowMatrix)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- transtion probability matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{SparseDiscPhaseVar}
\item{\vskip -1.9ex 
\index{SparseDiscPhaseVar(int)}
\hypertarget{jphase.SparseDiscPhaseVar(int)}{\membername{SparseDiscPhaseVar}}
{\tt public\ {\bf SparseDiscPhaseVar}( {\tt int} {\bf n} )
\label{jphase.SparseDiscPhaseVar(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs an empty Discrete Phase-type Distribution of size n with sparse representation (FlexCompRowMatrix)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- size of the Discrete Phase-type Distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{SparseDiscPhaseVar}
\item{\vskip -1.9ex 
\index{SparseDiscPhaseVar(SparseVector, FlexCompRowMatrix)}
\hypertarget{jphase.SparseDiscPhaseVar(no.uib.cipr.matrix.sparse.SparseVector, no.uib.cipr.matrix.sparse.FlexCompRowMatrix)}{\membername{SparseDiscPhaseVar}}
{\tt public\ {\bf SparseDiscPhaseVar}( {\tt no.uib.cipr.matrix.sparse.SparseVector} {\bf alpha},
{\tt no.uib.cipr.matrix.sparse.FlexCompRowMatrix} {\bf A} )
\label{jphase.SparseDiscPhaseVar(no.uib.cipr.matrix.sparse.SparseVector, no.uib.cipr.matrix.sparse.FlexCompRowMatrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs a discrete Phase-type Distribution with sparse representation (FlexCompRowMatrix)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- transition probability matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{SparseDiscPhaseVar}
\item{\vskip -1.9ex 
\index{SparseDiscPhaseVar(Vector, Matrix)}
\hypertarget{jphase.SparseDiscPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}{\membername{SparseDiscPhaseVar}}
{\tt public\ {\bf SparseDiscPhaseVar}( {\tt no.uib.cipr.matrix.Vector} {\bf alpha},
{\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.SparseDiscPhaseVar(no.uib.cipr.matrix.Vector, no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs a discrete Phase-type Distribution with sparse representation (FlexCompRowMatrix)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt A} -- transition probability matrix}
   \item{
\sld
{\tt alpha} -- initial probability distribution vector}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{copy()}
\hypertarget{jphase.SparseDiscPhaseVar.copy()}{\membername{copy}}
{\tt public DiscPhaseVar\ {\bf copy}(  )
\label{jphase.SparseDiscPhaseVar.copy()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.ContPhaseVar.copy()}{ContPhaseVar.copy()}} {\small 
\refdefined{jphase.ContPhaseVar.copy()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getMatrix}
\item{\vskip -1.9ex 
\index{getMatrix()}
\hypertarget{jphase.SparseDiscPhaseVar.getMatrix()}{\membername{getMatrix}}
{\tt public no.uib.cipr.matrix.Matrix\ {\bf getMatrix}(  )
\label{jphase.SparseDiscPhaseVar.getMatrix()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getMatrix()}{PhaseVar.getMatrix()}} {\small 
\refdefined{jphase.PhaseVar.getMatrix()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getVector}
\item{\vskip -1.9ex 
\index{getVector()}
\hypertarget{jphase.SparseDiscPhaseVar.getVector()}{\membername{getVector}}
{\tt public no.uib.cipr.matrix.Vector\ {\bf getVector}(  )
\label{jphase.SparseDiscPhaseVar.getVector()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.getVector()}{PhaseVar.getVector()}} {\small 
\refdefined{jphase.PhaseVar.getVector()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{newVar}
\item{\vskip -1.9ex 
\index{newVar(int)}
\hypertarget{jphase.SparseDiscPhaseVar.newVar(int)}{\membername{newVar}}
{\tt public DiscPhaseVar\ {\bf newVar}( {\tt int} {\bf n} )
\label{jphase.SparseDiscPhaseVar.newVar(int)}}%end signature
}%end item
\divideents{setMatrix}
\item{\vskip -1.9ex 
\index{setMatrix(Matrix)}
\hypertarget{jphase.SparseDiscPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{\membername{setMatrix}}
{\tt public void\ {\bf setMatrix}( {\tt no.uib.cipr.matrix.Matrix} {\bf A} )
\label{jphase.SparseDiscPhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}{PhaseVar.setMatrix(Matrix)}} {\small 
\refdefined{jphase.PhaseVar.setMatrix(no.uib.cipr.matrix.Matrix)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setVector}
\item{\vskip -1.9ex 
\index{setVector(Vector)}
\hypertarget{jphase.SparseDiscPhaseVar.setVector(no.uib.cipr.matrix.Vector)}{\membername{setVector}}
{\tt public void\ {\bf setVector}( {\tt no.uib.cipr.matrix.Vector} {\bf alpha} )
\label{jphase.SparseDiscPhaseVar.setVector(no.uib.cipr.matrix.Vector)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.PhaseVar.setVector(no.uib.cipr.matrix.Vector)}{PhaseVar.setVector(Vector)}} {\small 
\refdefined{jphase.PhaseVar.setVector(no.uib.cipr.matrix.Vector)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.AbstractDiscPhaseVar} \textnormal{\small\refdefined{jphase.AbstractDiscPhaseVar}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf cdf}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf CV}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf description}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf expectedValue}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public Vector {\bf getMat0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMat0Array}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getMatrixArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public int {\bf getNumPhases}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVec0}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getVectorArray}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public String {\bf label}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction1}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf lossFunction2}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf max}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf max}( {\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf median}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf min}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf min}( {\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf mix}( {\tt double} {\bf p},
{\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf moment}( {\tt int} {\bf k} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pmf}( {\tt int} {\bf k} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf pmf}( {\tt int} {\bf n},
{\tt int} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf prob}( {\tt double} {\bf a},
{\tt double} {\bf b} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf quantil}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf stdDeviation}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf sum}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf sum}( {\tt DiscPhaseVar} {\bf v2},
{\tt DiscPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf sumGeom}( {\tt double} {\bf p} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf v2} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public DiscPhaseVar {\bf sumPH}( {\tt DiscPhaseVar} {\bf B},
{\tt DiscPhaseVar} {\bf res} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt double} {\bf x} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf survival}( {\tt int} {\bf n},
{\tt double} {\bf delta} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public final String {\bf toString}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf variance}(  )
}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{SuperErlang}
\subsection{\label{jphase.SuperErlang}\index{SuperErlang}{\bf {\it Class} SuperErlang}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.SuperErlang}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class SuperErlang
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
java.io.Serializable}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.SuperErlang.ONE}{{\bf ONE}} The number one (1)\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.SuperErlang()}{{\bf SuperErlang()}} f(x) = 0.0\\
\hyperlink{jphase.SuperErlang(double, int, double)}{{\bf SuperErlang(double, int, double)}} f(x) = cf E(n,lbd)\\
\hyperlink{jphase.SuperErlang(jphase.Term)}{{\bf SuperErlang(Term)}} f(x) = t\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.SuperErlang.addTerm(double, int, double)}{{\bf addTerm(double, int, double)}} \\
\hyperlink{jphase.SuperErlang.addTerm(jphase.Term)}{{\bf addTerm(Term)}} \\
\hyperlink{jphase.SuperErlang.clone()}{{\bf clone()}} Clones this function\\
\hyperlink{jphase.SuperErlang.convolution(jphase.SuperErlang, jphase.SuperErlang)}{{\bf convolution(SuperErlang, SuperErlang)}} Return the convolution of this two functions\\
\hyperlink{jphase.SuperErlang.defIntegrate()}{{\bf defIntegrate()}} Returns the integral from 0 to infinity of this function.\\
\hyperlink{jphase.SuperErlang.defIntegrate(double)}{{\bf defIntegrate(double)}} Returns the definite integral from 0 to x of this function\\
\hyperlink{jphase.SuperErlang.derive()}{{\bf derive()}} Rturns the derivative at t of this function.\\
\hyperlink{jphase.SuperErlang.exp()}{{\bf exp()}} \\
\hyperlink{jphase.SuperErlang.expand(double)}{{\bf expand(double)}} Evaluates f(t) at a*t.\\
\hyperlink{jphase.SuperErlang.integrate()}{{\bf integrate()}} Rturns the integral from 0 to t of this function.\\
\hyperlink{jphase.SuperErlang.integrateCom()}{{\bf integrateCom()}} Rturns the integral from t to infinity of this function.\\
\hyperlink{jphase.SuperErlang.isZero()}{{\bf isZero()}} Detrmines whethr this function is identically equal to 0\\
\hyperlink{jphase.SuperErlang.moment(int)}{{\bf moment(int)}} \\
\hyperlink{jphase.SuperErlang.move(double)}{{\bf move(double)}} Evaluates the function at t+a\\
\hyperlink{jphase.SuperErlang.multiply(jphase.SuperErlang)}{{\bf multiply(SuperErlang)}} Multiply the function f2 with this function\\
\hyperlink{jphase.SuperErlang.multiply(jphase.SuperErlang, jphase.SuperErlang)}{{\bf multiply(SuperErlang, SuperErlang)}} Return the product of this two functions\\
\hyperlink{jphase.SuperErlang.numTerms()}{{\bf numTerms()}} Returns the number of terms.\\
\hyperlink{jphase.SuperErlang.poly(double, int)}{{\bf poly(double, int)}} Return a monomy c t$\wedge$n\\
\hyperlink{jphase.SuperErlang.sum(jphase.SuperErlang)}{{\bf sum(SuperErlang)}} Sums the function f2 to this function\\
\hyperlink{jphase.SuperErlang.sum(jphase.SuperErlang, jphase.SuperErlang)}{{\bf sum(SuperErlang, SuperErlang)}} Return the sum of this two functions\\
\hyperlink{jphase.SuperErlang.term(int)}{{\bf term(int)}} Returns the i-th term.\\
\hyperlink{jphase.SuperErlang.times(double)}{{\bf times(double)}} Returns this function times the constant\\
\hyperlink{jphase.SuperErlang.toString()}{{\bf toString()}} \\
\hyperlink{jphase.SuperErlang.toStringE()}{{\bf toStringE()}} String representation using the notation {\tt\small p1E(n1,a2) + p2E(n2,a2) + ...} where E(n,a) = a$\wedge$n x$\wedge$(n-1) e$\wedge$(-a x) / (n-1)!, is an Erlang pdf.\\
\hyperlink{jphase.SuperErlang.toStringP()}{{\bf toStringP()}} String representation using the notation {\tt\small p1P(n1,a2) + p2P(n2,a2) + ...} where E(n,a) = (a x)$\wedge$n e$\wedge$(-a x) / n!, is a poisson cdf..\\
\hyperlink{jphase.SuperErlang.toStringRTF()}{{\bf toStringRTF()}} String representation in RTF\\
\end{verse}
}
\subsubsection{Serializable Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{v}
private java.util.List {\bf v}}
\end{itemize}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{ONE}
\label{jphase.SuperErlang.ONE}\hypertarget{jphase.SuperErlang.ONE}{public static SuperErlang {\bf ONE}}
\begin{itemize}
\item{\vskip -.9ex 
The number one (1)}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{SuperErlang()}
\hypertarget{jphase.SuperErlang()}{\membername{SuperErlang}}
{\tt public\ {\bf SuperErlang}(  )
\label{jphase.SuperErlang()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

f(x) = 0.0
}
\end{itemize}
}%end item
\divideents{SuperErlang}
\item{\vskip -1.9ex 
\index{SuperErlang(double, int, double)}
\hypertarget{jphase.SuperErlang(double, int, double)}{\membername{SuperErlang}}
{\tt public\ {\bf SuperErlang}( {\tt double} {\bf cf},
{\tt int} {\bf n},
{\tt double} {\bf lbd} )
\label{jphase.SuperErlang(double, int, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

f(x) = cf E(n,lbd)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt cf} -- }
   \item{
\sld
{\tt n} -- }
   \item{
\sld
{\tt lbd} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{SuperErlang}
\item{\vskip -1.9ex 
\index{SuperErlang(Term)}
\hypertarget{jphase.SuperErlang(jphase.Term)}{\membername{SuperErlang}}
{\tt public\ {\bf SuperErlang}( {\tt Term} {\bf trm} )
\label{jphase.SuperErlang(jphase.Term)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

f(x) = t
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt trm} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{addTerm(double, int, double)}
\hypertarget{jphase.SuperErlang.addTerm(double, int, double)}{\membername{addTerm}}
{\tt public SuperErlang\ {\bf addTerm}( {\tt double} {\bf coeff},
{\tt int} {\bf power},
{\tt double} {\bf lmb} )
\label{jphase.SuperErlang.addTerm(double, int, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt coeff} -- }
   \item{
\sld
{\tt power} -- }
   \item{
\sld
{\tt lmb} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
f(x) := f(x) + coeff E(power, lmb) 
}%end item
\end{itemize}
}%end item
\divideents{addTerm}
\item{\vskip -1.9ex 
\index{addTerm(Term)}
\hypertarget{jphase.SuperErlang.addTerm(jphase.Term)}{\membername{addTerm}}
{\tt public SuperErlang\ {\bf addTerm}( {\tt Term} {\bf tr} )
\label{jphase.SuperErlang.addTerm(jphase.Term)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt tr} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
f(x) := f(x) + tr 
}%end item
\end{itemize}
}%end item
\divideents{clone}
\item{\vskip -1.9ex 
\index{clone()}
\hypertarget{jphase.SuperErlang.clone()}{\membername{clone}}
{\tt public java.lang.Object\ {\bf clone}(  )
\label{jphase.SuperErlang.clone()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Clones this function
}
\end{itemize}
}%end item
\divideents{convolution}
\item{\vskip -1.9ex 
\index{convolution(SuperErlang, SuperErlang)}
\hypertarget{jphase.SuperErlang.convolution(jphase.SuperErlang, jphase.SuperErlang)}{\membername{convolution}}
{\tt public static SuperErlang\ {\bf convolution}( {\tt SuperErlang} {\bf f1},
{\tt SuperErlang} {\bf f2} )
\label{jphase.SuperErlang.convolution(jphase.SuperErlang, jphase.SuperErlang)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the convolution of this two functions
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt f1} -- }
   \item{
\sld
{\tt f2} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
f1 * f2(x) 
}%end item
\end{itemize}
}%end item
\divideents{defIntegrate}
\item{\vskip -1.9ex 
\index{defIntegrate()}
\hypertarget{jphase.SuperErlang.defIntegrate()}{\membername{defIntegrate}}
{\tt public double\ {\bf defIntegrate}(  )
\label{jphase.SuperErlang.defIntegrate()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the integral from 0 to infinity of this function.
}
\item{{\bf Returns} -- 
integral value 
}%end item
\end{itemize}
}%end item
\divideents{defIntegrate}
\item{\vskip -1.9ex 
\index{defIntegrate(double)}
\hypertarget{jphase.SuperErlang.defIntegrate(double)}{\membername{defIntegrate}}
{\tt public double\ {\bf defIntegrate}( {\tt double} {\bf x} )
\label{jphase.SuperErlang.defIntegrate(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the definite integral from 0 to x of this function
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
int\_0$\wedge$x f(t)dt 
}%end item
\end{itemize}
}%end item
\divideents{derive}
\item{\vskip -1.9ex 
\index{derive()}
\hypertarget{jphase.SuperErlang.derive()}{\membername{derive}}
{\tt public SuperErlang\ {\bf derive}(  )
\label{jphase.SuperErlang.derive()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Rturns the derivative at t of this function.
}
\item{{\bf Returns} -- 
f'(x) 
}%end item
\end{itemize}
}%end item
\divideents{exp}
\item{\vskip -1.9ex 
\index{exp()}
\hypertarget{jphase.SuperErlang.exp()}{\membername{exp}}
{\tt protected double\ {\bf exp}(  )
\label{jphase.SuperErlang.exp()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
expected falue for the given pdf 
}%end item
\end{itemize}
}%end item
\divideents{expand}
\item{\vskip -1.9ex 
\index{expand(double)}
\hypertarget{jphase.SuperErlang.expand(double)}{\membername{expand}}
{\tt public SuperErlang\ {\bf expand}( {\tt double} {\bf a} )
\label{jphase.SuperErlang.expand(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates f(t) at a*t.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt a} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
f(a x) 
}%end item
\end{itemize}
}%end item
\divideents{integrate}
\item{\vskip -1.9ex 
\index{integrate()}
\hypertarget{jphase.SuperErlang.integrate()}{\membername{integrate}}
{\tt public SuperErlang\ {\bf integrate}(  )
\label{jphase.SuperErlang.integrate()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Rturns the integral from 0 to t of this function.
}
\item{{\bf Returns} -- 
int\_0$\wedge$x f(t)dt 
}%end item
\end{itemize}
}%end item
\divideents{integrateCom}
\item{\vskip -1.9ex 
\index{integrateCom()}
\hypertarget{jphase.SuperErlang.integrateCom()}{\membername{integrateCom}}
{\tt public SuperErlang\ {\bf integrateCom}(  )
\label{jphase.SuperErlang.integrateCom()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Rturns the integral from t to infinity of this function.
}
\item{{\bf Returns} -- 
int\_x$\wedge$infty f(t)dt 
}%end item
\end{itemize}
}%end item
\divideents{isZero}
\item{\vskip -1.9ex 
\index{isZero()}
\hypertarget{jphase.SuperErlang.isZero()}{\membername{isZero}}
{\tt public boolean\ {\bf isZero}(  )
\label{jphase.SuperErlang.isZero()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Detrmines whethr this function is identically equal to 0
}
\item{{\bf Returns} -- 
true if f(x) == 0.0 
}%end item
\end{itemize}
}%end item
\divideents{moment}
\item{\vskip -1.9ex 
\index{moment(int)}
\hypertarget{jphase.SuperErlang.moment(int)}{\membername{moment}}
{\tt protected double\ {\bf moment}( {\tt int} {\bf k} )
\label{jphase.SuperErlang.moment(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt k} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
k-th moment 
}%end item
\end{itemize}
}%end item
\divideents{move}
\item{\vskip -1.9ex 
\index{move(double)}
\hypertarget{jphase.SuperErlang.move(double)}{\membername{move}}
{\tt public SuperErlang\ {\bf move}( {\tt double} {\bf a} )
\label{jphase.SuperErlang.move(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates the function at t+a
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt a} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
f(t+a) 
}%end item
\end{itemize}
}%end item
\divideents{multiply}
\item{\vskip -1.9ex 
\index{multiply(SuperErlang)}
\hypertarget{jphase.SuperErlang.multiply(jphase.SuperErlang)}{\membername{multiply}}
{\tt public SuperErlang\ {\bf multiply}( {\tt SuperErlang} {\bf f2} )
\label{jphase.SuperErlang.multiply(jphase.SuperErlang)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Multiply the function f2 with this function
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt f2} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
f(x) x f2(x) 
}%end item
\end{itemize}
}%end item
\divideents{multiply}
\item{\vskip -1.9ex 
\index{multiply(SuperErlang, SuperErlang)}
\hypertarget{jphase.SuperErlang.multiply(jphase.SuperErlang, jphase.SuperErlang)}{\membername{multiply}}
{\tt public static SuperErlang\ {\bf multiply}( {\tt SuperErlang} {\bf f1},
{\tt SuperErlang} {\bf f2} )
\label{jphase.SuperErlang.multiply(jphase.SuperErlang, jphase.SuperErlang)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the product of this two functions
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt f1} -- }
   \item{
\sld
{\tt f2} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
f1(x) x f2(x) 
}%end item
\end{itemize}
}%end item
\divideents{numTerms}
\item{\vskip -1.9ex 
\index{numTerms()}
\hypertarget{jphase.SuperErlang.numTerms()}{\membername{numTerms}}
{\tt public int\ {\bf numTerms}(  )
\label{jphase.SuperErlang.numTerms()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the number of terms.
}
\item{{\bf Returns} -- 
Number of terms 
}%end item
\end{itemize}
}%end item
\divideents{poly}
\item{\vskip -1.9ex 
\index{poly(double, int)}
\hypertarget{jphase.SuperErlang.poly(double, int)}{\membername{poly}}
{\tt public static SuperErlang\ {\bf poly}( {\tt double} {\bf coef},
{\tt int} {\bf n} )
\label{jphase.SuperErlang.poly(double, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return a monomy c t$\wedge$n
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt coef} -- }
   \item{
\sld
{\tt n} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
c t$\wedge$n 
}%end item
\end{itemize}
}%end item
\divideents{sum}
\item{\vskip -1.9ex 
\index{sum(SuperErlang)}
\hypertarget{jphase.SuperErlang.sum(jphase.SuperErlang)}{\membername{sum}}
{\tt public SuperErlang\ {\bf sum}( {\tt SuperErlang} {\bf f2} )
\label{jphase.SuperErlang.sum(jphase.SuperErlang)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sums the function f2 to this function
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt f2} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
f(x) := f(x) + f2(x) 
}%end item
\end{itemize}
}%end item
\divideents{sum}
\item{\vskip -1.9ex 
\index{sum(SuperErlang, SuperErlang)}
\hypertarget{jphase.SuperErlang.sum(jphase.SuperErlang, jphase.SuperErlang)}{\membername{sum}}
{\tt public static SuperErlang\ {\bf sum}( {\tt SuperErlang} {\bf f1},
{\tt SuperErlang} {\bf f2} )
\label{jphase.SuperErlang.sum(jphase.SuperErlang, jphase.SuperErlang)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the sum of this two functions
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt f1} -- }
   \item{
\sld
{\tt f2} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
f1+f2 
}%end item
\end{itemize}
}%end item
\divideents{term}
\item{\vskip -1.9ex 
\index{term(int)}
\hypertarget{jphase.SuperErlang.term(int)}{\membername{term}}
{\tt public Term\ {\bf term}( {\tt int} {\bf i} )
\label{jphase.SuperErlang.term(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the i-th term.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt i} -- The 0based index.}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The i-th term 
}%end item
\end{itemize}
}%end item
\divideents{times}
\item{\vskip -1.9ex 
\index{times(double)}
\hypertarget{jphase.SuperErlang.times(double)}{\membername{times}}
{\tt public SuperErlang\ {\bf times}( {\tt double} {\bf cons} )
\label{jphase.SuperErlang.times(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns this function times the constant
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt cons} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
cons * f(x) 
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jphase.SuperErlang.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jphase.SuperErlang.toString()}}%end signature
}%end item
\divideents{toStringE}
\item{\vskip -1.9ex 
\index{toStringE()}
\hypertarget{jphase.SuperErlang.toStringE()}{\membername{toStringE}}
{\tt public java.lang.String\ {\bf toStringE}(  )
\label{jphase.SuperErlang.toStringE()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

String representation using the notation {\tt\small p1E(n1,a2) + p2E(n2,a2) + ...} where E(n,a) = a$\wedge$n x$\wedge$(n-1) e$\wedge$(-a x) / (n-1)!, is an Erlang pdf.
}
\item{{\bf Returns} -- 
Erlang type representation. 
}%end item
\end{itemize}
}%end item
\divideents{toStringP}
\item{\vskip -1.9ex 
\index{toStringP()}
\hypertarget{jphase.SuperErlang.toStringP()}{\membername{toStringP}}
{\tt public java.lang.String\ {\bf toStringP}(  )
\label{jphase.SuperErlang.toStringP()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

String representation using the notation {\tt\small p1P(n1,a2) + p2P(n2,a2) + ...} where E(n,a) = (a x)$\wedge$n e$\wedge$(-a x) / n!, is a poisson cdf..
}
\item{{\bf Returns} -- 
Erlang type representation. 
}%end item
\end{itemize}
}%end item
\divideents{toStringRTF}
\item{\vskip -1.9ex 
\index{toStringRTF()}
\hypertarget{jphase.SuperErlang.toStringRTF()}{\membername{toStringRTF}}
{\tt public java.lang.String\ {\bf toStringRTF}(  )
\label{jphase.SuperErlang.toStringRTF()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

String representation in RTF
}
\item{{\bf Returns} -- 
string 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{Term}
\subsection{\label{jphase.Term}\index{Term}{\bf {\it Class} Term}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.Term}{}\vskip .1in 
This class describes a basic term in a super-Erlang function It has the form: alpha lambda$\wedge$n * t$\wedge$(n-1) * exp($\wedge$-m*lambda) / (n-1)! Or alpha * R(n,lambda) where R(n,lambda) is an Erlang pdf.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class Term
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
java.io.Serializable}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.Term.ONE}{{\bf ONE}} Number 1.0\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.Term(double, int, double)}{{\bf Term(double, int, double)}} Creates a term cf * t$\wedge$pw exp(-lb * t)\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.Term.clone()}{{\bf clone()}} Clones this term\\
\hyperlink{jphase.Term.compareTo(jphase.Term)}{{\bf compareTo(Term)}} Compares according to lambda,power in that order.\\
\hyperlink{jphase.Term.convolution(jphase.Term, jphase.Term)}{{\bf convolution(Term, Term)}} Return the convolution of this two terms\\
\hyperlink{jphase.Term.convolutionUseExp(jphase.Term, jphase.Term)}{{\bf convolutionUseExp(Term, Term)}} \\
\hyperlink{jphase.Term.defIntegrate()}{{\bf defIntegrate()}} Returns the integral from 0 to infinity\\
\hyperlink{jphase.Term.defIntegrate(double)}{{\bf defIntegrate(double)}} Returns the integral from 0 to x\\
\hyperlink{jphase.Term.derive()}{{\bf derive()}} Returns the derivative at t\\
\hyperlink{jphase.Term.equalPowers(jphase.Term)}{{\bf equalPowers(Term)}} \\
\hyperlink{jphase.Term.evaluate()}{{\bf evaluate()}} Evaluates this term at infinity\\
\hyperlink{jphase.Term.evaluate(double)}{{\bf evaluate(double)}} Evaluates this term at the value x\\
\hyperlink{jphase.Term.expand(double)}{{\bf expand(double)}} Return this term evaluated at t*a\\
\hyperlink{jphase.Term.getCoeff()}{{\bf getCoeff()}} Returns the value of the coefficient\\
\hyperlink{jphase.Term.getDegree()}{{\bf getDegree()}} Returns the value of the degree\\
\hyperlink{jphase.Term.getLambda()}{{\bf getLambda()}} Returns the value of lambda\\
\hyperlink{jphase.Term.integrate()}{{\bf integrate()}} Returns the integral form 0 to t\\
\hyperlink{jphase.Term.integrateCom()}{{\bf integrateCom()}} Returns the integral from t to infinity\\
\hyperlink{jphase.Term.isConstant()}{{\bf isConstant()}} Tells if it is constatnt.\\
\hyperlink{jphase.Term.isPTerm()}{{\bf isPTerm()}} Tells if the term is a polinonial\\
\hyperlink{jphase.Term.isZero()}{{\bf isZero()}} Tells if it is identically = 0.\\
\hyperlink{jphase.Term.moment(int)}{{\bf moment(int)}} Computes the k-th moment\\
\hyperlink{jphase.Term.move(double)}{{\bf move(double)}} Return this term evaluated at t+a\\
\hyperlink{jphase.Term.multiply(jphase.Term)}{{\bf multiply(Term)}} Return the product of this term with tr\\
\hyperlink{jphase.Term.multiply(jphase.Term, jphase.Term)}{{\bf multiply(Term, Term)}} Return the product of this two terms\\
\hyperlink{jphase.Term.setCoeff(double)}{{\bf setCoeff(double)}} Sets the value of the coefficient\\
\hyperlink{jphase.Term.setDegree(int)}{{\bf setDegree(int)}} Returns the value of the degree\\
\hyperlink{jphase.Term.setLambda(double)}{{\bf setLambda(double)}} Returns the value of the coefficient\\
\hyperlink{jphase.Term.toString()}{{\bf toString()}} \\
\hyperlink{jphase.Term.toStringE()}{{\bf toStringE()}} Represents the term as a multiple of an Eralng pdf.\\
\hyperlink{jphase.Term.toStringP()}{{\bf toStringP()}} String representation of the Polynomial\\
\hyperlink{jphase.Term.toStringRTF()}{{\bf toStringRTF()}} RTF representation fo the term\\
\end{verse}
}
\subsubsection{Serializable Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{coeff}
private double {\bf coeff}}
\item{
\index{power}
private int {\bf power}}
\item{
\index{lambda}
private double {\bf lambda}}
\end{itemize}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{ONE}
\label{jphase.Term.ONE}\hypertarget{jphase.Term.ONE}{public static Term {\bf ONE}}
\begin{itemize}
\item{\vskip -.9ex 
Number 1.0}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{Term(double, int, double)}
\hypertarget{jphase.Term(double, int, double)}{\membername{Term}}
{\tt public\ {\bf Term}( {\tt double} {\bf cf},
{\tt int} {\bf pw},
{\tt double} {\bf lb} )
\label{jphase.Term(double, int, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates a term cf * t$\wedge$pw exp(-lb * t)
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt cf} -- coefficient}
   \item{
\sld
{\tt pw} -- power}
   \item{
\sld
{\tt lb} -- lambda}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{clone()}
\hypertarget{jphase.Term.clone()}{\membername{clone}}
{\tt public java.lang.Object\ {\bf clone}(  )
\label{jphase.Term.clone()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Clones this term
}
\end{itemize}
}%end item
\divideents{compareTo}
\item{\vskip -1.9ex 
\index{compareTo(Term)}
\hypertarget{jphase.Term.compareTo(jphase.Term)}{\membername{compareTo}}
{\tt public int\ {\bf compareTo}( {\tt Term} {\bf tr} )
\label{jphase.Term.compareTo(jphase.Term)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Compares according to lambda,power in that order.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt tr} -- Term to compare to}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
establishes an ordering among terms 
}%end item
\end{itemize}
}%end item
\divideents{convolution}
\item{\vskip -1.9ex 
\index{convolution(Term, Term)}
\hypertarget{jphase.Term.convolution(jphase.Term, jphase.Term)}{\membername{convolution}}
{\tt public static SuperErlang\ {\bf convolution}( {\tt Term} {\bf term1},
{\tt Term} {\bf term2} )
\label{jphase.Term.convolution(jphase.Term, jphase.Term)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the convolution of this two terms
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt term1} -- First term}
   \item{
\sld
{\tt term2} -- Second term}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
SuperErlang representation the convolution of this two terms 
}%end item
\end{itemize}
}%end item
\divideents{convolutionUseExp}
\item{\vskip -1.9ex 
\index{convolutionUseExp(Term, Term)}
\hypertarget{jphase.Term.convolutionUseExp(jphase.Term, jphase.Term)}{\membername{convolutionUseExp}}
{\tt public static SuperErlang\ {\bf convolutionUseExp}( {\tt Term} {\bf term1},
{\tt Term} {\bf term2} )
\label{jphase.Term.convolutionUseExp(jphase.Term, jphase.Term)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt term1} -- }
   \item{
\sld
{\tt term2} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Convolution of Term1 and Term2 
}%end item
\end{itemize}
}%end item
\divideents{defIntegrate}
\item{\vskip -1.9ex 
\index{defIntegrate()}
\hypertarget{jphase.Term.defIntegrate()}{\membername{defIntegrate}}
{\tt public double\ {\bf defIntegrate}(  )
\label{jphase.Term.defIntegrate()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the integral from 0 to infinity
}
\item{{\bf Returns} -- 
Value of the integral from 0 to infinity 
}%end item
\end{itemize}
}%end item
\divideents{defIntegrate}
\item{\vskip -1.9ex 
\index{defIntegrate(double)}
\hypertarget{jphase.Term.defIntegrate(double)}{\membername{defIntegrate}}
{\tt public double\ {\bf defIntegrate}( {\tt double} {\bf x} )
\label{jphase.Term.defIntegrate(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the integral from 0 to x
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- upper limit of the integral}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Value of the integral from 0 to x 
}%end item
\end{itemize}
}%end item
\divideents{derive}
\item{\vskip -1.9ex 
\index{derive()}
\hypertarget{jphase.Term.derive()}{\membername{derive}}
{\tt public SuperErlang\ {\bf derive}(  )
\label{jphase.Term.derive()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the derivative at t
}
\item{{\bf Returns} -- 
SuperErlang representation of the derivative at t 
}%end item
\end{itemize}
}%end item
\divideents{equalPowers}
\item{\vskip -1.9ex 
\index{equalPowers(Term)}
\hypertarget{jphase.Term.equalPowers(jphase.Term)}{\membername{equalPowers}}
{\tt public boolean\ {\bf equalPowers}( {\tt Term} {\bf tr} )
\label{jphase.Term.equalPowers(jphase.Term)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt tr} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
true if both terms have equal powers. 
}%end item
\end{itemize}
}%end item
\divideents{evaluate}
\item{\vskip -1.9ex 
\index{evaluate()}
\hypertarget{jphase.Term.evaluate()}{\membername{evaluate}}
{\tt public double\ {\bf evaluate}(  )
\label{jphase.Term.evaluate()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates this term at infinity
}
\item{{\bf Returns} -- 
value of the term at infinity 
}%end item
\end{itemize}
}%end item
\divideents{evaluate}
\item{\vskip -1.9ex 
\index{evaluate(double)}
\hypertarget{jphase.Term.evaluate(double)}{\membername{evaluate}}
{\tt public double\ {\bf evaluate}( {\tt double} {\bf x} )
\label{jphase.Term.evaluate(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Evaluates this term at the value x
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- Evaluation point}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Value of the term at the specified point 
}%end item
\end{itemize}
}%end item
\divideents{expand}
\item{\vskip -1.9ex 
\index{expand(double)}
\hypertarget{jphase.Term.expand(double)}{\membername{expand}}
{\tt public Term\ {\bf expand}( {\tt double} {\bf a} )
\label{jphase.Term.expand(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return this term evaluated at t*a
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt a} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
This term evaluated at t*a 
}%end item
\end{itemize}
}%end item
\divideents{getCoeff}
\item{\vskip -1.9ex 
\index{getCoeff()}
\hypertarget{jphase.Term.getCoeff()}{\membername{getCoeff}}
{\tt public double\ {\bf getCoeff}(  )
\label{jphase.Term.getCoeff()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the value of the coefficient
}
\item{{\bf Returns} -- 
the coefficient 
}%end item
\end{itemize}
}%end item
\divideents{getDegree}
\item{\vskip -1.9ex 
\index{getDegree()}
\hypertarget{jphase.Term.getDegree()}{\membername{getDegree}}
{\tt public int\ {\bf getDegree}(  )
\label{jphase.Term.getDegree()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the value of the degree
}
\item{{\bf Returns} -- 
the degree of this term 
}%end item
\end{itemize}
}%end item
\divideents{getLambda}
\item{\vskip -1.9ex 
\index{getLambda()}
\hypertarget{jphase.Term.getLambda()}{\membername{getLambda}}
{\tt public double\ {\bf getLambda}(  )
\label{jphase.Term.getLambda()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the value of lambda
}
\item{{\bf Returns} -- 
the value of lambda 
}%end item
\end{itemize}
}%end item
\divideents{integrate}
\item{\vskip -1.9ex 
\index{integrate()}
\hypertarget{jphase.Term.integrate()}{\membername{integrate}}
{\tt public SuperErlang\ {\bf integrate}(  )
\label{jphase.Term.integrate()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the integral form 0 to t
}
\item{{\bf Returns} -- 
SuperErlang representation of the integral from 0 to t 
}%end item
\end{itemize}
}%end item
\divideents{integrateCom}
\item{\vskip -1.9ex 
\index{integrateCom()}
\hypertarget{jphase.Term.integrateCom()}{\membername{integrateCom}}
{\tt public SuperErlang\ {\bf integrateCom}(  )
\label{jphase.Term.integrateCom()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the integral from t to infinity
}
\item{{\bf Returns} -- 
SuperErlang representation of the integral frrm t to infinity 
}%end item
\end{itemize}
}%end item
\divideents{isConstant}
\item{\vskip -1.9ex 
\index{isConstant()}
\hypertarget{jphase.Term.isConstant()}{\membername{isConstant}}
{\tt public boolean\ {\bf isConstant}(  )
\label{jphase.Term.isConstant()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Tells if it is constatnt.
}
\item{{\bf Returns} -- 
true if this term represents a constant 
}%end item
\end{itemize}
}%end item
\divideents{isPTerm}
\item{\vskip -1.9ex 
\index{isPTerm()}
\hypertarget{jphase.Term.isPTerm()}{\membername{isPTerm}}
{\tt public boolean\ {\bf isPTerm}(  )
\label{jphase.Term.isPTerm()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Tells if the term is a polinonial
}
\item{{\bf Returns} -- 
tru if it is a poer term. 
}%end item
\end{itemize}
}%end item
\divideents{isZero}
\item{\vskip -1.9ex 
\index{isZero()}
\hypertarget{jphase.Term.isZero()}{\membername{isZero}}
{\tt public boolean\ {\bf isZero}(  )
\label{jphase.Term.isZero()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Tells if it is identically = 0.
}
\item{{\bf Returns} -- 
true if this term represents a zero 
}%end item
\end{itemize}
}%end item
\divideents{moment}
\item{\vskip -1.9ex 
\index{moment(int)}
\hypertarget{jphase.Term.moment(int)}{\membername{moment}}
{\tt protected double\ {\bf moment}( {\tt int} {\bf k} )
\label{jphase.Term.moment(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the k-th moment
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt k} -- required moment}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
k-th moment 
}%end item
\end{itemize}
}%end item
\divideents{move}
\item{\vskip -1.9ex 
\index{move(double)}
\hypertarget{jphase.Term.move(double)}{\membername{move}}
{\tt public SuperErlang\ {\bf move}( {\tt double} {\bf a} )
\label{jphase.Term.move(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return this term evaluated at t+a
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt a} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
SuperErlang representation of the term evaluated at t+a 
}%end item
\end{itemize}
}%end item
\divideents{multiply}
\item{\vskip -1.9ex 
\index{multiply(Term)}
\hypertarget{jphase.Term.multiply(jphase.Term)}{\membername{multiply}}
{\tt public Term\ {\bf multiply}( {\tt Term} {\bf tr} )
\label{jphase.Term.multiply(jphase.Term)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the product of this term with tr
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt tr} -- Term to multiply}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Product of this term with tr 
}%end item
\end{itemize}
}%end item
\divideents{multiply}
\item{\vskip -1.9ex 
\index{multiply(Term, Term)}
\hypertarget{jphase.Term.multiply(jphase.Term, jphase.Term)}{\membername{multiply}}
{\tt public static Term\ {\bf multiply}( {\tt Term} {\bf t1},
{\tt Term} {\bf t2} )
\label{jphase.Term.multiply(jphase.Term, jphase.Term)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Return the product of this two terms
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt t1} -- First term to multiply}
   \item{
\sld
{\tt t2} -- Second term to multiply}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Product of this two terms 
}%end item
\end{itemize}
}%end item
\divideents{setCoeff}
\item{\vskip -1.9ex 
\index{setCoeff(double)}
\hypertarget{jphase.Term.setCoeff(double)}{\membername{setCoeff}}
{\tt public void\ {\bf setCoeff}( {\tt double} {\bf alpha} )
\label{jphase.Term.setCoeff(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Sets the value of the coefficient
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt alpha} -- new value}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setDegree}
\item{\vskip -1.9ex 
\index{setDegree(int)}
\hypertarget{jphase.Term.setDegree(int)}{\membername{setDegree}}
{\tt public void\ {\bf setDegree}( {\tt int} {\bf n} )
\label{jphase.Term.setDegree(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the value of the degree
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{setLambda}
\item{\vskip -1.9ex 
\index{setLambda(double)}
\hypertarget{jphase.Term.setLambda(double)}{\membername{setLambda}}
{\tt public void\ {\bf setLambda}( {\tt double} {\bf lbd} )
\label{jphase.Term.setLambda(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the value of the coefficient
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lbd} -- lambda}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{toString}
\item{\vskip -1.9ex 
\index{toString()}
\hypertarget{jphase.Term.toString()}{\membername{toString}}
{\tt public java.lang.String\ {\bf toString}(  )
\label{jphase.Term.toString()}}%end signature
}%end item
\divideents{toStringE}
\item{\vskip -1.9ex 
\index{toStringE()}
\hypertarget{jphase.Term.toStringE()}{\membername{toStringE}}
{\tt public java.lang.String\ {\bf toStringE}(  )
\label{jphase.Term.toStringE()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Represents the term as a multiple of an Eralng pdf.
}
\item{{\bf Returns} -- 
aforementioned string 
}%end item
\end{itemize}
}%end item
\divideents{toStringP}
\item{\vskip -1.9ex 
\index{toStringP()}
\hypertarget{jphase.Term.toStringP()}{\membername{toStringP}}
{\tt public java.lang.String\ {\bf toStringP}(  )
\label{jphase.Term.toStringP()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

String representation of the Polynomial
}
\item{{\bf Returns} -- 
String representation of the Polynomial 
}%end item
\end{itemize}
}%end item
\divideents{toStringRTF}
\item{\vskip -1.9ex 
\index{toStringRTF()}
\hypertarget{jphase.Term.toStringRTF()}{\membername{toStringRTF}}
{\tt public java.lang.String\ {\bf toStringRTF}(  )
\label{jphase.Term.toStringRTF()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

RTF representation fo the term
}
\item{{\bf Returns} -- 
a string representing this term 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{Utils}
\subsection{\label{jphase.Utils}\index{Utils}{\bf {\it Class} Utils}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.Utils}{}\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class Utils
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.Utils()}{{\bf Utils()}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.Utils.binomial(int, int)}{{\bf binomial(int, int)}} Binomial coefficient\\
\hyperlink{jphase.Utils.distance(double[], double[])}{{\bf distance(double\lbrack \rbrack , double\lbrack \rbrack )}} Euclidean norm btween given arrays\\
\hyperlink{jphase.Utils.fact(int)}{{\bf fact(int)}} Factorial function ( n! ).\\
\hyperlink{jphase.Utils.gammaP(double, double)}{{\bf gammaP(double, double)}} Incomplete gamma function.\\
\hyperlink{jphase.Utils.initUpperTriangular(int)}{{\bf initUpperTriangular(int)}} Creates storage for un upper triangular matrix.\\
\hyperlink{jphase.Utils.lnBinomial(int, int)}{{\bf lnBinomial(int, int)}} ln Binomial coefficient.\\
\hyperlink{jphase.Utils.lnFactorial(int)}{{\bf lnFactorial(int)}} Computes the log of Factorial function\\
\hyperlink{jphase.Utils.lnGamma(double)}{{\bf lnGamma(double)}} Computes the log of gamma function.\\
\hyperlink{jphase.Utils.lnPermut(int, int)}{{\bf lnPermut(int, int)}} Computes ln( n!/(n-k)! )\\
\hyperlink{jphase.Utils.permut(int, int)}{{\bf permut(int, int)}} Computes n!/(n-k)!\\
\hyperlink{jphase.Utils.pow(double, int)}{{\bf pow(double, int)}} Power function obtained by multiplying.\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{Utils()}
\hypertarget{jphase.Utils()}{\membername{Utils}}
{\tt public\ {\bf Utils}(  )
\label{jphase.Utils()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{binomial(int, int)}
\hypertarget{jphase.Utils.binomial(int, int)}{\membername{binomial}}
{\tt public static double\ {\bf binomial}( {\tt int} {\bf n},
{\tt int} {\bf k} )
\label{jphase.Utils.binomial(int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Binomial coefficient
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- }
   \item{
\sld
{\tt k} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
n!/ k! (n-k)! 
}%end item
\end{itemize}
}%end item
\divideents{distance}
\item{\vskip -1.9ex 
\index{distance(double\lbrack \rbrack , double\lbrack \rbrack )}
\hypertarget{jphase.Utils.distance(double[], double[])}{\membername{distance}}
{\tt public static double\ {\bf distance}( {\tt double\lbrack \rbrack } {\bf v1},
{\tt double\lbrack \rbrack } {\bf v2} )
\label{jphase.Utils.distance(double[], double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Euclidean norm btween given arrays
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt v1} -- }
   \item{
\sld
{\tt v2} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Euclidean norm 
}%end item
\end{itemize}
}%end item
\divideents{fact}
\item{\vskip -1.9ex 
\index{fact(int)}
\hypertarget{jphase.Utils.fact(int)}{\membername{fact}}
{\tt public static double\ {\bf fact}( {\tt int} {\bf n} )
\label{jphase.Utils.fact(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Factorial function ( n! ).
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
n! 
}%end item
\end{itemize}
}%end item
\divideents{gammaP}
\item{\vskip -1.9ex 
\index{gammaP(double, double)}
\hypertarget{jphase.Utils.gammaP(double, double)}{\membername{gammaP}}
{\tt public static double\ {\bf gammaP}( {\tt double} {\bf a},
{\tt double} {\bf x} )
\label{jphase.Utils.gammaP(double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Incomplete gamma function. ;
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt a} -- argument}
   \item{
\sld
{\tt x} -- upper limit}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
integ\{0,infty,x\}\ e$\wedge$(-t) t$\wedge$a / gamma(a) dt 
}%end item
\end{itemize}
}%end item
\divideents{initUpperTriangular}
\item{\vskip -1.9ex 
\index{initUpperTriangular(int)}
\hypertarget{jphase.Utils.initUpperTriangular(int)}{\membername{initUpperTriangular}}
{\tt public static double\lbrack \rbrack \lbrack \rbrack \ {\bf initUpperTriangular}( {\tt int} {\bf n} )
\label{jphase.Utils.initUpperTriangular(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Creates storage for un upper triangular matrix.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
An nxn upper triangular matrix. 
}%end item
\end{itemize}
}%end item
\divideents{lnBinomial}
\item{\vskip -1.9ex 
\index{lnBinomial(int, int)}
\hypertarget{jphase.Utils.lnBinomial(int, int)}{\membername{lnBinomial}}
{\tt public static double\ {\bf lnBinomial}( {\tt int} {\bf n},
{\tt int} {\bf k} )
\label{jphase.Utils.lnBinomial(int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

ln Binomial coefficient.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- }
   \item{
\sld
{\tt k} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
ln \lbrack n!/ k! (n-k)!\rbrack  
}%end item
\end{itemize}
}%end item
\divideents{lnFactorial}
\item{\vskip -1.9ex 
\index{lnFactorial(int)}
\hypertarget{jphase.Utils.lnFactorial(int)}{\membername{lnFactorial}}
{\tt public static double\ {\bf lnFactorial}( {\tt int} {\bf n} )
\label{jphase.Utils.lnFactorial(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the log of Factorial function
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
ln (n!) 
}%end item
\end{itemize}
}%end item
\divideents{lnGamma}
\item{\vskip -1.9ex 
\index{lnGamma(double)}
\hypertarget{jphase.Utils.lnGamma(double)}{\membername{lnGamma}}
{\tt public static double\ {\bf lnGamma}( {\tt double} {\bf xx} )
\label{jphase.Utils.lnGamma(double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes the log of gamma function.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt xx} -- value}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
lnGamma(xx) 
}%end item
\end{itemize}
}%end item
\divideents{lnPermut}
\item{\vskip -1.9ex 
\index{lnPermut(int, int)}
\hypertarget{jphase.Utils.lnPermut(int, int)}{\membername{lnPermut}}
{\tt public static double\ {\bf lnPermut}( {\tt int} {\bf n},
{\tt int} {\bf k} )
\label{jphase.Utils.lnPermut(int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes ln( n!/(n-k)! )
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- }
   \item{
\sld
{\tt k} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
ln( n!/(n-k) )! 
}%end item
\end{itemize}
}%end item
\divideents{permut}
\item{\vskip -1.9ex 
\index{permut(int, int)}
\hypertarget{jphase.Utils.permut(int, int)}{\membername{permut}}
{\tt public static double\ {\bf permut}( {\tt int} {\bf n},
{\tt int} {\bf k} )
\label{jphase.Utils.permut(int, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Computes n!/(n-k)!
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n} -- }
   \item{
\sld
{\tt k} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Computes n!/(n-k)! 
}%end item
\end{itemize}
}%end item
\divideents{pow}
\item{\vskip -1.9ex 
\index{pow(double, int)}
\hypertarget{jphase.Utils.pow(double, int)}{\membername{pow}}
{\tt public static double\ {\bf pow}( {\tt double} {\bf x},
{\tt int} {\bf n} )
\label{jphase.Utils.pow(double, int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Power function obtained by multiplying.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- }
   \item{
\sld
{\tt n} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
x$\wedge$n 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage}
}
\newpage
\def\packagename{jphase.fit}
\chapter{\bf Package jphase.fit}{
\thispagestyle{empty}
\label{jphase.fit}\hypertarget{jphase.fit}{}
\markboth{\protect\packagename}{\protect\packagename}
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Interfaces}
\entityintro{PhaseFitter}{jphase.fit.PhaseFitter}{This class defines the behaviour that any class for fitting data to a Phase-Type distribution should have}
\vskip .13in
\hbox{\bf Classes}
\entityintro{ContPhaseFitter}{jphase.fit.ContPhaseFitter}{This class defines the behaviour that any class for fitting data to a Continuous Phase-Type distribution should have}
\entityintro{DiscPhaseFitter}{jphase.fit.DiscPhaseFitter}{This class defines the behaviour that any class for fitting data to a Discrete Phase-Type distribution should have}
\entityintro{EMHyperErlangFit}{jphase.fit.EMHyperErlangFit}{This class implements the Maximum Likelihood method proposed by Thmmler, Buchholz and Telek in "A novel approach for fitting probability distributions to real trace data with the EM algorithm", 2005.}
\entityintro{EMHyperExpoFit}{jphase.fit.EMHyperExpoFit}{This class implements the Maximum Likelihood method proposed by Khayari, Sadre and Haverkort in "Fitting world-wide web request traces with the EM algorithm", 2003.}
\entityintro{EMPhaseFit}{jphase.fit.EMPhaseFit}{This class implements the Maximum Likelihood method proposed by Asmussen, Nerman and Olsson in "Fitting Phase-type Distributions via the EM algorithm", 1996.}
\entityintro{FitterUtils}{jphase.fit.FitterUtils}{This class contains a set of methods to make some usual calculations for the PhaseFitter classes}
\entityintro{MLContPhaseFitter}{jphase.fit.MLContPhaseFitter}{This class defines the behaviour for a class that implements a maximum likelihood algorithm for fitting data to a Continuous Phase-Type distribution}
\entityintro{MLDiscPhaseFitter}{jphase.fit.MLDiscPhaseFitter}{This class defines the behaviour for a class that implements a maximum likelihood algorithm for fitting data to a Discrete Phase-Type distribution}
\entityintro{MomentsACPH2Fit}{jphase.fit.MomentsACPH2Fit}{This class implements the Matching Moments method proposed by Telek and Heindl in "Matching Moments for Acyclic discrete and continuous Phase-Type distributions of Second order", 2002.}
\entityintro{MomentsACPHFit}{jphase.fit.MomentsACPHFit}{* This class implements the Matching Moments method proposed by Bobbio, Horvath and Telek in "Matching threee moments with minimal acyclic Phase-Type distributions", 2005.}
\entityintro{MomentsADPH2Fit}{jphase.fit.MomentsADPH2Fit}{This class implements the Matching Moments method proposed by Telek and Heindl in "Matching Moments for Acyclic discrete and continuous Phase-Type distributions of Second order", 2002.}
\entityintro{MomentsContPhaseFitter}{jphase.fit.MomentsContPhaseFitter}{This class defines the behaviour for a class that implements a moment matching algorithm for fitting data to a Continuous Phase-Type distribution}
\entityintro{MomentsDiscPhaseFitter}{jphase.fit.MomentsDiscPhaseFitter}{This class defines the behaviour for a class that implements a moment matching algorithm for fitting data to a Discrete Phase-Type distribution}
\entityintro{MomentsECCompleteFit}{jphase.fit.MomentsECCompleteFit}{This class implements the Matching Moments method proposed by Osogami and Harchol in "Closed form solutions for mapping general distributions to quasi-minimal PH distributions", 2005.}
\entityintro{MomentsECPositiveFit}{jphase.fit.MomentsECPositiveFit}{This class implements the Matching Moments method proposed by Osogami and Harchol in "Closed form solutions for mapping general distributions to quasi-minimal PH distributions", 2005.}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
Provides capabilities for fitting Phase type distribution parameters from data. There exists very diferent algorithms to adjust the parameters of these distributions, which can be divided in two groups: moments based methods and maximum likelihood approaches. This package includes the implementation of some of these algorithms, a framework and a set of utilities for implement new methods. For overviews, tutorials, examples, guides, and tool documentation, please see:

\hyperref{http://copa.uniandes.edu.co}{}{}{Copa Group WEB page.} (at http://copa.uniandes.edu.co)\mbox{}\\ \rule{\hsize}{.7mm}
\vskip .1in
\newpage
\markboth{\protect\packagename \hspace{.02in} -- \protect\classname}{\protect\packagename \hspace{.02in} -- \protect\classname}
\section{Interfaces}{
\gdef\classname{PhaseFitter}
\subsection{\label{jphase.fit.PhaseFitter}\index{PhaseFitter@{\it PhaseFitter}}{\bf {\it Interface} PhaseFitter}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.PhaseFitter}{}\vskip .1in 
This class defines the behaviour that any class for fitting data to a Phase-Type distribution should have\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public interface PhaseFitter
}}}
\subsubsection{All known subclasses}{MomentsECPositiveFit\small{\refdefined{jphase.fit.MomentsECPositiveFit}}, MomentsECCompleteFit\small{\refdefined{jphase.fit.MomentsECCompleteFit}}, MomentsDiscPhaseFitter\small{\refdefined{jphase.fit.MomentsDiscPhaseFitter}}, MomentsContPhaseFitter\small{\refdefined{jphase.fit.MomentsContPhaseFitter}}, MomentsADPH2Fit\small{\refdefined{jphase.fit.MomentsADPH2Fit}}, MomentsACPHFit\small{\refdefined{jphase.fit.MomentsACPHFit}}, MomentsACPH2Fit\small{\refdefined{jphase.fit.MomentsACPH2Fit}}, MLDiscPhaseFitter\small{\refdefined{jphase.fit.MLDiscPhaseFitter}}, MLContPhaseFitter\small{\refdefined{jphase.fit.MLContPhaseFitter}}, EMPhaseFit\small{\refdefined{jphase.fit.EMPhaseFit}}, EMHyperExpoFit\small{\refdefined{jphase.fit.EMHyperExpoFit}}, EMHyperErlangFit\small{\refdefined{jphase.fit.EMHyperErlangFit}}, DiscPhaseFitter\small{\refdefined{jphase.fit.DiscPhaseFitter}}, ContPhaseFitter\small{\refdefined{jphase.fit.ContPhaseFitter}}}
\subsubsection{All classes known to implement interface}{DiscPhaseFitter\small{\refdefined{jphase.fit.DiscPhaseFitter}}, ContPhaseFitter\small{\refdefined{jphase.fit.ContPhaseFitter}}}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.PhaseFitter.fit()}{{\bf fit()}} Executes the fitting procedure to find the parameter set\\
\end{verse}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{fit()}
\hypertarget{jphase.fit.PhaseFitter.fit()}{\membername{fit}}
{\tt  jphase.PhaseVar\ {\bf fit}(  )
\label{jphase.fit.PhaseFitter.fit()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Executes the fitting procedure to find the parameter set
}
\item{{\bf Returns} -- 
Phase variable found 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage}
\section{Classes}{
\gdef\classname{ContPhaseFitter}
\subsection{\label{jphase.fit.ContPhaseFitter}\index{ContPhaseFitter}{\bf {\it Class} ContPhaseFitter}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.ContPhaseFitter}{}\vskip .1in 
This class defines the behaviour that any class for fitting data to a Continuous Phase-Type distribution should have\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class ContPhaseFitter
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
PhaseFitter}}}
\subsubsection{All known subclasses}{MomentsECPositiveFit\small{\refdefined{jphase.fit.MomentsECPositiveFit}}, MomentsECCompleteFit\small{\refdefined{jphase.fit.MomentsECCompleteFit}}, MomentsContPhaseFitter\small{\refdefined{jphase.fit.MomentsContPhaseFitter}}, MomentsACPHFit\small{\refdefined{jphase.fit.MomentsACPHFit}}, MomentsACPH2Fit\small{\refdefined{jphase.fit.MomentsACPH2Fit}}, MLContPhaseFitter\small{\refdefined{jphase.fit.MLContPhaseFitter}}, EMPhaseFit\small{\refdefined{jphase.fit.EMPhaseFit}}, EMHyperExpoFit\small{\refdefined{jphase.fit.EMHyperExpoFit}}, EMHyperErlangFit\small{\refdefined{jphase.fit.EMHyperErlangFit}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.fit.ContPhaseFitter.data}{{\bf data}} Non-negative data trace from independent experiments\\
\hyperlink{jphase.fit.ContPhaseFitter.var}{{\bf var}} Fitted Continuous Phase-Type variable\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.ContPhaseFitter(double[])}{{\bf ContPhaseFitter(double\lbrack \rbrack )}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.ContPhaseFitter.fit()}{{\bf fit()}} \\
\hyperlink{jphase.fit.ContPhaseFitter.getLogLikelihood()}{{\bf getLogLikelihood()}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{var}
\label{jphase.fit.ContPhaseFitter.var}\hypertarget{jphase.fit.ContPhaseFitter.var}{protected jphase.ContPhaseVar {\bf var}}
\begin{itemize}
\item{\vskip -.9ex 
Fitted Continuous Phase-Type variable}
\end{itemize}
}
\item{
\index{data}
\label{jphase.fit.ContPhaseFitter.data}\hypertarget{jphase.fit.ContPhaseFitter.data}{protected double {\bf data}}
\begin{itemize}
\item{\vskip -.9ex 
Non-negative data trace from independent experiments}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{ContPhaseFitter(double\lbrack \rbrack )}
\hypertarget{jphase.fit.ContPhaseFitter(double[])}{\membername{ContPhaseFitter}}
{\tt public\ {\bf ContPhaseFitter}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.ContPhaseFitter(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{fit()}
\hypertarget{jphase.fit.ContPhaseFitter.fit()}{\membername{fit}}
{\tt public abstract jphase.ContPhaseVar\ {\bf fit}(  )
\label{jphase.fit.ContPhaseFitter.fit()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.fit.PhaseFitter.fit()}{PhaseFitter.fit()}} {\small 
\refdefined{jphase.fit.PhaseFitter.fit()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getLogLikelihood}
\item{\vskip -1.9ex 
\index{getLogLikelihood()}
\hypertarget{jphase.fit.ContPhaseFitter.getLogLikelihood()}{\membername{getLogLikelihood}}
{\tt public double\ {\bf getLogLikelihood}(  )
\label{jphase.fit.ContPhaseFitter.getLogLikelihood()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
-1 if there is no data associated to the algorithm, 0 if there has not been found a ContPhaseVar yet, or the likelihood. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{DiscPhaseFitter}
\subsection{\label{jphase.fit.DiscPhaseFitter}\index{DiscPhaseFitter}{\bf {\it Class} DiscPhaseFitter}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.DiscPhaseFitter}{}\vskip .1in 
This class defines the behaviour that any class for fitting data to a Discrete Phase-Type distribution should have\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class DiscPhaseFitter
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}\\ {\bf implements} 
PhaseFitter}}}
\subsubsection{All known subclasses}{MomentsDiscPhaseFitter\small{\refdefined{jphase.fit.MomentsDiscPhaseFitter}}, MomentsADPH2Fit\small{\refdefined{jphase.fit.MomentsADPH2Fit}}, MLDiscPhaseFitter\small{\refdefined{jphase.fit.MLDiscPhaseFitter}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.fit.DiscPhaseFitter.data}{{\bf data}} Non-negative data trace from independent experiments\\
\hyperlink{jphase.fit.DiscPhaseFitter.var}{{\bf var}} Fitted Discrete Phase-Type variable\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.DiscPhaseFitter(int[])}{{\bf DiscPhaseFitter(int\lbrack \rbrack )}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.DiscPhaseFitter.fit()}{{\bf fit()}} \\
\hyperlink{jphase.fit.DiscPhaseFitter.getLogLikelihood()}{{\bf getLogLikelihood()}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{var}
\label{jphase.fit.DiscPhaseFitter.var}\hypertarget{jphase.fit.DiscPhaseFitter.var}{protected jphase.DiscPhaseVar {\bf var}}
\begin{itemize}
\item{\vskip -.9ex 
Fitted Discrete Phase-Type variable}
\end{itemize}
}
\item{
\index{data}
\label{jphase.fit.DiscPhaseFitter.data}\hypertarget{jphase.fit.DiscPhaseFitter.data}{protected int {\bf data}}
\begin{itemize}
\item{\vskip -.9ex 
Non-negative data trace from independent experiments}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{DiscPhaseFitter(int\lbrack \rbrack )}
\hypertarget{jphase.fit.DiscPhaseFitter(int[])}{\membername{DiscPhaseFitter}}
{\tt public\ {\bf DiscPhaseFitter}( {\tt int\lbrack \rbrack } {\bf data} )
\label{jphase.fit.DiscPhaseFitter(int[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{fit()}
\hypertarget{jphase.fit.DiscPhaseFitter.fit()}{\membername{fit}}
{\tt public abstract jphase.DiscPhaseVar\ {\bf fit}(  )
\label{jphase.fit.DiscPhaseFitter.fit()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.fit.PhaseFitter.fit()}{PhaseFitter.fit()}} {\small 
\refdefined{jphase.fit.PhaseFitter.fit()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{getLogLikelihood}
\item{\vskip -1.9ex 
\index{getLogLikelihood()}
\hypertarget{jphase.fit.DiscPhaseFitter.getLogLikelihood()}{\membername{getLogLikelihood}}
{\tt public double\ {\bf getLogLikelihood}(  )
\label{jphase.fit.DiscPhaseFitter.getLogLikelihood()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
-1 if there is no data associated to the algorithm, 0 if there has not been found a ContPhaseVar yet, or the likelihood. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{EMHyperErlangFit}
\subsection{\label{jphase.fit.EMHyperErlangFit}\index{EMHyperErlangFit}{\bf {\it Class} EMHyperErlangFit}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.EMHyperErlangFit}{}\vskip .1in 
This class implements the Maximum Likelihood method proposed by Thmmler, Buchholz and Telek in "A novel approach for fitting probability distributions to real trace data with the EM algorithm", 2005. The method matches the likelilihood of any distribution to a subclass of Phase-Type distributions known as Hyper-Erlang distributions.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class EMHyperErlangFit
\\ {\bf extends} jphase.fit.MLContPhaseFitter
\refdefined{jphase.fit.MLContPhaseFitter}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.fit.EMHyperErlangFit.precision}{{\bf precision}} Precision for the convergence criterion in the algorithm\\
\hyperlink{jphase.fit.EMHyperErlangFit.precisionCV}{{\bf precisionCV}} Precision for the convergence criterion in the coefficient of variance\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.EMHyperErlangFit(double[])}{{\bf EMHyperErlangFit(double\lbrack \rbrack )}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.EMHyperErlangFit.doFitHyperErlang(double[])}{{\bf doFitHyperErlang(double\lbrack \rbrack )}} Returns a HyperErlang variable with the best fit\\
\hyperlink{jphase.fit.EMHyperErlangFit.doFitNM(double[], jphase.HyperErlangVar)}{{\bf doFitNM(double\lbrack \rbrack , HyperErlangVar)}} This method returns a completely specified HyperErlang variable, such that it has the best likelihood between all the possible combinations of N phases in M branches\\
\hyperlink{jphase.fit.EMHyperErlangFit.doFitNMR(double[], jphase.HyperErlangVar)}{{\bf doFitNMR(double\lbrack \rbrack , HyperErlangVar)}} This method returns a completely specified HyperErlang variable, such that it has the best likelihood after the execution of the EM algorithm for the case where the variable has N phases in M branches, distributed as determined by the vector r\\
\hyperlink{jphase.fit.EMHyperErlangFit.fit()}{{\bf fit()}} Returns a HyperErlang variable with the best fit, in the form of a Dense Continuous Phase variable\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{precision}
\label{jphase.fit.EMHyperErlangFit.precision}\hypertarget{jphase.fit.EMHyperErlangFit.precision}{public static double {\bf precision}}
\begin{itemize}
\item{\vskip -.9ex 
Precision for the convergence criterion in the algorithm}
\end{itemize}
}
\item{
\index{precisionCV}
\label{jphase.fit.EMHyperErlangFit.precisionCV}\hypertarget{jphase.fit.EMHyperErlangFit.precisionCV}{public static double {\bf precisionCV}}
\begin{itemize}
\item{\vskip -.9ex 
Precision for the convergence criterion in the coefficient of variance}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{EMHyperErlangFit(double\lbrack \rbrack )}
\hypertarget{jphase.fit.EMHyperErlangFit(double[])}{\membername{EMHyperErlangFit}}
{\tt public\ {\bf EMHyperErlangFit}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.EMHyperErlangFit(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{doFitHyperErlang(double\lbrack \rbrack )}
\hypertarget{jphase.fit.EMHyperErlangFit.doFitHyperErlang(double[])}{\membername{doFitHyperErlang}}
{\tt public jphase.HyperErlangVar\ {\bf doFitHyperErlang}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.EMHyperErlangFit.doFitHyperErlang(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a HyperErlang variable with the best fit
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- non-negative data trace from independent experiments to be fitted}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
HyperErlang variable with the best fit 
}%end item
\end{itemize}
}%end item
\divideents{doFitNM}
\item{\vskip -1.9ex 
\index{doFitNM(double\lbrack \rbrack , HyperErlangVar)}
\hypertarget{jphase.fit.EMHyperErlangFit.doFitNM(double[], jphase.HyperErlangVar)}{\membername{doFitNM}}
{\tt public double\ {\bf doFitNM}( {\tt double\lbrack \rbrack } {\bf data},
{\tt jphase.HyperErlangVar} {\bf var} )
\label{jphase.fit.EMHyperErlangFit.doFitNM(double[], jphase.HyperErlangVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method returns a completely specified HyperErlang variable, such that it has the best likelihood between all the possible combinations of N phases in M branches
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- non-negative data trace from independent experiments to be fitted}
   \item{
\sld
{\tt var} -- HyperErlang variable with the parameters N and M determined}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Likelihood of the best variable found. The variable is modified with the best parameters found. 
}%end item
\end{itemize}
}%end item
\divideents{doFitNMR}
\item{\vskip -1.9ex 
\index{doFitNMR(double\lbrack \rbrack , HyperErlangVar)}
\hypertarget{jphase.fit.EMHyperErlangFit.doFitNMR(double[], jphase.HyperErlangVar)}{\membername{doFitNMR}}
{\tt public double\ {\bf doFitNMR}( {\tt double\lbrack \rbrack } {\bf data},
{\tt jphase.HyperErlangVar} {\bf var} )
\label{jphase.fit.EMHyperErlangFit.doFitNMR(double[], jphase.HyperErlangVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method returns a completely specified HyperErlang variable, such that it has the best likelihood after the execution of the EM algorithm for the case where the variable has N phases in M branches, distributed as determined by the vector r
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- non-negative data trace from independent experiments to be fitted}
   \item{
\sld
{\tt var} -- HyperErlang variable with the parameters N, M and r determined}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Likelihood of the best variable found. The variable is modified with the best parameters found. 
}%end item
\end{itemize}
}%end item
\divideents{fit}
\item{\vskip -1.9ex 
\index{fit()}
\hypertarget{jphase.fit.EMHyperErlangFit.fit()}{\membername{fit}}
{\tt public jphase.DenseContPhaseVar\ {\bf fit}(  )
\label{jphase.fit.EMHyperErlangFit.fit()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a HyperErlang variable with the best fit, in the form of a Dense Continuous Phase variable
}
\item{{\bf Returns} -- 
HyperErlang variable with the best fit 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.MLContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.MLContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jphase.fit.ContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.ContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract ContPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{EMHyperExpoFit}
\subsection{\label{jphase.fit.EMHyperExpoFit}\index{EMHyperExpoFit}{\bf {\it Class} EMHyperExpoFit}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.EMHyperExpoFit}{}\vskip .1in 
This class implements the Maximum Likelihood method proposed by Khayari, Sadre and Haverkort in "Fitting world-wide web request traces with the EM algorithm", 2003. The method matches the likelilihood of heavy tailed distributions to the class of Hyper-Exponential distributions.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class EMHyperExpoFit
\\ {\bf extends} jphase.fit.MLContPhaseFitter
\refdefined{jphase.fit.MLContPhaseFitter}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.fit.EMHyperExpoFit.precision}{{\bf precision}} Precision for the convergence criterion in the algorithm\\
\hyperlink{jphase.fit.EMHyperExpoFit.precisionParam}{{\bf precisionParam}} Precision for the convergence criterion in the coefficient of variance\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.EMHyperExpoFit(double[])}{{\bf EMHyperExpoFit(double\lbrack \rbrack )}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.EMHyperExpoFit.doFitN(double[])}{{\bf doFitN(double\lbrack \rbrack )}} This method implements the EM algorithm from the data, with the specified number of exponential phases\\
\hyperlink{jphase.fit.EMHyperExpoFit.fit()}{{\bf fit()}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{precision}
\label{jphase.fit.EMHyperExpoFit.precision}\hypertarget{jphase.fit.EMHyperExpoFit.precision}{public static double {\bf precision}}
\begin{itemize}
\item{\vskip -.9ex 
Precision for the convergence criterion in the algorithm}
\end{itemize}
}
\item{
\index{precisionParam}
\label{jphase.fit.EMHyperExpoFit.precisionParam}\hypertarget{jphase.fit.EMHyperExpoFit.precisionParam}{public static double {\bf precisionParam}}
\begin{itemize}
\item{\vskip -.9ex 
Precision for the convergence criterion in the coefficient of variance}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{EMHyperExpoFit(double\lbrack \rbrack )}
\hypertarget{jphase.fit.EMHyperExpoFit(double[])}{\membername{EMHyperExpoFit}}
{\tt public\ {\bf EMHyperExpoFit}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.EMHyperExpoFit(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{doFitN(double\lbrack \rbrack )}
\hypertarget{jphase.fit.EMHyperExpoFit.doFitN(double[])}{\membername{doFitN}}
{\tt public double\ {\bf doFitN}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.EMHyperExpoFit.doFitN(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method implements the EM algorithm from the data, with the specified number of exponential phases
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- non-negative data trace from independent experiments}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The loglikelihood of the solution found. The values of the parameters are stored in the attributes probs and rates 
}%end item
\end{itemize}
}%end item
\divideents{fit}
\item{\vskip -1.9ex 
\index{fit()}
\hypertarget{jphase.fit.EMHyperExpoFit.fit()}{\membername{fit}}
{\tt public abstract jphase.ContPhaseVar\ {\bf fit}(  )
\label{jphase.fit.EMHyperExpoFit.fit()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.fit.PhaseFitter.fit()}{PhaseFitter.fit()}} {\small 
\refdefined{jphase.fit.PhaseFitter.fit()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.MLContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.MLContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jphase.fit.ContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.ContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract ContPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{EMPhaseFit}
\subsection{\label{jphase.fit.EMPhaseFit}\index{EMPhaseFit}{\bf {\it Class} EMPhaseFit}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.EMPhaseFit}{}\vskip .1in 
This class implements the Maximum Likelihood method proposed by Asmussen, Nerman and Olsson in "Fitting Phase-type Distributions via the EM algorithm", 1996. The method matches the likelilihood of any distribution to the entire class of Phase-Type distributions.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class EMPhaseFit
\\ {\bf extends} jphase.fit.MLContPhaseFitter
\refdefined{jphase.fit.MLContPhaseFitter}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.fit.EMPhaseFit.evalPoints}{{\bf evalPoints}} Constant to multiply thesize of the data trace to obtain the number of evaluation points.\\
\hyperlink{jphase.fit.EMPhaseFit.logPrecision}{{\bf logPrecision}} \\
\hyperlink{jphase.fit.EMPhaseFit.precision}{{\bf precision}} Precision for the convergence criterion in the algorithm\\
\hyperlink{jphase.fit.EMPhaseFit.precisionParam}{{\bf precisionParam}} Precision for the convergence criterion in the coefficient of variance\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.EMPhaseFit(double[])}{{\bf EMPhaseFit(double\lbrack \rbrack )}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.EMPhaseFit.doFitN(double[])}{{\bf doFitN(double\lbrack \rbrack )}} \\
\hyperlink{jphase.fit.EMPhaseFit.fit()}{{\bf fit()}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{precision}
\label{jphase.fit.EMPhaseFit.precision}\hypertarget{jphase.fit.EMPhaseFit.precision}{public static double {\bf precision}}
\begin{itemize}
\item{\vskip -.9ex 
Precision for the convergence criterion in the algorithm}
\end{itemize}
}
\item{
\index{logPrecision}
\label{jphase.fit.EMPhaseFit.logPrecision}\hypertarget{jphase.fit.EMPhaseFit.logPrecision}{public static double {\bf logPrecision}}
}
\item{
\index{precisionParam}
\label{jphase.fit.EMPhaseFit.precisionParam}\hypertarget{jphase.fit.EMPhaseFit.precisionParam}{public static double {\bf precisionParam}}
\begin{itemize}
\item{\vskip -.9ex 
Precision for the convergence criterion in the coefficient of variance}
\end{itemize}
}
\item{
\index{evalPoints}
\label{jphase.fit.EMPhaseFit.evalPoints}\hypertarget{jphase.fit.EMPhaseFit.evalPoints}{public static int {\bf evalPoints}}
\begin{itemize}
\item{\vskip -.9ex 
Constant to multiply thesize of the data trace to obtain the number of evaluation points. The number of evaluation points in the Runge-Kutta algorithm is the size of the data trace times evalPoints}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{EMPhaseFit(double\lbrack \rbrack )}
\hypertarget{jphase.fit.EMPhaseFit(double[])}{\membername{EMPhaseFit}}
{\tt public\ {\bf EMPhaseFit}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.EMPhaseFit(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{doFitN(double\lbrack \rbrack )}
\hypertarget{jphase.fit.EMPhaseFit.doFitN(double[])}{\membername{doFitN}}
{\tt public double\ {\bf doFitN}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.EMPhaseFit.doFitN(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The loglikelihood 
}%end item
\end{itemize}
}%end item
\divideents{fit}
\item{\vskip -1.9ex 
\index{fit()}
\hypertarget{jphase.fit.EMPhaseFit.fit()}{\membername{fit}}
{\tt public abstract jphase.ContPhaseVar\ {\bf fit}(  )
\label{jphase.fit.EMPhaseFit.fit()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.fit.PhaseFitter.fit()}{PhaseFitter.fit()}} {\small 
\refdefined{jphase.fit.PhaseFitter.fit()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.MLContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.MLContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jphase.fit.ContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.ContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract ContPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{FitterUtils}
\subsection{\label{jphase.fit.FitterUtils}\index{FitterUtils}{\bf {\it Class} FitterUtils}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.FitterUtils}{}\vskip .1in 
This class contains a set of methods to make some usual calculations for the PhaseFitter classes\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class FitterUtils
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.FitterUtils()}{{\bf FitterUtils()}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.FitterUtils.ceil(double, double)}{{\bf ceil(double, double)}} Calculates the ceil of a double with a predefined precision\\
\hyperlink{jphase.fit.FitterUtils.factMomentK(int[], int)}{{\bf factMomentK(int\lbrack \rbrack , int)}} Calculates the k-th factorial moment of the data trace\\
\hyperlink{jphase.fit.FitterUtils.floor(double, double)}{{\bf floor(double, double)}} Calculates the floor of a double with a predefined precision\\
\hyperlink{jphase.fit.FitterUtils.powerMomentK(double[], int)}{{\bf powerMomentK(double\lbrack \rbrack , int)}} Calculates the k-th power moment of the data trace\\
\hyperlink{jphase.fit.FitterUtils.sqrt(double, double)}{{\bf sqrt(double, double)}} Calculates the square root of a double with a predefined precision\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{FitterUtils()}
\hypertarget{jphase.fit.FitterUtils()}{\membername{FitterUtils}}
{\tt public\ {\bf FitterUtils}(  )
\label{jphase.fit.FitterUtils()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{ceil(double, double)}
\hypertarget{jphase.fit.FitterUtils.ceil(double, double)}{\membername{ceil}}
{\tt public static double\ {\bf ceil}( {\tt double} {\bf x},
{\tt double} {\bf epsilon} )
\label{jphase.fit.FitterUtils.ceil(double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Calculates the ceil of a double with a predefined precision
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- }
   \item{
\sld
{\tt epsilon} -- precision}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The ceil of a double with the predefined precision 
}%end item
\end{itemize}
}%end item
\divideents{factMomentK}
\item{\vskip -1.9ex 
\index{factMomentK(int\lbrack \rbrack , int)}
\hypertarget{jphase.fit.FitterUtils.factMomentK(int[], int)}{\membername{factMomentK}}
{\tt public static double\ {\bf factMomentK}( {\tt int\lbrack \rbrack } {\bf data},
{\tt int} {\bf k} )
\label{jphase.fit.FitterUtils.factMomentK(int[], int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Calculates the k-th factorial moment of the data trace
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- data trace}
   \item{
\sld
{\tt k} -- factorial moment to be calculated (\textgreater = 1)}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Data k-th factorial Moment 
}%end item
\end{itemize}
}%end item
\divideents{floor}
\item{\vskip -1.9ex 
\index{floor(double, double)}
\hypertarget{jphase.fit.FitterUtils.floor(double, double)}{\membername{floor}}
{\tt public static double\ {\bf floor}( {\tt double} {\bf x},
{\tt double} {\bf epsilon} )
\label{jphase.fit.FitterUtils.floor(double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Calculates the floor of a double with a predefined precision
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- }
   \item{
\sld
{\tt epsilon} -- precision}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The floor of a double with the predefined precision 
}%end item
\end{itemize}
}%end item
\divideents{powerMomentK}
\item{\vskip -1.9ex 
\index{powerMomentK(double\lbrack \rbrack , int)}
\hypertarget{jphase.fit.FitterUtils.powerMomentK(double[], int)}{\membername{powerMomentK}}
{\tt public static double\ {\bf powerMomentK}( {\tt double\lbrack \rbrack } {\bf data},
{\tt int} {\bf k} )
\label{jphase.fit.FitterUtils.powerMomentK(double[], int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Calculates the k-th power moment of the data trace
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- data trace}
   \item{
\sld
{\tt k} -- power moment to be calculated (\textgreater = 1)}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Data k-th power Moment 
}%end item
\end{itemize}
}%end item
\divideents{sqrt}
\item{\vskip -1.9ex 
\index{sqrt(double, double)}
\hypertarget{jphase.fit.FitterUtils.sqrt(double, double)}{\membername{sqrt}}
{\tt public static double\ {\bf sqrt}( {\tt double} {\bf x},
{\tt double} {\bf epsilon} )
\label{jphase.fit.FitterUtils.sqrt(double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Calculates the square root of a double with a predefined precision
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt x} -- }
   \item{
\sld
{\tt epsilon} -- precision}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The square root of a double with the predefined precision 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{MLContPhaseFitter}
\subsection{\label{jphase.fit.MLContPhaseFitter}\index{MLContPhaseFitter}{\bf {\it Class} MLContPhaseFitter}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.MLContPhaseFitter}{}\vskip .1in 
This class defines the behaviour for a class that implements a maximum likelihood algorithm for fitting data to a Continuous Phase-Type distribution\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class MLContPhaseFitter
\\ {\bf extends} jphase.fit.ContPhaseFitter
\refdefined{jphase.fit.ContPhaseFitter}}}}
\subsubsection{All known subclasses}{EMPhaseFit\small{\refdefined{jphase.fit.EMPhaseFit}}, EMHyperExpoFit\small{\refdefined{jphase.fit.EMHyperExpoFit}}, EMHyperErlangFit\small{\refdefined{jphase.fit.EMHyperErlangFit}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.MLContPhaseFitter(double[])}{{\bf MLContPhaseFitter(double\lbrack \rbrack )}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.MLContPhaseFitter.getLogLikelihood()}{{\bf getLogLikelihood()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MLContPhaseFitter(double\lbrack \rbrack )}
\hypertarget{jphase.fit.MLContPhaseFitter(double[])}{\membername{MLContPhaseFitter}}
{\tt public\ {\bf MLContPhaseFitter}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.MLContPhaseFitter(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getLogLikelihood()}
\hypertarget{jphase.fit.MLContPhaseFitter.getLogLikelihood()}{\membername{getLogLikelihood}}
{\tt public double\ {\bf getLogLikelihood}(  )
\label{jphase.fit.MLContPhaseFitter.getLogLikelihood()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
-1 if there is no data associated to the algorithm, 0 if there has not been found a ContPhaseVar yet, or the likelihood. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.ContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.ContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract ContPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MLDiscPhaseFitter}
\subsection{\label{jphase.fit.MLDiscPhaseFitter}\index{MLDiscPhaseFitter}{\bf {\it Class} MLDiscPhaseFitter}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.MLDiscPhaseFitter}{}\vskip .1in 
This class defines the behaviour for a class that implements a maximum likelihood algorithm for fitting data to a Discrete Phase-Type distribution\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class MLDiscPhaseFitter
\\ {\bf extends} jphase.fit.DiscPhaseFitter
\refdefined{jphase.fit.DiscPhaseFitter}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.MLDiscPhaseFitter(int[])}{{\bf MLDiscPhaseFitter(int\lbrack \rbrack )}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.MLDiscPhaseFitter.getLogLikelihood()}{{\bf getLogLikelihood()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MLDiscPhaseFitter(int\lbrack \rbrack )}
\hypertarget{jphase.fit.MLDiscPhaseFitter(int[])}{\membername{MLDiscPhaseFitter}}
{\tt public\ {\bf MLDiscPhaseFitter}( {\tt int\lbrack \rbrack } {\bf data} )
\label{jphase.fit.MLDiscPhaseFitter(int[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getLogLikelihood()}
\hypertarget{jphase.fit.MLDiscPhaseFitter.getLogLikelihood()}{\membername{getLogLikelihood}}
{\tt public double\ {\bf getLogLikelihood}(  )
\label{jphase.fit.MLDiscPhaseFitter.getLogLikelihood()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
-1 if there is no data associated to the algorithm, 0 if there has not been found a ContPhaseVar yet, or the likelihood. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.DiscPhaseFitter} \textnormal{\small\refdefined{jphase.fit.DiscPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract DiscPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MomentsACPH2Fit}
\subsection{\label{jphase.fit.MomentsACPH2Fit}\index{MomentsACPH2Fit}{\bf {\it Class} MomentsACPH2Fit}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.MomentsACPH2Fit}{}\vskip .1in 
This class implements the Matching Moments method proposed by Telek and Heindl in "Matching Moments for Acyclic discrete and continuous Phase-Type distributions of Second order", 2002. This is for the continuous case.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class MomentsACPH2Fit
\\ {\bf extends} jphase.fit.MomentsContPhaseFitter
\refdefined{jphase.fit.MomentsContPhaseFitter}}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsACPH2Fit.precision}{{\bf precision}} TODO get precision precision for calculations and convergence criterion\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsACPH2Fit(double[])}{{\bf MomentsACPH2Fit(double\lbrack \rbrack )}} \\
\hyperlink{jphase.fit.MomentsACPH2Fit(double, double, double)}{{\bf MomentsACPH2Fit(double, double, double)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsACPH2Fit.fit()}{{\bf fit()}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{precision}
\label{jphase.fit.MomentsACPH2Fit.precision}\hypertarget{jphase.fit.MomentsACPH2Fit.precision}{public static double {\bf precision}}
\begin{itemize}
\item{\vskip -.9ex 
TODO get precision precision for calculations and convergence criterion}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MomentsACPH2Fit(double\lbrack \rbrack )}
\hypertarget{jphase.fit.MomentsACPH2Fit(double[])}{\membername{MomentsACPH2Fit}}
{\tt public\ {\bf MomentsACPH2Fit}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.MomentsACPH2Fit(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- Data to be fitted}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MomentsACPH2Fit}
\item{\vskip -1.9ex 
\index{MomentsACPH2Fit(double, double, double)}
\hypertarget{jphase.fit.MomentsACPH2Fit(double, double, double)}{\membername{MomentsACPH2Fit}}
{\tt public\ {\bf MomentsACPH2Fit}( {\tt double} {\bf m1},
{\tt double} {\bf m2},
{\tt double} {\bf m3} )
\label{jphase.fit.MomentsACPH2Fit(double, double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt m1} -- }
   \item{
\sld
{\tt m2} -- }
   \item{
\sld
{\tt m3} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{fit()}
\hypertarget{jphase.fit.MomentsACPH2Fit.fit()}{\membername{fit}}
{\tt public abstract jphase.ContPhaseVar\ {\bf fit}(  )
\label{jphase.fit.MomentsACPH2Fit.fit()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.fit.PhaseFitter.fit()}{PhaseFitter.fit()}} {\small 
\refdefined{jphase.fit.PhaseFitter.fit()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.MomentsContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.MomentsContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf m1}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf m2}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf m3}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jphase.fit.ContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.ContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract ContPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MomentsACPHFit}
\subsection{\label{jphase.fit.MomentsACPHFit}\index{MomentsACPHFit}{\bf {\it Class} MomentsACPHFit}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.MomentsACPHFit}{}\vskip .1in 
* This class implements the Matching Moments method proposed by Bobbio, Horvath and Telek in "Matching threee moments with minimal acyclic Phase-Type distributions", 2005. The method match the first three moments of any distribution to a subclass of Phase-Type distributions known as Acyclic Phase-Type distributions.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class MomentsACPHFit
\\ {\bf extends} jphase.fit.MomentsContPhaseFitter
\refdefined{jphase.fit.MomentsContPhaseFitter}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsACPHFit(double[])}{{\bf MomentsACPHFit(double\lbrack \rbrack )}} \\
\hyperlink{jphase.fit.MomentsACPHFit(double, double, double)}{{\bf MomentsACPHFit(double, double, double)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsACPHFit.fit()}{{\bf fit()}} Solve the equation system to get the parameters of the distribution, if the moments are feasible\\
\hyperlink{jphase.fit.MomentsACPHFit.getSize(double, double)}{{\bf getSize(double, double)}} Calculates the minimum number of phases needed to represent the tuple of the normalized moments\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MomentsACPHFit(double\lbrack \rbrack )}
\hypertarget{jphase.fit.MomentsACPHFit(double[])}{\membername{MomentsACPHFit}}
{\tt public\ {\bf MomentsACPHFit}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.MomentsACPHFit(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MomentsACPHFit}
\item{\vskip -1.9ex 
\index{MomentsACPHFit(double, double, double)}
\hypertarget{jphase.fit.MomentsACPHFit(double, double, double)}{\membername{MomentsACPHFit}}
{\tt public\ {\bf MomentsACPHFit}( {\tt double} {\bf m1},
{\tt double} {\bf m2},
{\tt double} {\bf m3} )
\label{jphase.fit.MomentsACPHFit(double, double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt m1} -- }
   \item{
\sld
{\tt m2} -- }
   \item{
\sld
{\tt m3} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{fit()}
\hypertarget{jphase.fit.MomentsACPHFit.fit()}{\membername{fit}}
{\tt public jphase.ContPhaseVar\ {\bf fit}(  )
\label{jphase.fit.MomentsACPHFit.fit()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Solve the equation system to get the parameters of the distribution, if the moments are feasible
}
\item{{\bf Returns} -- 
Parameters of the Acyclic Continuous Phase Distribution of order n. param\lbrack 0\rbrack =n, param\lbrack 1\rbrack =p, param\lbrack 2\rbrack =lambdaY, param\lbrack 3\rbrack =lambdaX1, param\lbrack 4\rbrack =lambdaX2, param\lbrack 5\rbrack =pX 
}%end item
\end{itemize}
}%end item
\divideents{getSize}
\item{\vskip -1.9ex 
\index{getSize(double, double)}
\hypertarget{jphase.fit.MomentsACPHFit.getSize(double, double)}{\membername{getSize}}
{\tt public int\ {\bf getSize}( {\tt double} {\bf n2},
{\tt double} {\bf n3} )
\label{jphase.fit.MomentsACPHFit.getSize(double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Calculates the minimum number of phases needed to represent the tuple of the normalized moments
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt n2} -- Second normalized moment}
   \item{
\sld
{\tt n3} -- Third normalized moment}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Minimum number of phases needed to represent the tuple of the normalized moments 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.MomentsContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.MomentsContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf m1}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf m2}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf m3}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jphase.fit.ContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.ContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract ContPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MomentsADPH2Fit}
\subsection{\label{jphase.fit.MomentsADPH2Fit}\index{MomentsADPH2Fit}{\bf {\it Class} MomentsADPH2Fit}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.MomentsADPH2Fit}{}\vskip .1in 
This class implements the Matching Moments method proposed by Telek and Heindl in "Matching Moments for Acyclic discrete and continuous Phase-Type distributions of Second order", 2002. This is for the discrete case.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class MomentsADPH2Fit
\\ {\bf extends} jphase.fit.MomentsDiscPhaseFitter
\refdefined{jphase.fit.MomentsDiscPhaseFitter}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsADPH2Fit(double, double, double)}{{\bf MomentsADPH2Fit(double, double, double)}} \\
\hyperlink{jphase.fit.MomentsADPH2Fit(int[])}{{\bf MomentsADPH2Fit(int\lbrack \rbrack )}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsADPH2Fit.fit()}{{\bf fit()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MomentsADPH2Fit(double, double, double)}
\hypertarget{jphase.fit.MomentsADPH2Fit(double, double, double)}{\membername{MomentsADPH2Fit}}
{\tt public\ {\bf MomentsADPH2Fit}( {\tt double} {\bf m1},
{\tt double} {\bf m2},
{\tt double} {\bf m3} )
\label{jphase.fit.MomentsADPH2Fit(double, double, double)}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.fit.MomentsDiscPhaseFitter(double, double, double)}{MomentsDiscPhaseFitter(double,\allowbreak double,\allowbreak double)}} {\small 
\refdefined{jphase.fit.MomentsDiscPhaseFitter(double, double, double)}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MomentsADPH2Fit}
\item{\vskip -1.9ex 
\index{MomentsADPH2Fit(int\lbrack \rbrack )}
\hypertarget{jphase.fit.MomentsADPH2Fit(int[])}{\membername{MomentsADPH2Fit}}
{\tt public\ {\bf MomentsADPH2Fit}( {\tt int\lbrack \rbrack } {\bf data} )
\label{jphase.fit.MomentsADPH2Fit(int[])}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.fit.MomentsDiscPhaseFitter(int[])}{MomentsDiscPhaseFitter(int\lbrack \rbrack )}} {\small 
\refdefined{jphase.fit.MomentsDiscPhaseFitter(int[])}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{fit()}
\hypertarget{jphase.fit.MomentsADPH2Fit.fit()}{\membername{fit}}
{\tt public abstract jphase.DiscPhaseVar\ {\bf fit}(  )
\label{jphase.fit.MomentsADPH2Fit.fit()}}%end signature
\begin{itemize}
\item{{\bf See also}
  \begin{itemize}
\item{ {\tt \hyperlink{jphase.fit.PhaseFitter.fit()}{PhaseFitter.fit()}} {\small 
\refdefined{jphase.fit.PhaseFitter.fit()}}%end
}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.MomentsDiscPhaseFitter} \textnormal{\small\refdefined{jphase.fit.MomentsDiscPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf m1}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf m2}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf m3}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jphase.fit.DiscPhaseFitter} \textnormal{\small\refdefined{jphase.fit.DiscPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract DiscPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MomentsContPhaseFitter}
\subsection{\label{jphase.fit.MomentsContPhaseFitter}\index{MomentsContPhaseFitter}{\bf {\it Class} MomentsContPhaseFitter}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.MomentsContPhaseFitter}{}\vskip .1in 
This class defines the behaviour for a class that implements a moment matching algorithm for fitting data to a Continuous Phase-Type distribution\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class MomentsContPhaseFitter
\\ {\bf extends} jphase.fit.ContPhaseFitter
\refdefined{jphase.fit.ContPhaseFitter}}}}
\subsubsection{All known subclasses}{MomentsECPositiveFit\small{\refdefined{jphase.fit.MomentsECPositiveFit}}, MomentsECCompleteFit\small{\refdefined{jphase.fit.MomentsECCompleteFit}}, MomentsACPHFit\small{\refdefined{jphase.fit.MomentsACPHFit}}, MomentsACPH2Fit\small{\refdefined{jphase.fit.MomentsACPH2Fit}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsContPhaseFitter.m1}{{\bf m1}} \\
\hyperlink{jphase.fit.MomentsContPhaseFitter.m2}{{\bf m2}} \\
\hyperlink{jphase.fit.MomentsContPhaseFitter.m3}{{\bf m3}} \\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsContPhaseFitter(double[])}{{\bf MomentsContPhaseFitter(double\lbrack \rbrack )}} \\
\hyperlink{jphase.fit.MomentsContPhaseFitter(double, double, double)}{{\bf MomentsContPhaseFitter(double, double, double)}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{m1}
\label{jphase.fit.MomentsContPhaseFitter.m1}\hypertarget{jphase.fit.MomentsContPhaseFitter.m1}{protected double {\bf m1}}
}
\item{
\index{m2}
\label{jphase.fit.MomentsContPhaseFitter.m2}\hypertarget{jphase.fit.MomentsContPhaseFitter.m2}{protected double {\bf m2}}
}
\item{
\index{m3}
\label{jphase.fit.MomentsContPhaseFitter.m3}\hypertarget{jphase.fit.MomentsContPhaseFitter.m3}{protected double {\bf m3}}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MomentsContPhaseFitter(double\lbrack \rbrack )}
\hypertarget{jphase.fit.MomentsContPhaseFitter(double[])}{\membername{MomentsContPhaseFitter}}
{\tt public\ {\bf MomentsContPhaseFitter}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.MomentsContPhaseFitter(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MomentsContPhaseFitter}
\item{\vskip -1.9ex 
\index{MomentsContPhaseFitter(double, double, double)}
\hypertarget{jphase.fit.MomentsContPhaseFitter(double, double, double)}{\membername{MomentsContPhaseFitter}}
{\tt public\ {\bf MomentsContPhaseFitter}( {\tt double} {\bf m1},
{\tt double} {\bf m2},
{\tt double} {\bf m3} )
\label{jphase.fit.MomentsContPhaseFitter(double, double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt m1} -- }
   \item{
\sld
{\tt m2} -- }
   \item{
\sld
{\tt m3} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.ContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.ContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract ContPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MomentsDiscPhaseFitter}
\subsection{\label{jphase.fit.MomentsDiscPhaseFitter}\index{MomentsDiscPhaseFitter}{\bf {\it Class} MomentsDiscPhaseFitter}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.MomentsDiscPhaseFitter}{}\vskip .1in 
This class defines the behaviour for a class that implements a moment matching algorithm for fitting data to a Discrete Phase-Type distribution\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class MomentsDiscPhaseFitter
\\ {\bf extends} jphase.fit.DiscPhaseFitter
\refdefined{jphase.fit.DiscPhaseFitter}}}}
\subsubsection{All known subclasses}{MomentsADPH2Fit\small{\refdefined{jphase.fit.MomentsADPH2Fit}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsDiscPhaseFitter.m1}{{\bf m1}} \\
\hyperlink{jphase.fit.MomentsDiscPhaseFitter.m2}{{\bf m2}} \\
\hyperlink{jphase.fit.MomentsDiscPhaseFitter.m3}{{\bf m3}} \\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsDiscPhaseFitter(double, double, double)}{{\bf MomentsDiscPhaseFitter(double, double, double)}} \\
\hyperlink{jphase.fit.MomentsDiscPhaseFitter(int[])}{{\bf MomentsDiscPhaseFitter(int\lbrack \rbrack )}} \\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{m1}
\label{jphase.fit.MomentsDiscPhaseFitter.m1}\hypertarget{jphase.fit.MomentsDiscPhaseFitter.m1}{protected double {\bf m1}}
}
\item{
\index{m2}
\label{jphase.fit.MomentsDiscPhaseFitter.m2}\hypertarget{jphase.fit.MomentsDiscPhaseFitter.m2}{protected double {\bf m2}}
}
\item{
\index{m3}
\label{jphase.fit.MomentsDiscPhaseFitter.m3}\hypertarget{jphase.fit.MomentsDiscPhaseFitter.m3}{protected double {\bf m3}}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MomentsDiscPhaseFitter(double, double, double)}
\hypertarget{jphase.fit.MomentsDiscPhaseFitter(double, double, double)}{\membername{MomentsDiscPhaseFitter}}
{\tt public\ {\bf MomentsDiscPhaseFitter}( {\tt double} {\bf m1},
{\tt double} {\bf m2},
{\tt double} {\bf m3} )
\label{jphase.fit.MomentsDiscPhaseFitter(double, double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt m1} -- }
   \item{
\sld
{\tt m2} -- }
   \item{
\sld
{\tt m3} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MomentsDiscPhaseFitter}
\item{\vskip -1.9ex 
\index{MomentsDiscPhaseFitter(int\lbrack \rbrack )}
\hypertarget{jphase.fit.MomentsDiscPhaseFitter(int[])}{\membername{MomentsDiscPhaseFitter}}
{\tt public\ {\bf MomentsDiscPhaseFitter}( {\tt int\lbrack \rbrack } {\bf data} )
\label{jphase.fit.MomentsDiscPhaseFitter(int[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.DiscPhaseFitter} \textnormal{\small\refdefined{jphase.fit.DiscPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract DiscPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MomentsECCompleteFit}
\subsection{\label{jphase.fit.MomentsECCompleteFit}\index{MomentsECCompleteFit}{\bf {\it Class} MomentsECCompleteFit}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.MomentsECCompleteFit}{}\vskip .1in 
This class implements the Matching Moments method proposed by Osogami and Harchol in "Closed form solutions for mapping general distributions to quasi-minimal PH distributions", 2005. The method match the first three moments of any distribution to a subclass of Phase-Type distributions known as Erlang-Coxian distributions. This class implements the Complete solution.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class MomentsECCompleteFit
\\ {\bf extends} jphase.fit.MomentsContPhaseFitter
\refdefined{jphase.fit.MomentsContPhaseFitter}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsECCompleteFit(double[])}{{\bf MomentsECCompleteFit(double\lbrack \rbrack )}} \\
\hyperlink{jphase.fit.MomentsECCompleteFit(double, double, double)}{{\bf MomentsECCompleteFit(double, double, double)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsECCompleteFit.fit()}{{\bf fit()}} Fit a Phase Type distribution from a set of moments with the Complete method described by Osogami et al.\\
\hyperlink{jphase.fit.MomentsECCompleteFit.getParam()}{{\bf getParam()}} Solve the equation system to get the parameters of the distribution, if the moments are feasible\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MomentsECCompleteFit(double\lbrack \rbrack )}
\hypertarget{jphase.fit.MomentsECCompleteFit(double[])}{\membername{MomentsECCompleteFit}}
{\tt public\ {\bf MomentsECCompleteFit}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.MomentsECCompleteFit(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MomentsECCompleteFit}
\item{\vskip -1.9ex 
\index{MomentsECCompleteFit(double, double, double)}
\hypertarget{jphase.fit.MomentsECCompleteFit(double, double, double)}{\membername{MomentsECCompleteFit}}
{\tt public\ {\bf MomentsECCompleteFit}( {\tt double} {\bf m1},
{\tt double} {\bf m2},
{\tt double} {\bf m3} )
\label{jphase.fit.MomentsECCompleteFit(double, double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt m1} -- }
   \item{
\sld
{\tt m2} -- }
   \item{
\sld
{\tt m3} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{fit()}
\hypertarget{jphase.fit.MomentsECCompleteFit.fit()}{\membername{fit}}
{\tt public jphase.ContPhaseVar\ {\bf fit}(  )
\label{jphase.fit.MomentsECCompleteFit.fit()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Fit a Phase Type distribution from a set of moments with the Complete method described by Osogami et al.
}
\item{{\bf Returns} -- 
Phase variable found 
}%end item
\end{itemize}
}%end item
\divideents{getParam}
\item{\vskip -1.9ex 
\index{getParam()}
\hypertarget{jphase.fit.MomentsECCompleteFit.getParam()}{\membername{getParam}}
{\tt public double\lbrack \rbrack \ {\bf getParam}(  )
\label{jphase.fit.MomentsECCompleteFit.getParam()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Solve the equation system to get the parameters of the distribution, if the moments are feasible
}
\item{{\bf Returns} -- 
Parameters of the Acyclic Continuous Phase Distribution of order n. param\lbrack 0\rbrack =n, param\lbrack 1\rbrack =p, param\lbrack 2\rbrack =lambdaY, param\lbrack 3\rbrack =lambdaX1, param\lbrack 4\rbrack =lambdaX2, param\lbrack 5\rbrack =pX 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.MomentsContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.MomentsContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf m1}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf m2}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf m3}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jphase.fit.ContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.ContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract ContPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{MomentsECPositiveFit}
\subsection{\label{jphase.fit.MomentsECPositiveFit}\index{MomentsECPositiveFit}{\bf {\it Class} MomentsECPositiveFit}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.fit.MomentsECPositiveFit}{}\vskip .1in 
This class implements the Matching Moments method proposed by Osogami and Harchol in "Closed form solutions for mapping general distributions to quasi-minimal PH distributions", 2005. The method match the first three moments of any distribution to a subclass of Phase-Type distributions known as Erlang-Coxian distributions. This class implements the Positive solution.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class MomentsECPositiveFit
\\ {\bf extends} jphase.fit.MomentsContPhaseFitter
\refdefined{jphase.fit.MomentsContPhaseFitter}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsECPositiveFit(double[])}{{\bf MomentsECPositiveFit(double\lbrack \rbrack )}} \\
\hyperlink{jphase.fit.MomentsECPositiveFit(double, double, double)}{{\bf MomentsECPositiveFit(double, double, double)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.fit.MomentsECPositiveFit.fit()}{{\bf fit()}} Fit a Phase Type distribution with no mass at zero from a set of moments with the Positive method described by Osogami et al.\\
\hyperlink{jphase.fit.MomentsECPositiveFit.getParam()}{{\bf getParam()}} Solve the equation system to get the parameters of the distribution, if the moments are feasible\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{MomentsECPositiveFit(double\lbrack \rbrack )}
\hypertarget{jphase.fit.MomentsECPositiveFit(double[])}{\membername{MomentsECPositiveFit}}
{\tt public\ {\bf MomentsECPositiveFit}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.fit.MomentsECPositiveFit(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{MomentsECPositiveFit}
\item{\vskip -1.9ex 
\index{MomentsECPositiveFit(double, double, double)}
\hypertarget{jphase.fit.MomentsECPositiveFit(double, double, double)}{\membername{MomentsECPositiveFit}}
{\tt public\ {\bf MomentsECPositiveFit}( {\tt double} {\bf m1},
{\tt double} {\bf m2},
{\tt double} {\bf m3} )
\label{jphase.fit.MomentsECPositiveFit(double, double, double)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt m1} -- }
   \item{
\sld
{\tt m2} -- }
   \item{
\sld
{\tt m3} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{fit()}
\hypertarget{jphase.fit.MomentsECPositiveFit.fit()}{\membername{fit}}
{\tt public jphase.ContPhaseVar\ {\bf fit}(  )
\label{jphase.fit.MomentsECPositiveFit.fit()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Fit a Phase Type distribution with no mass at zero from a set of moments with the Positive method described by Osogami et al.
}
\item{{\bf Returns} -- 
Phase variable found 
}%end item
\end{itemize}
}%end item
\divideents{getParam}
\item{\vskip -1.9ex 
\index{getParam()}
\hypertarget{jphase.fit.MomentsECPositiveFit.getParam()}{\membername{getParam}}
{\tt public double\lbrack \rbrack \ {\bf getParam}(  ) throws java.lang.IllegalArgumentException
\label{jphase.fit.MomentsECPositiveFit.getParam()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Solve the equation system to get the parameters of the distribution, if the moments are feasible
}
\item{{\bf Returns} -- 
Parameters of the Acyclic Continuous Phase Distribution of order n. param\lbrack 0\rbrack =n, param\lbrack 1\rbrack =p, param\lbrack 2\rbrack =lambdaY, param\lbrack 3\rbrack =lambdaX1, param\lbrack 4\rbrack =lambdaX2, param\lbrack 5\rbrack =pX. If it is necessary, a new exponential phase with parameter lambda will be aggregated through convolution: param\lbrack 6\rbrack =lambda. If it is necessary, a new exponential phase with parameter lambda will be mixed up with probability 1-pMix: param\lbrack 6\rbrack =lambda, param\lbrack 7\rbrack\ = pMix. 
}%end item
\item{{\bf Throws}
  \begin{itemize}
\sld
   \item{\vskip -.6ex{\tt java.lang.IllegalArgumentException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.fit.MomentsContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.MomentsContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf m1}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf m2}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf m3}}%end signature
}%end item
\end{itemize}
}}
\subsubsection{Members inherited from class {\tt jphase.fit.ContPhaseFitter} \textnormal{\small\refdefined{jphase.fit.ContPhaseFitter}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt protected {\bf data}}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract ContPhaseVar {\bf fit}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public double {\bf getLogLikelihood}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage}
}
\newpage
\def\packagename{jphase.generator}
\chapter{\bf Package jphase.generator}{
\thispagestyle{empty}
\label{jphase.generator}\hypertarget{jphase.generator}{}
\markboth{\protect\packagename}{\protect\packagename}
\vskip -.25in
\hbox to \hsize{\it Package Contents\hfil Page}
\rule{\hsize}{.7mm}
\vskip .13in
\hbox{\bf Classes}
\entityintro{GeneratorUtils}{jphase.generator.GeneratorUtils}{This class contains a set of methods to make some usual calculations for the PhaseGenerator classes}
\entityintro{NeutsContPHGenerator}{jphase.generator.NeutsContPHGenerator}{This class implements the algorithm proposed by Neuts and Pagano "generating Random Variates of Phase-Type", 1981.}
\entityintro{NeutsDiscPHGenerator}{jphase.generator.NeutsDiscPHGenerator}{This class implements the algorithm proposed by Neuts and Pagano "generating Random Variates of Phase-Type", 1981.}
\entityintro{PhaseGenerator}{jphase.generator.PhaseGenerator}{This abstract class defines the behaviour that any Phase-Type random number generator should have}
\vskip .1in
\rule{\hsize}{.7mm}
\vskip .1in
Provides capabilities for generating random variates from Phase type distributions. These includes discrete and continuous random number generators. This package includes the implementation of two algorithms based on the alias method, a framework and a set of utilities for implement new methods. For overviews, tutorials, examples, guides, and tool documentation, please see:

\hyperref{http://copa.uniandes.edu.co}{}{}{Copa Group WEB page.} (at http://copa.uniandes.edu.co)\mbox{}\\ \rule{\hsize}{.7mm}
\vskip .1in
\newpage
\markboth{\protect\packagename \hspace{.02in} -- \protect\classname}{\protect\packagename \hspace{.02in} -- \protect\classname}
\section{Classes}{
\gdef\classname{GeneratorUtils}
\subsection{\label{jphase.generator.GeneratorUtils}\index{GeneratorUtils}{\bf {\it Class} GeneratorUtils}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.generator.GeneratorUtils}{}\vskip .1in 
This class contains a set of methods to make some usual calculations for the PhaseGenerator classes\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class GeneratorUtils
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.generator.GeneratorUtils()}{{\bf GeneratorUtils()}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.generator.GeneratorUtils.algorKS(double[], jphase.PhaseVar)}{{\bf algorKS(double\lbrack \rbrack , PhaseVar)}} This method implements the KS algorithm proposed by Gonzlez, Sahni and Franta in "An efficient algorithm for the Kolmogorov-Smirnov and Lilliefors Tests" in ACM Transactions on Mathematical Software, Vol 3, No.\\
\hyperlink{jphase.generator.GeneratorUtils.aliasCut(double[], int[], double[])}{{\bf aliasCut(double\lbrack \rbrack , int\lbrack \rbrack , double\lbrack \rbrack )}} This method generates the aliases and cutoff values according to the distribution especified.\\
\hyperlink{jphase.generator.GeneratorUtils.aliasCut(no.uib.cipr.matrix.Vector, int[], double[])}{{\bf aliasCut(Vector, int\lbrack \rbrack , double\lbrack \rbrack )}} This method generates the aliases and cutoff values according to the distribution especified.\\
\hyperlink{jphase.generator.GeneratorUtils.argmax(double[])}{{\bf argmax(double\lbrack \rbrack )}} Returns the index of the maximum value in the data\\
\hyperlink{jphase.generator.GeneratorUtils.argmin(double[])}{{\bf argmin(double\lbrack \rbrack )}} Returns the index of the minimum value in the data\\
\hyperlink{jphase.generator.GeneratorUtils.erlang(double, int, java.util.Random)}{{\bf erlang(double, int, Random)}} Returns a random number with Erlang(lambda, r) distribution.\\
\hyperlink{jphase.generator.GeneratorUtils.getNumber(double[], int[], double[], java.util.Random)}{{\bf getNumber(double\lbrack \rbrack , int\lbrack \rbrack , double\lbrack \rbrack , Random)}} Returns a random number with discrete distribution dist in \{0,...,n\}\\
\hyperlink{jphase.generator.GeneratorUtils.sum(double[])}{{\bf sum(double\lbrack \rbrack )}} Returns the sum of the elements of the data array\\
\hyperlink{jphase.generator.GeneratorUtils.sumAbs(double[])}{{\bf sumAbs(double\lbrack \rbrack )}} Returns the sum of the absolut values of the elements of the data array\\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{GeneratorUtils()}
\hypertarget{jphase.generator.GeneratorUtils()}{\membername{GeneratorUtils}}
{\tt public\ {\bf GeneratorUtils}(  )
\label{jphase.generator.GeneratorUtils()}}%end signature
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{algorKS(double\lbrack \rbrack , PhaseVar)}
\hypertarget{jphase.generator.GeneratorUtils.algorKS(double[], jphase.PhaseVar)}{\membername{algorKS}}
{\tt public static double\ {\bf algorKS}( {\tt double\lbrack \rbrack } {\bf data},
{\tt jphase.PhaseVar} {\bf var} )
\label{jphase.generator.GeneratorUtils.algorKS(double[], jphase.PhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method implements the KS algorithm proposed by Gonzlez, Sahni and Franta in "An efficient algorithm for the Kolmogorov-Smirnov and Lilliefors Tests" in ACM Transactions on Mathematical Software, Vol 3, No. 1, March 1977, pages 60-64.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- data trace to be tested}
   \item{
\sld
{\tt var} -- theoretical phase variable to be compared against the trace}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
absolute maximum deviation from the data to the phase variable 
}%end item
\end{itemize}
}%end item
\divideents{aliasCut}
\item{\vskip -1.9ex 
\index{aliasCut(double\lbrack \rbrack , int\lbrack \rbrack , double\lbrack \rbrack )}
\hypertarget{jphase.generator.GeneratorUtils.aliasCut(double[], int[], double[])}{\membername{aliasCut}}
{\tt public static void\ {\bf aliasCut}( {\tt double\lbrack \rbrack } {\bf dist},
{\tt int\lbrack \rbrack } {\bf alias},
{\tt double\lbrack \rbrack } {\bf cutoff} )
\label{jphase.generator.GeneratorUtils.aliasCut(double[], int[], double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method generates the aliases and cutoff values according to the distribution especified.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt dist} -- Distribution from which the aliases and cutoff vectors must be generated. Represented by array of doubles.}
   \item{
\sld
{\tt alias} -- vector of the distribution}
   \item{
\sld
{\tt cutoff} -- values of the distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{aliasCut}
\item{\vskip -1.9ex 
\index{aliasCut(Vector, int\lbrack \rbrack , double\lbrack \rbrack )}
\hypertarget{jphase.generator.GeneratorUtils.aliasCut(no.uib.cipr.matrix.Vector, int[], double[])}{\membername{aliasCut}}
{\tt public static void\ {\bf aliasCut}( {\tt no.uib.cipr.matrix.Vector} {\bf dist},
{\tt int\lbrack \rbrack } {\bf alias},
{\tt double\lbrack \rbrack } {\bf cutoff} )
\label{jphase.generator.GeneratorUtils.aliasCut(no.uib.cipr.matrix.Vector, int[], double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

This method generates the aliases and cutoff values according to the distribution especified. This distribution comes in a MTJ Vector and may sum less than one (as in the initial condition vector that defines a Markov process or a Phase-Type distribution). The distribution is then adjusted by adding a position in zero that completes the probability mass to summ to zero.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt dist} -- Distribution from which the aliases and cutoff vectors must be generated. Represented by a MTJ Vector.}
   \item{
\sld
{\tt alias} -- vector of the distribution}
   \item{
\sld
{\tt cutoff} -- values of the distribution}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\divideents{argmax}
\item{\vskip -1.9ex 
\index{argmax(double\lbrack \rbrack )}
\hypertarget{jphase.generator.GeneratorUtils.argmax(double[])}{\membername{argmax}}
{\tt public static int\ {\bf argmax}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.generator.GeneratorUtils.argmax(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the index of the maximum value in the data
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- array of data}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The index of the maximum value in data 
}%end item
\end{itemize}
}%end item
\divideents{argmin}
\item{\vskip -1.9ex 
\index{argmin(double\lbrack \rbrack )}
\hypertarget{jphase.generator.GeneratorUtils.argmin(double[])}{\membername{argmin}}
{\tt public static int\ {\bf argmin}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.generator.GeneratorUtils.argmin(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the index of the minimum value in the data
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- array of data}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
The index of the minimum value in the data 
}%end item
\end{itemize}
}%end item
\divideents{erlang}
\item{\vskip -1.9ex 
\index{erlang(double, int, Random)}
\hypertarget{jphase.generator.GeneratorUtils.erlang(double, int, java.util.Random)}{\membername{erlang}}
{\tt public static double\ {\bf erlang}( {\tt double} {\bf lambda},
{\tt int} {\bf r},
{\tt java.util.Random} {\bf rand} )
\label{jphase.generator.GeneratorUtils.erlang(double, int, java.util.Random)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a random number with Erlang(lambda, r) distribution.
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt lambda} -- Erlang rate}
   \item{
\sld
{\tt r} -- number of phases in the Erlang Distribution}
   \item{
\sld
{\tt rand} -- Random number source}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
random number with Erlang(lambda, r) distribution. 
}%end item
\end{itemize}
}%end item
\divideents{getNumber}
\item{\vskip -1.9ex 
\index{getNumber(double\lbrack \rbrack , int\lbrack \rbrack , double\lbrack \rbrack , Random)}
\hypertarget{jphase.generator.GeneratorUtils.getNumber(double[], int[], double[], java.util.Random)}{\membername{getNumber}}
{\tt public static int\ {\bf getNumber}( {\tt double\lbrack \rbrack } {\bf dist},
{\tt int\lbrack \rbrack } {\bf alias},
{\tt double\lbrack \rbrack } {\bf cutoff},
{\tt java.util.Random} {\bf rand} )
\label{jphase.generator.GeneratorUtils.getNumber(double[], int[], double[], java.util.Random)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns a random number with discrete distribution dist in \{0,...,n\}
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt dist} -- Discrete distribution in \{0,...,n\}}
   \item{
\sld
{\tt alias} -- Aliases of the distributions points}
   \item{
\sld
{\tt cutoff} -- Cutoff values to generate the random numbers}
   \item{
\sld
{\tt rand} -- Random type object to use as generator of random numbers}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
A random number with discrete distribution dist in \{0,...,n\} 
}%end item
\end{itemize}
}%end item
\divideents{sum}
\item{\vskip -1.9ex 
\index{sum(double\lbrack \rbrack )}
\hypertarget{jphase.generator.GeneratorUtils.sum(double[])}{\membername{sum}}
{\tt public static double\ {\bf sum}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.generator.GeneratorUtils.sum(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the sum of the elements of the data array
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- array of data}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of the elements of the data array 
}%end item
\end{itemize}
}%end item
\divideents{sumAbs}
\item{\vskip -1.9ex 
\index{sumAbs(double\lbrack \rbrack )}
\hypertarget{jphase.generator.GeneratorUtils.sumAbs(double[])}{\membername{sumAbs}}
{\tt public static double\ {\bf sumAbs}( {\tt double\lbrack \rbrack } {\bf data} )
\label{jphase.generator.GeneratorUtils.sumAbs(double[])}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Returns the sum of the absolut values of the elements of the data array
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt data} -- array of data}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
Sum of the absolut values of the elements of the data array 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage\gdef\classname{NeutsContPHGenerator}
\subsection{\label{jphase.generator.NeutsContPHGenerator}\index{NeutsContPHGenerator}{\bf {\it Class} NeutsContPHGenerator}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.generator.NeutsContPHGenerator}{}\vskip .1in 
This class implements the algorithm proposed by Neuts and Pagano "generating Random Variates of Phase-Type", 1981. This is also based in the so called alias method to generate a variate from a discrete distribution. This class implements the algorithm for the continuous case.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class NeutsContPHGenerator
\\ {\bf extends} jphase.generator.PhaseGenerator
\refdefined{jphase.generator.PhaseGenerator}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.generator.NeutsContPHGenerator(jphase.AbstractContPhaseVar)}{{\bf NeutsContPHGenerator(AbstractContPhaseVar)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.generator.NeutsContPHGenerator.getRandom()}{{\bf getRandom()}} \\
\hyperlink{jphase.generator.NeutsContPHGenerator.getRandom(int)}{{\bf getRandom(int)}} \\
\hyperlink{jphase.generator.NeutsContPHGenerator.initialize()}{{\bf initialize()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{NeutsContPHGenerator(AbstractContPhaseVar)}
\hypertarget{jphase.generator.NeutsContPHGenerator(jphase.AbstractContPhaseVar)}{\membername{NeutsContPHGenerator}}
{\tt public\ {\bf NeutsContPHGenerator}( {\tt jphase.AbstractContPhaseVar} {\bf var} )
\label{jphase.generator.NeutsContPHGenerator(jphase.AbstractContPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt var} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getRandom()}
\hypertarget{jphase.generator.NeutsContPHGenerator.getRandom()}{\membername{getRandom}}
{\tt public abstract double\ {\bf getRandom}(  )
\label{jphase.generator.NeutsContPHGenerator.getRandom()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
A random number that has a probability distribution of Phase-Type 
}%end item
\end{itemize}
}%end item
\divideents{getRandom}
\item{\vskip -1.9ex 
\index{getRandom(int)}
\hypertarget{jphase.generator.NeutsContPHGenerator.getRandom(int)}{\membername{getRandom}}
{\tt public abstract double\lbrack \rbrack \ {\bf getRandom}( {\tt int} {\bf num} )
\label{jphase.generator.NeutsContPHGenerator.getRandom(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt num} -- Number of variates to be generated}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
A vector of random numbers that have a probability distribution of Phase-Type 
}%end item
\end{itemize}
}%end item
\divideents{initialize}
\item{\vskip -1.9ex 
\index{initialize()}
\hypertarget{jphase.generator.NeutsContPHGenerator.initialize()}{\membername{initialize}}
{\tt protected abstract void\ {\bf initialize}(  )
\label{jphase.generator.NeutsContPHGenerator.initialize()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.generator.PhaseGenerator}{PhaseGenerator}{\small \refdefined{jphase.generator.PhaseGenerator}} }

Initialize the cutoff values and the aliases for the initial probability distribution and the transition probability matrix
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.generator.PhaseGenerator} \textnormal{\small\refdefined{jphase.generator.PhaseGenerator}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract double {\bf getRandom}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf getRandom}( {\tt int} {\bf num} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public PhaseVar {\bf getVar}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract void {\bf initialize}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{NeutsDiscPHGenerator}
\subsection{\label{jphase.generator.NeutsDiscPHGenerator}\index{NeutsDiscPHGenerator}{\bf {\it Class} NeutsDiscPHGenerator}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.generator.NeutsDiscPHGenerator}{}\vskip .1in 
This class implements the algorithm proposed by Neuts and Pagano "generating Random Variates of Phase-Type", 1981. This is also based in the so called alias method to generate a variate from a discrete distribution. This class implements the algorithm for the discrete case.\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public class NeutsDiscPHGenerator
\\ {\bf extends} jphase.generator.PhaseGenerator
\refdefined{jphase.generator.PhaseGenerator}}}}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.generator.NeutsDiscPHGenerator(jphase.AbstractDiscPhaseVar)}{{\bf NeutsDiscPHGenerator(AbstractDiscPhaseVar)}} \\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.generator.NeutsDiscPHGenerator.getRandom()}{{\bf getRandom()}} \\
\hyperlink{jphase.generator.NeutsDiscPHGenerator.getRandom(int)}{{\bf getRandom(int)}} \\
\hyperlink{jphase.generator.NeutsDiscPHGenerator.initialize()}{{\bf initialize()}} \\
\end{verse}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{NeutsDiscPHGenerator(AbstractDiscPhaseVar)}
\hypertarget{jphase.generator.NeutsDiscPHGenerator(jphase.AbstractDiscPhaseVar)}{\membername{NeutsDiscPHGenerator}}
{\tt public\ {\bf NeutsDiscPHGenerator}( {\tt jphase.AbstractDiscPhaseVar} {\bf var} )
\label{jphase.generator.NeutsDiscPHGenerator(jphase.AbstractDiscPhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt var} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getRandom()}
\hypertarget{jphase.generator.NeutsDiscPHGenerator.getRandom()}{\membername{getRandom}}
{\tt public abstract double\ {\bf getRandom}(  )
\label{jphase.generator.NeutsDiscPHGenerator.getRandom()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
A random number that has a probability distribution of Phase-Type 
}%end item
\end{itemize}
}%end item
\divideents{getRandom}
\item{\vskip -1.9ex 
\index{getRandom(int)}
\hypertarget{jphase.generator.NeutsDiscPHGenerator.getRandom(int)}{\membername{getRandom}}
{\tt public abstract double\lbrack \rbrack \ {\bf getRandom}( {\tt int} {\bf num} )
\label{jphase.generator.NeutsDiscPHGenerator.getRandom(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt num} -- Number of variates to be generated}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
A vector of random numbers that have a probability distribution of Phase-Type 
}%end item
\end{itemize}
}%end item
\divideents{initialize}
\item{\vskip -1.9ex 
\index{initialize()}
\hypertarget{jphase.generator.NeutsDiscPHGenerator.initialize()}{\membername{initialize}}
{\tt protected abstract void\ {\bf initialize}(  )
\label{jphase.generator.NeutsDiscPHGenerator.initialize()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description copied from \hyperlink{jphase.generator.PhaseGenerator}{PhaseGenerator}{\small \refdefined{jphase.generator.PhaseGenerator}} }

Initialize the cutoff values and the aliases for the initial probability distribution and the transition probability matrix
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class {\tt jphase.generator.PhaseGenerator} \textnormal{\small\refdefined{jphase.generator.PhaseGenerator}}}{
{\small 

\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
{\tt public abstract double {\bf getRandom}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public abstract double {\bf getRandom}( {\tt int} {\bf num} )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt public PhaseVar {\bf getVar}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected abstract void {\bf initialize}(  )
}%end signature
}%end item
\item{\vskip -1.9ex 
{\tt protected {\bf var}}%end signature
}%end item
\end{itemize}
}}
}
\newpage\gdef\classname{PhaseGenerator}
\subsection{\label{jphase.generator.PhaseGenerator}\index{PhaseGenerator}{\bf {\it Class} PhaseGenerator}}{
\rule[1em]{\hsize}{4pt}\vskip -1em
\hypertarget{jphase.generator.PhaseGenerator}{}\vskip .1in 
This abstract class defines the behaviour that any Phase-Type random number generator should have\vskip .1in 
\subsubsection{Declaration}{
\fcolorbox{black}{Light}{\parbox[s]{.98\hsize}{
\small public abstract class PhaseGenerator
\\ {\bf extends} java.lang.Object
\refdefined{java.lang.Object}}}}
\subsubsection{All known subclasses}{NeutsDiscPHGenerator\small{\refdefined{jphase.generator.NeutsDiscPHGenerator}}, NeutsContPHGenerator\small{\refdefined{jphase.generator.NeutsContPHGenerator}}}
\subsubsection{Field summary}{
\begin{verse}
\hyperlink{jphase.generator.PhaseGenerator.var}{{\bf var}} Phase variable from which the random numbers must be generated\\
\end{verse}
}
\subsubsection{Constructor summary}{
\begin{verse}
\hyperlink{jphase.generator.PhaseGenerator(jphase.PhaseVar)}{{\bf PhaseGenerator(PhaseVar)}} Construcs a new PhaseGenerator through its initialization\\
\end{verse}
}
\subsubsection{Method summary}{
\begin{verse}
\hyperlink{jphase.generator.PhaseGenerator.getRandom()}{{\bf getRandom()}} \\
\hyperlink{jphase.generator.PhaseGenerator.getRandom(int)}{{\bf getRandom(int)}} \\
\hyperlink{jphase.generator.PhaseGenerator.getVar()}{{\bf getVar()}} \\
\hyperlink{jphase.generator.PhaseGenerator.initialize()}{{\bf initialize()}} Initialize the cutoff values and the aliases for the initial probability distribution and the transition probability matrix\\
\end{verse}
}
\subsubsection{Fields}{
\rule[1em]{\hsize}{2pt}
\begin{itemize}
\item{
\index{var}
\label{jphase.generator.PhaseGenerator.var}\hypertarget{jphase.generator.PhaseGenerator.var}{protected jphase.PhaseVar {\bf var}}
\begin{itemize}
\item{\vskip -.9ex 
Phase variable from which the random numbers must be generated}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Constructors}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{PhaseGenerator(PhaseVar)}
\hypertarget{jphase.generator.PhaseGenerator(jphase.PhaseVar)}{\membername{PhaseGenerator}}
{\tt public\ {\bf PhaseGenerator}( {\tt jphase.PhaseVar} {\bf var} )
\label{jphase.generator.PhaseGenerator(jphase.PhaseVar)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Construcs a new PhaseGenerator through its initialization
}
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt var} -- variable from which the random numbers must be generated}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methods}{
\rule[1em]{\hsize}{2pt}\vskip -2em
\begin{itemize}
\item{\vskip -1.9ex 
\index{getRandom()}
\hypertarget{jphase.generator.PhaseGenerator.getRandom()}{\membername{getRandom}}
{\tt public abstract double\ {\bf getRandom}(  )
\label{jphase.generator.PhaseGenerator.getRandom()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
A random number that has a probability distribution of Phase-Type 
}%end item
\end{itemize}
}%end item
\divideents{getRandom}
\item{\vskip -1.9ex 
\index{getRandom(int)}
\hypertarget{jphase.generator.PhaseGenerator.getRandom(int)}{\membername{getRandom}}
{\tt public abstract double\lbrack \rbrack \ {\bf getRandom}( {\tt int} {\bf num} )
\label{jphase.generator.PhaseGenerator.getRandom(int)}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Parameters}
\sld\isep
  \begin{itemize}
\sld\isep
   \item{
\sld
{\tt num} -- Number of variates to be generated}
  \end{itemize}
}%end item
\item{{\bf Returns} -- 
A vector of random numbers that have a probability distribution of Phase-Type 
}%end item
\end{itemize}
}%end item
\divideents{getVar}
\item{\vskip -1.9ex 
\index{getVar()}
\hypertarget{jphase.generator.PhaseGenerator.getVar()}{\membername{getVar}}
{\tt public jphase.PhaseVar\ {\bf getVar}(  )
\label{jphase.generator.PhaseGenerator.getVar()}}%end signature
\begin{itemize}
\sld
\item{{\bf Returns} -- 
Phase variable that is being used to generate the random numbers 
}%end item
\end{itemize}
}%end item
\divideents{initialize}
\item{\vskip -1.9ex 
\index{initialize()}
\hypertarget{jphase.generator.PhaseGenerator.initialize()}{\membername{initialize}}
{\tt protected abstract void\ {\bf initialize}(  )
\label{jphase.generator.PhaseGenerator.initialize()}}%end signature
\begin{itemize}
\sld
\item{
\sld
{\bf Description}

Initialize the cutoff values and the aliases for the initial probability distribution and the transition probability matrix
}
\end{itemize}
}%end item
\end{itemize}
}
}
\newpage}
}
\markboth{}{}
\printindex

\end{document}
