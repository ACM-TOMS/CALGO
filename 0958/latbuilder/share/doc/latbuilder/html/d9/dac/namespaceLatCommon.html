<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Lattice Builder Manual: LatCommon Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lattice Builder Manual
   </div>
   <div id="projectbrief">Software Package for Constructing Rank-1 Lattices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d9/dac/namespaceLatCommon.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">LatCommon Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This module contains global constants used in <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This module describes various useful functions as well as functions interfacing with NTL...">LatMRG</a>{} and Lattice Builder.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:de/df4/namespaceLatCommon_1_1CoordinateSets"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df4/namespaceLatCommon_1_1CoordinateSets.html">CoordinateSets</a></td></tr>
<tr class="memdesc:de/df4/namespaceLatCommon_1_1CoordinateSets"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequences of coordinate sets. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dea/classLatCommon_1_1Base.html">Base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a basis for a lattice.  <a href="../../dd/dea/classLatCommon_1_1Base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d43/classLatCommon_1_1Coordinates.html">Coordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of coordinates.  <a href="../../da/d43/classLatCommon_1_1Coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d26/classLatCommon_1_1IntLattice.html">IntLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers tools to manipulate lattice bases.  <a href="../../d5/d26/classLatCommon_1_1IntLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da8/classLatCommon_1_1KorobovLattice.html">KorobovLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements lattice bases built from a Korobov lattice rule.  <a href="../../df/da8/classLatCommon_1_1KorobovLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dde/classLatCommon_1_1NormaBestLat.html">NormaBestLat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <em>best</em> theoretical bounds on the length of the shortest nonzero vector in a lattice, based on the densest sphere packing in lattices.  <a href="../../d5/dde/classLatCommon_1_1NormaBestLat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dd5/classLatCommon_1_1NormaLaminated.html">NormaLaminated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the length of the shortest nonzero vector in a lattice, based on the densest sphere packing in <em>laminated</em> lattices.  <a href="../../da/dd5/classLatCommon_1_1NormaLaminated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d05/classLatCommon_1_1Normalizer.html">Normalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes which inherit from this base class are used in implementing bounds on the length of the shortest nonzero vector in a lattice <a class="el" href="../../d0/de3/citelist.html#CITEREF_mCON99a">[3]</a> .  <a href="../../db/d05/classLatCommon_1_1Normalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2a/classLatCommon_1_1NormaMinkL1.html">NormaMinkL1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the length of the shortest nonzero vector in a lattice, based on the densest sphere packing in space.  <a href="../../d6/d2a/classLatCommon_1_1NormaMinkL1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d2f/classLatCommon_1_1NormaMinkowski.html">NormaMinkowski</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements {<em>Minkowski\/}'s</em> theoretical bounds on the length of the shortest nonzero vector in a lattice.  <a href="../../d4/d2f/classLatCommon_1_1NormaMinkowski.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de6/classLatCommon_1_1NormaRogers.html">NormaRogers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <em>Rogers</em> bounds on the density of sphere packing.  <a href="../../de/de6/classLatCommon_1_1NormaRogers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbd/classLatCommon_1_1OrderDependentWeights.html">OrderDependentWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order-dependent weights.  <a href="../../da/dbd/classLatCommon_1_1OrderDependentWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d58/classLatCommon_1_1PODWeights.html">PODWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product and order-dependent (POD) weights.  <a href="../../de/d58/classLatCommon_1_1PODWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d08/classLatCommon_1_1ProductWeights.html">ProductWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product weights.  <a href="../../d2/d08/classLatCommon_1_1ProductWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2b/classLatCommon_1_1ProjectionDependentWeights.html">ProjectionDependentWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projection-dependent weights.  <a href="../../d6/d2b/classLatCommon_1_1ProjectionDependentWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dd5/classLatCommon_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class generates random numbers (in fact pseudo-random numbers).  <a href="../../dc/dd5/classLatCommon_1_1Random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d4c/classLatCommon_1_1Rank1Lattice.html">Rank1Lattice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/ddf/classLatCommon_1_1Reducer.html">Reducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given lattice, this class implements methods to reduce its basis in the sense of Minkowski and to find the shortest non-zero vector of the lattice using pre-reductions and a branch-and-bound (BB) algorithm <a class="el" href="../../d0/de3/citelist.html#CITEREF_rLEC97c">[11]</a> .  <a href="../../d1/ddf/classLatCommon_1_1Reducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dd6/classLatCommon_1_1UniformWeights.html">UniformWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to implement the same weight for all projections.  <a href="../../d2/dd6/classLatCommon_1_1UniformWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da2/classLatCommon_1_1Weights.html">Weights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract weights class.  <a href="../../d0/da2/classLatCommon_1_1Weights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac877ba5335bc8575a96c339d7dc74c74"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#ac877ba5335bc8575a96c339d7dc74c74">Weight</a></td></tr>
<tr class="memdesc:ac877ba5335bc8575a96c339d7dc74c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar weight type.  <a href="#ac877ba5335bc8575a96c339d7dc74c74">More...</a><br /></td></tr>
<tr class="separator:ac877ba5335bc8575a96c339d7dc74c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:add4c45a7a3803fb5a4975437dff81767"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#add4c45a7a3803fb5a4975437dff81767">NormType</a> { <b>SUPNORM</b>, 
<b>L1NORM</b>, 
<b>L2NORM</b>, 
<b>ZAREMBANORM</b>
 }</td></tr>
<tr class="memdesc:add4c45a7a3803fb5a4975437dff81767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which norm is used to measure the length of vectors.  <a href="../../d9/dac/namespaceLatCommon.html#add4c45a7a3803fb5a4975437dff81767">More...</a><br /></td></tr>
<tr class="separator:add4c45a7a3803fb5a4975437dff81767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758d3c9e8f86ab5f52a055626174094b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a758d3c9e8f86ab5f52a055626174094b">GenType</a> { <br />
&#160;&#160;<b>LCG</b>, 
<b>MRG</b>, 
<b>MWC</b>, 
<b>KOROBOV</b>, 
<br />
&#160;&#160;<b>RANK1</b>
<br />
 }</td></tr>
<tr class="memdesc:a758d3c9e8f86ab5f52a055626174094b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to identify the type of a generator.  <a href="../../d9/dac/namespaceLatCommon.html#a758d3c9e8f86ab5f52a055626174094b">More...</a><br /></td></tr>
<tr class="separator:a758d3c9e8f86ab5f52a055626174094b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ed2a2f696926b82e588d842f3ebb55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a70ed2a2f696926b82e588d842f3ebb55">LatticeType</a> { <b>FULL</b>, 
<b>RECURRENT</b>, 
<b>ORBIT</b>, 
<b>PRIMEPOWER</b>
 }</td></tr>
<tr class="memdesc:a70ed2a2f696926b82e588d842f3ebb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether to analyze the lattice generated by all possible states, or a sub-lattice generated by the set of recurrent states or by a sub-cycle of the generator.  <a href="../../d9/dac/namespaceLatCommon.html#a70ed2a2f696926b82e588d842f3ebb55">More...</a><br /></td></tr>
<tr class="separator:a70ed2a2f696926b82e588d842f3ebb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ee3f50bd2cc77dc2001b40392d653c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23ee3f50bd2cc77dc2001b40392d653c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a23ee3f50bd2cc77dc2001b40392d653c">PrimeType</a> { <b>UNKNOWN</b>, 
<b>PRIME</b>, 
<b>PROB_PRIME</b>, 
<b>COMPOSITE</b>
 }</td></tr>
<tr class="memdesc:a23ee3f50bd2cc77dc2001b40392d653c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether an integer is prime, probably prime, composite or its status is unknown (or don't care). <br /></td></tr>
<tr class="separator:a23ee3f50bd2cc77dc2001b40392d653c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fd92967999f16fae471a5488ed82b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a14fd92967999f16fae471a5488ed82b5">DecompType</a> { <b>DECOMP</b>, 
<b>DECOMP_WRITE</b>, 
<b>DECOMP_READ</b>, 
<b>DECOMP_PRIME</b>
 }</td></tr>
<tr class="memdesc:a14fd92967999f16fae471a5488ed82b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an integer \(r\), indicates what to do about the decomposition of \(r\) in its prime factors.  <a href="../../d9/dac/namespaceLatCommon.html#a14fd92967999f16fae471a5488ed82b5">More...</a><br /></td></tr>
<tr class="separator:a14fd92967999f16fae471a5488ed82b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cdd498b2f20a100b1c563a8ea5e005"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#ad3cdd498b2f20a100b1c563a8ea5e005">OutputType</a> { <b>TERMINAL</b>, 
<b>RES</b>, 
<b>TEX</b>, 
<b>GEN</b>
 }</td></tr>
<tr class="memdesc:ad3cdd498b2f20a100b1c563a8ea5e005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates in which form and where the results will be sent.  <a href="../../d9/dac/namespaceLatCommon.html#ad3cdd498b2f20a100b1c563a8ea5e005">More...</a><br /></td></tr>
<tr class="separator:ad3cdd498b2f20a100b1c563a8ea5e005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad403368fce9d701987b6a65e01b4309c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#ad403368fce9d701987b6a65e01b4309c">CriterionType</a> { <b>SPECTRAL</b>, 
<b>BEYER</b>, 
<b>PALPHA</b>, 
<b>BOUND_JS</b>
 }</td></tr>
<tr class="memdesc:ad403368fce9d701987b6a65e01b4309c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the merit criterion for ranking generators or lattices.  <a href="../../d9/dac/namespaceLatCommon.html#ad403368fce9d701987b6a65e01b4309c">More...</a><br /></td></tr>
<tr class="separator:ad403368fce9d701987b6a65e01b4309c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6810518877211761291544d0ee2b771c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a6810518877211761291544d0ee2b771c">NormaType</a> { <br />
&#160;&#160;<b>BESTLAT</b>, 
<b>LAMINATED</b>, 
<b>ROGERS</b>, 
<b>MINKOWSKI</b>, 
<br />
&#160;&#160;<b>MINKL1</b>, 
<b>PALPHA_N</b>, 
<b>NORMA_GENERIC</b>
<br />
 }</td></tr>
<tr class="memdesc:a6810518877211761291544d0ee2b771c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which normalization is used to compute \(S_t\) in the spectral test, for each dimension \(t\).  <a href="../../d9/dac/namespaceLatCommon.html#a6810518877211761291544d0ee2b771c">More...</a><br /></td></tr>
<tr class="separator:a6810518877211761291544d0ee2b771c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689a9256cbfacf954b3085d2bcd49e49"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a689a9256cbfacf954b3085d2bcd49e49">CalcType</a> { <b>PAL</b>, 
<b>NORMPAL</b>, 
<b>BAL</b>, 
<b>SEEKPAL</b>
 }</td></tr>
<tr class="memdesc:a689a9256cbfacf954b3085d2bcd49e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which type of calculation is considered for the \(P_\alpha\) test.  <a href="../../d9/dac/namespaceLatCommon.html#a689a9256cbfacf954b3085d2bcd49e49">More...</a><br /></td></tr>
<tr class="separator:a689a9256cbfacf954b3085d2bcd49e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315cf9219517c9d31a1315330bf642c3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a315cf9219517c9d31a1315330bf642c3">ImplemCond</a> { <br />
&#160;&#160;<b>NO_COND</b>, 
<b>APP_FACT</b>, 
<b>POWER_TWO</b>, 
<b>EQUAL_COEF</b>, 
<br />
&#160;&#160;<b>ZERO_COEF</b>
<br />
 }</td></tr>
<tr class="memdesc:a315cf9219517c9d31a1315330bf642c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which type of conditions are imposed on the coefficients \(a_i\) of a recurrence.  <a href="../../d9/dac/namespaceLatCommon.html#a315cf9219517c9d31a1315330bf642c3">More...</a><br /></td></tr>
<tr class="separator:a315cf9219517c9d31a1315330bf642c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6a0e1ad183c20832f105f09c7f775f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a3d6a0e1ad183c20832f105f09c7f775f">SearchMethod</a> { <b>EXHAUST</b>, 
<b>RANDOM</b>
 }</td></tr>
<tr class="memdesc:a3d6a0e1ad183c20832f105f09c7f775f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the search method used to find good multipliers \(a_i\).  <a href="../../d9/dac/namespaceLatCommon.html#a3d6a0e1ad183c20832f105f09c7f775f">More...</a><br /></td></tr>
<tr class="separator:a3d6a0e1ad183c20832f105f09c7f775f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac3fab482ce2244ee55050959062e8db8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3fab482ce2244ee55050959062e8db8"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#ac3fab482ce2244ee55050959062e8db8">lFactorial</a> (int t)</td></tr>
<tr class="memdesc:ac3fab482ce2244ee55050959062e8db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\). <br /></td></tr>
<tr class="separator:ac3fab482ce2244ee55050959062e8db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9897dee077388e774ec878001be14b27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9897dee077388e774ec878001be14b27"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a9897dee077388e774ec878001be14b27">Digamma</a> (double x)</td></tr>
<tr class="memdesc:a9897dee077388e774ec878001be14b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\). <br /></td></tr>
<tr class="separator:a9897dee077388e774ec878001be14b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757b1ddc97f31fa825cabb8be8a18eee"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a757b1ddc97f31fa825cabb8be8a18eee">BernoulliPoly</a> (int n, double x)</td></tr>
<tr class="memdesc:a757b1ddc97f31fa825cabb8be8a18eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\).  <a href="#a757b1ddc97f31fa825cabb8be8a18eee">More...</a><br /></td></tr>
<tr class="separator:a757b1ddc97f31fa825cabb8be8a18eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af729c6570605a4319670e4cba3d6da29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af729c6570605a4319670e4cba3d6da29"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#af729c6570605a4319670e4cba3d6da29">Harmonic</a> (long n)</td></tr>
<tr class="memdesc:af729c6570605a4319670e4cba3d6da29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(n\)-th harmonic number \(H_n = \sum_{j=1}^n 1/j\). <br /></td></tr>
<tr class="separator:af729c6570605a4319670e4cba3d6da29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec4c6bb12637e9bbade1fc750e43235"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ec4c6bb12637e9bbade1fc750e43235"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a8ec4c6bb12637e9bbade1fc750e43235">Harmonic2</a> (long n)</td></tr>
<tr class="memdesc:a8ec4c6bb12637e9bbade1fc750e43235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum </p><p class="formulaDsp">
\[ \sideset{}{&#39;}\sum_{-n/2&lt;j\le n/2}\; \frac 1{|j|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(j=0\) is excluded from the sum. <br /></td></tr>
<tr class="separator:a8ec4c6bb12637e9bbade1fc750e43235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f48a545cb0e592f59f55f27342c27a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f48a545cb0e592f59f55f27342c27a6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a4f48a545cb0e592f59f55f27342c27a6">FourierC1</a> (double x, long n)</td></tr>
<tr class="memdesc:a4f48a545cb0e592f59f55f27342c27a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vJOE92b">[8]</a>) </p><p class="formulaDsp">
\[ S(x, n) = \sum_{j=1}^{n} \frac{\cos(2\pi j x)}{j}. \]
</p>
<p> Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). <br /></td></tr>
<tr class="separator:a4f48a545cb0e592f59f55f27342c27a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab8424381b4767bb8bed7df4cc84803"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a6ab8424381b4767bb8bed7df4cc84803">FourierE1</a> (double x, long n)</td></tr>
<tr class="memdesc:a6ab8424381b4767bb8bed7df4cc84803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series </p><p class="formulaDsp">
\[ G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\; \frac{e^{2\pi i h x}}{|h|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes.  <a href="#a6ab8424381b4767bb8bed7df4cc84803">More...</a><br /></td></tr>
<tr class="separator:a6ab8424381b4767bb8bed7df4cc84803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56536d4e688efe54aa875c7f255db27f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a56536d4e688efe54aa875c7f255db27f">MyExit</a> (int status, std::string msg)</td></tr>
<tr class="memdesc:a56536d4e688efe54aa875c7f255db27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special exit function.  <a href="#a56536d4e688efe54aa875c7f255db27f">More...</a><br /></td></tr>
<tr class="separator:a56536d4e688efe54aa875c7f255db27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b83f03360d08e2219ea30c35e75aa0d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2b83f03360d08e2219ea30c35e75aa0d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b83f03360d08e2219ea30c35e75aa0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a2b83f03360d08e2219ea30c35e75aa0d">swap9</a> (T &amp;x, T &amp;y)</td></tr>
<tr class="memdesc:a2b83f03360d08e2219ea30c35e75aa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values of <code>x</code> and <code>y</code>. <br /></td></tr>
<tr class="separator:a2b83f03360d08e2219ea30c35e75aa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c24118425dd013b8176f8703bae18b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a29c24118425dd013b8176f8703bae18b"></a>
template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a29c24118425dd013b8176f8703bae18b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conv</b> (A &amp;x, const B &amp;y)</td></tr>
<tr class="separator:a29c24118425dd013b8176f8703bae18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323e781ab4cf9f5c96f39fadd2961a96"><td class="memTemplParams" colspan="2"><a class="anchor" id="a323e781ab4cf9f5c96f39fadd2961a96"></a>
template&lt;class K , class C , class A &gt; </td></tr>
<tr class="memitem:a323e781ab4cf9f5c96f39fadd2961a96"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a323e781ab4cf9f5c96f39fadd2961a96">operator&lt;&lt;</a> (std::ostream &amp;out, const std::set&lt; K, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a323e781ab4cf9f5c96f39fadd2961a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">}. <br /></td></tr>
<tr class="separator:a323e781ab4cf9f5c96f39fadd2961a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fc9489f972eaee72203f09c006929b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae8fc9489f972eaee72203f09c006929b"></a>
template&lt;class K , class T , class C , class A &gt; </td></tr>
<tr class="memitem:ae8fc9489f972eaee72203f09c006929b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#ae8fc9489f972eaee72203f09c006929b">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; K, T, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:ae8fc9489f972eaee72203f09c006929b"><td class="mdescLeft">&#160;</td><td class="mdescRight">}. <br /></td></tr>
<tr class="separator:ae8fc9489f972eaee72203f09c006929b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">toString functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Useful functions for printing the <code>enum</code> constants in this module. </p>
</div></td></tr>
<tr class="memitem:a4484798c5e2dbf0f5816c08cb218a00e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a4484798c5e2dbf0f5816c08cb218a00e">toStringNorm</a> (<a class="el" href="../../d9/dac/namespaceLatCommon.html#add4c45a7a3803fb5a4975437dff81767">NormType</a>)</td></tr>
<tr class="memdesc:a4484798c5e2dbf0f5816c08cb218a00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>enum</code> constants in this module as strings.  <a href="#a4484798c5e2dbf0f5816c08cb218a00e">More...</a><br /></td></tr>
<tr class="separator:a4484798c5e2dbf0f5816c08cb218a00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf79fbeceb0701c975714793083db4bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf79fbeceb0701c975714793083db4bf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringGen</b> (<a class="el" href="../../d9/dac/namespaceLatCommon.html#a758d3c9e8f86ab5f52a055626174094b">GenType</a>)</td></tr>
<tr class="separator:aaf79fbeceb0701c975714793083db4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af588d8d9b5d29e1f57e23ebd45d50448"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af588d8d9b5d29e1f57e23ebd45d50448"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringLattice</b> (<a class="el" href="../../d9/dac/namespaceLatCommon.html#a70ed2a2f696926b82e588d842f3ebb55">LatticeType</a>)</td></tr>
<tr class="separator:af588d8d9b5d29e1f57e23ebd45d50448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fc421923882300a9e9877195a0504c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9fc421923882300a9e9877195a0504c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringPrime</b> (<a class="el" href="../../d9/dac/namespaceLatCommon.html#a23ee3f50bd2cc77dc2001b40392d653c">PrimeType</a>)</td></tr>
<tr class="separator:ad9fc421923882300a9e9877195a0504c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9a54357549ff252fc9085d4d8ddf58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c9a54357549ff252fc9085d4d8ddf58"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringDecomp</b> (<a class="el" href="../../d9/dac/namespaceLatCommon.html#a14fd92967999f16fae471a5488ed82b5">DecompType</a>)</td></tr>
<tr class="separator:a7c9a54357549ff252fc9085d4d8ddf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30394a893320e4ae16bf586b06f8bff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae30394a893320e4ae16bf586b06f8bff"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringOutput</b> (<a class="el" href="../../d9/dac/namespaceLatCommon.html#ad3cdd498b2f20a100b1c563a8ea5e005">OutputType</a>)</td></tr>
<tr class="separator:ae30394a893320e4ae16bf586b06f8bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489dd3aab896e4a794a65ac52f504752"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a489dd3aab896e4a794a65ac52f504752"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringCriterion</b> (<a class="el" href="../../d9/dac/namespaceLatCommon.html#ad403368fce9d701987b6a65e01b4309c">CriterionType</a>)</td></tr>
<tr class="separator:a489dd3aab896e4a794a65ac52f504752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad106aabcf87efd788f98949533fca0a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad106aabcf87efd788f98949533fca0a7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringNorma</b> (<a class="el" href="../../d9/dac/namespaceLatCommon.html#a6810518877211761291544d0ee2b771c">NormaType</a>)</td></tr>
<tr class="separator:ad106aabcf87efd788f98949533fca0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a120dd4bccf2c5602a42738cc5dab1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52a120dd4bccf2c5602a42738cc5dab1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringCalc</b> (<a class="el" href="../../d9/dac/namespaceLatCommon.html#a689a9256cbfacf954b3085d2bcd49e49">CalcType</a>)</td></tr>
<tr class="separator:a52a120dd4bccf2c5602a42738cc5dab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d65798445df475f3cc01f96dc8ead1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7d65798445df475f3cc01f96dc8ead1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringImplemCond</b> (<a class="el" href="../../d9/dac/namespaceLatCommon.html#a315cf9219517c9d31a1315330bf642c3">ImplemCond</a>)</td></tr>
<tr class="separator:ab7d65798445df475f3cc01f96dc8ead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6424a3a79ccee9b5f42a397ea40e0d29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6424a3a79ccee9b5f42a397ea40e0d29"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringSearchMethod</b> (<a class="el" href="../../d9/dac/namespaceLatCommon.html#a3d6a0e1ad183c20832f105f09c7f775f">SearchMethod</a>)</td></tr>
<tr class="separator:a6424a3a79ccee9b5f42a397ea40e0d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">NTL compatibility functions</div></td></tr>
<tr class="memitem:a6f5a4fd5434f1b04c117460a18fc2cce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f5a4fd5434f1b04c117460a18fc2cce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> (double &amp;x)</td></tr>
<tr class="separator:a6f5a4fd5434f1b04c117460a18fc2cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5923ab5f933cc456bc75b4f8d8026316"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5923ab5f933cc456bc75b4f8d8026316"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a5923ab5f933cc456bc75b4f8d8026316">clear</a> (long &amp;x)</td></tr>
<tr class="memdesc:a5923ab5f933cc456bc75b4f8d8026316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(x\) to 0. <br /></td></tr>
<tr class="separator:a5923ab5f933cc456bc75b4f8d8026316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3c461de17ef8537d9d8e71c9613451"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d3c461de17ef8537d9d8e71c9613451"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set9</b> (long &amp;x)</td></tr>
<tr class="separator:a8d3c461de17ef8537d9d8e71c9613451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6c9a5f07228436ba8dad5ec109337f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f6c9a5f07228436ba8dad5ec109337f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a8f6c9a5f07228436ba8dad5ec109337f">IsZero</a> (const long &amp;x)</td></tr>
<tr class="memdesc:a8f6c9a5f07228436ba8dad5ec109337f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if \(x = 0\). <br /></td></tr>
<tr class="separator:a8f6c9a5f07228436ba8dad5ec109337f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Division and remainder</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>For negative operands, the <code>/</code> and <code>%</code> operators do not give the same results for <a class="el" href="../../d2/d5a/namespaceNTL.html" title="Converts the array of characters (string) c into l. ">NTL</a> large integers <code>ZZ</code> and for primitive types <code>int</code> and <code>long</code>.</p>
<p>The negative quotient differs by 1 and the remainder also differs. Thus the following small <code>inline</code> functions for division and remainder. </p>
</div></td></tr>
<tr class="memitem:af617a9638424b53ecae96a4b4495373e"><td class="memTemplParams" colspan="2"><a class="anchor" id="af617a9638424b53ecae96a4b4495373e"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:af617a9638424b53ecae96a4b4495373e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Quotient</b> (const Int &amp;a, const Int &amp;b, Int &amp;q)</td></tr>
<tr class="separator:af617a9638424b53ecae96a4b4495373e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae7038e032742e07d962b5a2cef1911"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ae7038e032742e07d962b5a2cef1911"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Modulo</b> (const long &amp;a, const long &amp;b, long &amp;r)</td></tr>
<tr class="separator:a4ae7038e032742e07d962b5a2cef1911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5b24a119adf60ae2c1ba94a32d5c28"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a2b5b24a119adf60ae2c1ba94a32d5c28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a2b5b24a119adf60ae2c1ba94a32d5c28">Divide</a> (Real &amp;q, Real &amp;r, const Real &amp;a, const Real &amp;b)</td></tr>
<tr class="memdesc:a2b5b24a119adf60ae2c1ba94a32d5c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\).  <a href="#a2b5b24a119adf60ae2c1ba94a32d5c28">More...</a><br /></td></tr>
<tr class="separator:a2b5b24a119adf60ae2c1ba94a32d5c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f284275c039c3d7759478c0401ca40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70f284275c039c3d7759478c0401ca40"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Divide</b> (long &amp;q, long &amp;r, const long &amp;a, const long &amp;b)</td></tr>
<tr class="separator:a70f284275c039c3d7759478c0401ca40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174110a449a3c932f3fa65178a0e656b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a174110a449a3c932f3fa65178a0e656b"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a174110a449a3c932f3fa65178a0e656b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DivideRound</b> (const Real &amp;a, const Real &amp;b, Real &amp;q)</td></tr>
<tr class="separator:a174110a449a3c932f3fa65178a0e656b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5679d4c73e15822435744854ab3e6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac5679d4c73e15822435744854ab3e6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DivideRound</b> (const long &amp;a, const long &amp;b, long &amp;q)</td></tr>
<tr class="separator:aac5679d4c73e15822435744854ab3e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical functions</div></td></tr>
<tr class="memitem:a26d0d5ab592a3890ea8a6353c2f91119"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26d0d5ab592a3890ea8a6353c2f91119"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a26d0d5ab592a3890ea8a6353c2f91119">Euclide</a> (const MScal &amp;a, const MScal &amp;b, MScal &amp;C, MScal &amp;D, MScal &amp;E, MScal &amp;F, MScal &amp;G)</td></tr>
<tr class="memdesc:a26d0d5ab592a3890ea8a6353c2f91119"><td class="mdescLeft">&#160;</td><td class="mdescRight">For given \(a\) and \(b\), returns the values \(C\), \(D\), \(E\), \(F\) and \(G\) such that: </p><p class="formulaDsp">
\begin{eqnarray*} C a + D b &amp;=&amp; G = \mbox{GCD } (a,b) \\ E a + F b &amp;=&amp; 0. \end{eqnarray*}
</p>
<p>. <br /></td></tr>
<tr class="separator:a26d0d5ab592a3890ea8a6353c2f91119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00abef3e62421f090ab52fc157ea6495"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a00abef3e62421f090ab52fc157ea6495">gcd</a> (long a, long b)</td></tr>
<tr class="memdesc:a00abef3e62421f090ab52fc157ea6495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the greatest common divisor of \(a\) and \(b\).  <a href="#a00abef3e62421f090ab52fc157ea6495">More...</a><br /></td></tr>
<tr class="separator:a00abef3e62421f090ab52fc157ea6495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4a47eb1310966d9d7ea083eb424b32"><td class="memTemplParams" colspan="2"><a class="anchor" id="adc4a47eb1310966d9d7ea083eb424b32"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:adc4a47eb1310966d9d7ea083eb424b32"><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#adc4a47eb1310966d9d7ea083eb424b32">Round</a> (Real x)</td></tr>
<tr class="memdesc:adc4a47eb1310966d9d7ea083eb424b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds to the nearest integer value. <br /></td></tr>
<tr class="separator:adc4a47eb1310966d9d7ea083eb424b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab004d5d851fe3b3e97e3ba18f8dce454"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab004d5d851fe3b3e97e3ba18f8dce454"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#ab004d5d851fe3b3e97e3ba18f8dce454">IsPrime</a> (unsigned long n)</td></tr>
<tr class="memdesc:ab004d5d851fe3b3e97e3ba18f8dce454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if \(n\) is prime, <code>false</code> otherwise. <br /></td></tr>
<tr class="separator:ab004d5d851fe3b3e97e3ba18f8dce454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vector operations</div></td></tr>
<tr class="memitem:aa58a07e74d8e423e6807e804b870cc03"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa58a07e74d8e423e6807e804b870cc03"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:aa58a07e74d8e423e6807e804b870cc03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#aa58a07e74d8e423e6807e804b870cc03">SetZero</a> (Vect &amp;A, int d)</td></tr>
<tr class="memdesc:aa58a07e74d8e423e6807e804b870cc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets components \([0..d]\) of \(A\) to 0. <br /></td></tr>
<tr class="separator:aa58a07e74d8e423e6807e804b870cc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707791ae5b6d0f6e0df7e0d4ec3c7beb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a707791ae5b6d0f6e0df7e0d4ec3c7beb"></a>
template&lt;typename Vect , typename Scal &gt; </td></tr>
<tr class="memitem:a707791ae5b6d0f6e0df7e0d4ec3c7beb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a707791ae5b6d0f6e0df7e0d4ec3c7beb">ModifVect</a> (Vect &amp;A, Vect &amp;B, const Scal &amp;x, int n)</td></tr>
<tr class="memdesc:a707791ae5b6d0f6e0df7e0d4ec3c7beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector \(B\) multiplied by \(x\) to vector \(A\) using components \([1..n]\), and puts the result in \(A\). <br /></td></tr>
<tr class="separator:a707791ae5b6d0f6e0df7e0d4ec3c7beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab3582696e4e8df6a186101ff772f72"><td class="memTemplParams" colspan="2"><a class="anchor" id="afab3582696e4e8df6a186101ff772f72"></a>
template&lt;typename Vect , typename Scal &gt; </td></tr>
<tr class="memitem:afab3582696e4e8df6a186101ff772f72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#afab3582696e4e8df6a186101ff772f72">ModifVect</a> (MVect &amp;A, Vect &amp;B, const Scal &amp;x, int n)</td></tr>
<tr class="memdesc:afab3582696e4e8df6a186101ff772f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector \(B\) multiplied by \(x\) to vector \(A\) using components \([1..n]\), and puts the result in \(A\). <br /></td></tr>
<tr class="separator:afab3582696e4e8df6a186101ff772f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c6ae0a5fa1474d3fe5717b5e21b357"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae0c6ae0a5fa1474d3fe5717b5e21b357"></a>
template&lt;typename V , typename Scal &gt; </td></tr>
<tr class="memitem:ae0c6ae0a5fa1474d3fe5717b5e21b357"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ProdScal</b> (const V &amp;A, const V &amp;B, int n, Scal &amp;D)</td></tr>
<tr class="separator:ae0c6ae0a5fa1474d3fe5717b5e21b357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed39ba8e2e6e50617d2306533b0cb14"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ed39ba8e2e6e50617d2306533b0cb14"></a>
template&lt;typename Scal &gt; </td></tr>
<tr class="memitem:a0ed39ba8e2e6e50617d2306533b0cb14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a0ed39ba8e2e6e50617d2306533b0cb14">ProdScal</a> (const BVect &amp;A, const BVect &amp;B, int n, Scal &amp;D)</td></tr>
<tr class="memdesc:a0ed39ba8e2e6e50617d2306533b0cb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar product of vectors \(A\) and \(B\), using components \([1..n]\), and puts the result in \(D\). <br /></td></tr>
<tr class="separator:a0ed39ba8e2e6e50617d2306533b0cb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79972c4190a88cc92ba946c30616ea99"><td class="memTemplParams" colspan="2"><a class="anchor" id="a79972c4190a88cc92ba946c30616ea99"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a79972c4190a88cc92ba946c30616ea99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a79972c4190a88cc92ba946c30616ea99">ChangeSign</a> (Vect &amp;A, int n)</td></tr>
<tr class="memdesc:a79972c4190a88cc92ba946c30616ea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the sign of the components \([1..n]\) of vector \(A\). <br /></td></tr>
<tr class="separator:a79972c4190a88cc92ba946c30616ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dc9ef4001a60804f911df7effcd885"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52dc9ef4001a60804f911df7effcd885"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a52dc9ef4001a60804f911df7effcd885">GCD2vect</a> (std::vector&lt; long &gt; V, int k, int n)</td></tr>
<tr class="memdesc:a52dc9ef4001a60804f911df7effcd885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of \(V[k],\ldots,V[n]\). <br /></td></tr>
<tr class="separator:a52dc9ef4001a60804f911df7effcd885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e62df871bc68a0a5389a8a02207beaf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e62df871bc68a0a5389a8a02207beaf"></a>
template&lt;typename Vect , typename Scal &gt; </td></tr>
<tr class="memitem:a8e62df871bc68a0a5389a8a02207beaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a8e62df871bc68a0a5389a8a02207beaf">CalcNorm</a> (const Vect &amp;V, int n, Scal &amp;S, <a class="el" href="../../d9/dac/namespaceLatCommon.html#add4c45a7a3803fb5a4975437dff81767">NormType</a> norm)</td></tr>
<tr class="memdesc:a8e62df871bc68a0a5389a8a02207beaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code>norm</code> norm of vector \(V\), using components \([1..n]\), and puts the result in \(S\). <br /></td></tr>
<tr class="separator:a8e62df871bc68a0a5389a8a02207beaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrices</div></td></tr>
<tr class="memitem:afe6d3aeb3002d384a42ee688766a1cf5"><td class="memTemplParams" colspan="2"><a class="anchor" id="afe6d3aeb3002d384a42ee688766a1cf5"></a>
template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:afe6d3aeb3002d384a42ee688766a1cf5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#afe6d3aeb3002d384a42ee688766a1cf5">CheckTriangular</a> (const Matr &amp;A, int dim, const MScal &amp;m)</td></tr>
<tr class="memdesc:afe6d3aeb3002d384a42ee688766a1cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that square matrix \(A\) is upper triangular (modulo \(m\)) for dimensions 1 to <code>dim</code>. <br /></td></tr>
<tr class="separator:afe6d3aeb3002d384a42ee688766a1cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8f3b1fe6f1c8c88670094547fabb2d"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:a1b8f3b1fe6f1c8c88670094547fabb2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a1b8f3b1fe6f1c8c88670094547fabb2d">Triangularization</a> (Matr &amp;W, Matr &amp;V, int lin, int col, const MScal &amp;m)</td></tr>
<tr class="memdesc:a1b8f3b1fe6f1c8c88670094547fabb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an integer triangularization operation modulo \(m\) on the matrix \(W\) to obtain an upper triangular matrix \(V\), dual to \(W\).  <a href="#a1b8f3b1fe6f1c8c88670094547fabb2d">More...</a><br /></td></tr>
<tr class="separator:a1b8f3b1fe6f1c8c88670094547fabb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710b0a60463a29c60ec7e36ab5710b93"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:a710b0a60463a29c60ec7e36ab5710b93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a710b0a60463a29c60ec7e36ab5710b93">CalcDual</a> (const Matr &amp;A, Matr &amp;B, int d, const MScal &amp;m)</td></tr>
<tr class="memdesc:a710b0a60463a29c60ec7e36ab5710b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the \(m\)-dual of the matrix <code>A</code>.  <a href="#a710b0a60463a29c60ec7e36ab5710b93">More...</a><br /></td></tr>
<tr class="separator:a710b0a60463a29c60ec7e36ab5710b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Printing functions and operators</div></td></tr>
<tr class="memitem:acbcf71952113e63573ed204d17693fdf"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:acbcf71952113e63573ed204d17693fdf"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#acbcf71952113e63573ed204d17693fdf">toString</a> (const Vect &amp;A, int c, int d, const char *sep)</td></tr>
<tr class="memdesc:acbcf71952113e63573ed204d17693fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints components \([c..d]\) of vector \(A\) as a string.  <a href="#acbcf71952113e63573ed204d17693fdf">More...</a><br /></td></tr>
<tr class="separator:acbcf71952113e63573ed204d17693fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467511ae3965231b382dc10b0d13c5a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a467511ae3965231b382dc10b0d13c5a4"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a467511ae3965231b382dc10b0d13c5a4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a467511ae3965231b382dc10b0d13c5a4">toString</a> (const Vect &amp;A, int c, int d)</td></tr>
<tr class="memdesc:a467511ae3965231b382dc10b0d13c5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints components \([c..d]\) of vector \(A\) as a string. <br /></td></tr>
<tr class="separator:a467511ae3965231b382dc10b0d13c5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2bccea8e60435ba2dcca7e3f591585"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e2bccea8e60435ba2dcca7e3f591585"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a9e2bccea8e60435ba2dcca7e3f591585"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a9e2bccea8e60435ba2dcca7e3f591585">toString</a> (const Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a9e2bccea8e60435ba2dcca7e3f591585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints components \([1..d]\) of vector \(A\) as a string. <br /></td></tr>
<tr class="separator:a9e2bccea8e60435ba2dcca7e3f591585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00a02fe0ec0bd302e6117ab9d6cde25"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aa00a02fe0ec0bd302e6117ab9d6cde25"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#aa00a02fe0ec0bd302e6117ab9d6cde25">operator&lt;&lt;</a> (std::ostream &amp;out, const std::pair&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr class="memdesc:aa00a02fe0ec0bd302e6117ab9d6cde25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <a href="#aa00a02fe0ec0bd302e6117ab9d6cde25">More...</a><br /></td></tr>
<tr class="separator:aa00a02fe0ec0bd302e6117ab9d6cde25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d440f12f881becbac3cfd559b8aa1f"><td class="memTemplParams" colspan="2">template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:a60d440f12f881becbac3cfd559b8aa1f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a60d440f12f881becbac3cfd559b8aa1f">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a60d440f12f881becbac3cfd559b8aa1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <a href="#a60d440f12f881becbac3cfd559b8aa1f">More...</a><br /></td></tr>
<tr class="separator:a60d440f12f881becbac3cfd559b8aa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a88b39d5c4bef893ac839553f1b1bcebc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88b39d5c4bef893ac839553f1b1bcebc"></a>
const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dac/namespaceLatCommon.html#a88b39d5c4bef893ac839553f1b1bcebc">TWO_EXP</a> []</td></tr>
<tr class="memdesc:a88b39d5c4bef893ac839553f1b1bcebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of powers of 2: <code>TWO_EXP</code>[ \(i\)] \(= 2^i\), \(i=0, 1, \ldots\) for \(i \le 31\) for 32-bits machines, and \(i \le 63\) for 64-bits machines. <br /></td></tr>
<tr class="separator:a88b39d5c4bef893ac839553f1b1bcebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This module contains global constants used in <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This module describes various useful functions as well as functions interfacing with NTL...">LatMRG</a>{} and Lattice Builder. </p>
<p>This module describes useful tools and interface functions to Boost or <a class="el" href="../../d2/d5a/namespaceNTL.html" title="Converts the array of characters (string) c into l. ">NTL</a>.</p>
<p>This module implements a few useful mathematical functions.</p>
<dl class="section note"><dt>Note</dt><dd>Richard: Most of these are used only in <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This module describes various useful functions as well as functions interfacing with NTL...">LatMRG</a>; thus should separate this in two different files: one common and one in <a class="el" href="../../df/d5e/namespaceLatMRG.html" title="This module describes various useful functions as well as functions interfacing with NTL...">LatMRG</a>. </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac877ba5335bc8575a96c339d7dc74c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="../../d9/dac/namespaceLatCommon.html#ac877ba5335bc8575a96c339d7dc74c74">LatCommon::Weight</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar weight type. </p>
<dl class="section note"><dt>Note</dt><dd>We could have used <code>Weight</code>, but it might be wise to leave this <code>typedef</code> in case we decide to use <code>long Weight</code> at some point. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a689a9256cbfacf954b3085d2bcd49e49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/dac/namespaceLatCommon.html#a689a9256cbfacf954b3085d2bcd49e49">LatCommon::CalcType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which type of calculation is considered for the \(P_\alpha\) test. </p>
<p><code>CalcType.def</code><code>PAL</code> is for the \(P_\alpha\) test. \f[1ex] <code>BAL</code> is for the bound on the \(P_\alpha\) test. \f[1ex] <code>NORMPAL</code> is for the \(P_\alpha\) test <code>PAL</code>, with the result normalized over the <code>BAL</code> bound. \f[1ex] <code>SEEKPAL</code> is for the \(P_\alpha\) seek, which searches for good values of the multiplier. </p>

</div>
</div>
<a class="anchor" id="ad403368fce9d701987b6a65e01b4309c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/dac/namespaceLatCommon.html#ad403368fce9d701987b6a65e01b4309c">LatCommon::CriterionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the merit criterion for ranking generators or lattices. </p>
<p><code>BEYER:</code> the figure of merit is the Beyer quotient \(Q_T\).\f[1ex] <code>SPECTRAL:</code> the figure of merit \(S_T\) is based on the spectral test.\f[1ex] <code>PALPHA:</code> the figure of merit is based on \(P_\alpha\).\f[1ex] <code>BOUND_JS:</code> the figure of merit is based on the Joe-Sinescu bound <a class="el" href="../../d0/de3/citelist.html#CITEREF_rSIN08a">[17]</a> . </p>

</div>
</div>
<a class="anchor" id="a14fd92967999f16fae471a5488ed82b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/dac/namespaceLatCommon.html#a14fd92967999f16fae471a5488ed82b5">LatCommon::DecompType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an integer \(r\), indicates what to do about the decomposition of \(r\) in its prime factors. </p>
<p><code>DECOMP:</code> means that the program will factorize \(r\).\f[1ex] <code>DECOMP_WRITE:</code> means that the program will factorize \(r\) and writes the factors in a file.\f[1ex] <code>DECOMP_READ:</code> means that \(r\) is already factorized, and the factors will be read from a file.\f[1ex] <code>DECOMP_PRIME:</code> means that \(r\) is prime. No factorization will be done. </p>

</div>
</div>
<a class="anchor" id="a758d3c9e8f86ab5f52a055626174094b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/dac/namespaceLatCommon.html#a758d3c9e8f86ab5f52a055626174094b">LatCommon::GenType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to identify the type of a generator. </p>
<p>If a generator is of type <code>MWC</code>, it is converted to its corresponding <code>MRG</code> by the program.<code>LCG:</code> the linear congruential generator.\f[1ex] <code>MRG:</code> the multiple-recursive generator.\f[1ex] <code>MWC:</code> the multiply-with-carry generator.\f[1ex] <code>KOROBOV:</code> the Korobov lattice.\f[1ex] <code>RANK1:</code> the rank 1 lattice. </p>

</div>
</div>
<a class="anchor" id="a315cf9219517c9d31a1315330bf642c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/dac/namespaceLatCommon.html#a315cf9219517c9d31a1315330bf642c3">LatCommon::ImplemCond</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which type of conditions are imposed on the coefficients \(a_i\) of a recurrence. </p>
<p><code>NO_COND:</code> no condition is imposed on the coefficients.\f[1ex] <code>APP_FACT:</code> the coefficients must satisfy the ``approximate factoring'' condition \(|a_i| (m\mod |a_i|) &lt; m\). Congruential generators are easier to implement under this condition <a class="el" href="../../d0/de3/citelist.html#CITEREF_rLEC90a">[13]</a> .\f[1ex] <code>POWER_TWO:</code> the coefficients must be sums or differences of powers of 2.\f[1ex] <code>EQUAL_COEF:</code> all the coefficients must be equal by groups: a first group all equal to a first number, a second group all equal to a second number, and so on. \f[1ex] <code>ZERO_COEF:</code> all the coefficients must be equal to 0, except for a select fews. </p>

</div>
</div>
<a class="anchor" id="a70ed2a2f696926b82e588d842f3ebb55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/dac/namespaceLatCommon.html#a70ed2a2f696926b82e588d842f3ebb55">LatCommon::LatticeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether to analyze the lattice generated by all possible states, or a sub-lattice generated by the set of recurrent states or by a sub-cycle of the generator. </p>
<p><code>FULL:</code> The complete lattice, generated by all possible initial states, will be analyzed.\f[1ex] <code>RECURRENT:</code> If the (combined) generator has transient states, then the lattice analyzed will be the sub-lattice generated by the set of recurrent states.\f[1ex] <code>ORBIT:</code> The grid generated by the (forward) orbit of a state of the (combined) generator is analyzed. This state is specified as follows. On the following \(J\) lines, the initial state for each component must be given. This is an integer vector with a number of components equal to the order of the component.\f[1ex] <code>PRIMEPOWER:</code> In the case where some component is an MLCG whose modulus is a power of a prime \(p\), then the states visited over a single orbit (sub-cycle) of that component generate a sub-lattice (when \(a \equiv 1 \bmod{p}\)) or belong to the union of \(p-1\) sub-lattices (otherwise). If <code>LatticeType</code> takes this value, and a component is a MLCG ( \(k=1\)), and if the modulus of that MLCG is given in the data file in the form (b): \((x\ y\ z)\) with \(z=0\) and \(x\) prime, then what is analyzed is one of those sub-lattices. This is done by dividing the modulus by the appropriate power of \(p\), as described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rLEC94e">[12]</a> . For example, if \(p=2\) and \(a \mod 8 = 5\), then the modulus is divided by 4 as in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rFIS90a">[7]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_rKNU81a">[9]</a> . </p>

</div>
</div>
<a class="anchor" id="a6810518877211761291544d0ee2b771c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/dac/namespaceLatCommon.html#a6810518877211761291544d0ee2b771c">LatCommon::NormaType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which normalization is used to compute \(S_t\) in the spectral test, for each dimension \(t\). </p>
<p><code>BESTLAT:</code> the value used for \(d_t^*\) corresponds to the best lattice.\f[1ex] <code>LAMINATED:</code> the value used for \(d_t^*\) corresponds to the best <em>emph</em> lattice.\f[1ex] <code>ROGERS:</code> the value for \(d_t^*\) is obtained from <em>emph</em> bound on the density of sphere packing.\f[1ex] <code>MINKOWSKI:</code> the value for \(d_t^*\) is obtained from <em>emph</em> theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\cal L}_2\) norm.\f[1ex] <code>MINKL1:</code> the value for \(d_t^*\) is obtained from the theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\cal L}_1\) norm.\f[1ex] <code>PALPHA_N:</code> the case of the \(P_\alpha\) test.\f[1ex] <code>NORMA_GENERIC:</code> the trivial normalization (= 1) used for the generic case when no useful normalization constant is known. </p>

</div>
</div>
<a class="anchor" id="add4c45a7a3803fb5a4975437dff81767"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/dac/namespaceLatCommon.html#add4c45a7a3803fb5a4975437dff81767">LatCommon::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which norm is used to measure the length of vectors. </p>
<p>For \(X = (x_1,\dots,x_t)\),<code>SUPNORM</code> corresponds to \(\Vert X\Vert = \max (|x_1|,\dots,|x_t|)\).\f[1ex] <code>L1NORM</code> corresponds to \(\Vert X\Vert = |x_1|+\cdots+|x_t|\).\f[1ex] <code>L2NORM</code> corresponds to \(\Vert X\Vert = (x_1^2+\cdots+x_t^2)^{1/2}\).\f[1ex] <code>ZAREMBANORM</code> corresponds to \(\Vert X\Vert = \max(1, |x_1|)\cdots\max(1, |x_t|)\). </p>

</div>
</div>
<a class="anchor" id="ad3cdd498b2f20a100b1c563a8ea5e005"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/dac/namespaceLatCommon.html#ad3cdd498b2f20a100b1c563a8ea5e005">LatCommon::OutputType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates in which form and where the results will be sent. </p>
<p><code>co:output</code><code>TERMINAL:</code> the results will appear only on the terminal screen.\f[1ex] <code>RES:</code> the results will be in plain text format and sent to a file with extension ``<code></code>.res''.\f[1ex] <code>TEX:</code> the results will be in \(\mbox{\LaTeX}\) format and sent to a file with extension ``<code></code>.tex''.\f[1ex] <code>GEN:</code> the results will be sent to a file with extension ``<code></code>.gen''. </p>

</div>
</div>
<a class="anchor" id="a3d6a0e1ad183c20832f105f09c7f775f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/dac/namespaceLatCommon.html#a3d6a0e1ad183c20832f105f09c7f775f">LatCommon::SearchMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the search method used to find good multipliers \(a_i\). </p>
<p><code>EXHAUST:</code> the search will be exhaustive over the chosen regions.\f[1ex] <code>RANDOM:</code> the search will be random over the chosen regions. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a757b1ddc97f31fa825cabb8be8a18eee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatCommon::BernoulliPoly </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\). </p>
<p>The first Bernoulli polynomials are: </p><p class="formulaDsp">
\begin{align*} B_0(x) &amp;= 1 \\ B_1(x) &amp;= x - 1/2 \\ B_2(x) &amp;= x^2-x+1/6 \\ B_3(x) &amp;= x^3 - 3x^2/2 + x/2 \\ B_4(x) &amp;= x^4-2x^3+x^2-1/30 \\ B_5(x) &amp;= x^5 - 5x^4/2 + 5x^3/3 - x/6 \\ B_6(x) &amp;= x^6-3x^5+5x^4/2-x^2/2+1/42 \\ B_7(x) &amp;= x^7 - 7x^6/2 + 7x^5/2 - 7x^3/6 + x/6 \\ B_8(x) &amp;= x^8-4x^7+14x^6/3 - 7x^4/3 +2x^2/3-1/30. \end{align*}
</p>
<p> Only degrees \(n \le 8\) are programmed for now. </p>

</div>
</div>
<a class="anchor" id="a710b0a60463a29c60ec7e36ab5710b93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatCommon::CalcDual </td>
          <td>(</td>
          <td class="paramtype">const Matr &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MScal &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the \(m\)-dual of the matrix <code>A</code>. </p>
<p>The result is placed in the matrix <code>B</code>. Only the first \(d\) lines and columns are considered. </p>

</div>
</div>
<a class="anchor" id="a2b5b24a119adf60ae2c1ba94a32d5c28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatCommon::Divide </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\). </p>
<p>Truncates \(q\) to the nearest integer towards 0. One always has \(a = qb + r\) and \(|r| &lt; |b|\). </p>

</div>
</div>
<a class="anchor" id="a6ab8424381b4767bb8bed7df4cc84803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatCommon::FourierE1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series </p><p class="formulaDsp">
\[ G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\; \frac{e^{2\pi i h x}}{|h|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes. </p>
<p>Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a class="anchor" id="a00abef3e62421f090ab52fc157ea6495"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long LatCommon::gcd </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the greatest common divisor of \(a\) and \(b\). </p>
<dl class="section note"><dt>Note</dt><dd>Richard: Il y a déjà des fonctions GCD dans <a class="el" href="../../d2/d5a/namespaceNTL.html" title="Converts the array of characters (string) c into l. ">NTL</a>, pour les <code>long</code> et les <code>ZZ</code> (voir fichier ZZ.h) </dd></dl>

</div>
</div>
<a class="anchor" id="a56536d4e688efe54aa875c7f255db27f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatCommon::MyExit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special exit function. </p>
<p><code>status</code> is the code to return to the system, <code>msg</code> is the message to print on exit. </p>

</div>
</div>
<a class="anchor" id="aa00a02fe0ec0bd302e6117ab9d6cde25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatCommon::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a pair as: <code></code>(first,second). </p>

</div>
</div>
<a class="anchor" id="a60d440f12f881becbac3cfd559b8aa1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatCommon::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a vector as: <code>[ val1, ..., valN ]</code>. </p>

</div>
</div>
<a class="anchor" id="acbcf71952113e63573ed204d17693fdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatCommon::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints components \([c..d]\) of vector \(A\) as a string. </p>
<p>Components are separated by string <code>sep</code>. </p>

<p>Referenced by <a class="el" href="../../d9/dac/namespaceLatCommon.html#a467511ae3965231b382dc10b0d13c5a4">toString()</a>.</p>

</div>
</div>
<a class="anchor" id="a4484798c5e2dbf0f5816c08cb218a00e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatCommon::toStringNorm </td>
          <td>(</td>
          <td class="paramtype">NormType&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code>enum</code> constants in this module as strings. </p>
<dl class="section note"><dt>Note</dt><dd>Richard: These are global methods for now, but maybe <code>Const</code> should be a class containing these methods. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b8f3b1fe6f1c8c88670094547fabb2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatCommon::Triangularization </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MScal &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an integer triangularization operation modulo \(m\) on the matrix \(W\) to obtain an upper triangular matrix \(V\), dual to \(W\). </p>
<p>However, the matrix \(W\) will be transformed too in order to preserve duality. Only the first <code>lin</code> lines and the first <code>col</code> columns of the matrices will be considered (counting indices from 1; line 0 and column 0 must be there but are unused). </p>

<p>References <a class="el" href="../../d9/dac/namespaceLatCommon.html#a26d0d5ab592a3890ea8a6353c2f91119">Euclide()</a>, and <a class="el" href="../../d9/dac/namespaceLatCommon.html#a8f6c9a5f07228436ba8dad5ec109337f">IsZero()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/dac/namespaceLatCommon.html">LatCommon</a></li>
    <li class="footer">Generated on Wed Apr 1 2015 20:47:00 for Lattice Builder Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
