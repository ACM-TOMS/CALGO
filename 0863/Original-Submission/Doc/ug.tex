%\acmVolume{V}
%\acmNumber{N}
%\acmYear{YY}
%\acmMonth{M}


\documentclass[acmtoms]{acmtrans2m}
\usepackage{amsfonts}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{mathrsfs}

%TCIDATA{OutputFilter=LATEX.DLL}
%TCIDATA{LastRevised=Sat Feb 04 20:27:52 2006}
%TCIDATA{<META NAME="GraphicsSave" CONTENT="32">}
%TCIDATA{Language=American English}

\markboth{...}{...}
\begin{abstract}
L2WPMA is a package of Fortran 77 subroutines that calculates a weighted least squares piecewise monotonic approximation to univariate data contaminated by random errors [3]. This report provides an overview of the subroutines and gives instructions for using the package that specify its interface with the calling program.
\end{abstract}
\category{G.1.2}{Numerical analysis}{Approximation - least squares 
approximation - smoothing}
\category{G.2.1}{Combinatorics}{Recurrences}
\terms{Algorithms}
\keywords{approximation, data smoothing, divided difference, dynamic programming, fitting, turning point}
\input{tcilatex}

\begin{document}

\title{USER GUIDE FOR ALGORITH XXX: L2WPMA}
\author{IOANNIS C. DEMETRIOU \\
%EndAName
University of Athens}
\maketitle

\bigskip 
\begin{bottomstuff}
Unit of Mathematics and Informatics, Department of Economics,
University of Athens, 8 Pesmazoglou Street, 105 59 Athens, Greece,
e-mail: demetri@econ.uoa.gr
\end{bottomstuff}
\markboth{Ioannis C. Demetriou}{User guide for Algorithm XXX: L2WPMA}

\section{Problem definition and outline of the method}

L2WPMA is a package of Fortran subroutines that is presented by [3]. It
calculates a weighted least squares piecewise monotonic approximation to $n$
univariate data contaminated by random errors, which is defined as follows.
If a real function $f(x)$ is measured at the abscissae $x_{1}<x_{2}<\cdots
<x_{n}$ and the measurements \{$\phi _{i}\cong f(x_{i})$: $i=1,2,\ldots ,n$%
\} contain large uncorrelated random errors, then L2WPMA can be used to
calculate values for \{$y_{i}:i=1,2,\ldots ,n$\} that minimize the weighted
sum of the squares of the errors

\begin{equation}
\Phi (y)=\sum_{i=1}^{n}w_{i}(\phi _{i}-y_{i})^{2}  \label{1.1}
\end{equation}
so that the sequence \{$y_{i+1}-y_{i}:i=1,2,\ldots ,n-1$\} has at most $k-1$
sign changes, where $k$ is a given positive integer smaller than $n$.
Without loss of generality, we assume that the first nonzero difference $%
y_{i+1}-y_{i}$ is positive. So the constraints are [4] 
\begin{equation}
\left. 
\begin{array}{c}
y_{t_{j}}\leq y_{t_{j}+1}\leq \cdots \leq y_{t_{j+1}},{\text{ }}j{\text{ even%
}} \\ 
y_{t_{j}}\geq y_{t_{j}+1}\geq \cdots \geq y_{t_{j+1}},{\text{ }}j{\text{ odd}%
}
\end{array}
\right\} \text{,}  \label{1.2}
\end{equation}
where \{$t_{j}:j=1,2,...,k-1$\} are integers that satisfy the conditions 
\begin{equation}
1=t_{0}\leq t_{1}\leq \cdots \leq t_{k}=n,  \label{1.3}
\end{equation}
and where the numbers (weights) $w_{i}$ satisfy the inequalities $w_{i}>0$, $%
i=1,2,\ldots ,n$. While $k$ is provided by the user, \{$t_{j}:j=1,2,\ldots
,k-1$\} are variables of the minimization calculation together with \{$%
y_{i}:i=1,2,\ldots ,n$\}. It is convenient to the subsequent presentation to
consider \{$\phi _{i}:i=1,2,\ldots ,n$\} and \{$y_{i}:i=1,2,\ldots ,n$\} as
the components of vectors $\phi $ and $y$ in $\Bbb{R}^{n}$ respectively.

L2WPMA consists of five Fortran subroutines for the calculation of an
optimal fit to $\phi $. The user may specify\ whether the first monotonic
section is increasing or decreasing. The software package allows a monotonic
section to degenerate to a single component. The underlying method is
described by [2] except that L2WPMA allows the data have positive weights
and at the end of the calculation it provides a spline representation of the
fit and the corresponding Lagrange multipliers. The entry point of our
package, which also names the software package, is subroutine L2WPMA.
Section 2 specifies the interface of the software with the calling program.
Section 3 presents the purpose of each subroutine. Section 4 presents output
of a simple example. Section 5 gives information for further documentation.

In order to explain the purpose of the arguments of the user interface, we
outline below the method of calculation, but for details one may consult
[2]. For positive integers $p$ and $q$, we let 
\begin{equation}
\alpha (p,q)=\mathop {\min }\limits_{y_{p}\leq y_{p+1}\leq \cdots \leq
y_{q}}\sum\limits_{i=p}^{q}{w_{i}}(\phi _{i}-y_{i})^{2},\qquad 1\leq p\leq
q\leq n\text{,}  \label{1.4}
\end{equation}
\begin{equation}
\beta (p,q)=\mathop {\min }\limits_{y_{p}\geq y_{p+1}\geq \cdots \geq
y_{q}}\sum\limits_{i=p}^{q}{w_{i}}(\phi _{i}-y_{i})^{2},\qquad 1\leq p\leq
q\leq n\text{,}  \label{1.5}
\end{equation}
and for any integers $m\in \lbrack 1,k]$ and $t\in \lbrack 1,n]$ we let 
\[
G(m,t)=\text{\{}\mathop {\min }\limits_{z\in \Bbb{R}^{t}}\sum%
\limits_{i=1}^{t}{w_{i}}(\phi _{i}-z_{i})^{2},\text{ \ }z\text{ has }m\text{
monotonic sections\}.} 
\]
\newline
In order to calculate $G(k,n)$, which is the least value of (\ref{1.1}), we
begin the calculation from $G(1,t)=\alpha (1,t)$, for $t=1,2,\ldots ,n$, and
proceed by applying the dynamic programming formulae 
\begin{equation}
G(m,t)=\left\{ 
\begin{array}{r}
\stackunder{s\in \lbrack \max \{\vartheta (m),\tau (m-2,t\},t]\cap %
\mathscr{L}}{\min }[G(m-1,s)+\alpha (s,t)]\text{, \ }m\text{ odd,} \\ 
\stackunder{s\in \lbrack \max \{\vartheta (m),\tau (m-2,t\},t]\cap %
\mathscr{U}}{\min }[G(m-1,s)+\beta (s,t)]\text{, \ }m\text{ even,}
\end{array}
\right.  \label{1.6}
\end{equation}
for all $m\in \lbrack 2,k]$, while $t$ increments in $\mathscr{L}$ or $%
\mathscr{U}$, where: $\mathscr{L}$ and $\mathscr{U}$ are the sets of the
indices of local minima and local maxima of the data respectively (for the
definitions of $\mathscr{L}$ and $\mathscr{U}$ see [4]); $\tau (m,t)$ is the
value of $s$ that minimizes expression (\ref{1.6}), for each value of $m$
and $t$; and, $\vartheta (m)$ is the greatest value of $\{\tau (m,\ell
):\ell <t\}$ that has already been calculated while $\tau (m,\ell )$ is
chosen as small as possible. At the end of the process $m=k$ occurs, the
value $\tau (k,n)$ is the integer $t_{k-1}$ and we obtain the sequence of
optimal values $\{t_{j}:j=1,2,\ldots ,k-1\}$ by the backward formula 
\begin{equation}
t_{k}=n,\text{ }t_{m-1}=\tau (m,t_{m})\text{, \ \ \ }m=k,k-1,\ldots ,2.
\label{1.7}
\end{equation}
Then, the components of an optimal fit are monotonic increasing on $%
[1,t_{1}] $ and on $[t_{j},t_{j+1}]$ for even $j$ in $[1,k-1]$ and
decreasing on $[t_{j},t_{j+1}]$ for odd $j$ in $[1,k-1]$. In Section 4 a
numerical example demonstrates the derivation of the $t_{i}$s for $k>2$, by
means of (\ref{1.7}).

L2WPMA provides also the Lagrange multipliers $\{\lambda _{i}:i=2,3,\ldots
,n\}$ (although they are not required for obtaining the optimal fit). They
are defined as follows. Having obtained the optimal sequence of integers $%
\{t_{i}:i=2,3,\ldots ,k-1\}$ and the associated optimal fit $y$, the
Karush-Kuhn-Tucker conditions for the problem that minimizes (\ref{1.1})
subject to the constraints (\ref{1.2}) state that the equation 
\begin{equation}
\text{grad}\Phi (y)=\sum_{i\in \mathscr{A}}\lambda _{i}(e^{i-1}-e^{i})
\label{1.8}
\end{equation}
holds, where $\mathscr{A}$ is the subset $\mathscr{A}=\{i:y_{i-1}-y_{i}=0\}$
of the constraint indices $\{2,3,\ldots ,n\}$, $e^{i}$ is the $i$th
coordinate vector in $\Bbb{R}^{n}$ and $\text{grad}\Phi (y)$ is the gradient
of $\Phi (y)$; and, $\{\lambda _{i}:i\in \mathscr{A}\}$ are nonnegative,
when $i\in \lbrack 2,t_{1}]\cap \mathscr{A}$ and $i\in \lbrack
t_{j}+1,t_{j+1}]\cap \mathscr{A}$ for $j$ even, and nonpositive, when $i\in
\lbrack t_{j}+1,t_{j+1}]\cap \mathscr{A}$ for $j$ odd. Further, we define $%
\lambda _{i}=0$ for all integers $i$ in $[2,n]\backslash \mathscr{A}$, so
that $\lambda $ is a $(n-1)$-vector.

Finally, we may express the optimal fit $y$ in the form of first-order
B-splines (see [1: p.89]). To be specific, we represent $y$ by a triple $%
(\kappa ,\omega ,\zeta )$. Here $\kappa $ is a positive integer and $\omega $
and $\zeta $ are vectors in $\Bbb{R}^{\kappa }$, where the components of $%
\omega $ are positive integers whose sum is $n$. This triple denotes the
vector $y=y(\kappa ,\omega ,\zeta )\in \Bbb{R}^{n}$ that has $\omega _{1}$
components equal to $\zeta _{1}$, $\omega _{2}$ components equal to $\zeta
_{2}$ and so on up to $\omega _{\kappa }$ components equal to $\zeta
_{\kappa }$ . Hence we define the knots $\xi _{1}=x_{1}$, $\xi
_{2}=x_{\omega _{1}+1}$, $\xi _{3}=x_{\omega _{1}+\omega _{2}+1}$ and so on
up to $\xi _{\kappa }=x_{\omega _{1}+\omega _{2}+\cdots +\omega _{\kappa
-1}+1}$, we let $\zeta _{1}=y_{1}$, $\zeta _{2}=y_{\omega _{1}+1}$, $\zeta
_{3}=y_{\omega _{1}+\omega _{2}+1}$ and so on up to $\zeta _{\kappa
}=y_{\omega _{1}+\omega _{2}+\cdots +\omega _{\kappa -1}+1}$, and we obtain
the spline representation $s(x)$ of vector $y$ by 
\begin{equation}
s(x)=\sum\limits_{j=1}^{\kappa }\zeta _{j}B_{j}(x),\qquad x_{1}\leq x\leq
x_{n},  \label{1.9}
\end{equation}
where $B_{j}(x)=1$, if $\xi _{j}\leq x<\xi _{j+1}$, and $B_{j}(x)=0$
otherwise. L2WPMA at the end of the calculation provides the data indices of
the knots, so the user may obtain the sequences \{$\xi _{i}:i=1,2,\ldots
,\kappa $\} and \{$\zeta _{i}:i=1,2,\ldots ,\kappa $\} (see argument IAKN of
subroutine L2WPMA in Section 2).

\section{User interface}

The main subroutine that provides interface to the user is declared by

\bigskip 

SUBROUTINE L2WPMA(I1, N, X, F, WF, MODEWF, KSECTN, IORDER, +Y, WY, NK, IAKN,
NACT, IACT, PAR, ITAU, ITHETA, MODE, SS, G, RG, +LOWER, IUPPER, INDX, FT,
WFT, FTNEG, WY1, Z, WZ, IW, IAKNW)

\bigskip 

Subroutine L2WPMA implements Algorithm 1 of [2] with certain enhancements
that provide an optimal fit to $\phi $. The calculation starts by calling
subroutine TRIVIA (which is referred to in Section 3) in order to check on
certain trivial cases that may cause termination of the smoothing process
and ends by providing the knots of the spline representation (\ref{1.9}) of
the optimal fit and the associated Lagrange multipliers.

The purpose of each argument of L2WPMA follows. We allow the range of the
data indices be [I1,N] instead of $[1,n]$ and, henceforth, we shall refer to
the formulae of Section 1 by following this convention. All subroutines
referred to in the following list are explained in Section 3.

\bigskip

\textit{INPUT} (they must be set by the user)

I1\qquad \qquad \qquad Integer variable, lower data index, I1=1.

N\qquad \qquad \qquad Integer variable, upper data index, corresponds to $n$%
, N$\geq $I1.

X(I1:N)\qquad\ \ \ \ \ Real array of the abscissae $x_{i}$, $i$%
=I1,I1+1,...,N. The use of X is optional (see, MODEWF below).

F(I1:N)\qquad\ \ \ \ \ Real array of data values $\phi _{i}$, $i$%
=I1,I1+1...,N.

WF(I1:N) \qquad Real array of positive weights $w_{i}$, $i$=I1,I1+1,...N,
where $w_{i}$ is associated with $\phi _{i}$. The use of WF is optional as
we explain in MODEWF below.

MODEWF\qquad Integer variable that specifies the weights WF(.) as follows:

\qquad MODEWF=0 \ Specifying that WF(.) is supplied by the user (the default
value).

\qquad MODEWF=1 \ The components of WF(.) are set to unity by the program,
WF($i$)=1, $i$=I1,I1+1,...,N.

\qquad MODEWF=2 \ The components of WF(.) are set automatically to

\begin{equation}
\text{WF}(i)=\sigma _{i}/\sum_{i=\text{I1}}^{\text{N}}\sigma _{i}\text{, \ \
\ }i=\text{I1},\ldots ,\text{N,}  \label{2.1}
\end{equation}

where

\begin{equation}
\sigma _{i}=\left\{ 
\begin{array}{ll}
1/\nabla x_{i}\text{,} & i=\text{I1}+1,\ldots ,\text{N} \\ 
\left( \sum_{i=\text{I1}+1}^{\text{N}}\sigma _{i}\right) /(\text{N}-\text{I1}%
)\text{,} & i=\text{I1}
\end{array}
\right.  \label{2.2}
\end{equation}

and $\nabla x_{i}=x_{i}-x_{i-1}$.

\qquad MODEWF=3 \ The components of WF(.) are defined as in MODEWF=2, but

\begin{equation}
\sigma _{i}=\left\{ 
\begin{array}{ll}
1/\bigtriangleup x_{i}\text{,} & i=\text{I1},\ldots ,\text{N}-1 \\ 
\left( \sum_{i=\text{I1}}^{\text{N}-1}\sigma _{i}\right) /(\text{N}-\text{I1}%
)\text{,} & i=\text{N}
\end{array}
\right. \text{,}  \label{2.3}
\end{equation}

where $\bigtriangleup x_{i}=x_{i+1}-x_{i}$.

\qquad MODEWF=4 \ The components of WF(.) are set automatically to

\begin{equation}
\text{WF}(i)=\left\{ 
\begin{array}{ll}
\bigtriangleup x_{\text{I1}}/2\text{,} & i=\text{I1} \\ 
(\bigtriangleup x_{i-1}+\bigtriangleup x_{i})/2\text{,} & i=\text{I}%
1+1,\ldots ,\text{N}-1 \\ 
\bigtriangleup x_{\text{N}-1}/2\text{,} & i=\text{N}
\end{array}
\right. \text{.}  \label{2.4}
\end{equation}

\qquad MODEWF=5 \ Only the data values $\phi _{i}$, $i=$I1,I1+1,...,N, are
given. The abscissae are set automatically to X($i$)=$i$, $i$=I1,I1+1,...,N,
and the weights are set automatically to WF($i$)=1, $i$=I1,I1+1,...,N.

KSECTN \qquad Integer variable that specifies the number of monotonic
sections, corresponds to $k$, 1$\leq $KSECTN$\leq $N$-$I1.

IORDER \qquad\ Integer variable, whose default value is IORDER=0 and
specifies that the first monotonic section is increasing. If IORDER=$-1$,
then the first monotonic section is decreasing.

\bigskip

\textit{OUTPUT }

Y(I1:N) \qquad\ \ \ Real array containing an optimal fit to F(.) at the end
of the calculation. It corresponds to vector $y$.

WY(I1:N) \ \ \ \ \ \ Real array containing the weights of the optimal fit at
the end of the calculation.

NK \qquad \qquad\ \ Integer variable that is set to the number of knots of
the spline representation of the optimal fit as follows: If $\omega _{\kappa
}>1$, then NK=$\kappa +1$, otherwise NK=$\kappa $, where $\omega _{\kappa }$
and $\kappa $ are defined just before formula (\ref{1.9}). Therefore its
value is in the range [I1,N].

IAKN(I1:NK) \ Integer array containing the data indices of the knots of the
spline representation of the optimal fit, where we set IAKN(NK)=N, if $%
\omega _{\kappa }>1$ (note that IAKN(NK)=N, whenever $\omega _{\kappa }=1$).
Therefore the knots are $\xi _{i}$ =X(IAKN($i$)), $i$=I1,I1+1,...,NK, where $%
\xi _{1}=x_{1}$ and $\xi _{\text{NK}}=x_{n}$. Similarly, the coefficients in
expression (\ref{1.9}) are $\zeta _{i}$ =Y(IAKN($i$)), $i$=I1,I1+1,...,NK,
where $\zeta _{1}=y_{1}$ and $\zeta _{\text{NK}}=y_{n}$.

NACT \qquad\ \ \ Integer variable, the number of constraints that are
satisfied as equations at the end of the calculation, 0$\leq $NACT$\leq $N$-$%
I1.

IACT(1:NACT) \ Integer array that provides the indices of the constraints
satisfied as equations at termination. It corresponds to set $\mathscr{A}$.

PAR(I1+1:N) \ Real array containing the Lagrange parameters associated with
the constraints that are satisfied as equations by Y(.) at the end of the
calculation. Specifically, these parameters are PAR(IACT($k$)), $k$%
=1,2,...,NACT, and correspond to $\lambda _{k}$, $k\in \mathscr{A}$.

ITAU(0:KSECTN,I1:(N$-$I1+1)/2+1) \ Integer array such that ITAU($m,j$) is
the index of the ($m-1$)th extremum of an optimal fit with $m$ monotonic
sections to the first LOWER($j$) or IUPPER($j$) data, where 1$\leq m\leq $%
KSECTN, I1$\leq j\leq $(N$-$I1+1)$/2$ $+1$, and the arrays LOWER and IUPPER
are defined in the ''working space'' section below. ITAU($m,j$) corresponds
to $\tau (m,j)$.

ITHETA(0:KSECTN) \ Integer array that holds the values of the sequence $%
\vartheta (.)$ employed in formulae (\ref{1.6}). At the end of the
calculation ITHETA holds the optimal values of the integer variables \{$%
t_{j}:j=0,1,\ldots ,$KSECTN\}.

MODE \ \qquad Integer variable indicating the status of subroutine
termination as follows:

\qquad MODE=0\qquad Unsuccessful return of L2WPMA, because KSECTN, the
number of monotonic sections, is smaller than one.

\qquad MODE=1\qquad Successful return of L2WPMA.

\qquad MODE=2\qquad Successful return of L2WPMA due to $|\mathscr{U}|+|%
\mathscr{L}|\leq $KSECTN$+1$. The data itself provides the required optimal
fit.

\bigskip

\textit{WORKING SPACE}

SS(I1:N)\qquad Real array, argument of subroutine L2WMON (see Section 3),
that keeps either the values \{$\alpha (p,j):j=p,p+1,\ldots ,q$\} or the
values \{$\beta (j,q):j=p,p+1,\ldots ,q$\} as they are defined by formulae (%
\ref{1.4}) and (\ref{1.5}). SS(N) contains the value of the objective
function (\ref{1.1}) at the end of the calculation.

G(0:KSECTN,I1:(N$-$I1+1)/2+1) \ Real array that keeps in G($m,j$) the
weighted sum of squares of residuals of the fit associated with ITAU($m,j$).
G(.,.) is defined in Section 1.

RG(I1:(N$-$I1+1)/2+1) \ Real array that provides temporary storage for the
sum included in the brackets of formula (\ref{1.6}).

LOWER(I1:(N$-$I1+1)/2+1) \ Integer array that keeps the indices of the local
minima of F(.) denoted by $L$ in Section 1. It is formed by subroutine
XTREMA (see Section 3).

IUPPER(I1:(N$-$I1+1)/2+1) \ Integer array that keeps the indices of the
local maxima of F(.) denoted by $U$ in Section 1. It is formed by subroutine
XTREMA.

INDX(I1:N) \ Integer array that gives the data index of a local minimum or a
local maximum of F(.), such that INDX(LOWER($i$))=$i$ and INDX(IUPPER($i$))=$%
i$.

FT(I1:N), WFT(I1:N), FTNEG(I1:N), WY1(I1:N) \ Real arrays that are explained
in the comments of subroutine L2WPMA.

Z(1:N$-$I1+1), WZ(1:N$-$I1+1), IW(1:N$-$I1+1), IAKNW(1,N$-$I1+1) \ Arrays
that provide working space for subroutine L2WMON.

\bigskip

Subroutine L2WPMA is a finite procedure. Unsuccessful return (MODE=0) is
caused only if KSECTN\TEXTsymbol{<}$1$. Otherwise its return is successful,
Y(.) satisfies the constraints (\ref{1.2}), ITHETA(.) satisfies the
conditions (\ref{1.3}) and MODE is set to 1 or 2. The termination status is
explained by certain messages.

The data may be weighted in one of five ways depending on the value assigned
to MODEWF. When each data point $(x_{i},\phi _{i})$ consists of an average
of K, say, observations at $x_{i}$, one may wish to set the weight value of
this point to the inverse square of the standard deviation of these K
observations, in which case MODEWF has to be set to 0. If the weights are
equal to 1, then we set MODEWF=1 and the user need only supply X and F. When
we set MODEWF=2, the weights are defined by (\ref{2.1}) automatically so as
to reflect possible differences in the abscissae spacing. Specifically, the
closer is X($i$) to X($i-1$), the larger is the value we assign to the
weight WF($i$), according to formulae (\ref{2.1}). Moreover, in order to
define WF(I1) we require that the weights are normalized so that their sum
equals 1. Similarly for the case MODEWF=3, but formula (\ref{2.3}) is used
instead of (\ref{2.2}). If the abscissae are equally spaced, then the
options MODEWF=2 and MODEWF=3 imply WF($i$)=1/(N$-$I1+1), $i$=I1,I1+1,...,N,
and the value of (\ref{1.1}) gives an estimator of the variance of the
population that provided the sample $\phi _{i}$, $i$=I1,I1+1,...,N. Further,
since the length of [X($i-1$),X($i$)] is a measure of our information over
the interval, a typical choice of weights (see [1: p.220]) is provided by
formulae (\ref{2.4}) that is activated by setting MODEWF=4. Finally, if only
the data values $\phi _{i}$, $i$=I1,I1+1,...,N, are available, where we
assume that they have been derived with the natural order \{I1,I1+1,...,N\},
then X and WF are defined automatically by setting MODEWF=5.

\section{The purpose of the subroutines}

The Fortran software for the calculation described by [3] consists of five
subroutines. Common blocks and private array storage are avoided. The
working space is directed through the argument list of each subroutine.

Single and double precision versions have been developed for practical use.
All subroutines begin with comments that explain the input and output
arguments, the working space and the method followed. The entire code
consists of 1455 Fortran 77 lines including comments. The number of lines of
code for each subroutine is: L2WPMA 740, TRIVIA 183, XTREMA 137, L2WMON 250
and MESSGW 145. The purpose of each subroutine is as follows.

\textit{Subroutine L2WPMA\qquad }Interface to the user. Given I1, N, X(.),
F(.), WF(.) and KSECTN, it calculates a best weighted least squares
approximation Y(.) to F(.) as outlined in [3]. The use of X and WF is
optional. In addition, the user may specify the order of the first monotonic
section and may allow WF to be calculated automatically from the abscissae
spacing. The underlying method is described by [2], except that L2WPMA
employs weights and at the end of the calculation it provides the knots of
the spline representation (\ref{1.9}) of the solution and the corresponding
Lagrange multipliers. It calls subroutines TRIVIA, XTREMA, L2WMON and
MESSGW. The complexity of L2WPMA is $O(n|\mathscr{U}|+k|\mathscr{U}|^{2})$,
when $k\geq 3$, where $n$ is the number of data points and $|\mathscr{U}|$
is the number of the local maxima of the data, which is always bounded by $%
n/2$. This complexity reduces to $O(n)$ when $k=1$ or $k=2$.

\textit{Subroutine TRIVIA\qquad }In the beginning of subroutine L2WPMA,
subroutine TRIVIA is called to check on the following trivial cases. If
KSECTN$<1$ then a MODE=0 return of L2WPMA is caused. If KSECTN=$1$ then
TRIVIA returns to subroutine L2WPMA and subroutine L2WMON is called to
calculate the best monotonic increasing or decreasing approximation to the
data. If KSECTN$\geq $1 and N=I1 or F(I1)$\leq $F(I1+1)$\leq \cdots \leq $%
F(N) or F(I1)$\geq $F(I1+1)$\geq \cdots \geq $F(N) then the data satisfies
the constraints, thus it is the required optimal approximation, and on
return to subroutine L2WPMA termination occurs. The complexity of subroutine
TRIVIA is $O(n)$, where $n$ is the number of data.

\textit{Subroutine L2WMON\qquad }Given F(.), WF(.) and integers L1 and LN
such that I1$\leq $L1$\leq $LN$\leq $N, subroutine L2WMON calculates the
values $\alpha $(L1,$i$), $i$=L1,L1+1,..., LN, where $\alpha $(.,.) is
defined by (\ref{1.4}). The return of the solution components that occur in $%
\alpha $(L1,LN) depends on a flag, whose value is set by the calling
subroutine L2WPMA. L2WMON for this calculation implements a modification of
Algorithm 1 of [4] that allows a weight to each $\phi _{i}$. Its complexity
is $O(n)$, where $n$=LN$-$L1+1. The values $\beta $($i$,LN), $i$%
=L1,L1+1,...,LN, defined by formula (\ref{1.5}), can be calculated by
applying L2WMON to the data FT($i$), $i$=L1,L1+1,...,LN, associated with the
weights WFT($i$), $i$=L1,l1+1,...,LN, where FT and WFT are arrays that keep
the elements of F and WF in reverse order. Furthermore, L2WMON, together
with the monotonic components that occur at $\alpha $(L1,LN), provides the
knots of the corresponding spline representation and the Lagrange
multipliers associated with the solution.

\textit{Subroutine XTREMA\qquad }It forms the sets $\mathscr{L}$ and $%
\mathscr{U}$, LOWER and IUPPER respectively, that hold the indices of the
local minima and the indices of the local maxima of the data \{$\phi _{i}$: $%
i$=I1,I1+1,...,N\} as described by [4]. Its complexity is $O(n)$, where $n$
is the number of the data.

\textit{Subroutine MESSGW\qquad }It contains certain messages associated
with the operation of subroutines L2WPMA and TRIVIA.

\section{Output from a test example}

This section presents an example of the use of the package L2WPMA. The
calculations were performed on a personal computer with an Intel 733 MHz
processor (32 bits word length), operating with MS Windows 98 and using the
Compaq Visual FORTRAN 6.1 compiler in single precision arithmetic. A simple
driver program of L2WPMA uses I1=1, N=14, \{$(x_{i},\phi _{i}):i=1,2,...,N$%
\}, where \{$x_{i}=i:i=1,2,...,N$\}, $\phi _{1}=-0.1$, $\phi _{2}=0.71$, $%
\phi _{3}=0.69$, $\phi _{4}=0.87$, $\phi _{5}=-1$, $\phi _{6}=-1.11$, $\phi
_{7}=\phi _{8}=1$, $\phi _{9}=\phi _{10}=-1$, $\phi _{11}=0.68$, $\phi
_{12}=0.73$, $\phi _{13}=0.70$ and $\phi _{14}=0.50$, and \{$%
w_{i}=1:i=1,2,...,N$\}. We applied the driver program by requiring KSECTN=4
monotonic sections and L2WPMA carried out the calculation terminating with
the output displayed in Fig. 1. Due to the (even) value of KSECTN, the
computer program formed the sets $\mathscr{L}=\{1,3,6,9,14\}$ and $%
\mathscr{U}=\{2,4,7,12\}$, while at termination, the KSECTN$\times $%
\TEXTsymbol{\vert}$\mathscr{U}$\TEXTsymbol{\vert} array $\tau $=ITAU is 
\begin{equation}
\tau =\left( 
\begin{array}{lllll}
1 & 1 & 1 & 1 & 0 \\ 
1 & 2 & 4 & 7 & 7 \\ 
1 & 3 & 6 & 9 & 0 \\ 
0 & 0 & 0 & 0 & 7
\end{array}
\right)  \label{4.1}
\end{equation}

The integers $t_{i}$=ITHETA($i$), $i=0,1,\ldots ,$KSECTN, presented in Fig.
1, are derived by combining (\ref{1.7}) and (\ref{4.1})\ as follows.
Initially, we have $t_{4}=14$, which is the 5th element of $\mathscr{L}$. In
view of (\ref{1.7}), we obtain $t_{3}=\tau (4,5)=7$, which is the 3rd
element of $\mathscr{U}$, and subsequently $t_{2}=\tau (3,3)=6$, which is
the 3rd element of $\mathscr{L}$, $t_{1}=\tau (2,3)=4$, which is the 2nd
element of $\mathscr{U}$, and finally $t_{0}=\tau (1,2)=1$. Associated with
the $t_{i}$s, let $y\in \Bbb{R}^{14}$ be the fit to $\phi $ that has $k=4$
monotonic sections, whose components are shown in the column labeled '(Y)'
in Fig. 1. We see that $y_{i}$, $i=1,2,...,14$, satisfy the constraints $%
y_{1}\leq y_{2}\leq y_{3}\leq y_{4}$, $y_{4}\geq y_{5}\geq y_{6}$, $%
y_{6}\leq y_{7}$ and $y_{7}\geq y_{8}\geq \cdots \geq y_{14}$, and we are
going to prove that $y$ does minimize (\ref{1.1}) subject to these
constraints. Indeed, first due to formula (\ref{1.8}), we obtain the
identities $2w_{1}(y_{1}-\phi _{1})=-\lambda _{2}$, $2w_{2}(y_{2}-\phi
_{2})=\lambda _{2}-\lambda _{3},\ldots ,2w_{13}(y_{13}-\phi _{13})=\lambda
_{14}-\lambda _{13}$ and $2w_{14}(y_{14}-\phi _{14})=\lambda _{14}$. Then,
in view of the values (see column labeled 'Y' in Fig. 1) $y_{1}$ =$\phi _{1}$%
, $y_{2}=y_{3}=0.7$, $y_{i}=\phi _{i}$, for $i=4,5,\ldots ,8$, and $%
y_{9}=y_{10}=\cdots =y_{14}=0.1017$, it is straightforward to verify (the
actual formulae are presented in Section 2 of [3]) that the numbers shown in
the column labeled '(PAR)' in Fig. 1 are the Lagrange multipliers $\lambda
_{2}=0$, $\lambda _{3}=0.02$, $\lambda _{i}=0$, for $i=4,5,\ldots ,8$, $%
\lambda _{10}=-2.20$, $\lambda _{11}=-4.41$, $\lambda _{12}=-3.25$, $\lambda
_{13}=-1.99$ and $\lambda _{14}=-0.80$. Because $\lambda _{i}\geq 0$, for $%
i\in \lbrack 2,t_{1}]\cup \lbrack t_{2}+1,t_{3}]$, and $\lambda _{i}\leq 0$,
for $i\in \lbrack t_{1}+1,t_{2}]\cup \lbrack t_{3}+1,14]$, the
Karush-Kuhn-Tucker conditions for the solution of the quadratic programming
problem stated above are satisfied.

Next, we applied the driver program to the same data as those in Fig. 1 for
KSECTN=1,2,..., and the corresponding smoothed values are presented in Table
1 under the headings $k=1,k=2,\ldots ,k\geq 8$. The first three columns of
Table 1 present the vectors $x$, $\phi $ and $w$, while the last row gives
the value of the objective function (\ref{1.1}) at each approximation.
Certain features of the optimal approximation are demonstrated by this
example. They are that as $k$ increases, most of the extrema of the fits are
preserved, the ranges of constant components are reduced, some monotonic
sections may degenerate to a single point (as when $k=7$, where the
corresponding approximation consists of 6 monotonic sections) and $\phi $ is
the optimal fit whenever KSECTN$\geq $8, because $\phi $ satisfies the
constraints.

Table 2 presents output from an experiment similar to that in Table 1,
except that the abscissae take the nonuniformly spaced values of column 2.
We applied the driver program with MODEWF=2 and the weights presented in
column 4 were generated automatically due to (\ref{2.1}) giving
WF(1)=0.0714, WF(2)=0.0116 and so on up to WF(14)=0.7244. First we see that
the best weighted approximations of Table 2 exhibit features broadly similar
to the approximations in Table 1. In particular, let $y\in \Bbb{R}^{n}$ be
the best weighted approximation when $k=4$ in Table 2, which is associated
with $t_{1}=7,t_{2}=9$ and $t_{3}=12$, obtained from

\begin{equation}
\tau =\left( 
\begin{array}{r}
\begin{array}{lllll}
1 & 1 & 1 & 1 & \text{ }0 \\ 
1 & 2 & 4 & 7 & 12 \\ 
1 & 3 & 6 & 9 & \text{ }0 \\ 
0 & 0 & 0 & 0 & \text{ }7
\end{array}
\end{array}
\right)  \label{4.2}
\end{equation}
by analogy with (\ref{4.1}). Consequently the components of $y$ satisfy the
constraints $y_{1}\leq y_{2}\leq \cdots \leq y_{7}$, $y_{7}\geq y_{8}\geq
y_{9}$, $y_{9}\leq y_{10}$ $\leq y_{11}\leq y_{12}$ and $y_{12}\geq
y_{13}\geq y_{14}$, and by arguments similar to those in the paragraph
following (\ref{4.1}), we can show that the values $y_{1}=y_{2}=\cdots
=y_{6}=-0.1298$ and $y_{i}=\phi _{i},i=7,8,\ldots ,14$, minimize (\ref{1.1})
subject to these constraints. Indeed, it is straightforward to verify that (%
\ref{1.8}) is satisfied with $\lambda _{2}=0.0043,\lambda
_{3}=0.0237,\lambda _{4}=0.0292,\lambda _{5}=0.0463,\lambda _{6}=0.0067$,
and $\lambda _{i}=0,i=7,8,\ldots ,14$ and since $\lambda _{i}\geq 0$, $i\in
\lbrack 2,t_{1}]\cup \lbrack t_{2}+1,t_{3}],$ and $\lambda _{i}\leq 0$, $%
i\in \lbrack t_{1}+1,t_{2}]\cup \lbrack t_{3}+1,14]$, the Karush-Kuhn-Tucker
conditions for the solution of this quadratic programming problem are
satisfied. We conclude that the differences between the corresponding
approximations of Tables 1 and 2 are the result of the use of the weights.

Figs 2 and 3 illustrate the best approximations obtained by applying
subroutine L2WPMA to certain data sets. Fig. 2 presents an optimal fit with $%
k=6$ monotonic sections, which may be viewed as the result of an
intermediate step of a calculation that may further improve the fit. Here, a
disadvantage of the smoothing technique is shown at the rightmost monotonic
section of this fit, where the data errors are too small to be detected by
the first differences. Further, the particular $k$ of Fig. 3 allows L2WPMA
to achieve the piecewise monotonicity property it sets out to achieve and,
generally, any degree of undulation in the data can be accommodated by
choosing a suitable $k$.

\[
\text{\TEXTsymbol{<}Tables 1 and 2 and Figs 1, 2 and 3 belong to this section%
\TEXTsymbol{>}}
\]

\section{Documentation}

Distribution material that includes single and double precision versions of
the code, driver programs, numerical examples with output in order to help
new users of the method and documentation is available in ASCII form
accompanying [3].

The documentation, namely file INSTDE04.txt of the distribution material,
includes description of the driver programs, comments on the output of
several test examples that help the usage of L2WPMA, provides technical
details about installation, compilation, linking, running and testing of the
Fortran codes, and remarks on the Fortran listings.\bigskip

\textsc{REFERENCES}

[1] DE BOOR C. 2001. \emph{A Practical Guide to Splines. Revised Edition}.
Springer-Verlag, Applied Mathematical Sciences, Vol. 27, NY.

[2] DEMETRIOU I.C. 1995. Discrete piecewise monotonic approximation by a
strictly convex distance function. \emph{Mathematics of Computation}, Vol.
64, No 209, pp. 157-180.

[3] DEMETRIOU I.C. 2006. ALgorithm XXX: L2WPMA, a Fortran 77 Package for
Weighted Least Squares Piecewise Monotonic Data Approximation. To appear in 
\emph{ACM Transactions on Mathematical Software}.

[4] DEMETRIOU I.C. AND POWELL M.J.D. 1991. Least squares smoothing of
univariate data to achieve piecewise monotonicity. \emph{IMA J. of Numer.
Anal.}, Vol. 11, No 3, pp. 411-432.

\begin{received}
Received Month Year; revised Month Year; accepted Month Year
\end{received}

\end{document}
