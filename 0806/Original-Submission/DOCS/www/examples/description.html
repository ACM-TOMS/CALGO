<HTML>
<HEAD>
<TITLE> SPRNG: Scalable Parallel Pseudo-Random Number Generator Library </TITLE> 
</HEAD> 
<BODY BGCOLOR="#FFFFFF">

<H1 ALIGN=CENTER> Examples </H1>
<P>

<A NAME="simple"></A>
<H2>1. <SAMP>simple</SAMP></H2>
This program demonstrates the use of
<SAMP>sprng</SAMP> on one  processor without explicit initialization.

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG <A
HREF="../definitions.html#header"><EM>header file</EM></A>  We
have also <A HREF="../macros.html">defined</A> the <A
HREF="../definitions.html#macros"><EM>macro</EM></A>
<SAMP>SIMPLE_SPRNG</SAMP> before including the SPRNG header file in
order to invoke the simple interface.

<P>
When <SAMP>sprng</SAMP> is called the first time, it initializes a
default stream using default parameters, since no explicit
initialization has been performed. It then returns double precision random
numbers in [0,1).


<P>
<B>Code</B>:
<P ALIGN=CENTER>

<TABLE BORDER=5 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=2>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH WIDTH=50><A HREF="simple-simple.c">C</A></TH>
<TH><A HREF="simplef-simple.F">FORTRAN</A></TH>
<TH COLSPAN=2><EM>Not Available</EM></TH>
</TR>

</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD>
 cc -64  -I../include -o simple-simple simple-simple.c -L../lib -llcg
 </KBD><P>
Note: <KBD>-64</KBD> indicates the 64 bit compilation available on the
Power Challenge.
<DD><KBD>cc</KBD> is the C compiler.
<P>
<B>Output:</B>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% simple-simple
 Printing 3 random numbers in [0,1):
0.580114
0.740295
0.892874
</PRE>
</SAMP>

<HR>


<P><A NAME="sprng"></A>
<H2>2. <SAMP>sprng</SAMP></H2>
This program demonstrates the use of <SAMP>sprng</SAMP>,
<SAMP>isprng</SAMP>, <SAMP>init_sprng</SAMP> and <SAMP>print_sprng</SAMP>
 on one  process.

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG <A
HREF="../definitions.html#header"><EM>header file</EM></A>. 

<P>
 First we initialize a random number stream. The value of the <A
HREF="../definitions.html#seed"><EM>seed</EM></A> is defined to be
<SAMP>985456376</SAMP>.  We call
<SAMP>print_sprng</SAMP> immediately after initialization so that we
can record the particular stream we obtained, for later reference.

<P>
<SAMP>sprng</SAMP> is next called to return double precision random
numbers in [0,1) and then <SAMP>isprng</SAMP> is called to return random
integers in [0,2<SUP>31</SUP>).

 
<P>
<B>Code</B>:
<P ALIGN=CENTER>

<TABLE BORDER=5 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=3>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH WIDTH=50><A HREF="sprng-simple.c">C</A></TH>
<TH><A HREF="sprngf-simple.F">FORTRAN</A></TH>
<TH WIDTH=50><A HREF="sprng.c">C</A></TH>
<TH WIDTH=50><A HREF="sprng.C">C++</A></TH>
<TH><A HREF="sprngf.F">FORTRAN</A></TH>
</TR>

</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD>f77  -DPOINTER_SIZE=8  -64 -I../include -o sprngf  sprngf.F -L../lib -llcg
 </KBD><P>
Note: <KBD>-DPOINTER_SIZE=8</KBD> indicates that the pointer size is 8
bytes, rather than the default 4 bytes assumed by SPRNG.<BR>
<DD><KBD>f77</KBD> is the FORTRAN 77 compiler.
<P>
<B>Output:</B>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% sprngf
 Print information about new stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863279
        multiplier = 44485709377909

 Printing 3 random numbers in [0,1):
0.707488
0.664048
0.005616
 Printing 3 random integers in [0,2^31):
      1873949618
      1484742006
       602016304
</PRE>
</SAMP>

<HR>


<P>
<A NAME="sprng_mpi"></A>
<H2>3. <SAMP>sprng_mpi</SAMP></H2>
This program demonstrates the use of <SAMP>sprng</SAMP>
 with multiple
 processes.

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG and
MPI <A
HREF="../definitions.html#header"><EM>header files</EM></A> at the beginning. 


<P>
First we initialize MPI.

<P>
 We then initialize a random number stream. The value of the <A
HREF="../definitions.html#seed"><EM>seed</EM></A> is defined to be
<SAMP>985456376</SAMP>.  We call
<SAMP>print_sprng</SAMP> immediately after initialization so that we
can record the particular stream we obtained, for later reference.

<P>
<SAMP>sprng</SAMP> is next called to return double precision random
numbers in [0,1).


<P>
<B>Code</B>:
<P ALIGN=CENTER>

<TABLE BORDER=5 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=3>Simple Interface</TH>
<TH COLSPAN=2>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH WIDTH=50><A HREF="sprng-simple_mpi.c">C</A></TH>
<TH WIDTH=50><A HREF="sprng-simple_mpi.C">C++</A></TH>
<TH><A HREF="sprngf-simple_mpi.F">FORTRAN</A></TH>
<TH WIDTH=50><A HREF="sprng_mpi.c">C</A></TH>
<TH><A HREF="sprngf_mpi.F">FORTRAN</A></TH>
</TR>

</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD>CC -64    -I../include -o sprng-simple_mpi sprng-simple_mpi.C -L../lib -llcg -L/usr/lib64 -lmpi </KBD><P> 
Note: <KBD>CC</KBD> is the C++ compiler.
<P>
<B>Output:</B>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% mpirun -np 2 sprng-simple_mpi
Process 0, print information about stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863279
        multiplier = 44485709377909

Process 0, random number 1: 0.70748766363408
Process 0, random number 2: 0.66404841879710
Process 0, random number 3: 0.00561565119362
Process 1, print information about stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863259
        multiplier = 44485709377909

Process 1, random number 1: 0.99144237784703
Process 1, random number 2: 0.15098918187292
Process 1, random number 3: 0.09757740755008
</PRE>
</SAMP>
<P>
Note that the order in which the output is printed may differ.

<P>
<HR>


<P>
<A NAME="fsprng_mpi"></A>
<H2>4. <SAMP>fsprng_mpi</SAMP></H2>
This program demonstrates the use of the single precision
version of <SAMP>sprng</SAMP>
 with one <A HREF="../definitions.html#stream"><EM>stream</EM></A> per
 process.

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG and
MPI <A
HREF="../definitions.html#header"><EM>header files</EM></A> <A
HREF="../sprng.html#sprng"><SAMP>sprng.h</SAMP></A> and
<SAMP>mpi.h</SAMP> respectively at the beginning. Before including the
SPRNG header file, we have <A HREF="../macros.html">defined</A> the <A
HREF="../definitions.html#macros"><EM>macro</EM></A>
<SAMP>FLOAT_GEN</SAMP>, which results in single precision random
numbers being
generated by calls to <SAMP>sprng</SAMP>. 


<P>
First we initialize MPI.

<P>
 We then initialize a random number stream. The value of the <A
HREF="../definitions.html#seed"><EM>seed</EM></A> is defined to be
<SAMP>985456376</SAMP>.  We call
<SAMP>print_sprng</SAMP> immediately after initialization so that we
can record the particular stream we obtained, for later reference.

<P>
<SAMP>sprng</SAMP> is next called to return single precision random
numbers in [0,1).


<P>
<B>Code</B>:
<P ALIGN=CENTER>

<TABLE BORDER=5 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=2>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH WIDTH=50><A HREF="fsprng-simple_mpi.c">C</A></TH>
<TH><A HREF="fsprngf-simple_mpi.F">FORTRAN</A></TH>
<TH WIDTH=50><A HREF="fsprng_mpi.c">C</A></TH>
<TH><A HREF="fsprngf_mpi.F">FORTRAN</A></TH>
</TR>

</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD> f90  -DPOINTER_SIZE=8  -64 -I../include -o fsprngf_mpi  fsprngf_mpi.F -L../lib -llcg -L/usr/lib64 -lmpi </KBD><P> 
Note: <KBD>f90</KBD> is the FORTRAN 90 compiler.
<P>
<B>Output:</B>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% mpirun -np 2 fsprngf_mpi
Process 0: Print information about stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863279
        multiplier = 44485709377909

Process 0, random number 1: 0.707488
Process 0, random number 2: 0.664048
Process 0, random number 3: 0.005616
Process 1: Print information about stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863259
        multiplier = 44485709377909

Process 1, random number 1: 0.991442
Process 1, random number 2: 0.150989
Process 1, random number 3: 0.097577
</PRE>
</SAMP>

<P>
<P>
Note that the order in which the output is printed may differ.

<P>
<HR>


<A NAME="seed"></A>
<H2>5. <SAMP>seed</SAMP></H2>
This program demonstrates the use of <SAMP>make_sprng_seed</SAMP> on one
 processor.

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG <A
HREF="../definitions.html#header"><EM>header file</EM></A> at the beginning. 


<P>
 First we initialize a random number stream. The value of a <A
HREF="../definitions.html#seed"><EM>seed</EM></A> is obtained from a call
to
<SAMP>make_sprng_seed</SAMP> and is based on system date and time information.  We call
<SAMP>print_sprng</SAMP> immediately after initialization so that we
can record the particular stream we obtained, for later reference.

<P>
<SAMP>sprng</SAMP> is next called to return double precision random
numbers in [0,1).


<P>
<B>Code</B>:
<P ALIGN=CENTER>

<TABLE BORDER=1 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=2>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH WIDTH=50><A HREF="seed-simple.c">C</A></TH>
<TH><A HREF="seedf-simple.F">FORTRAN</A></TH>
<TH WIDTH=50><A HREF="seed.c">C</A></TH>
<TH><A HREF="seedf.F">FORTRAN</A></TH>
</TR>

</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD>cc -64  -I../include -o seed-simple seed-simple.c -L../lib -llcg </KBD><P> 
<B>Output:</B>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% seed-simple
 Printing information about new stream

Linear Congruential Generator

        seed = 178783069, prime = 11863279
        multiplier = 44485709377909

 Printing 3 random numbers in [0,1):
0.856970
0.110647
0.795213

</PRE>
</SAMP>

<P>
<HR>


<P>
<A NAME="seed_mpi"></A>
<H2>6. <SAMP>seed_mpi</SAMP></H2>
This program demonstrates the use of 
 <SAMP>make_sprng_seed</SAMP> with the <A
 HREF="../message-passing.html#mpi">MPI</A> version of SPRNG in order to
 obtain the same <A HREF="../definitions.html#seed"><EM>seed</EM></A> in
 each process.

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG and
MPI <A
HREF="../definitions.html#header"><EM>header files</EM></A> at the beginning. Before including the
SPRNG header file, we have <A HREF="../macros.html">defined</A> the <A
HREF="../definitions.html#macros"><EM>macro</EM></A>
<SAMP>USE_MPI</SAMP>, which enables SPRNG to make MPI calls to ensure
that the same seed is obtained on each process. 


<P>
First we initialize MPI.

<P>
 We then initialize a random number stream. The value of the <A
HREF="../definitions.html#seed"><EM>seed</EM></A> is obtained from a call
to 
<SAMP>make_sprng_seed</SAMP>. This function makes MPI calls to ensure
that the same seed is returned in each process, assuming that the MPI
version of SPRNG has been installed.  We call
<SAMP>print_sprng</SAMP> immediately after initialization so that we
can record the particular stream we obtained, for later reference.

<P>
<SAMP>sprng</SAMP> is next called to return double precision random
numbers in [0,1).

<P>
<B>Code</B>:
<P ALIGN=CENTER>

<TABLE BORDER=1 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=2>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH WIDTH=50><A HREF="seed-simple_mpi.c">C</A></TH>
<TH><A HREF="seedf-simple_mpi.F">FORTRAN</A></TH>
<TH WIDTH=50><A HREF="seed_mpi.c">C</A></TH>
<TH><A HREF="seedf_mpi.F">FORTRAN</A></TH>
</TR>

</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD> cc -64    -I../include -o seed-simple_mpi seed-simple_mpi.c -L../lib -llcg -L/usr/lib64 -lmpi </KBD><P> 
<B>Output:</B>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% mpirun -np 2 seed-simple_mpi
Process 0: seed =        837321565
Process 1: seed =        837321565
Process 0: Print information about stream:

Linear Congruential Generator

        seed = 837321565, prime = 11863279
        multiplier = 44485709377909

process 0, random number 1: 0.732603
process 0, random number 2: 0.753095
process 0, random number 3: 0.084726
Process 1: Print information about stream:

Linear Congruential Generator

        seed = 837321565, prime = 11863259
        multiplier = 44485709377909

process 1, random number 1: 0.200456
process 1, random number 2: 0.445652
process 1, random number 3: 0.576297
</PRE>
</SAMP>
<P>
Note that the order in which the output is printed may differ.

<P>

<A NAME="checkpoint"></A>
<H2>7. <SAMP>checkpoint</SAMP></H2>
This program demonstrates the use of
<SAMP>pack_sprng</SAMP> and <SAMP>unpack_sprng</SAMP> for
<A HREF="../definitions.html#checkpoint">check-pointing</A>. This
program prints a few random numbers and then stores the state of the
computation in a file. If users wish to continue their computations
from the previous state, then they can have this program read the
state of the computations from this file. The user is first prompted
for the name of the output file. Then the user is asked for the name
of the input file. If the user wishes to start a new run, then he
should enter <KCD>9</KBD> at this stage, in which case the program
initializes a 
random number stream instead of reading it from a file. 

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG <A
HREF="../definitions.html#header"><EM>header file</EM></A> <A
HREF="../sprng.html#sprng"><SAMP>sprng.h</SAMP></A> at the beginning.


<P>
 First we initialize a random number stream, if this is a new run. The value of the <A
HREF="../definitions.html#seed"><EM>seed</EM></A> is defined to be
<SAMP>985456376</SAMP>.  We call
<SAMP>print_sprng</SAMP> immediately after initialization so that we
can record the particular stream we obtained, for later reference.

<P>
If this is the continuation of a previous run, then we read in the state
of a stream from the input file, and unpack it to obtain a random
number stream.

<P>
<SAMP>sprng</SAMP> is next called to return double precision random
numbers in [0,1).

<P>

<P>
Finally, we pack the state of the stream into an array and store the
contents of this array into the output file.

<P>
<B>Code</B>:
<P ALIGN=CENTER>

<TABLE BORDER=1 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=2>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH WIDTH=50><A HREF="checkpoint-simple.c">C</A></TH>
<TH><A HREF="checkpointf-simple.F">FORTRAN</A></TH>
<TH WIDTH=50><A HREF="checkpoint.c">C</A></TH>
<TH><A HREF="checkpointf.F">FORTRAN</A></TH>
</TR>

</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD>cc -64  -I../include -o checkpoint-simple checkpoint-simple.c -L../lib -llcg </KBD><P> 
<B>Output:</B>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% checkpoint
Enter name of file to store final state of the stream:
<B>temp</B>
Enter name of file to read from:
        (enter 9 for a new run)
<B>9</B>
 Printing 5 random numbers in [0,1): 
1  0.707488
2  0.664048
3  0.005616
4  0.872626
5  0.691387
sprng/EXAMPLES:sif% checkpoint
Enter name of file to store final state of the stream:
<B>temp</B>
Enter name of file to read from:
        (enter 9 for a new run)
<B>temp</B>
 Printing 5 random numbers in [0,1): 
1  0.280336
2  0.005228
3  0.533545
4  0.710482
5  0.891603

</PRE>
</SAMP>

<P>
<HR>


<P>
<A NAME="message_mpi"></A>
<H2>8. <SAMP>message_mpi</SAMP></H2>
This program demonstrates the use of
<SAMP>pack_sprng</SAMP> and <SAMP>unpack_sprng</SAMP>
 for passing the state of a stream from one processor to another.

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG and
MPI <A
HREF="../definitions.html#header"><EM>header files</EM></A> at the beginning. 


<P>
First we initialize MPI.

<P>
 We then initialize a random number stream on process <SAMP>0</SAMP>. The value of the <A
HREF="../definitions.html#seed"><EM>seed</EM></A> is defined to be
<SAMP>985456376</SAMP>. We call
<SAMP>print_sprng</SAMP> immediately after initialization so that we
can record the particular stream we obtained, for later reference.

<P>
<SAMP>sprng</SAMP> is next called by process 0 to return double precision random
numbers in [0,1).

<P>
Process 0 then packs the state of the stream into an array and sends it
to process 1, which unpacks it and prints a few more random numbers
from that stream. In this process, the original default stream on
process 1 is over-written by the unpacked stream.


<P>
<B>Code</B>:
<P ALIGN=CENTER>

<TABLE BORDER=1 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=2>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH WIDTH=50><A HREF="message-simple_mpi.c">C</A></TH>
<TH><A HREF="messagef-simple_mpi.F">FORTRAN</A></TH>
<TH WIDTH=50><A HREF="message_mpi.c">C</A></TH>
<TH><A HREF="messagef_mpi.F">FORTRAN</A></TH>
</TR>

</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD>cc -64    -I../include -o message-simple_mpi message-simple_mpi.c -L../lib -llcg -L/usr/lib64 -lmpi </KBD><P> 
<B>Output:</B>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% mpirun -np 2 message-simple_mpi
Process 0: Print information about stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863279
        multiplier = 44485709377909

Process 0: Print 2 random numbers in [0,1):
Process 0: 0.707488
Process 0: 0.664048
 Process 0 sends stream to process 1
 Process 1 has received the packed stream
Process 1: Print information about stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863279
        multiplier = 44485709377909

 Process 1 prints 2 numbers from received stream:
Process 1: 0.005616
Process 1: 0.872626

</PRE>
</SAMP>
<P>
Note that the order in which the output is printed may differ.


<P>
<HR>

<P>
<A NAME="2streams_mpi"></A>
<H2>9. <SAMP>2streams_mpi</SAMP></H2>
This program demonstrates the use of multiple streams on
each process.

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG and
MPI <A
HREF="../definitions.html#header"><EM>header files</EM></A> at the beginning.


<P>
First we initialize MPI and determine the number of processes and the
rank of the local process.

<P>
 We then initialize a random number stream. The value of the <A
HREF="../definitions.html#seed"><EM>seed</EM></A> is defined to be
<SAMP>985456376</SAMP>. We shall have two streams per process, but
is only one of these streams will be distinct. The other stream will be
identical on each process. This is useful in situations in which we
would like all the processes to take the same decision based on a
random number. Thus the number of distinct streams is one more than
the total number of processor, resulting in <SAMP>nstreams = nprocs +
1</SAMP>. For the distinct stream on each
process, we initialize it with stream number as the rank of the local
process, <SAMP>myid</SAMP>. The common stream is initialized with the
stream number <SAMP>nprocs</SAMP>. 

<P>
<SAMP>sprng</SAMP> is next called for each stream. It returns a double precision random
numbers in [0,1) with the stream ID as its argument.

<P>
Finally, we free the memory used to store the states of the two streams by 
calls to <SAMP>free_sprng</SAMP>.

<P>
<B>Code:</B>
<P>
<TABLE BORDER=1 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=2>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2><EM>Not Available</EM></TH>
<TH WIDTH=50><A HREF="2streams_mpi.c">C</A></TH>
<TH><A HREF="2streamsf_mpi.F">FORTRAN</A></TH>
</TR>

</TABLE>


<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD> cc -64    -I../include -o 2streams_mpi 2streams_mpi.c -L../lib -llcg -L/usr/lib64 -lmpi </KBD>
<P>
<B>Output:</B>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% mpirun -np 2 2streams_mpi
Process 0: Print information about new stream

Linear Congruential Generator

        seed = 985456376, prime = 11863279
        multiplier = 44485709377909

Process 0: This stream is identical on all processes

Linear Congruential Generator

        seed = 985456376, prime = 11863253
        multiplier = 44485709377909

Process 0, random number (distinct stream) 1: 0.707488
Process 0, random number (distinct stream) 2: 0.664048
Process 0, random number (shared stream) 1: 0.700906
Process 0, random number (shared stream) 2: 0.602204
Process 1: Print information about new stream

Linear Congruential Generator

        seed = 985456376, prime = 11863259
        multiplier = 44485709377909

Process 1: This stream is identical on all processes

Linear Congruential Generator

        seed = 985456376, prime = 11863253
        multiplier = 44485709377909

Process 1, random number (distinct stream) 1: 0.991442
Process 1, random number (distinct stream) 2: 0.150989
Process 1, random number (shared stream) 1: 0.700906
Process 1, random number (shared stream) 2: 0.602204

</PRE>
</SAMP>
<P>
Note that the order in which the output is printed may differ.


<P>
<HR>



<P>

<A NAME="spawn"></A>
<H2>10. <SAMP>spawn</SAMP></H2>
This program demonstrates the use of <SAMP>spawn_sprng</SAMP>.

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG <A
HREF="../definitions.html#header"><EM>header file</EM></A>  at the beginning.

<P>
 First we initialize a random number stream. The value of the <A
HREF="../definitions.html#seed"><EM>seed</EM></A> is defined to be
<SAMP>985456376</SAMP>. Since there is only one stream,
the number of streams <SAMP>nstreams = 1</SAMP> and the stream number <SAMP>streamnum =
0</SAMP>. <SAMP>stream</SAMP> stores the returned <A
HREF="../definitions.html#ID"><EM>ID</EM></A> of the initialized stream. We call
<SAMP>print_sprng</SAMP> immediately after initialization so that we
can record the particular stream we obtained, for later reference.

<P>
<SAMP>sprng</SAMP> is next called to return double precision random
numbers in [0,1), with the stream ID as its argument.

<P>
We next spawn two streams from <SAMP>stream</SAMP>. Their <A
HREF="../definitions.html#ID"><EM>ID's</EM></A> are stored in an array
allocated by sprng. The variable <SAMP>new</SAMP> points to this
array. We print information about the newly spawned streams, and then
print a few random numbers from the second stream spawned.

<P>
Finally, we free the memory used to store the states of the streams by 
calls to <SAMP>free_sprng</SAMP>.

<P>
<B>Code:</B>
<P>
<TABLE BORDER=1 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=2>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2><EM>Not Available</EM></TH>
<TH WIDTH=50><A HREF="spawn.c">C</A></TH>
<TH><A HREF="spawnf.F">FORTRAN</A></TH>
</TR>

</TABLE>


<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KDB> cc -64  -I../include -o spawn spawn.c -L../lib -llcg<KDB>

<P>
<B>Output:</B>
<P>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% spawn
 Print information about stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863279
        multiplier = 44485709377909

 Printing 2 random numbers in [0,1):
0.707488
0.664048
 Spawned two streams
 Information on first spawned stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863259
        multiplier = 44485709377909

 Information on second spawned stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863253
        multiplier = 44485709377909

 Printing 2 random numbers from second spawned stream:
0.700906
0.602204
</PRE>
</SAMP>


<P>
<HR>



<P>
<A NAME="invalidid"></A>
<H2>11. <SAMP>invalid_ID</SAMP></H2>
This program demonstrates the handling of invalid pointers in the
interface with pointer checking.

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG <A
HREF="../definitions.html#header"><EM>header file</EM></A> <A
HREF="../sprng.html#sprng"><SAMP>sprng.h</SAMP></A> at the beginning. We
have also <A HREF="../macros.html">defined</A> the <A
HREF="../definitions.html#macros"><EM>macro</EM></A>
<SAMP>CHECK_POINTERS</SAMP> before including the SPRNG header file in
order to invoke the interface with pointer checking.

<P>
 First we initialize a random number stream. The value of the <A
HREF="../definitions.html#seed"><EM>seed</EM></A> is defined to be
<SAMP>985456376</SAMP>. Since there is only one stream,
the number of streams <SAMP>nstreams = 1</SAMP> and the stream number <SAMP>streamnum =
0</SAMP>. <SAMP>stream</SAMP> stores the returned <A
HREF="../definitions.html#ID"><EM>ID</EM></A> of the initialized stream. We call
<SAMP>print_sprng</SAMP> immediately after initialization so that we
can record the particular stream we obtained, for later reference.

<P>
<SAMP>sprng</SAMP> is next called to return double precision random
numbers in [0,1), with the stream ID as its argument.

<P>
Finally, we free the memory used to store the state of the stream by a
call to <SAMP>free_sprng</SAMP>.

<P>
we then try to use the freed stream again, which is an incorrect
usage. <SAMP>sprng</SAMP> returns <SAMP>-1.0</SAMP> due to the invalid
stream being passed as an argument.
<P>
<B>Code:</B>
<P>
<TABLE BORDER=1 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=2>Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2><EM>Not Available</EM></TH>
<TH WIDTH=50><A HREF="invalid_ID.c">C</A></TH>
<TH><A HREF="invalid_IDf.F">FORTRAN</A></TH>
</TR>

</TABLE>


<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KDB> cc -64  -I../include -o invalid_ID invalid_ID.c -L../lib -llcg<KDB>

<P>
<B>Output:</B>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% invalid_ID
Print information about random number stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863279
        multiplier = 44485709377909

Printing 3 random numbers in [0,1):
0.707488
0.664048
0.005616
Expect a SPRNG error message on the use of an invalid stream ID
ERROR: Invalid generator ID 10014ed8
sprng returns -1.000000 on being given an invalid stream ID

</PRE>
</SAMP>

<P>
Note that the incorrect ID, 10017258, may vary.


<P>


<P>
<HR>


<P>
<A NAME="convert"></A>
<H2>12. <SAMP>convert</SAMP></H2>
This program demonstrates converting user code to call SPRNG
instead of the original random number generator <SAMP>myrandom</SAMP>.
<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG <A
HREF="../definitions.html#header"><EM>header file</EM></A>  at the beginning. We
have also <A HREF="../macros.html">defined</A> the <A
HREF="../definitions.html#macros"><EM>macro</EM></A>
<SAMP>SIMPLE_SPRNG</SAMP> before including the SPRNG header file in
order to invoke the simple interface. We define the macro
<SAMP>myrandom</SAMP> to <SAMP>sprng</SAMP> <STRONG>after</SAMP>
including the SPRNG header. This replaces the former function call by
calls to SPRNG instead. 

<P>
 We then add statements to initialize SPRNG.



<P>
<B>Code</B>:
<P>
<TABLE BORDER=1 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=2>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH WIDTH=50><A HREF="convert.c">C</A></TH>
<TH><A HREF="convertf.F">FORTRAN</A></TH>
<TH COLSPAN=2><EM>Not Available</EM></TH>
</TR>

</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD> cc -64    -I../include convert.c -L../lib -llcg </KBD><P>
Note: In the code provided with SPRNG, users need to define the macro
<SAMP>CONVERT</SAMP> in order to get this converted code.
<P>
<B>Output:</B>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% a.out
Print information about random number stream:

Linear Congruential Generator

        seed = 985456376, prime = 11863279
        multiplier = 44485709377909

Printing 3 random numbers in [0,1):
0.707488
0.664048
0.005616

</PRE>
</SAMP>


<P>
<HR>


<P>

<A NAME="subroutine"></A>
<H2>13. <SAMP>subroutine</SAMP></H2>
This program demonstrates the use of SPRNG in
subroutines in FORTRAN programs.

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG <A
HREF="../definitions.html#header"><EM>header file</EM></A> <A
HREF="../sprng.html#sprngf"><SAMP>sprng_f.h</SAMP></A> at the
beginning. We have also included this header file in the subroutine
<SAMP>sub1</SAMP>. If we wished to define a macro for use by SPRNG, we
need only do it once in any file, before the first time a SPRNG
header is included.

<P>
Subroutine <SAMP>sub1</SAMP> is then called, which makes calls to <SAMP>sprng</SAMP>.


<P>
<B>Code:</B>
<P>
<TABLE BORDER=1 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2>Simple Interface</TH>
<TH COLSPAN=2>Default/Pointer<BR> Checking Interface</TH>
</TR>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH COLSPAN=2><EM>Not Available</EM></TH>
<TH><A HREF="subroutinef.F">FORTRAN</A></TH>
</TR>

</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KDB> f77 -64 -I../include -DPOINTER_SIZE=8 subroutinef.F -L../lib -llcg <KDB>

<P>
<B>Output:</B>
<P>
<SAMP>
<PRE>
sprng/EXAMPLES:sif% a.out
 Printing information about new stream

Linear Congruential Generator

        seed = 985456376, prime = 11863279
        multiplier = 44485709377909

 Printing 3 double precision numbers in [0,1): 
     1   0.7074876636340832
     2   0.6640484187971047
     3   0.0056156511936152
</PRE>
</SAMP>


<P>
<HR>


<P>
<A NAME="pi"></A>
<H2>14. <SAMP>pi-simple</SAMP></H2>
This is a serial program that demonstrates the use of several SPRNG features in a
simple example application involving the computation of <EM>PI</EM>
through a Monte Carlo method. We generate random points on a square of
side 2 which circumscribes a circle of unit radius. We determine the
proportion of points that fall within this circle. Since the ratio of
the area of the circle to the area of the square is <EM>PI/4</EM>, the
estimated value of <EM>PI</EM> is four times the proportion of points
that lie within the circle.

<P>
The user specifies the number of samples to be generated on the
square. The final state of the computations is stored in a file
specified by the user. The user can restart the computations by
reading from this file in subsequent runs. The user should also
specify whether the current run is a new one (in which case a new
random number stream is initialized) or an old one (in which case the
state of the random number stream is read from a file).

<P>
Note that we have <A
HREF="../definitions.html#include"><EM>included</EM></A> the SPRNG <A
HREF="../definitions.html#header"><EM>header file</EM></A>  at the beginning. We
have also <A HREF="../macros.html">defined</A> the <A
HREF="../definitions.html#macros"><EM>macro</EM></A>
<SAMP>SIMPLE_SPRNG</SAMP> before including the SPRNG header file in
order to invoke the simple interface.  

<P>
 The function <SAMP>initialize</SAMP> is then called to take suitable
 actions based on the information input by the user. A new run involves initializing a random number
 stream. In a continuation of a previous run, the state of the random number stream is
 read from a file whose name is input by the user. The final state of
 the computations is also written into this file.  The user should
 also input the number of samples to be generated in this run. In a
 new run, <SAMP>make_sprng_seed</SAMP> is called to produce a seed
 based on system date and time information.

<P>
Next the function <SAMP>count_in_circle</SAMP> is called, which
generates points on a square of side 2. The number of
points that fall on a circle of unit radius inscribed within this
square is returned by this function.

<P>
We then estimate <EM>PI</EM> as four times the proportion of points that fall
within the circle inscribed in the square.

<P>
Finally we call the function <SAMP>save_state</SAMP> to save the state
of the random number stream, the cumulative number of sample points
generated in all the runs, and the cumulative number of sample points
that lie within the inscribed circle in all the runs.



<P>
<B>Code</B>:
<P>
<TABLE BORDER=1 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH WIDTH=50><A HREF="pi-simple.c">C</A></TH>
<TH><A HREF="pif-simple.F">FORTRAN</A></TH>
</TR>
</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD> cc -64    -I../include -o pi-simple pi-simple.c -L../lib -llcg </KBD><P>

<P>
<B>Output:</B>
<SAMP>
<PRE>
<B>sprng/EXAMPLES:sif% pi-simple</B>
Enter 9 for a new run, or 2 for the continuation of an old run:
<B>9</B>
Enter name of file to store final state of the stream:
<B>temp</B>
Enter number of new samples:
<B>10000</B>

Linear Congruential Generator

        seed = 437891907, prime = 11863279
        multiplier = 44485709377909

pi is estimated as 3.1227999999999998 from 10000 samples.
        Error = 0.0187927, standard error = 0.0164218
<B>sprng/EXAMPLES:sif% pi-simple</B>
Enter 9 for a new run, or 2 for the continuation of an old run:
<B>2</B>
Enter name of file to store final state of the stream:
<B>temp</B>
Enter number of new samples:
<B>5000</B>
pi is estimated as 3.1165333333333334 from 15000 samples.
        Error = 0.0250593, standard error = 0.0134084
</PRE>
</SAMP>

<EM>Note:</EM> Results may vary due to the use of a random seed.


<P>
<HR>


<P>
<A NAME="pi-simple_mpi"></A>
<H2>15. <SAMP>pi-simple_mpi</SAMP></H2>
This is a parallel version of is a parallel version of <A
HREF="#pi">pi-simple</A> in which we divide the work of generating the
samples among the available processes. 

<P>
First we initialize MPI and call the function <SAMP>initialize</SAMP>
to initialize a random number stream. If this is the continuation of a
previously checkpointed run, then process 0 reads the previous state
and passes to to each process.

<P>
Next we divide the number of samples to be generated among all the
processes and then call the function <SAMP>count_in_circle</SAMP> as
in the sequential case. We then sum the number of points that fall within the circle across
all the processes by a call to <SAMP>MPI_REDUCE</SAMP> and estimate <EM>PI</EM> as four times the proportion of points that fall
within this circle inscribed in the square.

<P>
Finally we call the function <SAMP>save_state</SAMP> to save the state
of the random number stream, the cumulative number of sample points
generated in all the runs, and the cumulative number of sample points
that lie within the inscribed circle in all the runs. Each process
passes the state of its stream to process 0, which then saves it to a file.



<P>
<B>Code</B>:
<P>
<TABLE BORDER=1 VALIGN ALIGN=CENTER>

<TR ALIGN=CENTER VALIGN=MIDDLE>
<TH WIDTH=50><A HREF="pi-simple_mpi.c">C</A></TH>
</TR>
</TABLE>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD> cc -64    -I../include -o pi-simple pi-simple.c -L../lib -llcg </KBD><P>

<P>
<B>Compilation:</B> Example compilation on the SGI Power Challenge
<P>
<KBD> cc -64   -I../include -o pi-simple_mpi pi-simple_mpi.c -L../lib -llcg -L/usr/lib64 -lmpi </KBD><P>

<P>
<B>Output:</B>
<SAMP>
<PRE>
<B>sprng/EXAMPLES:sif% mpirun -np 2 pi-simple_mpi</B> 
Enter 9 for a new run, or 2 for the continuation of an old run:
<B>9</B>
Enter name of file to store final state of the stream:
<B>temp</B>
Enter number of new samples:
<B>5000</B>

Linear Congruential Generator

Linear Congruential Generator

        seed = 42578755, prime = 11863279
        multiplier = 44485709377909


        seed = 42578755, prime = 11863259
        multiplier = 44485709377909

pi is estimated as 3.1568000000000001 from 5000 samples.
        Error = 0.0152073, standard error = 0.023224
</PRE>
</SAMP>
<EM>Note:</EM> Results may vary due to the use of a random seed.



<P>
<HR>

</BODY>
<ADDRESS> Ashok Srinivasan <BR>
<A HREF="mailto:ashoks@ncsa.uiuc.edu"> ashoks@ncsa.uiuc.edu </A> <BR>
Last modified: 1 Apr, 1997
</ADDRESS>
</HTML> 
