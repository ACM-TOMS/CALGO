********************* Start of rksuite_90.doc ********************************

                  RKSUITE_90 Release 1.2  December 1995

                             written by

                 R.W. Brankin(*) and  I. Gladwell(**)



 (*)  Numerical Algorithms Group Ltd.
      Wilkinson House
      Jordan Hill Road
      Oxford OX2 8DR
      U.K.
      email: richard@nag.co.uk
             na.brankin@na-net.ornl.gov
      International phone: + 44 1865 511245
      International   fax: + 44 1865 310139

 (**) Department of Mathematics
      Southern Methodist University
      Dallas, Texas 75275-0156
      U.S.A.
      email: gladwell@seas.smu.edu
             igladwel@sun.cis.smu.edu
             h5nr1001@vm.cis.smu.edu
      U.S. phone: (214) 768-2542
      U.S.   fax: (214) 768-4138

*** The authors would very much appreciate receiving notification ***
*** of errors and constructive criticism of RKSUITE_90 ***

*************************** RKSUITE_90 Overview ******************************

RKSUITE_90 is a module based on Runge-Kutta formulas that solves the
initial value problem for ordinary differential equations. It integrates

             y' = f(t,y),     y(t_start) = y_start.

Here y is the solution (dependent variable) and t is the independent
variable. The integration proceeds from t = t_start to t = t_end.

The most commonly occurring case is where y and f are real vectors. At
the end of this section, we discuss how to produce "automatically" a
version of RKSUITE_90 for the cases where y and f are scalars, vectors
or matrices and for the cases where y and f are real or complex.

Algorithmically, RKSUITE_90 is taken almost entirely from the Fortran 77
package RKSUITE, designed and coded by L.F. Shampine and the authors of
RKSUITE_90.

RKSUITE_90 contains two recusive integration procedures, RANGE_INTEGRATE
and STEP_INTEGRATE, and a number of associated auxiliary procedures. You
define initial conditions and local error requirements, and set other
options by a call to procedure SETUP.  RANGE_INTEGRATE solves the
commonly occurring problem of integrating the differential equations
across a range obtaining answers at points you specify.  STEP_INTEGRATE
is designed for more complicated tasks and is a step oriented
integrator.  It is easy to change between RANGE_INTEGRATE and
STEP_INTEGRATE: all the arguments accessible to you have the same
meanings in both procedures.

The distribution version of RKSUITE_90 sets the working precision, WP,
using

                  WP = SELECTED_REAL_KIND (10,50).

When solving ordinary differential equations, it is advisable to use at
least 10 decimal digits of working accuracy as selected in this setting
(which also guarantees a decimal exponent range of 50 orders of
magnitude). Edit the second line of the module RKSUITE_90_PREC for other
choices of precision. The accuracy of the constants defining the
Runge-Kutta formulas implies that you should not request more than 30
decimal digits of working accuracy. If you wish to work in standard
DOUBLE PRECISION edit the precision line to

                         WP = KIND(1.0D0)

and for standard REAL (single precision) edit it to

                         WP = KIND(1.0E0)

Note that DOUBLE PRECISION on some machines (e.g. CRAYs) is about 30
decimal digits of working accuracy.

To set various arguments in RKSUITE_90, you may need to know MACHEPS,
the smallest number such that 1.0 + MACHEPS > 1.0 in the working
precision, and DWARF, the smallest number available in the working
precion. You may estimate these numbers by specifying a variable, DUMMY
say, of kind WP and then making the calls

                         MACHEPS = EPSILON (DUMMY)
                         DWARF = TINY (DUMMY)

Some errors that can arise in the use of RKSUITE_90 are catastrophic.
Examples include input arguments that are meaningless in context or are
inconsistent, and calls to procedures that have not been initialized or
cannot be used in the context prevailing.  A catastrophic error will
automatically lead to an explanatory message on the standard output
channel OUTPUT_CHANNEL and to the program STOPping. (It is possible to
override this STOP so that the main program can go on to another task.
This is achieved using procedures SET_STOP_ON_FATAL and
GET_SAVED_STATE.)  OUTPUT_CHANNEL is set (once) to 6 internally. To
change this value you must edit the module RKSUITE_90.

Module RKSUITE_90 needs to pass global information between its various
procedures. This is achieved using a variable of a predetermined derived
type, below called COMM of generic type "RK_COMM". The specification is
(usually):

COMM - type "RK_COMM", INTENT(INOUT) 
Used to communicate information between calls to the procedures in 
RKSUITE_90. The contents of COMM are private. **

In the base version of RKSUITE_90, "RK_COMM" is set to RK_COMM_REAL_1D.

You may specify as many derived types of type "RK_COMM" as you need,
hence permitting more than one simultaneous integration and/or recursive
calls to the integrators RANGE_INTEGRATE and STEP_INTEGRATE in a single
program.  The use of this method of keeping global information also
makes RKSUITE_90 "multiprocessor safe". If you wish to integrate a
number of differential equations in succession in a single program,
between calls you should deallocate the memory and nullify the pointers
used by COMM. Procedure GARBAGE_COLLECT is provided for this purpose.

In the specification below, a number of generic terms are used:

1. type("RK_COMM")

2. type(independent variable)

3. type(dependent variable)

4. shape(Y_START)

In the base version these are to be interpreted as:

1. type(RK_COMM_REAL_1D)

2. REAL of KIND = WP

3. REAL of KIND = WP

4. One-dimensional array of length of the vector of initial conditions,
   Y_START = y_start

With RKSUITE_90 we provide a UNIX script which will transform RKSUITE_90
to produce one or all of the combinations:

A. type dependent variable = REAL or COMPLEX of KIND = WP

B. shape(Y_START) can be zero (scalar), one (vector) or two (matrix)
   dimensional

In these instances "RK_COMM" is

                            REAL                COMPLEX
     Zero dimensions   RK_COMM_REAL_0D      RK_COMM_COMPLEX_0D
     One dimension     RK_COMM_REAL_1D      RK_COMM_COMPLEX_1D
     Two dimensions    RK_COMM_REAL_2D      RK_COMM_COMPLEX_2D

The other generic types are unchanged from the base version.

There follows a template to which you should refer when reading the
specification below. Note that it is for the base version of RKSUITE_90.

module define_f
use rksuite_90_prec, only:wp             ! get precision of rksuite_90
    ...                                  ! define data for f here
contains
   function f(t,y)
   real(kind=wp), intent(in) :: t
   real(kind=wp), dimension(:), intent(in) :: y
   real(kind=wp), dimension(size(y)) :: f
   f = (/ ...  /)                        ! evaluate f
   end function f
end module define_f

program demo
use rksuite_90                           ! access rksuite_90
use define_f                             ! access f
type(rk_comm_real_1d) :: comm            ! the communication structure
real(kind=wp) :: t_start=..., t_end=..., y_start(...)=(/.../),  &
                 tolerance=..., thresholds(size(y_start))=(/.../), &
                 t_want, t_inc=..., y_maxvals(size(y_start)), &
                 t_got, y_got(size(y_start))
integer :: flag
   ...                                   ! f90 statements
call setup(comm,t_start,y_start,t_end,tolerance,thresholds)
   ...                                   ! f90 statements
do
   t_want = t_want + t_inc
   if (t_want > t_end) exit
   call range_integrate(comm,f,t_want,t_got,y_got=y_got,flag=flag)
   if (flag /= 1) exit
   print*,' t = ',t_got,' y = ',y_got
end do
   ...                                   ! f90 statements
call statistics(comm,y_maxvals=y_maxvals)! optional call to statistics
print*,' y_maxvals = ',y_maxvals
   ...                                   ! f90 statements
end program demo

******************************************************************************

---------------------Description of Subroutine SETUP------------------------


SUBROUTINE SETUP(COMM,T_START,Y_START,T_END,TOLERANCE,THRESHOLDS,
           METHOD,TASK,ERROR_ASSESS,H_START,MESSAGE)

SETUP initializes the computation, so it is normally called only once.
A call to SETUP must precede the first call to RANGE_INTEGRATE or
STEP_INTEGRATE.  Any subsequent call to SETUP reinitializes the
computation.

ARGUMENTS

COMM - type("RK_COMM"), INTENT(OUT)
Used to communicate information between calls to the procedures in
RKSUITE_90. The contents of COMM are private.  **

T_START - type(independent variable), INTENT(IN)
The initial value of the independent variable. **

Y_START -type(dependent variable), INTENT(IN)
The initial values of the solution Y. **

T_END - type(independent variable), INTENT(OUT)
The integration proceeds from T_START in the direction of T_END. You
can, and often will, terminate the integration before reaching T_END,
but you cannot integrate past T_END.
Constraint: T_END must be clearly distinguishable from T_START in the
            precision available. **

The integration proceeds by steps from T_START towards T_END. An
approximate solution Y is computed at each step.  The error in Y made in
the step, i.e. the local error, is estimated.  The step size is chosen
automatically so that the integration will proceed efficiently while
keeping this local error estimate smaller than a tolerance that you
specify by means of the scalar argument TOLERANCE and THRESHOLDS which
has the same shape as Y_START .

You should consider carefully how you want the local error to be
controlled.  RKSUITE_90 basically uses relative local error control,
with TOLERANCE being the desired relative accuracy.  For reliable
computation, integrators must work with approximate solutions that have
some correct digits, so you are not allowed to specify TOLERANCE greater
than 0.01. It is impossible to compute a numerical solution more
accurate than the correctly rounded value of the true solution, so you
are not allowed to specify a TOLERANCE that is too small for the
precision you are using.  Specifically, TOLERANCE must be greater than
10.0*MACHEPS.

The magnitude of the local error in a component of Y on any step will
not be greater than TOLERANCE * max("magnitude_y",THRESHOLDS) where
"magnitude_y" is a average magnitude of the corresponding component of Y
over the step.  If THRESHOLDS is smaller than the current "magnitude_y",
this is a relative error test and TOLERANCE indicates how many
significant digits you want in Y.  If THRESHOLDS is larger than the
current "magnitude_y", this is an absolute error test with tolerance
TOLERANCE*THRESHOLDS.  Relative error control is recommended, but pure
relative error control is not permitted.  Specifically, no component of
THRESHOLDS can be smaller than SQRT(DWARF).  If certain solution
components are of no interest when they are smaller in magnitude than a
given threshold, you can inform RKSUITE_90 by setting corresponding
components of THRESHOLDS to this threshold. Hence, you avoid the cost of
computing unnecessary significant digits in a component of Y.  This is
important when a component of Y vanishes, and in particular, when a
component of the initial value Y_START vanishes.  Appropriate THRESHOLDS
depend on the general size of Y in the course of the integration.
Physical reasoning may help you select suitable threshold values.  If
you do not know what to expect of Y, you can find out by a preliminary
integration using RANGE_INTEGRATE with nominal values of THRESHOLDS. As
RANGE_INTEGRATE steps from T_START towards T_END, it forms Y_MAXVALS,
containing the largest magnitude of each component of Y computed at any
step in the integration so far. You can access Y_MAXVALS using procedure
STATISTICS.  Then, you can determine more appropriate values for
THRESHOLDS for an accurate integration.  You might, for example, take
THRESHOLDS = 10.0*MACHEPS * Y_MAXVALS after completing the trial
integration.

TOLERANCE - REAL(KIND=WP), INTENT(IN)
The relative error tolerance.
Constraint: 0.01 >= TOLERANCE >= 10.0*MACHEPS **

THRESHOLDS - REAL(KIND=WP), shape(Y_START), INTENT(IN)
Contains thresholds for the solution Y. Choose it so that a component of
Y is not important when it is smaller in magnitude than the
corresponding component of THRESHOLDS.
Constraint: THRESHOLDS >= SQRT(DWARF) **

Like practically all IVP integrators, RANGE_INTEGRATE and STEP_INTEGRATE
control the local error rather than the true (global) error, the
difference between the numerical and true solution.  Control of the
local error controls the true error indirectly.  Roughly speaking,
RKSUITE_90 produces a solution that satisfies the differential equation
with a discrepancy bounded in magnitude by the error tolerance. How
close the numerical solution is to the true solution depends on the
stability of the problem.  Most practical problems are at least
moderately stable, and the true error is then comparable to the error
tolerance. To judge the accuracy of the numerical solution, you could
reduce TOLERANCE substantially, e.g. by a factor of ten, and solve the
problem again.  This will usually result in a more accurate solution,
and the true error of the first integration can be estimated by
comparison.  Alternatively, a global error assessment can be computed
automatically by setting ERROR_ASSESS to .TRUE..  Because indirect
control of the true error by controlling the local error is generally
satisfactory and because both ways of assessing true errors cost twice,
or more, the cost of the integration itself, such assessments should be
used mainly for spot checks, for selecting appropriate tolerances for
local error control, and for exploratory computations.

RKSUITE_90 implements three Runge-Kutta formula pairs.  You may want
override the default selection depending on your requirements.

METHOD - CHARACTER (LEN = *), OPTIONAL, INTENT(IN)
Specifies which Runge-Kutta pair is to be used. Only the first character
of METHOD is used.
METHOD(1:1) = `L' or `l' - use the low order (2,3) pair
            = `M' or `m' - use the moderate order (4,5) pair (DEFAULT)
            = `H' or `h' - use the high order (7,8) pair
(The order of accuracy is 3,5,8, respectively.)
Constraint: METHOD(1:1) = `L', `l', `M', `m', `H' or `h'. **

The best choice for METHOD depends on the problem. As a rule, the
smaller TOLERANCE, the higher order you should make METHOD.  If the
components of THRESHOLDS are small enough that you are effectively
specifying relative error control, experience suggests

              TOLERANCE        most efficient METHOD
                       -4
             0.01 -- 10               `L' or `l'
               -3      -6
             10   -- 10               `M' or `m'
               -5
             10   -- 10*MACHEPS       `H' or `h'

The overlap in the ranges of tolerances appropriate for a given METHOD
reflects the dependence of efficiency on the problem.  Making TOLERANCE
smaller will normally make the integration more expensive.  However, in
the range of tolerances appropriate to a METHOD, the increase in cost is
modest. Sometimes one METHOD, or even this kind of integrator, is a poor
choice.  You should not specify a very small THRESHOLDS component, like
SQRT(DWARF), when the corresponding solution component might vanish.  In
particular, you should not do this when the component of Y_START is
zero.  If you do, the integrator will have to work hard with any METHOD
to compute significant digits, but METHOD = `L' is particularly poor
choice in this situation.  All three METHODs are inefficient when the
problem is "stiff".  If it is only mildly stiff, you can solve it with
acceptable efficiency with METHOD = `L', but if it is moderately or very
stiff, an integrator designed specifically for such problems will be
much more efficient.  The higher the order selected by METHOD, the more
smoothness is required of the solution for the METHOD to be efficient.

You must decide which integrator, RANGE_INTEGRATE or STEP_INTEGRATE, to
use. RANGE_INTEGRATE integrates the differential equation across a range
to obtain answers at points you specify.  STEP_INTEGRATE integrates
across internally chosen steps and is used for all more complicated
tasks.

TASK - CHARACTER(LEN = *), OPTIONAL, INTENT(IN)
Only the first character of TASK is significant.
TASK(1:1) = `R' or `r' - RANGE_INTEGRATE is to be used (DEFAULT)
          = `S' or `s' - STEP_INTEGRATE is to be used
Constraint: TASK(1:1) = `R' or `r' or `S' or `s' **

An assessment of the true (global) error is provided by setting
ERROR_ASSESS = .TRUE.. The error assessment is updated at each step. Its
value can be obtained at any time by a call to procedure GLOBAL_ERROR.

Warning: RKSUITE_90 monitors the computation of the global error
assessment and reports any doubts it has about the reliability of the
results.  The assessment scheme requires some smoothness of f(t,y), and
it can be deceived if f is insufficiently smooth.  At very crude
tolerances the numerical solution can become so inaccurate that it is
impossible to continue assessing the accuracy reliably.  At very
stringent tolerances the effects of finite precision arithmetic can make
it impossible to assess the accuracy reliably.  In either case the
integrator returns with a message and a flag (FLAG = 6) reporting that
global error assessment has broken down.

ERROR_ASSESS - LOGICAL, OPTIONAL, INTENT(IN)
    = .FALSE. - do not attempt to assess the true error (DEFAULT)
    = .TRUE.  - assess the true error, the difference between the
numerical solution and the true solution.  (The cost of this is roughly
twice the cost of the integration itself with METHODs `M' and `H', and
three times with METHOD = `L'.) **

The first step of the integration is critical because it sets the scale
of the problem. The integrator will find a starting step size
automatically if you set the variable H_START to 0.0. Automatic
selection of the first step is so effective that you should normally use
it.  Nevertheless, you might want to specify a trial value for the first
step to be certain that the integrator recognizes the scale on which
phenomena occur near the initial point. Also, automatic computation of
the first step size involves some cost, so supplying a good value for
this step size will result in a less expensive start.  If you are
confident that you have a good value, provide it in the variable
H_START.

H_START - type(independent variable), OPTIONAL, INTENT(IN)
     = zero - The integrator will select automatically the first step
              size of the integration. (DEFAULT)
     = non-zero - The integrator will try ABS(H_START) for the first step
              size of the integration. **

RANGE_INTEGRATE and STEP_INTEGRATE communicate with your calling program
by means of a argument FLAG.  If you wish, you can also have messages
written to the standard output channel OUTPUT_CHANNEL. The messages
provide more detail, so it is advisable to permit them for all but
production runs.

MESSAGE - LOGICAL, OPTIONAL, INTENT(IN)
Specifies whether you want informative messages written to OUTPUT_CHANNEL.
    = .TRUE.   - provide messages (DEFAULT)
    = .FALSE.  - do not provide messages **

The data input to SETUP is monitored. Any error detected is
catastrophic.  An error message is written to the output channel
OUTPUT_CHANNEL (even if MESSAGE = .FALSE.), and the program STOPs.

-------------------End of Description of Subroutine SETUP--------------------

********************** Subroutine RANGE_INTEGRATE  **************************

Subroutine RANGE_INTEGRATE is a member of the module, RKSUITE_90, for
solving the initial value problem for ordinary differential equations by
Runge-Kutta methods.  RANGE_INTEGRATE is designed for computing an
approximate solution at a sequence of points across a range of
integration.  First you call SETUP to specify the problem and how it is
to be solved. Thereafter you (repeatedly) call RANGE_INTEGRATE to obtain
answers at points you specify.  Another integrator, STEP_INTEGRATE, in
RKSUITE_90 is provided for more complicated tasks.

RANGE_INTEGRATE requires you to specify a sequence of output points.
They must be clearly distinguishable in the precision available, and the
first one must be distinguishable from t_start as defined in the
previous call to SETUP.  You are extremely unlikely to specify points
that are not clearly distinguishable except by mistake.  Should this
happen, the integrator will tell you how far apart the points must be.

-------------------Description of Subroutine RANGE_INTEGRATE------------------

  RECURSIVE SUBROUTINE RANGE_INTEGRATE(COMM,F,T_WANT,T_GOT,Y_GOT,
                                       YDERIV_GOT,FLAG)

ARGUMENTS

COMM - type("RK_COMM"), INTENT(IN)OUT
Used to communicate information between calls to the procedures in
RKSUITE_90. The contents of COMM are private. **

The differential equations are defined by the function F that you must
provide.  You may give this function any name you like but it must have
the following interface:

FUNCTION F(T,Y)
T - type(independent variable), INTENT(IN)
Y - type(dependent variable), shape(Y_START), INTENT(IN)
F - type(dependent variable), shape(Y_START)
Given input values of the independent variable T and the solution Y,
evaluate the differential equations for the derivative and return the
result in F. **

RANGE_INTEGRATE approximates the true solution of the initial value
problem and its first derivative at the point T_WANT specified in the
call to RANGE_INTEGRATE.  On return, integration has been successful as
far as T_GOT, and Y_GOT and YDERIV_GOT are accurate approximations to
the solution and its first derivative at T_GOT.  If all has gone well,
T_GOT equals T_WANT and FLAG = 1.  If the integrator did not reach
T_WANT then T_GOT is not equal to T_WANT and an explanation is indicated
by the value of FLAG. The integration proceeds by steps from T_START
towards T_END (both specified in SETUP).  For this reason, the specified
T_WANT must be closer to T_END than the previous value of T_GOT (T_START
on the first call to RANGE_INTEGRATE).  T_WANT can equal T_END.

T_WANT - type(independent variable), INTENT(IN)
The next value of the independent variable where a solution is desired.
Constraint: T_WANT must be closer to T_END than the previous value of
T_GOT (T_START on the first call to RANGE_INTEGRATE).  It can be equal
to T_END.  Unless exactly equal to T_END, it must be clearly
distinguishable from T_END and from T_GOT, in the precision available. **

T_GOT - type(independent variable), INTENT(OUT)
A solution has been computed at this value of the independent variable.
If the task was completed successfully, it is the same as T_WANT.  If
the integrator did not reach T_WANT, an explanation is provided by the
value of FLAG.  **

Y_GOT - type(dependent variable), shape(Y_START), OPTIONAL, INTENT(OUT)
Approximation to the true solution at T_GOT.  At each step of the
integration to T_GOT, the local error has been controlled as specified
by TOLERANCE and THRESHOLDS.  The local error in Y_GOT has been
controlled even when T_GOT differs from T_WANT. **

YDERIV_GOT - type(dependent variable), shape(Y_START), OPTIONAL, INTENT(OUT)
Approximation to the first derivative of the true solution at T_GOT.
The local error has been controlled even when T_GOT differs from
T_WANT. **

Normally, any difficulties encountered by RANGE_INTEGRATE will result
with an error message written to the output channel OUTPUT_CHANNEL and
the program STOPping unless the optional output argument FLAG is
provided.  If FLAG is present then RANGE_INTEGRATE reports success by
setting FLAG = 1.  Difficulties with the integration are reported by
values FLAG > 1.  If MESSAGE was set .TRUE. in the call to SETUP,
details about the difficulties are written to the standard output
channel OUTPUT_CHANNEL.  If RANGE_INTEGRATE fails catastrophically, for
example if values of its input variables are incompatible with those
provided in SETUP, details are written to the output channel
OUTPUT_CHANNEL (even if MESSAGE was set .FALSE.), and the program STOPs.

FLAG - INTEGER, OPTIONAL, INTENT(OUT)

   "SUCCESS" T_GOT = T_WANT.

= 1 - Successful call. To compute an approximation at a new T_WANT, just
call RANGE_INTEGRATE again with the new value of T_WANT.

    "SOFT FAILURES"

= 2 - This return is possible only when METHOD = `H'.  The integrator is
being used inefficiently because the step size has been reduced
drastically many times to get answers at many points T_WANT.  If you
really need the solution at this many points, you should change to
METHOD = `M' because it is (much) more efficient in this situation.  To
change METHOD, restart the integration from T_GOT, Y_GOT by a call to
SETUP (note that you must b using the optional argument Y_GOT to be able
to do this).  Precede this call to SETUP by a call to GARBAGE_COLLECT to use
memory efficiently. If you wish to continue on towards T_WANT with
METHOD = `H', just call RANGE_INTEGRATE again.  The monitor of this kind
of inefficiency will be reset automatically so that the integration can
proceed.

= 3 - A considerable amount of work has been expended in the (primary)
integration. This is measured by counting the number of calls to the
function F. At least 5000 calls have been made since the last time this
counter was reset.  Calls to F in a secondary integration for global
error assessment are not counted in this total. The integration was
interrupted, so T_GOT is not equal to T_WANT. If you wish to continue on
towards T_WANT, just call RANGE_INTEGRATE again. The counter measuring
work will be reset to zero automatically.

= 4 - It appears that this problem is "stiff".  The methods implemented
in RANGE_INTEGRATE can solve such problems, but they are inefficient.
You should change to an integrator based on methods appropriate for
stiff problems.  If you want to continue on towards T_WANT, just call
RANGE_INTEGRATE again. The stiffness monitor will be reset
automatically.

    "HARD FAILURES"

= 5 - It does not appear possible to achieve the accuracy specified by
TOLERANCE and THRESHOLDS in the call to SETUP with the precision
available on this computer and with this order of METHOD.  You cannot
continue integrating this problem. A higher order for METHOD, if
possible, will permit greater accuracy with this precision.  To increase
the order of METHOD and/or continue with larger values of TOLERANCE
and/or THRESHOLDS, restart the integration from T_GOT, Y_GOT by a call
to SETUP (note that you must b using the optional argument Y_GOT to be able
to do this). Precede this call to SETUP by a call to GARBAGE_COLLECT to use
memory efficiently.

= 6 - The global error assessment may not be reliable beyond the current
integration point T_GOT. This may occur because either too little or too
much accuracy has been requested or because f is not smooth enough near
T_GOT and current values of the solution.  The integration cannot be
continued.  This return does not mean that you cannot integrate past
T_GOT, rather that you cannot do it with ERROR_ASSESS = .TRUE.. However,
it may also indicate problems with the primary integration. You may
continue the integration by restarting with a call to SETUP. Precede
this call to SETUP by a call to GARBAGE_COLLECT to use memory
efficiently. **

Performance statistics are available after any return from
RANGE_INTEGRATE by a call to the procedure STATISTICS. IF ERROR_ASSESS
was set .TRUE., global error assessment is available after any return
from RANGE_INTEGRATE by a call to the procedure GLOBAL_ERROR.

After a hard failure (FLAG = 5 or 6) the diagnostic procedures
STATISTICS and GLOBAL_ERROR may be called only once. Other procedures
from RKSUITE_90 may not be called at all, except SETUP to restart the
integration. Precede this call to SETUP by a call to GARBAGE_COLLECT to
use memory efficiently.

-----------End of Description of Subroutine RANGE_INTEGRATE-----------------

------------Description of Subroutine GLOBAL_ERROR--------------------------

   SUBROUTINE GLOBAL_ERROR(COMM,RMS_ERROR,MAX_ERROR,T_MAX_ERROR)

To assess the true (global) error of the integration with STEP_INTEGRATE
or RANGE_INTEGRATE, set ERROR_ASSESS = .TRUE. in the call to SETUP.
After any call to STEP_INTEGRATE or RANGE_INTEGRATE, GLOBAL_ERROR may be
called for information about the assessment.  The solution Y is computed
in the primary integration. (The values Y_GOT in RANGE_INTEGRATE and
Y_NOW in STEP_INTEGRATE are instances of Y resulting from the primary
integration.)  A more accurate "true" solution Y_SECOND is computed in a
secondary integration.  The error is measured as specified in SETUP for
local error control.  At each step in the primary integration, an
average magnitude "magnitude_y" of Y is computed, and the error is

            abs(Y - Y_SECOND)/max("magnitude_y", THRESHOLDS).

It is difficult to estimate reliably the true error at a single point.
For this reason the RMS (root-mean-square) average of the estimated
global error is returned in RMS_ERROR.  This average is taken over all
steps from T_START through the current integration point.  If all has
gone well, the average errors reported in RMS_ERROR will be comparable
to TOLERANCE.  Other useful quantities are MAX_ERROR, the maximum error
seen in any component in the integration so far, and T_MAX_ERROR, the
point where the maximum error first occurred.

You may call GLOBAL_ERROR only once after a hard failure in
RANGE_INTEGRATE or STEP_INTEGRATE.

ARGUMENTS

COMM - type("RK_COMM"), INTENT(INOUT)
Used to communicate information between calls to the procedures in
RKSUITE_90. The contents of COMM are private. **

RMS_ERROR - REAL(KIND=WP), shape(Y_START), OPTIONAL, INTENT(OUT)
RMS_ERROR approximates the RMS average of the true error of the
numerical solution.  The average is taken over all steps from T_START
through the current integration point.  If all has gone well, RMS_ERROR
will be comparable to TOLERANCE. **

MAX_ERROR - REAL(KIND=WP), OPTIONAL, INTENT(OUT)
The maximum weighted approximate true error taken over all solution
components and all steps from T_START through the current integration
point.  If all has gone well, MAX_ERROR will be comparable to
TOLERANCE. **

T_MAX_ERROR - type(independent variable), OPTIONAL, INTENT(OUT)
First value of the independent variable where an approximate true error
attains the maximum value MAX_ERROR. **

At least one optional argument must be present.

The call to GLOBAL_ERROR is monitored. Any error is catastrophic. A
message is written to OUTPUT_CHANNEL (even if MESSAGE = .FALSE.), and
the program STOPs.

-----------------End of Description of Subroutine GLOBAL_ERROR-------------

 -------------------Description of Subroutine STATISTICS-------------------

        SUBROUTINE STATISTICS(COMM,TOTAL_F_CALLS,STEP_COST,WASTE,
                   NUM_SUCC_STEPS,H_NEXT,Y_MAXVALS)

STATISTICS may be called after any call to RANGE_INTEGRATE or
STEP_INTEGRATE to obtain details about the integration.  You may call
STATISTICS only once after a hard failure in RANGE_INTEGRATE or
STEP_INTEGRATE.

ARGUMENTS

COMM - type("RK_COMM"), INTENT(INOUT)
Used to communicate information between calls to the procedures in
RKSUITE_90. The contents of COMM are private. **

TOTAL_F_CALLS - INTEGER, OPTIONAL, INTENT(OUT)
Total number of calls to F in the integration so far -- a measure of the
cost of the integration. **

STEP_COST - INTEGER, OPTIONAL, INTENT(OUT)
Cost of a typical step with this METHOD measured in calls to F. **

WASTE - REAL(KIND=WP), OPTIONAL, INTENT(OUT)
The number of attempted steps that failed to meet the local error
requirement divided by the total number of steps attempted so far in the
integration.  A "large" fraction indicates that the integrator is having
trouble with this problem. This can happen when the problem is "stiff"
and also when the solution has discontinuities in a low order
derivative. **

NUM_SUCC_STEPS - INTEGER, OPTIONAL, INTENT(OUT)
The number of successful steps in the integratyion so far. **

H_NEXT - type(independent variable), OPTIONAL, INTENT(OUT)
The step size the integrator plans to use for the next step. **

Y_MAXVALS - REAL(KIND=WP), shape(Y_START), OPTIONAL, INTENT(OUT)
Y_MAXVALS is the componentwise largest value of ABS(Y) computed at any
step in the integration so far. (With METHODs `L' and `M' in
RANGE_INTEGRATE, Y_GOT is computed by interpolation, so Y_MAXVALS might
be a little different than any value ABS(Y_GOT) reported so far.) **

At least one optional argument must be present.

The call to STATISTICS is monitored. Any error is catastrophic. A
message is written to OUTPUT_CHANNEL (even if MESSAGE = .FALSE.), and
the program STOPs.

--------------End of Description of Subroutine STATISTICS---------------------

************ STEP_INTEGRATE: Subroutine for Complicated Tasks ****************

STEP_INTEGRATE is a member of RKSUITE_90, for solving the initial value
problem for ordinary differential equations by Runge-Kutta methods.
SETUP is used to specify the problem and how it is to be solved.
STEP_INTEGRATE is used to advance the integration one step.  Another
integrator, RANGE_INTEGRATE, in RKSUITE_90 is provided for the task of
obtaining an approximate solution at a sequence of points.
STEP_INTEGRATE is designed for more complicated tasks that require close
monitoring of the integration and additional capabilities.  To ease use,
less common demands are handled by means of the auxiliary procedures
INTERPOLATE and RESET_T_END.

-----------------------------------------------------------------------------
------------------Description of Subroutine STEP_INTEGRATE--------------------

  RECURSIVE SUBROUTINE STEP_INTEGRATE(COMM,F,T_NOW,Y_NOW,YDERIV_NOW,FLAG)

STEP_INTEGRATE is used to step from T_START in the direction of T_END as
specified in SETUP.  One way to use STEP_INTEGRATE involves repeatedly
resetting T_END, so a procedure RESET_T_END is provided for this
purpose.  When STEP_INTEGRATE is called, Y_NOW and YDERIV_NOW
approximate the solution its first derivative resectively at T_NOW.  If
the integrator encounters some difficulty in taking a step, it returns
with these values unaltered and provides an explanation by means of the
value of the optional argument FLAG, if supplied.  If all goes well,
STEP_INTEGRATE returns with FLAG = 1, and Y_NOW and YDERIV_NOW are the
new values of the approximate solution and its first derivative at the
end of a single step to the new T_NOW.  STEP_INTEGRATE tries to advance
the integration as far as possible subject to passing the test on the
local error and not going past T_END.  In the call to SETUP, you can
specify that STEP_INTEGRATE try H_START as its first step size or that
it compute automatically an appropriate value.  Thereafter
STEP_INTEGRATE estimates an appropriate step size for its next step.
This value and other details of the integration can be obtained after
any call to STEP_INTEGRATE by a call to procedure STATISTICS.  The local
error is controlled at every step as specified in SETUP. If you wish to
assess the true error, you must set ERROR_ASSESS = .TRUE. in the call to
SETUP. This assessment can be obtained after any call to STEP_INTEGRATE
by a call to the procedure GLOBAL_ERROR.

There are three ways to use STEP_INTEGRATE:

1. Step from T_START towards T_END, accepting answers at the points
chosen by the integrator.  This is often the best way to proceed when
you want to see how the solution behaves throughout the interval of
integration because the integrator tends to produce answers more
frequently where the solution changes more rapidly (the step sizes are
usually smaller there).

**  If you want answers at specific points, two ways to proceed are:

2. The more efficient way is to step past the point where a solution is
desired, and then call procedure INTERPOLATE to get an answer there.
Within the span of the current step, you can get all the answers you
want at very little cost by repeated calls to INTERPOLATE.  This is very
valuable when you want to find where something happens, e.g., where a
particular solution component vanishes.  You cannot proceed in this way
with METHOD = `H'.

3. The other way to get an answer at a specific point is to set T_END to
this value and integrate to T_END.  STEP_INTEGRATE will not step past
T_END.  So, when a step would carry it past T_END, it will be reduced so
as to produce an answer at T_END exactly.  After getting an answer there
(with T_NOW = T_END), you can reset T_END to the next point where you
want an answer, and repeat. T_END could be reset by a call to SETUP, but
you should not do this. You should use the procedure RESET_T_END because
it is both easier to use and much more efficient.  This way of getting
answers at specific points can be used with any of the METHODs, but it
is the only way with METHOD = `H'.  It can be inefficient.  Should this
be the case, RKSUITE_90 will bring the matter to your attention.

ARGUMENTS

COMM - type("RK_COMM"), INTENT(INOUT)
Used to communicate information between calls to the procedures in
RKSUITE_90. The contents of COMM are private. **

The differential equations are defined by the function F that you must
provide.  You may give this function any name you like but it must have
the following interface:

FUNCTION F(T,Y)
T - type(independent variable), INTENT(IN)
Y - type(dependent variable), shape(Y_START), INTENT(IN)
F - type(dependent variable), shape(Y_START)
Given input values of the independent variable T and the solution Y,
evaluate the differential equations for the derivative and return the
result in F. **

On each call, STEP_INTEGRATE tries to take a step from the current value
of T_NOW (initially T_START) in the direction of T_END.  On the previous
call, the integrator estimated an appropriate step size.  (On the first
call, either you provide the step size, or one is determined
automatically.) If this step size is too big for the formula to achieve
the specified accuracy, the integrator will adjust the step size and try
again.  It keeps trying until it produces a solution that is
sufficiently accurate, or it decides to report that it has run into
trouble via FLAG (and the standard output channel OUTPUT_CHANNEL if
MESSAGE was set .TRUE.  in SETUP).  In any case, the values returned in
Y_NOW and YDERIV_NOW satisfy the specified local accuracy requirement at
the value T_NOW.

T_NOW - type(independent variable), INTENT(OUT)
Current value of the independent variable after a step towards T_END. **

Y_NOW - type(dependent variable), shape(Y_START), OPTIONAL, INTENT(OUT)
Approximation to the solution at T_NOW.  The local error of the step to
T_NOW was no greater than permitted by the tolerances TOLERANCE and
THRESHOLDS as specified in SETUP. **

YDERIV_NOW - type(dependent variable), shape(Y_START), OPTIONAL,
              INTENT(OUT)
Approximation to the derivative of the solution at T_NOW. **

Normally, any difficulties encountered by STEP_INTEGRATE will result
with an error message written to the output channel OUTPUT_CHANNEL and
the program STOPping unless the optional output argument FLAG is
provided.  If FLAG is present then STEP_INTEGRATE reports success by
setting FLAG = 1.  Difficulties with the integration are reported by
values of FLAG > 1.  In such cases the integration has not advanced and
T_NOW, Y_NOW, and YDERIV_NOW are unchanged.  If MESSAGE was set .TRUE.
in the call to SETUP, some details about the difficulty are written to
the standard output channel OUTPUT_CHANNEL. The call to STEP_INTEGRATE
is monitored. If a catastrophic error is detected, for example when
STEP_INTEGRATE has been called out of context, then an error message is
written to the output channel OUTPUT_CHANNEL (even if MESSAGE was set to
.FALSE.), and the program STOPs.

FLAG - INTEGER, INTENT(OUT)

    "SUCCESS"

= 1 - Successful call.  A step was taken to T_NOW.  To continue the
integration in the direction of T_END, just call STEP_INTEGRATE again.
Do not alter any variables.

   "SOFT FAILURE"

= 2 - The integrator is being used inefficiently because the step size
has been reduced drastically many times to get answers at many values of
T_END. If you really need the solution at this many specific points, you
should use INTERPOLATE to get the answers inexpensively.  If you need to
change METHOD for this purpose, restart the integration from T_NOW,
Y_NOW by a call to SETUP (note that you must b using the optional
argument Y_NOW to be able to do this). Precede this call to SETUP by a
call to GARBAGE_COLLECT to use memory efficiently. If you wish to
continue toward T_END, just call STEP_INTEGRATE again. The monitor of
this kind of inefficiency will be reset automatically so that the
integration can proceed.

= 3 - A considerable amount of work has been expended in the (primary)
integration. This is measured by counting the number of calls to the
procedure F. At least 5000 calls have been made since the last time this
counter was reset.  Calls to F in a secondary integration for global
error assessment are not counted in this total.  If you wish to continue
towards T_END, just call STEP_INTEGRATE again. The counter measuring
work will be reset to zero automatically.

= 4 - It appears that this problem is "stiff".  The methods implemented
in STEP_INTEGRATE can solve such problems, but they are inefficient.
You should change to an integrator based on methods appropriate for
stiff problems.  If you want to continue toward T_END, just call
STEP_INTEGRATE again. The stiffness monitor will be reset automatically.

    "HARD FAILURE"

= 5 - It does not appear possible to achieve the accuracy specified by
TOLERANCE and THRESHOLDS in the call to SETUP with the precision
available on this computer and with this order of METHOD.  You cannot
continue integrating this problem. A higher order for METHOD, if
possible, will permit greater accuracy with this precision.  To increase
the order of METHOD and/or continue with larger values of TOLERANCE
and/or THRESHOLDS, restart the integration from T_NOW, Y_NOW by a call
to SETUP (note that you must b using the optional argument Y_NOW to be able
to do this). Precede this call to SETUP by a call to GARBAGE_COLLECT to use
memory efficiently.

= 6 - The global error assessment may not be reliable beyond the current
integration point T_NOW. This may occur because either too little or too
much accuracy has been requested or because f is not smooth enough for
values of t near T_NOW and current values of the solution. The integration
cannot be continued.  This return does not mean that you cannot integrate
past T_NOW, rather that you cannot do it with ERROR_ASSESS = .TRUE..
However, it may also indicate problems with the primary integration. You
may continue the integration by restarting with a call to SETUP. Precede
this call to SETUP by a call to GARBAGE_COLLECT to use memory
efficiently. **

Statistics of the performance of STEP_INTEGRATE are available after any
return from STEP_INTEGRATE by a call to the procedure STATISTICS. If
ERROR_ASSESS was set .TRUE., global error assessment is available after
any return from STEP_INTEGRATE by a call to the procedure GLOBAL_ERROR.

After a hard failure (FLAG = 5 or 6) the diagnostic procedures STATISTICS
and GLOBAL_ERROR may be called only once. Other procedures from RKSUITE_90
may not be called at all, except SETUP to restart the integration. Precede
this call to SETUP by a call to GARBAGE_COLLECT to use memory efficiently.

---------------Description of Subroutine RESET_T_END--------------------------

                SUBROUTINE RESET_T_END(COMM,T_END_NEW)

In the description of STEP_INTEGRATE it is explained how to get answers at
specific values of the independent variable by resetting T_END.  SETUP
could be used to reset T_END, but there are good reasons for calling
RESET_T_END for this specific task:

* RESET_T_END is simpler to use.

* RESET_T_END is much more efficient than SETUP because it only resets the
value of a variable whereas SETUP completely restarts the integration.

The integration proceeds from T_START in the direction of T_END, and at
present is at T_NOW.  To change T_END to a new value T_END_NEW, just call
RESET_T_END with T_END_NEW as the argument.  You must continue integrating
in the same direction, so the sign of (T_END_NEW - T_NOW) must be the same
as the sign of (T_END - T_START). To change direction of integration you
must restart by a call to SETUP. Precede this call to SETUP by a call to
GARBAGE_COLLECT to use memory efficiently.  RESET_T_END cannot be called
after a call to RANGE_INTEGRATE.

ARGUMENTS

COMM - type("RK_COMM"), INTENT(INOUT)
Used to communicate information between calls to the procedures in
RKSUITE_90. The contents of COMM are private. **

T_END_NEW - type(independent variable), INTENT(IN)
The new value of T_END.
Constraints: sign(T_END_NEW - T_NOW) = sign(T_END - T_START).  T_END
must be clearly distinguishable from T_NOW in the precision available. **

The call to RESET_T_END is monitored. Any error is catastrophic. An
error message is written to the output channel OUTPUT_CHANNEL (even if
MESSAGE = .FALSE.), and the program STOPs.

--------------End of Description of Subroutine RESET_T_END--------------------

-------------------Description of Subroutine INTERPOLATE---------------------

  RECURSIVE SUBROUTINE INTERPOLATE(COMM,F,T_WANT,Y_WANT,YDERIV_WANT)

In the description of STEP_INTEGRATE it is explained that when
integrating with METHOD = `L' or `M', answers can be obtained
inexpensively by interpolation.  Procedure INTERPOLATE is provided for
this purpose.  Within the span of each step the solution is approximated
by a polynomial of degree 3 when METHOD = `L' and a polynomial of degree
6 when METHOD = `M'.  The polynomials can be evaluated anywhere, but the
theory assures accurate approximations for the solution and its first
derivative only within the span of the current step, or very close to
it.  The interpolants for successive steps connect to form a piecewise
polynomial approximation over the whole interval of integration that is
continuous and has a continuous derivative (in the precision available).

With METHOD = `L', the interpolant uses just solution and derivative
information returned after calls to STEP_INTEGRATE. The matter is
slightly more complicated and expensive with METHOD = `M'.  In the
latter case additional calls to function F are needed to initialize the
computation.  Although more expensive than for METHOD = `L', this extra
cost is incurred only on those steps where you require interpolation,
and then only once per step, no matter how many answers you require in
the span of the step.  In either case it is far more efficient to let
the integrator work with the largest step size that will yield the
desired accuracy and obtain answers by interpolation than to obtain
answers by reducing the step size so as to step to the points where the
answers are desired.

INTERPOLATE is called after a successful step by STEP_INTEGRATE from a
previous value of T_NOW, called T_OLD below, to the current value of
T_NOW to get an answer at T_WANT.  You can specify any value of T_WANT
you wish, but specifying a value outside the interval [T_OLD,T_NOW],
called "extrapolation", is likely to yield answers with unsatisfactory
accuracy.

Warning: You cannot call INTERPOLATE after a return from STEP_INTEGRATE
with any kind of failure.  You cannot call INTERPOLATE when you are
using RANGE_INTEGRATE.

ARGUMENTS

COMM - type("RK_COMM"), INTENT(INOUT)
Used to communicate information between calls to the procedures in
RKSUITE_90. The contents of COMM are private. **

Because INTERPOLATE may need to evaluate the differential equations, it
must be supplied with the name of the function you provided to
STEP_INTEGRATE for evaluating the differential equations.

FUNCTION F(T,Y)
T - type(independent variable), INTENT(IN)
Y - type(dependent variable), shape(Y_START), INTENT(IN)
F - type(dependent variable), shape(Y_START)
Given input values of the independent variable T and the solution Y,
evaluate the differential equations for the derivative and return the
result in F. **

T_WANT - type(independent variable), INTENT(IN)
The value of the independent variable where a solution is desired. **

The interpolant is to be evaluated at T_WANT to approximate the solution
and/or its first derivative there.

Y_WANT - type(dependent variable), shape(Y_START), OPTIONAL, INTENT(OUT)
Approximation the true solution at T_WANT. **

YDERIV_WANT - type(dependent variable), shape(Y_START), OPTIONAL, INTENT(OUT)
Approximation to the first derivative of the true solution at T_WANT. **

If neither of Y_WANT and YDERIV_WANT is present, then the call to
INTERPOLATE results in the coefficients of the interpolant being initialized.

The call to INTERPOLATE and the data input are monitored. Any error is
catastrophic. An error message is written to the output channel
OUTPUT_CHANNEL (even if MESSAGE = .FALSE.), and the program STOPs.

--------------End of Description of Subroutine INTERPOLATE------------------

---------------Description of Subroutine GARBAGE_COLLECT--------------------

                 SUBROUTINE GARBAGE_COLLECT(COMM)

If you wish to integrate a number of differential equations in
succession in a single program, between calls you should deallocate the
memory and nullify the pointers used by COMM. Procedure GARBAGE_COLLECT
is provided for this purpose.

COMM - type("RK_COMM"), INTENT(INOUT)
Used to communicate information between calls to the procedures in
RKSUITE_90. The contents of COMM are private. **

----------------End of RKSUITE_90 Subroutine Documentation-------------------

-----------------------------ACKNOWLEDGEMENTS-------------------------------

P.J. Prince and J.R. Dormand of the University of Cleveland (UK)
developed one of the pairs of Runge-Kutta formulas used in RKSUITE_90
and P. Bogacki of Old Dominion University and L.F. Shampine developed
the others.  We are grateful for the assistance these friends and
colleagues gave us in implementing their formulas.  We also wish to
thank G. Kraut of the University of Texas at Tyler for her meticulous
testing of the methods in the Fortran 77 version of RKSUITE.

NATO Scientific Affairs Division (Grant 898/83) funded early joint work
of I. Gladwell and L.F. Shampine that led to the development of RKSUITE.
R.W. Brankin's involvement was entirely funded by the Numerical
Algorithms Group Ltd. Some of L.F. Shampine's research on basic
algorithms used later in RKSUITE was supported in part by the Applied
Mathematical Sciences program of the Office of Energy Research of the
U.S. Department of Energy.  Development of RKSUITE_90 was partly funded
by NATO grant CRG 920037.

--------------------------------REFERENCES-----------------------------------

Some references describe the formulas and algorithms used in RKSUITE.
Others describe the design, implementation, and testing of codes based
on explicit Runge-Kutta formulas and the development of additional
capabilities that played a more-or-less direct role in the development
of RKSUITE. Those publications directly pertaining to RKSUITE_90 are
marked (**). Those that played a significant part in the design choices
are marked (*).

C.A. Addison, W.H. Enright, P.W. Gaffney, I. Gladwell and P.M. Hanson, "A
Decision Tree for the Numerical Solution of Initial Value Ordinary
Differential Equations",  ACM Trans. on Math. Soft., 17 (1991), 1-10.

(*) P. Bogacki and L.F. Shampine, "A 3(2) Pair of Runge-Kutta Formulas",
Appl.  Math. Lett., 2 (1989) 321-325.
Note: Derives the (2,3) pair implemented in the Fortran 77 RKSUITE and in
RKSUITE_90

(*) P. Bogacki and L.F. Shampine, "An Efficient Runge-Kutta (4,5) Pair",
Rept.  89-20, Math. Dept., Southern Methodist University, Dallas, Texas,
USA, 1989.
Note: Derives the (4,5) pair implemented in the Fortran 77 RKSUITE and in
RKSUITE_90

R.W. Brankin, J.R. Dormand, I. Gladwell, P.J. Prince and W.L. Seward, "A
Runge-Kutta-Nystrom Code",  ACM Trans. on Math. Soft., 15 (1989) 31-40.

(**) R.W. Brankin and I. Gladwell, "A Fortran 90 ODE Solver", pp. 363-376 of
"Annals of Numer. Math., 1 (Proceedings of SCADE '93)" (ed. P. Sharp),
J.C.Baltzer ag Science Publishers, 1994.
Note: Describes Release 0 of RKSUITE_90

(**) R.W. Brankin, I. Gladwell and L.F. Shampine, "RKSUITE: a Suite of
Runge-Kutta Codes for the Initial Value Problem for ODEs", Softreport
92-S1, Math. Dept., Southern Methodist University, Dallas, Texas, U.S.A,
1991, (also available by anonymous ftp and from netlib).
Note: Contains the software and documentation for the Fortran 77 RKSUITE

(**) R.W. Brankin, I. Gladwell and L.F. Shampine, "RKSUITE: A Suite of
Explicit Runge-Kutta Codes", pp. 41-53 of "Contributions to Numerical
Mathematics" (ed. R.P. Agarwal), WSSIAA 2, World Scientific Press, 1993.
Note: Discusses the design philosophy and implementation of the Fortran 77
RKSUITE

R.W. Brankin and I. Gladwell, "Using Shape Preserving Local Interpolants
for Plotting Solutions of Ordinary Differential Equations", IMA J. of
Numer. Anal., 9 (1989) 555-566.

R.W. Brankin, I. Gladwell and L.F. Shampine, "Starting Adams and BDF Codes
at Optimal Order", J. Comp. Appl. Math., 21 (1988) 357-368.

I. Gladwell, "Initial Value Routines in the NAG Library", ACM Trans. on
Math. Soft., 5 (1979) 386-400.

I. Gladwell, J.A.I. Craigie and C.R. Crowther, "Testing Initial Value
Routines as Black Boxes", Numer. Anal. Rept. 34, Math. Dept., Univ. of
Manchester, U.K., 1979.

I. Gladwell, M. Berzins and M. Brankin, "Design of Stiff Integrators in
the NAG Library", SIGNUM Newsletter, 23 (1988) 16-23.

(*) I. Gladwell, L.F. Shampine, L.S. Baca and R.W. Brankin, "Practical Aspects
of Interpolation with Runge-Kutta Codes",  SIAM J. Sci., Stat. Comp., 8
(1987) 322-341.
Note: Discusses types of interpolation strategies employed in the Fortran
77 RKSUITE and in RKSUITE_90

(*) I. Gladwell, L.F. Shampine and R.W. Brankin, "Automatic Selection of
the Initial Step Size for an ODE Solver",  J. Comp. Appl. Math., 18 (1987)
175-192.
Note: Presents early version of starting step size strategy implemented in
the Fortran 77 RKSUITE and in RKSUITE

I. Gladwell, L.F. Shampine and R.W. Brankin, "Locating Special Events When
Solving ODEs",  Appl. Math. Lett.,  1 (1988) 153-156.

(**) G. Kraut, "A Comparison of RKSUITE with Runge-Kutta Codes from the
IMSL, NAG and SLATEC Libraries", Report 91-6, Math. Dept., Southern
Methodist University, Dallas, Texas, U.S.A., 1991.
Note: Presents efficiency tests of formulas implemented in the Fortran 77
RKSUITE and in RKSUITE_90 in comparison with formulas in the most widely
used current ODE codes

(*) P.J. Prince and J.R. Dormand, " High Order Embedded Runge-Kutta
Formulae", J. Comput. Appl. Math., 7 (1981), 67-85.
Note: Derives the (7,8) pair implemented in the Fortran 77 RKSUITE and in
RKSUITE_90

L.F. Shampine, "Local Extrapolation in the Solution of Ordinary
Differential Equations", Math. Comp., 27 (1973) 91-97.

L.F. Shampine, "Limiting Precision in Differential Equation Solvers",
Math.  Comp., 28 (1974) 141-144.

L.F. Shampine, "Storage Reduction for Runge-Kutta Codes", ACM Trans. on
Math. Soft., 5 (1979) 245-250.

L.F. Shampine, "Stiffness and Non-Stiff Differential Equation Solvers II:
Detecting Stiffness with Runge-Kutta Methods", ACM Trans. on Math. Soft.,
3 (1977) 44-53.

L.F. Shampine, "Local Error Control in Codes for Ordinary Differential
Equations", Appl. Math. Comp., 3 (1977) 189-210.

L.F. Shampine, "Limiting Precision in Differential Equation Solvers II:
Sources of Trouble and Starting a Code", Math. Comp., 32 (1978) 1115-1122.

L.F. Shampine, "Lipschitz Constants and Robust ODE Codes", pp. 427-449 in
J.T. Oden, ed., Computational Methods in Nonlinear Mechanics,
North-Holland, Amsterdam, 1980.

L.F. Shampine, "Estimating the Cost of Output in ODE Codes", Matematica
Aplicada e Computacional, 2 (1983) 157-169.

L.F. Shampine, "Stiffness and the Automatic Selection of ODE Code", J.
Comp. Phys., 54 (1984) 74-86.

L.F. Shampine, "Stability of Explicit Runge-Kutta Methods", Comp. & Maths.
with Applics., 10 (1984) 419-432.

L.F. Shampine, "Measuring Stiffness", Appl. Numer. Math., 1 (1985)
107-119.

L.F. Shampine, "The Step Sizes Used by One-Step Codes for ODEs", Appl.
Numer. Math., 1 (1985) 95-106.

L.F. Shampine, "Interpolation for Runge-Kutta Methods", SIAM J. Numer.
Anal., 22 (1985) 1014-1027.

L.F. Shampine, "Global Error Estimation with One-Step Methods", Comp. &
Maths. with Applics., 12A (1986) 885-894.

L.F. Shampine, "Some Practical Runge-Kutta Formulas", Math. Comp., 46
(1986) 135-150.

L.F. Shampine, "Interpolation for Variable Order Runge-Kutta Methods",
Comp. & Maths. with Applics., 14 (1987) 255-260.

L.F. Shampine, "Tolerance Proportionality in ODE Codes", pp. 118-136 in
Numerical Methods in ODEs, A. Bellen et al., eds., Lecture Notes in Math.,
1386, Springer, Berlin, 1989.

(**) L.F. Shampine, "Diagnosing Stiffness for Runge-Kutta Methods", SIAM J.
Sci., Stat. Comput., 12 (1991) 260-272.
Note: Presents stiffness detection strategy used in the Fortran 77 RKSUITE
and algorithmic base for the stiffness test in RKSUITE_90.

L.F. Shampine and L.S. Baca, "Fixed vs. Variable Order Runge-Kutta", ACM
Trans. on Math. Soft., 12 (1986) 1-23.

L.F. Shampine, S.M. Davenport and H.A. Watts, " Comparison of Some Codes
for the Initial Value Problem for Ordinary Differential Equations", pp.
349-353 in Numerical Solutions of Boundary Value Problems for Ordinary
Differential Equations, A. K. Aziz, ed., Academic, New York,1975.

L.F. Shampine, S.M. Davenport and H.A. Watts, "Solving Nonstiff Ordinary
Differential Equations -- the State of the Art", SIAM Review, 18 (1976)
376-411.

(*) L.F. Shampine and I. Gladwell, "The Next Generation of Runge-Kutta
Codes", in Computational Ordinary Differential Equations, J.R.Cash and
I.Gladwell, eds., IMA Conference Series, New Series 39, Clarendon Press,
Oxford, 1992.
Note: Outlines the requirements and design of the Fortran 77 RKSUITE

L.F. Shampine, I. Gladwell and R.W. Brankin, "Reliable Solution of Special
Root Finding Problems for ODE's",  ACM Trans. on Math. Soft., 17 (1991)
11-25.

L.F. Shampine and M.K. Gordon, "Numerical Solution of Ordinary
Differential Equations: the Initial Value Problem", W. H. Freeman and Co.,
San Francisco, 1975.

L.F. Shampine, M.K. Gordon and J.A. Wisniewski, "Variable order
Runge-Kutta codes", pp. 83-101 in Computational Techniques for Ordinary
Differential Equations, I. Gladwell and D.K. Sayers, eds., Academic,
London, 1980.

L.F. Shampine and H.A. Watts, "Comparing Error Estimators for Runge-Kutta
methods", Math. Comp., 25 (1971) 445-455.

L.F. Shampine and H.A. Watts, "Global Error Estimation for Ordinary
Differential Equations", ACM Trans. on Math. Soft., 2 (1976) 172-186.

L.F. Shampine and H.A. Watts, "The Art of Writing a Runge-Kutta Code, Part
I", in Mathematical Software III, J. R. Rice, ed., Academic, New York,
1977.

L.F. Shampine and H.A. Watts, "The Art of Writing a Runge-Kutta Code, II",
Appl. Math. Comp., 5 (1979) 93-121.

(*) H.A. Watts, "Step Size Control in Ordinary Differential Equation
Solvers", Trans. Soc. for Computer Simulation, 1 (1984), 15-25.
Note: Gives earlier version of the step size stragety implemented in
Fortran 77 RKSUITE and in RKSUITE_90

************************ End of rksuite_90.doc *******************************
