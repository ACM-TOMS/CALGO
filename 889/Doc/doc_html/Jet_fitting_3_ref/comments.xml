<manual_tools_output>

<package id="Jet_fitting_3_ref">
<refpage id="DataKernel">
  <localscope></localscope>
  <refcat>Concept</refcat>
  <globalscope></globalscope>
  <definition>DataKernel</definition>
  <item>
    <kind>nested_type</kind>
    <name>FT</name>
    <comment>The scalar type.</comment>
  </item>
  <item>
    <kind>nested_type</kind>
    <name>Point_3</name>
    <comment>The  point type.</comment>
  </item>
  <item>
    <kind>nested_type</kind>
    <name>Vector_3</name>
    <comment>The vector  type.</comment>
  </item>
</refpage>


<refpage id="Lapack_svd">
  <localscope></localscope>
  <refcat>Class</refcat>
  <globalscope>CGAL::</globalscope>
  <definition>Lapack_svd</definition>
</refpage>


<refpage id="LocalKernel">
  <localscope></localscope>
  <refcat>Concept</refcat>
  <globalscope></globalscope>
  <definition>LocalKernel</definition>
  <item>
    <kind>nested_type</kind>
    <name>FT</name>
    <comment>The scalar type.</comment>
  </item>
  <item>
    <kind>nested_type</kind>
    <name>Point_3</name>
    <comment>The  point type.</comment>
  </item>
  <item>
    <kind>nested_type</kind>
    <name>Vector_3</name>
    <comment>The vector  type.</comment>
  </item>
  <item>
    <kind>nested_type</kind>
    <name>LKMatrix</name>
    <comment>For dimension 2 and 3 square matrices.</comment>
  </item>
  <item>
    <kind>nested_type</kind>
    <name>Aff_transformation</name>
    <comment>For 3d affine tranformation.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>FT Lsqrt( FT x);</name>
    <comment></comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>LKMatrix inverse (LKMatrix M, FT&amp; D);</name>
    <comment>returns the inverse
  matrix of M. More precisely, 1/D times the matrix returned is the
  inverse of M.  Precondition: \ccc{determinant(M) != 0}.  Precondition: M
  is square.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>int sign_of_determinant (LKMatrix M);</name>
    <comment>returns the sign of
  the determinant of M.  Precondition: M is square.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>void eigen_symmetric (const FT *mat, const int n, FT *eigen_vectors, FT *eigen_values);</name>
    <comment></comment>
  </item>
</refpage>


<refpage id="Monge_form">
  <localscope>Monge_via_jet_fitting&lt; DataKernel, LocalKernel, SvdTraits&gt;::</localscope>
  <refcat>Class</refcat>
  <globalscope>CGAL::</globalscope>
  <definition>Monge_form</definition>
  <item>
    <kind>typedef</kind>
    <name>typedef typename DataKernel::FT FT;</name>
    <comment></comment>
  </item>
  <item>
    <kind>typedef</kind>
    <name>typedef typename DataKernel::Point_3 Point_3;</name>
    <comment></comment>
  </item>
  <item>
    <kind>typedef</kind>
    <name>typedef typename DataKernel::Vector_3 Vector_3;</name>
    <comment></comment>
  </item>
  <item>
    <kind>constructor</kind>
    <name>Monge_form();</name>
    <comment>default constructor.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>Point_3 origin();</name>
    <comment>Point on the fitted surface where
differential quantities are computed.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>Vector_3 maximal_principal_direction();</name>
    <comment></comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>Vector_3 minimal_principal_direction();</name>
    <comment></comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>Vector_3 normal_direction();</name>
    <comment></comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>FT principal_curvatures(size_t i);</name>
    <comment>$i=0$ for the maximum and $i=1$ for the minimum.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>FT third_order_coefficients(size_t i);</name>
    <comment>$0 \leqi \leq3$</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>FT fourth_order_coefficients(size_t i);</name>
    <comment>$0 \leqi \leq4$</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>void comply_wrt_given_normal(const Vector_3 given_normal);</name>
    <comment>change principal basis and Monge coefficients so that the
given\_normal and the Monge normal make an acute angle.\\ If
given\_normal.monge\_normal $&lt; 0$ then change the orientation: if
$z=g(x,y)$ in the basis (d1,d2,n) then in the basis (d2,d1,-n)
$z=h(x,y)=-g(y,x)$.</comment>
  </item>
</refpage>


<refpage id="Monge_via_jet_fitting">
  <localscope></localscope>
  <refcat>Class</refcat>
  <globalscope>CGAL::</globalscope>
  <definition>Monge_via_jet_fitting&lt;DataKernel, LocalKernel, KernelConverters, SvdTraits&gt;</definition>
  <item>
    <kind>typedef</kind>
    <name>typedef DataKernel Data_kernel;</name>
    <comment></comment>
  </item>
  <item>
    <kind>typedef</kind>
    <name>typedef LocalKernel Local_kernel;</name>
    <comment></comment>
  </item>
  <item>
    <kind>typedef</kind>
    <name>typedef typename Local_kernel::FT FT;</name>
    <comment></comment>
  </item>
  <item>
    <kind>typedef</kind>
    <name>typedef typename Local_kernel::Vector_3 Vector_3;</name>
    <comment></comment>
  </item>
  <item>
    <kind>typedef</kind>
    <name>typedef typename DataKernel::Vector_3 DVector_3;</name>
    <comment></comment>
  </item>
  <item>
    <kind>nested_type</kind>
    <name>Monge_form</name>
    <comment>see  the section below.</comment>
  </item>
  <item>
    <kind>constructor</kind>
    <name>Monge_via_jet_fitting();</name>
    <comment>default constructor</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>template &lt;class InputIterator&gt; Monge_form operator()(InputIterator begin, InputIterator end, size_t d, size_t d');</name>
    <comment>This operator performs all the computations. The $N$ input points are
  given by the \ccc{InputIterator} parameters which value-type are
  \ccc{Data_kernel::Point_3}, \ccc{d} is the degree of the fitted
  polynomial, \ccc{d'} is the degree of the expected Monge
  coefficients.  \ccPrecond$N \geqN_{d}:=(d+1)(d+2)/2$, $1 \leqd'
  \leq\min(d,4) $.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>template &lt;class InputIterator&gt; Monge_form operator()(InputIterator begin, InputIterator end, size_t d, size_t d', DVector_3 vx, DVector_3 vy, DVector_3 vz);</name>
    <comment>This operator
  performs the same computations as the former. The difference is that
  the coordinate system in which the fitting is performed is given by
  the orthonormal basis (vx, vy, vz).</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>FT condition_number();</name>
    <comment>condition number of the linear fitting system.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>std::pair&lt;FT, Vector_3&gt; pca_basis(size_t i);</name>
    <comment>pca eigenvalues and eigenvectors, the pca\_basis has always 3 such pairs.
 Precondition : $i$ ranges from 0 to 2.</comment>
  </item>
</refpage>


<refpage id="SvdTraits">
  <localscope></localscope>
  <refcat>Concept</refcat>
  <globalscope></globalscope>
  <definition>SvdTraits</definition>
  <item>
    <kind>nested_type</kind>
    <name>FT</name>
    <comment>The scalar type.</comment>
  </item>
  <item>
    <kind>nested_type</kind>
    <name>Vector</name>
    <comment>The vector type.</comment>
  </item>
  <item>
    <kind>nested_type</kind>
    <name>Matrix</name>
    <comment>The matrix type.</comment>
  </item>
  <item>
    <kind>constructor</kind>
    <name>Vector(size_t n);</name>
    <comment>initialize all the elements of the vector to zero.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>size_t size();</name>
    <comment></comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>FT operator()(size_t i);</name>
    <comment>return the $i^{th}$ entry, $i$ from $0$ to $size()-1$.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>void set(size_t i, const FT value);</name>
    <comment>set the $i^{th}$ entry to $value$.</comment>
  </item>
  <item>
    <kind>constructor</kind>
    <name>Matrix(size_t n1, size_t n2);</name>
    <comment>initialize all the entries of the matrix to zero.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>size_t number_of_rows();</name>
    <comment></comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>size_t number_of_columns();</name>
    <comment></comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>FT operator()(size_t i, size_t j);</name>
    <comment>return the entry at row $i$ and column $j$, $i$ from $0$ to \ccc{number_of_rows - 1}, 
$j$ from $0$ to \ccc{number_of_columns - 1}.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>void set(size_t i, size_t j, const FT value);</name>
    <comment>set the entry at row $i$ and column $j$ to $value$.</comment>
  </item>
  <item>
    <kind>memberfunction</kind>
    <name>FT solve(Matrix&amp; M, Vector&amp; B);</name>
    <comment>Solves the system $MX=B$ (in the least square sense if $M$ is not
square) using a singular value decomposition and returns the condition
number of $M$. The solution is stored in $B$.</comment>
  </item>
</refpage>



</package>
</manual_tools_output>
