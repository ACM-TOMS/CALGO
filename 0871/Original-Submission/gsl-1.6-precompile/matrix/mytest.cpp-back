#include "gsl_matrix.h"

int main(){
  MpIeee::fpEnv.setRadix(2);
  
  //testing own matrix allocation
  MpIeee* myMat = new MpIeee[9];
  
  MpIeee counter("0");
  cout << "showing myMat="<<flush;
  for( int row=0;row<3;row++){
    for( int col = 0; col<3; col++){
      myMat[row*3+col]=counter++;
      cout << myMat[row*3+col] << "\t" << flush;
    }
    cout << endl;
  }


  //putting it into a block myself
  //...
  
   gsl_block* block = new gsl_block();
   block->size=9;
   block->data=myMat;
   
   gsl_matrix* m = new gsl_matrix();
   
   m->data = block->data;
   m->size1 = 3;
   m->size2 = 3;
   m->tda = 3; //this is the trailing dimension (gsl uses row*tda + col to get the index see matrix_source.c)
   m->block = block;
   m->owner = 1;

  cout << "showing m="<<flush;  
  for( int row=0;row<3;row++){
    for( int col = 0; col<3; col++){
      cout << gsl_matrix_get( m, row, col ) << "\t" << flush;
    }
    cout << endl;
  }
  
  gsl_matrix_set_identity( m );
  
  cout << "showing m="<<flush;  
  for( int row=0;row<3;row++){
    for( int col = 0; col<3; col++){
      cout << gsl_matrix_get( m, row, col ) << "\t" << flush;
    }
    cout << endl;
  }
  
  

  //using gsl matrix alloc functions
  gsl_matrix* M=gsl_matrix_alloc( 3,3 ); //allocate 3 by 3
  cout << "allocated M(3,3)"<<endl;


//  this Aborts
//  gsl_matrix_set_identity( M ); //make it the identity matrix
//  cout << "set M to identity" << endl;

  gsl_matrix_set_zero( M ); //make zero matrix, also Abort :(
  cout << "set M to zeros" << endl;

  cout << "showing M="<<flush;  
  for( int row=0;row<3;row++){
    for( int col = 0; col<3; col++){
      cout << gsl_matrix_get( M, row, col ) << "\t" << flush;
    }
    cout << endl;
  }  
  return 0;
}


