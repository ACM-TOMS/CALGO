<!-- Generated with BaseML v0.4b -->
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

     <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
       <head>         <meta content="application/xhtml+xml; charset=UTF-8" http-equiv="content-type"/>         <meta content="walter.schreppers@ua.ac.be" name="author"/>         <meta content="author" name="generator"/>                  <link title="Homepage" href="./index.html" rel="top"/>         <link title="Up" href="./index.html" rel="up"/>         <link title="First page" href="./index.html" rel="first"/>         <link title="Previous page" href="./index.html" rel="previous"/>         <link title="Next page" href="./index.html" rel="next"/>         <link title="Last page" href="./index.html" rel="last"/>         <link title="Table of contents" href="./index.html" rel="toc"/>         <link title="Site map" href="./index.html" rel="index"/>         <link media="screen" href="css/screen.css" type="text/css" rel="stylesheet"/>         <link media="screen" href="css/colors.css" type="text/css" rel="stylesheet"/>         <link media="print" href="css/print.css" type="text/css" rel="stylesheet"/>         <title>CANT Research Group -> Precompiler ->  Examples  </title>       </head>     <body>
    	<div id="top"></div>
          <div id="header">      <div id="topbar">        <span class="nodisplay">Related sites:</span>        <a href="http://www.ua.ac.be/">University of Antwerp</a> |
        <a href="http://www.win.ua.ac.be/">Department of Mathematics and Computer Science</a>      </div>      <div id="title">        <h1>CANT Research Group</h1>      </div>      <div id="menubar">        <span class="nodisplay">Navigation:</span>        <a href="index.html">Precompiler</a>      </div>    </div>        <div id="sidebar">      
      <div>        <p class="title">Precompiler</p>        <ul>                 <li><a href="index.html">&rsaquo; Introduction</a></li>              <li><a href="download.html">&rsaquo; Download</a></li>              <li><a href="usage.html">&rsaquo; Usage</a></li>                <li><a class="thispage" href="examples.html">&rsaquo; Examples</a></li>            <li><a href="gsl-conversion.html">&rsaquo; GSL Conversion</a></li>              <li><a href="arprec.html">&rsaquo; ARPREC Example</a></li>                </ul>      </div>      <div id="related">        <p class="title">Navigate page</p>        <ul>            <li><a href="#ex1">&rsaquo; Example 1</a></li>          <li><a href="#ex2">&rsaquo; Example 2</a></li>          <li><a href="#ex3">&rsaquo; Example 3</a></li>          <li><a href="#ex4">&rsaquo; Example 4</a></li>          <li><a href="#ex5">&rsaquo; Example 5</a></li>          <li><a href="#ex6">&rsaquo; Example 6</a></li>          <li><a href="#ex7">&rsaquo; Example 7</a></li>          <li><a href="#ex8">&rsaquo; Example 8</a></li>          <li><a href="#ex9">&rsaquo; Example 9</a></li>              </ul>      </div>    </div>            <div id="content">          
  <h1 id="ex">Examples</h1>    <p>This section contains various examples. On the <a href="usage.html">Usage</a> page 
        all command line options are given.
    </p>  <br/><br/>      <a title="Go to the top of this page" href="#top" class="topofpage2">^ TOP</a> 
  <h2 id="ex1">Example 1 : Using the -nofor and -noprintf options</h2>    <p>      Consider the C++ code <a href="files/in.cpp">source code 'in.cpp'</a>:
    </p>    <pre>int main(){
  float b;
  for(float a=0;a&lt;10;a=a+0.5){
    b=a*2;
    printf("a=%f",a);
  }
  return 0;
}
    </pre>    <p>      We can use the precompiler to convert this code with <a href="files/mpieee.xml">the conversion file for the MpIeee datatype</a>: 
    </p>    <pre>./precompile -x mpieee.xml in.cpp out.cpp</pre>    <p>The resulting output file out.cpp now contains the following code:</p>    <pre>int main(){
  MpIeee b;
  for(MpIeee a= MpIeee( "0" );a&lt;MpIeee( "10" );a=a+MpIeee( "0.5" )){
    b=a*MpIeee( "2" );
    {cout&lt;&lt;"a="&lt;&lt;setiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;a;
cout.precision(6);cout.fill(' ');cout.width(0);cout.setf(ios::dec,ios::basefield);
cout&lt;&lt;resetiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;"";}
  }
  return 0;
}
    </pre>    <p>       To optimize the loop and thus skip conversion of the loop variable 'a' we use the <a href="usage.html#nofor">-nofor</a> option:
    </p>    <pre>./precompile -x mpieee.xml in.cpp out.cpp -nofor</pre>    <p>The resulting output:</p>    <pre>int main(){
  MpIeee b;
  for(float a=0;a&lt;10;a=a+0.5){
    b=a*MpIeee( "2" );
    {cout&lt;&lt;"a="&lt;&lt;setiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;a;
cout.precision(6);cout.fill(' ');cout.width(0);cout.setf(ios::dec,ios::basefield);
cout&lt;&lt;resetiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;"";}
  }
  return 0;
}
  </pre><p>  Now we do have an unchecked conversion in the assignment to the MpIeee variable b. Here the precompiler will give a warning:</p>  <pre>Warning : Assignment or comparison to type MpIeee may contain wrong conversion for 'a' at line: 8</pre><p>  To avoid conversion of the printf statements, use the <a href="usage.html#noprintf">-noprintf</a> option:</p>  <pre>./precompile -x mpieee.xml in.cpp out.cpp -nofor -noprintf</pre><p>  The resulting output code is:</p>  <pre>int main(){
  MpIeee b;
  for(float a=0;a&lt;10;a=a+0.5){
    b=a*MpIeee( "2" );
    printf("a=%f",a);
  }
  return 0;
}
  </pre>    <br/><br/>      <a title="Go to the top of this page" href="#top" class="topofpage2">^ TOP</a> 
  <h2 id="ex2">Example 2 : The preparse option</h2>  <p>Specific functions or variables can be skipped using a skip configuration file. To get a list
        of variables and functions which are candidates for skipping we use the <a href="usage.html#preparse">-preparse</a> 
	option:
  </p><pre>./precompile -x mpieee.xml in.cpp variables.out -preparse</pre>  <p>The variables.out file for the C++ program in <a href="#ex1">Example 1</a> :</p><pre>/               globD           double
main            b               float
main            a               float</pre><p>Every variable is represented in one row. The first column gives its function name or / if it's a global variable. The second column gives the variable name and
the third column gives the type.</p>  <br/><br/>      <a title="Go to the top of this page" href="#top" class="topofpage2">^ TOP</a> 
  <h2 id="ex3">Example 3 : The constants option</h2>    <p>To identify the used constants in a source file we can use the <a href="usage.html#constants">-constants</a> option:
    </p><pre>./precompile -x mpieee.xml in.cpp constants.out -constants</pre> <p>The constants.out file contains the following information:</p><pre>CONSTANTS IN FILE : 'in.cpp'
constant: '2.2' at line 3, col 14
constant: '0' at line 7, col 15
constant: '10' at line 7, col 19
constant: '0.5' at line 7, col 26
constant: '2' at line 8, col 9
constant: '0' at line 11, col 10</pre><p>This option is used to identify any interesting constants such as mathematical constants. Using the information in
        the constants output file it is easier to replace such mathematical constants by their multiprecision implementations.</p>  <br/><br/>      <a title="Go to the top of this page" href="#top" class="topofpage2">^ TOP</a> 
  <h2 id="ex4">Example 4 : The skip configuration file</h2> <p>Sometimes we want to skip conversion of specific variables or even entire functions.
	To do this we use the <a href="usage.html#skipfile">-c &lt;skip configfile&gt;</a> option.
	The skipconfig file is an XML file.
	Let's say we want to skip variable b in the main function of <a href="files/in.cpp">'in.cpp'</a>.
	We create the following skipconfig file:</p><pre>&lt;document>
  &lt;skip name="example">
    &lt;function name="main"/>
    &lt;variable name="b"/>
  &lt;/skip&gt;<br/>&lt;/document></pre><p>When running the precompiler with this skipconfig file </p><pre>./precompile -x mpieee.xml in.cpp out.cpp -c skip1.conf</pre><p>the variable b will not be converted and the resulting output is</p><pre>...
int main(){
  float  b;
  for(MpIeee a= MpIeee( "0" );a&lt;MpIeee( "10" );a=a+MpIeee( "0.5" )){
    b=a*2;
    {cout&lt;&lt;"a="&lt;&lt;setiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;a;
cout.precision(6);cout.fill(' ');cout.width(0);cout.setf(ios::dec,ios::basefield);
cout&lt;&lt;resetiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;"";}
  }
  return 0;
}</pre><p>To skip every variable in a function, just omit the variable name.</p><pre>&lt;document>
  &lt;skip name="example">
    &lt;function name="main"/>
  &lt;/skip&gt; <br/>&lt;/document></pre><p>When we run the following command:</p><pre>./precompile -c skip2.conf -x mpieee.xml in.cpp out.cpp -noprintf</pre><p>This will result in the output where everything is copied literally except for the globD variable.</p><pre>#include "MpIeee.hh"
#include "ArithmosIO.hh"

#include &lt;stdio.h>

MpIeee globD= MpIeee( "2.2" );

int main(){
  float  b;
  for(float  a= 0;a&lt;10;a=a+0.5){
    b=a*2;
    printf("a=%f",a);
  }
  return 0;
}</pre><p>To skip the global variables like globD we specify an empty function name:</p><pre>&lt;document>
  &lt;skip>
    &lt;function name=""/>
    &lt;variable name="globD"/>
  &lt;/skip><br/>&lt;/document></pre><p>There is one more variation. To skip all variables of a certain name in all functions. You leave out the function tag.
	If we want to skip all variables with the name 'tmp' we would create the following line in our skipconfig file:</p><pre> &lt;skip>&lt;variable name="tmp"/>&lt;/skip></pre>  <br/><br/>      <a title="Go to the top of this page" href="#top" class="topofpage2">^ TOP</a> 
  <h2 id="ex5">Example 5 : The MpIeee specific command line options (expbits, radix, precision, round)</h2><p>We start out with a little example program:</p><pre>#include &lt;stdio.h>

int main(){
  double c=1.0/3.0;
  printf( "c=%f\n",c);
}</pre><p>We want to test this with arithmos and set some settings.
	Let's say we want 4 bits exponent, radix=10, precision=5 and rounding down to zero.
	We will run the precompiler like this:</p><pre>./precompile test.cpp test_out.cpp -x mpieee.xml -expbits 4 -radix 10 -precision 5 -round z -default</pre><p>The resulting converted file in test_out.cpp will look like this:</p><pre>#include &lt;iostream>
#include &lt;iomanip>
using namespace std;

#include "MpIeee.hh"
#include "ArithmosIO.hh"

#include &lt;stdio.h>

int main(){

  MpIeee::fpEnv.setRadix(10);
  MpIeee::fpEnv.setPrecision(5);
  MpIeee::fpEnv.setExponentRange(-6,7);
  MpIeee::fpEnv.setRound(FP_RZ);
  ArithmosIO::setIoMode(ARITHMOS_IO_MPIEEE_DECIMAL);

  MpIeee c= MpIeee( "1.0" )/MpIeee( "3.0" );
  {cout&lt;&lt;"c="&lt;&lt;setiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;c;
cout.precision(6);cout.fill(' ');cout.width(0);cout.setf(ios::dec,ios::basefield);
cout&lt;&lt;resetiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;"\n";}
}</pre><p>  We see the correct settings for MpIeee are set in the main routine and the printf is converted to cout to use with classes.
  We can now quickly experiment with different settings by changing the command line options to experiment with different settings
  using the precompiler to generate different versions of our program until we are satisfied with the result.</p>  <br/><br/>      <a title="Go to the top of this page" href="#top" class="topofpage2">^ TOP</a> 
  <h2 id="ex6">Example 6 : Arithmos specific command line options (exp, outputverbose, outputmpieee)</h2><p>In this example we will use the <a href="usage.html#exp">-exp</a> option to set the exponent range. This is the general version of expbits
where you can specify any L and U for the exponent (L=minimum, U=maximum). The only requirement is U=-L-1 and the values are limited (have to fit in a <b>long int</b>).
We also set some flags using <a href="usage.html#outputverbose">-outputverbose</a> and <a href="usage.html#outputmpieee">-outputmpieee</a> options.
Remember to use the <a href="usage.html#default">-default</a> option so that this is inserted into the <b>main()</b> function.
We run the precompiler on the <a href="files/in.cpp">in.cpp</a> with the following options:</p><pre>./precompile in.cpp out.cpp -x mpieee.xml -outputmpieee pyh -outputverbose -exp -100 99 -default</pre><p>We can see in the resulting <b>out.cpp</b> that the exponent range is set and the 3 flags for mpieee and the general verbose flag is set for the arithmos library:</p><pre>#include &lt;iostream>
#include &lt;iomanip>
using namespace std;

#include "MpIeee.hh"
#include "ArithmosIO.hh"

#include &lt;stdio.h>

MpIeee globD= MpIeee( "2.2" );

int main(){

  MpIeee::fpEnv.setRadix(2);
  MpIeee::fpEnv.setPrecision(24);
  MpIeee::fpEnv.setExponentRange(-100,99);
  MpIeee::fpEnv.setRound(FP_RN);
  ArithmosIO::setIoMode(ARITHMOS_IO_VERBOSE|
			ARITHMOS_IO_MPIEEE_PARAM|
			ARITHMOS_IO_MPIEEE_BINREP|ARITHMOS_IO_MPIEEE_HEXREP );

  MpIeee b;
  for(MpIeee a= MpIeee( "0" );a&lt;MpIeee( "10" );a=a+MpIeee( "0.5" )){
    b=a*MpIeee( "2" );
    {cout&lt;&lt;"a="&lt;&lt;setiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;a;
cout.precision(6);cout.fill(' ');cout.width(0);cout.setf(ios::dec,ios::basefield);
cout&lt;&lt;resetiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;"";}
  }
  return 0;
}</pre>  <br/><br/>      <a title="Go to the top of this page" href="#top" class="topofpage2">^ TOP</a> 
  <h2 id="ex7">Example 7 : The init tag and -init option</h2><p>In the previous 2 examples we showed how the <a href="usage.html@default">-default</a> option was used to insert arithmos
	specific settings. In this example we show how to use the more generic <a href="usage.html#init">-init</a> option.
	The data contained in the given file <a href="files/init.txt">init.txt</a> will be inserted literally
        in the main function. </p><pre>./precompile -x mpieee.xml in.cpp out.cpp -init init.txt </pre><p>As seen in the resulting output file the code in <a href="files/init.txt">init.txt</a> was inserted into the main function.</p><pre>#include &lt;iostream>
#include &lt;iomanip>
using namespace std;

#include "MpIeee.hh"
#include "ArithmosIO.hh"

#include &lt;stdio.h>

MpIeee globD= MpIeee( "2.2" );

int main(){
/*
Some extra initialization code.
*/

MpIeee::setPrecision(20);

  MpIeee b;
  for(MpIeee a= MpIeee( "0" );a&lt;MpIeee( "10" );a=a+MpIeee( "0.5" )){
    b=a*MpIeee( "2" );
    {cout&lt;&lt;"a="&lt;&lt;setiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;a;
cout.precision(6);cout.fill(' ');cout.width(0);cout.setf(ios::dec,ios::basefield);
cout&lt;&lt;resetiosflags((ios::fixed &amp; ios::floatfield))&lt;&lt;"";}
  }
  return 0;
}</pre><p>Apart from using a seperate file, one can also insert extra initialization code using an &lt;init> tag in the <a href="usage.html#configfile">conversion configuration file</a>. 
In our example we would add this tag to the configuration file:</p><pre>&lt;init>
    /*
    Some extra initialization code.
    */
    MpIeee::setPrecision(20);<br/>&lt;/init></pre>  <br/><br/>      <a title="Go to the top of this page" href="#top" class="topofpage2">^ TOP</a> 
  <h2 id="ex8">Example 8 : Custom operation functions</h2>    <p>      The existing operation functions can be found in the execute member of the ConvertConfig class.
      When adding a new operation to the ConvertConfig class be sure to update the ConvertConfig::execute
      member (add another case to the if/else if construction).
      
      </p><pre>      ...
      if( cElem.operation == "toStringConstructor" ) {
        retStr=toStringConstructor( cElem, value );
      }
      else if( cElem.operation == "toConstructor" ) {
        retStr=toConstructor( cElem, value );
      }
      
      --&gt; write the 'else if' for your operation function here &lt;---
      ...
      </pre><p>                                                                                                                   
    </p>    <p>      Short overview of existing operation functions:
      </p>      <table class="bordered">       <tr><th> Operation </th>              <th> Description </th> </tr>       <tr><td> "toStringConstructor" </td>  <td> Calls a string constructor of target with value inside quotes</td></tr>       <tr><td> "toConstructor" </td>        <td> Calls normal constructor of target</td></tr>       <tr><td> "toRational" </td>           <td> Calls a string constructor of target with modified value which is in for "numerator/denomenator"</td></tr>       <tr><td> "toString" </td>             <td> Constructs a std::string from value</td></tr>       <tr><td> "toMatrix" </td>             <td> Specific/custom rule for Mpfr </td></tr>       <tr><td> "typeDef" </td>              <td> Specific/custom rule for MpIeee</td></tr>       <tr><td> "noChange" </td>             <td> Used when you wan't to identify types which don't need a type change</td></tr>       <tr><td> "castIt" </td>               <td> Calls MpIeee specific function to convert to 32bit integer</td></tr>      </table><p>      Assume we want to add our own type of conversion rule called 'callMember'.
      This may be usefull if the target class has some conversion function as a member of its class.
      First we add the following lines to the ConvertConfig::execute member of the precompiler:</p><pre>string ConvertConfig::execute(const ConvertElem& cElem, const string& value){
 ...
    else if( cElem.operation == "callMember" ){
      retStr = callMember( cElem, value );
    }
 ...</pre>  <p>We add the function callMember to the class (by adding some lines to the ConvertConfig.h and ConvertConfig.cpp).
Here is the function implementation:
  </p><pre>string ConvertConfig::callMember( const ConvertElem& cElem, const string& value ){
  return value + "." + cElem.target.keyword + "()";
}</pre><p>We add the new rule to our configuration file:</p><pre> &lt;convert name="to index type">
    &lt;rhs name="rmpieee"/>
    &lt;source name="INDECES"/>
    &lt;operation>callMember&lt;/operation>
  &lt;/convert></pre><p>The operation function callMember is now executed whenever we have an MpIeee on the right hand side and an INDECES type on the left side. 
We test it on the following input file:</p><pre>int main(){
  int a;
  float value=123.4;
  a = value;

  return 0;
}</pre><p>In the assignment a = value, the rule 'callMember' will be executed. And the output looks like this:</p><pre>int main(){
  int a;
  MpIeee value= MpIeee( "123.4" );
  a = value.int();

  return 0;
}</pre><p>This is nice, we added a new type of operation rule and used it. But for this type of rule there is something missing. Let's say the member function to do the
conversion is not called 'int()' but some other name. Without the ability to give an extra argument to the conversion
rules we would have to add a different operation function to the ConvertConfig class. This will have to be done every time the 
conversion member name of the target data type changes.
We improved the precompiler by making some extra modifications which extend the capabilities of our XML conversion configuration files. This
way only the XML file needs to be updated when the target data type changes in some way.</p><p>We added a new public local variable to the ConvertElem class called operationArg.
And an extra line of code in the setOperation member of ConvertElem:</p><pre>void ConvertElem::setOperation(XMLNode::iterator i){
 ...
	operationArg = e->attribute("argument",""); //additional, optional argument for operations
 ...
}</pre><p>And a line in the assignment operator which is also used by the copy constructor </p><pre>ConvertElem& ConvertElem::operator=(const ConvertElem& m){
  ...
  operationArg=m.operationArg;
  ...
}</pre><p> With this extension we can use the following conversion rule:</p><pre>  &lt;convert name="to index type">
    &lt;rhs name="rmpieee"/>
    &lt;source name="INDECES"/>
    &lt;operation argument="toInt()">callMember&lt;/operation> 
  &lt;/convert></pre><p>In other words, it is now possible to give operation rules an extra argument which can be used
in any way desired. Here we use it in our callMember conversion operation to specify the name of the function that we want to call
when converting from INDECES data type to the MpIeee data type.
The callMember implementation in the ConvertConfig class :</p><pre>string ConvertConfig::callMember( const ConvertElem& cElem, const string& value ){
  return value + "." + cElem.operationArg;
}</pre><p>This callMember operation can now be used to call arbitrary member functions of our target class. The operation argument extension
is included in the algorithm submission.
Another example of this extended operation tag is given in the <a href="#ex9">next example</a>.</p><p>The final output, using the new callMember operation function with the argument 'toInt()' :</p><pre>int main(){
  int a;
  MpIeee value= MpIeee( "123.4" );
  a = value.toInt();

  return 0;
}</pre>Here is the configuration file used for this example : <a href="files/precompile.xml">precompile.xml</a>.
  <br/><br/>      <a title="Go to the top of this page" href="#top" class="topofpage2">^ TOP</a> 
  <h2 id="ex9">Example 9 : Writing a custom configuration file.</h2>    <p>  	Up to now we've been using the same configuration file namely the <a href="files/mpieee.xml">mpieee.xml</a>.
	Here we will explain how to write your own configuration file with a little example that demonstrates the precompiler
	can be used for arbitrary type conversions. 
    </p>    <p>        Let's say we have two types we want to use: BigNumber and BigFloat. The former is for big integers and the latter for floating point.
	Let's say we want to convert int, long to BigNumber and we only want double to be converted to BigFloat.
	We define some source tags, in our case for int,long and double. Here is what our new conversion file looks like up to now:
    </p><pre>&lt;?xml version="1.0"?>&lt;document>
  &lt;source name="integer">
    &lt;keyword>long&lt;/keyword>
    &lt;keyword>int&lt;/keyword>
  &lt;/source>

  &lt;source name="floating">
    &lt;keyword> double&lt;/keyword>
  &lt;/source>&lt;/document></pre><p>So we want the integer to be converted into BigNumber and the floating into BigFloat. We add some target types for BigNumber and BigFloat
and 2 conversion rules that do this.</p><pre>&lt;?xml version="1.0"?>&lt;document>
  &lt;source name="integer">
    &lt;keyword>long&lt;/keyword>
    &lt;keyword>int&lt;/keyword>
  &lt;/source>

  &lt;source name="floating">
    &lt;keyword> double&lt;/keyword>
  &lt;/source>

  &lt;target name="bigfloat">
    &lt;keyword>BigFloat&lt;/keyword>
  &lt;/target>

  &lt;target name="bigint">
    &lt;keyword>BigNumber&lt;/keyword>
  &lt;/target>


  &lt;convert>
        &lt;source name="integer"/>
        &lt;target name="bigint"/>
  &lt;/convert>

  &lt;convert>
        &lt;source name="floating"/>
        &lt;target name="bigfloat"/>
  &lt;/convert>&lt;/document></pre><p>Now let's run our custom file on the following example:</p><pre>int main(){
  int a;
  float b;
  long c;
  double d;

  return 0;
}</pre><p>When we use the precompiler with our custom configuration file we get the following output:</p><pre>wschrep@pascal:~/precompiler> ./precompile custom.cpp custom_pre.cpp -x custom.xml -noprintf
wschrep@pascal:~/precompiler> cat custom_pre.cpp
int main(){
  BigNumber a;
  float b;
  BigNumber c;
  BigFloat d;

  return 0;
}</pre><p> We extend our example input source and add an assignment between 2 different types by adding the line:</p><pre>  d=a; </pre><p>This is where the <a href="#ex8">operation functions</a> come in to play. Let's assume there is a member in BigFloat called 'ceil' which returns a BigNumber type. 
We will use the 'callMember' operation function to automate the conversion for such assignments.</p><p>Here is the conversion rule we add to our configuration file:</p><pre>  &lt;convert>
        &lt;target name="bigint"/>
        &lt;target name="bigfloat"/>
        &lt;operation argument="ceil()">callMember&lt;/operation>
  &lt;/convert></pre><p>The output using the new configuration file :</p><pre>int main(){
  BigNumber a;
  float b;
  BigNumber c;
  BigFloat d;

  d=a.ceil();
  return 0;
}</pre><p>The assignment d=a; was changed into d=a.ceil();. Without the last convert rule the precompiler would have given a warning and just copied the assignment literally.
You can run this example yourself with different command line options and/or configuration files and/or input files. 
Here are the files to replicate this example:</p><table class="bordered"><tr><th>File</th><th>Description</th></tr><tr> <td><a href="files/custom.xml">custom.xml</a></td>          <td>Custom configuration file</td></tr><tr> <td><a href="files/custom.cpp">custom.cpp</a></td>          <td>An input file</td></tr><tr> <td><a href="files/custom_pre.cpp">custom_pre.cpp</a></td>  <td>Generated output file</td></tr></table><p>The user can also add a rhs tag as exercise so that a constant assignment to this type is modified. Look at <a href="files/mpieee.xml">a
complete example</a> which contains these rhs tags.</p>  <br/><br/>    </div>                      <div id="footer">           <div class="left">        For questions regarding this website, please contact the
             <a href="mailto:walter.schreppers@ua.ac.be">webmaster</a>.<br/>        Validate the <a href="http://validator.w3.org/check/referer">XHTML</a> and
             <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a> of this page.
           </div>           <br class="nodisplay noprint"/>           <div class="right">          Copyright CANT 2006.<br/><br/>           </div>         </div>       </body>
     </html>
    
<!-- Generated in 0.026996 (virtual) seconds -->
