% ----------------------------------------------------------------------
% S. Martello, D. Pisinger, D. Vigo, E. den Boef, J. Korst
% Algorithms for General and Robot-packable variants of
% the Three-Dimensional Bin Packing Problem
% january, february, March 2003
% ----------------------------------------------------------------------
\documentstyle[12pt,a4wide]{article}
\baselineskip=18pt
\newcommand{\fracs}[2]{{\textstyle \frac{ #1}{ #2}}}


\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{algorithm}{Algorithm}
\newtheorem{property}{Property}
\newenvironment{proof}{\noindent{\bf Proof.}~}{$\Box$\vspace*{1ex} }
\newenvironment{prog*}
 {\begin{tabbing}xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=
 \kill}{\end{tabbing}}


\newcommand{\xbegin}      {\mbox{\bf begin\ }}
\newcommand{\xend}        {\mbox{\bf end}}
\newcommand{\xif}         {\mbox{\bf if\ }}
\newcommand{\xthen}       {\mbox{\bf then\ }}
\newcommand{\xelse}       {\mbox{\bf else\ }}
\newcommand{\xotherwise}  {\mbox{\bf otherwise\ }}
\newcommand{\xfi}         {\mbox{\bf fi}}
\newcommand{\xrof}        {\mbox{\bf rof}}
\newcommand{\xelihw}      {\mbox{\bf elihw}}
\newcommand{\xendwhile}   {\mbox{\bf endwhile}}
\newcommand{\xwhile}      {\mbox{\bf while\ }}
\newcommand{\xdo}         {\mbox{\bf do\ }}
\newcommand{\xod}         {\mbox{\bf od}}
\newcommand{\xrepeat}     {\mbox{\bf repeat\ }}
\newcommand{\xuntil}      {\mbox{\bf until\ }}
\newcommand{\xfor}        {\mbox{\bf for\ }}
\newcommand{\xforeach}    {\mbox{\bf for each\ }}
\newcommand{\xto}         {\mbox{\bf to\ }}
\newcommand{\xdto}        {\mbox{\bf downto\ }}
\newcommand{\xand}        {\mbox{\bf and\ }}
\newcommand{\xor}         {\mbox{\bf or\ }}
\newcommand{\xtrue}       {\mbox{\bf true}}
\newcommand{\xfalse}      {\mbox{\bf false}}
\newcommand{\xcall}       {\mbox{\bf call\ }}
\newcommand{\xprocedure}  {\mbox{\bf procedure\ }}
\newcommand{\xalgorithm}  {\mbox{\bf algorithm\ }}
\newcommand{\xreturn}     {\mbox{\bf return}}
\newcommand{\xnil}        {\mbox{\bf nil}}
\newcommand{\xvar}        {\mbox{\bf var\ }}
\newcommand{\xcase}       {\mbox{\bf case\ }}
\newcommand{\xof}         {\mbox{\bf of\ }}
\newcommand{\xmod}        {\mbox{\bf mod\ }}
\newcommand{\xesac}       {\mbox{\bf esac}}
\newcommand{\xboolean}    {\mbox{\bf boolean}}
\newcommand{\xinteger}    {\mbox{\bf integer}}
\newcommand{\xforever}    {\mbox{\bf forever}}
\newcommand{\xxbreak}     {\mbox{\bf break}}
\newcommand{\xswap}       {\mbox{\bf swap}}
\newcommand{\xcomment}    {\mbox{\bf comment}}


\newcommand{\stdtable}  {
~\\
\scriptsize\centering\begin{tabular}{|c|r|rrrrr|rrr|r|}\hline
%\scriptsize\centering\begin{tabular}{|c|r|ccccc|ccc|c|}\hline
\multicolumn{2}{|c|}{} & \multicolumn{9}{c|}{Class} \\
\cline{3-11} \multicolumn{1}{|c}{packing} & \multicolumn{1}{r|}{$n$} &
\multicolumn{1}{c}{$1$} & \multicolumn{1}{c}{$2$} & \multicolumn{1}{c}{$3$} &
\multicolumn{1}{c}{$4$} & \multicolumn{1}{c|}{$5$}& \multicolumn{1}{c}{$6$} &
\multicolumn{1}{c}{$7$} & \multicolumn{1}{c|}{$8$}& \multicolumn{1}{c|}{$9$}
\\ \hline }


\newcommand{\rev}{\bf}
%\newcommand{\rev}{}


% ----------------------------------------------------------------------
\title{Code binpack3d: User Manual}
\author{Silvano Martello$^{*}$, David Pisinger$^{\dag}$,
Daniele Vigo$^{*}$,\\ Edgar den Boef$^{\S}$, Jan
Korst$^{\S}$\\*[1ex] $^{*}$DEIS, University of Bologna, Italy \\
$^{\dag}$DIKU, University of Copenhagen, Denmark\\
$^{\S}$Philips
Research Laboratories, Eindhoven, The Netherlands}


\date{}


%%%%%%%%%%%%%%%%%%%%%%%%
%\input{tab5.tex}
\input{tables.tex}
%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}


\maketitle


\section{The Code}\label{code}

Algorithm {\tt binpack3d}, described in Martello et al. \cite{MPVBK06},
was coded in ANSI-C and compiled on
several platforms using {\tt cc} and {\tt gcc} compilers. In
particular, the code has been tested with the {\tt -pedantic}
option of {\tt gcc} to ensure that the ANSI-C standard is strictly
respected. The $n$ boxes are here numbered from 0 to $n-1$. Box
positions are referred to a coordinate system having its origin in
the lower-left-backward corner of the bin.

The algorithm comes with program  {\tt test3dbpp}
that either reads an instance from an input file or constructs some randomly
generated instances presented in Martello, Pisinger and Vigo \cite{MarPisVig98}.

A prototype of {\tt binpack3d} appears as
\begin{flushleft}
\tt void binpack3d(int n, int W, int H, int D,
            int *w, int *h, int *d, \\ \rule{28mm}{0mm}
            int *x, int *y, int *z, int *bno,
            int *lb, int *ub,\\ \rule{28mm}{0mm}
            int nodelimit, int iterlimit, int timelimit,
            int *nodeused,\\ \rule{28mm}{0mm}
            int *iterused, int *timeused, int packingtype)
\end{flushleft}
%
where the parameters are:
\medskip

\noindent
\makebox[2.7cm][l]{\tt n} \parbox[t]{13.0cm}{size of the
problem, i.e., number of boxes to be packed;}
\medskip

\noindent
\makebox[2.7cm][l]{\tt W,H,D} \parbox[t]{13.0cm}{width, height and
depth of every bin;}
\medskip

\noindent
\makebox[2.7cm][l]{\tt w,h,d}
\parbox[t]{13.0cm}{integer arrays of length {\tt n}, where ${\tt
w[j-1]}=w_j$, ${\tt h[j-1]}=h_j$, ${\tt d[j-1]}=d_j$ are the
dimensions of box $j$ ($j=1, \dots, n$);}
\medskip

\noindent
\makebox[2.7cm][l]{\tt x,y,z,bno} \parbox[t]{13.0cm}{integer
arrays of length {\tt n}, where the solution found is returned.
For each box $j$ ($j=1,\dots,n$), {\tt bno[j-1]} is the bin number
it is packed into, and {\tt x[j-1], y[j-1], z[j-1]} are the
coordinates of its lower-left-backward corner;}
\medskip

\noindent
\makebox[2.7cm][l]{\tt lb} \parbox[t]{13.0cm}{best lower bound on
the solution value obtained;}\medskip

\noindent
\makebox[2.7cm][l]{\tt ub}
\parbox[t]{13.0cm}{objective value of the solution found, i.e.,
number of bins used to pack the $n$ boxes. If an optimal solution
was found, then {\tt ub}={\tt lb};}\medskip

\noindent
\makebox[2.7cm][l]{\tt nodelimit}
\parbox[t]{13.0cm}{maximum number of decision nodes to be explored
in the main branching tree (in thousands).
If set to zero, the algorithm will run until an optimal solution is
found ({unless either} {\tt timelimit} or {\tt iterlimit} is reached);}
\medskip

\noindent
\makebox[2.7cm][l]{\tt iterlimit}
\parbox[t]{13.0cm}{maximum number of iterations in the ONEBIN algorithm
which packs a single bin (in thousands).
If set to zero, the algorithm will run until an optimal solution is
found ({unless either} {\tt timelimit} or {\tt nodelimit} is reached);}
\medskip

\noindent
\makebox[2.7cm][l]{\tt timelimit}
\parbox[t]{13.0cm}{time limit for solving the problem,
expressed in seconds. If set to zero, the algorithm will run until
an optimal solution is found ({unless either} {\tt nodelimit} or {\tt iterlimit} is reached);
otherwise, no new branching node will be explored after {\tt
timelimit} seconds;}
\medskip

\noindent
\makebox[2.7cm][l]{\tt nodeused}
\parbox[t]{13.0cm}{a pointer to an integer where the number
of {nodes in the main branch and bound tree} is returned;}
\medskip

\noindent
\makebox[2.7cm][l]{\tt iterused}
\parbox[t]{13.0cm}{a pointer to an integer where the {total} number
of iterations in ONEBIN is returned;}
\medskip

\noindent
\makebox[2.7cm][l]{\tt timeused}
\parbox[t]{13.0cm}{a pointer to an integer where the used time
in milliseconds is returned;}
\medskip

\noindent
\makebox[2.7cm][l]{\tt packingtype}
\parbox[t]{13.0cm}{desired packing type. If set to zero, the
algorithm will search for an optimal general packing; if set to
one, it will search for a robot packing.}
\medskip

\noindent
{The general structure of the code is shown in Figure \ref{figtwo}.
Initial lower bounds and heuristic solutions are computed at the root
node. If the problem is not solved to optimality, the tree enumeration
is recursively performed through procedure {\tt rec\_binpack}.
   }

\setlength{\unitlength}{0.05cm}
\begin{figure}[htb]
\begin{center}
\begin{picture}(320,230)(0,0)
  \put(0,0){\framebox(320,230){\shortstack[l]
  {
\makebox[0.7cm][l]{\bf 1.} copy the input information to internal
structures;\\*[1ex]
\makebox[0.7cm][l]{\bf 2.} compute lower bound $L_2$;\\*[1ex]
\makebox[0.7cm][l]{\bf 3.} execute heuristics $H1$ and $H2$, and
set $u$ to the best solution value found;\\*[1ex]
\makebox[0.7cm][l]{\bf 4.} {\bf while} no optimal solution is found or stopping criterion is met {\bf do}\\*[1ex]
\makebox[1.14cm][l]{~}\hspace*{0.25cm} {\bf comment:} perform the tree enumeration;\\*[1ex]
\makebox[0.7cm][l]{\bf 4.1}\hspace*{0.7cm} assign the next box to an open bin or a new bin;\\*[1ex]
\makebox[0.7cm][l]{\bf 4.2}\hspace*{0.7cm} check feasibility of the assignment with {\tt onebin\_decision};\\*[1ex]
\makebox[0.7cm][l]{\bf 4.3}\hspace*{0.7cm} {\bf if} the assignment is not feasible {\bf then} backtrack;\\*[1ex]
\makebox[0.7cm][l]{~}\hspace*{0.7cm} {\bf else}\\*[1ex]
\makebox[0.7cm][l]{~}\hspace*{1.4cm} check the current solution for (non-)optimality;\\*[1ex]
\makebox[0.7cm][l]{~}\hspace*{1.4cm} check node limit and time limit;\\*[1ex]
\makebox[0.7cm][l]{~}\hspace*{1.4cm} {\bf for each} open bin {\bf do}\\*[1ex]
\makebox[0.7cm][l]{~}\hspace*{2.1cm} {\bf if} the bin can be closed {\bf then}\\*[1ex]
\makebox[0.7cm][l]{~}\hspace*{2.8cm} compute a new lower bound and possibly backtrack\\*[1ex]
\makebox[0.7cm][l]{~}\hspace*{1.4cm} {\bf end for}\\*[1ex]
\makebox[0.7cm][l]{~}\hspace*{0.7cm} {\bf end if}\\*[1ex]
\makebox[0.7cm][l]{\bf 5.} return the best solution found.
   }
            }                  }
\end{picture}
\end{center}
\caption{Structure of procedure {\tt binpack3d} \label{figtwo}}
\end{figure}


% -----------------------------------------------------------------------
\section{Implementation details}\label{datastruct}

All parameters {concerning the boxes}
are passed to algorithm {\tt binpack3d} as integer
arrays to form a simple interface to other programs. {However,
internally the algorithm stores} the information of each box in a
structure {\tt box
} that contains the following fields:
\medskip

\noindent
%
\makebox[2.2cm][l]{\tt
no} \parbox[t]{13.5cm}{original (input) number of the box. This
number follows the box throughout the algorithm for easy
identification and debugging;}\medskip

\noindent
\makebox[2.2cm][l]{\tt w,h,d} \parbox[t]{13.5cm}{width,
height and depth of the box;}\medskip

\noindent
\makebox[2.2cm][l]{\tt x,y,z} \parbox[t]{13.5cm}{coordinates of
the current position of the lower-left-backward corner of the
box;}\medskip

\noindent
\makebox[2.2cm][l]{\tt bno}
\parbox[t]{13.5cm}{number of the bin the box is currently assigned
to. If ${\tt bno}=0$ the box is not currently assigned to any
bin;}\medskip

\noindent
\makebox[2.2cm][l]{\tt k} \parbox[t]{13.5cm}{boolean
variable indicating whether the current box was selected when
solving the single-bin subproblem;}\medskip

\noindent
\makebox[2.2cm][l]{\tt vol}
\parbox[t]{13.5cm}{volume of the box.}
\medskip

\noindent
{All problem information is stored in a structure {\tt allinfo}
that contains the problem data and execution parameters, working data,
bound values at the root node, as well as debugging, control and statistic
information. Additional structures are used for the heuristic algorithms
({\tt heurpair}) and the constraint programming algorithm
({\tt domainpair}).
}

Different upper and lower bound values may be
obtained by considering the instance according to the three
different orientations. {To this purpose, the computations are
performed for a single orientation (procedures {\tt bound\_two\_x},
{\tt dfirst\_heuristic} and {\tt mcut\_heuristic}): the overall lower and
upper bound values are then obtained (through procedures {\tt bound\_two}, {\tt
dfirst3\_heuristic} and {\tt mcut3\_heuristic})
making use of a routine {\tt rotate\_problem} that rotates the
dimensions as $w \leftarrow h \leftarrow d \leftarrow w$ and
$W \leftarrow H \leftarrow D \leftarrow W$.}
This routine is always called three times, so that all variables
are restored to their original values after the three iterations.
When deriving upper bounds, a routine {\tt rotate\_solution} is
executed with {\tt rotate\_problem}, in order to ensure that
solution coordinates follow the orientation of the instance.

\begin{thebibliography}{99}

\bibitem{MarPisVig98} S.~Martello, D.~Pisinger, D.~Vigo (2000),
``The Three-Dimensional Bin Packing Problem'', {\em
Operations Research} 48, 256--267.

\bibitem{MPVBK06} S.~Martello,
D.~Pisinger, D.~Vigo, E.~den Boef and J.~Korst (2006), ``Algorithms for General and Robot-Packable Variants of
the Three-Dimensional Bin Packing Problem", {\em ACM Transactions on Mathematical Software} (to appear).
\end{thebibliography}

\end{document}
