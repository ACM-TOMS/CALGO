
!     FM 1.3                              David M. Smith                              6-21-2010


!  The routines in this package perform multiple precision arithmetic and functions
!  on three kinds of numbers.
!  FM routines handle floating-point real multiple precision numbers,
!  IM routines handle integer multiple precision numbers, and
!  ZM routines handle floating-point complex multiple precision numbers.
!  References to FM numbers below mean the low-level array form of the number used by the routines
!  in FM.f95, and not the derived type (fm) numbers handled by the FMZM module.  Logically, both may
!  refer to the same multiple precision number, but the syntax for dealing with the two types of
!  objects is different.  The same is true of references to IM numbers and ZM numbers below.

!  These are the basic routines for the FM package, and the expectation is that the user will not
!  call these routines directly.  The typical usage is for a program to declare multiple precision
!  variables with the three derived types defined in module FMZM in file FMZM90.f95.  Then that
!  module provides the interface between the user's program and the routines in this file.  See the
!  documentation in the FM_User_Manual.txt file for advice on using the FMZM module.
!  The information below is intended as a technical reference on the inner workings of FM, and most
!  FM users should not need to study it.


!  1. INITIALIZING THE PACKAGE

!  The variables that contain values to be shared by the different routines are located in module
!  FMVALS in file FMSAVE.f95.  Variables that are described below for controlling various features
!  of the FM package are found in this module.  They are initialized to default values assuming
!  32-bit integers and 64-bit double precision representation of the arrays holding multiple
!  precision numbers.  The base and number of digits to be used are initialized to give slightly
!  more than 50 decimal digits.  Subroutine FMVARS can be used to get a list of these variables
!  and their values.

!  The intent of module FMVALS is to hide the FM internal variables from the user's program, so that
!  no name conflicts can occur.  Subroutine FMSETVAR can be used to change the variables listed
!  below to new values.  It is not always safe to try to change these variables directly by putting
!  USE FMVALS into the calling program and then changing them by hand.  Some of the saved constants
!  depend upon others, so that changing one variable may cause errors if others depending on that
!  one are not also changed.  FMSETVAR automatically updates any others that depend upon the one
!  being changed.

!  Subroutine FMSET also initializes these variables.  It tries to compute the best value for each,
!  and it checks several of the default values set in FMVALS to see that they are reasonable for a
!  given machine.  FMSET can also be called to set or change the current precision level for the
!  multiple precision numbers.

!  Calling FMSET is optional starting in version 1.2 of the FM package.  In previous versions one
!  call was required before any other routine in the package could be used.

!  The routine ZMSET from version 1.1 is no longer needed, and the complex operations are
!  automatically initialized in FMVALS.  It has been left in the package for compatibility with
!  version 1.1.


!  2.  REPRESENTATION OF FM NUMBERS

!  MBASE is the base in which the arithmetic is done.  MBASE must be bigger than one, and less than
!        or equal to the square root of the largest representable integer.  For best efficiency
!        MBASE should be large, but no more than about 1/4 of the square root of the largest
!        representable integer.  Input and output conversions are much faster when MBASE is a
!        power of ten.

!  NDIG  is the number of base MBASE digits that are carried in the multiple precision numbers.
!        NDIG must be at least two.  The upper limit for NDIG is restricted only by the amount
!        of memory available.

!  Sometimes it is useful to dynamically vary NDIG during the program.  Routine FMEQU should be used
!  to round numbers to lower precision or zero-pad them to higher precision when changing NDIG.

!  The default value of MBASE is a large power of ten.  FMSET also sets MBASE to a large power of
!  ten.  For an application where another base is used, such as simulating a given machine's base
!  two arithmetic, use subroutine FMSETVAR to change MBASE, so that the other internal values
!  depending on MBASE will be changed accordingly.

!  There are two representations for a floating point multiple precision number.  The unpacked
!  representation used by the routines while doing the computations is base MBASE and is stored
!  in NDIG+3 words.  A packed representation is available to store the numbers in compressed form.
!  In this format, the NDIG (base MBASE) digits of the mantissa are packed two per word to conserve
!  storage.  Thus the external, packed form of a number requires (NDIG+1)/2+3 words.

!  This version uses double precision arrays to hold the numbers.  Version 1.0 of FM used integer
!  arrays, which are faster on some machines.  The package can be changed to use integer arrays ---
!  see section 10 on EFFICIENCY below.

!  The unpacked format of a floating multiple precision number is as follows.  A number MA refers
!  to an array with the multiple precision number stored as follows:
!       1  Sign of the number
!       2  Accuracy
!       3  Exponent of the number
!       4  First digit of the number
!     ...
!  NDIG+3  Last digit of the number.

!  The accuracy is the approximate number of bits of precision of the number.  This precision value
!  is intended to be used by FM functions that need to monitor cancellation error in addition and
!  subtraction.  The cancellation monitor code is usually disabled for user calls, and FM functions
!  only check for cancellation when they must.  Tracking cancellation causes most routines to run
!  slower, with addition and subtraction being affected the most.

!  The exponent is a power of MBASE and the implied radix point is immediately before the first
!  digit of the mantissa.  The exponent is a signed integer.  The overflow threshold is
!  MBASE**(MXEXP+1), and the underflow threshold is MBASE**(-MXEXP-1).  This means the valid
!  exponents for an FM number can range from -MXEXP to MXEXP+1 (inclusive).
!  Every nonzero number is normalized so that the first digit of the mantissa is nonzero.

!  For MBASE = 10,000 and NDIG = 4, if MA is the number -pi, it would have these representations:

!                   Word 1         2         3         4         5         6         7

!         Unpacked:     -1        42         1         3      1415      9265      3590
!         Packed:       -1        42         1     31415  92653590

!  The mantissa has about 42 bits of precision, and the number represented is
!  (-1)*(10000**1)*(.0003141592653590).

!  Because of the normalization of the digits with a large base, the equivalent number of base 10
!  significant digits for an FM number may be as small as LOG10(MBASE)*(NDIG-1) + 1.  In the -pi
!  example above, this is 4*3 + 1 = 13.

!  In version 1.2 and before, each variable like MA was a fixed-size array.  Now the array values
!  for all multiple precision numbers are stored together in one dynamic array, MWK.  A variable
!  name like MA is just an integer index giving the location within MWK where the digits are put.
!  This allows the memory management of the package to be more flexible than before, to handle
!  large arrays of multiple precision numbers at low precision (30 to 50 s.d.) as well as some
!  at high precision (millions of s.d.).

!  The integer routines use the FM format to represent numbers, without the number of digits (NDIG)
!  being fixed.  Integers in IM format are essentially variable precision, using the minimum number
!  of words to represent each value.

!  The unpacked format is the default.  As machines' memories have gotten bigger, few applications
!  need the packed format.  A program that uses packed format numbers should not use the FMZM module
!  or the multiple precision derived types defined in FMZM.  Packed numbers are treated as temporary
!  values by the routines in FMZM, so mixing packed numbers with derived type operations from FMZM
!  means the packed numbers could be deleted before the main program is finished with them.

!  For programs using both FM and IM numbers, FM routines should not be called with IM numbers, and
!  IM routines should not be called with FM numbers, since the implied value of NDIG used for an IM
!  number may not match the explicit NDIG expected by an FM routine.  Use the conversion routines
!  IMFM2I and IMI2FM to change between the FM and IM formats.

!  The format for complex FM numbers (called ZM numbers below) is very similar to that for real FM
!  numbers.  Each ZM number consists of two FM numbers representing the real and imaginary parts of
!  a complex number.  If MA is a ZM number, then the real part is MA(1) and the imaginary part is
!  MA(2).  As with FM, there are packed and unpacked formats for the numbers.


!  3. INPUT/OUTPUT ROUTINES

!  All versions of the input routines perform free-format conversion from characters to FM numbers.

!  a. Conversion to or from a character array

!     FMINP converts from a character(1) array to an FM number.

!     FMOUT converts an FM number to base 10 and formats it for output as an array of type
!           character(1).  The output is left justified in the array, and the format is defined
!           by two variables in module FMVALS, so that a separate format definition does not have
!           to be provided for each output call.

!     JFORM1 and JFORM2 define a default output format.

!     JFORM1 = 0     E   format       ( .314159M+6 )
!            = 1     ES  format       ( 3.14159M+5 )
!            = 2     F   format       ( 314159.000 )

!     JFORM2 is the number of significant digits to display (if JFORM1 = 0 or 1).
!            If JFORM2 = 0 then a default number of digits is chosen.  The default is roughly
!            the full precision of the number.
!     JFORM2 is the number of digits after the decimal point (if JFORM1 = 2).
!            See the FMOUT documentation for more details.

!  b. Conversion to or from a character string

!     FMST2M converts from a character string to an FM number.

!     FMFORM converts an FM number to a character string according to a format provided in each
!            call.  The format description is more like that of a Fortran FORMAT statement, and
!            integer or fixed-point output is right justified.

!  c. Direct read or write

!     FMPRINT uses FMOUT to print one FM number.

!     FMFPRINT uses FMFORM to print one FM number.

!     FMWRITE writes FM numbers for later input using FMREAD.

!     FMREAD reads FM numbers written by FMWRITE.

!  The values given to JFORM1 and JFORM2 can be used to define a default output format when FMOUT
!  or FMPRINT are called.  The explicit format used in a call to FMFORM or FMFPRINT overrides the
!  settings of JFORM1 and JFORM2.

!  KW is the unit number to be used for standard output from the package, including error and
!  warning messages, and trace output.

!  For multiple precision integers, the corresponding routines IMINP, IMOUT, IMST2M, IMFORM,
!  IMPRINT, IMFPRINT, IMWRITE, and IMREAD provide similar input and output conversions.  For output
!  of IM numbers, JFORM1 and JFORM2 are ignored and integer format (JFORM1=2, JFORM2=0) is used.

!  For ZM numbers, the corresponding routines ZMINP, ZMOUT, ZMST2M, ZMFORM, ZMPRINT, ZMFPRINT,
!  ZMWRITE, and ZMREAD provide similar input and output conversions.

!  For the output format of ZM numbers, JFORM1 and JFORM2 determine the default format for the
!  individual parts of a complex number as with FM numbers.

!     JFORMZ determines the combined output format of the real and imaginary parts.

!     JFORMZ = 1  normal setting    :    1.23 - 4.56 i
!            = 2  use capital I     :    1.23 - 4.56 I
!            = 3  parenthesis format:  ( 1.23 , -4.56 )

!     JPRNTZ controls whether to print real and imaginary parts on one line whenever possible.

!     JPRNTZ = 1  print both parts as a single string :
!                     1.23456789M+321 - 9.87654321M-123 i
!            = 2  print on separate lines without the 'i' :
!                     1.23456789M+321
!                    -9.87654321M-123

!  For further description of these routines, see section 9 below.


!  4. ARITHMETIC TRACING

!  NTRACE and LVLTRC control trace printout from the package.

!  NTRACE =  0   No output except warnings and errors.  (Default)
!         =  1   The result of each call to one of the routines is printed in base 10, using FMOUT.
!         = -1   The result of each call to one of the routines is printed in internal base MBASE
!                     format.
!         =  2   The input arguments and result of each call to one of the routines is printed in
!                     base 10, using FMOUT.
!         = -2   The input arguments and result of each call to one of the routines is printed in
!                     base MBASE format.

!  LVLTRC defines the call level to which the trace is done.  LVLTRC = 1 means only FM routines
!         called directly by the user are traced, LVLTRC = 2 also prints traces for FM routines
!         called by other FM routines called directly by the user, etc.  Default is 1.

!  In the above description, internal MBASE format means the number is printed as it appears in the
!  array --- the sign, accuracy, exponent, then the NDIG base MBASE digits.


!  5. ERROR CONDITIONS

!  KFLAG is a condition value returned by the package after each call to one of the routines.
!        Negative values indicate conditions for which a warning message will be printed unless
!        KWARN = 0.
!        Positive values indicate conditions that may be of interest but are not errors.  No warning
!        message is printed if KFLAG is nonnegative.

!  Subroutine FMFLAG is provided to give the user access to the current condition code.  For
!  example, to set the user's local variable LFLAG to FM's internal KFLAG value:
!        CALL FMFLAG(LFLAG)

!    KFLAG =  0     Normal operation.

!          =  1     One of the operands in FMADD or FMSUB was insignificant with respect to the
!                       other.  This means that in the default (symmetric) rounding mode the result
!                       is equal to the argument of larger magnitude.  KFLAG = 1 is still returned
!                       with the other three rounding modes (see KROUND below), but the result may
!                       not be equal to either input argument.
!          =  2     In converting an FM number to a one word integer in FMM2I, the FM number was
!                       not exactly an integer.  The next integer toward zero was returned.

!          = -1     NDIG was less than 2.
!          = -2     MBASE was less than 2 or more than MXBASE.
!          = -3     An exponent was out of range.
!          = -4     Invalid input argument(s) to an FM routine.  UNKNOWN was returned.
!          = -5     + or - OVERFLOW was generated as a result from an FM routine.
!          = -6     + or - UNDERFLOW was generated as a result from an FM routine.
!          = -7     The input string (array) to FMINP was not legal.
!          = -8     The character array was not large enough in an input or output routine.
!          = -9     Precision could not be raised enough to provide all requested guard digits.
!                        This means the program has run out of memory.
!                        UNKNOWN was returned.
!          = -10    An FM input argument was too small in magnitude to convert to the machine's
!                        single or double precision in FMM2SP or FMM2DP.  Check that the definitions
!                        of SPMAX and DPMAX in file FMSAVE.f95 are correct for the current machine.
!                        Zero was returned.
!          = -11    Array MBERN is not dimensioned large enough for the requested number of
!                        Bernoulli numbers.
!          = -12    Array MJSUMS is not dimensioned large enough for the number of coefficients
!                        needed in the reflection formula in FMPGAM.

!  When a negative KFLAG condition is encountered, the value of KWARN determines the action to
!  be taken.

!  KWARN = 0     Execution continues and no message is printed.
!        = 1     A warning message is printed and execution continues.
!        = 2     A warning message is printed and execution stops.

!  The default setting is KWARN = 1.

!  When an overflow or underflow is generated for an operation in which an input argument was
!  already an overflow or underflow, no additional message is printed.  When an unknown result
!  is generated and an input argument was already unknown, no additional message is printed.
!  In these cases the negative KFLAG value is still returned.

!  IM routines handle exceptions like OVERFLOW or UNKNOWN in the same way as FM routines, but there
!  are some differences because the number of digits carried for IM numbers is not fixed.  For
!  example, in computing the product of two large integers FM will try to allocate more space rather
!  than returning +OVERFLOW.  If this allocation fails, FM will write an error message indicating it
!  could not get more memory, and the program will stop.  The routines IMMPY_MOD and IMPOWER_MOD can
!  be used to obtain modular products and powers without as much chance of running out of memory.


!  6. OTHER OPTIONS

!  KRAD = 0     All angles in the real trigonometric functions and inverse functions are measured
!                   in degrees.
!       = 1     All angles are measured in radians.  (Default)

!  KROUND = -1  All results are rounded toward minus infinity.
!         =  0  All results are rounded toward zero (chopped).
!         =  1  All results are rounded to the nearest FM number, or to the value with an even last
!                   digit if the result is exactly halfway between two FM numbers.  (Default)
!         =  2  All results are rounded toward plus infinity.

!  KSWIDE defines the maximum screen width to be used for all unit KW output.  Default is 80.

!  KESWCH controls the action taken in FMINP and other input routines for strings like 'E7' that
!         have no digits before the exponent field.  This is sometimes a convenient abbreviation
!         when doing interactive keyboard input.
!         KESWCH = 1 causes 'E7' to translate like '1.0E+7'.  (Default)
!         KESWCH = 0 causes 'E7' to translate like '0.0E+7' and give 0.

!  CMCHAR defines the exponent letter to be used for FM variable output.
!         Default is 'M', as in 1.2345M+678.
!         Change it to 'E' for output to be read by a non-FM program.

!  KDEBUG = 0   No error checking is done to see if input arguments are valid and parameters like
!                  NDIG and MBASE are correct upon entry to each routine.  (Default)
!         = 1   Some error checking is done.  (Slower speed)

!  See module FMVALS in file FMSAVE.f95 for additional description of these and other variables
!  defining various FM conditions.


!  7. ARRAY DIMENSIONS

!  Before version 1.3 the multiple-precision numbers were each stored in a separate array.  Now all
!  these arrays have been combined into one, MWK.  Each multiple-precision number is represented by
!  a single integer that is used to access the number in the MWK array.  This makes the memory usage
!  within the package much more flexible.


!  8. PORTABILITY

!  In FMSET several variables are set to machine-dependent values, and many of the variables
!  initialized in module FMVALS in file FMSAVE.f95 are checked to see that they have reasonable
!  values.  FMSET will print warning messages on unit KW for any of the FMVALS variables that
!  seem to be poorly initialized.

!  If an FM run fails, call FMVARS to get a list of all the FMVALS variables printed on unit KW.
!  Setting KDEBUG = 1 at the start may also identify some errors.

!  In the routines for special functions, several constants are used that require the machine's
!  integer word size to be at least 32 bits.


!  9.  LIST OF ROUTINES

!  First are the routines that deal with multiple precision real numbers.  All of these are
!  subroutines except logical function FMCOMPARE.

!  MA, MB, MC refer to FM format numbers (i.e., integers as opposed to the derived types with
!  integer components that are defined in file FMZM90.f95)

!  In Fortran-90 and later versions of the Fortran standard, it is potentially unsafe to use the
!  same variable more than once in the calling sequence.  The operation MA = MA + MB should not be
!  written as
!        CALL FMADD(MA,MB,MA)
!  since the code for the subroutine will not know that the first and third arguments are the same,
!  and some code optimizations under the assumption that all three arguments are different could
!  cause errors.

!  One solution is to use a third array and then put the result back in MA:
!        CALL FMADD(MA,MB,MC)
!        CALL FMEQ(MC,MA)

!  When the first call is doing one of the "fast" operations like addition, the extra call to move
!  the result back to MA can cause a noticeable loss in efficiency.  To avoid this, separate
!  routines are provided for the basic arithmetic operations when the result is to be returned in
!  the same array as one of the inputs.

!  A routine name with a suffix of  "_R1" returns the result in the first input array, and a suffix
!  of "_R2" returns the result in the second input array.  The example above would then be:
!        CALL FMADD_R1(MA,MB)

!  These routines each have one less argument than the original version, since the output is
!  re-directed to one of the inputs.  The result array should not be the same as any input array
!  when the original version of the routine is used.

!  The routines that can be used this way are listed below.  For others, like
!        CALL FMEXP(MA,MA)
!  the relative cost of doing an extra copy is small.  This one should become
!        CALL FMEXP(MA,MB)
!        CALL FMEQ(MB,MA)

!  When the derived-type interface is used, as in
!        TYPE (FM), SAVE :: A, B
!        ...
!        A = A + B
!  there is no problem putting the result back into A, since the interface routine creates a
!  temporary scratch array for the result of A + B.

!  For each of these routines there is also a version available for which the argument list is
!  the same but all FM numbers are in packed format.  The routines using packed numbers have the
!  same names except 'FM' is replaced by 'FP' at the start of each name.

!  Some of the routine names were restricted to 6 characters in earlier versions of FM.  The old
!  names have been retained for compatibility, but new names that are longer and more readable
!  have been added.  For example, the old routine FMCSSN can now also be called as FMCOS_SIN.
!  Both old and new names are listed below.


!  FMABS(MA,MB)              MB = ABS(MA)

!  FMACOS(MA,MB)             MB = ACOS(MA)

!  FMADD(MA,MB,MC)           MC = MA + MB

!  FMADD_R1(MA,MB)           MA = MA + MB

!  FMADD_R2(MA,MB)           MB = MA + MB

!  FMADDI(MA,IVAL)           MA = MA + IVAL   Increment an FM number by a one word integer.
!                                             Note this call does not have an "MB" result
!                                             like FMDIVI and FMMPYI.

!  FMASIN(MA,MB)             MB = ASIN(MA)

!  FMATAN(MA,MB)             MB = ATAN(MA)

!  FMATAN2(MA,MB,MC)         MC = ATAN2(MA,MB)     < old name: FMATN2 >

!  FMBIG(MA)                 MA = Biggest FM number less than overflow.

!  FMCHANGEBASE(MA,MB,NEW_MBASE,NEW_NDIG)
!                            MB is returned with the base NEW_MBASE and precision NEW_NDIG
!                               representation MA, where MA is given in the current base (MBASE)
!                               and precision (NDIG).  This routine is primarily meant to be used
!                               for input and output conversion when a base is being used that is
!                               not a power of ten.

!  FMCOMPARE(MA,LREL,MB)     Logical comparison of MA and MB.     < old name: FMCOMP >
!                            LREL is a character(2) value identifying which of the six comparisons
!                                 is to be made.
!                            Example:  IF (FMCOMPARE(MA,'>=',MB)) ...
!                            Also can be:  IF (FMCOMPARE(MA,'GE',MB)) ...
!                            character(1) is ok:  IF (FMCOMPARE(MA,'>',MB)) ...

!  FMCONS                    Set several saved constants that depend on MBASE, the base being used.
!                            FMCONS should be called immediately after changing MBASE.

!  FMCOS(MA,MB)              MB = COS(MA)

!  FMCOS_SIN(MA,MB,MC)       MB = COS(MA),  MC = SIN(MA).     < old name: FMCSSN >
!                                 Faster than making two separate calls.

!  FMCOSH(MA,MB)             MB = COSH(MA)

!  FMCOSH_SINH(MA,MB,MC)     MB = COSH(MA),  MC = SINH(MA).     < old name: FMCHSH >
!                                 Faster than making two separate calls.

!  FMDIG(NSTACK,KST)         Find a set of precisions to use during Newton iteration for finding a
!                            simple root starting with about double precision accuracy.

!  FMDIM(MA,MB,MC)           MC = DIM(MA,MB)

!  FMDIV(MA,MB,MC)           MC = MA / MB

!  FMDIV_R1(MA,MB)           MA = MA / MB

!  FMDIV_R2(MA,MB)           MB = MA / MB

!  FMDIVI(MA,IVAL,MB)        MB = MA/IVAL   IVAL is a one word integer.

!  FMDIVI_R1(MA,IVAL)        MA = MA/IVAL

!  FMDP2M(X,MA)              MA = X    Convert from double precision to FM.

!  FMDPM(X,MA)               MA = X    Convert from double precision to FM.
!                                      Faster than FMDP2M, but MA agrees with X only to D.P.
!                                      accuracy.  See the comments in the two routines.

!  FMEQ(MA,MB)               MB = MA   Both have precision NDIG.
!                                      This is the version to use for standard  B = A  statements.

!  FMEQU(MA,MB,NA,NB)        MB = MA   Version for changing precision.
!                                      MA has NA digits (i.e., MA was computed using NDIG = NA), and
!                                      MB will be defined having NB digits.
!                                      MB is rounded if NB < NA
!                                      MB is zero-padded if NB > NA

!  FMEXP(MA,MB)              MB = EXP(MA)

!  FMFLAG(K)                 K = KFLAG  get the value of the FM condition flag -- stored in the
!                                       internal FM variable KFLAG in module FMVALS.

!  FMFORM(FORM,MA,STRING)    MA is converted to a character string using format FORM and returned in
!                               STRING.  FORM can represent I, F, E, or ES formats.  Example:
!                               CALL FMFORM('F60.40',MA,STRING)

!  FMFPRINT(FORM,MA)         Print MA on unit KW using FORM format.     < old name: FMFPRT >

!  FMI2M(IVAL,MA)            MA = IVAL   Convert from one word integer to FM.

!  FMINP(LINE,MA,LA,LB)      MA = LINE   Input conversion.
!                                        Convert LINE(LA) through LINE(LB) from characters to FM.

!  FMINT(MA,MB)              MB = INT(MA)    Integer part of MA.

!  FMIPOWER(MA,IVAL,MB)      MB = MA**IVAL   Raise an FM number to a one word integer power.
!                                            < old name: FMIPWR >

!  FMLOG10(MA,MB)            MB = LOG10(MA)     < old name: FMLG10 >

!  FMLN(MA,MB)               MB = LOG(MA)

!  FMLNI(IVAL,MA)            MA = LOG(IVAL)   Natural log of a one word integer.

!  FMM2DP(MA,X)              X  = MA     Convert from FM to double precision.

!  FMM2I(MA,IVAL)            IVAL = MA   Convert from FM to integer.

!  FMM2SP(MA,X)              X  = MA     Convert from FM to single precision.

!  FMMAX(MA,MB,MC)           MC = MAX(MA,MB)

!  FMMIN(MA,MB,MC)           MC = MIN(MA,MB)

!  FMMOD(MA,MB,MC)           MC = MA mod MB

!  FMMPY(MA,MB,MC)           MC = MA * MB

!  FMMPY_R1(MA,MB)           MA = MA * MB

!  FMMPY_R2(MA,MB)           MB = MA * MB

!  FMMPYI(MA,IVAL,MB)        MB = MA*IVAL    Multiply by a one word integer.

!  FMMPYI_R1(MA,IVAL)        MA = MA*IVAL

!  FMNINT(MA,MB)             MB = NINT(MA)   Nearest FM integer.

!  FMOUT(MA,LINE,LB)         LINE = MA   Convert from FM to character.
!                                        LINE is a character array of length LB.

!  FMPI(MA)                  MA = pi

!  FMPRINT(MA)               Print MA on unit KW using current format.     < old name: FMPRNT >

!  FMPOWER(MA,MB,MC)         MC = MA**MB     < old name: FMPWR >

!  FM_RANDOM_NUMBER(X)       X is returned as a double precision random number, uniformly
!                            distributed on the open interval (0,1).  It is a high-quality,
!                            long-period generator based on 49-digit prime numbers.
!                            Note that X is double precision, unlike the similar Fortran intrinsic
!                            random number routine, which returns a single-precision result.
!                            A default initial seed is used if FM_RANDOM_NUMBER is called without
!                            calling FM_RANDOM_SEED_PUT first.  See the comments in section 11 below
!                            and also those in the routine for more details.

!  FM_RANDOM_SEED_GET(SEED)  returns the seven integers SEED(1) through SEED(7) as the current seed
!                            for the FM_RANDOM_NUMBER generator.

!  FM_RANDOM_SEED_PUT(SEED)  initializes the FM_RANDOM_NUMBER generator using the seven integers
!                            SEED(1) through SEED(7). These get and put functions are slower than
!                            FM_RANDOM_NUMBER, so FM_RANDOM_NUMBER should be called many times
!                            between FM_RANDOM_SEED_PUT calls.  Also, some generators that used a
!                            9-digit modulus have failed randomness tests when used with only a few
!                            numbers being generated between calls to re-start with a new seed.

!  FM_RANDOM_SEED_SIZE(SIZE) returns integer SIZE as the size of the SEED array used by the
!                            FM_RANDOM_NUMBER generator.  Currently, SIZE = 7.

!  FMRATIONAL_POWER(MA,K,J,MB)
!                            MB = MA**(K/J)  Rational power.     < old name: FMRPWR >
!                            Faster than FMPOWER for functions like the cube root.

!  FMREAD(KREAD,MA)          MA   is returned after reading one (possibly multi-line) FM number
!                                 on unit KREAD.  This routine reads numbers written by FMWRITE.

!  FMSET(NPREC)              Set the internal FM variables so that the precision is at least NPREC
!                            base 10 digits plus three base 10 guard digits.

!  FMSETVAR(STRING)          Define a new value for one of the internal FM variables in module
!                            FMVALS that controls one of the FM options.  STRING has the form
!                                  variable = value.
!                            Example:  To change the screen width for FM output:
!                                  CALL FMSETVAR(' KSWIDE = 120 ')
!                            The variables that can be changed and the options they control are
!                            listed in sections 2 through 6 above.  Only one variable can be set
!                            per call.  The variable name in STRING must have no embedded blanks.
!                            The value part of STRING can be in any numerical format, except in
!                            the case of variable CMCHAR, which is character type.  To set CMCHAR
!                            to 'E', don't use any quotes in STRING:
!                                  CALL FMSETVAR(' CMCHAR = E ')

!  FMSIGN(MA,MB,MC)          MC = SIGN(MA,MB)   Returns the absolute value of MA times the sign
!                                               of MB.

!  FMSIN(MA,MB)              MB = SIN(MA)

!  FMSINH(MA,MB)             MB = SINH(MA)

!  FMSP2M(X,MA)              MA = X   Convert from single precision to FM.

!  FMSQR(MA,MB)              MB = MA * MA   Faster than FMMPY.

!  FMSQR_R1(MA)              MA = MA * MA

!  FMSQRT(MA,MB)             MB = SQRT(MA)

!  FMSQRT_R1(MA)             MA = SQRT(MA)

!  FMST2M(STRING,MA)         MA = STRING
!                                 Convert from character string to FM.  STRING may be in any
!                                 numerical format.  FMST2M is often more convenient than FMINP,
!                                 which converts an array of character(1) values.  Example:
!                                       CALL FMST2M('123.4',MA)

!  FMSUB(MA,MB,MC)           MC = MA - MB

!  FMSUB_R1(MA,MB)           MA = MA - MB

!  FMSUB_R2(MA,MB)           MB = MA - MB

!  FMTAN(MA,MB)              MB = TAN(MA)

!  FMTANH(MA,MB)             MB = TANH(MA)

!  FMTINY(MA)                MA = Smallest positive FM number greater than underflow.

!  FMULP(MA,MB)              MB = One Unit in the Last Place of MA.  For positive MA this is the
!                                 same as the Fortran function SPACING, but MB < 0 if MA < 0.
!                                 Examples:  If MBASE = 10 and NDIG = 30, then ulp(1.0) = 1.0E-29,
!                                            ulp(-4.5E+67) = -1.0E+38.

!  FMVARS                    Write the current values of the internal FM variables on unit KW.

!  FMWRITE(KWRITE,MA)        Write MA on unit KWRITE.     < old name: FMWRIT >
!                            Multi-line numbers will have '&' as the last nonblank character on all
!                            but the last line.  These numbers can then be read easily using FMREAD.


!  These are the available mathematical special functions.

!  FMBERNOULLI(N,MA)         MA = B(N)      Nth Bernoulli number

!  FMBESJ(N,MA,MB)           MB = J(N,MA)   Bessel function of the first kind.

!  FMBESY(N,MA,MB)           MB = Y(N,MA)   Bessel function of the second kind.

!  FMBETA(MA,MB,MC)          MC = Beta(MA,MB)

!  FMC(MA,MB)                MB = C(MA)     Fresnel Cosine Integral

!  FMCHI(MA,MB)              MB = Chi(MA)   Hyperbolic Cosine Integral

!  FMCI(MA,MB)               MB = Ci(MA)    Cosine Integral

!  FMCOMB(MA,MB,MC)          MC = Combination MA choose MB  (Binomial coefficient)

!  FMEI(MA,MB)               MB = Ei(MA)    Exponential Integral

!  FMEN(N,MA,MB)             MB = E(N,MA)   Exponential Integral E_n

!  FMERF(MA,MB)              MB = Erf(MA)   Error function

!  FMERFC(MA,MB)             MB = Erfc(MA)  Complimentary Error function

!  FMEULER(MA)               MA = Euler's constant ( 0.5772156649... )     < old name: FMEULR >

!  FMFACT(MA,MB)             MB = MA Factorial  (Gamma(MA+1))

!  FMGAM(MA,MB)              MB = Gamma(MA)

!  FMIBTA(MX,MA,MB,MC)       MC = Incomplete Beta(MX,MA,MB)

!  FMIGM1(MA,MB,MC)          MC = Incomplete Gamma(MA,MB).  Lower case Gamma(a,x)

!  FMIGM2(MA,MB,MC)          MC = Incomplete Gamma(MA,MB).  Upper case Gamma(a,x)

!  FMLERC(MA,MB)             MB = Ln(Erfc(MA))  Log Erfc

!  FMLI(MA,MB)               MB = Li(MA)    Logarithmic Integral

!  FMLNGM(MA,MB)             MB = Ln(Gamma(MA))

!  FMPGAM(N,MA,MB)           MB = Polygamma(N,MA)  (Nth derivative of Psi)

!  FMPOCH(MA,N,MB)           MB = MA*(MA+1)*(MA+2)*...*(MA+N-1)  (Pochhammer)

!  FMPSI(MA,MB)              MB = Psi(MA)   (Derivative of Ln(Gamma(MA))

!  FMS(MA,MB)                MB = S(MA)     Fresnel Sine Integral

!  FMSHI(MA,MB)              MB = Shi(MA)   Hyperbolic Sine Integral

!  FMSI(MA,MB)               MB = Si(MA)    Sine Integral


!  These are the routines that deal with multiple precision integer numbers.
!  All are subroutines except logical function IMCOMPARE.  MA, MB, MC refer to IM format numbers.
!  In each case the version of the routine to handle packed IM numbers has the same name, with
!  'IM' replaced by 'IP'.

!  IMABS(MA,MB)              MB = ABS(MA)

!  IMADD(MA,MB,MC)           MC = MA + MB

!  IMBIG(MA)                 MA = 10**(10**6).
!                                 Larger IM numbers can be obtained, but setting MA to the largest
!                                 possible value would leave no room for any other numbers.

!  IMCOMPARE(MA,LREL,MB)     Logical comparison of MA and MB.     < old name: IMCOMP >
!                            LREL is a character(2) value identifying which of the six comparisons
!                                 is to be made.
!                            Example:  IF (IMCOMPARE(MA,'GE',MB)) ...
!                            Also can be:  IF (IMCOMPARE(MA,'>=',MB))
!                            character(1) is ok:  IF (IMCOMPARE(MA,'>',MB)) ...

!  IMDIM(MA,MB,MC)           MC = DIM(MA,MB)

!  IMDIV(MA,MB,MC)           MC = int(MA/MB)
!                                 Use IMDIVR if the remainder is also needed.

!  IMDIVI(MA,IVAL,MB)        MB = int(MA/IVAL)
!                                 IVAL is a one word integer.  Use IMDVIR to get the remainder also.

!  IMDIVR(MA,MB,MC,MD)       MC = int(MA/MB),   MD = MA mod MB
!                                 When both the quotient and remainder are needed, this routine is
!                                 twice as fast as calling both IMDIV and IMMOD.

!  IMDVIR(MA,IVAL,MB,IREM)   MB = int(MA/IVAL),   IREM = MA mod IVAL
!                            IVAL and IREM are one word integers.

!  IMEQ(MA,MB)               MB = MA

!  IMFM2I(MAFM,MB)           MB = MAFM  Convert from real (FM) format to integer (IM) format.

!  IMFORM(FORM,MA,STRING)    MA is converted to a character string using format FORM and
!                               returned in STRING.  FORM can represent I, F, E, or ES formats.
!                               Example: CALL IMFORM('I70',MA,STRING)

!  IMFPRINT(FORM,MA)         Print MA on unit KW using FORM format.     < old name: IMFPRT >

!  IMGCD(MA,MB,MC)           MC = greatest common divisor of MA and MB.

!  IMI2FM(MA,MBFM)           MBFM = MA  Convert from integer (IM) format to real (FM) format.

!  IMI2M(IVAL,MA)            MA = IVAL   Convert from one word integer to IM.

!  IMINP(LINE,MA,LA,LB)      MA = LINE   Input conversion.
!                                        Convert LINE(LA) through LINE(LB) from characters to IM.

!  IMM2DP(MA,X)              X  = MA     Convert from IM to double precision.

!  IMM2I(MA,IVAL)            IVAL = MA   Convert from IM to one word integer.

!  IMM2SP(MA,X)              X  = MA     Convert from IM to single precision.

!  IMMAX(MA,MB,MC)           MC = MAX(MA,MB)

!  IMMIN(MA,MB,MC)           MC = MIN(MA,MB)

!  IMMOD(MA,MB,MC)           MC = MA mod MB

!  IMMPY(MA,MB,MC)           MC = MA*MB

!  IMMPYI(MA,IVAL,MB)        MB = MA*IVAL    Multiply by a one word integer.

!  IMMPY_MOD(MA,MB,MC,MD)    MD = MA*MB mod MC     < old name: IMMPYM >
!                                 Slightly faster than calling IMMPY and IMMOD separately.

!  IMOUT(MA,LINE,LB)         LINE = MA   Convert from IM to character.
!                                        LINE is a character array of length LB.

!  IMPOWER(MA,MB,MC)         MC = MA**MB     < old name: IMPWR >

!  IMPOWER_MOD(MA,MB,MC,MD)  MD = MA**MB mod MC     < old name: IMPMOD >

!  IMPRINT(MA)               Print MA on unit KW.     < old name: IMPRNT >

!  IMREAD(KREAD,MA)          MA   is returned after reading one (possibly multi-line)
!                                 IM number on unit KREAD.
!                                 This routine reads numbers written by IMWRITE.

!  IMSIGN(MA,MB,MC)          MC = SIGN(MA,MB)   Returns the absolute value of MA times the
!                                               sign of MB.

!  IMSQR(MA,MB)              MB = MA*MA   Faster than IMMPY.

!  IMST2M(STRING,MA)         MA = STRING
!                                 Convert from character string to IM.
!                                 IMST2M is often more convenient than IMINP, which converts
!                                 an array of character(1) values.  Example:
!                                      CALL IMST2M('12345678901',MA)

!  IMSUB(MA,MB,MC)           MC = MA - MB

!  IMWRITE(KWRITE,MA)        Write MA on unit KWRITE.
!                            Multi-line numbers will have '&' as the last nonblank character on all
!                            but the last line.  These numbers can then be read easily using IMREAD.


!  These are the routines that deal with multiple precision complex numbers.
!  All are subroutines, and in each case the version of the routine to handle packed ZM numbers has
!  the same name, with 'ZM' replaced by 'ZP'.

!  MA, MB, MC refer to ZM format complex numbers.
!  MAFM, MBFM, MCFM refer to FM format real numbers.
!  INTEG is a Fortran INTEGER variable.
!  ZVAL is a Fortran COMPLEX variable.

!  ZMABS(MA,MBFM)            MBFM = ABS(MA)    Result is real.

!  ZMACOS(MA,MB)             MB = ACOS(MA)

!  ZMADD(MA,MB,MC)           MC = MA + MB

!  ZMADDI(MA,INTEG)          MA = MA + INTEG  Increment an ZM number by a one word integer.
!                                             Note this call does not have an "MB" result
!                                             like ZMDIVI and ZMMPYI.

!  ZMARG(MA,MBFM)            MBFM = Argument(MA)    Result is real.

!  ZMASIN(MA,MB)             MB = ASIN(MA)

!  ZMATAN(MA,MB)             MB = ATAN(MA)

!  ZMCOMPLEX(MAFM,MBFM,MC)   MC = CMPLX(MAFM,MBFM)     < old name: ZMCMPX >

!  ZMCONJUGATE(MA,MB)        MB = CONJG(MA)     < old name: ZMCONJ >

!  ZMCOS(MA,MB)              MB = COS(MA)

!  ZMCOS_SIN(MA,MB,MC)       MB = COS(MA),  MC = SIN(MA).     < old name: ZMCSSN >
!                                 Faster than 2 calls.

!  ZMCOSH(MA,MB)             MB = COSH(MA)

!  ZMCOSH_SINH(MA,MB,MC)     MB = COSH(MA),  MC = SINH(MA).     < old name: ZMCHSH >
!                                 Faster than 2 calls.

!  ZMDIV(MA,MB,MC)           MC = MA / MB

!  ZMDIVI(MA,INTEG,MB)       MB = MA / INTEG

!  ZMEQ(MA,MB)               MB = MA

!  ZMEQU(MA,MB,NDA,NDB)      MB = MA    Version for changing precision.
!                                       (NDA and NDB are as in FMEQU)

!  ZMEXP(MA,MB)              MB = EXP(MA)

!  ZMFORM(FORM1,FORM2,MA,STRING)
!                            STRING = MA
!                            MA is converted to a character string using format FORM1 for the real
!                            part and FORM2 for the imaginary part.  The result is returned in
!                            STRING.  FORM1 and FORM2 can represent I, F, E, or ES formats.
!                            Example:
!                                  CALL ZMFORM('F20.10','F15.10',MA,STRING)

!  ZMFPRINT(FORM1,FORM2,MA)  Print MA on unit KW using formats FORM1 and FORM2.
!                            < old name: ZMFPRT >

!  ZMI2M(INTEG,MA)           MA = CMPLX(INTEG,0)

!  ZM2I2M(INTEG1,INTEG2,MA)  MA = CMPLX(INTEG1,INTEG2)

!  ZMIMAG(MA,MBFM)           MBFM = IMAG(MA)    Imaginary part.

!  ZMINP(LINE,MA,LA,LB)      MA = LINE   Input conversion.
!                                 Convert LINE(LA) through LINE(LB) from characters to ZM.
!                                 LINE is a character array of length at least LB.

!  ZMINT(MA,MB)              MB = INT(MA)       Integer part of both Real and Imaginary parts of MA.

!  ZMIPOWER(MA,INTEG,MB)     MB = MA ** INTEG   Integer power function.     < old name: ZMIPWR >

!  ZMLOG10(MA,MB)            MB = LOG10(MA)     < old name: ZMLG10 >

!  ZMLN(MA,MB)               MB = LOG(MA)

!  ZMM2I(MA,INTEG)           INTEG = INT(REAL(MA))

!  ZMM2Z(MA,ZVAL)            ZVAL = MA

!  ZMMPY(MA,MB,MC)           MC = MA * MB

!  ZMMPYI(MA,INTEG,MB)       MB = MA * INTEG

!  ZMNINT(MA,MB)             MB = NINT(MA)   Nearest integer of both Real and Imaginary.

!  ZMOUT(MA,LINE,LB,LAST1,LAST2)
!                            LINE = MA
!                            Convert from FM to character.
!                            LINE  is the returned character(1) array.
!                            LB    is the dimensioned size of LINE.
!                            LAST1 is returned as the position in LINE of the last character
!                                  of REAL(MA)
!                            LAST2 is returned as the position in LINE of the last character
!                                  of AIMAG(MA)

!  ZMPOWER(MA,MB,MC)         MC = MA ** MB     < old name: ZMPWR >

!  ZMPRINT(MA)               Print MA on unit KW using current format.     < old name: ZMPRNT >

!  ZMRATIONAL_POWER(MA,IVAL,JVAL,MB)
!                            MB = MA ** (IVAL/JVAL)     < old name: ZMRPWR >

!  ZMREAD(KREAD,MA)          MA   is returned after reading one (possibly multi-line) ZM number on
!                                 unit KREAD.  This routine reads numbers written by ZMWRITE.

!  ZMREAL(MA,MBFM)           MBFM = REAL(MA)    Real part.

!  ZMSET(NPREC)              Set precision to the equivalent of a few more than NPREC base 10
!                            digits.  This is now the same as FMSET, but is retained for
!                            compatibility with earlier versions of the package.

!  ZMSIN(MA,MB)              MB = SIN(MA)

!  ZMSINH(MA,MB)             MB = SINH(MA)

!  ZMSQR(MA,MB)              MB = MA*MA    Faster than ZMMPY.

!  ZMSQRT(MA,MB)             MB = SQRT(MA)

!  ZMST2M(STRING,MA)         MA = STRING
!                                 Convert from character string to ZM.  ZMST2M is often more
!                                 convenient than ZMINP, which converts an array of character(1)
!                                 values.  Example:
!                                       CALL ZMST2M('123.4+5.67i',MA).

!  ZMSUB(MA,MB,MC)           MC = MA - MB

!  ZMTAN(MA,MB)              MB = TAN(MA)

!  ZMTANH(MA,MB)             MB = TANH(MA)

!  ZMWRITE(KWRITE,MA)        Write MA on unit KWRITE.  Multi-line numbers are formatted for
!                            automatic reading with ZMREAD.     < old name: ZMWRIT >

!  ZMZ2M(ZVAL,MA)            MA = ZVAL


!  10. EFFICIENCY

!  To take advantage of hardware architecture on different machines, the package has been designed
!  so that the arithmetic used to perform the multiple precision operations can easily be changed.
!  All variables that must be changed to get a different arithmetic have names beginning with 'M'
!  and are declared using REAL (KIND(1.0D0)) ...

!  For example, to change the package to use integer arithmetic internally, make these two changes
!  everywhere in the FM.f95 file.
!  Change  'REAL (KIND(1.0D0))'  to  'INTEGER'.
!  Change  'AINT ('  to  '('.  Note the blank between AINT and (.

!  In many places in FM, an AINT function is not supposed to be changed.  These are written 'AINT(',
!  with no embedded blank, so they will not be changed by the global change above.

!  The first of these changes must also be made throughout the file FMSAVE.f95.
!  Change  'REAL (KIND(1.0D0))'  to  'INTEGER'.

!  Many of the variables in FMSAVE.f95 are initialized when they are declared, so the initialization
!  values should be changed to integer values.  Find the lines beginning  '! Integer initialization'
!  in FMSAVE.f95 and change the values.  The values needed for 32-bit integer arithmetic are next to
!  the double precision values, but commented out.  In every case, the line before the '! Integer
!  initialization' should have '!' inserted in column 1 and the line after should have the '!'
!  removed from column 1.  If a different wordsize is used, the first call to FMSET will check the
!  values defined in file FMSAVE.f95 and write messages (on unit KW) if any need to be changed.

!  This version of FM restricts the base used to be also representable in integer variables, so
!  using precision above double usually does not save much time unless integers can also be declared
!  at a higher precision.  Using IEEE Extended would allow a base of around 10**9 to be chosen, but
!  the delayed digit-normalization method used for multiplication and division means that a slightly
!  smaller base like 10**8 would probably run faster.  This would usually not be much faster than
!  using the usual base 10**7 with double precision.

!  For cases where special compiler directives or minor re-writing of the code may improve speed,
!  several of the most important loops in FM are identified by comments containing the string
!  '(Inner Loop)'.


!  10. NEW FOR VERSION 1.3

!  The routines for the exponential integral function and related mathematical special functions
!  are new in version 1.3.  These routines are:
!  FMBESJ, FMBESY, FMC, FMCHI, FMCI, FMEI, FMEN, FMERF, FMERFC, FMLERC, FMLI, FMS, FMSHI, FMSI.

!  Some of the routines were moved between files FM.f95 and FMZM90.f95 so that now all routines
!  using the module FMZM (in file FMZM90.f95) for multiple precision derived types and operator
!  overloading are located in FMZM90.f95.  This means that programs not using derived types can
!  skip compiling and/or linking FMZM90.f95.

!  The array function DOTPRODUCT in FMZM has been re-named DOT_PRODUCT to agree with the Fortran
!  standard.  For type ZM complex arguments its definition has been changed to agree with the
!  Fortran intrinsic function.  When X and Y are complex, DOT_PRODUCT(X,Y) is not just the sum of
!  the products of the corresponding array elements, as it is for types FM and IM.  For type ZM,
!  the formula is the sum of conjg(X(j)) * Y(j).  This definition is used so that the complex dot
!  product will be an inner product in the mathematical sense.

!  New routines have been added to module FMZM to provide array syntax for the three multiple
!  precision derived types.  This means statements like V = 1 and A = B + C now work when these
!  variables are vectors or matrices of multiple precision numbers.

!  One routine from FM 1.2 has been split into three routines in version 1.3.  The routine
!  FM_RANDOM_SEED from FM 1.2 has become three subroutines, so that the optional arguments and
!  the need for an explicit interface can be avoided.  See the three routines starting with
!  FM_RANDOM_SEED in the list above.  The same multiplicative congruential generator as before
!  is used, but the shuffling of those values has been removed, so that saving seeds and
!  re-starting the generator now works more like the standard Fortran random function.

!  Multiple precision variables were separate fixed-size arrays in previous versions.  Now they are
!  single integers that serve as index values to a single large array (MWK, defined in file
!  FMSAVE.f95) where the actual values are stored.  This often improves both efficiency and memory
!  utilization, since many compilers implemented the derived type operations using copy in and copy
!  out of the arguments for a given operation.  Copying entire arrays was slower, and there were
!  often memory leaks when the compiler automatically created temporary derived type objects while
!  evaluating derived type expressions.  The static arrays in previous versions also meant that
!  memory was wasted when only a few kinds of operations were used at high precision.  Now the
!  space needed by any unused operations never gets allocated.

!  Some new error checking is now done for the derived type multiple precision variables. Attempting
!  to use an undefined variable will cause an error message to be printed.

!  Much higher precision can be attained in version 1.3, since machines are faster and have more
!  memory.  To support higher precision, a routine for FFT-based multiplication has been included,
!  and when precision gets high enough, the algorithms for multiplication, division, squares, square
!  roots, etc., will switch to the FFT routine.

!  Binary splitting algorithms are used for the mathematical constants at high precision.  At the
!  time version 1.3 was released, computing a million digits of e, pi, or the logarithm of a small
!  integer took a few seconds, while a million digits of Euler's constant took a few minutes.

!  Perfect rounding is now done all the time.  In version 1.2 perfect rounding was an option, but
!  the default rounding could round the wrong direction once every few million operations, when the
!  exact result was very close to halfway between two adjacent representable numbers.

! --------------------------------------------------------------------------------------------------
! --------------------------------------------------------------------------------------------------



      SUBROUTINE FMSET(NPREC)

!  Initialize the global FM variables that must be set before calling other FM routines.
!  These variables are initialized to fairly standard values in the FMSAVE.f95 file (MODULE FMVALS),
!  so calling FMSET at the beginning of a program is now optional.  FMSET is a convenient way to set
!  or change the precision being used, and it also checks to see that the generic values chosen for
!  several machine-dependent variables are valid.

!  Base and precision will be set to give at least NPREC+3 decimal digits of precision (giving the
!  user at least three base ten guard digits).  When the base is large, each extra word contains
!  several extra digits when viewed in base ten.  This means that some choices of NPREC will give
!  a few more than three base ten guard digits.

!  MBASE (base for FM arithmetic) is set to a large power of ten.
!  JFORM1 and JFORM2 (default output format controls) are set to ES format displaying NPREC
!  significant digits.

!  Several FM options were set here in previous versions of the package, and are now initialized to
!  their default values in module FMVALS.
!  Here are the initial settings:

!  The trace option is set off.
!  The mode for angles in trig functions is set to radians.
!  The rounding mode is set to symmetric rounding.
!  Warning error message level is set to 1.
!  Cancellation error monitor is set off.
!  Screen width for output is set to 80 columns.
!  The exponent character for FM output is set to 'M'.
!  Debug error checking is set off.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NPREC

      REAL (KIND(1.0D0)) :: MAXINT_CHK,MXEXP2_CHK,MEXPOV_CHK,MEXPUN_CHK,MUNKNO_CHK
      DOUBLE PRECISION :: DPEPS_CHK,DPMAX_CHK,SPMAX_CHK,TEMP
      INTEGER :: INTMAX_CHK,K,NPSAVE
      INTENT (IN) :: NPREC

!             MAXINT should be set to a very large integer, possibly the largest representable
!                    integer for the current machine.  For most 32-bit machines, MAXINT is set
!                    to  2**53 - 1 = 9.007D+15  when double precision arithmetic is used for
!                    M-variables.  Using integer M-variables usually gives
!                    MAXINT = 2**31 - 1 = 2147483647.

!                    Setting MAXINT to a smaller number is ok, but this unnecessarily restricts
!                    the permissible range of MBASE and MXEXP.

      MAXINT_CHK = RADIX(MAXINT_CHK)
      MAXINT_CHK = ((MAXINT_CHK**(DIGITS(MAXINT_CHK)-1)-1)*MAXINT_CHK - 1) + MAXINT_CHK
      IF (MAXINT > MAXINT_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MAXINT was set to ',MAXINT,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',MAXINT_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MAXINT has been changed to ',MAXINT_CHK
          WRITE (KW,*) ' '
          MAXINT = MAXINT_CHK
      ELSE IF (MAXINT < MAXINT_CHK/2) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MAXINT was set to ',MAXINT,' in file FMSAVE.f95'
          WRITE (KW,*) ' For better performance set it to ',MAXINT_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MAXINT has been changed to ',MAXINT_CHK
          WRITE (KW,*) ' '
          MAXINT = MAXINT_CHK
      ENDIF

!             INTMAX is a large value close to the overflow threshold for integer variables.
!                    It is usually 2**31 - 1 for machines with 32-bit integer arithmetic.

!                    The following code sets INTMAX_CHK to the largest representable integer.
!                    Then INTMAX is checked against this value.

      INTMAX_CHK = HUGE(1)
      IF (INTMAX > INTMAX_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' INTMAX was set to ',INTMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',INTMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, INTMAX has been changed to ',INTMAX_CHK
          WRITE (KW,*) ' '
          INTMAX = INTMAX_CHK
      ELSE IF (INTMAX < INTMAX_CHK/2) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' INTMAX was set to ',INTMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For better performance set it to ',INTMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, INTMAX has been changed to ',INTMAX_CHK
          WRITE (KW,*) ' '
          INTMAX = INTMAX_CHK
      ENDIF

!             DPMAX should be set to a value near the machine's double precision overflow threshold,
!                   so that DPMAX and 1.0D0/DPMAX are both representable in double precision.

      DPMAX_CHK = HUGE(1.0D0)/5
      IF (DPMAX > DPMAX_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' DPMAX was set to ',DPMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',DPMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, DPMAX has been changed to ',DPMAX_CHK
          WRITE (KW,*) ' '
          DPMAX = DPMAX_CHK
      ELSE IF (DPMAX < DPMAX_CHK/1.0D2) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' DPMAX was set to ',DPMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For better performance set it to ',DPMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, DPMAX has been changed to ',DPMAX_CHK
          WRITE (KW,*) ' '
          DPMAX = DPMAX_CHK
      ENDIF

!             SPMAX should be set to a value near the machine's single precision overflow threshold,
!                   so that 1.01*SPMAX and 1.0/SPMAX are both representable in single precision.

      SPMAX_CHK = HUGE(1.0)/5
      IF (SPMAX > SPMAX_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' SPMAX was set to ',SPMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',SPMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, SPMAX has been changed to ',SPMAX_CHK
          WRITE (KW,*) ' '
          SPMAX = SPMAX_CHK
      ELSE IF (SPMAX < SPMAX_CHK/1.0D2) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' SPMAX was set to ',SPMAX,' in file FMSAVE.f95'
          WRITE (KW,*) ' For better performance set it to ',SPMAX_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, SPMAX has been changed to ',SPMAX_CHK
          WRITE (KW,*) ' '
          SPMAX = SPMAX_CHK
      ENDIF

!             MXBASE is the maximum value for MBASE.

      TEMP = MAXINT
      TEMP = INT(MIN(DBLE(INTMAX),SQRT(TEMP)))
      IF (MXBASE > TEMP) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MXBASE was set to ',MXBASE,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',TEMP
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MXBASE has been changed to ',TEMP
          WRITE (KW,*) ' '
          MXBASE = TEMP
      ELSE IF (MXBASE < TEMP/2) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MXBASE was set to ',MXBASE,' in file FMSAVE.f95'
          WRITE (KW,*) ' For better performance set it to ',TEMP
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MXBASE has been changed to ',TEMP
          WRITE (KW,*) ' '
          MXBASE = TEMP
      ENDIF

!             KROUND controls the rounding mode.  Set it to symmetric rounding.

      KROUND = 1

!             MBASE is the currently used base for arithmetic.

      K = INT(LOG10(DBLE(MXBASE)/4))
      MBASE = 10**K

!             NDIG is the number of digits currently being carried.

      NPSAVE = NPREC
      NDIG = 2 + (NPREC+2)/K
      IF (NDIG < 2) THEN
          NDIG = MAX(2,NDIG)
          WRITE (KW,  &
                 "(//' Precision out of range when calling FMSET.',"  //  &
                 "'  NPREC =',I20/' The nearest valid NDIG will be'," //  &
                 "' used instead:   NDIG =',I20//)"                        &
                ) NPREC,NDIG
          NPSAVE = 0
      ENDIF

!             NCALL is the call stack pointer.

      NCALL = 0

!             MXEXP  is the current maximum exponent.
!             MXEXP2 is the internal maximum exponent.  This is used to define the overflow and
!                    underflow thresholds.

!             These values are chosen so that FM routines can raise the overflow/underflow limit
!             temporarily while computing intermediate results, and so that EXP(INTMAX) is greater
!             than MXBASE**(MXEXP2+1).

!             The overflow threshold is MBASE**(MXEXP+1), and the underflow threshold is
!             MBASE**(-MXEXP-1).  This means the valid exponents in the first word of an FM number
!             can range from -MXEXP to MXEXP+1 (inclusive).

      MXEXP = INT((DBLE(INTMAX))/(2.0D0*LOG(DBLE(MXBASE))) - 1.0D0)
      MXEXP2_CHK = INT(2*MXEXP + MXEXP/100)
      IF (MXEXP2 > MXEXP2_CHK*1.01) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MXEXP2 was set to ',MXEXP2,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',MXEXP2_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MXEXP2 has been changed to ',MXEXP2_CHK
          WRITE (KW,*) ' '
          MXEXP2 = MXEXP2_CHK
      ELSE IF (MXEXP2 < MXEXP2_CHK*0.99) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MXEXP2 was set to ',MXEXP2,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no less than ',MXEXP2_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MXEXP2 has been changed to ',MXEXP2_CHK
          WRITE (KW,*) ' '
          MXEXP2 = MXEXP2_CHK
      ENDIF

!             KACCSW is a switch used to enable cancellation error monitoring.  Routines where
!                    cancellation is not a problem run faster by skipping the cancellation monitor
!                    calculations.
!                    KACCSW = 0 means no error monitoring,
!                           = 1 means error monitoring is done.

      KACCSW = 0

!             MEXPUN is the exponent used as a special symbol for underflowed results.

      MEXPUN_CHK = -AINT(MXEXP2*1.01D0)
      IF (MEXPUN < MEXPUN_CHK*1.01) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MEXPUN was set to ',MEXPUN,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no less than ',MEXPUN_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MEXPUN has been changed to ',MEXPUN_CHK
          WRITE (KW,*) ' '
          MEXPUN = MEXPUN_CHK
      ELSE IF (MEXPUN > MEXPUN_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MEXPUN was set to ',MEXPUN,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',MEXPUN_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MEXPUN has been changed to ',MEXPUN_CHK
          WRITE (KW,*) ' '
          MEXPUN = MEXPUN_CHK
      ENDIF

!             MEXPOV is the exponent used as a special symbol for overflowed results.

      MEXPOV_CHK = -MEXPUN
      IF (MEXPOV /= MEXPOV_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MEXPOV was set to ',MEXPOV,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be ',MEXPOV_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MEXPOV has been changed to ',MEXPOV_CHK
          WRITE (KW,*) ' '
          MEXPOV = MEXPOV_CHK
      ENDIF

!             MUNKNO is the exponent used as a special symbol for unknown FM results
!                    (1/0, SQRT(-3.0), ...).

      MUNKNO_CHK = AINT(MEXPOV*1.01D0)
      IF (MUNKNO > MUNKNO_CHK*1.01) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MUNKNO was set to ',MUNKNO,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',MUNKNO_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MUNKNO has been changed to ',MUNKNO_CHK
          WRITE (KW,*) ' '
          MUNKNO = MUNKNO_CHK
      ELSE IF (MUNKNO < MUNKNO_CHK) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' MUNKNO was set to ',MUNKNO,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no less than ',MUNKNO_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, MUNKNO has been changed to ',MUNKNO_CHK
          WRITE (KW,*) ' '
          MUNKNO = MUNKNO_CHK
      ENDIF

!             RUNKNO is returned from FM to real or double conversion routines when no valid result
!                    can be expressed in real or double precision.  On systems that provide a value
!                    for undefined results (e.g., Not A Number) setting RUNKNO to that value is
!                    reasonable.  On other systems set it to a value that is likely to make any
!                    subsequent results obviously wrong that use it.  In either case a KFLAG = -4
!                    condition is also returned.

      RUNKNO = -1.01*SPMAX

!             IUNKNO is returned from FM to integer conversion routines when no valid result can be
!                    expressed as a one word integer.  KFLAG = -4 is also set.

      IUNKNO = -INT(MXEXP2)

!             DPEPS is the approximate machine precision.

      DPEPS_CHK = EPSILON(1.0D0)
      IF (DPEPS > DPEPS_CHK*1.01) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' DPEPS was set to ',DPEPS,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no more than ',DPEPS_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, DPEPS has been changed to ',DPEPS_CHK
          WRITE (KW,*) ' '
          DPEPS = DPEPS_CHK
      ELSE IF (DPEPS < DPEPS_CHK*0.99) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' In routine FMSET it appears that FM internal variable'
          WRITE (KW,*) ' DPEPS was set to ',DPEPS,' in file FMSAVE.f95'
          WRITE (KW,*) ' For this machine it should be no less than ',DPEPS_CHK
          WRITE (KW,*) ' Change the initialization in FMSAVE.f95 to this value.'
          WRITE (KW,*) ' For this run, DPEPS has been changed to ',DPEPS_CHK
          WRITE (KW,*) ' '
          DPEPS = DPEPS_CHK
      ENDIF

!             JFORM1 indicates the format used by FMOUT.

      JFORM1 = 1

!             JFORM2 indicates the number of digits used in FMOUT.

      JFORM2 = NPSAVE

!             Set JFORMZ to ' 1.23 + 4.56 i ' format.

      JFORMZ = 1

!             Set JPRNTZ to print real and imaginary parts on one line whenever possible.

      JPRNTZ = 1

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      CALL FMHTBL

!             FMCONS sets several real and double precision constants.

      CALL FMCONS

      RETURN
      END SUBROUTINE FMSET

      SUBROUTINE FMABS(MA,MB)

!  MB = ABS(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      REAL (KIND(1.0D0)) :: MD2B
      INTEGER :: KWRNSV

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMABS'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)

      KFLAG = 0
      KWRNSV = KWARN
      KWARN = 0
      CALL FMEQ(MA,MB)
      MWK(START(MB)) = 1
      KWARN = KWRNSV

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MWK(START(MB)+1),MD2B)
      ENDIF
      IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMABS

      SUBROUTINE FMACOS(MA,MB)

!  MB = ACOS(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. KRAD == 0) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMACOS'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMI2M(180,MXY(1))
          CALL FMPI(MXY(2))
          CALL FMDIV(MXY(1),MXY(2),MXY(3))
          IF (MWK(START(MA)+2) > MEXPUN) THEN
              CALL FMMPY(MXY(3),MA,MXY(2))
          ELSE
              CALL FMEQ(MA,MXY(2))
          ENDIF
          CALL FMI2M(90,MXY(1))
          CALL FMSUB(MXY(1),MXY(2),MB)
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMACOS'
              KFLAG = -4
              CALL FMWARN
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMACOS'
              IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
              CALL FMWARN
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMACOS'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+2) > 0 .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMACOS   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMACOS'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MAS = MWK(START(MA))
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(6),NDSAVE,NDIG)
      MWK(START(MXY(6))+1) = NINT(NDIG*ALOGM2)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMST2M('0.5',MXY(1))
          CALL FMSUB(MXY(6),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('60',MXY(6))
              GO TO 120
          ENDIF
          CALL FMADD(MXY(6),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('120',MXY(6))
              GO TO 120
          ENDIF
      ENDIF

!             Use ACOS(X) = ATAN(SQRT(1-X*X)/X)

      MWK(START(MXY(6))) = 1
      CALL FMI2M(1,MXY(4))
      CALL FMSUB(MXY(4),MXY(6),MXY(2))
      CALL FMADD(MXY(4),MXY(6),MXY(3))
      CALL FMMPY_R2(MXY(2),MXY(3))
      CALL FMSQRT_R1(MXY(3))
      CALL FMDIV(MXY(3),MXY(6),MXY(5))
      CALL FMATAN(MXY(5),MXY(6))

      IF (MAS < 0) THEN
          IF (KRAD == 1) THEN
              CALL FMPI(MXY(4))
          ELSE
              CALL FMI2M(180,MXY(4))
          ENDIF
          CALL FMSUB_R2(MXY(4),MXY(6))
      ENDIF

!             Round the result and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(6))+3))+1))/0.69315)
      MWK(START(MXY(6))+1) = MIN(MWK(START(MXY(6))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(6))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMACOS

      SUBROUTINE FMADD(MA,MB,MC)

!  MC = MA + MB

!  This routine performs the trace printing for addition.  FMADD2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMADD'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMADD2(MA,MB,MC)

          CALL FMNTR(1,MC,MC,1,1)
      ELSE
          CALL FMADD2(MA,MB,MC)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD

      SUBROUTINE FMADD2(MA,MB,MC)

!  Internal addition routine.  MC = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MA0,MA1,MA2,MAS,MB0,MB1,MB2,MB2RD,MBS
      INTEGER :: J,JCOMP,JRSSAV,JSIGN,KRESLT,N1,NGUARD,NMWA
      REAL :: B2RDA,B2RDB
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MA2 = MWK(START(MA)+3)
      MB2 = MWK(START(MB)+3)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          IF (KSUB == 1) THEN
              CALL FMARGS('FMSUB    ',2,MA,MB,KRESLT)
          ELSE
              CALL FMARGS('FMADD    ',2,MA,MB,KRESLT)
          ENDIF
          IF (KRESLT /= 0) THEN
              IF ((KRESLT /= 1 .AND. KRESLT /= 2) .OR. MWK(START(MA)+3) == 0 .OR.  &
                  MWK(START(MB)+3) == 0) THEN
                  NCALL = NCALL + 1
                  IF (KSUB == 1) THEN
                      NAMEST(NCALL) = 'FMSUB'
                  ELSE
                      NAMEST(NCALL) = 'FMADD'
                  ENDIF
                  CALL FMRSLT(MA,MB,MC,KRESLT)
                  JRSIGN = JRSSAV
                  NCALL = NCALL - 1
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
      ELSE
          IF (MWK(START(MA)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              CALL FMEQ(MB,MC)
              MWK(START(MC)+1) = MA0
              KFLAG = 1
              IF (KSUB == 1) THEN
                  IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
                      MWK(START(MC)) = -MWK(START(MC))
                  KFLAG = 0
              ENDIF
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MB)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              CALL FMEQ(MA,MC)
              MWK(START(MC)+1) = MA0
              KFLAG = 1
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

      MA0 = MWK(START(MA)+1)
      IF (KACCSW == 1) THEN
          MB0 = MWK(START(MB)+1)
          MA1 = MWK(START(MA)+2)
          MB1 = MWK(START(MB)+2)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KROUND_RETRY >= 1) THEN
              NGUARD = NDIG
          ENDIF
      ENDIF
      NMWA = N1 + NGUARD

!             Save the signs of MA and MB and then work with positive numbers.
!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF (KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
      ELSE IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MWK(START(MA)+J+1) > MWK(START(MB)+J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MWK(START(MB)+J+1) > MWK(START(MA)+J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MA,MB,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MA,MB,NGUARD,NMWA)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MB,MA,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MB,MA,NGUARD,NMWA)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (KROUND_RETRY == 1 .AND. NGUARD < NDIG) THEN
          KROUND_RETRY = 2
          GO TO 110
      ENDIF

!             Transfer to MC and fix the sign of the result.

      CALL FMMOVE(MWA,MC)
      MWK(START(MC)) = 1
      IF (JSIGN < 0 .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1

      IF (KFLAG < 0) THEN
          IF (KSUB == 1) THEN
              NAMEST(NCALL) = 'FMSUB'
          ELSE
              NAMEST(NCALL) = 'FMADD'
          ENDIF
          CALL FMWARN
      ENDIF

      IF (KACCSW == 1) THEN
          B2RDA = LOG(REAL(ABS(MWK(START(MC)+3))+1)/REAL(ABS(MA2)+1))/0.69315 +  &
                  REAL(MWK(START(MC)+2)-MA1)*ALOGM2 + REAL(MA0)
          B2RDB = LOG(REAL(ABS(MWK(START(MC)+3))+1)/REAL(ABS(MB2)+1))/0.69315 +  &
                  REAL(MWK(START(MC)+2)-MB1)*ALOGM2 + REAL(MB0)
          MB2RD = NINT(MAX(0.0,MIN(B2RDA,B2RDB,  &
                  (NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MC)+3))+1))/0.69315)))
          IF (MWK(START(MC)+3) == 0) THEN
              MWK(START(MC)+1) = 0
          ELSE
              MWK(START(MC)+1) = MIN(MAX(MA0,MB0),MB2RD)
          ENDIF
      ELSE
          MWK(START(MC)+1) = MA0
      ENDIF

      JRSIGN = JRSSAV
      KROUND_RETRY = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD2

      SUBROUTINE FMADD_R1(MA,MB)

!  MA = MA + MB

!  This routine performs the trace printing for addition.  FMADD2_R1 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMADD_R1'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMADD2_R1(MA,MB)

          NAMEST(NCALL) = 'FMADD_R1'
          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMADD2_R1(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD_R1

      SUBROUTINE FMADD2_R1(MA,MB)

!  Internal addition routine.  MA = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MA0,MA1,MA2,MAS,MB0,MB1,MB2,MB2RD,MBS
      INTEGER :: J,JCOMP,JRSSAV,JSIGN,KRESLT,N1,NGUARD,NMWA
      REAL :: B2RDA,B2RDB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MA2 = MWK(START(MA)+3)
      MB2 = MWK(START(MB)+3)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          IF (KSUB == 1) THEN
              CALL FMARGS('FMSUB    ',2,MA,MB,KRESLT)
          ELSE
              CALL FMARGS('FMADD    ',2,MA,MB,KRESLT)
          ENDIF
          IF (KRESLT /= 0) THEN
              IF ((KRESLT /= 1 .AND. KRESLT /= 2) .OR. MWK(START(MA)+3) == 0 .OR.  &
                  MWK(START(MB)+3) == 0) THEN
                  NCALL = NCALL + 1
                  IF (KSUB == 1) THEN
                      NAMEST(NCALL) = 'FMSUB_R1'
                  ELSE
                      NAMEST(NCALL) = 'FMADD_R1'
                  ENDIF
                  CALL FMRSLT(MA,MB,MXY(1),KRESLT)
                  CALL FMEQ(MXY(1),MA)
                  JRSIGN = JRSSAV
                  NCALL = NCALL - 1
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MA) == -1) TEMPV(MA) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
      ELSE
          IF (MWK(START(MA)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              CALL FMEQ(MB,MA)
              MWK(START(MA)+1) = MA0
              KFLAG = 1
              IF (KSUB == 1) THEN
                  IF (MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0)  &
                      MWK(START(MA)) = -MWK(START(MA))
                  KFLAG = 0
              ENDIF
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MB)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MA)+1) = MA0
              KFLAG = 1
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

      MA0 = MWK(START(MA)+1)
      IF (KACCSW == 1) THEN
          MB0 = MWK(START(MB)+1)
          MA1 = MWK(START(MA)+2)
          MB1 = MWK(START(MB)+2)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KROUND_RETRY >= 1) THEN
              NGUARD = NDIG
          ENDIF
      ENDIF
      NMWA = N1 + NGUARD

!             Save the signs of MA and MB and then work with positive numbers.
!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF (KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
      ELSE IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MWK(START(MA)+J+1) > MWK(START(MB)+J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MWK(START(MB)+J+1) > MWK(START(MA)+J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MA,MB,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MA,MB,NGUARD,NMWA)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MB,MA,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MB,MA,NGUARD,NMWA)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (KROUND_RETRY == 1 .AND. NGUARD < NDIG) THEN
          KROUND_RETRY = 2
          GO TO 110
      ENDIF

!             Transfer to MA and fix the sign of the result.

      CALL FMMOVE(MWA,MA)
      MWK(START(MA)) = 1
      IF (JSIGN < 0 .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1

      IF (KFLAG < 0) THEN
          IF (KSUB == 1) THEN
              NAMEST(NCALL) = 'FMSUB_R1'
          ELSE
              NAMEST(NCALL) = 'FMADD_R1'
          ENDIF
          CALL FMWARN
      ENDIF

      IF (KACCSW == 1) THEN
          B2RDA = LOG(REAL(ABS(MWK(START(MA)+3))+1)/REAL(ABS(MA2)+1))/0.69315 +  &
                  REAL(MWK(START(MA)+2)-MA1)*ALOGM2 + REAL(MA0)
          B2RDB = LOG(REAL(ABS(MWK(START(MA)+3))+1)/REAL(ABS(MB2)+1))/0.69315 +  &
                  REAL(MWK(START(MA)+2)-MB1)*ALOGM2 + REAL(MB0)
          MB2RD = NINT(MAX(0.0,MIN(B2RDA,B2RDB,  &
                  (NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)))
          IF (MWK(START(MA)+3) == 0) THEN
              MWK(START(MA)+1) = 0
          ELSE
              MWK(START(MA)+1) = MIN(MAX(MA0,MB0),MB2RD)
          ENDIF
      ELSE
          MWK(START(MA)+1) = MA0
      ENDIF

      JRSIGN = JRSSAV
      KROUND_RETRY = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD2_R1

      SUBROUTINE FMADD_R2(MA,MB)

!  MB = MA + MB

!  This routine performs the trace printing for addition.  FMADD2_R2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMADD_R2'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMADD2_R2(MA,MB)

          NAMEST(NCALL) = 'FMADD_R2'
          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMADD2_R2(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD_R2

      SUBROUTINE FMADD2_R2(MA,MB)

!  Internal addition routine.  MB = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MA0,MA1,MA2,MAS,MB0,MB1,MB2,MB2RD,MBS
      INTEGER :: J,JCOMP,JRSSAV,JSIGN,KRESLT,N1,NGUARD,NMWA
      REAL :: B2RDA,B2RDB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MA2 = MWK(START(MA)+3)
      MB2 = MWK(START(MB)+3)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          IF (KSUB == 1) THEN
              CALL FMARGS('FMSUB    ',2,MA,MB,KRESLT)
          ELSE
              CALL FMARGS('FMADD    ',2,MA,MB,KRESLT)
          ENDIF
          IF (KRESLT /= 0) THEN
              IF ((KRESLT /= 1 .AND. KRESLT /= 2) .OR. MWK(START(MA)+3) == 0 .OR.  &
                  MWK(START(MB)+3) == 0) THEN
                  NCALL = NCALL + 1
                  IF (KSUB == 1) THEN
                      NAMEST(NCALL) = 'FMSUB_R2'
                  ELSE
                      NAMEST(NCALL) = 'FMADD_R2'
                  ENDIF
                  CALL FMRSLT(MA,MB,MXY(1),KRESLT)
                  CALL FMEQ(MXY(1),MB)
                  JRSIGN = JRSSAV
                  NCALL = NCALL - 1
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MB) == -1) TEMPV(MB) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
      ELSE
          IF (MWK(START(MA)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MB)+1) = MA0
              KFLAG = 1
              IF (KSUB == 1) THEN
                  IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
                      MWK(START(MB)) = -MWK(START(MB))
                  KFLAG = 0
              ENDIF
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MB)+3) == 0) THEN
              MA0 = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              CALL FMEQ(MA,MB)
              MWK(START(MB)+1) = MA0
              KFLAG = 1
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

      MA0 = MWK(START(MA)+1)
      IF (KACCSW == 1) THEN
          MB0 = MWK(START(MB)+1)
          MA1 = MWK(START(MA)+2)
          MB1 = MWK(START(MB)+2)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KROUND_RETRY >= 1) THEN
              NGUARD = NDIG
          ENDIF
      ENDIF
      NMWA = N1 + NGUARD

!             Save the signs of MA and MB and then work with positive numbers.
!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF (KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
      ELSE IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MWK(START(MA)+J+1) > MWK(START(MB)+J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MWK(START(MB)+J+1) > MWK(START(MA)+J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MA,MB,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MA,MB,NGUARD,NMWA)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          JRSIGN = JSIGN
          IF (MAS*MBS > 0) THEN
              CALL FMADDP(MB,MA,NGUARD,NMWA)
          ELSE
              CALL FMADDN(MB,MA,NGUARD,NMWA)
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (KROUND_RETRY == 1 .AND. NGUARD < NDIG) THEN
          KROUND_RETRY = 2
          GO TO 110
      ENDIF

!             Transfer to MB and fix the sign of the result.

      CALL FMMOVE(MWA,MB)
      MWK(START(MB)) = 1
      IF (JSIGN < 0 .AND. MWK(START(MB)+3) /= 0) MWK(START(MB)) = -1

      IF (KFLAG < 0) THEN
          IF (KSUB == 1) THEN
              NAMEST(NCALL) = 'FMSUB_R2'
          ELSE
              NAMEST(NCALL) = 'FMADD_R2'
          ENDIF
          CALL FMWARN
      ENDIF

      IF (KACCSW == 1) THEN
          B2RDA = LOG(REAL(ABS(MWK(START(MB)+3))+1)/REAL(ABS(MA2)+1))/0.69315 +  &
                  REAL(MWK(START(MB)+2)-MA1)*ALOGM2 + REAL(MA0)
          B2RDB = LOG(REAL(ABS(MWK(START(MB)+3))+1)/REAL(ABS(MB2)+1))/0.69315 +  &
                  REAL(MWK(START(MB)+2)-MB1)*ALOGM2 + REAL(MB0)
          MB2RD = NINT(MAX(0.0,MIN(B2RDA,B2RDB,  &
                  (NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)))
          IF (MWK(START(MB)+3) == 0) THEN
              MWK(START(MB)+1) = 0
          ELSE
              MWK(START(MB)+1) = MIN(MAX(MA0,MB0),MB2RD)
          ENDIF
      ELSE
          MWK(START(MB)+1) = MA0
      ENDIF

      JRSIGN = JRSSAV
      KROUND_RETRY = 0
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMADD2_R2

      SUBROUTINE FMADDI(MA,IVAL)

!  MA = MA + IVAL

!  Increment MA by one word integer IVAL.

!  This routine is faster than FMADD when IVAL is small enough so that it can be added to a single
!  word of MA without often causing a carry.  Otherwise FMI2M and FMADD are used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MAEXP,MD2B,MKSUM
      INTEGER :: KPTMA
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMADDI'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
      ENDIF
      KFLAG = 0

      MAEXP = MWK(START(MA)+2)
      IF (MAEXP <= 0 .OR. MAEXP > NDIG) GO TO 110
      KPTMA = INT(MAEXP) + 1
      IF (MWK(START(MA)) < 0) THEN
          MKSUM = MWK(START(MA)+KPTMA+1) - IVAL
      ELSE
          MKSUM = MWK(START(MA)+KPTMA+1) + IVAL
      ENDIF

      IF (MKSUM >= MBASE .OR. MKSUM < 0) GO TO 110
      IF (KPTMA == 2 .AND. MKSUM == 0) GO TO 110
      MWK(START(MA)+KPTMA+1) = MKSUM
      GO TO 120

  110 CALL FMI2M(IVAL,MXY(1))
      CALL FMADD2_R1(MA,MXY(1))

  120 IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          MWK(START(MA)+1) = MIN(MWK(START(MA)+1),MD2B)
      ENDIF
      IF (NTRACE /= 0) THEN
          CALL FMNTR(1,MA,MA,1,1)
      ENDIF
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FMADDI

      SUBROUTINE FMADDN(MA,MB,NGUARD,NMWA)

!  Internal addition routine.  MWA = MA - MB
!  The arguments are such that MA >= MB >= 0.

!  NGUARD is the number of guard digits being carried.
!  NMWA is the number of words in MWA that will be used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: NGUARD,NMWA
      REAL (KIND(1.0D0)) :: MK,MR
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JMA,JMB,JMWA,K,KL,KP1,KP2,KPT,KSH,N1,N2,NK,NK1
      INTENT (IN) :: MA,MB

      N1 = NDIG + 1

!             Check for an insignificant operand.

      MK = MWK(START(MA)+2) - MWK(START(MB)+2)
      IF (MK >= NDIG+2) THEN
          DO J = 1, N1
             MWK(START(MWA)+J+1) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MWA)+N1+2) = 0
          IF (KROUND == 0 .OR. (KROUND == 2 .AND. JRSIGN == -1) .OR.  &
             (KROUND == -1 .AND. JRSIGN == 1)) THEN
              MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) - 1
              GO TO 120
          ENDIF
          KFLAG = 1
          RETURN
      ENDIF
      K = INT(MK)
      IF (NGUARD <= 1) NMWA = N1 + 2

!             Subtract MB from MA.

      KP1 = MIN(N1,K+1)
      MWK(START(MWA)+K+2) = 0
      DO J = 1, KP1
         MWK(START(MWA)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      JMA = START(MA) + 1
      JMB = START(MB) + 1 - K
      JMWA = START(MWA) + 1
      DO J = KP2, N1
         MWK(JMWA+J) = MWK(JMA+J) - MWK(JMB+J)
      ENDDO

      N2 = NDIG + 2
      IF (N2-K <= 1) N2 = 2 + K
      NK = MIN(NMWA,N1+K)
      DO J = N2, NK
         MWK(START(MWA)+J+1) = -MWK(START(MB)+J-K+1)
      ENDDO
      NK1 = NK + 1
      DO J = NK1, NMWA
         MWK(START(MWA)+J+1) = 0
      ENDDO

!             Normalize.  Fix the sign of any negative digit.

      IF (K > 0) THEN
          DO J = NMWA, KP2, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - 1
             ENDIF
          ENDDO

          KPT = KP2 - 1
  110     IF (MWK(START(MWA)+KPT+1) < 0 .AND. KPT >= 3) THEN
              MWK(START(MWA)+KPT+1) = MWK(START(MWA)+KPT+1) + MBASE
              MWK(START(MWA)+KPT) = MWK(START(MWA)+KPT) - 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
          GO TO 130
      ENDIF

  120 DO J = N1, 3, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - 1
         ENDIF
      ENDDO

!             Shift left if there are any leading zeros in the mantissa.

  130 DO J = 2, NMWA
         IF (MWK(START(MWA)+J+1) > 0) THEN
             KSH = J - 2
             GO TO 140
         ENDIF
      ENDDO
      MWK(START(MWA)+2) = 0
      RETURN

  140 IF (KSH > 0) THEN
          KL = NMWA - KSH
          DO J = 2, KL
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+KSH+1)
          ENDDO
          DO J = KL+1, NMWA
             MWK(START(MWA)+J+1) = 0
          ENDDO
          MWK(START(MWA)+2) = MWK(START(MWA)+2) - KSH
          IF (MK >= NDIG+2) THEN
              MWK(START(MWA)+N1+1) = MBASE - 1
          ENDIF
      ENDIF

!             Round the result.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KROUND_RETRY = KROUND_RETRY + 1
      ENDIF
      MR = 2*MWK(START(MWA)+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,0)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                  MWK(START(MWA)+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ENDIF
      ENDIF

!             See if the result is equal to one of the input arguments.

      IF (ABS(MWK(START(MA)+2)-MWK(START(MB)+2)) < NDIG) GO TO 150
      IF (ABS(MWK(START(MA)+2)-MWK(START(MB)+2)) > NDIG+1) THEN
          KFLAG = 1
          GO TO 150
      ENDIF

      N2 = NDIG + 4
      DO J = 3, N1
         IF (MWK(START(MWA)+N2-J+1) /= MWK(START(MA)+N2-J+1)) GO TO 150
      ENDDO
      IF (MWK(START(MWA)+2) /= MWK(START(MA)+2)) GO TO 150
      IF (MWK(START(MWA)+3) /= ABS(MWK(START(MA)+3))) GO TO 150
      KFLAG = 1

  150 RETURN
      END SUBROUTINE FMADDN

      SUBROUTINE FMADDP(MA,MB,NGUARD,NMWA)

!  Internal addition routine.  MWA = MA + MB
!  The arguments are such that MA >= MB >= 0.

!  NMWA is the number of words in MWA that will be used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: NGUARD,NMWA
      REAL (KIND(1.0D0)) :: MK,MKT,MR
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JMA,JMB,JMWA,K,KL,KP,KP2,KPT,KSHIFT,N1,N2,NK
      INTENT (IN) :: MA,MB

      N1 = NDIG + 1

!             Check for an insignificant operand.

      MK = MWK(START(MA)+2) - MWK(START(MB)+2)
      IF (MK >= NDIG+1) THEN
          MWK(START(MWA)+2) = MWK(START(MA)+2) + 1
          MWK(START(MWA)+3) = 0
          DO J = 2, N1
             MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MWA)+N1+3) = 0
          IF ((KROUND ==  2 .AND. JRSIGN ==  1) .OR.  &
              (KROUND == -1 .AND. JRSIGN == -1)) THEN
              MWK(START(MWA)+N1+3) = 1
              GO TO 120
          ENDIF
          KFLAG = 1
          RETURN
      ENDIF
      K = INT(MK)

!             Add MA and MB.

      MWK(START(MWA)+2) = MWK(START(MA)+2) + 1
      MWK(START(MWA)+3) = 0
      DO J = 2, K+1
         MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      JMA = START(MA) + 1
      JMB = START(MB) + 1 - K
      JMWA = START(MWA) + 2
      DO J = KP2, N1
         MWK(JMWA+J) = MWK(JMA+J) + MWK(JMB+J)
      ENDDO
      N2 = NDIG + 2
      NK = MIN(NMWA,N1+K)
      DO J = N2, NK
         MWK(START(MWA)+J+2) = MWK(START(MB)+J-K+1)
      ENDDO
      DO J = NK+1, NMWA
         MWK(START(MWA)+J+2) = 0
      ENDDO

!             Normalize.  Fix any digit not less than MBASE.

      IF (K == NDIG) GO TO 140

      IF (K > 0) THEN
          DO J = N1+1, KP2, -1
             IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) + 1
             ENDIF
          ENDDO

          KPT = KP2 - 1
  110     IF (MWK(START(MWA)+KPT+1) >= MBASE .AND. KPT >= 3) THEN
              MWK(START(MWA)+KPT+1) = MWK(START(MWA)+KPT+1) - MBASE
              MWK(START(MWA)+KPT) = MWK(START(MWA)+KPT) + 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
          GO TO 120
      ENDIF

      DO J = N1+1, 3, -1
         IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) + 1
         ENDIF
      ENDDO

!             Shift right if the leading digit is not less than MBASE.

  120 IF (MWK(START(MWA)+3) >= MBASE) THEN
  130     KP = NMWA + 4
          DO J = 4, NMWA
             MWK(START(MWA)+KP-J+1) = MWK(START(MWA)+KP-J)
          ENDDO
          MKT = AINT (MWK(START(MWA)+3)/MBASE)
          MWK(START(MWA)+4) = MWK(START(MWA)+3) - MKT*MBASE
          MWK(START(MWA)+3) = MKT
          MWK(START(MWA)+2) = MWK(START(MWA)+2) + 1
          IF (MWK(START(MWA)+3) >= MBASE) GO TO 130
      ENDIF

!             Round the result.

  140 KSHIFT = 0
      IF (MWK(START(MWA)+3) == 0) KSHIFT = 1
      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KROUND_RETRY = KROUND_RETRY + 1
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF

!             See if the result is equal to one of the input arguments.

      IF (ABS(MWK(START(MA)+2)-MWK(START(MB)+2)) < NDIG) GO TO 150
      IF (KSHIFT == 0) GO TO 150
      IF (ABS(MWK(START(MA)+2)-MWK(START(MB)+2)) > NDIG+1) THEN
          KFLAG = 1
          GO TO 150
      ENDIF

      N2 = NDIG + 4
      DO J = 3, N1
         IF (MWK(START(MWA)+N2-J+2) /= MWK(START(MA)+N2-J+1)) GO TO 150
      ENDDO
      IF (MWK(START(MWA)+2) /= MWK(START(MA)+2)+1) GO TO 150
      IF (MWK(START(MWA)+4) /= ABS(MWK(START(MA)+3))) GO TO 150
      KFLAG = 1

  150 RETURN
      END SUBROUTINE FMADDP

      SUBROUTINE FMARGS(KROUTN,NARGS,MA,MB,KRESLT)

!  Check the input arguments to a routine for special cases.

!  KROUTN - Name of the subroutine that was called
!  NARGS  - The number of input arguments (1 or 2)
!  MA     - First input argument
!  MB     - Second input argument (if NARGS is 2)
!  KRESLT - Result code returned to the calling routine.

!  Result codes:

!   0 - Perform the normal operation
!   1 - The result is the first input argument
!   2 - The result is the second input argument
!   3 - The result is -OVERFLOW
!   4 - The result is +OVERFLOW
!   5 - The result is -UNDERFLOW
!   6 - The result is +UNDERFLOW
!   7 - The result is -1.0
!   8 - The result is +1.0
!   9 - The result is -pi/2
!  10 - The result is +pi/2
!  11 - The result is 0.0
!  12 - The result is UNKNOWN
!  13 - The result is +pi
!  14 - The result is -pi/4
!  15 - The result is +pi/4

      USE FMVALS
      IMPLICIT NONE
      CHARACTER(9) :: KROUTN
      INTEGER :: MA,MB
      INTEGER :: NARGS,KRESLT

      REAL (KIND(1.0D0)) :: MBS
      INTEGER :: J,KWRNSV,NCATMA,NCATMB,NDS

!             These tables define the result codes to be returned for given values of the input
!             argument(s).

!             For example, row 7 column 2 of this array initialization KADD(2,7) = 2 means that if
!             the first argument in a call to FMADD is in category 7 ( -UNDERFLOW ) and the second
!             argument is in category 2 ( near -OVERFLOW but representable ) then the result code
!             is 2 ( the value of the sum is equal to the second input argument ).
!             See routine FMCAT for descriptions of the categories.

      INTEGER :: KADD(15,15) = RESHAPE(  (/  &
                 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,12,12,  &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,12,  &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,  &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,  &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,  &
                 3, 0, 0, 0, 0, 0,12, 1,12, 0, 0, 0, 0, 0, 4,  &
                 3, 2, 2, 2, 2,12,12, 5,12,12, 2, 2, 2, 2, 4,  &
                 3, 2, 2, 2, 2, 2, 5, 2, 6, 2, 2, 2, 2, 2, 4,  &
                 3, 2, 2, 2, 2,12,12, 6,12,12, 2, 2, 2, 2, 4,  &
                 3, 0, 0, 0, 0, 0,12, 1,12, 0, 0, 0, 0, 0, 4,  &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,  &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,  &
                 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,  &
                12, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 4,  &
                12,12, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4   /)  &
        , (/ 15,15 /) )

      INTEGER :: KMPY(15,15) = RESHAPE(  (/  &
                 4, 4, 4, 4,12,12,12,11,12,12,12, 3, 3, 3, 3,  &
                 4, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 3,  &
                 4, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 3,  &
                 4, 0, 0, 0, 0, 0, 6,11, 5, 0, 0, 1, 0, 0, 3,  &
                12, 0, 0, 0, 0, 0, 6,11, 5, 0, 0, 1, 0, 0,12,  &
                12, 0, 0, 0, 0, 0, 6,11, 5, 0, 0, 1, 0, 0,12,  &
                12,12,12, 6, 6, 6, 6,11, 5, 5, 5, 5,12,12,12,  &
                11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,  &
                12,12,12, 5, 5, 5, 5,11, 6, 6, 6, 6,12,12,12,  &
                12, 0, 0, 0, 0, 0, 5,11, 6, 0, 0, 1, 0, 0,12,  &
                12, 0, 0, 0, 0, 0, 5,11, 6, 0, 0, 1, 0, 0,12,  &
                 3, 2, 2, 2, 2, 2, 5,11, 6, 2, 2, 2, 2, 2, 4,  &
                 3, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 4,  &
                 3, 0, 0, 0, 0, 0,12,11,12, 0, 0, 1, 0, 0, 4,  &
                 3, 3, 3, 3,12,12,12,11,12,12,12, 4, 4, 4, 4   /)  &
        , (/ 15,15 /) )

      INTEGER :: KDIV(15,15) = RESHAPE(  (/  &
                12,12,12, 4, 4, 4, 4,12, 3, 3, 3, 3,12,12,12,  &
                12, 0, 0, 0, 0, 0, 4,12, 3, 0, 0, 1, 0, 0,12,  &
                12, 0, 0, 0, 0, 0, 4,12, 3, 0, 0, 1, 0, 0,12,  &
                 6, 0, 0, 0, 0, 0, 4,12, 3, 0, 0, 1, 0, 0, 5,  &
                 6, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 5,  &
                 6, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 5,  &
                 6, 6, 6, 6,12,12,12,12,12,12,12, 5, 5, 5, 5,  &
                11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,  &
                 5, 5, 5, 5,12,12,12,12,12,12,12, 6, 6, 6, 6,  &
                 5, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 6,  &
                 5, 0, 0, 0, 0, 0,12,12,12, 0, 0, 1, 0, 0, 6,  &
                 5, 0, 0, 0, 0, 0, 3,12, 4, 0, 0, 1, 0, 0, 6,  &
                12, 0, 0, 0, 0, 0, 3,12, 4, 0, 0, 1, 0, 0,12,  &
                12, 0, 0, 0, 0, 0, 3,12, 4, 0, 0, 1, 0, 0,12,  &
                12,12,12, 3, 3, 3, 3,12, 4, 4, 4, 4,12,12,12   /)  &
        , (/ 15,15 /) )

      INTEGER :: KPWR(15,15) = RESHAPE(  (/  &
                12,12, 0, 5,12,12,12, 8,12,12,12, 3, 0,12,12,  &
                12,12, 0, 0,12,12,12, 8,12,12,12, 1, 0,12,12,  &
                12,12, 0, 0,12,12,12, 8,12,12,12, 1, 0,12,12,  &
                12,12, 0, 0,12,12,12, 8,12,12,12, 1, 0,12,12,  &
                12,12, 0, 0,12,12,12, 8,12,12,12, 1, 0,12,12,  &
                12,12, 0, 0,12,12,12, 8,12,12,12, 1, 0,12,12,  &
                12,12, 0, 3,12,12,12, 8,12,12,12, 5, 0,12,12,  &
                12,12,12,12,12,12,12,12,11,11,11,11,11,11,11,  &
                 4, 4, 4, 4,12,12,12, 8,12,12,12, 6, 6, 6, 6,  &
                 4, 4, 0, 0, 0, 8, 8, 8, 8, 0, 0, 1, 0, 6, 6,  &
                 4, 4, 0, 0, 0, 8, 8, 8, 8, 0, 0, 1, 0, 6, 6,  &
                 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  &
                 6, 6, 0, 0, 0, 8, 8, 8, 8, 8, 0, 1, 0, 4, 4,  &
                 6, 6, 0, 0, 0, 8, 8, 8, 8, 8, 0, 1, 0, 4, 4,  &
                 6, 6, 6, 6,12,12,12, 8,12,12,12, 4, 4, 4, 4   /)  &
        , (/ 15,15 /) )

      INTEGER :: KSQRT(15) = (/ 12,12,12,12,12,12,12,11,12, 0, 0, 8, 0, 0,12 /)
      INTEGER :: KEXP(15)  = (/  6, 6, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 4, 4 /)
      INTEGER :: KLN(15)   = (/ 12,12,12,12,12,12,12,12,12, 0, 0,11, 0, 0,12 /)
      INTEGER :: KSIN(15)  = (/ 12,12, 0, 0, 0, 0, 5,11, 6, 0, 0, 0, 0,12,12 /)
      INTEGER :: KCOS(15)  = (/ 12,12, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0,12,12 /)
      INTEGER :: KTAN(15)  = (/ 12,12, 0, 0, 0, 0, 5,11, 6, 0, 0, 0, 0,12,12 /)
      INTEGER :: KASIN(15) = (/ 12,12,12, 9, 0, 0, 5,11, 6, 0, 0,10,12,12,12 /)
      INTEGER :: KACOS(15) = (/ 12,12,12,13, 0,10,10,10,10,10, 0,11,12,12,12 /)
      INTEGER :: KATAN(15) = (/  9, 9, 0,14, 0, 0, 5,11, 6, 0, 0,15, 0,10,10 /)
      INTEGER :: KSINH(15) = (/  3, 3, 0, 0, 0, 1, 5,11, 6, 1, 0, 0, 0, 4, 4 /)
      INTEGER :: KCOSH(15) = (/  4, 4, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 4, 4 /)
      INTEGER :: KTANH(15) = (/  7, 7, 0, 0, 0, 1, 5,11, 6, 1, 0, 0, 0, 8, 8 /)
      INTEGER :: KLG10(15) = (/ 12,12,12,12,12,12,12,12,12, 0, 0,11, 0, 0,12 /)
      INTENT (IN) :: MA,MB

      KRESLT = 12
      KFLAG = -4
      IF (MWK(START(MA)+2) == MUNKNO) RETURN
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) == MUNKNO) RETURN
      ENDIF
      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      NAMEST(NCALL) = KROUTN

!             Check the validity of parameters if this is a user call.

      IF (NCALL > 1 .AND. KDEBUG == 0) GO TO 130

!             Check NDIG.

      IF (NDIG < 2) THEN
          KFLAG = -1
          CALL FMWARN
          NDS = NDIG
          IF (NDIG < 2) NDIG = 2
          WRITE (KW,  &
                 "(' NDIG was',I10,'.  It has been changed to',I10,'.')"  &
                ) NDS,NDIG
          RETURN
      ENDIF

!             Check MBASE.

      IF (MBASE < 2 .OR. MBASE > MXBASE) THEN
          KFLAG = -2
          CALL FMWARN
          MBS = MBASE
          IF (MBASE < 2) MBASE = 2
          IF (MBASE > MXBASE) MBASE = MXBASE
          WRITE (KW,  &
                 "(' MBASE was',I10,'.  It has been changed to',I10,'.')"  &
                ) INT(MBS),INT(MBASE)
          CALL FMCONS
          RETURN
      ENDIF

!             Check exponent range.

      IF (MWK(START(MA)+2) > MXEXP+1 .OR. MWK(START(MA)+2) < -MXEXP) THEN
          IF (ABS(MWK(START(MA)+2)) /= MEXPOV .OR. ABS(MWK(START(MA)+3)) /= 1) THEN
              KFLAG = -3
              CALL FMWARN
              RETURN
          ENDIF
      ENDIF
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) > MXEXP+1 .OR. MWK(START(MB)+2) < -MXEXP) THEN
              IF (ABS(MWK(START(MB)+2)) /= MEXPOV .OR. ABS(MWK(START(MB)+3)) /= 1) THEN
                  KFLAG = -3
                  CALL FMWARN
                  RETURN
              ENDIF
          ENDIF
      ENDIF

!             Check for properly normalized digits in the input arguments.

      IF (ABS(MWK(START(MA)+2)-INT(MWK(START(MA)+2))) /= 0) KFLAG = 1
      IF (MWK(START(MA)+3) <= (-1) .OR. MWK(START(MA)+3) >= MBASE .OR.  &
          ABS(MWK(START(MA)+3)-INT(MWK(START(MA)+3))) /= 0) KFLAG = 2
      IF (KDEBUG == 0) GO TO 110
      DO J = 3, NDIG+1
         IF (MWK(START(MA)+J+1) < 0 .OR. MWK(START(MA)+J+1) >= MBASE .OR.  &
             ABS(MWK(START(MA)+J+1)-INT(MWK(START(MA)+J+1))) /= 0) THEN
             KFLAG = J
             GO TO 110
         ENDIF
      ENDDO
  110 IF (KFLAG /= 0) THEN
          J = KFLAG
          KFLAG = -4
          KWRNSV = KWARN
          IF (KWARN >= 2) KWARN = 1
          CALL FMWARN
          KWARN = KWRNSV
          IF (KWARN >= 1) THEN
              WRITE (KW,*) ' First invalid array element:  MA(', J,') = ',MWK(START(MA)+J+1)
          ENDIF
          KFLAG = -4
          IF (KWARN >= 2) THEN
              STOP
          ENDIF
          RETURN
      ENDIF
      IF (NARGS == 2) THEN
          IF (ABS(MWK(START(MB)+2)-INT(MWK(START(MB)+2))) /= 0) KFLAG = 1
          IF (MWK(START(MB)+3) <= (-1) .OR. MWK(START(MB)+3) >= MBASE .OR.  &
              ABS(MWK(START(MB)+3)-INT(MWK(START(MB)+3))) /= 0) KFLAG = 2
          IF (KDEBUG == 0) GO TO 120
          DO J = 3, NDIG+1
             IF (MWK(START(MB)+J+1) < 0 .OR. MWK(START(MB)+J+1) >= MBASE .OR.  &
                 ABS(MWK(START(MB)+J+1)-INT(MWK(START(MB)+J+1))) /= 0) THEN
                 KFLAG = J
                 GO TO 120
             ENDIF
          ENDDO
  120     IF (KFLAG /= 0) THEN
              J = KFLAG
              KFLAG = -4
              KWRNSV = KWARN
              IF (KWARN >= 2) KWARN = 1
              CALL FMWARN
              KWARN = KWRNSV
              IF (KWARN >= 1) THEN
                  WRITE (KW,*) ' First invalid array element:  MB(', J,') = ',MWK(START(MB)+J+1)
              ENDIF
              KFLAG = -4
              IF (KWARN >= 2) THEN
                  STOP
              ENDIF
              RETURN
          ENDIF
      ENDIF

!             Check for special cases.

  130 CALL FMCAT(MA,NCATMA)
      IF (NCATMA > 15) THEN
          KRESLT = 12
          RETURN
      ENDIF
      NCATMB = 0
      IF (NARGS == 2) THEN
          CALL FMCAT(MB,NCATMB)
          IF (NCATMB > 15) THEN
              KRESLT = 12
              RETURN
          ENDIF
      ENDIF

      IF (KROUTN == 'FMADD') THEN
          KRESLT = KADD(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSUB') THEN
          IF (NCATMB < 16) NCATMB = 16 - NCATMB
          KRESLT = KADD(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMMPY') THEN
          KRESLT = KMPY(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMDIV') THEN
          KRESLT = KDIV(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMPWR') THEN
          KRESLT = KPWR(NCATMB,NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSQRT' .OR. KROUTN == 'FMSQRT_R1') THEN
          KRESLT = KSQRT(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMEXP') THEN
          KRESLT = KEXP(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMLN') THEN
          KRESLT = KLN(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSIN') THEN
          KRESLT = KSIN(NCATMA)
          IF (KRAD == 0 .AND. (NCATMA == 2 .OR. NCATMA == 14)) KRESLT = 0
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMCOS') THEN
          KRESLT = KCOS(NCATMA)
          IF (KRAD == 0 .AND. (NCATMA == 2 .OR. NCATMA == 14)) KRESLT = 0
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMTAN') THEN
          KRESLT = KTAN(NCATMA)
          IF (KRAD == 0 .AND. (NCATMA == 2 .OR. NCATMA == 14)) KRESLT = 0
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMASIN') THEN
          KRESLT = KASIN(NCATMA)
          IF ((NCATMA == 7.OR.NCATMA == 9) .AND. KRAD == 0) KRESLT = 12
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMACOS') THEN
          KRESLT = KACOS(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMATAN') THEN
          KRESLT = KATAN(NCATMA)
          IF ((NCATMA == 7.OR.NCATMA == 9) .AND. KRAD == 0) KRESLT = 12
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMSINH') THEN
          KRESLT = KSINH(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMCOSH') THEN
          KRESLT = KCOSH(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMTANH') THEN
          KRESLT = KTANH(NCATMA)
          GO TO 140
      ENDIF

      IF (KROUTN == 'FMLG10') THEN
          KRESLT = KLG10(NCATMA)
          GO TO 140
      ENDIF

      KRESLT = 0
      RETURN

  140 IF (KRESLT == 12) THEN
          KFLAG = -4
          CALL FMWARN
      ENDIF
      IF (KRESLT == 3 .OR. KRESLT == 4) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              KFLAG = -5
          ELSE
              KFLAG = -5
              CALL FMWARN
          ENDIF
      ENDIF
      IF (KRESLT == 5 .OR. KRESLT == 6) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              KFLAG = -6
          ELSE
              KFLAG = -6
              CALL FMWARN
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMARGS

      SUBROUTINE FMASIN(MA,MB)

!  MB = ARCSIN(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. KRAD == 1) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMASIN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),6,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. KROUND == -1) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE IF (MWK(START(MA)) >= 0 .AND. KROUND == 2) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMASIN'
              KFLAG = -4
              CALL FMWARN
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMASIN'
              IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
              CALL FMWARN
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMASIN'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+2) > 0 .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMASIN   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMASIN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMST2M('0.5',MXY(1))
          CALL FMSUB(MXY(5),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('30',MXY(5))
              GO TO 120
          ENDIF
          CALL FMADD(MXY(5),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('-30',MXY(5))
              GO TO 120
          ENDIF
      ENDIF

!             Use ASIN(X) = ATAN(X/SQRT(1-X*X))

      CALL FMI2M(1,MXY(3))
      CALL FMSUB(MXY(3),MXY(5),MXY(1))
      CALL FMADD(MXY(3),MXY(5),MXY(2))
      CALL FMMPY_R2(MXY(1),MXY(2))
      CALL FMSQRT_R1(MXY(2))
      CALL FMDIV(MXY(5),MXY(2),MXY(4))
      CALL FMATAN(MXY(4),MXY(5))

!             Round the result and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMASIN

      SUBROUTINE FMATAN(MA,MB)

!  MB = ARCTAN(MA)

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: X,XM
      INTEGER :: MA,MB
      INTEGER :: NSTACK(49)
      REAL (KIND(1.0D0)) :: MA1,MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,KST,KWRNSV,NDSAV1,NDSAVE,NDSV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      KWRNSV = KWARN

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. KRAD == 1) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),-3,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE IF (MWK(START(MA)) >= 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = KWRNSV
          IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              KFLAG = -4
              CALL FMWARN
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
              CALL FMWARN
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (KROUND /= 1 .AND. MWK(START(MA)+2) > NDIG .AND. MWK(START(MA)+2) /= MUNKNO .AND.  &
          KRAD /= 1) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          KWARN = 0
          IF (MWK(START(MA)) < 0) THEN
              IF (MWK(START(MA)+2) /= MEXPOV) THEN
                  CALL FMI2M(180,MXY(1))
                  CALL FMPI(MXY(2))
                  CALL FMDIV(MXY(1),MXY(2),MXY(3))
                  CALL FMDIV(MXY(3),MA,MXY(2))
                  CALL FMI2M(-90,MXY(1))
                  CALL FMSUB(MXY(1),MXY(2),MXY(3))
              ELSE
                  CALL FMI2M(-90,MXY(1))
                  CALL FMTINY(MXY(2))
                  CALL FMADD(MXY(1),MXY(2),MXY(3))
              ENDIF
          ELSE
              IF (MWK(START(MA)+2) /= MEXPOV) THEN
                  CALL FMI2M(180,MXY(1))
                  CALL FMPI(MXY(2))
                  CALL FMDIV(MXY(1),MXY(2),MXY(3))
                  CALL FMDIV(MXY(3),MA,MXY(2))
                  CALL FMI2M(90,MXY(1))
                  CALL FMSUB(MXY(1),MXY(2),MXY(3))
              ELSE
                  CALL FMI2M(90,MXY(1))
                  CALL FMTINY(MXY(2))
                  CALL FMSUB(MXY(1),MXY(2),MXY(3))
              ENDIF
          ENDIF
          CALL FMEQ(MXY(3),MB)
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = KWRNSV
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMATAN'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMATAN   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMATAN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
      MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMI2M(1,MXY(1))
          CALL FMSUB(MXY(3),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('45',MXY(5))
              GO TO 140
          ENDIF
          CALL FMADD(MXY(3),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMST2M('-45',MXY(5))
              GO TO 140
          ENDIF
      ENDIF

!             If MA >= 1 work with 1/MA.

      MA1 = MWK(START(MA)+2)
      MAS = MWK(START(MA))
      MWK(START(MXY(3))) = 1
      IF (MA1 >= 1) THEN
          CALL FMI2M(1,MXY(5))
          CALL FMDIV_R2(MXY(5),MXY(3))
      ENDIF

      KRSAVE = KRAD
      KRAD = 1
      X = MWK(START(MXY(3))+2)
      XM = MXBASE

!             In case pi has not been computed at the current precision and will be needed here,
!             get it to full precision first to avoid repeated calls at increasing precision during
!             Newton iteration.

      IF (MA1 >= 1 .OR. KRSAVE == 0) THEN
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(5))
              NDIG = NDSV
          ENDIF
      ENDIF

!             If the argument is small, use the Taylor series, otherwise use Newton iteration.

      IF (X*DLOGMB < -5.0D0*LOG(XM)) THEN
          KWARN = 0
          CALL FMEQ(MXY(3),MXY(5))
          IF (MWK(START(MXY(5))+2) <= -NDIG) GO TO 130
          CALL FMSQR(MXY(3),MXY(4))
          J = 3
          NDSAV1 = NDIG

  120     CALL FMMPY_R1(MXY(3),MXY(4))
          IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
              MWK(START(MXY(3))) = -MWK(START(MXY(3)))
          CALL FMDIVI(MXY(3),J,MXY(1))
          NDIG = NDSAV1
          CALL FMADD_R1(MXY(5),MXY(1))
          IF (KFLAG /= 0) THEN
              KFLAG = 0
              GO TO 130
          ENDIF
          NDIG = NDSAV1 - INT((MWK(START(MXY(5))+2)-MWK(START(MXY(1))+2)))
          IF (NDIG < NGRD22) NDIG = NGRD22
          J = J + 2
          GO TO 120
      ELSE

          CALL FMI2M(0,MXY(1))
          CALL FMI2M(0,MXY(2))
          CALL FMI2M(0,MXY(4))
          CALL FMM2DP(MXY(3),X)
          X = ATAN(X)
          CALL FMDPM(X,MXY(5))
          CALL FMDIG(NSTACK,KST)

!             Newton iteration.

          DO J = 1, KST
             NDIG = NSTACK(J)
             CALL FMSIN(MXY(5),MXY(4))
             CALL FMSQR(MXY(4),MXY(1))
             CALL FMI2M(1,MXY(2))
             CALL FMSUB_R2(MXY(2),MXY(1))
             CALL FMSQRT(MXY(1),MXY(2))
             CALL FMDIV_R2(MXY(4),MXY(2))
             CALL FMSUB_R1(MXY(2),MXY(3))
             CALL FMMPY_R2(MXY(1),MXY(2))
             CALL FMSUB_R1(MXY(5),MXY(2))
          ENDDO
          MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      ENDIF

!             If MA >= 1 use pi/2 - ATAN(1/MA)

  130 IF (MA1 >= 1) THEN
          CALL FMDIVI(MPISAV,2,MXY(4))
          CALL FMSUB_R2(MXY(4),MXY(5))
      ENDIF

!             Convert to degrees if necessary, round and return.

      KRAD = KRSAVE
      IF (KRAD == 0) THEN
          CALL FMMPYI_R1(MXY(5),180)
          CALL FMDIV_R1(MXY(5),MPISAV)
      ENDIF
      IF (MWK(START(MXY(5))+2) /= MUNKNO .AND. MWK(START(MXY(5))+3) /= 0 .AND. MAS < 0)  &
          MWK(START(MXY(5))) = -MWK(START(MXY(5)))

  140 IF (KFLAG == 1) KFLAG = 0
      KWARN = KWRNSV
      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMATAN

      SUBROUTINE FMATN2(MA,MB,MC)

!  MC = ATAN2(MA,MB)

!  MC is returned as the angle between -pi and pi (or -180 and 180 if degree mode is selected) for
!  which TAN(MC) = MA/MB.  MC is an angle for the point (MB,MA) in polar coordinates.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MXEXP1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JQUAD,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MB)) >= 0 .AND. KRAD == 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KL = KROUND
          KROUND = 1
          NCALL = NCALL + 1
          CALL FMDIV(MA,MB,MXY(1))
          NCALL = NCALL - 1
          KROUND = KL
          IF (MWK(START(MXY(1))+2) < -NDIG) THEN
              NTRACE = J
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMATN2'
                  CALL FMNTR(2,MA,MB,2,1)
                  NCALL = NCALL - 1
              ENDIF
              NTRACE = 0
              IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
                  CALL FMEQ(MXY(1),MXY(3))
              ELSE
                  CALL FMSQR(MXY(1),MXY(2))
                  CALL FMMPY_R1(MXY(2),MXY(1))
                  CALL FMDIVI_R1(MXY(2),3)
                  IF (MWK(START(MXY(2))+2) /= MEXPUN) THEN
                      CALL FMSUB(MXY(1),MXY(2),MXY(3))
                  ELSE IF (MWK(START(MXY(1))) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                      KL = MWK(START(MXY(1))+2)
                      MWK(START(MXY(1))+2) = 0
                      CALL FMULP(MXY(1),MXY(2))
                      CALL FMSUB(MXY(1),MXY(2),MXY(4))
                      MWK(START(MXY(4))+2) = KL + MWK(START(MXY(4))+2)
                      CALL FMEQ(MXY(4),MXY(3))
                  ELSE IF (MWK(START(MXY(1))) >= 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                      KL = MWK(START(MXY(1))+2)
                      MWK(START(MXY(1))+2) = 0
                      CALL FMULP(MXY(1),MXY(2))
                      CALL FMSUB(MXY(1),MXY(2),MXY(4))
                      MWK(START(MXY(4))+2) = KL + MWK(START(MXY(4))+2)
                      CALL FMEQ(MXY(4),MXY(3))
                  ELSE
                      CALL FMEQ(MXY(1),MXY(3))
                  ENDIF
              ENDIF
              KFLAG = 0
              NTRACE = J
              KWARN = K
              CALL FMEQ(MXY(3),MC)
              IF (MWK(START(MC)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO .AND.  &
                  MWK(START(MB)+2) /= MUNKNO) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMATN2'
                  KFLAG = -4
                  CALL FMWARN
                  NCALL = NCALL - 1
              ELSE IF (ABS(MWK(START(MC)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV .AND.  &
                       ABS(MWK(START(MB)+2))  < MEXPOV) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMATN2'
                  IF (MWK(START(MC)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MC)+2) == MEXPUN) KFLAG = -6
                  CALL FMWARN
                  NCALL = NCALL - 1
              ENDIF
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMATN2'
                  CALL FMNTR(1,MC,MC,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NTRACE = J
          KWARN = K
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB) THEN
          CALL FMENTR('FMATN2   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMATN2'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

      KWRNSV = KWARN
      KWARN = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
         (MWK(START(MA)+3) == 0 .AND. MWK(START(MB)+3) == 0)) THEN
          CALL FMST2M('UNKNOWN',MXY(5))
          KFLAG = -4
          GO TO 120
      ENDIF
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMTINY(MXY(3))
          ELSE IF (MWK(START(MA)+2) == MEXPOV) THEN
              CALL FMBIG(MXY(3))
          ELSE
              CALL FMEQ(MXY(1),MXY(3))
          ENDIF
          MWK(START(MXY(3))) = MWK(START(MA))
          IF (MWK(START(MB)+2) == MEXPUN) THEN
              CALL FMTINY(MXY(4))
          ELSE IF (MWK(START(MB)+2) == MEXPOV) THEN
              CALL FMBIG(MXY(4))
          ELSE
              CALL FMEQ(MXY(2),MXY(4))
          ENDIF
          MWK(START(MXY(4))) = MWK(START(MB))
          IF (MWK(START(MXY(3))+2) > MWK(START(MXY(4))+2)+NDIG) THEN
              IF (MWK(START(MA)) > 0) THEN
                  CALL FMDIV(MXY(4),MXY(3),MXY(5))
                  CALL FMMPYI_R1(MXY(5),180)
                  CALL FMPI(MXY(3))
                  CALL FMDIV(MXY(5),MXY(3),MXY(4))
                  CALL FMI2M(90,MXY(3))
                  CALL FMSUB(MXY(3),MXY(4),MXY(5))
                  GO TO 120
              ENDIF
              IF (MWK(START(MA)) < 0) THEN
                  CALL FMDIV(MXY(4),MXY(3),MXY(5))
                  CALL FMMPYI_R1(MXY(5),180)
                  CALL FMPI(MXY(3))
                  CALL FMDIV(MXY(5),MXY(3),MXY(4))
                  CALL FMI2M(-90,MXY(3))
                  CALL FMSUB(MXY(3),MXY(4),MXY(5))
                  GO TO 120
              ENDIF
          ENDIF
          IF (MWK(START(MXY(4))+2) > MWK(START(MXY(3))+2)+NDIG .AND. MWK(START(MB)) < 0) THEN
              IF (MWK(START(MA)) > 0) THEN
                  CALL FMDIV(MXY(3),MXY(4),MXY(5))
                  CALL FMMPYI_R1(MXY(5),180)
                  CALL FMPI(MXY(3))
                  CALL FMDIV(MXY(5),MXY(3),MXY(4))
                  CALL FMI2M(180,MXY(3))
                  CALL FMADD(MXY(3),MXY(4),MXY(5))
                  GO TO 120
              ENDIF
              IF (MWK(START(MA)) < 0) THEN
                  CALL FMDIV(MXY(3),MXY(4),MXY(5))
                  CALL FMMPYI_R1(MXY(5),180)
                  CALL FMPI(MXY(3))
                  CALL FMDIV(MXY(5),MXY(3),MXY(4))
                  CALL FMI2M(-180,MXY(3))
                  CALL FMADD(MXY(3),MXY(4),MXY(5))
                  GO TO 120
              ENDIF
          ENDIF
      ENDIF

      IF (MWK(START(MB)+3) == 0 .AND. MWK(START(MA)) > 0) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(90,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
              CALL FMDIVI_R1(MXY(5),2)
          ENDIF
          GO TO 120
      ENDIF

      IF (MWK(START(MB)+3) == 0 .AND. MWK(START(MA)) < 0) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(-90,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
              CALL FMDIVI_R1(MXY(5),-2)
          ENDIF
          GO TO 120
      ENDIF

      MXEXP1 = INT(MXEXP2/2.01D0)
      IF (MWK(START(MA)+2) == MEXPOV .AND. MWK(START(MB)+2) < MXEXP1-NDIG-2) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(90,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
              CALL FMDIVI_R1(MXY(5),2)
          ENDIF
          IF (MWK(START(MXY(1))) < 0) MWK(START(MXY(5))) = -1
          GO TO 120
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN .AND. (-MWK(START(MB)+2)) < MXEXP1-NDIG-2 .AND.  &
                                 MWK(START(MB)) < 0) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(180,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
          ENDIF
          IF (MWK(START(MXY(1))) < 0) MWK(START(MXY(5))) = -1
          GO TO 120
      ENDIF

      IF (MWK(START(MB)+2) == MEXPOV .AND. MWK(START(MA)+2) < MXEXP1-NDIG-2 .AND.  &
                                MWK(START(MB)) < 0) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(180,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
          ENDIF
          IF (MWK(START(MXY(1))) < 0) MWK(START(MXY(5))) = -1
          GO TO 120
      ENDIF

      IF (MWK(START(MB)+2) == MEXPUN .AND. MWK(START(MA)+3) == 0) THEN
          IF (MWK(START(MB)) < 0) THEN
              IF (KRAD == 0) THEN
                  CALL FMI2M(180,MXY(5))
              ELSE
                  CALL FMPI(MXY(5))
              ENDIF
          ELSE
              CALL FMI2M(0,MXY(5))
          ENDIF
          GO TO 120
      ENDIF

      IF (MWK(START(MB)+2) == MEXPUN .AND. (-MWK(START(MA)+2)) < MXEXP1-NDIG-2) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(90,MXY(5))
          ELSE
              CALL FMPI(MXY(5))
              CALL FMDIVI_R1(MXY(5),2)
          ENDIF
          IF (MWK(START(MXY(1))) < 0) MWK(START(MXY(5))) = -1
          GO TO 120
      ENDIF

!             Determine the quadrant for the result, then use FMATAN.

      IF (MWK(START(MA)) >= 0 .AND. MWK(START(MB)) > 0) JQUAD = 1
      IF (MWK(START(MA)) >= 0 .AND. MWK(START(MB)) < 0) JQUAD = 2
      IF (MWK(START(MA))  < 0 .AND. MWK(START(MB)) < 0) JQUAD = 3
      IF (MWK(START(MA))  < 0 .AND. MWK(START(MB)) > 0) JQUAD = 4

      CALL FMDIV(MXY(1),MXY(2),MXY(4))
      MWK(START(MXY(4))) = 1
      CALL FMATAN(MXY(4),MXY(5))

      IF (JQUAD == 2 .OR. JQUAD == 3) THEN
          IF (KRAD == 0) THEN
              CALL FMI2M(180,MXY(3))
              CALL FMSUB_R2(MXY(3),MXY(5))
          ELSE
              CALL FMPI(MXY(3))
              CALL FMSUB_R2(MXY(3),MXY(5))
          ENDIF
      ENDIF

      IF ((JQUAD == 3 .OR. JQUAD == 4) .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(5))+3) /= 0) MWK(START(MXY(5))) = -MWK(START(MXY(5)))

!             Round the result and return.

  120 IF (KFLAG == 1) KFLAG = 0
      KWARN = KWRNSV
      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACCB,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMATN2

      SUBROUTINE FMBIG(MA)

!     MA = The biggest representable FM number using the current base and precision.
!          The smallest positive number is then 1.0/MA.
!          In some rounding modes, 1.0/(1.0/MA) may then overflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTEGER :: J,N1

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMBIG'

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      N1 = NDIG + 1
      DO J = 2, N1
         MWK(START(MA)+J+1) = MBASE - 1
      ENDDO
      MWK(START(MA)+2) = MXEXP + 1
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      MWK(START(MA)) = 1

      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBIG

      SUBROUTINE FMCAT(MA,NCAT)

!  NCAT is returned as the category of MA.  This is used by the various arithmetic routines to
!  handle special cases such as: 'number greater than 1' + 'underflowed result' is the first
!  argument, 'overflowed result' / 'overflowed result' is 'unknown'.

!  NCAT       range

!   1.         -OV                OV stands for overflowed results.
!   2.   (-OV   , -OVTH)             ( MWK(START(MA)+2) >= MAXEXP+2 )
!   3.   (-OVTH ,    -1)
!   4.         -1                 OVTH stands for a representable
!   5.   (-1    , -UNTH)               number near the overflow
!   6.   (-UNTH ,   -UN)               threshold.
!   7.         -UN                     ( MWK(START(MA)+2) >= MAXEXP-NDIG+1 )
!   8.          0
!   9.         +UN                UN stands for underflowed results.
!  10.   (+UN   , +UNTH)             ( MWK(START(MA)+2) <= -MAXEXP-1 )
!  11.   (+UNTH ,    +1)
!  12.         +1                 UNTH stands for a representable
!  13.   (+1    , +OVTH)               number near the underflow
!  14.   (+OVTH ,   +OV)               threshold.
!  15.         +OV                     ( MWK(START(MA)+2) <= -MAXEXP+NDIG-1 )
!  16.       UNKNOWN

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: NCAT

      REAL (KIND(1.0D0)) :: MA2,MXEXP1
      INTEGER :: J,NLAST
      INTENT (IN) :: MA
      INTENT (INOUT) :: NCAT

!             Check for special symbols.

      NCAT = 16
      IF (MWK(START(MA)+2) == MUNKNO) RETURN

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          NCAT = 15
          IF (MWK(START(MA)) < 0) NCAT = 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          NCAT = 9
          IF (MWK(START(MA)) < 0) NCAT = 7
          RETURN
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          NCAT = 8
          RETURN
      ENDIF

!             Check for +1 or -1.

      MA2 = ABS(MWK(START(MA)+3))
      IF (MWK(START(MA)+2) == 1 .AND. MA2 == 1) THEN
          NLAST = NDIG + 1
          IF (NLAST >= 3) THEN
              DO J = 3, NLAST
                 IF (MWK(START(MA)+J+1) /= 0) GO TO 110
              ENDDO
          ENDIF
          NCAT = 12
          IF (MWK(START(MA)) < 0) NCAT = 4
          RETURN
      ENDIF

  110 MXEXP1 = INT(MXEXP)
      IF (MWK(START(MA)+2) >= MXEXP1-NDIG+2) THEN
          NCAT = 14
          IF (MWK(START(MA)) < 0) NCAT = 2
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) >= 1) THEN
          NCAT = 13
          IF (MWK(START(MA)) < 0) NCAT = 3
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) >= -MXEXP1+NDIG) THEN
          NCAT = 11
          IF (MWK(START(MA)) < 0) NCAT = 5
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) >= -MXEXP1) THEN
          NCAT = 10
          IF (MWK(START(MA)) < 0) NCAT = 6
          RETURN
      ENDIF

      RETURN
      END SUBROUTINE FMCAT

      SUBROUTINE FMCHANGEBASE(MA,MB,NEW_MBASE,NEW_NDIG)

!  Change the internal representation of a number from one base to another.
!  MA is given with NDIG digits in base MBASE (the current precision and base).
!  MB is returned as the same number, approximated with NEW_NDIG digits in base NEW_MBASE.

!  Note NDIG and MBASE are unchanged after calling FMCHANGEBASE, but if MB is to be used
!  in further operations, NDIG and MBASE should be changed to the new values in the calling program.
!
!  This routine is primarily meant to be used by the input and output conversion routines when the
!  base being used is not a power of ten.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: NEW_MBASE,NEW_NDIG
      INTENT (IN) :: MA,NEW_MBASE,NEW_NDIG
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),NUMBER_USED_SAVE,IEXTRA,J,K,KL,KRSAVE,KR_RETRY,NDSAVE,MBPOWERS(9)
      REAL (KIND(1.0D0)) :: MBSAVE
      DOUBLE PRECISION :: ERR

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MBPOWERS = -2
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMCHANGEB'

!             The change of base is done by summing this series in the new base:
!                 d(1)/b + d(2)/b**2 + ... + d(k)/b**k
!             where d(i) is the i-th digit in the old base, b.

      NDSAVE = NDIG
      MBSAVE = MBASE
      MBASE = NEW_MBASE
      CALL FMCONS
      NDIG = NEW_NDIG + NGRD52

!             If the exponent is large, raise the precision.

      IEXTRA = MAX(0,ABS(INT(LOG(MAX(1.0D0,DBLE(ABS(MWK(START(MA)+2)))))/LOG(DBLE(MBSAVE))))+1)
      NDIG = NDIG + IEXTRA

      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      KRSAVE = KROUND
      KR_RETRY = 0
  110 IF (KR_RETRY >= 1) THEN
          NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF

!             Initialize the array of powers of the base.

      CALL IMI2M2(1,MXY(3))
      DO K = 1, 9
         CALL IMMPYI2(MXY(3),INT(MBSAVE),MBPOWERS(K))
         CALL IMEQ(MBPOWERS(K),MXY(3))
      ENDDO

      CALL FMCHANGEBASE_TQ(MA,MBSAVE,0,NDSAVE-1,MXY(1),MXY(2),MBPOWERS)

      KROUND = 1
      CALL IMI2FM(MXY(1),MXY(3))
      CALL IMI2FM(MXY(2),MXY(4))
      CALL FMDIV2(MXY(3),MXY(4),MXY(2))

!             Put the exponent and sign on MB.

      K = MBSAVE
      CALL FMIM(K,MXY(3))
      K = MWK(START(MA)+2)
      IF (K /= 0) THEN
          CALL FMIPWR2(MXY(3),K,MXY(4))
          CALL FMMPY2(MXY(2),MXY(4),MXY(1))
          CALL FMEQ(MXY(1),MXY(2))
      ENDIF
      MWK(START(MXY(2))) = MWK(START(MA))
      KROUND = KRSAVE
      CALL FMEQU(MXY(2),MB,NDIG,NEW_NDIG)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL >= 1) THEN
          KL = MIN(NDIG-NEW_NDIG,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NEW_NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NEW_NDIG+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      MBASE = MBSAVE
      CALL FMCONS
      NDIG = NDSAVE

      NUMBER_USED = NUMBER_USED_SAVE
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCHANGEBASE

      RECURSIVE SUBROUTINE FMCHANGEBASE_TQ(MA,MBSAVE,A,B,MT,MQ,MBPOWERS)

!  This routine does the binary splitting for computing a change of base.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MT,MQ
      INTEGER :: A,B
      REAL (KIND(1.0D0)) :: MBSAVE
      INTENT (IN) :: MA,A,B,MBSAVE
      INTENT (INOUT) :: MT,MQ
      INTEGER :: MXY(4),NUMBER_USED_SAVE,DIGIT,J,K,M,OLD_BASE,MBPOWERS(9)
      REAL (KIND(0.0D0)) :: DA,DB,DM

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      DM = MBSAVE
      OLD_BASE = MBSAVE
      RESULT_SIZE = ( (DB-DA+1)*LOG(DM) + 5 ) / DLOGMB + 8
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MT <= 0) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ENDIF
      IF (MQ <= 0) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ELSE IF (SIZE_OF(MQ) < RESULT_SIZE) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (B-A < 9) THEN
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          DIGIT = MWK(START(MA)+A+3)
          CALL IMI2M2(DIGIT,MT)
          DO J = A+1, B
             CALL IMMPYI2(MT,OLD_BASE,MXY(2))
             DIGIT = MWK(START(MA)+J+3)
             CALL IMI2M2(DIGIT,MXY(1))
             CALL IMADD2(MXY(2),MXY(1),MT)
          ENDDO

!             There may be thousands of calls, all with K = 5,6,7,8,9.
!             These powers are saved instead of re-computing them each time.

          K = B - A + 1
          CALL IMEQ(MBPOWERS(K),MQ)
          GO TO 110
      ENDIF

      M = (A+B)/2
      CALL FMCHANGEBASE_TQ(MA,MBSAVE,A,M-1,MXY(1),MXY(2),MBPOWERS)
      CALL FMCHANGEBASE_TQ(MA,MBSAVE,M,B,MXY(3),MXY(4),MBPOWERS)
      CALL IMMPY2(MXY(1),MXY(4),MQ)
      CALL IMADD2(MXY(3),MQ,MT)

      CALL IMMPY2(MXY(2),MXY(4),MQ)

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
          IF (TEMPV(MQ) == -1) TEMPV(MQ) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCHANGEBASE_TQ

      SUBROUTINE FMCHSH(MA,MB,MC)

!  MB = COSH(MA),    MC = SINH(MA)

!  If both the hyperbolic sine and cosine are needed, this routine is faster than calling both
!  FMCOSH and FMSINH.

!  MB and MC must be distinct arrays.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NCSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      MAS = MWK(START(MA))
      KR_RETRY = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCHSH'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMCOSH(MA,MB)
          CALL FMSINH(MA,MC)
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCHSH'
              CALL FMNTR(1,MB,MB,1,1)
              IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
                  IF (NTRACE < 0) THEN
                      CALL FMNTRJ(MC,NDIG)
                  ELSE
                      CALL FMPRNT(MC)
                  ENDIF
              ENDIF
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          NCSAVE = NCALL
          CALL FMENTR('FMCHSH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (MWK(START(MA)+2) == MUNKNO) KOVUN = 2
          NCALL = NCSAVE + 1
          CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
          MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
          MWK(START(MXY(3))) = 1
          CALL FMCOSH(MXY(3),MXY(4))
          CALL FMSINH(MXY(3),MXY(5))
          GO TO 120
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMCHSH'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
      MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(3))) = 1

      K = 1
      IF (MWK(START(MXY(3))+2) == 0 .AND. MWK(START(MXY(3))+3) /= 0) THEN
          IF (MBASE/MWK(START(MXY(3))+3) >= 100) K = 2
      ENDIF
      IF (MWK(START(MXY(3))+2) >= 0 .AND. MWK(START(MXY(3))+3) /= 0 .AND. K == 1) THEN
          CALL FMCOSH(MXY(3),MXY(4))
          IF (MWK(START(MXY(4))+2) > NDIG) THEN
              CALL FMEQ(MXY(4),MXY(5))
              GO TO 120
          ENDIF
          CALL FMSQR(MXY(4),MXY(2))
          CALL FMI2M(-1,MXY(1))
          CALL FMADD_R1(MXY(2),MXY(1))
          CALL FMSQRT(MXY(2),MXY(5))
      ELSE
          CALL FMSINH(MXY(3),MXY(5))
          CALL FMSQR(MXY(5),MXY(2))
          CALL FMI2M(1,MXY(1))
          CALL FMADD_R1(MXY(2),MXY(1))
          CALL FMSQRT(MXY(2),MXY(4))
      ENDIF

!             Round and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND. MWK(START(MXY(5))+3) /= 0)  &
          MWK(START(MXY(5))) = -MWK(START(MXY(5)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(4))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEQU(MXY(5),MC,NDIG,NDSAVE)
      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(4))+3))+1))/0.69315)
      MWK(START(MXY(4))+1) = MIN(MWK(START(MXY(4))+1),MACCA,MACMAX)
      IF (KOVUN == 2) THEN
          KWRNSV = KWARN
          KWARN = 0
      ENDIF
      CALL FMEXIT(MXY(4),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KOVUN == 2) THEN
          KWARN = KWRNSV
      ENDIF
      IF (NTRACE /= 0) THEN
          IF (ABS(NTRACE) >= 1 .AND. NCALL+1 <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MC,NDIG)
              ELSE
                  CALL FMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCHSH

      FUNCTION FMCOMP(MA,LREL,MB)

!  Logical comparison of FM numbers MA and MB.

!  LREL is a CHARACTER description of the comparison to be done:
!  LREL = 'EQ' returns FMCOMP = .TRUE. if MA == MB
!       = 'NE', 'GE', 'GT', 'LE', 'LT' also work like a logical IF.
!       = '==', '/=', '<', '<=', '>', '>=' may be used.

!  For comparisons involving 'UNKNOWN' or two identical special symbols such as
!  +OVERFLOW,'EQ',+OVERFLOW, FMCOMP is returned FALSE and a KFLAG = -4 error condition is returned.

      USE FMVALS
      IMPLICIT NONE

      LOGICAL :: FMCOMP
      CHARACTER(*) :: LREL
      CHARACTER(2) :: JREL
      INTEGER :: MA,MB

      INTEGER :: J,JCOMP,NLAST
      INTENT (IN) :: MA,LREL,MB

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMCOMP'

      IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 2) THEN
          WRITE (KW,"(' Input to FMCOMP')")

          IF (NTRACE > 0) THEN
              CALL FMPRNT(MA)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              CALL FMPRNT(MB)
          ELSE
              CALL FMNTRJ(MA,NDIG)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              CALL FMNTRJ(MB,NDIG)
          ENDIF
      ENDIF

!             JCOMP will be 1 if MA > MB
!                           2 if MA == MB
!                           3 if MA < MB

!             Check for special cases.

      JREL = LREL
      IF (LREL /= 'EQ' .AND. LREL /= 'NE' .AND. LREL /= 'LT' .AND.  &
          LREL /= 'GT' .AND. LREL /= 'LE' .AND. LREL /= 'GE') THEN
          IF (LREL == 'eq' .OR. LREL == '==') THEN
              JREL = 'EQ'
          ELSE IF (LREL == 'ne' .OR. LREL == '/=') THEN
              JREL = 'NE'
          ELSE IF (LREL == 'lt' .OR. LREL == '<') THEN
              JREL = 'LT'
          ELSE IF (LREL == 'gt' .OR. LREL == '>') THEN
              JREL = 'GT'
          ELSE IF (LREL == 'le' .OR. LREL == '<=') THEN
              JREL = 'LE'
          ELSE IF (LREL == 'ge' .OR. LREL == '>=') THEN
              JREL = 'GE'
          ELSE
              FMCOMP = .FALSE.
              KFLAG = -4
              IF (NCALL /= 1 .OR. KWARN <= 0) GO TO 120
              IF (KWARN <= 0) GO TO 120
              WRITE (KW,  &
                     "(/' Error of type KFLAG = -4 in FM package in',"   //  &
                     "' routine FMCOMP'//1X,A,' is not one of the six'," //  &
                     "' recognized comparisons.'//' .FALSE. has been',"  //  &
                     "' returned.'/)"                                        &
                    ) LREL
              IF (KWARN >= 2) THEN
                  STOP
              ENDIF
              GO TO 120
          ENDIF
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          FMCOMP = .FALSE.
          KFLAG = -4
          GO TO 120
      ENDIF

      IF (ABS(MWK(START(MA)+2)) == MEXPOV .AND. MWK(START(MA)+2) == MWK(START(MB)+2) .AND.  &
          MWK(START(MA)+3) == MWK(START(MB)+3) .AND. MWK(START(MA)) == MWK(START(MB))) THEN
          FMCOMP = .FALSE.
          KFLAG = -4
          IF (NCALL /= 1 .OR. KWARN <= 0) GO TO 120
          IF (KWARN <= 0) GO TO 120
          WRITE (KW,  &
                 "(/' Error of type KFLAG = -4 in FM package in routine'," //  &
                 "' FMCOMP'//' Two numbers in the same overflow or',"      //  &
                 "' underflow category cannot be compared.'//"             //  &
                 "' .FALSE. has been returned.'/)"                             &
                 )
          IF (KWARN >= 2) THEN
              STOP
          ENDIF
          GO TO 120
      ENDIF

!             Check for zero.

      KFLAG = 0
      IF (MWK(START(MA)+3) == 0) THEN
          JCOMP = 2
          IF (MWK(START(MB)+3) == 0) GO TO 110
          IF (MWK(START(MB)) < 0) JCOMP = 1
          IF (MWK(START(MB)) > 0) JCOMP = 3
          GO TO 110
      ENDIF
      IF (MWK(START(MB)+3) == 0) THEN
          JCOMP = 1
          IF (MWK(START(MA)) < 0) JCOMP = 3
          GO TO 110
      ENDIF

!             Check for opposite signs.

      IF (MWK(START(MA)) > 0 .AND. MWK(START(MB)) < 0) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MWK(START(MB)) > 0 .AND. MWK(START(MA)) < 0) THEN
          JCOMP = 3
          GO TO 110
      ENDIF

!             See which one is larger in absolute value.

      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
          GO TO 110
      ENDIF
      NLAST = NDIG + 1

      DO J = 2, NLAST
         IF (ABS(MWK(START(MA)+J+1)) > ABS(MWK(START(MB)+J+1))) THEN
             JCOMP = 1
             GO TO 110
         ENDIF
         IF (ABS(MWK(START(MB)+J+1)) > ABS(MWK(START(MA)+J+1))) THEN
             JCOMP = 3
             GO TO 110
         ENDIF
      ENDDO

      JCOMP = 2

!             Now match the JCOMP value to the requested comparison.

  110 IF (JCOMP == 1 .AND. MWK(START(MA)) < 0) THEN
          JCOMP = 3
      ELSE IF (JCOMP == 3 .AND. MWK(START(MB)) < 0) THEN
          JCOMP = 1
      ENDIF

      FMCOMP = .FALSE.
      IF (JCOMP == 1 .AND. (JREL == 'GT' .OR. JREL == 'GE' .OR. JREL == 'NE')) FMCOMP = .TRUE.
      IF (JCOMP == 2 .AND. (JREL == 'EQ' .OR. JREL == 'GE' .OR. JREL == 'LE')) FMCOMP = .TRUE.
      IF (JCOMP == 3 .AND. (JREL == 'NE' .OR. JREL == 'LT' .OR. JREL == 'LE')) FMCOMP = .TRUE.

  120 CONTINUE
      IF (NTRACE /= 0) THEN
          IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 1) THEN
              IF (KFLAG == 0) THEN
                  WRITE (KW,  &
                         "(' FMCOMP',15X,'Call level =',I2,5X,'MBASE =',"  //  &
                         "I10,5X,'NDIG =',I10)"                                &
                        ) NCALL,INT(MBASE),NDIG
              ELSE
                  WRITE (KW,  &
                         "(' FMCOMP',6X,'Call level =',I2,4X,'MBASE =',"  //  &
                         "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"               &
                        ) NCALL,INT(MBASE),NDIG,KFLAG
              ENDIF
              IF (FMCOMP) THEN
                  WRITE (KW,"(7X,'.TRUE.')")
              ELSE
                  WRITE (KW,"(7X,'.FALSE.')")
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      RETURN
      END FUNCTION FMCOMP

      SUBROUTINE FMCONS

!  Set several saved machine precision constants.

      USE FMVALS
      IMPLICIT NONE

      MBLOGS = MBASE
      ALOGMB = LOG(REAL(MBASE))
      ALOGM2 = ALOGMB/LOG(2.0)
      ALOGMX = LOG(REAL(MAXINT))
      ALOGMT = ALOGMB/LOG(10.0)
      NGRD21 = INT(2.0/ALOGMT + 1.0)
      NGRD52 = INT(5.0/ALOGMT + 2.0)
      NGRD22 = INT(2.0/ALOGMT + 2.0)
      IF (MBASE < 1000) THEN
          NGRD21 = 2*NGRD21
          NGRD52 = 4*NGRD52
          NGRD22 = 2*NGRD22
      ELSE
          NGRD21 = NGRD21 + 1
          NGRD52 = NGRD52 + 1
          NGRD22 = NGRD22 + 1
      ENDIF
      MEXPAB = AINT (MXEXP2/5)
      DLOGMB = LOG(DBLE(MBASE))
      DLOGTN = LOG(10.0D0)
      DLOGTW = LOG(2.0D0)
      DPPI = 4.0D0*ATAN(1.0D0)
      DLOGTP = LOG(2.0D0*DPPI)
      DLOGPI = LOG(DPPI)
      DLOGEB = -LOG(DPEPS)/DLOGMB

      RETURN
      END SUBROUTINE FMCONS

      SUBROUTINE FMCOS(MA,MB)

!  MB = COS(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE,NDSV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOS'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          IF (KRAD == 0) THEN
              CALL FMPI(MXY(2))
              CALL FMSQR(MXY(2),MXY(3))
              CALL FMDIVI_R1(MXY(3),32400)
              CALL FMMPY_R1(MXY(1),MXY(3))
          ENDIF
          CALL FMDIVI(MXY(1),-2,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMADD(MXY(1),MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMADD(MXY(1),MXY(3),MB)
          ELSE IF (KROUND == -1 .OR. KROUND == 0) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMDP2M(0.9D0,MXY(2))
              CALL FMULP(MXY(2),MXY(3))
              CALL FMSUB(MXY(1),MXY(3),MB)
          ELSE
              CALL FMI2M(1,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOS'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMCOS    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMCOS'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(6),NDSAVE,NDIG)
      MWK(START(MXY(6))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(6))) = 1
      IF (MWK(START(MA)+2) > 3*10**5 .AND. KRAD == 1) THEN
          KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(6))
          GO TO 120
      ENDIF
      CALL FMEQ(MXY(6),MXY(5))
      KWRNSV = KWARN
      KWARN = 0

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMI2M(30,MXY(1))
          CALL FMSUB(MXY(6),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0 .AND. JSWAP == 1) THEN
              CALL FMST2M('0.5',MXY(1))
              CALL FMMPYI(MXY(1),JCOS,MXY(6))
              GO TO 120
          ENDIF
      ENDIF
      KWARN = KWRNSV
      IF (MWK(START(MXY(6))+2) == MUNKNO) THEN
          IF (KRAD /= 1 .OR. JSWAP == 1) THEN
              CALL FMEQ(MXY(5),MXY(6))
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
              GO TO 120
          ENDIF
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(3))
              NDIG = NDSV
          ENDIF
          CALL FMDIV(MXY(5),MPISAV,MXY(3))
          CALL FMNINT(MXY(3),MXY(2))
          CALL FMMPY(MXY(2),MPISAV,MXY(1))
          CALL FMSUB_R2(MXY(5),MXY(1))
          IF (MWK(START(MXY(1))+3) == 0) CALL FMULP(MXY(5),MXY(1))
          CALL FMI2M(1,MXY(3))
          CALL FMSQR_R1(MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMSUB_R2(MXY(3),MXY(1))
          CALL FMSUB_R1(MXY(1),MXY(3))
          IF (MWK(START(MXY(1))+3) == 0) THEN
              CALL FMI2M(JCOS,MXY(6))
          ELSE
              CALL FMEQ(MXY(5),MXY(6))
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
          ENDIF
          GO TO 120
      ENDIF
      IF (KRAD == 0) THEN
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(4))
              NDIG = NDSV
          ENDIF
          CALL FMMPY_R1(MXY(6),MPISAV)
          CALL FMDIVI_R1(MXY(6),180)
      ENDIF
      IF (MWK(START(MXY(6))+2) /= MUNKNO) THEN
          IF (JSWAP == 0) THEN
              CALL FMCOS2(MXY(6),MXY(4))
              CALL FMEQ(MXY(4),MXY(6))
          ELSE
              IF (MWK(START(MXY(6))+2) < 0 .OR. NDIG <= 50) THEN
                  CALL FMSIN2(MXY(6),MXY(4))
                  CALL FMEQ(MXY(4),MXY(6))
              ELSE
                  CALL FMCOS2(MXY(6),MXY(4))
                  CALL FMI2M(1,MXY(2))
                  CALL FMSQR(MXY(4),MXY(6))
                  CALL FMSUB_R2(MXY(2),MXY(6))
                  CALL FMSQRT_R1(MXY(6))
              ENDIF
          ENDIF
      ENDIF

!             Append the sign, round, and return.

      IF (MWK(START(MXY(6))+2) /= MUNKNO .AND. MWK(START(MXY(6))+3) /= 0 .AND. JCOS == -1)  &
          MWK(START(MXY(6))) = -MWK(START(MXY(6)))
  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(6))+3))+1))/0.69315)
      MWK(START(MXY(6))+1) = MIN(MWK(START(MXY(6))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(6))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCOS

      SUBROUTINE FMCOS2(MA,MB)

!  Internal subroutine for MB = COS(MA) where 0 <= MA <= 1.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MAXVAL
      INTEGER :: J,J2,K,K2,KTWO,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG2,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMI2M(1,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      NDSAVE = NDIG
      KWRNSV = KWARN
      KWARN = 0

!             Use the direct series:  COS(X) = 1 - X**2/2! + X**4/4! - ...

!             The argument will be divided by 2**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.  The approximately optimal values of K2 and J2 are now
!             computed to try to minimize the time required. N2/2 is the approximate number of terms
!             of the series that will be needed, and L2 guard digits will be carried.

!             Since X is small when the series is summed, COS(X) - 1 is computed.  Then a version of
!             the recovery formula can be used that does not suffer from severe cancellation.

      B = REAL(MBASE)
      K = NGRD52
      T = MAX(NDIG-K,2)
      ALOG2 = LOG(2.0)
      ALOGT = LOG(T)
      TJ = 0.03*ALOGMB*T**0.3333 + 1.85
      J2 = INT(TJ)
      J2 = MAX(1,MIN(J2,LJSUMS))
      IF (NDIG > 2000) THEN
          J2 = -4.0 + 3.0*ALOGT
      ENDIF
      K2 = INT(0.5*SQRT(T*ALOGMB/TJ) + 2.8)

      L = INT(-(REAL(MWK(START(MA)+2))*ALOGMB+LOG(REAL(MWK(START(MA)+3))/B +  &
          REAL(MWK(START(MA)+4))/(B*B)))/ALOG2 - 0.3)
      K2 = K2 - L
      IF (L < 0) L = 0
      IF (NDIG > 2000) THEN
          K2 = 5.8*ALOGMB - 263 + (35 - 0.58*ALOGMB)*ALOGT
      ENDIF
      IF (K2 < 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2)) + .33)
      ENDIF
      IF (J2 <= 1) J2 = 1

      N2 = INT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2))
      L2 = INT(LOG(REAL(N2)+2.0D0**K2)/ALOGMB)
      NDIG = NDIG + L2
      NDSAV1 = NDIG

!             Divide the argument by 2**K2.

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      KTWO = 1
      MAXVAL = MXBASE/2
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTWO = 2*KTWO
             IF (KTWO > MAXVAL) THEN
                 CALL FMDIVI_R1(MXY(1),KTWO)
                 KTWO = 1
             ENDIF
          ENDDO
          IF (KTWO > 1) CALL FMDIVI_R1(MXY(1),KTWO)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum as
!             the terms get smaller.

      CALL FMSQR_R1(MXY(1))
      CALL FMEQ(MXY(1),MXY(2))
      IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
          MWK(START(MXY(2))) = -MWK(START(MXY(2)))
      NTERM = 2
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         CALL FMDIVI_R1(MXY(2),NBOT)
         NTERM = NTERM + 2
         CALL FMEQ(MXY(2),MJSUMS(J))
         IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
             MWK(START(MXY(2))) = -MWK(START(MXY(2)))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 120
      CALL FMIPWR(MXY(1),J2,MXY(3))

  110 CALL FMMPY_R1(MXY(2),MXY(3))
      LARGE = INT(INTMAX/NTERM)
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMDIVI_R1(MXY(2),NTERM)
             NBOT = NTERM - 1
             CALL FMDIVI_R1(MXY(2),NBOT)
         ELSE
             CALL FMDIVI_R1(MXY(2),NBOT)
         ENDIF
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 120
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(2))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
             MWK(START(MXY(2))) = -MWK(START(MXY(2)))
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(3))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(1),MXY(3))
             CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))
          ENDDO
      ENDIF

!             Reverse the effect of reducing the argument to compute COS(MA).

      NDIG = NDSAV1
      IF (K2 > 0) THEN
          IF (NDSAVE <= 20) THEN
              CALL FMI2M(2,MXY(1))
              DO J = 1, K2
                 CALL FMADD(MXY(3),MXY(1),MXY(2))
                 CALL FMMPY_R2(MXY(3),MXY(2))
                 CALL FMADD(MXY(2),MXY(2),MXY(3))
              ENDDO
          ELSE
              DO J = 1, K2
                 CALL FMSQR(MXY(3),MXY(2))
                 CALL FMADD(MXY(3),MXY(3),MXY(1))
                 CALL FMADD_R1(MXY(2),MXY(1))
                 CALL FMADD(MXY(2),MXY(2),MXY(3))
              ENDDO
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(2))
      CALL FMADD_R2(MXY(2),MXY(3))

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE)
      NDIG = NDSAVE
      KWARN = KWRNSV

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCOS2

      SUBROUTINE FMCOSH(MA,MB)

!  MB = COSH(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NMETHD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOSH'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMDIVI(MXY(1),2,MXY(2))
          IF (MWK(START(MXY(2))+2) > MEXPUN) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMADD(MXY(1),MXY(2),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMADD(MXY(1),MXY(2),MB)
          ELSE IF (KROUND == 2) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
          ELSE
              CALL FMI2M(1,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOSH'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMENTR('FMCOSH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMCOSH'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(2))) = 1
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMI2M(1,MXY(2))
          GO TO 120
      ENDIF

!             Use a series for small arguments, FMEXP for large ones.

      IF (MWK(START(MXY(2))+2) == MUNKNO) GO TO 120
      IF (MBASE > 99) THEN
          IF (MWK(START(MXY(2))+2) <= 0) THEN
              NMETHD = 1
          ELSE IF (MWK(START(MXY(2))+2) >= 2) THEN
              NMETHD = 2
          ELSE IF (ABS(MWK(START(MXY(2))+3)) < 10) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MWK(START(MXY(2))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 1) THEN
          CALL FMCSH2(MXY(2),MXY(1))
          CALL FMEQ(MXY(1),MXY(2))
      ELSE
          CALL FMEXP(MXY(2),MXY(1))
          CALL FMEQ(MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+2) == MEXPOV) THEN
              GO TO 120
          ENDIF
          IF (INT(MWK(START(MXY(2))+2)) <= (NDIG+1)/2) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMDIV_R1(MXY(1),MXY(2))
              CALL FMADD_R1(MXY(2),MXY(1))
          ENDIF
          CALL FMDIVI_R1(MXY(2),2)
      ENDIF

!             Round and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(2))+3))+1))/0.69315)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCOSH

      SUBROUTINE FMCSH2(MA,MB)

!  Internal subroutine for MB = COSH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAXVAL
      INTEGER :: J,J2,K,K2,KTWO,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG2,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMI2M(1,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      NDSAVE = NDIG
      KWRNSV = KWARN
      KWARN = 0

!             Use the direct series:  COSH(X) = 1 + X**2/2! + X**4/4! - ...

!             The argument will be divided by 2**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.  The approximately optimal values of K2 and J2 are now
!             computed to try to minimize the time required.  N2/2 is the approximate number of
!             terms of the series that will be needed, and L2 guard digits will be carried.

!             Since X is small when the series is summed, COSH(X) - 1 is computed.  Then a version
!             of the recovery formula can be used that does not suffer from severe cancellation.

      B = REAL(MBASE)
      K = NGRD52
      T = MAX(NDIG-K,2)
      ALOG2 = LOG(2.0)
      ALOGT = LOG(T)
      TJ = 0.03*ALOGMB*T**0.3333 + 1.85
      J2 = INT(TJ)
      J2 = MAX(1,MIN(J2,LJSUMS))
      K2 = INT(0.5*SQRT(T*ALOGMB/TJ) + 2.8)

      L = INT(-(REAL(MWK(START(MA)+2))*ALOGMB+LOG(REAL(MWK(START(MA)+3))/B +  &
            REAL(MWK(START(MA)+4))/(B*B)))/ALOG2 - 0.3)
      K2 = K2 - L
      IF (L < 0) L = 0
      IF (K2 < 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2)) + .33)
      ENDIF
      IF (J2 <= 1) J2 = 1

      N2 = INT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2))
      L2 = INT(LOG(REAL(N2)+2.0D0**K2)/ALOGMB)
      NDIG = NDIG + L2
      NDSAV1 = NDIG
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)

!             Divide the argument by 2**K2.

      KTWO = 1
      MAXVAL = MXBASE/2
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTWO = 2*KTWO
             IF (KTWO > MAXVAL) THEN
                 CALL FMDIVI_R1(MXY(1),KTWO)
                 KTWO = 1
             ENDIF
          ENDDO
          IF (KTWO > 1) CALL FMDIVI_R1(MXY(1),KTWO)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum as
!             the terms get smaller.

      CALL FMSQR_R1(MXY(1))
      CALL FMEQ(MXY(1),MXY(2))
      NTERM = 2
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         CALL FMDIVI_R1(MXY(2),NBOT)
         NTERM = NTERM + 2
         CALL FMEQ(MXY(2),MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 120
      CALL FMIPWR(MXY(1),J2,MXY(3))

  110 CALL FMMPY_R1(MXY(2),MXY(3))
      LARGE = INT(INTMAX/NTERM)
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMDIVI_R1(MXY(2),NTERM)
             NBOT = NTERM - 1
             CALL FMDIVI_R1(MXY(2),NBOT)
         ELSE
             CALL FMDIVI_R1(MXY(2),NBOT)
         ENDIF
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 120
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(2))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(3))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(1),MXY(3))
             CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))
          ENDDO
      ENDIF

!             Reverse the effect of reducing the argument to compute COSH(MA).

      NDIG = NDSAV1
      IF (K2 > 0) THEN
          IF (NDSAVE <= 20) THEN
              CALL FMI2M(2,MXY(1))
              DO J = 1, K2
                 CALL FMADD(MXY(3),MXY(1),MXY(2))
                 CALL FMMPY_R2(MXY(3),MXY(2))
                 CALL FMADD(MXY(2),MXY(2),MXY(3))
              ENDDO
          ELSE
              DO J = 1, K2
                 CALL FMSQR(MXY(3),MXY(2))
                 CALL FMADD(MXY(3),MXY(3),MXY(1))
                 CALL FMADD_R1(MXY(2),MXY(1))
                 CALL FMADD(MXY(2),MXY(2),MXY(3))
              ENDDO
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(2))
      CALL FMADD_R2(MXY(2),MXY(3))

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE)
      NDIG = NDSAVE
      KWARN = KWRNSV

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCSH2

      SUBROUTINE FMCSSN(MA,MB,MC)

!  MB = COS(MA),    MC = SIN(MA)

!  If both the sine and cosine are needed, this routine is faster than calling both FMCOS and FMSIN.

!  MB and MC must be distinct arrays.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NCSAVE,NDSAVE,NDSV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MXY(7),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      MAS = MWK(START(MA))
      KR_RETRY = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCSSN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMCOS(MA,MB)
          CALL FMSIN(MA,MC)
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCSSN'
              CALL FMNTR(1,MB,MB,1,1)
              IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
                  IF (NTRACE < 0) THEN
                      CALL FMNTRJ(MC,NDIG)
                  ELSE
                      CALL FMPRNT(MC)
                  ENDIF
              ENDIF
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          NCSAVE = NCALL
          CALL FMENTR('FMCSSN   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (MWK(START(MA)+2) == MUNKNO) KOVUN = 2
          NCALL = NCSAVE + 1
          CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
          MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
          MWK(START(MXY(3))) = 1
          IF (MWK(START(MA)+2) == MEXPOV) THEN
              KFLAG = -4
              CALL FMST2M('UNKNOWN',MXY(5))
              CALL FMST2M('UNKNOWN',MXY(6))
          ELSE
              CALL FMCOS(MXY(3),MXY(5))
              CALL FMSIN(MXY(3),MXY(6))
          ENDIF
          GO TO 120
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMCSSN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      IF (MWK(START(MA)+2) > 3*10**5 .AND. KRAD == 1) THEN
          KFLAG = -4
          CALL FMWARN
          CALL FMST2M('UNKNOWN',MXY(5))
          CALL FMST2M('UNKNOWN',MXY(6))
          GO TO 120
      ENDIF

      CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(5))) = 1
      CALL FMEQ(MXY(5),MXY(7))

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the functions.

      CALL FMRDC(MXY(5),JSIN,JCOS,JSWAP)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMI2M(30,MXY(1))
          CALL FMSUB(MXY(5),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMCOS(MXY(7),MXY(5))
              CALL FMSIN(MXY(7),MXY(6))
              GO TO 120
          ENDIF
      ENDIF
      IF (MWK(START(MXY(5))+2) == MUNKNO) THEN
          CALL FMCOS(MXY(7),MXY(5))
          CALL FMSIN(MXY(7),MXY(6))
          GO TO 120
      ENDIF
      IF (KRAD == 0) THEN
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(6))
              NDIG = NDSV
          ENDIF
          CALL FMMPY_R1(MXY(5),MPISAV)
          CALL FMDIVI_R1(MXY(5),180)
      ENDIF
      IF (MWK(START(MXY(5))+2) /= MUNKNO) THEN
          IF (JSWAP == 0) THEN
              IF (MWK(START(MXY(5))+2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(6))
                  MWK(START(MXY(6))) = JSIN*MWK(START(MXY(6)))
                  CALL FMSQR(MXY(6),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  CALL FMSQRT(MXY(2),MXY(5))
                  MWK(START(MXY(5))) = JCOS*MWK(START(MXY(5)))
              ELSE
                  CALL FMCOS2(MXY(5),MXY(4))
                  CALL FMEQ(MXY(4),MXY(5))
                  MWK(START(MXY(5))) = JCOS*MWK(START(MXY(5)))
                  CALL FMSQR(MXY(5),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  CALL FMSQRT(MXY(2),MXY(6))
                  MWK(START(MXY(6))) = JSIN*MWK(START(MXY(6)))
              ENDIF
          ELSE
              IF (MWK(START(MXY(5))+2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(4))
                  CALL FMEQ(MXY(4),MXY(5))
                  MWK(START(MXY(5))) = JCOS*MWK(START(MXY(5)))
                  CALL FMSQR(MXY(5),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  CALL FMSQRT(MXY(2),MXY(6))
                  MWK(START(MXY(6))) = JSIN*MWK(START(MXY(6)))
              ELSE
                  CALL FMCOS2(MXY(5),MXY(6))
                  MWK(START(MXY(6))) = JSIN*MWK(START(MXY(6)))
                  CALL FMSQR(MXY(6),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  CALL FMSQRT(MXY(2),MXY(5))
                  MWK(START(MXY(5))) = JCOS*MWK(START(MXY(5)))
              ENDIF
          ENDIF
      ELSE
          CALL FMEQ(MXY(5),MXY(6))
      ENDIF

!             Round and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(6))+3))+1))/0.69315)
      MWK(START(MXY(6))+1) = MIN(MWK(START(MXY(6))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(6))+2) /= MUNKNO .AND. MWK(START(MXY(6))+3) /= 0)  &
          MWK(START(MXY(6))) = -MWK(START(MXY(6)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1 .AND. MWK(START(MA)+2) /= MEXPOV .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(6))+2) /= MUNKNO) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(6))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1 .AND. MWK(START(MA)+2) /= MEXPOV .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(6))+2) /= MUNKNO) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)
      IF (KOVUN == 2) THEN
          KWRNSV = KWARN
          KWARN = 0
      ENDIF
      NDSV = NDIG
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      CALL FMEQU(MXY(6),MC,NDSV,NDSAVE)
      IF (KOVUN == 2) THEN
          KWARN = KWRNSV
      ENDIF
      IF (NTRACE /= 0) THEN
          IF (ABS(NTRACE) >= 1 .AND. NCALL+1 <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MC,NDIG)
              ELSE
                  CALL FMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCSSN

      SUBROUTINE FMDBL(A,B,C)

!  C = A + B.  All are double precision.  This routine tries to force the compiler to round C to
!  double precision accuracy. Some compilers allow double precision loops like the one in FMDM to
!  be done in extended precision, which defeats the routine's attempt to determine double precision
!  accuracy.  This can lead to doing too few Newton steps and failing to get sufficient accuracy in
!  several FM routines.

      USE FMVALS
      IMPLICIT NONE
      DOUBLE PRECISION :: A,B,C
      INTENT (IN) :: A,B
      INTENT (INOUT) :: C
      C = A + B
      RETURN
      END SUBROUTINE FMDBL

      SUBROUTINE FMDEFINE(MA)

!  Assign space in the FM work area, MWK, for a new multiple precision number.
!  Before being defined the first time, MA must have one of these values, to indicate what
!  type of multiple precision number MA will represent, and how much space it will need:

!      -1 for derived type FM, IM, ZM temporary numbers
!      -2 for internal FM temporary multiple precision numbers
!      -3 for user saved derived type variables or FM saved constants (pi, e, ...)
!      -4 for bigger saved FM work areas (MWA, ...)
!      -5 for multiple precision temporary numbers in packed format

!  After calling FMDEFINE with MA from -5 to -1, the returned value of MA is positive, giving an
!  "index" value.  Then START(MA) gives the starting location in array MWK for the multiple
!  precision number, and SIZE_OF(MA) gives the number of array elements in MWK that are assigned
!  to multiple precision number MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTEGER :: J,K,L,L1,L2,LAST_J,NEW_K,NEW_START,NEW_SIZE,NFREE,N_RESIZE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      N_RESIZE = 0
      IF (MA > SIZE_OF_START) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  In FMDEFINE the index value of MA is too large.'
          WRITE (KW,*) '               Index =',MA,' cannot be greater than ',SIZE_OF_START,'.'
          WRITE (KW,*) '               Usually this means type (FM), (ZM), or (IM) variables in'
          WRITE (KW,*) "               the user's program were declared but not initialized to -3."
          WRITE (KW,*) ' '
          STOP
      ENDIF

!             If MA has already been defined at a lower precision, MA will be positive here.
!             Re-define it with a new index and more space in MWK.

!             TEMPV(L) is set to the -1, ..., -5 input value of MA when MA is defined (= L) the
!             first time, so that a record is preserved of which type of multiple precision number
!             MA represents.
!             TEMPV(L) is set to -6 if MA gets re-defined at higher precision.  MA then has a new
!             index value and more space in MWK, and the -6 TEMPV value marks the old index as
!             unused.
!             If MWK runs out of space for new multiple precision numbers, it is re-allocated at a
!             bigger size.  When that is done, the unused space in MWK corresponding to any
!             TEMPV = -6 index values is deleted, and then those TEMPV elements are set to -7 to
!             mark those indexes as deleted.

      IF (MA > 0) THEN
          N_RESIZE = RESIZE(MA)
          RESIZE(MA) = 0
          L = MA
          MA = TEMPV(L)
          TEMPV(L) = -6
          N_RESIZE = N_RESIZE + 1
      ELSE IF (MA == 0 .OR. MA < -5) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  In FMDEFINE the index value of MA must be positive or in'
          WRITE (KW,*) '               the range -5, ..., -1.  MA is ',MA
          WRITE (KW,*) '               Usually this means type (FM), (ZM), or (IM) variables in'
          WRITE (KW,*) "               the user's program were declared but not initialized to -3."
          WRITE (KW,*) ' '
          STOP
      ENDIF
      NEW_SIZE = NDIG + 3
      IF (MA == -4) NEW_SIZE = 2*NDIG + 30
      IF (MA == -5) NEW_SIZE = NDIG/2 + 4
      IF (N_RESIZE > 10) NEW_SIZE = 2*NEW_SIZE

!             L1    is the last word used on the left of MWK.
!             L2    is the first word used on the right of MWK.
!             NFREE is the number of free words in the middle.

      L1 = 1
      IF (NUMBER_USED > 0) L1 = START(NUMBER_USED)+SIZE_OF(NUMBER_USED)
      L2 = SIZE_OF_MWK
      IF (START_OF_SAVED_CONSTANTS <= SIZE_OF_START) L2 = START(START_OF_SAVED_CONSTANTS)
      NFREE = L2 - L1 - 1

!             If MWK runs out of space, try to re-allocate it with a bigger size.

      IF (NEW_SIZE > NFREE) THEN
          IF (SIZE_OF_MWK > 0) THEN
              ALLOCATE(MOVE_MWK(SIZE_OF_MWK),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              DO J = 1, SIZE_OF_MWK
                 MOVE_MWK(J) = MWK(J)
              ENDDO
              DEALLOCATE(MWK)
              L2 = MAX(10000,2*SIZE_OF_MWK,SIZE_OF_MWK+NEW_SIZE+30)
              ALLOCATE(MWK(L2),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              DO J = 1, L2
                 MWK(J) = MUNKNO
              ENDDO
              IF (NUMBER_USED > 0) THEN
                  NEW_K = 0
                  DO J = 1, NUMBER_USED
                     IF (TEMPV(J) > -6) THEN
                         NEW_START = NEW_K + 1
                         DO K = START(J), START(J)+SIZE_OF(J)-1
                            NEW_K = NEW_K + 1
                            MWK(NEW_K) = MOVE_MWK(K)
                         ENDDO
                         START(J) = NEW_START
                         LAST_J = J
                     ELSE
                         TEMPV(J) = -7
                     ENDIF
                  ENDDO
                  START(NUMBER_USED) = NEW_START
                  SIZE_OF(NUMBER_USED) = SIZE_OF(LAST_J)
              ENDIF
              IF (START_OF_SAVED_CONSTANTS <= SIZE_OF_START) THEN
                  NEW_K = L2 + 1
                  DO J = SIZE_OF_START, START_OF_SAVED_CONSTANTS, -1
                     IF (TEMPV(J) > -6) THEN
                         DO K = START(J)+SIZE_OF(J)-1, START(J), -1
                            NEW_K = NEW_K - 1
                            MWK(NEW_K) = MOVE_MWK(K)
                         ENDDO
                         START(J) = NEW_K
                         LAST_J = J
                     ELSE
                         TEMPV(J) = -7
                     ENDIF
                  ENDDO
                  START(START_OF_SAVED_CONSTANTS) = NEW_K
                  SIZE_OF(START_OF_SAVED_CONSTANTS) = SIZE_OF(LAST_J)
              ENDIF
              DEALLOCATE(MOVE_MWK)
              SIZE_OF_MWK = L2
          ELSE
              L2 = MAX(10000,NEW_SIZE+30)
              ALLOCATE(MWK(L2),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              SIZE_OF_MWK = L2
              DO J = 1, SIZE_OF_MWK
                 MWK(J) = MUNKNO
              ENDDO
          ENDIF
      ENDIF

      IF (MA == -3 .OR. MA == -4) GO TO 110

!             Store temporary variables from the beginning of MWK.

      IF (NUMBER_USED <= 0) THEN
          NUMBER_USED = 1
          START(1) = 1
          SIZE_OF(1) = NDIG + 3
          IF (MA == -5) SIZE_OF(1) = NDIG/2 + 4
      ELSE
          IF (START_OF_SAVED_CONSTANTS <= SIZE_OF_START) THEN
              L1 = START(START_OF_SAVED_CONSTANTS)
          ELSE
              L1 = SIZE_OF_MWK
          ENDIF
          IF (NUMBER_USED+1 >= START_OF_SAVED_CONSTANTS) THEN
              CALL FMDEFINE_ERROR(2)
          ENDIF
          NUMBER_USED = NUMBER_USED + 1
          START(NUMBER_USED) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
          SIZE_OF(NUMBER_USED) = NDIG + 3
          IF (MA == -5) SIZE_OF(NUMBER_USED) = NDIG/2 + 4
      ENDIF
      MAXIMUM_NUMBER_USED = MAX(MAXIMUM_NUMBER_USED,NUMBER_USED)
      L1 = NDIG + 3
      IF (MA == -5) L1 = NDIG/2 + 4
      MAXIMUM_MWK_USED = MAX(MAXIMUM_MWK_USED,START(NUMBER_USED)+L1)
      TEMPV(NUMBER_USED) = MA

      MA = NUMBER_USED
      RESIZE(MA) = N_RESIZE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

!             Store saved variables from the end of MWK.

  110 IF (START_OF_SAVED_CONSTANTS > SIZE_OF_START) THEN
          START_OF_SAVED_CONSTANTS = SIZE_OF_START
          IF (MA == -3) THEN
              START(START_OF_SAVED_CONSTANTS) = SIZE_OF_MWK - NDIG - 2
              SIZE_OF(START_OF_SAVED_CONSTANTS) = NDIG + 3
          ELSE
              START(START_OF_SAVED_CONSTANTS) = SIZE_OF_MWK - (2*NDIG+30) + 1
              SIZE_OF(START_OF_SAVED_CONSTANTS) = 2*NDIG + 30
          ENDIF
          TEMPV(START_OF_SAVED_CONSTANTS) = MA
          MA = START_OF_SAVED_CONSTANTS
      ELSE
          IF (START_OF_SAVED_CONSTANTS <= SIZE_OF_START) THEN
              L1 = START(START_OF_SAVED_CONSTANTS)
          ELSE
              L1 = SIZE_OF_MWK
          ENDIF
          IF (NUMBER_USED > 0) THEN
              L2 = START(NUMBER_USED) + SIZE_OF(NUMBER_USED)
          ELSE
              L2 = 1
          ENDIF
          IF (MA == -3) THEN
              K = NDIG + 3
          ELSE
              K = 2*NDIG + 30
          ENDIF
          L = -1
          DO J = START_OF_SAVED_CONSTANTS, SIZE_OF_START
             IF (TEMPV(J) /= -6) CYCLE
             IF (SIZE_OF(J) >= K) THEN
                 IF (L < 0) THEN
                     L = J
                 ELSE
                     IF (SIZE_OF(J) < SIZE_OF(L)) THEN
                         L = J
                     ENDIF
                 ENDIF
             ENDIF
          ENDDO
          IF (L < 0) THEN
              IF (NUMBER_USED+1 >= START_OF_SAVED_CONSTANTS .OR. L2+NDIG+3 >= L1) THEN
                  CALL FMDEFINE_ERROR(2)
              ENDIF
              START_OF_SAVED_CONSTANTS = START_OF_SAVED_CONSTANTS - 1
              IF (MA == -3) THEN
                  START(START_OF_SAVED_CONSTANTS) = START(START_OF_SAVED_CONSTANTS+1) - (NDIG+3)
                  SIZE_OF(START_OF_SAVED_CONSTANTS) = NDIG + 3
              ELSE
                  START(START_OF_SAVED_CONSTANTS) = START(START_OF_SAVED_CONSTANTS+1) - (2*NDIG+30)
                  SIZE_OF(START_OF_SAVED_CONSTANTS) = 2*NDIG + 30
              ENDIF
              TEMPV(START_OF_SAVED_CONSTANTS) = MA
              MA = START_OF_SAVED_CONSTANTS
          ELSE
              TEMPV(L) = MA
              MA = L
          ENDIF
      ENDIF
      MINIMUM_SAVED_CONSTANTS_USED = MIN(MINIMUM_SAVED_CONSTANTS_USED,START_OF_SAVED_CONSTANTS)
      RESIZE(MA) = N_RESIZE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDEFINE

      SUBROUTINE FMDEFINE_ERROR(KERR)

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KERR

      IF (KERR <= 1) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  Out of memory for the database of multiple precision numbers'
          WRITE (KW,*) '               or character strings to format FM output.'
          WRITE (KW,*) '               Allocation of more memory failed.'
          WRITE (KW,*) ' '
      ELSE
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  More than ',SIZE_OF_START,' type (FM), (ZM), (IM) numbers'
          WRITE (KW,*) '               have been defined.  Variable  SIZE_OF_START  in file'
          WRITE (KW,*) '               FMSAVE.f95  defines this value.'
          WRITE (KW,*) '               Possible causes of this error and remedies:'
          WRITE (KW,*) '               (1) Make sure all subroutines (also functions that do not'
          WRITE (KW,*) '                   return type FM, ZM, or IM function values) have'
          WRITE (KW,*) '                       CALL FM_ENTER_USER_ROUTINE'
          WRITE (KW,*) '                   at the start and '
          WRITE (KW,*) '                       CALL FM_EXIT_USER_ROUTINE'
          WRITE (KW,*) '                   at the end and before any other return, and all'
          WRITE (KW,*) '                   functions returning an FM, ZM, or IM function value have'
          WRITE (KW,*) '                       CALL FM_ENTER_USER_FUNCTION(F)'
          WRITE (KW,*) '                   at the start and '
          WRITE (KW,*) '                       CALL FM_EXIT_USER_FUNCTION(F)'
          WRITE (KW,*) '                   at the end and before any other return, where the actual'
          WRITE (KW,*) '                   function name replaces  F  above.'
          WRITE (KW,*) '                   Otherwise that routine could be leaking memory, and'
          WRITE (KW,*) '                   worse, could get wrong results because of deleting some'
          WRITE (KW,*) '                   FM, ZM, or IM temporary variables too soon.'
          WRITE (KW,*) '               (2) Make sure all subroutines and functions declare any'
          WRITE (KW,*) '                   local type FM, ZM, or IM variables as saved.  Otherwise'
          WRITE (KW,*) '                   some compilers create new instances of those variables'
          WRITE (KW,*) '                   with each call, leaking memory.'
          WRITE (KW,*) '                   For example:'
          WRITE (KW,*) '                       SUBROUTINE SUB(A,B,C,X,Y,RESULT)'
          WRITE (KW,*) '                       TYPE (FM) :: A,B,C,X,Y,RESULT,ERR,TOL,H'
          WRITE (KW,*) '                   Here A,B,C,X,Y,RESULT are the input variables and'
          WRITE (KW,*) '                   ERR,TOL,H are local variables.  The fix is:'
          WRITE (KW,*) '                       SUBROUTINE SUB(A,B,C,X,Y,RESULT)'
          WRITE (KW,*) '                       TYPE (FM) :: A,B,C,X,Y,RESULT'
          WRITE (KW,*) '                       TYPE (FM), SAVE :: ERR,TOL,H'
          WRITE (KW,*) '               (3) Since = assignments for multiple precision variables are'
          WRITE (KW,*) '                   the trigger for cleaning up temporary multiple precision'
          WRITE (KW,*) '                   variables, a loop with subroutine calls that has no ='
          WRITE (KW,*) '                   assignments can run out of space to store temporaries.'
          WRITE (KW,*) '                   For example:'
          WRITE (KW,*) '                       DO J = 1, N'
          WRITE (KW,*) '                          CALL SUB(A,B,C,TO_FM(0),TO_FM(1),RESULT)'
          WRITE (KW,*) '                       ENDDO'
          WRITE (KW,*) '                   Most compilers will create two temporary variables with'
          WRITE (KW,*) '                   each call, to hold the TO_FM values.'
          WRITE (KW,*) '                   One fix is to put an assignment into the loop:'
          WRITE (KW,*) '                       DO J = 1, N'
          WRITE (KW,*) '                          ZERO = TO_FM(0)'
          WRITE (KW,*) '                          CALL SUB(A,B,C,ZERO,TO_FM(1),RESULT)'
          WRITE (KW,*) '                       ENDDO'
          WRITE (KW,*) '               (4) If a routine uses allocatable type FM, ZM, or IM arrays'
          WRITE (KW,*) '                   and allocates and deallocates with each call, then after'
          WRITE (KW,*) '                   many calls this limit on number of variables could be '
          WRITE (KW,*) '                   exceeded, since new FM variable index numbers are'
          WRITE (KW,*) '                   generated for each call to the routine.'
          WRITE (KW,*) '                   A fix for this is to call FM_DEALLOCATE before actually'
          WRITE (KW,*) '                   deallocating each array, so those index numbers can be'
          WRITE (KW,*) '                   re-used.  For example:'
          WRITE (KW,*) '                       DEALLOCATE(T)'
          WRITE (KW,*) '                   becomes:'
          WRITE (KW,*) '                       CALL FM_DEALLOCATE(T)'
          WRITE (KW,*) '                       DEALLOCATE(T)'
          WRITE (KW,*) '               (5) If none of this helps, try running this program again'
          WRITE (KW,*) '                   after increasing the value of  SIZE_OF_START  and'
          WRITE (KW,*) '                   re-compiling.'
          WRITE (KW,*) ' '
      ENDIF
      STOP
      END SUBROUTINE FMDEFINE_ERROR

      SUBROUTINE FMDIG(NSTACK,KST)

!  Compute the number of intermediate digits to be used in Newton iteration.  This assumes that a
!  starting approximation that is accurate to double precision is used, and the root is simple.

!  KST is the number of iterations needed for final accuracy NDIG.
!  NSTACK(J) holds the value of NDIG to be used for the Jth iteration.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NSTACK(49),KST
      INTENT (INOUT) :: NSTACK,KST

      DOUBLE PRECISION :: Y
      INTEGER :: J,JT,L,ND,NDT,NE

      IF (MBLOGS /= MBASE) CALL FMCONS

!             NE is the maximum number of base MBASE digits that can be used in the first
!                Newton iteration.

      NE = INT(1.9D0*DLOGEB)

!             Fill the intermediate digit stack (backwards).

      KST = 1
      ND = NDIG
      NSTACK(1) = ND
      IF (ND < NE .OR. ND <= 2) RETURN

  110 Y = ND

!             The 1.9 accounts for the fact that the number of correct digits approximately doubles
!             at each iteration.

      NDT = INT(Y/1.9D0)
      IF (2*NDT <= ND) NDT = NDT + 1
      ND = NDT
      KST = KST + 1
      NSTACK(KST) = ND
      IF (ND > NE .AND. ND > 2) GO TO 110

!             Reverse the stack.

      L = KST/2
      DO J = 1, L
         JT = NSTACK(J)
         NSTACK(J) = NSTACK(KST+1-J)
         NSTACK(KST+1-J) = JT
      ENDDO

      RETURN
      END SUBROUTINE FMDIG

      SUBROUTINE FMDIM(MA,MB,MC)

!  MC = DIM(MA,MB)

!  Positive difference.  MC = MA - MB  if MA >= MB,
!                           = 0        otherwise.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MXSAVE
      INTEGER :: KASAVE,KOVUN,KRESLT,KWRNSV,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB) THEN
          CALL FMENTR('FMDIM    ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NDIG = NDSAVE
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMDIM'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          KASAVE = KACCSW
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KWRNSV = KWARN
      KWARN = 0
      MXEXP = MXSAVE

      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

      IF (FMCOMP(MXY(1),'<',MXY(2))) THEN
          CALL FMI2M(0,MXY(3))
      ELSE
          NCALL = NCALL - 1
          CALL FMSUB(MXY(1),MXY(2),MXY(3))
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMDIM'
      ENDIF

      IF (KFLAG == 1) KFLAG = 0
      KWARN = KWRNSV
      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(3))+3))+1))/0.69315)
      MWK(START(MXY(3))+1) = MIN(MWK(START(MXY(3))+1),MACCA,MACCB,MACMAX)
      CALL FMEXIT(MXY(3),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIM

      SUBROUTINE FMDIV(MA,MB,MC)

!  MC = MA / MB

!  This routine performs the trace printing for division.  FMDIV2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIV'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMDIV2(MA,MB,MC)

          CALL FMNTR(1,MC,MC,1,1)
      ELSE
          CALL FMDIV2(MA,MB,MC)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV

      SUBROUTINE FMDIV2(MA,MB,MC)

!  Internal division routine.  MC = MA / MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MLR,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KT3,L,N1,NG,NGUARD,NL
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMDIV    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMDIV'
              CALL FMRSLT(MA,MB,MC,KRESLT)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          IF (MWK(START(MB)+3) == 0) THEN
              NAMEST(NCALL) = 'FMDIV'
              CALL FMIM(0,MC)
              KFLAG = -4
              CALL FMWARN
              MWK(START(MC)+2) = MUNKNO
              MWK(START(MC)+3) = 1
              MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MA)+3) == 0) THEN
              CALL FMIM(0,MC)
              MWK(START(MC)+1) = MIN(MACCA,MACCB)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52 - 1
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10
      N1 = NDIG + 1
      NG = NDIG + NGUARD

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      MWK(START(MWA)+2) = MWK(START(MA)+2) - MWK(START(MB)+2) + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+2
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          NG = NDIG + NGRDN + 1
          IF (MWK(START(MPMA)+3) >= MWK(START(MPMB)+3)) NG = NG + 1

!             Copy MA into the working array.

          DO J = 2, NDIG+1
             MWK(START(MWA)+J+2) = MWK(START(MPMA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          DO J = NDIG+3, NG+4
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MPMB,NG)
          IF (MWK(START(MWA)+3) >= MBASEL) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J)
              ENDDO
              MWK(START(MWA)+3) = 0
              MWK(START(MWA)+2) = MWK(START(MWA)+2) + 1
          ENDIF
          KT3 = N21 - 1
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 2+NDIG+NGRDN, 3, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K-KT3+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

!             Copy MA into the working array.

          DO J = 2, N1
             MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          NL = N1 + NGUARD + 3
          DO J = NDIG+3, NL
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MB,NG)
      ENDIF

!             Round, affix the sign, and return.

      IF (MWK(START(MWA)+3) == 0) THEN

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+3)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MC)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIV'
          CALL FMWARN
      ENDIF

      MWK(START(MC)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
          MWK(START(MC)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MC)+3))+1))/0.69315)
          MWK(START(MC)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MC)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV2

      SUBROUTINE FMDIV_R1(MA,MB)

!  MA = MA / MB

!  This routine performs the trace printing for division.  FMDIV2_R1 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIV_R1'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMDIV2_R1(MA,MB)

          NAMEST(NCALL) = 'FMDIV_R1'
          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMDIV2_R1(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV_R1

      SUBROUTINE FMDIV2_R1(MA,MB)

!  Internal division routine.  MA = MA / MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MLR,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KT3,L,N1,NG,NGUARD,NL
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NUMBER_USED_SAVE = NUMBER_USED
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      KR_RETRY = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMDIV    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMDIV_R1'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT)
              CALL FMEQ(MXY(1),MA)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          IF (MWK(START(MB)+3) == 0) THEN
              NAMEST(NCALL) = 'FMDIV_R1'
              CALL FMIM(0,MA)
              KFLAG = -4
              CALL FMWARN
              MWK(START(MA)+2) = MUNKNO
              MWK(START(MA)+3) = 1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MA)+3) == 0) THEN
              CALL FMIM(0,MA)
              MWK(START(MA)+1) = MIN(MACCA,MACCB)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52 - 1
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10
      N1 = NDIG + 1
      NG = NDIG + NGUARD

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      MWK(START(MWA)+2) = MWK(START(MA)+2) - MWK(START(MB)+2) + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+2
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          NG = NDIG + NGRDN + 1
          IF (MWK(START(MPMA)+3) >= MWK(START(MPMB)+3)) NG = NG + 1

!             Copy MA into the working array.

          DO J = 2, NDIG+1
             MWK(START(MWA)+J+2) = MWK(START(MPMA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          DO J = NDIG+3, NG+4
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MPMB,NG)
          IF (MWK(START(MWA)+3) >= MBASEL) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J)
              ENDDO
              MWK(START(MWA)+3) = 0
              MWK(START(MWA)+2) = MWK(START(MWA)+2) + 1
          ENDIF
          KT3 = N21 - 1
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 2+NDIG+NGRDN, 3, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K-KT3+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

!             Copy MA into the working array.

          DO J = 2, N1
             MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          NL = N1 + NGUARD + 3
          DO J = NDIG+3, NL
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MB,NG)
      ENDIF

!             Round, affix the sign, and return.

      IF (MWK(START(MWA)+3) == 0) THEN

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+3)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIV_R1'
          CALL FMWARN
      ENDIF

      MWK(START(MA)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0)  &
          MWK(START(MA)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          MWK(START(MA)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MA)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV2_R1

      SUBROUTINE FMDIV_R2(MA,MB)

!  MB = MA / MB

!  This routine performs the trace printing for division.  FMDIV2_R2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIV_R2'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMDIV2_R2(MA,MB)

          NAMEST(NCALL) = 'FMDIV_R2'
          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMDIV2_R2(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV_R2

      SUBROUTINE FMDIV2_R2(MA,MB)

!  Internal division routine.  MB = MA / MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MLR,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KT3,L,N1,NG,NGUARD,NL
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NUMBER_USED_SAVE = NUMBER_USED
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      KR_RETRY = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMDIV    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMDIV_R2'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT)
              CALL FMEQ(MXY(1),MB)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          IF (MWK(START(MB)+3) == 0) THEN
              NAMEST(NCALL) = 'FMDIV_R2'
              CALL FMIM(0,MB)
              KFLAG = -4
              CALL FMWARN
              MWK(START(MB)+2) = MUNKNO
              MWK(START(MB)+3) = 1
              MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          IF (MWK(START(MA)+3) == 0) THEN
              CALL FMIM(0,MB)
              MWK(START(MB)+1) = MIN(MACCA,MACCB)
              JRSIGN = JRSSAV
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52 - 1
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10
      N1 = NDIG + 1
      NG = NDIG + NGUARD

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      MWK(START(MWA)+2) = MWK(START(MA)+2) - MWK(START(MB)+2) + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+2
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          NG = NDIG + NGRDN + 1
          IF (MWK(START(MPMA)+3) >= MWK(START(MPMB)+3)) NG = NG + 1

!             Copy MA into the working array.

          DO J = 2, NDIG+1
             MWK(START(MWA)+J+2) = MWK(START(MPMA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          DO J = NDIG+3, NG+4
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MPMB,NG)
          IF (MWK(START(MWA)+3) >= MBASEL) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J)
              ENDDO
              MWK(START(MWA)+3) = 0
              MWK(START(MWA)+2) = MWK(START(MWA)+2) + 1
          ENDIF
          KT3 = N21 - 1
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 2+NDIG+NGRDN, 3, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 2+NDIG+NGRDN, 3, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2+KT3)
                    MWK(START(MWA)+K-KT3+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K-KT3+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

!             Copy MA into the working array.

          DO J = 2, N1
             MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
          NL = N1 + NGUARD + 3
          DO J = NDIG+3, NL
             MWK(START(MWA)+J+1) = 0
          ENDDO
          CALL FMDIV3(MB,NG)
      ENDIF

!             Round, affix the sign, and return.

      IF (MWK(START(MWA)+3) == 0) THEN

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+3)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          IF (NCALL == 1 .AND. NGUARD < NDIG+10) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) )    &
                  KR_RETRY = KR_RETRY + 1
          ENDIF
          IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
              KR_RETRY = 2
              GO TO 110
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIV_R2'
          CALL FMWARN
      ENDIF

      MWK(START(MB)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
          MWK(START(MB)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MB)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIV2_R2

      SUBROUTINE FMDIV3(MB,NG)

!  Internal division routine.  Divide MA/MB and return the quotient in MWA.
!  MA has already been copied into MWA.
!  NG is the number of guard digits used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MB

      DOUBLE PRECISION :: XB,XBR,XBASE,XMWA
      REAL (KIND(1.0D0)) :: MAXMWA,MBM1,MCARRY,MKT,MLMAX,MQD
      INTEGER :: J,JB,JL,JMB,JMWA,KA,KB,KL,KPTMWA,N1,NG,NL,NMBWDS,NMETHD,NZDMB
      INTENT (IN) :: MB

      N1 = NDIG + 1
      NL = NG + 4

!             Check for using an FFT-based method if precision is very high.

      IF (NDIG >= 2200) THEN
          NZDMB = 0
          DO J = 2, NDIG
             IF (MWK(START(MB)+J+2) == 0) NZDMB = NZDMB + 1
          ENDDO
          IF (NDIG-NZDMB < 50 .OR. REAL(NZDMB)/NDIG > 0.8 ) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMDIVFFT(MB)
          RETURN
      ENDIF

!             NMBWDS is the number of words of MB used to compute the estimated quotient digit MQD.

      NMBWDS = 4
      IF (MBASE < 100) NMBWDS = 7

!             XB is an approximation of MB used in estimating the quotient digits.

      XBASE = DBLE(MBASE)
      XB = 0
      JL = NMBWDS
      IF (JL <= N1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MWK(START(MB)+J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= N1) THEN
                 XB = XB*XBASE + DBLE(MWK(START(MB)+J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= N1) THEN
          XB = XB + DBLE(MWK(START(MB)+JL+2))/XBASE
      ENDIF
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBM1 = MBASE - 1
      MLMAX = MAXINT/MBM1
      MKT = INTMAX - MBASE
      MLMAX = MIN(MLMAX,MKT)

!             Count the trailing zero digits of MB.

      DO J = N1, 2, -1
         IF (MWK(START(MB)+J+1) /= 0) THEN
             NZDMB = N1 - J
             GO TO 110
         ENDIF
      ENDDO

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.  It is used
!             to determine whether normalization can be postponed.

  110 MAXMWA = 0

!             KPTMWA points to the next digit in the quotient.

      KPTMWA = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in estimating quotient digits.

  120 KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMWA+1))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMWA+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQD is the estimated quotient digit.

      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1

      IF (MQD > 0) THEN
          MAXMWA = MAXMWA + MQD
      ELSE
          MAXMWA = MAXMWA - MQD
      ENDIF

!             See if MWA must be normalized.

      KA = KPTMWA + 1
      KB = MIN(KA+NDIG-1-NZDMB,NL)
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          IF (KL <= NL) THEN
              DO J = KPTMWA, KL
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
              ENDDO
          ELSE
              DO J = KPTMWA, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQD = AINT(XMWA*XBR)
          IF (MQD < 0) MQD = MQD - 1
          IF (MQD > 0) THEN
              MAXMWA = MQD
          ELSE
              MAXMWA = -MQD
          ENDIF
      ENDIF

!             Subtract MQD*MB from MWA.

      JB = KA - 2
      IF (MQD /= 0) THEN

!             Major (Inner Loop)

          JMB = START(MB) + 1 - JB
          JMWA = START(MWA) + 1
          DO J = KA, KB
             MWK(JMWA+J) = MWK(JMWA+J) - MQD*MWK(JMB+J)
          ENDDO
      ENDIF

      MWK(START(MWA)+KA+1) = MWK(START(MWA)+KA+1) + MWK(START(MWA)+KA)*MBASE
      MWK(START(MWA)+KPTMWA+1) = MQD

      KPTMWA = KPTMWA + 1
      IF (KPTMWA <= NG) GO TO 120
      IF (MWK(START(MWA)+3) == 0 .AND. KPTMWA <= NG+1) GO TO 120

      KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMWA+1))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMWA+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF
      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1
      MWK(START(MWA)+KPTMWA+1) = MQD
      MWK(START(MWA)+KPTMWA+2) = 0
      MWK(START(MWA)+KPTMWA+3) = 0

!             Final normalization.

      IF (KPTMWA > 2*NDIG) THEN
          DO J = 2*NDIG+1, KPTMWA
             IF (MWK(START(MWA)+J+1) /= MBASE-1) EXIT
             IF (J == KPTMWA) MWK(START(MWA)+J+1) = MBASE
          ENDDO
      ENDIF
      DO J = KPTMWA, 3, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
      ENDDO

      RETURN
      END SUBROUTINE FMDIV3

      SUBROUTINE FMDIVD(MA,MB,MC,MD,ME)

!  Double division routine.  MD = MA / MC,   ME = MB / MC

!  It is usually slightly faster to do two divisions that have a common denominator with one call.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD,ME

      REAL (KIND(1.0D0)) :: MA2P,MACCA,MACCB,MACCC,MAS,MAXMWA,MB2P,MBS,MBM1,MC2P,MCARRY,MCS,MD2B,  &
                            MKT,MLMAX,MLR,MQDMWA,MQDMWD,MTEMP
      DOUBLE PRECISION :: ERR,XB,XBR,XBASE,XMWA,XMWD
      INTEGER :: J,JB,JL,JMC,JMWA,JMWD,JRSSAV,KA,KB,KL,KOVUN,KPTMW,N1,NG,NGUARD,NL,  &
                 NMBWDS,NZDMB
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD,ME
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MD <= 0) THEN
          CALL FMDEFINE(MD)
      ELSE IF (SIZE_OF(MD) < NDIG+3) THEN
          CALL FMDEFINE(MD)
      ENDIF
      IF (ME <= 0) THEN
          CALL FMDEFINE(ME)
      ELSE IF (SIZE_OF(ME) < NDIG+3) THEN
          CALL FMDEFINE(ME)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      IF (MWD <= 0) THEN
          CALL FMDEFINE(MWD)
      ELSE IF (SIZE_OF(MWD) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWD)
      ENDIF

      NCALL = NCALL + 1
      JRSSAV = JRSIGN
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIVD'
          CALL FMNTR(2,MA,MB,2,1)
          IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MC,NDIG)
              ELSE
                  CALL FMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      MACCC = MWK(START(MC)+1)
      IF (NDIG >= 2200 .OR.                                                      &
          ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MC)+2)) > MEXPAB .OR. MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN .OR.  &
              MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN .OR.  &
              MWK(START(MC)+2) == MEXPOV .OR. MWK(START(MC)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
              MWK(START(MC)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL FMDIV2(MA,MC,MWD)
          KB = KFLAG
          CALL FMDIV2(MB,MC,ME)
          NCALL = NCALL - 1
          IF (((KFLAG < 0 .OR. KB < 0) .AND. KOVUN == 0) .OR.  &
              ((KFLAG == -4 .OR. KB == -4) .AND. KOVUN == 1)) THEN
              IF (KFLAG == -4 .OR. KB == -4) THEN
                  KFLAG = -4
              ELSE IF (KFLAG == -5 .OR. KB == -5) THEN
                  KFLAG = -5
              ELSE
                  KFLAG = MIN(KFLAG,KB)
              ENDIF
              NAMEST(NCALL) = 'FMDIVD'
              CALL FMWARN
          ENDIF
          CALL FMEQ(MWD,MD)
          GO TO 150
      ENDIF
      IF (MWK(START(MC)+3) == 0) THEN
          NAMEST(NCALL) = 'FMDIVD'
          KFLAG = -4
          CALL FMWARN
          CALL FMST2M('UNKNOWN',MD)
          CALL FMST2M('UNKNOWN',ME)
          GO TO 150
      ENDIF
      IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          CALL FMDIV2(MA,MC,MWD)
          CALL FMDIV2(MB,MC,ME)
          CALL FMEQ(MWD,MD)
          GO TO 150
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

      IF (NCALL > 1) THEN
          NGUARD = NGRD21
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52 - 1
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10
      MA2P = ABS(MWK(START(MA)+3))
      MB2P = ABS(MWK(START(MB)+3))
      MC2P = ABS(MWK(START(MC)+3))
      IF ((MC2P >= MA2P .OR. MC2P >= MB2P) .AND. NGUARD < 2) NGUARD = 2
      N1 = NDIG + 1
      NG = NDIG + NGUARD

!             Copy MA and MB into the working arrays.

      DO J = 3, N1
         MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
         MWK(START(MWD)+J+2) = MWK(START(MB)+J+1)
      ENDDO
      MWK(START(MWA)+2) = MWK(START(MA)+2) - MWK(START(MC)+2) + 1
      MWK(START(MWD)+2) = MWK(START(MB)+2) - MWK(START(MC)+2) + 1
      MWK(START(MWA)+3) = 0
      MWK(START(MWD)+3) = 0
      NL = N1 + NGUARD + 3
      DO J = NDIG+3, NL
         MWK(START(MWA)+J+1) = 0
         MWK(START(MWD)+J+1) = 0
      ENDDO

!             Save the signs and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      MCS = MWK(START(MC))
      MWK(START(MWA)+4) = MWK(START(MA)+3)
      MWK(START(MWD)+4) = MWK(START(MB)+3)

!             NMBWDS is the number of words used to compute the estimated quotient digits.

      NMBWDS = 4
      IF (MBASE < 100) NMBWDS = 7

!             XB is an approximation of MC used in selecting estimated quotients.

      XBASE = DBLE(MBASE)
      XB = 0
      JL = NMBWDS
      IF (JL <= N1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MWK(START(MC)+J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= N1) THEN
                 XB = XB*XBASE + DBLE(MWK(START(MC)+J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= N1) XB = XB + DBLE(MWK(START(MC)+JL+2))/XBASE
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBM1 = MBASE - 1
      MLMAX = MAXINT/MBM1
      MKT = INTMAX - MBASE
      MLMAX = MIN(MLMAX,MKT)

!             Count the trailing zero digits of MC.

      DO J = N1, 2, -1
         IF (MWK(START(MC)+J+1) /= 0) THEN
             NZDMB = N1 - J
             GO TO 110
         ENDIF
      ENDDO

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.  It is used
!             to determine whether normalization can be postponed.

  110 MAXMWA = 0

!             KPTMW points to the next digit in the quotient.

      KPTMW = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in selecting estimated
!             quotients.

  120 KL = KPTMW + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMW+1))*XBASE + DBLE(MWK(START(MWA)+KPTMW+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMW+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMW+4))
          XMWD = ((DBLE(MWK(START(MWD)+KPTMW+1))*XBASE + DBLE(MWK(START(MWD)+KPTMW+2)))*XBASE  &
                 + DBLE(MWK(START(MWD)+KPTMW+3)))*XBASE + DBLE(MWK(START(MWD)+KPTMW+4))
          DO J = KPTMW+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMW+1))
          XMWD = DBLE(MWK(START(MWD)+KPTMW+1))
          DO J = KPTMW+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
                 XMWD = XMWD*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQDMWA and MQDMWD are the estimated quotient digits.

      MQDMWA = AINT(XMWA*XBR)
      IF (MQDMWA < 0) MQDMWA = MQDMWA - 1
      MQDMWD = AINT(XMWD*XBR)
      IF (MQDMWD < 0) MQDMWD = MQDMWD - 1

      MAXMWA = MAXMWA + MAX(ABS(MQDMWA),ABS(MQDMWD))

!             See if MWA and MWD must be normalized.

      KA = KPTMW + 1
      KB = MIN(KA+NDIG-1-NZDMB,NL)
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ENDIF
             IF (MWK(START(MWD)+J+1) < 0) THEN
                 MCARRY = INT((-MWK(START(MWD)+J+1)-1)/MBASE) + 1
                 MWK(START(MWD)+J+1) = MWK(START(MWD)+J+1) + MCARRY*MBASE
                 MWK(START(MWD)+J) = MWK(START(MWD)+J) - MCARRY
             ELSE IF (MWK(START(MWD)+J+1) >= MBASE) THEN
                 MCARRY = -INT(MWK(START(MWD)+J+1)/MBASE)
                 MWK(START(MWD)+J+1) = MWK(START(MWD)+J+1) + MCARRY*MBASE
                 MWK(START(MWD)+J) = MWK(START(MWD)+J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          XMWD = 0
          IF (KL <= NL) THEN
              DO J = KPTMW, KL
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
              ENDDO
          ELSE
              DO J = KPTMW, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                     XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                     XMWD = XMWD*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQDMWA = AINT(XMWA*XBR)
          IF (MQDMWA < 0) MQDMWA = MQDMWA - 1
          MQDMWD = AINT(XMWD*XBR)
          IF (MQDMWD < 0) MQDMWD = MQDMWD - 1
          MAXMWA = MAX(ABS(MQDMWA),ABS(MQDMWD))
      ENDIF

!             Subtract MQDMWA*MC from MWA and MQDMWD*MC from MWD.

      JB = KA - 2

!             Major (Inner Loop)

      JMC = START(MC) + 1 - JB
      JMWA = START(MWA) + 1
      JMWD = START(MWD) + 1
      DO J = KA, KB
         MTEMP = MWK(JMC+J)
         MWK(JMWA+J) = MWK(JMWA+J) - MQDMWA*MTEMP
         MWK(JMWD+J) = MWK(JMWD+J) - MQDMWD*MTEMP
      ENDDO

      MWK(START(MWA)+KA+1) = MWK(START(MWA)+KA+1) + MWK(START(MWA)+KA)*MBASE
      MWK(START(MWD)+KA+1) = MWK(START(MWD)+KA+1) + MWK(START(MWD)+KA)*MBASE
      MWK(START(MWA)+KPTMW+1) = MQDMWA
      MWK(START(MWD)+KPTMW+1) = MQDMWD

      KPTMW = KPTMW + 1
      IF (KPTMW <= NG) GO TO 120

      KL = KPTMW + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMW+1))*XBASE + DBLE(MWK(START(MWA)+KPTMW+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMW+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMW+4))
          XMWD = ((DBLE(MWK(START(MWD)+KPTMW+1))*XBASE + DBLE(MWK(START(MWD)+KPTMW+2)))*XBASE  &
                 + DBLE(MWK(START(MWD)+KPTMW+3)))*XBASE + DBLE(MWK(START(MWD)+KPTMW+4))
          DO J = KPTMW+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMW+1))
          XMWD = DBLE(MWK(START(MWD)+KPTMW+1))
          DO J = KPTMW+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 XMWD = XMWD*XBASE + DBLE(MWK(START(MWD)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
                 XMWD = XMWD*XBASE
             ENDIF
          ENDDO
      ENDIF
      MQDMWA = AINT(XMWA*XBR)
      IF (MQDMWA < 0) MQDMWA = MQDMWA - 1
      MQDMWD = AINT(XMWD*XBR)
      IF (MQDMWD < 0) MQDMWD = MQDMWD - 1
      MWK(START(MWA)+KPTMW+1) = MQDMWA
      MWK(START(MWA)+KPTMW+2) = 0
      MWK(START(MWA)+KPTMW+3) = 0
      MWK(START(MWD)+KPTMW+1) = MQDMWD
      MWK(START(MWD)+KPTMW+2) = 0
      MWK(START(MWD)+KPTMW+3) = 0

!             Final normalization.

      DO J = KPTMW-1, 3, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
         IF (MWK(START(MWD)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWD)+J+1)-1)/MBASE) + 1
             MWK(START(MWD)+J+1) = MWK(START(MWD)+J+1) + MCARRY*MBASE
             MWK(START(MWD)+J) = MWK(START(MWD)+J) - MCARRY
         ELSE IF (MWK(START(MWD)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWD)+J+1)/MBASE)
             MWK(START(MWD)+J+1) = MWK(START(MWD)+J+1) + MCARRY*MBASE
             MWK(START(MWD)+J) = MWK(START(MWD)+J) - MCARRY
         ENDIF
      ENDDO

!             Round, affix the sign, and return.

      IF ((MAS > 0 .AND. MCS > 0) .OR. (MAS < 0 .AND. MCS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWA)+3) == 0) THEN
          IF (NCALL == 1) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+3)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MA,MC,MD)
                  GO TO 130
              ENDIF
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          IF (NCALL == 1) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MA,MC,MD)
                  GO TO 130
              ENDIF
          ENDIF
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,NGUARD,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MD)

  130 IF ((MBS > 0 .AND. MCS > 0) .OR. (MBS < 0 .AND. MCS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWD)+3) == 0) THEN
          IF (NCALL == 1) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWD)+J+NDIG+3)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MB,MC,ME)
                  GO TO 140
              ENDIF
          ENDIF
          MLR = 2*MWK(START(MWD)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWD,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWD)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWD)+N1+2) = MWK(START(MWD)+N1+2) + 1
                      MWK(START(MWD)+N1+3) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWD,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          IF (NCALL == 1) THEN
              KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
              ERR = 0
              DO J = KL, 1, -1
                 ERR = (ERR + MWK(START(MWD)+J+NDIG+2)) / MBASE
              ENDDO
              IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
                   (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
                  CALL FMDIV2(MB,MC,ME)
                  GO TO 140
              ENDIF
          ENDIF
          MLR = 2*MWK(START(MWD)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWD,NDIG,NGUARD,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWD)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWD)+N1+1) = MWK(START(MWD)+N1+1) + 1
                      MWK(START(MWD)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWD,NDIG,NGUARD,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWD,ME)

  140 IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIVD'
          CALL FMWARN
      ENDIF

      MWK(START(MD)) = 1
      IF (MAS*MCS < 0 .AND. MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0)  &
          MWK(START(MD)) = -1
      MWK(START(ME)) = 1
      IF (MBS*MCS < 0 .AND. MWK(START(ME)+2) /= MUNKNO .AND. MWK(START(ME)+3) /= 0)  &
          MWK(START(ME)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MD)+3))+1))/0.69315)
          MWK(START(MD)+1) = MIN(MACCA,MACCC,MD2B)
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(ME)+3))+1))/0.69315)
          MWK(START(ME)+1) = MIN(MACCB,MACCC,MD2B)
      ELSE
          MWK(START(MD)+1) = MIN(MACCA,MACCC)
          MWK(START(ME)+1) = MIN(MACCB,MACCC)
      ENDIF

  150 IF (NTRACE /= 0) THEN
          CALL FMNTR(1,MD,MD,1,1)
          IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(ME,NDIG)
              ELSE
                  CALL FMPRNT(ME)
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          IF (TEMPV(ME) == -1) TEMPV(ME) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVD

      SUBROUTINE FMDIVFFT(MB)
      USE FMVALS
      IMPLICIT NONE

!  Internal division routine MA/MB for very high precision.
!  MA has already been moved to MWA before this routine is called.
!  Fast Fourier transforms are used, and the number of digits carried is usually
!  raised slightly, because the FFT is faster when N has only small prime factors.

      INTEGER :: MB
      INTENT (IN) :: MB
      DOUBLE PRECISION :: XB
      REAL (KIND(1.0D0)) :: MWA1
      INTEGER :: J,K,KST,ND2,NDSAVE,NSTACK(49)
      INTEGER :: MXY(10),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      NDSAVE = NDIG

!             Save low precision copies of the numerator and denominator.

      NDIG = 20
      CALL FMIM(1,MXY(7))
      DO J = 1, SIZE_OF(MXY(7))-3
         MWK(START(MXY(7))+J+2) = MWK(START(MWA)+J+3)
      ENDDO
      MWK(START(MXY(7))+2) = MWK(START(MWA)+2) + MWK(START(MB)+2) - 1
      CALL FMEQU(MB,MXY(8),NDSAVE,20)
      NDIG = NDSAVE

!             Use Newton iteration and the routine FMMPYFFT, with the formula
!                 x = x + x*(1 - b*x)
!             to converge to 1/b.

      K = MAX(NGRD52-1,2)
      NDIG = MAX(NDIG+K,2)

!             Generate the first approximation.

      CALL FMIM(1,MXY(1))
      DO J = 1, NDSAVE
         MWK(START(MXY(1))+J+2) = MWK(START(MWA)+J+3)
      ENDDO
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(1))+2) = 0
      MWK(START(MXY(2))) = 1
      MWK(START(MXY(2))+2) = 0
      KST = MWK(START(MWA)+2)

!             FMADD2 will negate MXY(2) and add.

      KSUB = 1
      CALL FMADD2(MXY(1),MXY(2),MXY(3))
      KSUB = 0
      IF (MWK(START(MXY(3))) >= 0) THEN
          MWA1 = KST
      ELSE
          MWA1 = KST - 1
      ENDIF
      CALL FMMD(MXY(2),XB)
      XB = 1.0D0/XB
      CALL FMDM(XB,MXY(3))

!             Initialize.

      CALL FMIM(0,MXY(4))
      CALL FMIM(0,MXY(5))
      CALL FMIM(1,MXY(6))
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST-1
         NDIG = NSTACK(J)
         CALL FMMPY2(MXY(2),MXY(3),MXY(4))
         KSUB = 1
         CALL FMADD2_R2(MXY(6),MXY(4))
         KSUB = 0
         NDIG = NSTACK(MAX(1,J-1))
         CALL FMMPY2(MXY(3),MXY(4),MXY(5))
         NDIG = NSTACK(J)
         CALL FMADD2_R1(MXY(3),MXY(5))
      ENDDO

!             Karp's trick:
!             The standard last step would give 1/b and then a final full precision
!             multiply by a would be done.  That does 2 full mpy's at the final precision,
!             and one at next-to-last (1/2 of final) precision.

!             Instead combine the a* step into the last iteration and get
!             y = a*x   at 1/2 precision, then
!             y = y + x*(a - b*y)
!             where the x* mpy is at 1/2 precision and only b*y is at final precision.

      NDIG = NSTACK(MAX(1,KST-1))
      CALL FMMPY2(MXY(1),MXY(3),MXY(4))
      NDIG = NSTACK(KST)
      CALL FMMPY2(MXY(2),MXY(4),MXY(5))
      KSUB = 1
      CALL FMADD2(MXY(1),MXY(5),MXY(6))
      KSUB = 0
      NDIG = NSTACK(MAX(1,KST-1))
      CALL FMMPY2(MXY(3),MXY(6),MXY(5))
      NDIG = NSTACK(KST)
      CALL FMADD2(MXY(4),MXY(5),MXY(6))

      MWK(START(MXY(6))+2) = MWA1

!             Because of rounding errors in the Newton iteration, if the quotient is very close
!             to a power of MBASE the exponent of the result might be off by one.
!             Check by doing low precision multiplications.

      ND2 = NDIG
      MWK(START(MXY(7))) = -1
      MWK(START(MXY(8))) = 1
      CALL FMEQU(MXY(6),MXY(4),NDSAVE,20)
      MWK(START(MXY(4))) = 1
      NDIG = 20
      CALL FMMPY2(MXY(8),MXY(4),MXY(5))
      CALL FMADD2(MXY(5),MXY(7),MXY(9))
      MWK(START(MXY(9))) = 1
      MWK(START(MXY(4))+2) = MWK(START(MXY(4))+2) + 1
      CALL FMMPY2(MXY(8),MXY(4),MXY(5))
      CALL FMADD2(MXY(5),MXY(7),MXY(10))
      IF (MWK(START(MXY(10))+3) /= 0) MWK(START(MXY(10))) = -1
      CALL FMADD2(MXY(10),MXY(9),MXY(5))
      IF (MWK(START(MXY(5))) == 1) THEN
          CALL FMEQ(MXY(10),MXY(9))
          MWK(START(MXY(6))+2) = MWK(START(MXY(6))+2) + 1
      ENDIF
      MWK(START(MXY(4))+2) = MWK(START(MXY(4))+2) - 2
      CALL FMMPY2(MXY(8),MXY(4),MXY(5))
      CALL FMADD2(MXY(5),MXY(7),MXY(10))
      IF (MWK(START(MXY(10))+3) /= 0) MWK(START(MXY(10))) = -1
      CALL FMADD2(MXY(10),MXY(9),MXY(5))
      IF (MWK(START(MXY(5))) == 1) THEN
          MWK(START(MXY(6))+2) = MWK(START(MXY(6))+2) - 1
      ENDIF
      NDIG = ND2

      CALL FMEQ(MXY(6),MWA)
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVFFT

      SUBROUTINE FMDIVI(MA,IVAL,MB)

!  MB = MA / IVAL

!  Divide FM number MA by one word integer IVAL.

!  This routine is faster than FMDIV when the divisor is less than MXBASE (the square root of the
!  largest integer).
!  When IVAL is not less than MXBASE, FMDIV2 is used.  In this case, if IVAL is known to be a
!  product of two integers less than MXBASE, it is usually faster to make two calls to FMDIVI
!  with half-word factors than one call with their product.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MD2B
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      MACCA = MWK(START(MA)+1)
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIVI'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
          CALL FMDIVN(MA,IVAL,MB)
          IF (KACCSW == 1) THEN
              MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
              MWK(START(MB)+1) = MIN(MACCA,MD2B)
          ELSE
              MWK(START(MB)+1) = MACCA
          ENDIF
          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMDIVN(MA,IVAL,MB)
          IF (KACCSW == 1) THEN
              MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
              MWK(START(MB)+1) = MIN(MACCA,MD2B)
          ELSE
              MWK(START(MB)+1) = MACCA
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVI

      SUBROUTINE FMDIVI_R1(MA,IVAL)

!  MA = MA / IVAL

!  Divide FM number MA by one word integer IVAL.

!  This routine is faster than FMDIV when the divisor is less than MXBASE (the square root of the
!  largest integer).
!  When IVAL is not less than MXBASE, FMDIV2 is used.  In this case, if IVAL is known to be a
!  product of two integers less than MXBASE, it is usually faster to make two calls to FMDIVI
!  with half-word factors than one call with their product.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MD2B
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      MACCA = MWK(START(MA)+1)
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMDIVI_R1'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
          CALL FMDIVN_R1(MA,IVAL)
          IF (KACCSW == 1) THEN
              MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
              MWK(START(MA)+1) = MIN(MACCA,MD2B)
          ELSE
              MWK(START(MA)+1) = MACCA
          ENDIF
          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMDIVN_R1(MA,IVAL)
          IF (KACCSW == 1) THEN
              MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
              MWK(START(MA)+1) = MIN(MACCA,MD2B)
          ELSE
              MWK(START(MA)+1) = MACCA
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVI_R1

      SUBROUTINE FMDIVN(MA,IVAL,MB)

!  Internal divide by integer routine.  MB = MA / IVAL

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MA1,MAS,MKT,MLR,MODINT,MVALP
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JMA,JMWA,JRSSAV,KA,KB,KL,KPT,KPTWA,KR_RETRY,N1,NGUARD,NMVAL,NV2
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      KR_RETRY = 0

!             Check for special cases.

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      N1 = NDIG + 1
      IF (MWK(START(MA)+2) == MUNKNO .OR. IVAL == 0) THEN
          MA1 = MWK(START(MA)+2)
          CALL FMIM(0,MB)
          MWK(START(MB)+1) = NINT(10**7*ALOGM2)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          KFLAG = -4
          IF (MA1 /= MUNKNO) THEN
              NAMEST(NCALL) = 'FMDIVI'
              CALL FMWARN
          ENDIF
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(MWK(START(MA)+2)) < MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (ABS(IVAL) == 1) THEN
          DO J = 0, N1
             MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
          ENDDO
          MWK(START(MB)) = MWK(START(MA))*IVAL
          IF (MWK(START(MA)+2) == MEXPOV) KFLAG = -5
          IF (MWK(START(MA)+2) == MEXPUN) KFLAG = -6
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          MAS = MWK(START(MA))
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MEXPUN
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MWK(START(MB)) = -1
          KFLAG = -6
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          NAMEST(NCALL) = 'FMDIVI'
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          KFLAG = -4
          CALL FMWARN
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
      ELSE
          NGUARD = NGRD52
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10

!             If ABS(IVAL) >= MXBASE use FMDIV.

      MVALP = ABS(IVAL)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1))
          CALL FMDIV2(MA,MXY(1),MB)
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Work with positive numbers.

      MAS = MWK(START(MA))

!             Find the first significant digit of the quotient.

      MKT = MWK(START(MA)+3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 130
      ENDIF
      DO J = 3, N1
         MKT = MKT*MBASE + MWK(START(MA)+J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 130
         ENDIF
      ENDDO
      KPT = N1

  120 KPT = KPT + 1
      MKT = MKT*MBASE
      IF (MKT < MVALP) GO TO 120

!             Do the rest of the division.

  130 KA = KPT + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + 2 - KPT
      MWK(START(MWA)+3) = INT (MKT/MVALP)
      MODINT = MKT - MWK(START(MWA)+3)*MVALP
      KPTWA = 2
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1 + KL
          DO J = KA, N1
             MKT = MODINT*MBASE + MWK(JMA+J)
             MWK(JMWA+J) = INT (MKT/MVALP)
             MODINT = MKT - MWK(JMWA+J)*MVALP
          ENDDO
          KPTWA = KL + N1
      ENDIF

      KA = KPTWA + 1
      KB = N1 + NGUARD
      DO J = KA, KB
         MKT = MODINT*MBASE
         MWK(START(MWA)+J+1) = INT (MKT/MVALP)
         MODINT = MKT - MWK(START(MWA)+J+1)*MVALP
      ENDDO

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Round the result, put the sign on MB and return.

      MLR = 2*MWK(START(MWA)+NDIG+3) + 1
      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,0)
      ELSE IF (MLR >= MBASE) THEN
          IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                  MWK(START(MWA)+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIVI'
          CALL FMWARN
      ENDIF
      MWK(START(MB)) = JRSIGN
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVN

      SUBROUTINE FMDIVN_R1(MA,IVAL)

!  Internal divide by integer routine.  MA = MA / IVAL

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MA1,MAS,MKT,MLR,MODINT,MVALP
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JMA,JMWA,JRSSAV,KA,KB,KL,KPT,KPTWA,KR_RETRY,N1,NGUARD,NMVAL,NV2
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      KR_RETRY = 0

!             Check for special cases.

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      N1 = NDIG + 1
      IF (MWK(START(MA)+2) == MUNKNO .OR. IVAL == 0) THEN
          MA1 = MWK(START(MA)+2)
          CALL FMIM(0,MA)
          MWK(START(MA)+1) = NINT(10**7*ALOGM2)
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          KFLAG = -4
          IF (MA1 /= MUNKNO) THEN
              NAMEST(NCALL) = 'FMDIVI_R1'
              CALL FMWARN
          ENDIF
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(MWK(START(MA)+2)) < MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (ABS(IVAL) == 1) THEN
          MWK(START(MA)) = MWK(START(MA))*IVAL
          IF (MWK(START(MA)+2) == MEXPOV) KFLAG = -5
          IF (MWK(START(MA)+2) == MEXPUN) KFLAG = -6
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          MAS = MWK(START(MA))
          CALL FMIM(0,MA)
          MWK(START(MA)+2) = MEXPUN
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MWK(START(MA)) = -1
          KFLAG = -6
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          NAMEST(NCALL) = 'FMDIVI_R1'
          CALL FMIM(0,MA)
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          KFLAG = -4
          CALL FMWARN
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD21
      ELSE
          NGUARD = NGRD52
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 10
          ENDIF
      ENDIF
      IF (NGUARD > NDIG+10) NGUARD = NDIG + 10

!             If ABS(IVAL) >= MXBASE use FMDIV.

      MVALP = ABS(IVAL)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1))
          CALL FMDIV2_R1(MA,MXY(1))
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Work with positive numbers.

      MAS = MWK(START(MA))

!             Find the first significant digit of the quotient.

      MKT = MWK(START(MA)+3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 130
      ENDIF
      DO J = 3, N1
         MKT = MKT*MBASE + MWK(START(MA)+J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 130
         ENDIF
      ENDDO
      KPT = N1

  120 KPT = KPT + 1
      MKT = MKT*MBASE
      IF (MKT < MVALP) GO TO 120

!             Do the rest of the division.

  130 KA = KPT + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + 2 - KPT
      MWK(START(MWA)+3) = INT (MKT/MVALP)
      MODINT = MKT - MWK(START(MWA)+3)*MVALP
      KPTWA = 2
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1 + KL
          DO J = KA, N1
             MKT = MODINT*MBASE + MWK(JMA+J)
             MWK(JMWA+J) = INT (MKT/MVALP)
             MODINT = MKT - MWK(JMWA+J)*MVALP
          ENDDO
          KPTWA = KL + N1
      ENDIF

      KA = KPTWA + 1
      KB = N1 + NGUARD
      DO J = KA, KB
         MKT = MODINT*MBASE
         MWK(START(MWA)+J+1) = INT (MKT/MVALP)
         MODINT = MKT - MWK(START(MWA)+J+1)*MVALP
      ENDDO

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Round the result, put the sign on MA and return.

      MLR = 2*MWK(START(MWA)+NDIG+3) + 1
      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,0)
      ELSE IF (MLR >= MBASE) THEN
          IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                  MWK(START(MWA)+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,0)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMDIVI_R1'
          CALL FMWARN
      ENDIF
      MWK(START(MA)) = JRSIGN
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDIVN_R1

      SUBROUTINE FMDM(X,MA)

!  Internal routine for converting double precision to multiple precision.  Called by FMDPM.

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      INTEGER :: MA

      DOUBLE PRECISION :: ONE,XBASE,Y,Y2,YT
      REAL (KIND(1.0D0)) :: MK,MN
      INTEGER :: J,K,N1,NE
      INTENT (IN) :: X
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      N1 = NDIG + 1

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (EXPONENT(X) > EXPONENT(HUGE(X))) THEN
          DO J = 2, NDIG
             MWK(START(MA)+J+2) = 0
          ENDDO
          KFLAG = -4
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          MWK(START(MA)) = 1
          CALL FMWARN
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      ONE = 1.0D0
      XBASE = MBASE
      K = 0

!             NE-1 is the number of words at the current precision and base roughly equal to
!             machine precision.

      NE = INT(DLOGEB) + 3
      Y = X
      IF (X < 0.0) Y = -X

      IF (X == 0.0) THEN
          DO J = 1, N1
             MWK(START(MA)+J+1) = 0
          ENDDO
          GO TO 160
      ENDIF

!             Get the exponent.

      IF (Y > ONE) THEN
          IF (Y/XBASE < Y) THEN
  110         K = K + 1
              Y = Y/XBASE
              IF (Y > ONE) GO TO 110
              IF (Y < ONE) THEN
                  MWK(START(MA)+2) = K
                  GO TO 140
              ENDIF
              GO TO 130
          ELSE
              KFLAG = -4
              CALL FMWARN
              DO J = 1, N1
                 MWK(START(MA)+J+1) = 0
              ENDDO
              MWK(START(MA)+2) = MUNKNO
              MWK(START(MA)+3) = 1
              MWK(START(MA)) = 1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

      IF (Y < ONE) THEN
          IF (Y*XBASE > Y) THEN
  120         K = K - 1
              Y = Y*XBASE
              IF (Y < ONE) GO TO 120
              IF (Y > ONE) THEN
                  K = K + 1
                  Y = Y/XBASE
                  MWK(START(MA)+2) = K
                  GO TO 140
              ENDIF
          ELSE
              KFLAG = -4
              CALL FMWARN
              DO J = 1, N1
                 MWK(START(MA)+J+1) = 0
              ENDDO
              MWK(START(MA)+2) = MUNKNO
              MWK(START(MA)+3) = 1
              MWK(START(MA)) = 1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

  130 MWK(START(MA)+2) = K + 1
      MWK(START(MA)+3) = 1
      DO J = 3, N1
         MWK(START(MA)+J+1) = 0
      ENDDO
      GO TO 160

!             Build the rest of the number.

  140 DO J = 2, NE
         Y = Y*XBASE
         MK = AINT(Y)
         YT = -MK
         CALL FMDBL(Y,YT,Y2)
         Y = Y2
         MWK(START(MA)+J+1) = MK
         IF (J >= N1) GO TO 150
      ENDDO
      K = NE + 1
      DO J = K, N1
         MWK(START(MA)+J+1) = 0
      ENDDO

!             Normalize.

  150 IF (ABS(MWK(START(MA)+3)) >= MBASE) THEN
          K = N1 + 1
          DO J = 3, N1
             K = K - 1
             MWK(START(MA)+K+1) = MWK(START(MA)+K)
          ENDDO
          MN = AINT (MWK(START(MA)+3)/MBASE)
          MWK(START(MA)+4) = MWK(START(MA)+3) - MN*MBASE
          MWK(START(MA)+3) = MN
          MWK(START(MA)+2) = MWK(START(MA)+2) + 1
          GO TO 160
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          DO J = 2, NDIG
             MWK(START(MA)+J+1) = MWK(START(MA)+J+2)
          ENDDO
          MWK(START(MA)+2) = MWK(START(MA)+2) - 1
          MWK(START(MA)+N1+1) = 0
      ENDIF

  160 MWK(START(MA)) = 1
      IF (X < 0.0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1
      MWK(START(MA)+1) = MIN(NINT((NE-1)*ALOGM2),NINT(NDIG*ALOGM2))
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDM

      SUBROUTINE FMDM2(X,MA)

!  Internal routine for converting double precision to multiple precision.  Called by FMDP2M.

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      INTEGER :: MA
      DOUBLE PRECISION :: F1,F2,Y,Y1,Y2,TWO20
      INTEGER :: J,J1,J2,JD,JEXP,K,KEXP,L,NDSAVE
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD21,1)
          NDIG = MAX(NDIG+K,2)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0

!             Special case for X = 0.

      IF (X == 0.0D0) THEN
          DO J = 1, NDSAVE+1
             MWK(START(MA)+J+1) = 0
          ENDDO
          GO TO 140
      ENDIF

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (EXPONENT(X) > EXPONENT(HUGE(X))) THEN
          DO J = 2, NDSAVE
             MWK(START(MA)+J+2) = 0
          ENDDO
          KFLAG = -4
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDSAVE*ALOGM2)
          MWK(START(MA)) = 1
          CALL FMWARN
          NDIG = NDSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Special case for MBASE = 2.

      IF (MBASE == 2 .AND. RADIX(X) == 2) THEN
          NDIG = MAX(NDIG,DIGITS(X))
          Y = FRACTION(ABS(X))
          CALL FMI2M(0,MXY(5))
          DO J = 1, MIN(DIGITS(X),NDIG)
             Y = Y + Y
             MWK(START(MXY(5))+J+2) = INT(Y)
             Y = Y - INT(Y)
          ENDDO
          MWK(START(MXY(5))+2) = EXPONENT(X)
          CALL FMEQU(MXY(5),MA,NDIG,NDSAVE)
          GO TO 140
      ENDIF

!             Special case for MBASE = 10**L.

      K = MBASE
      L = 0
      DO
         IF (MOD(K,10) == 0) THEN
             L = L + 1
             K = K/10
             IF (K == 1) EXIT
         ELSE
             L = 0
             EXIT
         ENDIF
      ENDDO
      IF (L > 0) THEN
          NDIG = MAX(NDIG,INT(DIGITS(X)*0.30103/L)+1)
          Y = FRACTION(ABS(X))
          CALL FMI2M(0,MXY(5))
          DO J = 1, NDIG

!             Multiply by 10**L to get the next digit in base MBASE.
!             To avoid any rounding errors in double precision, do each multiply by 10 as
!             one multiply by 8 and one by 2, and keep two integer and two fraction results.
!             So 10*y is broken into 8*y + 2*y, since there will be no rounding with either
!             term in double precision on a binary machine.

             JD = 0
             DO K = 1, L
                Y1 = 8*Y
                Y2 = 2*Y
                J1 = Y1
                J2 = Y2
                F1 = Y1 - J1
                F2 = Y2 - J2
                JD = 10*JD + J1 + J2
                Y = F1 + F2
                IF (Y >= 1.0D0) THEN
                    JD = JD + 1
                    Y = Y - 1
                ENDIF
             ENDDO
             MWK(START(MXY(5))+J+2) = JD
             IF (Y == 0) EXIT
          ENDDO
          K = INTMAX
          IF (MAXINT/MBASE < K) K = MAXINT/MBASE
          K = K/2
          J2 = 1
          JEXP = EXPONENT(X)
          DO J = 1, ABS(JEXP)
             J2 = 2*J2
             IF (J2 >= K .OR. J == ABS(JEXP)) THEN
                 IF (JEXP > 0) THEN
                     CALL FMMPYI_R1(MXY(5),J2)
                 ELSE
                     CALL FMDIVI_R1(MXY(5),J2)
                 ENDIF
                 J2 = 1
             ENDIF
          ENDDO
          CALL FMEQU(MXY(5),MA,NDIG,NDSAVE)
          GO TO 140
      ENDIF

      Y = ABS(X)
      TWO20 = 1048576.0D0

!             If this power of two is not representable at the current base and precision, use a
!             smaller one.

      IF (INT(NDIG*ALOGM2) < 20) THEN
          K = INT(NDIG*ALOGM2)
          TWO20 = 1.0D0
          DO J = 1, K
             TWO20 = TWO20*2.0D0
          ENDDO
      ENDIF

      KEXP = 0
      IF (Y > TWO20) THEN
  110     Y = Y/TWO20
          KEXP = KEXP + 1
          IF (Y > TWO20) GO TO 110
      ELSE IF (Y < 1.0D0) THEN
  120     Y = Y*TWO20
          KEXP = KEXP - 1
          IF (Y < 1.0D0) GO TO 120
      ENDIF

      K = INT(TWO20)
      CALL FMI2M(K,MXY(3))
      K = INT(Y)
      CALL FMI2M(K,MXY(1))
      Y = (Y-DBLE(K))*TWO20
      JEXP = 0

  130 K = INT(Y)
      CALL FMI2M(K,MXY(2))
      CALL FMMPY_R1(MXY(1),MXY(3))
      JEXP = JEXP + 1
      CALL FMADD_R1(MXY(1),MXY(2))
      Y = (Y-DBLE(K))*TWO20
      IF (JEXP <= 1000 .AND. Y /= 0.0D0) GO TO 130

      K = KEXP - JEXP
      IF (K >= 0) THEN
          IF (K == 0) THEN
              CALL FMEQ(MXY(1),MXY(5))
          ELSE IF (K == 1) THEN
              CALL FMMPY(MXY(1),MXY(3),MXY(5))
          ELSE IF (K == 2) THEN
              CALL FMSQR(MXY(3),MXY(2))
              CALL FMMPY(MXY(1),MXY(2),MXY(5))
          ELSE
              CALL FMIPWR(MXY(3),K,MXY(2))
              CALL FMMPY(MXY(1),MXY(2),MXY(5))
          ENDIF
      ELSE
          IF (K == -1) THEN
              CALL FMDIV(MXY(1),MXY(3),MXY(5))
          ELSE IF (K == -2) THEN
              CALL FMSQR(MXY(3),MXY(2))
              CALL FMDIV(MXY(1),MXY(2),MXY(5))
          ELSE
              CALL FMIPWR(MXY(3),-K,MXY(2))
              CALL FMDIV(MXY(1),MXY(2),MXY(5))
          ENDIF
      ENDIF
      CALL FMEQU(MXY(5),MA,NDIG,NDSAVE)

  140 MWK(START(MA)) = 1
      IF (X < 0.0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1
      MWK(START(MA)+1) = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDM2

      SUBROUTINE FMDP2M(X,MA)

!  MA = X

!  Convert a double precision floating point number to FM format.

!  This version tries to convert the double precision machine number to FM with accuracy of nearly
!  full FM precision. If conversion to FM with approximately double precision accuracy is good
!  enough, FMDPM is faster and uses less scratch space.

!  This routine assumes the machine's base for double precision is a power of two.

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      INTEGER :: MA
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMDP2M'
      IF (NTRACE /= 0) CALL FMNTRR(2,X,1)

      CALL FMDM2(X,MA)

      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDP2M

      SUBROUTINE FMDPM(X,MA)

!  MA = X

!  Convert a double precision floating point number to FM format.

!  In general, the relative accuracy of the FM number returned is only the relative accuracy of a
!  machine precision number.  This may be true even if X can be represented exactly in the machine
!  floating point number system.

!  This version is faster than FMDP2M, but often less accurate.

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: X
      INTEGER :: MA

      DOUBLE PRECISION :: Y,YT
      INTEGER :: J,K
      INTENT (IN) :: X
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMDPM'
      IF (NTRACE /= 0) CALL FMNTRR(2,X,1)

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (EXPONENT(X) > EXPONENT(HUGE(X))) THEN
          DO J = 2, NDIG
             MWK(START(MA)+J+2) = 0
          ENDDO
          KFLAG = -4
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          MWK(START(MA)) = 1
          CALL FMWARN
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Check to see if X is exactly a small integer.  If so, converting as an integer is
!             better.  Also see if X is exactly a small integer divided by a small power of two.

      Y = 1048576.0D0
      IF (ABS(X) < Y) THEN
          K = INT(X)
          Y = K
          IF (Y == X) THEN
              CALL FMIM(K,MA)
              GO TO 110
          ENDIF
      ENDIF
      IF (ABS(X) < 1.0D0) THEN
          Y = 4096.0D0*X
          K = INT(Y)
          YT = K
          IF (Y == YT) THEN
              CALL FMIM(K,MA)
              CALL FMDIVI_R1(MA,4096)
              GO TO 110
          ENDIF
      ENDIF

      CALL FMDM(X,MA)

  110 IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMDPM

      SUBROUTINE FMENTR(NROUTN,MA,MB,NARGS,KNAM,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Do the argument checking and increasing of precision and overflow threshold upon entry to an
!  FM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  KNAM   - positive if the routine name is to be printed.
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result
!           immediately (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KASAVE - saves the value of KACCSW
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow
!           or underflow.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: KNAM,NARGS,KRESLT,NDSAVE,KASAVE,KOVUN

      REAL (KIND(1.0D0)) :: MACCAB
      INTEGER :: K
      INTENT (IN) :: NROUTN,MA,MB,NARGS,KNAM
      INTENT (INOUT) :: MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = NROUTN
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,NARGS,KNAM)
      CALL FMARGS(NROUTN,NARGS,MA,MB,KRESLT)

      IF (MBLOGS /= MBASE) CALL FMCONS
      KOVUN = 0
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
      ENDIF

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD52-1,2)
          NDIG = MAX(NDIG+K,2)
      ENDIF

      IF (KRESLT /= 0) THEN
          MACCAB = MWK(START(MA)+1)
          IF (NARGS == 2) MACCAB = MIN(MACCAB,MWK(START(MB)+1))
          IF (KRESLT == 9 .OR. KRESLT == 10 .OR. KRESLT >= 13) THEN
              IF (KRAD == 1) THEN
                  CALL FMPI(MXY(1))
              ELSE
                  CALL FMI2M(180,MXY(1))
              ENDIF
              IF (KRESLT <= 10) CALL FMDIVI_R1(MXY(1),2)
              IF (KRESLT >= 14) CALL FMDIVI_R1(MXY(1),4)
              IF ((KRESLT == 9 .OR. KRESLT == 14) .AND. MWK(START(MXY(1))+2) /= MUNKNO .AND.  &
                  MWK(START(MXY(1))+3) /= 0) MWK(START(MXY(1))) = -MWK(START(MXY(1)))
              CALL FMEQU(MXY(1),MC,NDIG,NDSAVE)
              NDIG = NDSAVE
              MWK(START(MC)+1) = MACCAB
              IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
              NUMBER_USED = NUMBER_USED_SAVE
              KASAVE = KACCSW
              MXSAVE = MXEXP
              NCALL = NCALL - 1
              RETURN
          ENDIF

          NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT)
          IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
          NUMBER_USED = NUMBER_USED_SAVE
          KASAVE = KACCSW
          MXSAVE = MXEXP
          NCALL = NCALL - 1
          RETURN
      ENDIF

      KASAVE = KACCSW
      KACCSW = 0
      NUMBER_USED = NUMBER_USED_SAVE

!             Extend the overflow/underflow threshold.

      MXSAVE = MXEXP
      MXEXP = MXEXP2
      RETURN
      END SUBROUTINE FMENTR

      SUBROUTINE FMENTR2(NROUTN,MA,MB,NARGS,KNAM,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Do the argument checking and increasing of precision and overflow threshold upon entry to a
!  low-level FM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  KNAM   - positive if the routine name is to be printed.
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result
!           immediately (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KASAVE - saves the value of KACCSW
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow
!           or underflow.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: KNAM,NARGS,KRESLT,NDSAVE,KASAVE,KOVUN

      REAL (KIND(1.0D0)) :: MACCAB
      INTEGER :: K
      INTENT (IN) :: NROUTN,MA,MB,NARGS,KNAM
      INTENT (INOUT) :: MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN

      NCALL = NCALL + 1
      NAMEST(NCALL) = NROUTN
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,NARGS,KNAM)
      CALL FMARGS(NROUTN,NARGS,MA,MB,KRESLT)

      IF (MBLOGS /= MBASE) CALL FMCONS
      KOVUN = 0
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
      ENDIF

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD52-1,2)
          NDIG = MAX(NDIG+K,2)
      ENDIF

      IF (KRESLT /= 0) THEN
          MACCAB = MWK(START(MA)+1)
          IF (NARGS == 2) MACCAB = MIN(MACCAB,MWK(START(MB)+1))
          NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT)
          IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
          KASAVE = KACCSW
          MXSAVE = MXEXP
          NCALL = NCALL - 1
          RETURN
      ENDIF

      KASAVE = KACCSW
      KACCSW = 0

!             Extend the overflow/underflow threshold.

      MXSAVE = MXEXP
      MXEXP = MXEXP2
      RETURN
      END SUBROUTINE FMENTR2

      SUBROUTINE FMEQ(MA,MB)

!  MB = MA

!  This is the standard form of equality, where MA and MB both have precision NDIG.
!  Use FMEQU for assignments that also change precision.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: J
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF

!             If the user tries to change precision, one common mistake is to fail to increase the
!             size of all existing variables.  Check to make sure MA has a valid definition.

      IF (MA <= 0) CALL FMINPUT_ERROR(1)
      IF (MA > NUMBER_USED .AND. MA < START_OF_SAVED_CONSTANTS) CALL FMINPUT_ERROR(2)
      IF (MA > SIZE_OF_START) CALL FMINPUT_ERROR(3)
      IF (START(MA) < 0 .OR. START(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(4)
      IF (SIZE_OF(MA) < 0 .OR. SIZE_OF(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(5)
      IF (START(MA)+SIZE_OF(MA)-1 > SIZE_OF_MWK) CALL FMINPUT_ERROR(6)
      IF (SIZE_OF(MA) < NDIG+3) CALL FMINPUT_ERROR(7)

!             Copy MA to MB.

      DO J = -1, NDIG+1
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO

!             Check for overflow or underflow.

      IF (ABS(MWK(START(MB)+2)) > MXEXP) THEN
          IF (MWK(START(MB)+2) /= MUNKNO .OR. MWK(START(MB)+3) /= 1) THEN
              NCALL = NCALL + 1
              CALL FMTRAP(MB)
              NCALL = NCALL - 1
          ENDIF
          IF (MWK(START(MB)+2) == MUNKNO) KFLAG = -4
      ENDIF

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEQ

      SUBROUTINE FMEQU(MA,MB,NDA,NDB)

!  Set MB (having NDB digits) equal to MA (having NDA digits).

!  If MB has less precision than MA the result is rounded to NDB digits.

!  If MB has more precision the result has zero digits padded on the right.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NDA,NDB
      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: M2,MACCA,MBS,MKT
      INTEGER :: J,JT,K,KB,L,N1
      INTENT (IN) :: MA,NDA,NDB
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FMEQU.'
          WRITE (KW,*) ' MA is not defined on input.'
          WRITE (KW,*) ' Call stack: '
          WRITE (KW,"(10(3X,A))") (NAMEST(J),J=1,NCALL)
          WRITE (KW,*) ' '
          STOP
      ENDIF
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,NDB+3)
      ENDIF
      IF (SIZE_OF(MB) < NDB+3) THEN
          CALL IMDEFINE(MB,NDB+3)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)

!             If the user tries to change precision, one common mistake is to fail to increase the
!             size of all existing variables.  Check to make sure MA has a valid definition.

      IF (MA <= 0) CALL FMINPUT_ERROR(1)
      IF (MA > NUMBER_USED .AND. MA < START_OF_SAVED_CONSTANTS) CALL FMINPUT_ERROR(2)
      IF (MA > SIZE_OF_START) CALL FMINPUT_ERROR(3)
      IF (START(MA) < 0 .OR. START(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(4)
      IF (SIZE_OF(MA) < 0 .OR. SIZE_OF(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(5)
      IF (START(MA)+SIZE_OF(MA)-1 > SIZE_OF_MWK) CALL FMINPUT_ERROR(6)
      IF (SIZE_OF(MA) < NDA+3) CALL FMINPUT_ERROR(7)

!             Check for precision in range.

      IF (NDA < 1 .OR. NDB < 1) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMEQU'
          KFLAG = -1
          CALL FMWARN
          WRITE (KW,  &
                 "(/' The two precisions in FMEQU were NDA =',I19,"  //  &
                  "' NDB =',I19/)"                                       &
                ) NDA,NDB
          DO J = 2, NDB
             MWK(START(MB)+J+2) = 0
          ENDDO
          KFLAG = -1
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDB*ALOGM2)
          MWK(START(MB)) = 1
          NCALL = NCALL - 1
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MBS = MWK(START(MA))
      MWK(START(MB)) = MBS

!             Check for special symbols.

      KFLAG = 0
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) THEN
          DO J = 2, NDB
             MWK(START(MB)+J+2) = 0
          ENDDO
          MWK(START(MB)+2) = MWK(START(MA)+2)
          MWK(START(MB)+3) = MWK(START(MA)+3)
          GO TO 150
      ENDIF

      IF (NDB == NDA) GO TO 130

      IF (NDB > NDA) GO TO 140

!             Round to NDB digits.

      N1 = NDB + 1
      DO J = 1, N1
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      IF (KROUND == -1 .AND. NCALL <= 1) THEN
          IF (MWK(START(MA)) > 0) GO TO 150
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) > 0) GO TO 110
          ENDDO
          GO TO 150
      ENDIF
      IF (KROUND == 2 .AND. NCALL <= 1) THEN
          IF (MWK(START(MA)) < 0) GO TO 150
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) > 0) GO TO 110
          ENDDO
          GO TO 150
      ENDIF
      IF (KROUND == 0 .AND. NCALL <= 1) GO TO 150

      IF (INT(MBASE-AINT (MBASE/2)*2) /= 0) THEN
          M2 = AINT (MBASE/2)
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) /= M2) EXIT
             IF (J == NDA+1) GO TO 110
          ENDDO
      ENDIF
      L = NDB + 2
      IF (2*(MWK(START(MA)+L+1)+1) < MBASE) GO TO 150
      M2 = 2
      IF (INT(MBASE-AINT (MBASE/M2)*M2) == 0) THEN
          IF (2*MWK(START(MA)+L+1) < MBASE) GO TO 150
          IF (2*MWK(START(MA)+L+1) == MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (MWK(START(MA)+J+2) > 0) GO TO 110
                  ENDDO
              ENDIF

!                       Round to even.

              IF (INT(MWK(START(MB)+N1+1)-AINT (MWK(START(MB)+N1+1)/M2)*M2) == 0) GO TO 150
          ENDIF
      ELSE
          IF (2*MWK(START(MA)+L+1)+1 == MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (2*(MWK(START(MA)+J+2)+1) < MBASE) GO TO 150
                     IF (2*MWK(START(MA)+J+2) > MBASE) GO TO 110
                  ENDDO
                  GO TO 150
              ENDIF
          ENDIF
      ENDIF

  110 MWK(START(MB)+NDB+2) = MWK(START(MB)+NDB+2) + 1

!             Check whether there was a carry in the rounded digit.

      KB = NDB + 1
      IF (KB >= 3) THEN
          K = KB + 1
          DO J = 3, KB
             K = K - 1
             IF (MWK(START(MB)+K+1) < MBASE) GO TO 120
             MKT = AINT (MWK(START(MB)+K+1)/MBASE)
             MWK(START(MB)+K) = MWK(START(MB)+K) + MKT
             MWK(START(MB)+K+1) = MWK(START(MB)+K+1) - MKT*MBASE
          ENDDO
      ENDIF

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

      IF (MWK(START(MB)+3) < MBASE) GO TO 120
      IF (KB >= 4) THEN
          K = KB + 1
          DO J = 4, KB
             K = K - 1
             MWK(START(MB)+K+1) = MWK(START(MB)+K)
          ENDDO
      ENDIF

      MKT = AINT (MWK(START(MB)+3)/MBASE)
      IF (KB >= 3) MWK(START(MB)+4) = MWK(START(MB)+3) - MKT*MBASE
      MWK(START(MB)+3) = MKT
      MWK(START(MB)+2) = MWK(START(MB)+2) + 1

  120 IF (MBS < 0 .AND. MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0) MWK(START(MB)) = -1
      GO TO 150

!             MA and MB have the same precision.

  130 DO J = 1, NDA+1
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      GO TO 150

!             Extend to NDB digits by padding with zeros.

  140 DO J = 1, NDA+1
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      DO J = NDA+2, NDB+1
         MWK(START(MB)+J+1) = 0
      ENDDO

!             Check for overflow or underflow.

  150 IF (ABS(MWK(START(MB)+2)) > MXEXP) THEN
          IF (MWK(START(MB)+2) /= MUNKNO .OR. MWK(START(MB)+3) /= 1) THEN
              IF (MWK(START(MB)+2) > MXEXP+1) THEN
                  IF (MWK(START(MB)) > 0) THEN
                      DO J = 2, NDB
                         MWK(START(MB)+J+2) = 0
                      ENDDO
                      MWK(START(MB)+2) = MEXPOV
                      MWK(START(MB)+3) = 1
                      MWK(START(MB)) = 1
                      MWK(START(MB)+1) = NINT(NDB*ALOGM2)
                  ELSE
                      DO J = 2, NDB
                         MWK(START(MB)+J+2) = 0
                      ENDDO
                      MWK(START(MB)+2) = MEXPOV
                      MWK(START(MB)+3) = 1
                      MWK(START(MB)) = -1
                      MWK(START(MB)+1) = NINT(NDB*ALOGM2)
                  ENDIF
                  KFLAG = -5
              ENDIF
              IF (MWK(START(MB)+2) < -MXEXP) THEN
                  IF (MWK(START(MB)) > 0) THEN
                      DO J = 2, NDB
                         MWK(START(MB)+J+2) = 0
                      ENDDO
                      MWK(START(MB)+2) = MEXPUN
                      MWK(START(MB)+3) = 1
                      MWK(START(MB)) = 1
                      MWK(START(MB)+1) = NINT(NDB*ALOGM2)
                  ELSE
                      DO J = 2, NDB
                         MWK(START(MB)+J+2) = 0
                      ENDDO
                      MWK(START(MB)+2) = MEXPUN
                      MWK(START(MB)+3) = 1
                      MWK(START(MB)) = -1
                      MWK(START(MB)+1) = NINT(NDB*ALOGM2)
                  ENDIF
                  KFLAG = -6
              ENDIF
          ENDIF
          IF (MWK(START(MB)+2) == MUNKNO) KFLAG = -4
      ENDIF

      IF (KACCSW == 1) THEN
          JT = NINT(LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          IF (NDB > NDA) THEN
              MWK(START(MB)+1) = NINT((NDB-1)*ALOGM2 + JT)
          ELSE
              MWK(START(MB)+1) = MIN(NINT((NDB-1)*ALOGM2+JT),INT(MACCA))
          ENDIF
      ELSE
          MWK(START(MB)+1) = MWK(START(MA)+1)
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEQU

      SUBROUTINE FMEQU_R1(MA,NDA,NDB)

!  Change precision of MA from NDA digits on input to NDB digits on output.

!  If NDB is less than NDA the result is rounded to NDB digits.

!  If NDB is greater than NDA the result has zero digits padded on the right.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: NDA,NDB

      REAL (KIND(1.0D0)) :: M2,MACCA,MBS,MKT
      REAL (KIND(1.0D0)), DIMENSION(:), ALLOCATABLE :: MA_COPY
      INTEGER :: J,JT,K,KB,L,N1
      INTENT (INOUT) :: MA
      INTENT (IN) :: NDA,NDB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FMEQU_R1.'
          WRITE (KW,*) ' MA is not defined on input.'
          WRITE (KW,*) ' Call stack: '
          WRITE (KW,"(10(3X,A))") (NAMEST(J),J=1,NCALL)
          WRITE (KW,*) ' '
          STOP
      ENDIF
      IF (SIZE_OF(MA) < NDB+3) THEN
          ALLOCATE(MA_COPY(NDA+3),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          DO J = -1, NDA+1
             MA_COPY(2+J) = MWK(START(MA)+J+1)
          ENDDO
          CALL IMDEFINE(MA,NDB+3)
          DO J = -1, NDA+1
             MWK(START(MA)+J+1) = MA_COPY(2+J)
          ENDDO
          DEALLOCATE(MA_COPY)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)

!             If the user tries to change precision, one common mistake is to fail to increase the
!             size of all existing variables.  Check to make sure MA has a valid definition.

      IF (MA <= 0) CALL FMINPUT_ERROR(1)
      IF (MA > NUMBER_USED .AND. MA < START_OF_SAVED_CONSTANTS) CALL FMINPUT_ERROR(2)
      IF (MA > SIZE_OF_START) CALL FMINPUT_ERROR(3)
      IF (START(MA) < 0 .OR. START(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(4)
      IF (SIZE_OF(MA) < 0 .OR. SIZE_OF(MA) > SIZE_OF_MWK) CALL FMINPUT_ERROR(5)
      IF (START(MA)+SIZE_OF(MA)-1 > SIZE_OF_MWK) CALL FMINPUT_ERROR(6)
      IF (SIZE_OF(MA) < NDA+3) CALL FMINPUT_ERROR(7)

!             Check for precision in range.

      IF (NDA < 1 .OR. NDB < 1) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMEQU'
          KFLAG = -1
          CALL FMWARN
          WRITE (KW,  &
                 "(/' The two precisions in FMEQU were NDA =',I19,"  //  &
                  "' NDB =',I19/)"                                       &
                ) NDA,NDB
          DO J = 2, NDB
             MWK(START(MA)+J+2) = 0
          ENDDO
          KFLAG = -1
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDB*ALOGM2)
          MWK(START(MA)) = 1
          NCALL = NCALL - 1
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MBS = MWK(START(MA))

!             Check for special symbols.

      KFLAG = 0
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) THEN
          DO J = 2, NDB
             MWK(START(MA)+J+2) = 0
          ENDDO
          GO TO 140
      ENDIF

      IF (NDB == NDA) GO TO 140

      IF (NDB > NDA) GO TO 130

!             Round to NDB digits.

      N1 = NDB + 1
      IF (KROUND == -1 .AND. NCALL <= 1) THEN
          IF (MWK(START(MA)) > 0) GO TO 140
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) > 0) GO TO 110
          ENDDO
          GO TO 140
      ENDIF
      IF (KROUND == 2 .AND. NCALL <= 1) THEN
          IF (MWK(START(MA)) < 0) GO TO 140
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) > 0) GO TO 110
          ENDDO
          GO TO 140
      ENDIF
      IF (KROUND == 0 .AND. NCALL <= 1) GO TO 140

      IF (INT(MBASE-AINT (MBASE/2)*2) /= 0) THEN
          M2 = AINT (MBASE/2)
          DO J = NDB+2, NDA+1
             IF (MWK(START(MA)+J+1) /= M2) EXIT
             IF (J == NDA+1) GO TO 110
          ENDDO
      ENDIF
      L = NDB + 2
      IF (2*(MWK(START(MA)+L+1)+1) < MBASE) GO TO 140
      M2 = 2
      IF (INT(MBASE-AINT (MBASE/M2)*M2) == 0) THEN
          IF (2*MWK(START(MA)+L+1) < MBASE) GO TO 140
          IF (2*MWK(START(MA)+L+1) == MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (MWK(START(MA)+J+2) > 0) GO TO 110
                  ENDDO
              ENDIF

!                       Round to even.

              IF (INT(MWK(START(MA)+N1+1)-AINT (MWK(START(MA)+N1+1)/M2)*M2) == 0) GO TO 140
          ENDIF
      ELSE
          IF (2*MWK(START(MA)+L+1)+1 == MBASE) THEN
              IF (L <= NDA) THEN
                  DO J = L, NDA
                     IF (2*(MWK(START(MA)+J+2)+1) < MBASE) GO TO 140
                     IF (2*MWK(START(MA)+J+2) > MBASE) GO TO 110
                  ENDDO
                  GO TO 140
              ENDIF
          ENDIF
      ENDIF

  110 MWK(START(MA)+NDB+2) = MWK(START(MA)+NDB+2) + 1
      MWK(START(MA)+NDB+3) = 0

!             Check whether there was a carry in the rounded digit.

      KB = NDB + 1
      IF (KB >= 3) THEN
          K = KB + 1
          DO J = 3, KB
             K = K - 1
             IF (MWK(START(MA)+K+1) < MBASE) GO TO 120
             MKT = AINT (MWK(START(MA)+K+1)/MBASE)
             MWK(START(MA)+K) = MWK(START(MA)+K) + MKT
             MWK(START(MA)+K+1) = MWK(START(MA)+K+1) - MKT*MBASE
          ENDDO
      ENDIF

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

      IF (MWK(START(MA)+3) < MBASE) GO TO 120
      IF (KB >= 4) THEN
          K = KB + 1
          DO J = 4, KB
             K = K - 1
             MWK(START(MA)+K+1) = MWK(START(MA)+K)
          ENDDO
      ENDIF

      MKT = AINT (MWK(START(MA)+3)/MBASE)
      IF (KB >= 3) MWK(START(MA)+4) = MWK(START(MA)+3) - MKT*MBASE
      MWK(START(MA)+3) = MKT
      MWK(START(MA)+2) = MWK(START(MA)+2) + 1

  120 IF (MBS < 0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1
      GO TO 140

!             Extend to NDB digits by padding with zeros.

  130 DO J = NDA+2, NDB+1
         MWK(START(MA)+J+1) = 0
      ENDDO

!             Check for overflow or underflow.

  140 IF (ABS(MWK(START(MA)+2)) > MXEXP) THEN
          IF (MWK(START(MA)+2) /= MUNKNO .OR. MWK(START(MA)+3) /= 1) THEN
              IF (MWK(START(MA)+2) > MXEXP+1) THEN
                  IF (MWK(START(MA)) > 0) THEN
                      DO J = 2, NDB
                         MWK(START(MA)+J+2) = 0
                      ENDDO
                      MWK(START(MA)+2) = MEXPOV
                      MWK(START(MA)+3) = 1
                      MWK(START(MA)) = 1
                      MWK(START(MA)+1) = NINT(NDB*ALOGM2)
                  ELSE
                      DO J = 2, NDB
                         MWK(START(MA)+J+2) = 0
                      ENDDO
                      MWK(START(MA)+2) = MEXPOV
                      MWK(START(MA)+3) = 1
                      MWK(START(MA)) = -1
                      MWK(START(MA)+1) = NINT(NDB*ALOGM2)
                  ENDIF
                  KFLAG = -5
              ENDIF
              IF (MWK(START(MA)+2) < -MXEXP) THEN
                  IF (MWK(START(MA)) > 0) THEN
                      DO J = 2, NDB
                         MWK(START(MA)+J+2) = 0
                      ENDDO
                      MWK(START(MA)+2) = MEXPUN
                      MWK(START(MA)+3) = 1
                      MWK(START(MA)) = 1
                      MWK(START(MA)+1) = NINT(NDB*ALOGM2)
                  ELSE
                      DO J = 2, NDB
                         MWK(START(MA)+J+2) = 0
                      ENDDO
                      MWK(START(MA)+2) = MEXPUN
                      MWK(START(MA)+3) = 1
                      MWK(START(MA)) = -1
                      MWK(START(MA)+1) = NINT(NDB*ALOGM2)
                  ENDIF
                  KFLAG = -6
              ENDIF
          ENDIF
          IF (MWK(START(MA)+2) == MUNKNO) KFLAG = -4
      ENDIF

      IF (KACCSW == 1) THEN
          JT = NINT(LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          IF (NDB > NDA) THEN
              MWK(START(MA)+1) = NINT((NDB-1)*ALOGM2 + JT)
          ELSE
              MWK(START(MA)+1) = MIN(NINT((NDB-1)*ALOGM2+JT),INT(MACCA))
          ENDIF
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEQU_R1

      SUBROUTINE FMEXIT(MT,MC,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Upon exit from an FM routine the result MT (having precision NDIG) is rounded and returned in MC
!  (having precision NDSAVE).  The values of NDIG, MXEXP, and KACCSW are restored.  KOVUN is nonzero
!  if one of the routine's input arguments was overflow or underflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MT,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KASAVE,KOVUN

      INTEGER :: KFSAVE,KWRNSV
      INTENT (IN) :: MT,NDSAVE,MXSAVE,KASAVE,KOVUN
      INTENT (INOUT) :: MC

      KWRNSV = KWARN
      KWARN = 0
      MXEXP = MXSAVE
      KFSAVE = KFLAG
      CALL FMEQU(MT,MC,NDIG,NDSAVE)
      IF (KFLAG /= -5 .AND. KFLAG /= -6) KFLAG = KFSAVE
      NDIG = NDSAVE
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = 0
      IF ((MWK(START(MC)+2) == MUNKNO .AND. KFLAG /= -9)  &
         .OR. (MWK(START(MC)+2) == MEXPUN .AND. KOVUN == 0)  &
         .OR. (MWK(START(MC)+2) == MEXPOV .AND. KOVUN == 0)) CALL FMWARN
      IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      NCALL = NCALL - 1
      KACCSW = KASAVE
      RETURN
      END SUBROUTINE FMEXIT

      SUBROUTINE FMEXP(MA,MB)

!  MB = EXP(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      CHARACTER(155) :: STRING
      REAL (KIND(1.0D0)) :: M1,MA1,MA2,MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KT,KWRNSV,L,NDMB,NDSAVE,NDSV,NMETHD
      REAL :: XMA,XOV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (NDIG > 1000) THEN
          NDSAVE = NDIG
          NDIG = NDIG + 100 + NDIG/100
          IF (MWA <= 0) THEN
              CALL FMDEFINE(MWA)
          ELSE IF (SIZE_OF(MWA) < 2*NDIG + 30) THEN
              CALL FMDEFINE(MWA)
          ENDIF
          NDIG = NDSAVE
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMEXP'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMI2M(1,MXY(1))
          CALL FMADD(MXY(1),MA,MB)
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMEXP'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMEXP    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMEXP'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MA1 = MWK(START(MA)+2)
      MA2 = MWK(START(MA)+3)
      MAS = MWK(START(MA))

      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

!             Check for obvious underflow or overflow.
!             XOV is LN(LN(slightly above overflow))
!             XMA is LN(LN(EXP(MA))) approximately.

      XOV = LOG(1.01*REAL(MXEXP)) + LOG(ALOGMB)
      M1 = 1
      XMA = LOG(REAL(MAX(ABS(MA2),M1))) - ALOGMB + REAL(MA1)*ALOGMB

  120 IF (XMA >= XOV) THEN
          CALL FMIM(0,MXY(2))
          IF (MAS > 0) THEN
              KFLAG = -5
              CALL FMST2M('OVERFLOW',MXY(2))
          ELSE
              KFLAG = -6
              CALL FMST2M('UNDERFLOW',MXY(2))
          ENDIF
          CALL FMEQU(MXY(2),MB,NDIG,NDSAVE)
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
          CALL FMWARN
          IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Split MA into integer and fraction parts.  Work with a positive argument.
!             MXY(1) = integer part of ABS(MA)
!             MXY(2) = fraction part of ABS(MA)

      MWK(START(MXY(2))) = 1
      CALL FMINT(MXY(2),MXY(1))
      CALL FMSUB_R1(MXY(2),MXY(1))

!             If the integer part is not zero, use FMIPWR to compute E**(MXY(1)).  If MXY(1) is too
!             large to represent as a one word integer, the definition of MXEXP insures that
!             E**(MXY(1)) overflows or underflows.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(1),KT)
      KWARN = KWRNSV
      IF (KFLAG /= 0) THEN
          XMA = XOV
          GO TO 120
      ENDIF
      IF (KT > 0) THEN

!             Compute IEXTRA, the number of extra digits required to get EXP(KT) correct to the
!             current precision.

          IEXTRA = INT(LOG(REAL(KT))/ALOGMB + 0.5)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA

!             Check whether the current precision of e is large enough.

          IF (MBSE /= MBASE .OR. NDIG > NDIGE) THEN
              NDMB = INT(150.0*2.302585/ALOGMB)
              IF (NDMB >= NDIG) THEN
                  NDSV = NDIG
                  NDIG = NDMB
                  IF (MESAV > 0) THEN
                      IF (SIZE_OF(MESAV) < NDIG+3) THEN
                          L = -3
                          CALL FMDEFINE(L)
                          TEMPV(MESAV) = -6
                          MESAV = L
                      ENDIF
                  ENDIF
                  STRING = '2.718281828459045235360287471352662497757247'//  &
                  '09369995957496696762772407663035354759457138217852516'//  &
                  '6427427466391932003059921817413596629043572900334295261'
                  CALL FMST2M(STRING,MESAV)
                  MWK(START(MESAV)+1) = NINT(NDIG*ALOGM2)
                  MBSE = MBASE
                  NDIGE = NDIG
                  IF (ABS(MWK(START(MESAV)+2)) > 10) NDIGE = 0
                  NDIG = NDSV
              ELSE
                  NDSV = NDIG
                  NDIG = NDIG + 2 + NDIG/100
                  IF (MESAV > 0) THEN
                      IF (SIZE_OF(MESAV) < NDIG+3) THEN
                          L = -3
                          CALL FMDEFINE(L)
                          TEMPV(MESAV) = -6
                          MESAV = L
                      ENDIF
                  ENDIF
                  CALL FMI2M(1,MESAV)
                  CALL FMEXP2(MESAV,MXY(4))
                  CALL FMEQ(MXY(4),MESAV)
                  MWK(START(MESAV)+1) = NINT(NDIG*ALOGM2)
                  MBSE = MBASE
                  NDIGE = NDIG
                  IF (ABS(MWK(START(MESAV)+2)) > 10) NDIGE = 0
                  NDIG = NDSV
              ENDIF
          ENDIF
      ENDIF

!             Now do the fraction part of MA and combine the results.

      KWRNSV = KWARN
      KWARN = 0
      NMETHD = 1
      IF (NDIG > 50) NMETHD = 2
      IF (MWK(START(MXY(2))+3) /= 0 .AND. KT > 0 .AND. NMETHD == 1) THEN
          CALL FMEXP2(MXY(2),MXY(4))
          CALL FMIPWR(MESAV,KT,MXY(3))
          CALL FMMPY(MXY(4),MXY(3),MXY(2))
      ELSE IF (MWK(START(MXY(2))+3) /= 0 .AND. KT == 0 .AND. NMETHD == 1) THEN
          CALL FMEXP2(MXY(2),MXY(4))
          CALL FMEQ(MXY(4),MXY(2))
      ELSE IF (MWK(START(MXY(2))+3) /= 0 .AND. KT > 0 .AND. NMETHD == 2) THEN
          NDSV = NDIG
          NDIG = NDIG + NGRD21
          CALL FMEQU_R1(MXY(2),NDSV,NDIG)
          IF (MWK(START(MXY(2))+2) >= 0) THEN
              CALL FMCSH2(MXY(2),MXY(4))
              CALL FMSQR(MXY(4),MXY(3))
              CALL FMI2M(-1,MXY(1))
              CALL FMADD_R1(MXY(3),MXY(1))
              CALL FMSQRT_R1(MXY(3))
              CALL FMADD(MXY(4),MXY(3),MXY(2))
          ELSE
              CALL FMSNH2(MXY(2),MXY(4))
              CALL FMSQR(MXY(4),MXY(3))
              CALL FMI2M(1,MXY(1))
              CALL FMADD_R1(MXY(3),MXY(1))
              CALL FMSQRT_R1(MXY(3))
              CALL FMADD(MXY(4),MXY(3),MXY(2))
          ENDIF
          NDIG = NDSV
          CALL FMIPWR(MESAV,KT,MXY(3))
          CALL FMMPY_R1(MXY(2),MXY(3))
      ELSE IF (MWK(START(MXY(2))+3) /= 0 .AND. KT == 0 .AND. NMETHD == 2) THEN
          NDSV = NDIG
          NDIG = NDIG + NGRD21
          CALL FMEQU_R1(MXY(2),NDSV,NDIG)
          IF (MWK(START(MXY(2))+2) >= 0) THEN
              CALL FMCSH2(MXY(2),MXY(4))
              CALL FMSQR(MXY(4),MXY(3))
              CALL FMI2M(-1,MXY(1))
              CALL FMADD_R1(MXY(3),MXY(1))
              CALL FMSQRT_R1(MXY(3))
              CALL FMADD(MXY(4),MXY(3),MXY(2))
          ELSE
              CALL FMSNH2(MXY(2),MXY(4))
              CALL FMSQR(MXY(4),MXY(3))
              CALL FMI2M(1,MXY(1))
              CALL FMADD_R1(MXY(3),MXY(1))
              CALL FMSQRT_R1(MXY(3))
              CALL FMADD(MXY(4),MXY(3),MXY(2))
          ENDIF
          NDIG = NDSV
      ELSE IF (MWK(START(MXY(2))+3) == 0 .AND. KT > 0) THEN
          CALL FMIPWR(MESAV,KT,MXY(2))
      ELSE
          CALL FMI2M(1,MXY(2))
      ENDIF

!             Invert if MA was negative.

      IF (MAS < 0) THEN
          CALL FMI2M(1,MXY(1))
          CALL FMDIV_R2(MXY(1),MXY(2))
      ENDIF
      KWARN = KWRNSV

!             Round the result and return.

      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(2))+3))+1))/0.69315)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEXP

      SUBROUTINE FMEXP2(MA,MB)

!  MB = EXP(MA)

!  Internal exponential routine (called with 0 < MA <= 1).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAXVAL
      REAL (KIND(0.0D0)) :: X1,X2,X3,F1,F2,F3,PI
      INTEGER :: J,J2,K,K2,KTWO,L,L2,N2,NBIG,NBOT,NDSAV1,NDSAVE,NTERM,NTOP
      REAL :: ALOG2,ALOGT,B,T,TJ,XN
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      NDSAVE = NDIG
      IF (MWK(START(MA)+2) == 1) THEN

!             Here the special case EXP(1.0) is computed.

          T = NDIG
          XN = T*ALOGMB/LOG(T)
          K = INT(LOG(XN)/ALOGMB)
          NDIG = MAX(NDIG+K,2)
          NDSAV1 = NDIG

          IF (NDSAVE < 100) THEN

!             If precision is not very high, use the direct series  e = 1/0! + 1/1! + 1/2! + ...
!             Do as much of the work as possible using small integers to minimize the number of
!             FM calls.  Reduce NDIG while computing each term in the sum as the terms get smaller.

              CALL FMI2M(2,MXY(2))
              CALL FMI2M(1,MXY(1))
              J = 2
              NBIG = INT(MXBASE)

  110         NTOP = 1
              NBOT = J
  120         IF (NBOT > NBIG/(J+1)) GO TO 130
              J = J + 1
              NTOP = J*NTOP + 1
              NBOT = J*NBOT
              GO TO 120

  130         CALL FMDIVI_R1(MXY(1),NBOT)
              IF (NTOP > 1) THEN
                  CALL FMMPYI(MXY(1),NTOP,MXY(3))
                  NDIG = NDSAV1
                  CALL FMADD_R1(MXY(2),MXY(3))
                  NDIG = NDSAV1 - INT(MWK(START(MXY(2))+2)-MWK(START(MXY(3))+2))
              ELSE
                  NDIG = NDSAV1
                  CALL FMADD_R1(MXY(2),MXY(1))
                  NDIG = NDSAV1 - INT(MWK(START(MXY(2))+2)-MWK(START(MXY(1))+2))
              ENDIF
              IF (NDIG < NGRD22) NDIG = NGRD22
              IF (KFLAG /= 1) THEN
                  J = J + 1
                  GO TO 110
              ENDIF
              NDIG = NDSAVE
              KFLAG = 0
              CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE)
          ELSE

!             If precision is high, use the binary splitting method for summing the direct series.

!             Determine K, the number of terms to sum in the series for e.

              X1 = 1.184*NDIG*DLOGMB/LOG(NDIG*DLOGMB) + 1.95*NDIG**0.777 + 10
              PI = ACOS(-1.0D0)
              F1 = NDIG*DLOGMB - (X1 + 0.5)*LOG(X1) + X1 - LOG(2.0*PI)/2 - 1/(12.0*X1)
              IF (F1 < 0) THEN
                  X2 = 0.9*X1
              ELSE
                  X2 = 1.1*X1
              ENDIF
              F2 = NDIG*DLOGMB - (X2 + 0.5)*LOG(X2) + X2 - LOG(2.0*PI)/2 - 1/(12.0*X2)
              DO J = 1, 5
                 X3 = X2 - F2*(X2 - X1)/(F2 - F1)
                 F3 = NDIG*DLOGMB - (X3 + 0.5)*LOG(X3) + X3 - LOG(2.0*PI)/2 - 1/(12.0*X3)
                 IF (ABS(X3-X2) < 0.1) EXIT
                 X1 = X2
                 F1 = F2
                 X2 = X3
                 F2 = F3
              ENDDO

              K = X3 + 10
              CALL FMEXP2_TQ(0,K,MXY(1),MXY(2))
              IF (MWK(START(MXY(1))+2) >= NDIG .AND. MWK(START(MXY(2))+2) >= NDIG) THEN
                  CALL FMDIV_R2(MXY(1),MXY(2))
                  NDIG = NDSAVE
                  KFLAG = 0
                  CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE)
              ELSE
                  CALL IMI2FM(MXY(1),MXY(3))
                  CALL IMI2FM(MXY(2),MXY(4))
                  CALL FMDIV(MXY(3),MXY(4),MXY(2))
                  NDIG = NDSAVE
                  KFLAG = 0
                  CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE)
              ENDIF
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Here is the general case.  Compute EXP(MA) where 0 < MA < 1.

!             Use the direct series
!                  EXP(X) = 1 + X + X**2/2! + X**3/3! + ...

!             The argument will be halved K2 times before the series is summed.  The series will be
!             added as J2 concurrent series.  The approximately optimal values of K2 and J2 are now
!             computed to try to minimize the time required. N2 is the approximate number of terms
!             of the series that will be needed, and L2 guard digits will be carried.

      B = REAL(MBASE)
      K = NGRD52
      T = MAX(NDIG-K,2)
      ALOG2 = REAL(DLOGTW)
      ALOGT = LOG(T)
      TJ = 0.051*ALOGMB*T**0.3333 + 1.85
      J2 = INT(TJ)
      J2 = MAX(1,MIN(J2,LJSUMS))
      K2 = INT(1.13*SQRT(T*ALOGMB/TJ) - 0.5*ALOGT + 4.5)

      L = INT(-(REAL(MWK(START(MA)+2))*ALOGMB+LOG(REAL(MWK(START(MA)+3))/B +  &
                REAL(MWK(START(MA)+4))/(B*B)))/ALOG2 - 0.3)
      K2 = K2 - L
      IF (L < 0) L = 0
      IF (K2 < 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2)) + .33)
      ENDIF
      IF (J2 <= 1) J2 = 1

      N2 = INT(T*ALOGMB/(ALOGT+REAL(L)*ALOG2))
      L2 = INT(LOG(REAL(N2)+2.0D0**K2)/ALOGMB)
      NDIG = NDIG + L2
      NDSAV1 = NDIG

!             Halve the argument K2 times.

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      KTWO = 1
      MAXVAL = MXBASE/2
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTWO = 2*KTWO
             IF (KTWO > MAXVAL) THEN
                 CALL FMDIVI_R1(MXY(1),KTWO)
                 KTWO = 1
             ENDIF
          ENDDO
          IF (KTWO > 1) CALL FMDIVI_R1(MXY(1),KTWO)
      ENDIF

!             Sum the series X + X**2/2! + X**3/3! + ....
!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum as
!             the terms get smaller.

      CALL FMEQ(MXY(1),MXY(2))
      NTERM = 1
      DO J = 1, J2
         CALL FMDIVI_R1(MXY(2),NTERM)
         NTERM = NTERM + 1
         CALL FMEQ(MXY(2),MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 150
      CALL FMIPWR(MXY(1),J2,MXY(3))

  140 CALL FMMPY_R1(MXY(2),MXY(3))
      DO J = 1, J2
         CALL FMDIVI_R1(MXY(2),NTERM)
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 150
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(2))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 140

!             Put the J2 separate sums back together.

  150 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(3))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(1),MXY(3))
             CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))
          ENDDO
      ENDIF

!             Reverse the effect of halving the argument to compute EXP(MA).

      NDIG = NDSAV1
      IF (K2 > 0) THEN
          IF (NDSAVE <= 20) THEN
              CALL FMI2M(2,MXY(1))
              DO J = 1, K2
                 CALL FMADD(MXY(3),MXY(1),MXY(2))
                 CALL FMMPY_R2(MXY(2),MXY(3))
              ENDDO
          ELSE
              DO J = 1, K2
                 CALL FMSQR(MXY(3),MXY(2))
                 CALL FMADD(MXY(3),MXY(3),MXY(1))
                 CALL FMADD(MXY(2),MXY(1),MXY(3))
              ENDDO
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(1))
      CALL FMADD(MXY(1),MXY(3),MXY(2))

      CALL FMEQU(MXY(2),MB,NDSAV1,NDSAVE)
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEXP2

      RECURSIVE SUBROUTINE FMEXP2_TQ(A,B,MT,MQ)

!  This routine does the binary splitting for computing the constant e.
!  When A is zero, e is approximated by MT/MQ.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MT,MQ
      INTEGER :: A,B
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MT,MQ
      INTEGER :: MXY(4),NUMBER_USED_SAVE,J,KQ,KT,M
      REAL (KIND(0.0D0)) :: DA,DB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      NUMBER_USED_SAVE = NUMBER_USED

      IF (B-A < 25) THEN
          RESULT_SIZE = ( (DB+0.5D0)*LOG(DB+1) - DB + 1/(12*(DB+1)) -  &
                        ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) + 10 ) / DLOGMB + 8
          RESULT_SIZE = MAX(5,RESULT_SIZE)
          IF (MT <= 0) THEN
              CALL IMDEFINE(MT,RESULT_SIZE)
          ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
              CALL IMDEFINE(MT,RESULT_SIZE)
          ENDIF
          IF (MQ <= 0) THEN
              CALL IMDEFINE(MQ,RESULT_SIZE)
          ELSE IF (SIZE_OF(MQ) < RESULT_SIZE) THEN
              CALL IMDEFINE(MQ,RESULT_SIZE)
          ENDIF
          NUMBER_USED_SAVE = NUMBER_USED
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          CALL IMDEFINE(MXY(3),RESULT_SIZE)
          CALL IMDEFINE(MXY(4),RESULT_SIZE)
          CALL IMI2M(1,MT)
          CALL IMI2M(1,MXY(1))
          DO J = 0, B-A-2, 2
             CALL IMMPYI(MXY(1),B-J,MXY(2))
             CALL IMADD(MT,MXY(2),MXY(3))
             CALL IMMPYI(MXY(2),B-J-1,MXY(1))
             CALL IMADD(MXY(3),MXY(1),MT)
          ENDDO
          IF (MOD(B-A,2) == 1) THEN
              CALL IMMPYI(MXY(1),A+1,MXY(2))
              CALL IMADD(MT,MXY(2),MXY(3))
              CALL IMEQ(MXY(3),MT)
          ENDIF

          IF (A == 0) THEN
              CALL IMI2M(1,MQ)
          ELSE
              CALL IMI2M(A,MQ)
          ENDIF
          DO J = A+1, B-1, 2
             CALL IMMPYI(MQ,J,MXY(1))
             CALL IMMPYI(MXY(1),J+1,MQ)
          ENDDO
          IF (MOD(B-A+1,2) == 0) THEN
              CALL IMMPYI(MQ,B,MXY(1))
              CALL IMEQ(MXY(1),MQ)
          ENDIF
          GO TO 110
      ENDIF

      M = (A+B)/2
      CALL FMEXP2_TQ(A,M-1,MXY(1),MXY(2))
      CALL FMEXP2_TQ(M,B,MXY(3),MXY(4))

      CALL IM_OR_FM_MPY(MXY(2),MXY(4),MQ)

      CALL IM_OR_FM_MPY(MXY(1),MXY(4),MXY(2))
      CALL IM_OR_FM_ADD(MXY(3),MXY(2),MT)

!             Move MQ and MT to the front of the unused area of MWK and save them.

      NUMBER_USED = NUMBER_USED_SAVE + 1
      KQ = MQ
      MQ = NUMBER_USED
      IF (NUMBER_USED <= 1) THEN
          START(MQ) = 1
      ELSE
          START(MQ) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
      ENDIF
      SIZE_OF(MQ) = SIZE_OF(KQ)
      DO J = 1, SIZE_OF(MQ)
         MWK(START(MQ)+J-1) = MWK(START(KQ)+J-1)
      ENDDO
      TEMPV(MQ) = -2
      NUMBER_USED = NUMBER_USED + 1
      KT = MT
      MT = NUMBER_USED
      START(MT) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
      SIZE_OF(MT) = SIZE_OF(KT)
      DO J = 1, SIZE_OF(MT)
         MWK(START(MT)+J-1) = MWK(START(KT)+J-1)
      ENDDO
      TEMPV(MT) = -2
      NUMBER_USED_SAVE = NUMBER_USED

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
          IF (TEMPV(MQ) == -1) TEMPV(MQ) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEXP2_TQ

      SUBROUTINE FMFLAG(K)

!  Return the internal condition variable KFLAG to the user.

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: K
      K = KFLAG
      RETURN
      END SUBROUTINE FMFLAG

      SUBROUTINE FMFFT(A,N,W)

!  Internal routine used during very high precision multiplication.

!  A is returned as the FFT of the input array A(1:N).
!  W is a scratch array.
!  This is a slightly modified version of a Fast Fourier Transform routine found at www.netlib.org.

      IMPLICIT NONE
      INTEGER :: N
      COMPLEX (KIND(0.0D0)) :: A(N),W(N),S,S1,S2,S3,S4,ST,T
      REAL (KIND(0.0D0)) :: PI
      INTEGER D,E,F,G,H,I,J,K,L,M,O
      INTEGER, PARAMETER :: P(25) = (/ 2,3,5,7,11,13,17,19,23,29,31,37,41,  &
                                      43,47,53,59,61,67,71,73,79,83,89,97 /)
      INTEGER, PARAMETER :: NP = 25
      M = N
      F = 0
      PI = ACOS(-1.0D0)
  110 IF ( M == 1 ) GO TO 910
      DO I = 1,NP
         IF ( (M/P(I))*P(I) == M ) GO TO 120
      ENDDO
      L = M
      GO TO 130
  120 L = P(I)
  130 O = M
      M = M/L
      ST = CMPLX(-2*SIN(M*PI/N)**2,SIN(2*M*PI/N), KIND(0.0D0) )
      S1 = (1.0D0,0.0D0)
      S = S1
      S2 = (0.0D0,0.0D0)
      H = 0
      IF ( F == 1 ) GO TO 520
      IF ( L == 2 ) GO TO 140
      IF ( L == 3 ) GO TO 250
      GO TO 360
  140 IF ( M == 1 ) GO TO 230
      IF ( M == 2 ) GO TO 210
      IF ( M == 3 ) GO TO 190
      IF ( M == 4 ) GO TO 170
  150 J = -H
  160 I = H + 1
      H = H + M
      E = J + M
      IF (ABS(S-(1.0D0,0.0D0)) < 10*EPSILON(1.0D0)) THEN
          DO K = I, H
             W(K) = A(J+K) + A(E+K)
          ENDDO
      ELSE IF (ABS(S-(-1.0D0,0.0D0)) < 10*EPSILON(1.0D0)) THEN
          DO K = I, H
             W(K) = A(J+K) - A(E+K)
          ENDDO
      ELSE
          DO K = I, H
             W(K) = A(J+K) + S*A(E+K)
          ENDDO
      ENDIF
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 160
      IF ( H < N ) GO TO 150
      F = 1
      GO TO 110
  170 J = -H
  180 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 180
      IF ( H < N ) GO TO 170
      F = 1
      GO TO 110
  190 J = -H
  200 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 200
      IF ( H < N ) GO TO 190
      F = 1
      GO TO 110
  210 J = -H
  220 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 220
      IF ( H < N ) GO TO 210
      F = 1
      GO TO 110
  230 J = -H
  240 H = H + 1
      E = J + M
      W(H) = A(J+H) + S*A(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 240
      IF ( H < N ) GO TO 230
      F = 1
      GO TO 110
  250 IF ( M == 1 ) GO TO 340
      IF ( M == 2 ) GO TO 320
      IF ( M == 3 ) GO TO 300
      IF ( M == 4 ) GO TO 280
  260 J = -H
  270 I = H + 1
      H = H + M
      E = J + M
      D = E + M
      T = S*S
      DO K = I, H
         W(K) = A(J+K) + S*A(E+K) + T*A(D+K)
      ENDDO
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 270
      IF ( H < N ) GO TO 260
      F = 1
      GO TO 110
  280 J = -H
  290 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 290
      IF ( H < N ) GO TO 280
      F = 1
      GO TO 110
  300 J = -H
  310 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 310
      IF ( H < N ) GO TO 300
      F = 1
      GO TO 110
  320 J = -H
  330 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      H = H + 1
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 330
      IF ( H < N ) GO TO 320
      F = 1
      GO TO 110
  340 J = -H
  350 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      W(H) = A(J+H) + S*A(E+H) + T*A(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 350
      IF ( H < N ) GO TO 340
      F = 1
      GO TO 110
  360 IF ( M == 1 ) GO TO 490
      IF ( M == 2 ) GO TO 460
      IF ( M == 3 ) GO TO 430
      IF ( M == 4 ) GO TO 400
  370 J = -H
  380 I = H + 1
      H = H + M
      G = J + O
      DO K = I, H
         W(K) = A(J+K)
      ENDDO
      T = S
      J = J + M
  390 DO K = I, H
         W(K) = W(K) + T*A(J+K)
      ENDDO
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 390
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 380
      IF ( H < N ) GO TO 370
      F = 1
      GO TO 110
  400 J = -H
  410 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      D = E + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
      W(E) = (0.0D0,0.0D0)
      W(D) = (0.0D0,0.0D0)
      W(H) = (0.0D0,0.0D0)
  420 W(I) = W(I) + T*A(J+I)
      W(E) = W(E) + T*A(J+E)
      W(D) = W(D) + T*A(J+D)
      W(H) = W(H) + T*A(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 420
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 410
      IF ( H < N ) GO TO 400
      F = 1
      GO TO 110
  430 J = -H
  440 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
      W(E) = (0.0D0,0.0D0)
      W(H) = (0.0D0,0.0D0)
  450 W(I) = W(I) + T*A(J+I)
      W(E) = W(E) + T*A(J+E)
      W(H) = W(H) + T*A(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 450
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 440
      IF ( H < N ) GO TO 430
      F = 1
      GO TO 110
  460 J = -H
  470 T = (1.0D0,0.0D0)
      I = H + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
      W(H) = (0.0D0,0.0D0)
  480 W(I) = W(I) + T*A(J+I)
      W(H) = W(H) + T*A(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 480
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 470
      IF ( H < N ) GO TO 460
      F = 1
      GO TO 110
  490 J = -H
  500 T = (1.0D0,0.0D0)
      I = H + 1
      H = H + M
      G = J + O
      W(I) = (0.0D0,0.0D0)
  510 W(I) = W(I) + T*A(J+I)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 510
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 500
      IF ( H < N ) GO TO 490
      F = 1
      GO TO 110
  520 IF ( L == 2 ) GO TO 530
      IF ( L == 3 ) GO TO 640
      GO TO 750
  530 IF ( M == 1 ) GO TO 620
      IF ( M == 2 ) GO TO 600
      IF ( M == 3 ) GO TO 580
      IF ( M == 4 ) GO TO 560
  540 J = -H
  550 I = H + 1
      H = H + M
      E = J + M
      DO K = I, H
         A(K) = W(J+K) + S*W(E+K)
      ENDDO
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 550
      IF ( H < N ) GO TO 540
      F = 0
      GO TO 110
  560 J = -H
  570 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 570
      IF ( H < N ) GO TO 560
      F = 0
      GO TO 110
  580 J = -H
  590 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 590
      IF ( H < N ) GO TO 580
      F = 0
      GO TO 110
  600 J = -H
  610 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 610
      IF ( H < N ) GO TO 600
      F = 0
      GO TO 110
  620 J = -H
  630 H = H + 1
      E = J + M
      A(H) = W(J+H) + S*W(E+H)
      J = E
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 630
      IF ( H < N ) GO TO 620
      F = 0
      GO TO 110
  640 IF ( M == 1 ) GO TO 730
      IF ( M == 2 ) GO TO 710
      IF ( M == 3 ) GO TO 690
      IF ( M == 4 ) GO TO 670
  650 J = -H
  660 I = H + 1
      H = H + M
      E = J + M
      D = E + M
      T = S*S
      DO K = I, H
         A(K) = W(J+K) + S*W(E+K) + T*W(D+K)
      ENDDO
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 660
      IF ( H < N ) GO TO 650
      F = 0
      GO TO 110
  670 J = -H
  680 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 680
      IF ( H < N ) GO TO 670
      F = 0
      GO TO 110
  690 J = -H
  700 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 700
      IF ( H < N ) GO TO 690
      F = 0
      GO TO 110
  710 J = -H
  720 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      H = H + 1
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 720
      IF ( H < N ) GO TO 710
      F = 0
      GO TO 110
  730 J = -H
  740 H = H + 1
      E = J + M
      D = E + M
      T = S*S
      A(H) = W(J+H) + S*W(E+H) + T*W(D+H)
      J = D
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 740
      IF ( H < N ) GO TO 730
      F = 0
      GO TO 110
  750 IF ( M == 1 ) GO TO 880
      IF ( M == 2 ) GO TO 850
      IF ( M == 3 ) GO TO 820
      IF ( M == 4 ) GO TO 790
  760 J = -H
  770 I = H + 1
      H = H + M
      G = J + O
      DO K = I, H
         A(K) =  W(J+K)
      ENDDO
      T = S
      J = J + M
  780 DO K = I, H
         A(K) = A(K) + T*W(J+K)
      ENDDO
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 780
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 770
      IF ( H < N ) GO TO 760
      F = 0
      GO TO 110
  790 J = -H
  800 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      D = E + 1
      H = H + M
      G = J + O
      A(I) = (0.0D0,0.0D0)
      A(E) = (0.0D0,0.0D0)
      A(D) = (0.0D0,0.0D0)
      A(H) = (0.0D0,0.0D0)
  810 A(I) = A(I) + T*W(J+I)
      A(E) = A(E) + T*W(J+E)
      A(D) = A(D) + T*W(J+D)
      A(H) = A(H) + T*W(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 810
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 800
      IF ( H < N ) GO TO 790
      F = 0
      GO TO 110
  820 J = -H
  830 T = (1.0D0,0.0D0)
      I = H + 1
      E = I + 1
      H = H + M
      G = J + O
      A(I) = (0.0D0,0.0D0)
      A(E) = (0.0D0,0.0D0)
      A(H) = (0.0D0,0.0D0)
  840 A(I) = A(I) + T*W(J+I)
      A(E) = A(E) + T*W(J+E)
      A(H) = A(H) + T*W(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 840
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 830
      IF ( H < N ) GO TO 820
      F = 0
      GO TO 110
  850 J = -H
  860 T = (1.0D0,0.0D0)
      I = H + 1
      H = H + M
      G = J + O
      A(I) = (0.0D0,0.0D0)
      A(H) = (0.0D0,0.0D0)
  870 A(I) = A(I) + T*W(J+I)
      A(H) = A(H) + T*W(J+H)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 870
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 860
      IF ( H < N ) GO TO 850
      F = 0
      GO TO 110
  880 J = -H
  890 I = H + 1
      H = H + M
      G = J + O
      A(I) = W(J+I)
      T = S
      J = J + M
  900 A(I) = A(I) + T*W(J+I)
      T = T*S
      J = J + M
      IF ( J < G ) GO TO 900
      J = J - M
      S3 = ST*S
      S4 = S1 + S3
      S2 = S2 + ((S1-S4)+S3)
      S1 = S4
      S = S1 + S2
      IF ( J+H < N ) GO TO 890
      IF ( H < N ) GO TO 880
      F = 0
      GO TO 110
  910 IF ( F /= 0 ) THEN
          DO I = 1, N
             A(I) = W(I)
          ENDDO
      ENDIF
      RETURN
      END SUBROUTINE FMFFT

      SUBROUTINE FMFORM(FORM,MA,STRING)

!  Convert an FM number (MA) to a character string base 10 (STRING) using character string
!  FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

!  If Iw format is used and MA is not exactly an integer, then the nearest integer to MA is printed.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM,STRING
      INTEGER :: MA
      INTENT (IN) :: FORM,MA
      INTENT (INOUT) :: STRING
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K1,K2,K3,KD,KSAVE,KWD,KWI,LAST,LB,LENGFM,LENGST,LFIRST,ND,NEXP
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMFORM'

      KSAVE = KFLAG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      STRING = ' '
      LENGFM = LEN(FORM)
      LENGST = LEN(STRING)
      KWI = 75
      KWD = 40

      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = LENGST
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          JFORM1 = 2
          JFORM2 = 0
          KWD = KWI + 21
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMNINT(MA,MXY(1))
          IF (MWK(START(MXY(1))+3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFF,KWD)
          ELSE
              DO J = 1, KWD
                 CMBUFF(J) = ' '
              ENDDO
              CMBUFF(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 STRING(J:J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM,'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 2
          JFORM2 = KD
          ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWD)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid showing
!             no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(REAL(MWK(START(MA)+2)))+1)*LOG10(REAL(MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  JFORM1 = 0
                  JFORM2 = ND
                  IF (KWI+50 > LMBUFF) THEN
                      IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
                      ALLOCATE(CMBUFF(KWI+50),STAT=J)
                      IF (J /= 0) THEN
                          CALL FMDEFINE_ERROR(1)
                      ENDIF
                      LMBUFF = KWI + 50
                  ENDIF
                  CALL FMOUT(MA,CMBUFF,KWI)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFF(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFF(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 STRING(J:J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 STRING(JPT:JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM,'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 1
          JFORM2 = KD + 1
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
          DO J = KWI, 1, -1
             IF (J > LENGST) THEN
                 IF (CMBUFF(J) /= ' ') GO TO 110
             ELSE
                 STRING(J:J) = CMBUFF(J)
             ENDIF
          ENDDO
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM,'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,MIN(KWI,LENGST))
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 0
          JFORM2 = KD
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
          DO J = KWI, 1, -1
             IF (J > LENGST) THEN
                 IF (CMBUFF(J) /= ' ') GO TO 110
             ELSE
                 STRING(J:J) = CMBUFF(J)
             ENDIF
          ENDDO
      ELSE
          GO TO 110
      ENDIF
      GO TO 120

!             Error condition.

  110 KFLAG = -8
      DO J = 1, LENGST
         STRING(J:J) = '*'
      ENDDO

  120 KFLAG = KSAVE
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FMFORM

      SUBROUTINE FMFPRT(FORM,MA)

!  Print an FM number (MA) on unit KW using character string FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

!  If Iw format is used and MA is not exactly an integer, then the nearest integer to MA is printed.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      INTEGER :: MA
      CHARACTER(20) :: FORM2
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K,K1,K2,K3,KD,KSAVE,KWD,KWI,LAST,LB,LENGFM,LFIRST,ND,NEXP
      INTENT (IN) :: FORM,MA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMFPRT'

      KSAVE = KFLAG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      LENGFM = LEN(FORM)
      KWI = 75
      KWD = 40

      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          JFORM1 = 2
          JFORM2 = 0
          KWD = KWI + 21
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMNINT(MA,MXY(1))
          IF (MWK(START(MXY(1))+3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFF,KWD)
          ELSE
              DO J = 1, KWD
                 CMBUFF(J) = ' '
              ENDDO
              CMBUFF(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 2
          JFORM2 = KD
          ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWD)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid showing
!             no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(REAL(MWK(START(MA)+2)))+1)*LOG10(REAL(MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  JFORM1 = 0
                  JFORM2 = ND
                  IF (KWI+50 > LMBUFF) THEN
                      IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
                      ALLOCATE(CMBUFF(KWI+50),STAT=J)
                      IF (J /= 0) THEN
                          CALL FMDEFINE_ERROR(1)
                      ENDIF
                      LMBUFF = KWI + 50
                  ENDIF
                  CALL FMOUT(MA,CMBUFF,KWI)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFF(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFF(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 IF (JPT /= J) CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 1
          JFORM2 = KD + 1
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 0
          JFORM2 = KD
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
      ELSE
          GO TO 110
      ENDIF
      GO TO 120

!             Error condition.

  110 KFLAG = -8
      DO J = 1, KWI
         CMBUFF(J) = '*'
      ENDDO

  120 LAST = KWI + 1
      WRITE (FORM2,"(' (6X,',I3,'A1) ')") KSWIDE-7
      IF (KFLAG /= -8) KFLAG = KSAVE
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      DO J = KWI, 1, -1
         IF (CMBUFF(J) /= ' ' .OR. J == 1) THEN
             WRITE (KW,FORM2) (CMBUFF(K),K=1,J)
             NCALL = NCALL - 1
             NUMBER_USED = NUMBER_USED_SAVE
             IF (TEMPV_CALL_STACK == 1) THEN
                 IF (TEMPV(MA) == -1) TEMPV(MA) = -2
             ENDIF
             TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
             RETURN
         ENDIF
      ENDDO
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFPRT

      SUBROUTINE FMGCDI(N1,N2)

!  Find the Greatest Common Divisor of N1 and N2, and return both having been divided by their GCD.
!  Both must be positive.

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: K1,K2,K3,N1,N2
      INTENT (INOUT) :: N1,N2

      K1 = MAX(N1,N2)
      K2 = MIN(N1,N2)
  110 K3 = MOD(K1,K2)
      IF (K3 == 0) THEN
          N1 = N1/K2
          N2 = N2/K2
          RETURN
      ELSE
          K1 = K2
          K2 = K3
          GO TO 110
      ENDIF
      RETURN
      END SUBROUTINE FMGCDI

      SUBROUTINE FMHTBL

!  Initialize two hash tables that are used for character look-up during input conversion.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: J,KPT

      CHARACTER :: LCHARS(21) = (/  &
                  '+','-','0','1','2','3','4','5','6','7','8','9',  &
                  '.','E','D','Q','M','e','d','q','m' /)
      INTEGER :: LTYPES(21) = (/ 1,1,2,2,2,2,2,2,2,2,2,2,3,4,4,4,4,4,4,4,4 /)
      INTEGER :: LVALS(21) = (/ 1,-1,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0,0 /)

      DO J = LHASH1, LHASH2
         KHASHT(J) = 5
         KHASHV(J) = 0
      ENDDO
      DO J = 1, 21
         KPT = ICHAR(LCHARS(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,  &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LCHARS(J),KPT,LHASH1,LHASH2
         ELSE
             KHASHT(KPT) = LTYPES(J)
             KHASHV(KPT) = LVALS(J)
         ENDIF
      ENDDO
      LHASH = 1
      RETURN
      END SUBROUTINE FMHTBL

      SUBROUTINE FMI2M(IVAL,MA)

!  MA = IVAL

!  Convert an integer to FM format.

!  The conversion is exact if IVAL is less than MBASE**NDIG, otherwise the result is
!  an approximation.

!  This routine performs the trace printing for the conversion.  FMIM is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMI2M'
          CALL FMNTRI(2,IVAL,1)

          CALL FMIM(IVAL,MA)

          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMIM(IVAL,MA)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMI2M

      SUBROUTINE FMIM(IVAL,MA)

!  MA = IVAL.  Internal integer conversion routine.

!  The conversion is exact if IVAL is less than MBASE**NDIG, otherwise FMDM is used to get
!  an approximation.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL

      DOUBLE PRECISION :: X
      REAL (KIND(1.0D0)) :: MK,ML,MVAL
      INTEGER :: J,JM2,KB,KB1,N1,NMVAL,NV2
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      N1 = NDIG + 1

      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1
      IF (ABS(IVAL) > MXBASE .OR. NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIMS(IVAL,MA)
          GO TO 120
      ENDIF

!              Check for small IVAL.

      IF (MVAL < MBASE) THEN
          DO J = 3, N1
             MWK(START(MA)+J+1) = 0
          ENDDO
          IF (IVAL >= 0) THEN
              MWK(START(MA)+3) = IVAL
              MWK(START(MA)) = 1
          ELSE
              MWK(START(MA)+3) = -IVAL
              MWK(START(MA)) = -1
          ENDIF
          IF (IVAL == 0) THEN
              MWK(START(MA)+2) = 0
          ELSE
              MWK(START(MA)+2) = 1
          ENDIF
          GO TO 120
      ENDIF

!             Compute and store the digits, right to left.

      MWK(START(MA)+2) = 0
      J = NDIG + 1

  110 MK = AINT (MVAL/MBASE)
      ML = MVAL - MK*MBASE
      MWK(START(MA)+2) = MWK(START(MA)+2) + 1
      MWK(START(MA)+J+1) = ML
      IF (MK > 0) THEN
          MVAL = MK
          J = J - 1
          IF (J >= 2) GO TO 110

!             Here IVAL cannot be expressed exactly.

          X = IVAL
          CALL FMDM(X,MA)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Normalize MA.

      KB = N1 - J + 2
      JM2 = J - 2
      DO J = 2, KB
         MWK(START(MA)+J+1) = MWK(START(MA)+J+JM2+1)
      ENDDO
      KB1 = KB + 1
      IF (KB1 <= N1) THEN
          DO J = KB1, N1
             MWK(START(MA)+J+1) = 0
          ENDDO
      ENDIF

      MWK(START(MA)) = 1
      IF (IVAL < 0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1

  120 MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIM

      SUBROUTINE FMIMS(IVAL,MA)

!  MA = IVAL.  Internal integer conversion routine.

!  This routine is called when M-variable precision is less than Integer precision.  This often
!  happens when single precision is chosen for M-variables.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL

      DOUBLE PRECISION :: X
      REAL (KIND(1.0D0)) :: ML
      INTEGER :: J,JM2,KB,KB1,KBASE,KMK,KVAL,N1
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      N1 = NDIG + 1

!              Check for small IVAL.

      KVAL = ABS(IVAL)
      KBASE = INT(MBASE)
      IF (KVAL < KBASE) THEN
          DO J = 3, N1
             MWK(START(MA)+J+1) = 0
          ENDDO
          IF (IVAL >= 0) THEN
              MWK(START(MA)+3) = IVAL
              MWK(START(MA)) = 1
          ELSE
              MWK(START(MA)+3) = -IVAL
              MWK(START(MA)) = -1
          ENDIF
          IF (IVAL == 0) THEN
              MWK(START(MA)+2) = 0
          ELSE
              MWK(START(MA)+2) = 1
          ENDIF
          GO TO 120
      ENDIF

!             Compute and store the digits, right to left.

      MWK(START(MA)+2) = 0
      J = NDIG + 1

  110 KMK = (KVAL/KBASE)
      ML = KVAL - KMK*KBASE
      MWK(START(MA)+2) = MWK(START(MA)+2) + 1
      MWK(START(MA)+J+1) = ML
      IF (KMK > 0) THEN
          KVAL = KMK
          J = J - 1
          IF (J >= 2) GO TO 110

!             Here IVAL cannot be expressed exactly.

          X = IVAL
          CALL FMDM(X,MA)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Normalize MA.

      KB = N1 - J + 2
      JM2 = J - 2
      DO J = 2, KB
         MWK(START(MA)+J+1) = MWK(START(MA)+J+JM2+1)
      ENDDO
      KB1 = KB + 1
      IF (KB1 <= N1) THEN
          DO J = KB1, N1
             MWK(START(MA)+J+1) = 0
          ENDDO
      ENDIF

      MWK(START(MA)) = 1
      IF (IVAL < 0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -1

  120 MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIMS

      SUBROUTINE FMINP(LINE,MA,LA,LB)

!  Convert an array of characters to floating point multiple precision format.

!  LINE is an A1 character array of length LB to be converted to FM format and returned in MA.
!  LA is a pointer telling the routine where in the array to begin the conversion.  This allows
!     more than one number to be stored in an array and converted in place.
!  LB is a pointer to the last character of the field for that number.

!  The input number may be in integer or any real format.

!  KESWCH = 1  causes input to FMINP with no digits before the exponent letter to be treated as if
!              there were a leading '1'.  This is sometimes better for interactive input:
!              'E7' converts to 10.0**7.
!         = 0  causes a leading zero to be assumed.  This gives compatibility with Fortran:
!              'E7' converts to 0.0.

!  In exponential format the 'E' may also be 'D', 'Q', or 'M'.

!  So that FMINP will convert any output from FMOUT, LINE is tested to see if the input is one of
!  the special symbols +OVERFLOW, -OVERFLOW, +UNDERFLOW, -UNDERFLOW, or UNKNOWN.
!  For user input the abbreviations OVFL, UNFL, UNKN may be used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA

      REAL (KIND(1.0D0)) :: MBSAVE,MXSAV1,MXSAV2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KMN,KOF,KPOWER,KPT,KR_RETRY,KSPEC,KSTART,KSTOP,  &
                 KTYPE,KUF,KUK,KWRNSV,L,ND,NDSAV1,NDSAVE,NEW_MBASE,NEW_NDIG,NTRSAV
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA

      CHARACTER :: KOVFL(4) = (/ 'O','V','F','L' /)
      CHARACTER :: KUNFL(4) = (/ 'U','N','F','L' /)
      CHARACTER :: KUNKN(4) = (/ 'U','N','K','N' /)
      CHARACTER :: LOVFL(4) = (/ 'o','v','f','l' /)
      CHARACTER :: LUNFL(4) = (/ 'u','n','f','l' /)
      CHARACTER :: LUNKN(4) = (/ 'u','n','k','n' /)
      CHARACTER(9) :: NAMEST_SAVE(0:50)
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             To avoid recursion, FMINP calls only internal arithmetic routines (FMADD2,
!             FMMPY2, ...), so no trace printout is done during a call to FMINP.

      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMINP'
      NDSAVE = NDIG
      KASAVE = KACCSW
      KACCSW = 0
      KWRNSV = KWARN
      KWARN = 0
      KR_RETRY = 0
      KFLAG = 0
      MXSAV1 = MXEXP
      MXSAV2 = MXEXP2
      IF (MXEXP < 100000) THEN
          MXEXP  = 201000
          MXEXP2 = 201000
      ELSE
          MXEXP = MXEXP2
      ENDIF

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (LHASH == 0) CALL FMHTBL

!             Check for special symbols.

      KSPEC = 0
      KMN = 1
      KOF = 1
      KUF = 1
      KUK = 1
      DO J = LA, LB
         KPT = ICHAR(LINE(J))
         IF (KPT >= LHASH1 .AND. KPT <= LHASH2) THEN
             KTYPE = KHASHT(KPT)
             IF (KTYPE == 2) GO TO 110
         ENDIF
         IF (LINE(J) == '-') KMN = -1
         IF (LINE(J) == KOVFL(KOF) .OR. LINE(J) == LOVFL(KOF)) THEN
             KOF = KOF + 1
             IF (KOF == 5) THEN
                 KSPEC = 1
                 CALL FMIM(0,MXY(5))
                 MWK(START(MXY(5))+2) = MEXPOV
                 MWK(START(MXY(5))+3) = 1
                 MWK(START(MXY(5))) = KMN
                 MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
                 GO TO 130
             ENDIF
         ENDIF
         IF (LINE(J) == KUNFL(KUF) .OR. LINE(J) == LUNFL(KUF)) THEN
             KUF = KUF + 1
             IF (KUF == 5) THEN
                 KSPEC = 1
                 CALL FMIM(0,MXY(5))
                 MWK(START(MXY(5))+2) = MEXPUN
                 MWK(START(MXY(5))+3) = 1
                 MWK(START(MXY(5))) = KMN
                 MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
                 GO TO 130
             ENDIF
         ENDIF
         IF (LINE(J) == KUNKN(KUK) .OR. LINE(J) == LUNKN(KUK)) THEN
             KUK = KUK + 1
             IF (KUK == 5) THEN
                 KSPEC = 1
                 CALL FMIM(0,MXY(5))
                 MWK(START(MXY(5))+2) = MUNKNO
                 MWK(START(MXY(5))+3) = 1
                 MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
                 GO TO 130
             ENDIF
         ENDIF
      ENDDO

!             Increase the working precision.

  110 K = NGRD52
      NDIG = MAX(NDIG+K,2)

  120 IF (KR_RETRY >= 1) THEN
          NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      NDSAV1 = NDIG
      KSTART = LA
      KSTOP = LB

!             If MBASE is a power of ten then call FMINP2 for faster input conversion.

      KPOWER = INT(LOG10(DBLE(MBASE)) + 0.5D0)
      IF (MBASE == 10**KPOWER) THEN
          K = 0
          DO J = LA, LB
             IF (LINE(J) /= ' ') THEN
                 DO L = LB, LA, -1
                    IF (LINE(L) /= ' ') THEN
                        K = (L-J+1)*LOG(10.0D0)/LOG(DBLE(MBASE))
                        EXIT
                    ENDIF
                 ENDDO
                 EXIT
             ENDIF
          ENDDO
          IF (NDIG <= K+9) THEN
              NDIG = K + 10
              NDSAV1 = NDIG
          ENDIF
          CALL FMIM(0,MXY(1))
          CALL FMIM(0,MXY(2))
          CALL FMIM(0,MXY(3))
          CALL FMIM(0,MXY(4))
          CALL FMIM(0,MXY(5))
          CALL FMINP2(MXY,LINE,KSTART,KSTOP,KPOWER)
          IF (MWK(START(MXY(5))+2) == MUNKNO) GO TO 140
          GO TO 130
      ENDIF

!             If MBASE is not a power of ten then call FMINP2 first using a power of ten base,
!             then change to base MBASE.

      MBSAVE = MBASE
      KPOWER = INT(LOG10(DBLE(MXBASE)/4) + 0.5D0)
      MBASE = 10**KPOWER
      NDIG = NDSAV1*LOG(DBLE(MBSAVE))/LOG(DBLE(MBASE)) + 3
      K = 0
      DO J = LA, LB
         IF (LINE(J) /= ' ') THEN
             DO L = LB, LA, -1
                IF (LINE(L) /= ' ') THEN
                    K = (L-J+1)*LOG(10.0D0)/LOG(DBLE(MBASE))
                    EXIT
                ENDIF
             ENDDO
             EXIT
         ENDIF
      ENDDO
      IF (NDIG <= K+9) THEN
          NDIG = K + 10
      ENDIF
      CALL FMCONS
      CALL FMIM(0,MXY(1))
      CALL FMIM(0,MXY(2))
      CALL FMIM(0,MXY(3))
      CALL FMIM(0,MXY(4))
      CALL FMIM(0,MXY(5))
      J = MXEXP2
      K = J*LOG(DBLE(MBSAVE))/LOG(DBLE(MBASE)) + 0.5
      MXEXP2 = K
      CALL FMINP2(MXY,LINE,KSTART,KSTOP,KPOWER)
      MXEXP2 = J
      NEW_MBASE = MBSAVE
      NEW_NDIG = MAX(NDSAV1,NDIG*NINT(LOG(DBLE(MBASE))/LOG(DBLE(MBSAVE))))
      ND = 2
      DO J = NDIG, 3, -1
         IF (MWK(START(MXY(5))+J+2) /= 0) THEN
             ND = J
             EXIT
         ENDIF
      ENDDO
      NDIG = ND
      NTRSAV = NTRACE
      NTRACE = 0
      J = NCALL
      NAMEST_SAVE(0:NCALL) = NAMEST(0:NCALL)
      NCALL = 0
      IF (ABS(MWK(START(MXY(5))+2)) < MEXPOV) THEN
          CALL FMCHANGEBASE(MXY(5),MXY(4),NEW_MBASE,NEW_NDIG)
      ELSE
          CALL FMEQU(MXY(5),MXY(4),NDIG,NEW_NDIG)
      ENDIF
      NCALL = J
      NAMEST(0:NCALL) = NAMEST_SAVE(0:NCALL)
      NTRACE = NTRSAV
      MBASE = MBSAVE
      NDIG = NEW_NDIG
      CALL FMCONS
      CALL FMEQ(MXY(4),MXY(5))
      IF (MWK(START(MXY(5))+2) == MUNKNO) GO TO 140

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (KSPEC == 0) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF
      MXEXP = MXSAV1
      MXEXP2 = MXSAV2
      IF (INT(MBASE-AINT (MBASE/2)*2) == 0) THEN
          CALL FMEQU(MXY(5),MA,NDIG,NDSAVE)
      ELSE
          CALL FMEQU(MXY(5),MA,NDIG-1,NDSAVE)
      ENDIF
      IF (KSPEC == 0) THEN
          IF (MWK(START(MA)+2) == MUNKNO) GO TO 140
      ELSE
          KFLAG = 0
      ENDIF
      NDIG = NDSAVE
      KACCSW = KASAVE
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = 0
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      IF (MWK(START(MA)+3) == 0) MWK(START(MA)) = 1
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

!             Error in converting the number.

  140 CALL FMIM(0,MXY(5))
      CALL FMEQU(MXY(5),MA,NDIG,NDSAVE)
      MWK(START(MA)+2) = MUNKNO
      MWK(START(MA)+3) = 1
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      KWARN = KWRNSV
      KFLAG = -7
      NAMEST(NCALL) = 'FMINP'
      CALL FMWARN
      NDIG = NDSAVE
      KACCSW = KASAVE
      MXEXP = MXSAV1
      MXEXP2 = MXSAV2
      IF (KFLAG == 1) KFLAG = 0
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      IF (MWK(START(MA)+3) == 0) MWK(START(MA)) = 1
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMINP

      SUBROUTINE FMINP2(MXY,LINE,KSTART,KSTOP,KPOWER)

!  Internal routine for input conversion for a power of ten MBASE.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MXY(5)
      INTEGER :: KSTART,KSTOP,KPOWER
      CHARACTER :: LINE(KSTOP)

      INTEGER :: J,JSTATE,K,KDFLAG,KEXP,KF1,KF1DIG,KF2,KF2DIG,KF2PT,KNZDIG,KPT,KSHIFT,KSIGN,  &
                 KSIGNX,KTYPE,KVAL,LARGE,LNZD
      INTENT (IN) :: LINE,KSTART,KSTOP,KPOWER
      INTENT (INOUT) :: MXY

!  Simulate a finite-state automaton to scan the input line and build the number.
!  States of the machine:

!  1.  Initial entry to the subroutine
!  2.  Sign of the number
!  3.  Scanning digits before a decimal point
!  4.  Decimal point
!  5.  Scanning digits after a decimal point
!  6.  E, D, Q, or M -- precision indicator before the exponent
!  7.  Sign of the exponent
!  8.  Scanning exponent
!  9.  Syntax error

!  Character types recognized by the machine:

!  1.  Sign (+,-)
!  2.  Numeral (0,1,...,9)
!  3.  Decimal point (.)
!  4.  Precision indicator (E,D,Q,M)
!  5.  Illegal character for number

!  All blanks are ignored.  The analysis of the number proceeds as follows:  If the simulated
!  machine is in state JSTATE and a character of type JTYPE is encountered the new state of the
!  machine is given by JTRANS(JSTATE,JTYPE).

!  In this initialization, the array is loaded by columns.

!          State   1  2  3  4  5  6  7  8

      INTEGER :: JTRANS(8,4) = RESHAPE(  (/     &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8,4 /) )

      JSTATE = 1
      KDFLAG = 0
      KSIGN = 1
      KSIGNX = 1
      KF1 = 0
      KNZDIG = 0
      LNZD = 0
      KF1DIG = 0
      KF2 = 0
      KF2DIG = 0
      KF2PT = 2
      KEXP = 0
      LARGE = INT(INTMAX/10)

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (LINE(J) == ' ') CYCLE
         KPT = ICHAR(LINE(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,  &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LINE(J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = KHASHT(KPT)
             KVAL  = KHASHV(KPT)
         ENDIF

         IF (KTYPE >= 5) GO TO 110

         JSTATE = JTRANS(JSTATE,KTYPE)

         SELECT CASE (JSTATE)

!             State 2.  Sign of the number.

         CASE (2)
             KSIGN = KVAL

!             State 3.  Digits before a decimal point.

         CASE (3)
             KDFLAG = 1
             KF1 = 10*KF1 + KVAL
             IF (KVAL > 0) LNZD = 1
             IF (KVAL > 0 .OR. KNZDIG /= 0) THEN
                 KNZDIG = 1
                 KF1DIG = KF1DIG + 1
             ENDIF
             IF (KF1DIG == KPOWER) THEN
                 MWK(START(MXY(2))+2) = MWK(START(MXY(2))+2) + 1
                 K = MWK(START(MXY(2))+2)
                 IF (K < NDIG) THEN
                     MWK(START(MXY(2))+K+2) = KF1
                 ENDIF
                 KF1 = 0
                 KF1DIG = 0
             ENDIF

!             State 4.  Decimal point

         CASE (4)
             CYCLE

!             State 5.  Digits after a decimal point.

         CASE (5)
             KDFLAG = 1
             IF (KVAL > 0) LNZD = 1
             IF (KF2PT > NDIG+1) CYCLE
             KF2 = 10*KF2 + KVAL
             KF2DIG = KF2DIG + 1
             IF (KF2DIG == KPOWER) THEN
                 MWK(START(MXY(3))+KF2PT+1) = KF2
                 IF (KF2 == 0 .AND. KF2PT == 2) THEN
                     MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) - 1
                 ELSE
                     KF2PT = KF2PT + 1
                 ENDIF
                 KF2 = 0
                 KF2DIG = 0
             ENDIF

!             State 6.  Precision indicator.

         CASE (6)
             IF (KDFLAG == 0 .AND. KESWCH == 1) THEN
                 LNZD = 1
                 CALL FMIM(1,MXY(2))
             ENDIF

!             State 7.  Sign of the exponent.

         CASE (7)
             KSIGNX = KVAL

!             State 8.  Digits of the exponent.

         CASE (8)
             IF (KEXP >= LARGE) THEN
                 IF (LNZD == 0) THEN
                     CALL FMIM(0,MXY(5))
                     RETURN
                 ENDIF
                 CALL FMINP3(LINE,KSTART,KSTOP,MXY(5))
                 RETURN
             ENDIF
             KEXP = 10*KEXP + KVAL
             IF (KEXP >= 0.75D0*MXEXP2*DLOGMB/DLOGTN .AND. LNZD /= 0) THEN
                 CALL FMINP3(LINE,KSTART,KSTOP,MXY(5))
                 RETURN
             ENDIF

         CASE DEFAULT
             GO TO 110

         END SELECT

      ENDDO

!             Form the number and return.  MXY(5) = KSIGN*(MXY(2) + MXY(3))*10.0**(KSIGNX*KEXP)

      IF (KF1DIG /= 0) THEN
          MWK(START(MXY(2))+2) = MWK(START(MXY(2))+2) + 1
          KSHIFT = 10**(KPOWER-KF1DIG)
          K = MWK(START(MXY(2))+2)
          IF (K < NDIG) MWK(2+INT(K)+START(MXY(2))) = KF1*KSHIFT
          IF (KSHIFT > 1) THEN
              CALL FMDIVN_R1(MXY(2),KSHIFT)
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))+3) == 0) THEN
          MWK(START(MXY(2))) = 1
          MWK(START(MXY(2))+2) = 0
      ELSE
          MWK(START(MXY(2))) = 1
      ENDIF

      IF (KF2DIG /= 0) THEN
          KSHIFT = 10**(KPOWER-KF2DIG)
          MWK(START(MXY(3))+KF2PT+1) = KF2*KSHIFT
      ENDIF
      IF (MWK(START(MXY(3))+3) == 0) THEN
          MWK(START(MXY(3))) = 1
          MWK(START(MXY(3))+2) = 0
      ELSE
          MWK(START(MXY(3))) = 1
      ENDIF

      IF (KEXP /= 0) THEN
          IF (KSIGNX == 1) THEN
              MWK(START(MXY(4))+2) = INT(KEXP/KPOWER) + 1
              MWK(START(MXY(4))+3) = 10**(MOD(KEXP,KPOWER))
          ELSE
              MWK(START(MXY(4))+2) = -INT((KEXP-1)/KPOWER)
              KSHIFT = 10**(MOD(KEXP,KPOWER))
              IF (KSHIFT > 1) THEN
                  MWK(START(MXY(4))+3) = MBASE/KSHIFT
              ELSE
                  MWK(START(MXY(4))+3) = 1
              ENDIF
          ENDIF
      ENDIF

      CALL FMADD2(MXY(2),MXY(3),MXY(5))

      IF (KEXP > 0) CALL FMMPY2_R1(MXY(5),MXY(4))
      MWK(START(MXY(5))) = KSIGN

      RETURN

!             Error in converting the number.

  110 CALL FMIM(0,MXY(5))
      MWK(START(MXY(5))+2) = MUNKNO
      MWK(START(MXY(5))+3) = 1
      MWK(START(MXY(5))) = 1
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      KFLAG = -7
      RETURN
      END SUBROUTINE FMINP2

      SUBROUTINE FMINP3(LINE,KSTART,KSTOP,MA)

!  Internal routine to see if the input character string in LINE would overflow or underflow
!  with the current base and precision.

!  MA is returned as + or - over/underflow or unknown.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KSTART,KSTOP,MA
      CHARACTER :: LINE(KSTOP)
      INTEGER :: J,JSTATE,KDIGFL,KPT,KSIGN,KSIGNX,KTYPE,KVAL,N1,N2
      DOUBLE PRECISION :: X,F1,F2,FEXP,FLARGE

      INTEGER :: JTRANS(8,4) = RESHAPE(  (/    &
                   2, 9, 7, 7, 7, 7, 9, 9,  &
                   3, 3, 3, 5, 5, 8, 8, 8,  &
                   4, 4, 4, 9, 9, 9, 9, 9,  &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8,4 /) )

      CHARACTER :: KBLANK = ' '
      INTENT (IN) :: LINE,KSTART,KSTOP
      INTENT (INOUT) :: MA

!             X will approximate the log of the magnitude of the number represented by LINE.

      JSTATE = 1
      KSIGN = 1
      F1 = 0
      F2 = 0
      N1 = 0
      N2 = 0
      KSIGNX = 1
      FEXP = 0
      FLARGE = HUGE(F1)/31

!             KDIGFL will be 1 if any digits are found before 'E'.

      KDIGFL = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (LHASH == 0) CALL FMHTBL

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (LINE(J) == KBLANK) CYCLE
         KPT = ICHAR(LINE(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,  &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LINE(J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = KHASHT(KPT)
             KVAL  = KHASHV(KPT)
         ENDIF
         IF (KTYPE >= 5) GO TO 110

         JSTATE = JTRANS(JSTATE,KTYPE)

         SELECT CASE (JSTATE)

!             State 2.  Sign of the number.

         CASE (2)
             KSIGN = KVAL

!             State 3.  Digits before a decimal point.

         CASE (3)
             KDIGFL = 1
             IF (F1 < FLARGE) THEN
                 F1 = 10.0D0*F1 + KVAL
             ELSE
                 N1 = N1 + 1
             ENDIF

!             State 4.  Decimal point

         CASE (4)
             CYCLE

!             State 5.  Digits after a decimal point.

         CASE (5)
             KDIGFL = 1
             IF (F2 < FLARGE) THEN
                 F2 = 10.0D0*F2 + KVAL
                 N2 = N2 + 1
             ENDIF

!             State 6.  Precision indicator.

         CASE (6)
             IF (KDIGFL == 0) F1 = 1.0D0

!             State 7.  Sign of the exponent.

         CASE (7)
             KSIGNX = KVAL

!             State 8.  Digits of the exponent.

         CASE (8)
             IF (FEXP < FLARGE) THEN
                 FEXP = 10*FEXP + KVAL
             ENDIF

         CASE DEFAULT
             GO TO 110

         END SELECT

      ENDDO

!             Check to see if the number would over/underflow.

      IF (F1 > 0) THEN
          X = LOG(F1) + (FEXP+N1)*LOG(10.0D0)
      ELSE IF (F2 > 0) THEN
          X = LOG(F2) - N2*LOG(10.0D0) + FEXP*LOG(10.0D0)
      ENDIF
      IF (X > (MXEXP2/2.0D0)*LOG(DBLE(MBASE)) .AND. KSIGNX > 0) THEN
          CALL FMIM(0,MA)
          MWK(START(MA)+2) = MEXPOV
          MWK(START(MA)+3) = 1
          MWK(START(MA)) = KSIGN
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          KFLAG = -5
      ELSE IF (X > (MXEXP2/2.0D0)*LOG(DBLE(MBASE)) .AND. KSIGNX < 0) THEN
          CALL FMIM(0,MA)
          MWK(START(MA)+2) = MEXPUN
          MWK(START(MA)+3) = 1
          MWK(START(MA)) = KSIGN
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          KFLAG = -6
      ELSE
          GO TO 110
      ENDIF

      RETURN

!             Error in converting the number.

  110 CALL FMIM(0,MA)
      MWK(START(MA)+2) = MUNKNO
      MWK(START(MA)+3) = 1
      MWK(START(MA)) = 1
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      KFLAG = -7
      RETURN
      END SUBROUTINE FMINP3

      SUBROUTINE FMINPUT_ERROR(J)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: J
      WRITE (*,*) ' '
      WRITE (*,*) ' '
      WRITE (*,*) ' ***  Error in a program using the FM package  ***'
      WRITE (*,*) ' '
      WRITE (*,*) ' A multiple precision number is undefined in an expression or as an input'
      WRITE (*,*) ' argument to a subprogram.'
      WRITE (*,*) ' '
      IF (J == 1) THEN
          WRITE (*,*) ' Negative variable index.'
          WRITE (*,*) ' This usually means trying to use an undefined multiple precision variable'
      ELSE IF (J == 2) THEN
          WRITE (*,*) ' (Variable index between temp zone and saved zone)'
      ELSE IF (J == 3) THEN
          WRITE (*,*) ' (Variable index larger than SIZE_OF_START)'
      ELSE IF (J == 4) THEN
          WRITE (*,*) ' (START(.) is not between 0 and SIZE_OF_MWK'
      ELSE IF (J == 5) THEN
          WRITE (*,*) ' (SIZE_OF(.) is not between 0 and SIZE_OF_MWK'
      ELSE IF (J == 6) THEN
          WRITE (*,*) ' (START(.)+SIZE_OF(.) is greater than SIZE_OF_MWK'
      ELSE IF (J == 7) THEN
          WRITE (*,*) ' (SIZE_OF(.) < NDIG+3 -- too small for current precision'
      ENDIF
      WRITE (*,*) ' '
      WRITE (*,*) ' To help isolate the code that caused this error, this error message is followed'
      WRITE (*,*) ' by an illegal out-of-range array reference.  Many compilers have an option for'
      WRITE (*,*) ' checking array bounds and will give a traceback with the line number in the'
      WRITE (*,*) ' calling program where the error originated.'
      WRITE (*,*) ' '
      WRITE (*,*) ' The program has been stopped.'
      WRITE (*,*) ' '
      IF (MWK(-NDIG) > -314159) WRITE (*,*) ' Negative array subscript.'
      STOP
      END SUBROUTINE FMINPUT_ERROR

      SUBROUTINE FMINT(MA,MB)

!  MB = INT(MA)

!  The integer part of MA is computed and returned in MB as a multiple precision floating
!  point number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MACMAX
      INTEGER :: J,KA,KB,KRESLT,N1
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMINT'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMARGS('FMINT    ',1,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              CALL FMRSLT(MA,MA,MB,KRESLT)
              IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF

      N1 = NDIG + 1

!             If MA is less than one in magnitude, return zero.

      IF (MWK(START(MA)+2) <= 0) THEN
          DO J = 1, N1
             MWK(START(MB)+J+1) = 0
          ENDDO
          GO TO 110
      ENDIF

!             If the radix point is off the right end of MA then MA is already an integer.
!             Return MA.

      IF (MWK(START(MA)+2) >= NDIG) THEN
          DO J = 1, N1
             MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
          ENDDO
          GO TO 110
      ENDIF

!             Here MA has both integer and fraction parts.  Replace the digits right of the
!             radix point by zeros.

      KA = INT(MWK(START(MA)+2)) + 2
      KB = KA - 1
      DO J = 1, KB
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO

      DO J = KA, N1
         MWK(START(MB)+J+1) = 0
      ENDDO

  110 IF (KACCSW == 1) THEN
          MACMAX = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MACMAX)
      ELSE
          MWK(START(MB)+1) = MACCA
      ENDIF
      MWK(START(MB)) = MWK(START(MA))
      IF (MWK(START(MB)+3) == 0) MWK(START(MB)) = 1
      IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMINT

      SUBROUTINE FMIPWR(MA,IVAL,MB)

!  MB = MA ** IVAL

!  This routine performs the trace printing for integer power.  FMIPWR2 is used to do
!  the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMIPWR'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)

          CALL FMIPWR2(MA,IVAL,MB)

          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMIPWR2(MA,IVAL,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIPWR

      SUBROUTINE FMIPWR2(MA,IVAL,MB)

!  MB = MA ** IVAL

!  Raise an FM number to an integer power.
!  The binary multiplication method used requires an average of 1.5 * LOG2(IVAL) multiplications.
!  MA may be negative.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MACMAX
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JSIGN,K,KL,KR_RETRY,KWRNSV,NDSAVE
      REAL :: XVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. (IVAL <= 0 .AND. MWK(START(MA)+3) == 0)) THEN
          KFLAG = -4
          IF (IVAL <= 0 .AND. MWK(START(MA)+3) == 0) THEN
              NAMEST(NCALL) = 'FMIPWR'
              CALL FMWARN
          ENDIF
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(1,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          KWRNSV = KWARN
          KWARN = 0
          IF (IVAL == 1) THEN
              CALL FMEQ(MA,MB)
          ELSE
              CALL FMIM(1,MXY(1))
              CALL FMDIV2(MXY(1),MA,MB)
          ENDIF
          KWARN = KWRNSV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          JSIGN = 1
          IF (MWK(START(MA)) < 0) JSIGN = -1
          CALL FMIM(0,MB)
          IF (IVAL > 0) THEN
              CALL FMIM(1,MB)
              MWK(START(MB)+2) = MEXPOV
              MWK(START(MB)+3) = 1
              MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
              MWK(START(MB)) = JSIGN**MOD(IVAL,2)
              KFLAG = -5
          ELSE
              CALL FMIM(1,MB)
              MWK(START(MB)+2) = MEXPUN
              MWK(START(MB)+3) = 1
              MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
              MWK(START(MB)) = JSIGN**MOD(IVAL,2)
              KFLAG = -6
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          JSIGN = 1
          IF (MWK(START(MA)) < 0) JSIGN = -1
          CALL FMIM(0,MB)
          IF (IVAL > 0) THEN
              CALL FMIM(1,MB)
              MWK(START(MB)+2) = MEXPUN
              MWK(START(MB)+3) = 1
              MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
              MWK(START(MB)) = JSIGN**MOD(IVAL,2)
              KFLAG = -6
          ELSE
              CALL FMIM(1,MB)
              MWK(START(MB)+2) = MEXPOV
              MWK(START(MB)+3) = 1
              MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
              MWK(START(MB)) = JSIGN**MOD(IVAL,2)
              KFLAG = -5
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KR_RETRY = 0

!             Increase the working precision.

      NDSAVE = NDIG
  110 IF (NCALL == 1) THEN
          XVAL = ABS(IVAL)
          K = INT((5.0*REAL(DLOGTN) + LOG(XVAL))/ALOGMB + 2.0)
          NDIG = MAX(NDIG+K,2)
          IF (KR_RETRY >= 1) THEN
              NDIG = MAX(NDIG,2*NDSAVE+10)
          ENDIF
      ELSE
          XVAL = ABS(IVAL)
          IF (XVAL > 10.0 .OR. REAL(MBASE) <= 999.0) THEN
              K = INT(LOG(XVAL)/ALOGMB + 1.0)
              NDIG = NDIG + K
          ENDIF
      ENDIF

!             Initialize.

      K = ABS(IVAL)
      KWRNSV = KWARN
      KWARN = 0
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

!             Handle small exponents by hand.

      IF (K == 2) THEN
          CALL FMSQR2(MXY(1),MXY(2))
          GO TO 130
      ENDIF
      IF (K == 3) THEN
          CALL FMSQR2(MXY(1),MXY(2))
          CALL FMMPY2_R1(MXY(2),MXY(1))
          GO TO 130
      ENDIF
      IF (K == 4) THEN
          CALL FMSQR2(MXY(1),MXY(2))
          CALL FMSQR2_R1(MXY(2))
          GO TO 130
      ENDIF
      IF (K == 5) THEN
          CALL FMSQR2(MXY(1),MXY(2))
          CALL FMSQR2_R1(MXY(2))
          CALL FMMPY2_R1(MXY(2),MXY(1))
          GO TO 130
      ENDIF

      IF (MOD(K,2) == 0) THEN
          CALL FMIM(1,MXY(2))
      ELSE
          CALL FMEQ(MXY(1),MXY(2))
      ENDIF

!             This is the multiplication loop.

  120 K = K/2
      CALL FMSQR2_R1(MXY(1))
      IF (MOD(K,2) == 1) CALL FMMPY2_R2(MXY(1),MXY(2))
      IF (K > 1) GO TO 120

!             Invert if the exponent is negative.

  130 IF (IVAL < 0) THEN
          CALL FMIM(1,MXY(1))
          CALL FMDIV2_R2(MXY(1),MXY(2))
      ENDIF
      KWARN = KWRNSV

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Round the result and return.

      CALL FMEQU(MXY(2),MB,NDIG,NDSAVE)
      NDIG = NDSAVE
      IF (KACCSW == 1) THEN
          MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MWK(START(MB)+1),MACCA,MACMAX)
      ELSE
          MWK(START(MB)+1) = MACCA
      ENDIF
      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMIPWR'
          CALL FMWARN
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIPWR2

      SUBROUTINE FMLG10(MA,MB)

!  MB = LOG10(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      REAL :: X
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) < 0) THEN
          CALL FMENTR('FMLG10   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMLG10'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF

      IF (MWK(START(MA)+2) == 0 .OR. MWK(START(MA)+2) == 1) THEN
          X = REAL(MBASE)
          X = X**(INT(MWK(START(MA)+2))-1)*(REAL(MWK(START(MA)+3))+REAL(MWK(START(MA)+4))/X)
      ELSE
          X = 2.0
      ENDIF
      IF (X > 0.9 .AND. X < 1.1) NDIG = NDIG + 1

      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

      CALL FMLN(MXY(2),MXY(3))
      IF (MBASE /= MBSLI .OR. NDIG > NDIGLI) THEN
          CALL FMLNI(10,MXY(1))
      ELSE
          CALL FMADD(MLN2,MLN5,MXY(1))
      ENDIF
      CALL FMDIV(MXY(3),MXY(1),MXY(2))

!             Round the result and return.

      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(2))+3))+1))/0.69315)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLG10

      SUBROUTINE FMLN(MA,MB)

!  MB = LOG(MA)     (Natural logarithm)

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: Y
      INTEGER :: MA,MB
      INTEGER :: NSTACK(49)
      REAL (KIND(1.0D0)) :: MA1,MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,IVAL,J,K,K2,K2EXP,KASAVE,KBOT,KL,KM1,KR_RETRY,KOVUN,KRESLT,KSCALE,KST,  &
                 KWRNSV,L,LAST,N1,N3,NDSAV1,NDSAVE,NDSV
      REAL :: X
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) < 0) THEN
          CALL FMENTR('FMLN     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMLN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF

!             If MA is close to 1, use the Taylor series:
!                   LN(1+X) = X - X**2/2 + X**3/3 - ...
!             This is faster for small X and avoids cancellation error.

!             This method is faster for moderate sized NDIG, but is asymptotically slower by a
!             factor of NDIG**(2/3) than using Newton and FMEXP.  For MBASE=10,000 the Taylor
!             series is faster for NDIG less than about 150 (and is used only when MA is between
!             .9999 and 1.0001).

      IF (MWK(START(MA)+2) == 0 .OR. MWK(START(MA)+2) == 1) THEN
          X = REAL(MBASE)
          X = X**(INT(MWK(START(MA)+2))-1)*(REAL(MWK(START(MA)+3))+REAL(MWK(START(MA)+4))/X)
      ELSE
          X = 2.0
      ENDIF
      IF (X > 0.9999 .AND. X <= 1.0001) THEN
          MACCA = MWK(START(MA)+1)
          CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
          MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)

          CALL FMI2M(-1,MXY(1))
          CALL FMADD_R1(MXY(3),MXY(1))

!             The sum will be done as two concurrent series.

          NDSAV1 = NDIG
          CALL FMEQ(MXY(3),MXY(4))
          CALL FMDIVI(MXY(3),2,MXY(5))
          CALL FMSQR(MXY(3),MXY(6))
          CALL FMEQ(MXY(3),MXY(2))
          KBOT = 2

  120     KBOT = KBOT + 1
          CALL FMMPY_R1(MXY(2),MXY(6))
          CALL FMDIVI(MXY(2),KBOT,MXY(1))
          NDIG = NDSAV1
          CALL FMADD_R1(MXY(4),MXY(1))
          NDIG = MAX(NGRD22,NDSAV1 - INT(MWK(START(MXY(4))+2)-MWK(START(MXY(1))+2)))
          KBOT = KBOT + 1
          CALL FMDIVI(MXY(2),KBOT,MXY(1))
          NDIG = NDSAV1
          CALL FMADD_R1(MXY(5),MXY(1))
          NDIG = MAX(NGRD22,NDSAV1 - INT(MWK(START(MXY(4))+2)-MWK(START(MXY(1))+2)))
          IF (KFLAG /= 1) GO TO 120

          NDIG = NDSAV1
          CALL FMMPY_R1(MXY(5),MXY(3))
          CALL FMSUB(MXY(4),MXY(5),MXY(6))
          GO TO 150
      ENDIF

      MA1 = MWK(START(MA)+2)
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)

!             Compute IEXTRA, the number of extra digits required.

      CALL FMI2M(1,MXY(4))
      CALL FMSUB_R1(MXY(4),MXY(5))
      IEXTRA = MAX(0-INT(MWK(START(MXY(4))+2)),0)
      IF (X > 0.9 .AND. X < 1.1) IEXTRA = IEXTRA + 1
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(5),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Check to see if the argument is a small integer.  If so use FMLNI.

      KM1 = 0

      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(5),IVAL)
      KWARN = KWRNSV
      IF (KFLAG == 0 .AND. IVAL < MXBASE) THEN
          CALL FMLNI(IVAL,MXY(6))
          GO TO 150
      ENDIF

!             See if the argument can be scaled to a small integer.

      N3 = NDIG + 3
      N1 = NDIG + 1
      DO J = 2, N1
         IF (MWK(START(MXY(5))+N3-J+1) /= 0) THEN
             LAST = N3 - J - 1
             GO TO 130
         ENDIF
      ENDDO

  130 KSCALE = INT(MA1) - LAST
      MWK(START(MXY(5))+2) = LAST
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(5),IVAL)
      KWARN = KWRNSV
      IF (KFLAG == 0 .AND. IVAL < MXBASE) THEN
          CALL FMLNI(IVAL,MXY(4))
          IF (IVAL == 1) KM1 = 1
          K2EXP = 0
          GO TO 140
      ENDIF

!             For the non-integer case, scale the argument to lie between e/2 and e to speed up
!             the calls to FMEXP.

      MWK(START(MXY(5))+2) = 1
      KSCALE = INT(MA1) - 1
      CALL FMM2DP(MXY(5),Y)
      K2EXP = INT(LOG(2.0*REAL(Y)/2.71828)/0.693147)
      IF (Y < 1.359141) THEN
          K2EXP = -1
          CALL FMMPYI_R1(MXY(5),2)
          Y = 2.0D0*Y
      ELSE
          K2 = 2**K2EXP
          CALL FMDIVI_R1(MXY(5),K2)
          Y = Y/K2
      ENDIF

!             Generate the initial approximation.

      CALL FMI2M(0,MXY(2))
      CALL FMI2M(0,MXY(6))
      Y = LOG(Y)
      CALL FMDPM(Y,MXY(4))
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMEXP(MXY(4),MXY(6))
         CALL FMSUB(MXY(5),MXY(6),MXY(2))
         CALL FMDIV_R2(MXY(2),MXY(6))
         CALL FMADD_R1(MXY(4),MXY(6))
      ENDDO
      MWK(START(MXY(4))+1) = NINT(NDIG*ALOGM2)

!             Compute LN(MBASE**KSCALE).

  140 IF ((MBSLB /= MBASE .OR. NDIGLB < NDIG) .AND. KSCALE /= 0) THEN
          NDSV = NDIG
          NDIG = NDIG + 2 + NDIG/100
          IF (MLBSAV > 0) THEN
              IF (SIZE_OF(MLBSAV) < NDIG+3) THEN
                  L = -3
                  CALL FMDEFINE(L)
                  TEMPV(MLBSAV) = -6
                  MLBSAV = L
              ENDIF
          ENDIF
          CALL FMLNI(INT(MBASE),MLBSAV)
          MBSLB = MBASE
          NDIGLB = NDIG
          IF (ABS(MWK(START(MLBSAV)+2)) > 10) NDIGLB = 0
          NDIG = NDSV
      ENDIF

      IF (KSCALE /= 0 .AND. KM1 == 0) THEN
          CALL FMMPYI(MLBSAV,KSCALE,MXY(6))
          CALL FMADD_R2(MXY(4),MXY(6))
      ELSE IF (KSCALE /= 0 .AND. KM1 == 1) THEN
          CALL FMMPYI(MLBSAV,KSCALE,MXY(6))
      ELSE IF (KSCALE == 0 .AND. KM1 == 0) THEN
          CALL FMEQ(MXY(4),MXY(6))
      ELSE IF (KSCALE == 0 .AND. KM1 == 1) THEN
          CALL FMI2M(0,MXY(6))
      ENDIF

      IF (K2EXP /= 0) THEN
          IF (MBASE /= MBSLI .OR. NDIG > NDIGLI) THEN
              CALL FMLNI(2,MXY(4))
          ENDIF
          CALL FMMPYI(MLN2,K2EXP,MXY(4))
          CALL FMADD_R1(MXY(6),MXY(4))
      ENDIF

!             Round the result and return.

  150 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(6))+3))+1))/0.69315)
      MWK(START(MXY(6))+1) = MIN(MWK(START(MXY(6))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(6))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLN

      SUBROUTINE FMLNI(IVAL,MA)

!  MA = LOG(IVAL)

!  Compute the natural logarithm of an integer IVAL.

!  If IVAL has only powers of 2, 3, 5, and 7 in its factorization then FMLNI is faster than FMLN.
!  Otherwise, if IVAL >= MXBASE (i.e., IVAL does not fit in 1/2 word) then FMLN is usually faster.

!  Use FMLN instead of FMLNI if 10*IVAL would cause integer overflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      CHARACTER(155) :: STRING
      INTEGER :: INT2,J,J2,J3,J5,J7,JTEMP2,JTEMP3,JTEMP5,JTEMP7,K,K2,K3,K5,K7,KASAVE,KDELTA,KL,  &
                 KR_RETRY,L,LAST,N,ND,NDMB,NDSAVE,NDSV,NT
      REAL :: XVAL
      DOUBLE PRECISION :: ERR
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMLNI'
      IF (NTRACE /= 0) CALL FMNTRI(2,IVAL,1)

!             Check for special cases.

      IF (IVAL <= 0) THEN
          KFLAG = -4
          CALL FMWARN
          CALL FMST2M('UNKNOWN',MA)
          IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 1) THEN
          CALL FMI2M(0,MA)
          IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = NGRD52
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      KASAVE = KACCSW
      KACCSW = 0

!             Find integers K2, K3, K5, and K7 such that
!                NT = 2**K2 * 3**K3 * 5**K5 * 7**K7
!             is a good approximation of IVAL.
!             KDELTA = ABS(IVAL - NT).

      INT2 = IVAL
      IF (IVAL > INTMAX/100) INT2 = IVAL/100
      KDELTA = INT2
      NT = 0
      K2 = 0
      K3 = 0
      K5 = 0
      K7 = 0

!             Start the search loop.

      XVAL = INT2
      LAST = INT(LOG(DBLE(XVAL))/DLOGTW + 2.0D0)

      JTEMP7 = 1
      DO J7 = 1, LAST
         IF (JTEMP7 > INT2 .AND. ABS(JTEMP7-INT2) > KDELTA) GO TO 150

         JTEMP5 = JTEMP7
         DO J5 = 1, LAST
            IF (JTEMP5 > INT2 .AND. ABS(JTEMP5-INT2) > KDELTA) GO TO 140

            JTEMP3 = JTEMP5
            DO J3 = 1, LAST
               IF (JTEMP3 > INT2 .AND. ABS(JTEMP3-INT2) > KDELTA) GO TO 130

               JTEMP2 = JTEMP3
               DO J2 = 1, LAST
                  IF (ABS(JTEMP2-INT2) <= KDELTA) THEN
                      IF (ABS(JTEMP2-INT2) == KDELTA .AND. JTEMP2 < INT2) GO TO 120
                      KDELTA = ABS(JTEMP2-INT2)
                      NT = JTEMP2
                      K2 = J2 - 1
                      K3 = J3 - 1
                      K5 = J5 - 1
                      K7 = J7 - 1
                      IF (KDELTA == 0) GO TO 150
                  ENDIF
                  IF (JTEMP2 > INT2) GO TO 120

                  JTEMP2 = 2*JTEMP2
               ENDDO

  120          JTEMP3 = 3*JTEMP3
            ENDDO

  130       JTEMP5 = 5*JTEMP5
         ENDDO

  140    JTEMP7 = 7*JTEMP7
      ENDDO

!             If IVAL was too close to the integer overflow limit, restore NT to an
!             approximation of IVAL.

  150 IF (INT2 /= IVAL) THEN
          IF (NT <= INT2) THEN
              NT = NT*100
              K2 = K2 + 2
              K5 = K5 + 2
          ELSE IF (NT <= IVAL/98) THEN
              NT = NT*98
              K2 = K2 + 1
              K7 = K7 + 2
          ELSE
              NT = NT*70
              K2 = K2 + 1
              K5 = K5 + 1
              K7 = K7 + 1
          ENDIF
      ENDIF

!             End of the search.
!             Now compute LN(NT) as a linear combination of LN(2), LN(3), LN(5), and LN(7).

      IF (MBASE /= MBSLI .OR. NDIG > NDIGLI) THEN
          NDMB = INT(150.0*2.302585/ALOGMB)
          IF (NDMB >= NDIG) THEN
              NDSV = NDIG
              NDIG = NDMB
              IF (MLN2 > 0) THEN
                  IF (SIZE_OF(MLN2) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN2) = -6
                      MLN2 = L
                  ENDIF
              ENDIF
              STRING = '0.693147180559945309417232121458176568075500'//  &
              '13436025525412068000949339362196969471560586332699641'//  &
              '8687542001481020570685733685520235758130557032670751635'
              CALL FMST2M(STRING,MLN2)
              IF (MLN3 > 0) THEN
                  IF (SIZE_OF(MLN3) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN3) = -6
                      MLN3 = L
                  ENDIF
              ENDIF
              STRING = '1.098612288668109691395245236922525704647490'//  &
              '55782274945173469433363749429321860896687361575481373'//  &
              '2088787970029065957865742368004225930519821052801870767'
              CALL FMST2M(STRING,MLN3)
              IF (MLN5 > 0) THEN
                  IF (SIZE_OF(MLN5) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN5) = -6
                      MLN5 = L
                  ENDIF
              ENDIF
              STRING = '1.609437912434100374600759333226187639525601'//  &
              '35426851772191264789147417898770765776463013387809317'//  &
              '9610799966303021715562899724005229324676199633616617464'
              CALL FMST2M(STRING,MLN5)
              IF (MLN7 > 0) THEN
                  IF (SIZE_OF(MLN7) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN7) = -6
                      MLN7 = L
                  ENDIF
              ENDIF
              STRING = '1.945910149055313305105352743443179729637084'//  &
              '72958186118845939014993757986275206926778765849858787'//  &
              '1526993061694205851140911723752257677786843148958095164'
              CALL FMST2M(STRING,MLN7)
              MBSLI = MBASE
              NDIGLI = NDIG
              IF (ABS(MWK(START(MLN2)+2)) > 10 .OR. ABS(MWK(START(MLN3)+2)) > 10 .OR.  &
                  ABS(MWK(START(MLN5)+2)) > 10 .OR. ABS(MWK(START(MLN7)+2)) > 10) NDIGLI = 0
          ELSE
              NDSV = NDIG
              NDIG = NDIG + 2 + NDIG/100
              MBSLI = MBASE
              NDIGLI = NDIG
              IF (MLN2 > 0) THEN
                  IF (SIZE_OF(MLN2) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN2) = -6
                      MLN2 = L
                  ENDIF
              ENDIF
              IF (MLN3 > 0) THEN
                  IF (SIZE_OF(MLN3) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN3) = -6
                      MLN3 = L
                  ENDIF
              ENDIF
              IF (MLN5 > 0) THEN
                  IF (SIZE_OF(MLN5) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN5) = -6
                      MLN5 = L
                  ENDIF
              ENDIF
              IF (MLN7 > 0) THEN
                  IF (SIZE_OF(MLN7) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MLN7) = -6
                      MLN7 = L
                  ENDIF
              ENDIF

!                 If precision is high, use the binary splitting method.

              IF (NDIG < 40) THEN

                  CALL FMLNI2(1,126,MLN2)
                  CALL FMLNI2(1,225,MLN3)
                  CALL FMLNI2(1,2401,MLN5)
                  CALL FMLNI2(1,4375,MLN7)

!                    Get Ln(2).

                  CALL FMMPYI_R1(MLN2,-72)
                  CALL FMMPYI(MLN3,-27,MXY(3))
                  CALL FMADD_R1(MLN2,MXY(3))
                  CALL FMMPYI(MLN5,19,MXY(3))
                  CALL FMADD_R1(MLN2,MXY(3))
                  CALL FMMPYI(MLN7,-31,MXY(3))
                  CALL FMADD_R1(MLN2,MXY(3))

!                    Get Ln(3).

                  CALL FMMPYI_R1(MLN3,-3)
                  CALL FMMPYI(MLN2,19,MXY(3))
                  CALL FMADD_R1(MLN3,MXY(3))
                  CALL FMSUB_R1(MLN3,MLN5)
                  CALL FMADD_R1(MLN3,MLN7)
                  CALL FMDIVI_R1(MLN3,12)

!                    Get Ln(5).

                  CALL FMSUB_R1(MLN5,MLN2)
                  CALL FMMPYI(MLN3,27,MXY(3))
                  CALL FMADD_R1(MLN5,MXY(3))
                  CALL FMMPYI(MLN7,-4,MXY(3))
                  CALL FMADD_R1(MLN5,MXY(3))
                  CALL FMDIVI_R1(MLN5,18)

!                    Get Ln(7).

                  CALL FMSUB_R2(MLN2,MLN7)
                  CALL FMMPYI(MLN3,7,MXY(3))
                  CALL FMADD_R1(MLN7,MXY(3))
                  CALL FMMPYI(MLN5,-4,MXY(3))
                  CALL FMADD_R1(MLN7,MXY(3))
              ELSE
                  CALL FMLNI3
              ENDIF
          ENDIF
          MWK(START(MLN2)+1) = NINT(NDIG*ALOGM2)
          MWK(START(MLN3)+1) = MWK(START(MLN2)+1)
          MWK(START(MLN5)+1) = MWK(START(MLN2)+1)
          MWK(START(MLN7)+1) = MWK(START(MLN2)+1)
          IF (ABS(MWK(START(MLN2)+2)) > 10 .OR. ABS(MWK(START(MLN3)+2)) > 10 .OR.  &
              ABS(MWK(START(MLN5)+2)) > 10 .OR. ABS(MWK(START(MLN7)+2)) > 10) NDIGLI = 0
          NDIG = NDSV
      ENDIF

!             If NT /= IVAL then the final step is to compute LN(IVAL/NT) and then use
!             LN(IVAL) = LN(IVAL/NT) + LN(NT).

      IF (NT /= IVAL) THEN
          ND = NT - IVAL
          IF (NDIG < 40) THEN
              CALL FMLNI2(ND,NT,MXY(3))
          ELSE
              IF (IVAL == NT-1) THEN
                  N = 2*IVAL + 1
                  K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
                  CALL IMI2FM(MXY(1),MXY(4))
                  CALL IMI2FM(MXY(2),MXY(5))
                  CALL IMI2FM(MXY(3),MXY(6))
                  CALL FMDIV(MXY(6),MXY(5),MXY(2))
                  CALL FMDIV(MXY(2),MXY(4),MXY(1))
                  CALL FMMPYI(MXY(1),-2,MXY(2))
                  CALL FMDIVI(MXY(2),N,MXY(3))
              ELSE IF (IVAL == NT+1) THEN
                  N = 2*IVAL - 1
                  K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
                  CALL IMI2FM(MXY(1),MXY(4))
                  CALL IMI2FM(MXY(2),MXY(5))
                  CALL IMI2FM(MXY(3),MXY(6))
                  CALL FMDIV(MXY(6),MXY(5),MXY(2))
                  CALL FMDIV(MXY(2),MXY(4),MXY(1))
                  CALL FMMPYI(MXY(1),2,MXY(2))
                  CALL FMDIVI(MXY(2),N,MXY(3))
              ELSE IF (IVAL == NT-2) THEN
                  N = IVAL + 1
                  K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
                  CALL IMI2FM(MXY(1),MXY(4))
                  CALL IMI2FM(MXY(2),MXY(5))
                  CALL IMI2FM(MXY(3),MXY(6))
                  CALL FMDIV(MXY(6),MXY(5),MXY(2))
                  CALL FMDIV(MXY(2),MXY(4),MXY(1))
                  CALL FMMPYI(MXY(1),-2,MXY(2))
                  CALL FMDIVI(MXY(2),N,MXY(3))
              ELSE IF (IVAL == NT+2) THEN
                  N = IVAL - 1
                  K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
                  CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
                  CALL IMI2FM(MXY(1),MXY(4))
                  CALL IMI2FM(MXY(2),MXY(5))
                  CALL IMI2FM(MXY(3),MXY(6))
                  CALL FMDIV(MXY(6),MXY(5),MXY(2))
                  CALL FMDIV(MXY(2),MXY(4),MXY(1))
                  CALL FMMPYI(MXY(1),2,MXY(2))
                  CALL FMDIVI(MXY(2),N,MXY(3))
              ELSE
                  CALL FMLNI4(IVAL,NT,MXY(3))
              ENDIF
          ENDIF
      ENDIF

      CALL FMMPYI(MLN2,K2,MXY(2))
      CALL FMMPYI(MLN3,K3,MXY(1))
      CALL FMADD_R1(MXY(2),MXY(1))
      CALL FMMPYI(MLN5,K5,MXY(1))
      CALL FMADD_R1(MXY(2),MXY(1))
      CALL FMMPYI(MLN7,K7,MXY(1))
      IF (NT /= IVAL) CALL FMADD_R1(MXY(2),MXY(3))
      CALL FMADD(MXY(2),MXY(1),MXY(3))

!             Round and move the result to MA.

      KACCSW = KASAVE

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEQU(MXY(3),MA,NDIG,NDSAVE)
      NDIG = NDSAVE
      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNI

      SUBROUTINE FMLNI2(INT1,INT2,MA)

!  MA = LN(1 - INT1/INT2)

!  Taylor series for computing the logarithm of a rational number near 1.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: INT1,INT2
      INTEGER :: MA
      INTEGER :: J,NDSAVE
      INTENT (IN) :: INT1,INT2
      INTENT (INOUT) :: MA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMI2M(INT1,MXY(2))
      CALL FMDIVI_R1(MXY(2),INT2)
      CALL FMEQ(MXY(2),MA)
      NDSAVE = NDIG
      J = 1

  110 J = J + 1
      IF (INT1 /= 1) CALL FMMPYI_R1(MXY(2),INT1)
      CALL FMDIVI_R1(MXY(2),INT2)
      CALL FMDIVI(MXY(2),J,MXY(1))
      NDIG = NDSAVE
      CALL FMADD_R1(MA,MXY(1))
      NDIG = NDSAVE - INT(MWK(START(MA)+2)-MWK(START(MXY(1))+2))
      IF (NDIG < NGRD22) NDIG = NGRD22
      IF (KFLAG /= 1) GO TO 110

      NDIG = NDSAVE
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      IF (MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0) MWK(START(MA)) = -MWK(START(MA))
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNI2

      SUBROUTINE FMLNI3

!  Binary splitting version.  Faster for large NDIG.

!  Compute the four saved constants Ln(2), Ln(3), Ln(5), Ln(7).

      USE FMVALS
      IMPLICIT NONE

      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: K,KASAVE,NDSAVE,N
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD52-1,2)
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KASAVE = KACCSW
      KACCSW = 0
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Determine K, the number of terms to sum in the series for
!             Ln( (N+1) / (N-1) ) = (2/N)*( 1 + 1/(3*d) + 1/(5*d**2) + ...), with d = N**2.
!             Four calls are made:  N = 251, 449, 4801, 8549.

      N = 251
      K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
      CALL IMI2FM(MXY(1),MXY(4))
      CALL IMI2FM(MXY(2),MXY(5))
      CALL IMI2FM(MXY(3),MXY(6))
      CALL FMDIV(MXY(6),MXY(5),MXY(2))
      CALL FMDIV(MXY(2),MXY(4),MXY(1))
      CALL FMMPYI(MXY(1),2,MXY(2))
      CALL FMDIVI(MXY(2),N,MLN2)
      NUMBER_USED = NUMBER_USED_SAVE
      MXY = -2

      N = 449
      K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
      CALL IMI2FM(MXY(1),MXY(4))
      CALL IMI2FM(MXY(2),MXY(5))
      CALL IMI2FM(MXY(3),MXY(6))
      CALL FMDIV(MXY(6),MXY(5),MXY(2))
      CALL FMDIV(MXY(2),MXY(4),MXY(1))
      CALL FMMPYI(MXY(1),2,MXY(2))
      CALL FMDIVI(MXY(2),N,MLN3)
      NUMBER_USED = NUMBER_USED_SAVE
      MXY = -2

      N = 4801
      K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
      CALL IMI2FM(MXY(1),MXY(4))
      CALL IMI2FM(MXY(2),MXY(5))
      CALL IMI2FM(MXY(3),MXY(6))
      CALL FMDIV(MXY(6),MXY(5),MXY(2))
      CALL FMDIV(MXY(2),MXY(4),MXY(1))
      CALL FMMPYI(MXY(1),2,MXY(2))
      CALL FMDIVI(MXY(2),N,MLN5)
      NUMBER_USED = NUMBER_USED_SAVE
      MXY = -2

      N = 8749
      K = NDIG*DLOGMB/LOG(DBLE(N)**2) + 10
      CALL FMLNI3_QBT(0,K,N,MXY(1),MXY(2),MXY(3))
      CALL IMI2FM(MXY(1),MXY(4))
      CALL IMI2FM(MXY(2),MXY(5))
      CALL IMI2FM(MXY(3),MXY(6))
      CALL FMDIV(MXY(6),MXY(5),MXY(2))
      CALL FMDIV(MXY(2),MXY(4),MXY(1))
      CALL FMMPYI(MXY(1),2,MXY(2))
      CALL FMDIVI(MXY(2),N,MLN7)

!            Get Ln(2).

      CALL FMMPYI_R1(MLN2,72)
      CALL FMMPYI(MLN3,27,MXY(3))
      CALL FMADD_R1(MLN2,MXY(3))
      CALL FMMPYI(MLN5,-19,MXY(3))
      CALL FMADD_R1(MLN2,MXY(3))
      CALL FMMPYI(MLN7,31,MXY(3))
      CALL FMADD_R1(MLN2,MXY(3))

!            Get Ln(3).

      CALL FMMPYI_R1(MLN3,3)
      CALL FMMPYI(MLN2,19,MXY(3))
      CALL FMADD_R1(MLN3,MXY(3))
      CALL FMADD_R1(MLN3,MLN5)
      CALL FMSUB_R1(MLN3,MLN7)
      CALL FMDIVI_R1(MLN3,12)

!            Get Ln(5).

      CALL FMADD_R1(MLN5,MLN2)
      CALL FMMPYI(MLN3,27,MXY(3))
      CALL FMSUB_R2(MXY(3),MLN5)
      CALL FMMPYI(MLN7,4,MXY(3))
      CALL FMADD_R1(MLN5,MXY(3))
      CALL FMDIVI_R1(MLN5,18)

!            Get Ln(7).

      CALL FMADD_R2(MLN2,MLN7)
      CALL FMMPYI(MLN3,7,MXY(3))
      CALL FMADD_R1(MLN7,MXY(3))
      CALL FMMPYI(MLN5,-4,MXY(3))
      CALL FMADD_R1(MLN7,MXY(3))

      MXEXP = MXSAVE
      NDIG = NDSAVE
      KACCSW = KASAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNI3

      RECURSIVE SUBROUTINE FMLNI3_QBT(A,B,N,MQ,MB,MT)

!  This routine does the binary splitting for computing the constant Ln( (N+1) / (N-1) ).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MQ,MB,MT
      INTEGER :: A,B,N
      INTENT (IN) :: A,B,N
      INTENT (INOUT) :: MQ,MB,MT
      INTEGER :: MXY(6),NUMBER_USED_SAVE,J,M
      REAL (KIND(0.0D0)) :: DA,DB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      RESULT_SIZE = ( (DB - DA + 1)*LOG(DBLE(N)**2) ) / DLOGMB + 7
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MQ <= 0) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ELSE IF (SIZE_OF(MQ) < RESULT_SIZE) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ENDIF
      J = RESULT_SIZE
      RESULT_SIZE = ( (DB+1.5D0)*LOG(DB+2) - DB + 1/(12*(DB+2)) -          &
                      ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) - 1 +  &
                      (DB-DA+1)*LOG(2.0D0) ) / DLOGMB + 7
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = RESULT_SIZE + J
      IF (MT <= 0) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (B-A < 6) THEN
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          CALL IMDEFINE(MXY(3),RESULT_SIZE)
          CALL IMDEFINE(MXY(4),RESULT_SIZE)
          CALL IMDEFINE(MXY(5),RESULT_SIZE)
          CALL IMI2M(N,MXY(2))
          CALL IMSQR(MXY(2),MXY(1))
          CALL IMI2M(B-A+1,MXY(2))
          CALL IMPWR(MXY(1),MXY(2),MQ)

          CALL IMI2M(1,MB)
          DO J = A+1, B, 2
             CALL IMMPYI(MB,2*J-1,MXY(1))
             CALL IMMPYI(MXY(1),2*J+1,MB)
          ENDDO
          IF (MOD(B-A,2) == 0) THEN
              CALL IMMPYI(MB,2*B+1,MXY(1))
              CALL IMEQ(MXY(1),MB)
          ENDIF

!             MT is the sum
!             MXY(2) is (N*N)^(J+1)

          CALL IMDIVI(MB,2*B+1,MXY(1))
          CALL IMMPYI(MXY(1),N,MXY(2))
          CALL IMMPYI(MXY(2),N,MT)
          CALL IMI2M(N,MXY(1))
          CALL IMSQR(MXY(1),MXY(2))
          DO J = 1, B-A
             CALL IMDIVI(MB,2*B+1-2*J,MXY(3))
             CALL IMMPYI(MXY(2),N,MXY(4))
             CALL IMMPYI(MXY(4),N,MXY(2))
             CALL IMMPY(MXY(2),MXY(3),MXY(4))
             CALL IMADD(MT,MXY(4),MXY(5))
             CALL IMEQ(MXY(5),MT)
          ENDDO
          GO TO 110
      ENDIF

      M = (A+B)/2
      CALL FMLNI3_QBT(A,M-1,N,MXY(1),MXY(2),MXY(3))
      CALL FMLNI3_QBT(M,B,N,MXY(4),MXY(5),MXY(6))
      CALL IMMPY(MXY(1),MXY(4),MQ)
      CALL IMMPY(MXY(2),MXY(5),MB)
      CALL IMMPY(MXY(5),MXY(4),MT)
      CALL IMMPY(MXY(3),MT,MXY(1))
      CALL IMMPY(MXY(2),MXY(6),MXY(3))
      CALL IMADD(MXY(1),MXY(3),MT)

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MQ) == -1) TEMPV(MQ) = -2
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNI3_QBT

      SUBROUTINE FMLNI4(IVAL,NT,MA)

!  Binary splitting version.  Faster for large NDIG.

!  MA = Ln(IVAL/NT).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL,NT
      INTENT (IN) :: IVAL,NT
      INTENT (INOUT) :: MA
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: A,B,K,KASAVE,NDSAVE
      INTEGER :: MXY(7),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD52-1,2)
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KASAVE = KACCSW
      KACCSW = 0
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Determine K, the number of terms to sum in the series for
!             Ln( (B+A) / (B-A) ) = (2*A/B)*( 1 + 1/(3*d) + 1/(5*d^2) + ...), with d = (B/A)^2.

      A = ABS(IVAL - NT)
      B = IVAL + NT
      CALL FMGCDI(A,B)
      IF (IVAL-NT < 0) A = -A
      K = NDIG*DLOGMB/LOG(DBLE(B)**2/DBLE(A)**2) + 10
      CALL FMLNI4_PQBT(0,K,A,B,MXY(1),MXY(2),MXY(3),MXY(4))
      CALL IMI2FM(MXY(2),MXY(5))
      CALL IMI2FM(MXY(3),MXY(6))
      CALL IMI2FM(MXY(4),MXY(7))
      CALL FMDIV(MXY(7),MXY(6),MXY(2))
      CALL FMDIV(MXY(2),MXY(5),MXY(1))
      CALL FMMPYI(MXY(1),2*A,MXY(2))
      CALL FMDIVI(MXY(2),B,MXY(3))

      CALL FMEQU(MXY(3),MA,NDIG,NDSAVE)
      MXEXP = MXSAVE
      NDIG = NDSAVE
      KACCSW = KASAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNI4

      RECURSIVE SUBROUTINE FMLNI4_PQBT(A,B,C,D,MP,MQ,MB,MT)

!  This routine does the binary splitting for computing the constant Ln( (B+A) / (B-A) ).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MP,MQ,MB,MT
      INTEGER :: A,B,C,D
      INTENT (IN) :: A,B,C,D
      INTENT (INOUT) :: MP,MQ,MB,MT
      INTEGER :: MXY(8),NUMBER_USED_SAVE,J,M
      REAL (KIND(0.0D0)) :: DA,DB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      RESULT_SIZE = ( (DB - DA + 1)*LOG(DBLE(C)**2) ) / DLOGMB + 7
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MP <= 0) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ELSE IF (SIZE_OF(MP) < RESULT_SIZE) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = ( (DB - DA + 1)*LOG(DBLE(D)**2) ) / DLOGMB + 7
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MQ <= 0) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ELSE IF (SIZE_OF(MQ) < RESULT_SIZE) THEN
          CALL IMDEFINE(MQ,RESULT_SIZE)
      ENDIF
      J = RESULT_SIZE
      RESULT_SIZE = ( (DB+1.5D0)*LOG(DB+2) - DB + 1/(12*(DB+2)) -  &
                      ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) - 1 +  &
                      (DB-DA+1)*LOG(2.0D0) ) / DLOGMB + 7
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = RESULT_SIZE + J
      IF (MT <= 0) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION + 1

      IF (B-A < 6) THEN
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          CALL IMDEFINE(MXY(3),RESULT_SIZE)
          CALL IMDEFINE(MXY(4),RESULT_SIZE)
          CALL IMDEFINE(MXY(5),RESULT_SIZE)
          CALL IMI2M(C,MXY(2))
          CALL IMSQR(MXY(2),MXY(1))
          CALL IMI2M(B-A+1,MXY(2))
          CALL IMPWR(MXY(1),MXY(2),MP)

          CALL IMI2M(D,MXY(2))
          CALL IMSQR(MXY(2),MXY(1))
          CALL IMI2M(B-A+1,MXY(2))
          CALL IMPWR(MXY(1),MXY(2),MQ)

          CALL IMI2M(1,MB)
          DO J = A+1, B, 2
             CALL IMMPYI(MB,2*J-1,MXY(1))
             CALL IMMPYI(MXY(1),2*J+1,MB)
          ENDDO
          IF (MOD(B-A,2) == 0) THEN
              CALL IMMPYI(MB,2*B+1,MXY(1))
              CALL IMEQ(MXY(1),MB)
          ENDIF

          CALL IMI2M(D,MXY(1))
          CALL IMSQR(MXY(1),MXY(2))
          CALL IMI2M(B-A+1,MXY(1))
          CALL IMPWR(MXY(2),MXY(1),MXY(3))

          CALL IMI2M(1,MXY(4))
          CALL IMI2M(0,MT)

          DO J = A, B
             CALL IMDIVI(MB,2*J+1,MXY(1))
             CALL IMMPY(MXY(1),MXY(3),MXY(2))
             CALL IMMPY(MXY(2),MXY(4),MXY(1))
             CALL IMADD(MT,MXY(1),MXY(5))
             CALL IMEQ(MXY(5),MT)
             CALL IMDIVI(MXY(3),D,MXY(5))
             CALL IMDIVI(MXY(5),D,MXY(3))
             CALL IMMPYI(MXY(4),C,MXY(5))
             CALL IMMPYI(MXY(5),C,MXY(4))
          ENDDO
          GO TO 110
      ENDIF

      M = (A+B)/2
      CALL FMLNI4_PQBT(A,M-1,C,D,MXY(1),MXY(2),MXY(3),MXY(4))
      CALL FMLNI4_PQBT(M,B,C,D,MXY(5),MXY(6),MXY(7),MXY(8))

!             MP is not needed in FMLNI4, so this multiplication can be skipped at the top level
!             of the recursion.

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IMMPY(MXY(1),MXY(5),MP)
      ELSE
          CALL IMI2M(0,MP)
      ENDIF
      CALL IMMPY(MXY(2),MXY(6),MQ)
      CALL IMMPY(MXY(3),MXY(7),MB)
      CALL IMMPY(MXY(6),MXY(7),MT)
      CALL IMMPY(MXY(4),MT,MXY(5))
      CALL IMMPY(MXY(1),MXY(3),MT)
      CALL IMMPY(MXY(8),MT,MXY(2))
      CALL IMADD(MXY(5),MXY(2),MT)

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
          IF (TEMPV(MQ) == -1) TEMPV(MQ) = -2
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION - 1
      RETURN
      END SUBROUTINE FMLNI4_PQBT

      SUBROUTINE FMM2DP(MA,X)

!  X = MA

!  Convert an FM number to double precision.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's double
!  precision number system, change the definition of DPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      DOUBLE PRECISION :: X

      INTEGER :: KRESLT
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMM2DP'
      KRESLT = 0
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMARGS('FMM2DP   ',1,MA,MA,KRESLT)
      ENDIF
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.
!             Set X to some value that the user is likely to recognize as wrong.

          X = DBLE(RUNKNO)
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
          IF (NTRACE /= 0) CALL FMNTRR(1,X,1)
          NCALL = NCALL - 1
          RETURN
      ENDIF

      CALL FMMD(MA,X)

      IF (NTRACE /= 0) CALL FMNTRR(1,X,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE FMM2DP

      SUBROUTINE FMM2I(MA,IVAL)

!  IVAL = MA

!  Convert an FM number to integer.

!  KFLAG =  0 is returned if the conversion is exact.
!        = -4 is returned if MA is larger than INTMAX in magnitude.  IVAL = IUNKNO is returned
!             as an indication that IVAL could not be computed without integer overflow.
!        =  2 is returned if MA is smaller than INTMAX in magnitude but MA is not an integer.
!             The next integer toward zero is returned in IVAL.
!  It is sometimes convenient to call FMM2I to see if an FM number can be represented as a one-word
!  integer, by checking KFLAG upon return.  To avoid an unwanted error message being printed in the
!  KFLAG=-4 case, set KWARN=0 before the call to FMM2I and reset it after the call.

!  This routine performs the trace printing for the conversion.  FMMI is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMM2I'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)

      CALL FMMI(MA,IVAL)

      IF (NTRACE /= 0) CALL FMNTRI(1,IVAL,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE FMM2I

      SUBROUTINE FMM2SP(MA,X)

!  X = MA

!  Convert an FM number to single precision.

!  MA is converted and the result is returned in X.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's single
!  precision number system, change the definition of SPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      REAL :: X

      DOUBLE PRECISION :: Y
      INTEGER :: KRESLT
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMM2SP'
      KRESLT = 0
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMARGS('FMM2SP   ',1,MA,MA,KRESLT)
      ENDIF
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.
!             Set X to some value that the user is likely to recognize as wrong.

          X = RUNKNO
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
          Y = DBLE(X)
          IF (NTRACE /= 0) CALL FMNTRR(1,Y,1)
          NCALL = NCALL - 1
          RETURN
      ENDIF

      CALL FMMD(MA,Y)
      X = REAL(Y)

      IF (NTRACE /= 0) THEN
          Y = DBLE(X)
          CALL FMNTRR(1,Y,1)
      ENDIF
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE FMM2SP

      SUBROUTINE FMMAX(MA,MB,MC)

!  MC = MAX(MA,MB)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMMAX'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (FMCOMP(MA,'<',MB)) THEN
          CALL FMEQ(MB,MC)
      ELSE
          CALL FMEQ(MA,MC)
      ENDIF

      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMAX

      SUBROUTINE FMMD(MA,X)

!  X = MA

!  Internal routine for conversion to double precision.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      DOUBLE PRECISION :: X

      DOUBLE PRECISION :: AQ(2),XQ(2),YQ(2),Y1(2),Y2(2),XBASE,PMAX,DLOGDP,  &
                          A1,A2,C,C1,C2,C21,C22,Q1,Q2,T,Z1,Z2
      REAL (KIND(1.0D0)) :: MA1,MAS
      INTEGER :: J,K,KWRNSV,NCASE
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

!             Check to see if MA is in range for single or double precision.

      IF (MBLOGS /= MBASE) CALL FMCONS
      PMAX = DPMAX
      IF (NCALL > 0) THEN
          IF (NAMEST(NCALL) == 'FMM2SP') PMAX = DBLE(SPMAX)
      ENDIF
      DLOGDP = LOG(PMAX)
      MA1 = MWK(START(MA)+2)
      NCASE = 0
      IF (DBLE(MWK(START(MA)+2)-1)*DLOGMB > DLOGDP) THEN
          KFLAG = -4
          X = DBLE(RUNKNO)
          CALL FMWARN
          RETURN
      ELSE IF (DBLE(MWK(START(MA)+2)+1)*DLOGMB > DLOGDP) THEN
          MA1 = MA1 - 2
          NCASE = 1
      ELSE IF (DBLE(MWK(START(MA)+2)+1)*DLOGMB < -DLOGDP) THEN
          KFLAG = -10
          X = 0.0D0
          CALL FMWARN
          RETURN
      ELSE IF (DBLE(MWK(START(MA)+2)-1)*DLOGMB < -DLOGDP) THEN
          MA1 = MA1 + 2
          NCASE = 2
      ENDIF

!             Try FMMI first so that small integers will be converted quickly.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMMI(MA,J)
      KWARN = KWRNSV
      IF (KFLAG == 0) THEN
          X = J
          RETURN
      ENDIF
      KFLAG = 0

!             General case.
!             In order to get the correctly rounded X, the arithmetic for computing X is done
!             with simulated quadruple-precision with the arrays of length 2.

      MAS = MWK(START(MA))
      XBASE = MBASE
      XQ = (/ 0.0D0 , 0.0D0 /)
      YQ = (/ 1.0D0 , 0.0D0 /)
      C = RADIX(X)**(DIGITS(X) - DIGITS(X)/2) + 1
      K = (LOG(DBLE(RADIX(X)))/DLOGMB)*DIGITS(X) + 2
      DO J = 2, MIN(K+1,NDIG+1)
         Z1 = YQ(1) / XBASE
         T = XBASE*C
         A1 = (XBASE - T) + T
         A2 = XBASE - A1
         T = Z1*C
         C1 = (Z1 - T) + T
         C2 = Z1 - C1
         T = C2*C
         C21 = (C2 - T) + T
         C22 = C2 - C21
         Q1 = XBASE*Z1
         Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
         Z2 = ((((YQ(1)-Q1) - Q2) + YQ(2))) / XBASE
         YQ(1) = Z1 + Z2
         YQ(2) = (Z1-YQ(1)) + Z2
         T = YQ(1)*C
         A1 = (YQ(1) - T) + T
         A2 = YQ(1) - A1
         T = DBLE(MWK(START(MA)+J+1))*C
         C1 = (DBLE(MWK(START(MA)+J+1)) - T) + T
         C2 = DBLE(MWK(START(MA)+J+1)) - C1
         T = C2*C
         C21 = (C2 - T) + T
         C22 = C2 - C21
         Q1 = YQ(1)*DBLE(MWK(START(MA)+J+1))
         Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
         Z2 = YQ(2)*DBLE(MWK(START(MA)+J+1)) + Q2
         AQ(1) = Q1 + Z2
         AQ(2) = (Q1-AQ(1)) + Z2
         Z1 = XQ(1) + AQ(1)
         Q1 = XQ(1) - Z1
         Z2 = (((Q1+AQ(1)) + (XQ(1)-(Q1+Z1))) + XQ(2)) + AQ(2)
         XQ(1) = Z1 + Z2
         XQ(2) = (Z1-XQ(1)) + Z2
      ENDDO

      Y1 = (/ XBASE , 0.0D0 /)
      K = ABS(MA1)
      IF (MOD(K,2) == 0) THEN
          Y2 = (/ 1.0D0 , 0.0D0 /)
      ELSE
          Y2 = (/ XBASE , 0.0D0 /)
      ENDIF

  110 K = K/2
      T = Y1(1)*C
      A1 = (Y1(1) - T) + T
      A2 = Y1(1) - A1
      T = Y1(1)*C
      C1 = (Y1(1) - T) + T
      C2 = Y1(1) - C1
      T = C2*C
      C21 = (C2 - T) + T
      C22 = C2 - C21
      Q1 = Y1(1)*Y1(1)
      Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
      Z2 = ((Y1(1) + Y1(2))*Y1(2) + Y1(2)*Y1(1)) + Q2
      Y1(1) = Q1 + Z2
      Y1(2) = (Q1-Y1(1)) + Z2
      IF (MOD(K,2) == 1) THEN
          T = Y1(1)*C
          A1 = (Y1(1) - T) + T
          A2 = Y1(1) - A1
          T = Y2(1)*C
          C1 = (Y2(1) - T) + T
          C2 = Y2(1) - C1
          T = C2*C
          C21 = (C2 - T) + T
          C22 = C2 - C21
          Q1 = Y1(1)*Y2(1)
          Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
          Z2 = ((Y1(1) + Y1(2))*Y2(2) + Y1(2)*Y2(1)) + Q2
          Y2(1) = Q1 + Z2
          Y2(2) = (Q1-Y2(1)) + Z2
      ENDIF
      IF (K > 1) GO TO 110

      IF (MA1 < 0) THEN
          Z1 = XQ(1) / Y2(1)
          T = Y2(1)*C
          A1 = (Y2(1) - T) + T
          A2 = Y2(1) - A1
          T = Z1*C
          C1 = (Z1 - T) + T
          C2 = Z1 - C1
          T = C2*C
          C21 = (C2 - T) + T
          C22 = C2 - C21
          Q1 = Y2(1)*Z1
          Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
          Z2 = ((((XQ(1)-Q1) - Q2) + XQ(2)) - Z1*Y2(2)) / (Y2(1) + Y2(2))
          AQ(1) = Z1 + Z2
          AQ(2) = (Z1-AQ(1)) + Z2
      ELSE
          T = XQ(1)*C
          A1 = (XQ(1) - T) + T
          A2 = XQ(1) - A1
          T = Y2(1)*C
          C1 = (Y2(1) - T) + T
          C2 = Y2(1) - C1
          T = C2*C
          C21 = (C2 - T) + T
          C22 = C2 - C21
          Q1 = XQ(1)*Y2(1)
          Q2 = ((((A1*C1 - Q1) + A1*C2) + C1*A2) + C21*A2) + C22*A2
          Z2 = ((XQ(1) + XQ(2))*Y2(2) + XQ(2)*Y2(1)) + Q2
          AQ(1) = Q1 + Z2
          AQ(2) = (Q1-AQ(1)) + Z2
      ENDIF

      X = AQ(1) + AQ(2)

      IF (MAS < 0) X = -X

!             Check the result if it is near overflow or underflow.

      IF (NCASE == 1) THEN
          IF (X <= PMAX/(XBASE*XBASE)) THEN
              X = X*XBASE*XBASE
          ELSE
              KFLAG = -4
              X = DBLE(RUNKNO)
              CALL FMWARN
          ENDIF
      ELSE IF (NCASE == 2) THEN
          IF (X >= (1.0D0/PMAX)*XBASE*XBASE) THEN
              X = X/(XBASE*XBASE)
          ELSE
              KFLAG = -10
              X = 0.0D0
              CALL FMWARN
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMMD

      SUBROUTINE FMMI(MA,IVAL)

!  IVAL = MA.  Internal FM to integer conversion routine.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL

      INTEGER :: J,KA,KB,LARGE,N1
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL

      KFLAG = 0
      N1 = NDIG + 1
      LARGE = INT(INTMAX/MBASE)
      IVAL = 0
      IF (MWK(START(MA)+2) <= 0) THEN
          IF (MWK(START(MA)+3) /= 0) KFLAG = 2
          RETURN
      ENDIF

      KB = INT(MWK(START(MA)+2)) + 1
      IVAL = INT(ABS(MWK(START(MA)+3)))
      IF (KB >= 3) THEN
          DO J = 3, KB
             IF (IVAL > LARGE) THEN
                 KFLAG = -4
                 IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
                 IVAL = IUNKNO
                 RETURN
             ENDIF
             IF (J <= N1) THEN
                 IVAL = IVAL*INT(MBASE)
                 IF (IVAL > INTMAX-MWK(START(MA)+J+1)) THEN
                     KFLAG = -4
                     IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
                     IVAL = IUNKNO
                     RETURN
                 ELSE
                     IVAL = IVAL + INT(MWK(START(MA)+J+1))
                 ENDIF
             ELSE
                 IVAL = IVAL*INT(MBASE)
             ENDIF
          ENDDO
      ENDIF

      IF (MWK(START(MA)) < 0) IVAL = -IVAL

!             Check to see if MA is an integer.

      KA = KB + 1
      IF (KA <= N1) THEN
          DO J = KA, N1
             IF (MWK(START(MA)+J+1) /= 0) THEN
                 KFLAG = 2
                 RETURN
             ENDIF
          ENDDO
      ENDIF

      RETURN
      END SUBROUTINE FMMI

      SUBROUTINE FMMIN(MA,MB,MC)

!  MC = MIN(MA,MB)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMMIN'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (FMCOMP(MA,'>',MB)) THEN
          CALL FMEQ(MB,MC)
      ELSE
          CALL FMEQ(MA,MC)
      ENDIF

      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMIN

      SUBROUTINE FMMOD(MA,MB,MC)

!  MC = MA(MOD MB).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MVB,MVC,MVY,MVZ,MXSAVE
      INTEGER :: J,K,KASAVE,KB,KE,KN,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB) THEN
          CALL FMENTR('FMMOD    ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMMOD'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KWRNSV = KWARN
      KWARN = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)

      IF (MWK(START(MB)+2) > MWK(START(MA)+2) .AND. MWK(START(MB)+3) /= 0) THEN
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      ELSE

!             Special cases when MB is a small integer.

          CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
          MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
          CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
          MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
          MWK(START(MXY(2))) = 1
          MWK(START(MXY(3))) = 1

          CALL FMM2I(MXY(3),KB)
          IF (KFLAG == 0 .AND. KB < MXBASE) THEN
              IF (KB == 1 .OR. KB == -1) THEN
                  IF (MWK(START(MXY(2))+2) >= NDIG) THEN
                      CALL FMI2M(0,MXY(1))
                      GO TO 130
                  ELSE
                      CALL FMINT(MXY(2),MXY(3))
                      CALL FMSUB(MXY(2),MXY(3),MXY(1))
                      IF (MWK(START(MA)) < 0 .AND. MWK(START(MXY(1))+2) /= MUNKNO .AND.  &
                          MWK(START(MXY(1))+3) /= 0) MWK(START(MXY(1))) = -MWK(START(MXY(1)))
                      GO TO 130
                  ENDIF
              ELSE IF (MWK(START(MXY(2))+2) == MEXPOV .OR. KB == 0) THEN
                  KFLAG = -4
                  KWARN = KWRNSV
                  KACCSW = KASAVE
                  MXEXP = MXSAVE
                  CALL FMWARN
                  NDIG = NDSAVE
                  CALL FMST2M('UNKNOWN',MC)
                  IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
                  NCALL = NCALL - 1
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ELSE IF (MWK(START(MXY(2))+2) > NDIG.AND.MOD(INT(MBASE),KB) == 0) THEN
                  CALL FMI2M(0,MXY(1))
                  GO TO 130
              ENDIF
              IF (MWK(START(MXY(2))+2) < NDIG) THEN
                  DO J = INT(MWK(START(MXY(2))+2))+1, NDIG+1
                     IF (MWK(START(MXY(2))+J+1) /= 0) GO TO 120
                  ENDDO
              ENDIF
              KE = MIN(INT(MWK(START(MXY(2))+2)),NDIG)
              MVB = KB
              MVC = MOD(MWK(START(MXY(2))+3),MVB)
              DO J = 3, KE+1
                 MVC = MOD(MVC*MBASE+MWK(START(MXY(2))+J+1),MVB)
              ENDDO
              IF (MVC == 0) THEN
                   CALL FMI2M(0,MXY(1))
                   GO TO 130
              ENDIF
              KN = INT(MWK(START(MXY(2))+2)) - KE
              MVY = MOD(MBASE,MVB)
              MVZ = 1
              IF (MOD(KN,2) == 1) MVZ = MVY

              IF (MVY /= 1) THEN
  110             KN = KN/2
                  MVY = MOD(MVY*MVY,MVB)
                  IF (MOD(KN,2) == 1) MVZ = MOD(MVZ*MVY,MVB)
                  IF (KN > 1) GO TO 110
              ENDIF
              MVZ = MOD(MVZ*MVC,MVB)
              KE = INT(MVZ)
              CALL FMI2M(KE,MXY(1))
              IF (MWK(START(MA)) < 0 .AND. MWK(START(MXY(1))+2) /= MUNKNO .AND.  &
                  MWK(START(MXY(1))+3) /= 0) MWK(START(MXY(1))) = -MWK(START(MXY(1)))
              GO TO 130
          ENDIF
          IF (MWK(START(MA)+2)-MWK(START(MB)+2) > 3*10**5) THEN
              KFLAG = -4
              CALL FMWARN
              CALL FMST2M('UNKNOWN',MXY(1))
              GO TO 130
          ENDIF

!             General case.

  120     IF (MWK(START(MA)+3) /= 0) THEN
              NDIG = NDIG + INT(MWK(START(MA)+2)-MWK(START(MB)+2))
          ENDIF
          IF (MWK(START(MB)+3) == 0) THEN
              KFLAG = -9
              IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN .OR.   &
                  MWK(START(MB)+3) == 0) KFLAG = -4
              KWARN = KWRNSV
              KACCSW = KASAVE
              MXEXP = MXSAVE
              CALL FMWARN
              NDIG = NDSAVE
              CALL FMST2M('UNKNOWN',MC)
              IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF

          CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
          MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
          CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
          MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)

          MWK(START(MXY(2))) = 1
          MWK(START(MXY(3))) = 1
          CALL FMDIV(MXY(2),MXY(3),MXY(1))
          CALL FMINT(MXY(1),MXY(4))
          CALL FMMPY_R1(MXY(4),MXY(3))
          CALL FMSUB(MXY(2),MXY(4),MXY(1))

!             Due to rounding, MXY(1) may not be between 0 and MB here.

          NTRSAV = NTRACE
          NTRACE = 0
          IF (FMCOMP(MXY(1),'>=',MXY(3))) THEN
              NTRACE = NTRSAV
              CALL FMSUB_R1(MXY(1),MXY(3))
          ENDIF
          NTRACE = NTRSAV
          IF (MWK(START(MXY(1))) < 0) CALL FMADD_R1(MXY(1),MXY(3))
          IF (MWK(START(MA)) < 0 .AND. MWK(START(MXY(1))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(1))+3) /=0) MWK(START(MXY(1))) = -MWK(START(MXY(1)))
      ENDIF

  130 IF (KFLAG == 1) KFLAG = 0
      KWARN = KWRNSV
      MACMAX = NINT((NDSAVE-1)*ALOGM2+LOG(REAL(ABS(MWK(START(MXY(1))+3))+1))/0.69315)
      MWK(START(MXY(1))+1) = MIN(MWK(START(MXY(1))+1),MACCA,MACCB,MACMAX)
      CALL FMEXIT(MXY(1),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMOD

      SUBROUTINE FMMOVE(MW,MA)

!  Move a result from a work area (MW) to MA.

!  If the result has MWK(START(MW)+3)=0, then it is shifted and the exponent adjusted when it is
!  moved to MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MW

      INTEGER :: J,JMA,JMW,N1,N2
      INTENT (IN) :: MW
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MWK(START(MW)+3) /= 0) THEN
          N1 = NDIG + 1

!             Major (Inner Loop)

          JMA = START(MA) + 1
          JMW = START(MW) + 1
          DO J = 1, N1
             MWK(JMA+J) = MWK(JMW+J)
          ENDDO
      ELSE
          N2 = NDIG + 2
          JMA = START(MA)
          JMW = START(MW) + 1
          DO J = 3, N2
             MWK(JMA+J) = MWK(JMW+J)
          ENDDO
          IF (MWK(START(MA)+3) /= 0) THEN
              MWK(START(MA)+2) = MWK(START(MW)+2) - 1
          ELSE
              MWK(START(MA)+2) = 0
          ENDIF
      ENDIF

      MWK(START(MA)) = 1
      IF (ABS(MWK(START(MA)+2)) > MXEXP) CALL FMTRAP(MA)

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMOVE

      SUBROUTINE FMMPY(MA,MB,MC)

!  MC = MA * MB

!  When one of the numbers MA, MB is known to have more zero digits (base MBASE) than the other,
!  it is faster if MB is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  FMMPY2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPY'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMMPY2(MA,MB,MC)

          CALL FMNTR(1,MC,MC,1,1)
      ELSE
          CALL FMMPY2(MA,MB,MC)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY

      SUBROUTINE FMMPY2(MA,MB,MC)

!  Internal multiplication routine.  MC = MA * MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KSHIFT,L,N1,NGUARD
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      KR_RETRY = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMMPY    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMMPY'
              CALL FMRSLT(MA,MB,MC,KRESLT)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          CALL FMIM(0,MC)
          MWK(START(MC)+1) = MIN(MACCA,MACCB)
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KFLAG = 0

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 2
          ELSE IF (MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,NDIG+2)
          ENDIF
      ENDIF
      IF (MWK(START(MA)+3)*MWK(START(MB)+3) < MBASE .AND. NGUARD < 3) NGUARD = 3

      N1 = NDIG + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+1
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          CALL FMMPY3(MPMA,MPMB,NGRDN,KSHIFT)
          IF (MWK(START(MWA)+3) == 0) THEN
              DO J = 3, 1+NDIG+NGRDN
                 MWK(START(MWA)+J) = MWK(START(MWA)+J+1)
              ENDDO
              MWK(START(MWA)+NDIG+NGRDN+2) = 0
              KSHIFT = 0
          ENDIF
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 1+NDIG+NGRDN, 2, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 1+NDIG+NGRDN, 2, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          KSHIFT = 0
          IF (MWK(START(MWA)+3) == 0) KSHIFT = 1
          MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

          CALL FMMPY3(MA,MB,NGUARD,KSHIFT)
      ENDIF

!             The multiplication is complete.
!             Round the result, move it to MC, and append the correct sign.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MC)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPY'
          CALL FMWARN
      ENDIF

      MWK(START(MC)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
          MWK(START(MC)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MC)+3))+1))/0.69315)
          MWK(START(MC)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MC)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY2

      SUBROUTINE FMMPY_R1(MA,MB)

!  MA = MA * MB

!  When one of the numbers MA, MB is known to have more zero digits (base MBASE) than the other,
!  it is faster if MB is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  FMMPY2_R1 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPY_R1'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMMPY2_R1(MA,MB)

          NAMEST(NCALL) = 'FMMPY_R1'
          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMMPY2_R1(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY_R1

      SUBROUTINE FMMPY2_R1(MA,MB)

!  Internal multiplication routine.  MA = MA * MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KSHIFT,L,N1,NGUARD
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NUMBER_USED_SAVE = NUMBER_USED
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      KR_RETRY = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMMPY    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMMPY_R1'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT)
              CALL FMEQ(MXY(1),MA)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          CALL FMIM(0,MA)
          MWK(START(MA)+1) = MIN(MACCA,MACCB)
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KFLAG = 0

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 2
          ELSE IF (MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,NDIG+2)
          ENDIF
      ENDIF
      IF (MWK(START(MA)+3)*MWK(START(MB)+3) < MBASE .AND. NGUARD < 3) NGUARD = 3

      N1 = NDIG + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+1
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          CALL FMMPY3(MPMA,MPMB,NGRDN,KSHIFT)
          IF (MWK(START(MWA)+3) == 0) THEN
              DO J = 3, 1+NDIG+NGRDN
                 MWK(START(MWA)+J) = MWK(START(MWA)+J+1)
              ENDDO
              MWK(START(MWA)+NDIG+NGRDN+2) = 0
              KSHIFT = 0
          ENDIF
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 1+NDIG+NGRDN, 2, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 1+NDIG+NGRDN, 2, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          KSHIFT = 0
          IF (MWK(START(MWA)+3) == 0) KSHIFT = 1
          MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

          CALL FMMPY3(MA,MB,NGUARD,KSHIFT)
      ENDIF

!             The multiplication is complete.
!             Round the result, move it to MA, and append the correct sign.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPY_R1'
          CALL FMWARN
      ENDIF

      MWK(START(MA)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MA)+3) /= 0)  &
          MWK(START(MA)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          MWK(START(MA)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MA)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY2_R1

      SUBROUTINE FMMPY_R2(MA,MB)

!  MB = MA * MB

!  When one of the numbers MA, MB is known to have more zero digits (base MBASE) than the other,
!  it is faster if MB is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  FMMPY2_R2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPY_R2'
          CALL FMNTR(2,MA,MB,2,1)

          CALL FMMPY2_R2(MA,MB)

          NAMEST(NCALL) = 'FMMPY_R2'
          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMMPY2_R2(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY_R2

      SUBROUTINE FMMPY2_R2(MA,MB)

!  Internal multiplication routine.  MB = MA * MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS,MD2B,MR,MS,MT1,MT2
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JRSSAV,K,KL,KR_RETRY,KRESLT,KT,KT1,KT2,KSHIFT,L,N1,NGUARD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NUMBER_USED_SAVE = NUMBER_USED
      MXY = -2
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      KR_RETRY = 0
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR. KDEBUG == 1) THEN
          CALL FMARGS('FMMPY    ',2,MA,MB,KRESLT)
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMMPY_R2'
              CALL FMRSLT(MA,MB,MXY(1),KRESLT)
              CALL FMEQ(MXY(1),MB)
              JRSIGN = JRSSAV
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          CALL FMIM(0,MB)
          MWK(START(MB)+1) = MIN(MACCA,MACCB)
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KFLAG = 0

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 2
          ELSE IF (MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,NDIG+2)
          ENDIF
      ENDIF
      IF (MWK(START(MA)+3)*MWK(START(MB)+3) < MBASE .AND. NGUARD < 3) NGUARD = 3

      N1 = NDIG + 1

      IF (MBASE*MBASE <= MXBASE/(4*MBASE)) THEN

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2^24) while
!             doing the operation.

          IF (NDIGL /= NDIG .OR. MBASEL /= MBASE .OR. NGUARL /= NGUARD) THEN
              MBASEL = MBASE
              NDIGL = NDIG
              NGUARL = NGUARD
              DO J = 2, 1000
                 MR = MBASE*MBASEL
                 IF (4*MR > MXBASE) THEN
                     N21 = J - 1
                     NDIG = (NDIGL-1)/N21 + 1
                     IF (NDIG < 2) NDIG = 2
                     NGRDN = (NDIGL+NGUARD-1)/N21 + 2 - NDIG
                     IF (NGRDN < 1) NGRDN = 1
                     EXIT
                 ENDIF
                 MBASE = MR
              ENDDO
              MBASEN = MBASE
              NDIGN = NDIG
          ELSE
              MBASE = MBASEN
              NDIG = NDIGN
          ENDIF
          IF (MBLOGS /= MBASE) CALL FMCONS
          J = NDIG
          NDIG = NDIG + NGRDN + 5
          IF (MPMA <= 0) THEN
              CALL FMDEFINE(MPMA)
          ELSE IF (SIZE_OF(MPMA) < NDIG+3) THEN
              CALL FMDEFINE(MPMA)
          ENDIF
          IF (MPMB <= 0) THEN
              CALL FMDEFINE(MPMB)
          ELSE IF (SIZE_OF(MPMB) < NDIG+3) THEN
              CALL FMDEFINE(MPMB)
          ENDIF
          NDIG = J
          MWK(START(MPMA)) = MWK(START(MA))
          MWK(START(MPMB)) = MWK(START(MB))
          MWK(START(MPMA)+1) = MWK(START(MA)+1)
          MWK(START(MPMB)+1) = MWK(START(MB)+1)
          MWK(START(MPMA)+2) = 0
          MWK(START(MPMB)+2) = 0
          L = 2 - N21
          DO J = 2, NDIGL+2-N21, N21
             MT1 = MWK(START(MA)+J+1)
             MT2 = MWK(START(MB)+J+1)
             DO K = J+1, J+N21-1
                MT1 = MT1*MBASEL + MWK(START(MA)+K+1)
                MT2 = MT2*MBASEL + MWK(START(MB)+K+1)
             ENDDO
             MWK(START(MPMA)+3+J/N21) = MT1
             MWK(START(MPMB)+3+J/N21) = MT2
             L = J
          ENDDO
          DO J = 3+L/N21, NDIG+NGRDN+1
             MWK(START(MPMA)+J+1) = 0
             MWK(START(MPMB)+J+1) = 0
          ENDDO
          IF (L+N21 <= NDIGL+1) THEN
              MT1 = 0
              MT2 = 0
              DO J = L+N21, L+2*N21-1
                 IF (J <= NDIGL+1) THEN
                     MT1 = MT1*MBASEL + MWK(START(MA)+J+1)
                     MT2 = MT2*MBASEL + MWK(START(MB)+J+1)
                 ELSE
                     MT1 = MT1*MBASEL
                     MT2 = MT2*MBASEL
                 ENDIF
              ENDDO
              MWK(START(MPMA)+3+(L+N21)/N21) = MT1
              MWK(START(MPMB)+3+(L+N21)/N21) = MT2
          ENDIF
          CALL FMMPY3(MPMA,MPMB,NGRDN,KSHIFT)
          IF (MWK(START(MWA)+3) == 0) THEN
              DO J = 3, 1+NDIG+NGRDN
                 MWK(START(MWA)+J) = MWK(START(MWA)+J+1)
              ENDDO
              MWK(START(MWA)+NDIG+NGRDN+2) = 0
              KSHIFT = 0
          ENDIF
          IF (MBASEL == 2 .AND. MBASE < INTMAX) THEN
              DO J = 1+NDIG+NGRDN, 2, -1
                 KT1 = MWK(START(MWA)+J+1)
                 KT = 2 + (J-2)*N21
                 KT2 = N21 + KT - 1
                 DO K = KT, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = IBITS(KT1,KT2-K,1)
                 ENDDO
              ENDDO
          ELSE
              MS = MBASEL**(N21-1)
              DO J = 1+NDIG+NGRDN, 2, -1
                 MR = MS
                 MT1 = MWK(START(MWA)+J+1)
                 DO K = 2+(J-2)*N21, MIN(1+(J-1)*N21,NDIGL+NGUARD+2)
                    MWK(START(MWA)+K+1) = AINT (MT1/MR)
                    MT1 = MT1 - MWK(START(MWA)+K+1)*MR
                    MR = AINT (MR/MBASEL)
                 ENDDO
              ENDDO
          ENDIF
          KSHIFT = 0
          IF (MWK(START(MWA)+3) == 0) KSHIFT = 1
          MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          NDIG = NDIGL
          MBASE = MBASEL
          IF (MBLOGS /= MBASE) CALL FMCONS
      ELSE

!             This is the normal case, where the base is not small.

          CALL FMMPY3(MA,MB,NGUARD,KSHIFT)
      ENDIF

!             The multiplication is complete.
!             Round the result, move it to MB, and append the correct sign.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPY_R2'
          CALL FMWARN
      ENDIF

      MWK(START(MB)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
          MWK(START(MB)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MACCB,MD2B)
      ELSE
          MWK(START(MB)+1) = MIN(MACCA,MACCB)
      ENDIF
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPY2_R2

      SUBROUTINE FMMPY3(MA,MB,NGUARD,KSHIFT)

!  Internal multiplication of MA*MB.  The result is returned in MWA.  Both MA and MB are positive.

!  NGUARD is the number of guard digits that will be used.
!  KSHIFT = 1 is returned if a left shift is pending (i.e., MWK(START(MWA)+3)=0).  The shift will
!             be done in FMMOVE.  KSHIFT = 0 is returned if no shift is pending.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: NGUARD,KSHIFT

      REAL (KIND(1.0D0)) :: MAXMWA,MBJ,MBKJ,MBM1,MBNORM,MK,MKT,MMAX,MT
      INTEGER :: J,JM1,JMA,JMWA,K,KB,KI,KJ,KL,KNZ,KWA,L,N1,NMETHD,NZDA,NZDB
      INTENT (IN) :: MA,MB,NGUARD
      INTENT (INOUT) :: KSHIFT

      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)

!             Check for using an FFT-based method if precision is very high.

      IF (NDIG >= 2200) THEN
          NZDA = 2
          NZDB = NDIG
          DO J = NDIG, 2, -1
             IF (MWK(START(MA)+J+2) /= 0) THEN
                 NZDA = J
                 EXIT
             ENDIF
          ENDDO
          DO J = 2, NDIG
             IF (MWK(START(MB)+J+2) == 0) NZDB = NZDB - 1
          ENDDO
          IF (REAL(NZDA)*NZDB < 236.0*NDIG*LOG(REAL(NDIG))) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMMPYFFT(MA,MB)
          IF (MWK(START(MWA)+3) == 0) THEN
              KSHIFT = 1
          ELSE
              KSHIFT = 0
          ENDIF
          RETURN
      ENDIF

      L = N1 + NGUARD
      MWK(START(MWA)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBM1 = MBASE - 1
      MBNORM = (MAXINT/(MBM1*MBM1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBM1 - MBM1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MB)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = NDIG, 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWK(START(MWA)+3) = 0
          DO K = NDIG+2, L
             MWK(START(MWA)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          DO K = 2, N1
             MWK(JMWA+K) = MWK(JMA+K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, N1
             MBJ = MWK(START(MB)+J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 JMA = START(MA) + 1 - JM1
                 JMWA = START(MWA) + 1
                 DO K = J+1, J+KL-1
                    MWK(JMWA+K) = MWK(JMWA+K) + MWK(JMA+K)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, JM1+2, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Perform the final normalization.  (Inner Loop)

          JMWA = START(MWA) + 1
          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MB)+KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MK
                MK = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MK
             ENDDO
             MWK(START(MWA)+KWA-KL) = MK
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWK(START(MWA)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

      RETURN
      END SUBROUTINE FMMPY3

      SUBROUTINE FMMPYD(MA,MB,MC,MD,ME)

!  Double multiplication routine.  MD = MA * MB,   ME = MA * MC

!  It is usually slightly faster to do two multiplications that have a common factor with one call.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD,ME

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACCC,MAS,MAXMWA,MBS,MBJ,MBKJ,MBM1,MBNORM,MCJ,MCKJ,MCS,  &
                            MD2B,MKB,MKC,MKT,MMAX,MR,MT,MTEMP
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JM1,JMA,JMWA,JMWD,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KSHIFT,KWA,L,N1,NGUARD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD,ME
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MD <= 0) THEN
          CALL FMDEFINE(MD)
      ELSE IF (SIZE_OF(MD) < NDIG+3) THEN
          CALL FMDEFINE(MD)
      ENDIF
      IF (ME <= 0) THEN
          CALL FMDEFINE(ME)
      ELSE IF (SIZE_OF(ME) < NDIG+3) THEN
          CALL FMDEFINE(ME)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      IF (MWD <= 0) THEN
          CALL FMDEFINE(MWD)
      ELSE IF (SIZE_OF(MWD) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWD)
      ENDIF

      NCALL = NCALL + 1
      JRSSAV = JRSIGN
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPYD'
          CALL FMNTR(2,MA,MB,2,1)
          IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MC,NDIG)
              ELSE
                  CALL FMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      MACCC = MWK(START(MC)+1)
      IF (NDIG >= 2200 .OR.                                                      &
          ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MC)+2)) > MEXPAB .OR. MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN .OR.  &
              MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN .OR.  &
              MWK(START(MC)+2) == MEXPOV .OR. MWK(START(MC)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
              MWK(START(MC)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL FMMPY2(MA,MB,MWD)
          KB = KFLAG
          CALL FMMPY2(MA,MC,ME)
          NCALL = NCALL - 1
          IF (((KFLAG < 0 .OR. KB < 0) .AND. KOVUN == 0) .OR.  &
              ((KFLAG == -4 .OR. KB == -4) .AND. KOVUN == 1)) THEN
              IF (KFLAG == -4 .OR. KB == -4) THEN
                  KFLAG = -4
              ELSE IF (KFLAG == -5 .OR. KB == -5) THEN
                  KFLAG = -5
              ELSE
                  KFLAG = MIN(KFLAG,KB)
              ENDIF
              NAMEST(NCALL) = 'FMMPYD'
              CALL FMWARN
          ENDIF
          CALL FMEQ(MWD,MD)
          GO TO 140
      ENDIF
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMIM(0,MD)
          MWK(START(MD)+1) = MIN(MACCA,MACCB)
          CALL FMIM(0,ME)
          MWK(START(ME)+1) = MIN(MACCA,MACCC)
          GO TO 140
      ENDIF
      IF (MWK(START(MB)+3) == 0) THEN
          CALL FMMPY2(MA,MC,ME)
          CALL FMIM(0,MD)
          MWK(START(MD)+1) = MIN(MACCA,MACCB)
          GO TO 140
      ENDIF
      IF (MWK(START(MC)+3) == 0) THEN
          CALL FMMPY2(MA,MB,MD)
          CALL FMIM(0,ME)
          MWK(START(ME)+1) = MIN(MACCA,MACCC)
          GO TO 140
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

      IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (MBASE < 10**6) NGUARD = MIN(NGUARD+1,NDIG+2)
      ENDIF
      IF ((MWK(START(MA)+3)*MWK(START(MB)+3) < MBASE .OR.  &
           MWK(START(MA)+3)*MWK(START(MC)+3) < MBASE) .AND. NGUARD < 3) NGUARD = 3

!             Save the sign of MA, MB, and MC and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      MCS = MWK(START(MC))

      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
      MWK(START(MWD)+2) = MWK(START(MA)+2) + MWK(START(MC)+2)
      L = NDIG + 1 + NGUARD
      MWK(START(MWA)+L+2) = 0
      MWK(START(MWD)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBM1 = MBASE - 1
      MBNORM = (MAXINT/(MBM1*MBM1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBM1 - MBM1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MB)+3)
          MCJ = MWK(START(MC)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = NDIG, 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWK(START(MWA)+3) = 0
          MWK(START(MWD)+3) = 0
          DO K = NDIG+2, L
             MWK(START(MWA)+K+1) = 0
             MWK(START(MWD)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          JMWD = START(MWD) + 2
          DO K = 2, N1
             MTEMP = MWK(JMA+K)
             MWK(JMWA+K) = MTEMP*MBJ
             MWK(JMWD+K) = MTEMP*MCJ
          ENDDO
          IF (MBJ > MCJ) THEN
              MAXMWA = MBJ
          ELSE
              MAXMWA = MCJ
          ENDIF
          DO J = 3, N1
             MBJ = MWK(START(MB)+J+1)
             MCJ = MWK(START(MC)+J+1)
             IF (MBJ > MCJ) THEN
                 MAXMWA = MAXMWA + MBJ
             ELSE
                 MAXMWA = MAXMWA + MCJ
             ENDIF
             JM1 = J - 1
             KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

             JMA = START(MA) + 1 - JM1
             JMWA = START(MWA) + 1
             JMWD = START(MWD) + 1
             DO K = J+1, J+KL-1
                MTEMP = MWK(JMA+K)
                MWK(JMWA+K) = MWK(JMWA+K) + MTEMP*MBJ
                MWK(JMWD+K) = MWK(JMWD+K) + MTEMP*MCJ
             ENDDO

             IF (MAXMWA > MMAX) THEN
                 MAXMWA = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, JM1+2, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                    MKT = INT (MWK(START(MWD)+KB+1)/MBASE)
                    MWK(START(MWD)+KB) = MWK(START(MWD)+KB) + MKT
                    MWK(START(MWD)+KB+1) = MWK(START(MWD)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Perform the final normalization.  (Inner Loop)

          JMWA = START(MWA) + 1
          JMWD = START(MWD) + 1
          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
             MKT = INT (MWK(JMWD+KB)/MBASE)
             MWK(JMWD+KB-1) = MWK(JMWD+KB-1) + MKT
             MWK(JMWD+KB) = MWK(JMWD+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
             MWK(START(MWD)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MB)+KJ+1)
             MCKJ = MWK(START(MC)+KJ+1)
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MKB = 0
             MKC = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MKB
                MKB = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MKB
                MT = MWK(START(MA)+KI-K+1)*MCKJ + MWK(START(MWD)+KWA-K+1) + MKC
                MKC = INT (MT/MBASE)
                MWK(START(MWD)+KWA-K+1) = MT - MBASE*MKC
             ENDDO
             MWK(START(MWA)+KWA-KL) = MKB
             MWK(START(MWD)+KWA-KL) = MKC
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWK(START(MWA)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplications are complete.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MB,MD)
              GO TO 120
          ENDIF
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MD)

  120 IF ((MAS > 0 .AND. MCS > 0) .OR. (MAS < 0 .AND. MCS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWD)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWD)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MC,ME)
              GO TO 130
          ENDIF
      ENDIF
      MR = 2*MWK(START(MWD)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWD,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWD)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWD)+KSHIFT+N1+1) = MWK(START(MWD)+KSHIFT+N1+1) + 1
                  MWK(START(MWD)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWD,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWD,ME)

  130 IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPYD'
          CALL FMWARN
      ENDIF

      MWK(START(MD)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0)  &
          MWK(START(MD)) = -1
      MWK(START(ME)) = 1
      IF (MAS*MCS < 0 .AND. MWK(START(ME)+2) /= MUNKNO .AND. MWK(START(ME)+3) /= 0)  &
          MWK(START(ME)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MD)+3))+1))/0.69315)
          MWK(START(MD)+1) = MIN(MACCA,MACCB,MD2B)
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(ME)+3))+1))/0.69315)
          MWK(START(ME)+1) = MIN(MACCA,MACCC,MD2B)
      ELSE
          MWK(START(MD)+1) = MIN(MACCA,MACCB)
          MWK(START(ME)+1) = MIN(MACCA,MACCC)
      ENDIF

  140 IF (NTRACE /= 0) THEN
          CALL FMNTR(1,MD,MD,1,1)
          IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(ME,NDIG)
              ELSE
                  CALL FMPRNT(ME)
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          IF (TEMPV(ME) == -1) TEMPV(ME) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYD

      SUBROUTINE FMMPYE(MA,MB,MC,MD,ME,MF,MG)

!  Triple multiplication routine.

!      ME = MA * MB,   MF = MA * MC,   MG = MA * MD

!  It is usually slightly faster to do three multiplications that have a common factor with
!  one call.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD,ME,MF,MG

      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACCC,MACCD,MAS,MAXJ,MAXMWA,MBS,MBJ,MBKJ,MBM1,MBNORM,  &
                            MCJ,MCKJ,MCS,MD2B,MDJ,MDKJ,MDS,MKB,MKC,MKD,MKT,MMAX,MR,MT,MTEMP
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JM1,JMA,JMWA,JMWD,JMWE,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KSHIFT,KWA,L,  &
                 N1,NGUARD
      INTENT (IN) :: MA,MB,MC,MD
      INTENT (INOUT) :: ME,MF,MG
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (ME <= 0) THEN
          CALL FMDEFINE(ME)
      ELSE IF (SIZE_OF(ME) < NDIG+3) THEN
          CALL FMDEFINE(ME)
      ENDIF
      IF (MF <= 0) THEN
          CALL FMDEFINE(MF)
      ELSE IF (SIZE_OF(MF) < NDIG+3) THEN
          CALL FMDEFINE(MF)
      ENDIF
      IF (MG <= 0) THEN
          CALL FMDEFINE(MG)
      ELSE IF (SIZE_OF(MG) < NDIG+3) THEN
          CALL FMDEFINE(MG)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      IF (MWD <= 0) THEN
          CALL FMDEFINE(MWD)
      ELSE IF (SIZE_OF(MWD) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWD)
      ENDIF
      IF (MWE <= 0) THEN
          CALL FMDEFINE(MWE)
      ELSE IF (SIZE_OF(MWE) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWE)
      ENDIF

      NCALL = NCALL + 1
      JRSSAV = JRSIGN
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPYE'
          CALL FMNTR(2,MA,MB,2,1)
          IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MC,NDIG)
                  CALL FMNTRJ(MD,NDIG)
              ELSE
                  CALL FMPRNT(MC)
                  CALL FMPRNT(MD)
              ENDIF
          ENDIF
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      MACCC = MWK(START(MC)+1)
      MACCD = MWK(START(MD)+1)
      IF (NDIG >= 2200 .OR.                                                      &
          ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MC)+2)) > MEXPAB .OR. ABS(MWK(START(MD)+2)) > MEXPAB .OR.  &
          MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN .OR.  &
              MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN .OR.  &
              MWK(START(MC)+2) == MEXPOV .OR. MWK(START(MC)+2) == MEXPUN .OR.  &
              MWK(START(MD)+2) == MEXPOV .OR. MWK(START(MD)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
              MWK(START(MC)+2) == MUNKNO .OR. MWK(START(MD)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL FMMPY2(MA,MB,MWD)
          KB = KFLAG
          CALL FMMPY2(MA,MC,MWE)
          KJ = KFLAG
          CALL FMMPY2(MA,MD,MG)
          NCALL = NCALL - 1
          IF (((KFLAG < 0 .OR. KB < 0 .OR. KJ < 0) .AND. KOVUN == 0)  &
              .OR. ((KFLAG == -4 .OR. KB == -4 .OR. KJ == -4) .AND.  &
              KOVUN == 1)) THEN
              IF (KFLAG == -4 .OR. KB == -4 .OR. KJ == -4) THEN
                  KFLAG = -4
              ELSE IF (KFLAG == -5 .OR. KB == -5 .OR. KJ == -5) THEN
                  KFLAG = -5
              ELSE
                  KFLAG = MIN(KFLAG,KB,KJ)
              ENDIF
              NAMEST(NCALL) = 'FMMPYE'
              CALL FMWARN
          ENDIF
          CALL FMEQ(MWD,ME)
          CALL FMEQ(MWE,MF)
          GO TO 150
      ENDIF
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMIM(0,ME)
          MWK(START(ME)+1) = MIN(MACCA,MACCB)
          CALL FMIM(0,MF)
          MWK(START(MF)+1) = MIN(MACCA,MACCC)
          CALL FMIM(0,MG)
          MWK(START(MG)+1) = MIN(MACCA,MACCD)
          GO TO 150
      ENDIF
      IF (MWK(START(MB)+3) == 0 .OR. MWK(START(MC)+3) == 0 .OR. MWK(START(MD)+3) == 0) THEN
          CALL FMMPY2(MA,MB,MWD)
          CALL FMMPY2(MA,MC,MWE)
          CALL FMMPY2(MA,MD,MG)
          CALL FMEQ(MWD,ME)
          CALL FMEQ(MWE,MF)
          GO TO 150
      ENDIF
      KFLAG = 0

!             NGUARD is the number of guard digits used.

      IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (MBASE < 10**6) NGUARD = MIN(NGUARD+1,NDIG+2)
      ENDIF
      IF ((MWK(START(MA)+3)*MWK(START(MB)+3) < MBASE .OR.  &
           MWK(START(MA)+3)*MWK(START(MC)+3) < MBASE .OR.  &
           MWK(START(MA)+3)*MWK(START(MD)+3) < MBASE) .AND. NGUARD < 3) NGUARD = 3

!             Save the signs and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      MCS = MWK(START(MC))
      MDS = MWK(START(MD))

      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
      MWK(START(MWD)+2) = MWK(START(MA)+2) + MWK(START(MC)+2)
      MWK(START(MWE)+2) = MWK(START(MA)+2) + MWK(START(MD)+2)
      L = NDIG + 1 + NGUARD
      MWK(START(MWA)+L+2) = 0
      MWK(START(MWD)+L+2) = 0
      MWK(START(MWE)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBM1 = MBASE - 1
      MBNORM = (MAXINT/(MBM1*MBM1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBM1 - MBM1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MB)+3)
          MCJ = MWK(START(MC)+3)
          MDJ = MWK(START(MD)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = NDIG, 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWK(START(MWA)+3) = 0
          MWK(START(MWD)+3) = 0
          MWK(START(MWE)+3) = 0
          DO K = NDIG+2, L
             MWK(START(MWA)+K+1) = 0
             MWK(START(MWD)+K+1) = 0
             MWK(START(MWE)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          JMWD = START(MWD) + 2
          JMWE = START(MWE) + 2
          DO K = 2, N1
             MTEMP = MWK(JMA+K)
             MWK(JMWA+K) = MTEMP*MBJ
             MWK(JMWD+K) = MTEMP*MCJ
             MWK(JMWE+K) = MTEMP*MDJ
          ENDDO
          MAXMWA = MBJ
          IF (MCJ > MAXMWA) MAXMWA = MCJ
          IF (MDJ > MAXMWA) MAXMWA = MDJ
          DO J = 3, N1
             MBJ = MWK(START(MB)+J+1)
             MCJ = MWK(START(MC)+J+1)
             MDJ = MWK(START(MD)+J+1)
             MAXJ = MBJ
             IF (MCJ > MAXJ) MAXJ = MCJ
             IF (MDJ > MAXJ) MAXJ = MDJ
             MAXMWA = MAXMWA + MAXJ
             JM1 = J - 1
             KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

             JMA = START(MA) + 1 - JM1
             JMWA = START(MWA) + 1
             JMWD = START(MWD) + 1
             JMWE = START(MWE) + 1
             DO K = J+1, J+KL-1
                MTEMP = MWK(JMA+K)
                MWK(JMWA+K) = MWK(JMWA+K) + MTEMP*MBJ
                MWK(JMWD+K) = MWK(JMWD+K) + MTEMP*MCJ
                MWK(JMWE+K) = MWK(JMWE+K) + MTEMP*MDJ
             ENDDO

             IF (MAXMWA > MMAX) THEN
                 MAXMWA = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, JM1+2, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                    MKT = INT (MWK(START(MWD)+KB+1)/MBASE)
                    MWK(START(MWD)+KB) = MWK(START(MWD)+KB) + MKT
                    MWK(START(MWD)+KB+1) = MWK(START(MWD)+KB+1) - MKT*MBASE
                    MKT = INT (MWK(START(MWE)+KB+1)/MBASE)
                    MWK(START(MWE)+KB) = MWK(START(MWE)+KB) + MKT
                    MWK(START(MWE)+KB+1) = MWK(START(MWE)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Perform the final normalization.  (Inner Loop)

          JMWA = START(MWA) + 1
          JMWD = START(MWD) + 1
          JMWE = START(MWE) + 1
          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
             MKT = INT (MWK(JMWD+KB)/MBASE)
             MWK(JMWD+KB-1) = MWK(JMWD+KB-1) + MKT
             MWK(JMWD+KB) = MWK(JMWD+KB) - MKT*MBASE
             MKT = INT (MWK(JMWE+KB)/MBASE)
             MWK(JMWE+KB-1) = MWK(JMWE+KB-1) + MKT
             MWK(JMWE+KB) = MWK(JMWE+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
             MWK(START(MWD)+J+1) = 0
             MWK(START(MWE)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MB)+KJ+1)
             MCKJ = MWK(START(MC)+KJ+1)
             MDKJ = MWK(START(MD)+KJ+1)
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MKB = 0
             MKC = 0
             MKD = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MKB
                MKB = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MKB
                MT = MWK(START(MA)+KI-K+1)*MCKJ + MWK(START(MWD)+KWA-K+1) + MKC
                MKC = INT (MT/MBASE)
                MWK(START(MWD)+KWA-K+1) = MT - MBASE*MKC
                MT = MWK(START(MA)+KI-K+1)*MDKJ + MWK(START(MWE)+KWA-K+1) + MKD
                MKD = INT (MT/MBASE)
                MWK(START(MWE)+KWA-K+1) = MT - MBASE*MKD
             ENDDO
             MWK(START(MWA)+KWA-KL) = MKB
             MWK(START(MWD)+KWA-KL) = MKC
             MWK(START(MWE)+KWA-KL) = MKD
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWK(START(MWA)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplications are complete.

      IF ((MAS > 0 .AND. MBS > 0) .OR. (MAS < 0 .AND. MBS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MB,ME)
              GO TO 120
          ENDIF
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,ME)

  120 IF ((MAS > 0 .AND. MCS > 0) .OR. (MAS < 0 .AND. MCS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWD)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWD)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MC,MF)
              GO TO 130
          ENDIF
      ENDIF
      MR = 2*MWK(START(MWD)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWD,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWD)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWD)+KSHIFT+N1+1) = MWK(START(MWD)+KSHIFT+N1+1) + 1
                  MWK(START(MWD)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWD,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWD,MF)

  130 IF ((MAS > 0 .AND. MDS > 0) .OR. (MAS < 0 .AND. MDS < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWE)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWE)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) THEN
              CALL FMMPY2(MA,MD,MG)
              GO TO 140
          ENDIF
      ENDIF
      MR = 2*MWK(START(MWE)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWE,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWE)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWE)+KSHIFT+N1+1) = MWK(START(MWE)+KSHIFT+N1+1) + 1
                  MWK(START(MWE)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWE,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWE,MG)

  140 IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPYE'
          CALL FMWARN
      ENDIF

      MWK(START(ME)) = 1
      IF (MAS*MBS < 0 .AND. MWK(START(ME)+2) /= MUNKNO .AND. MWK(START(ME)+3) /= 0)  &
          MWK(START(ME)) = -1
      MWK(START(MF)) = 1
      IF (MAS*MCS < 0 .AND. MWK(START(MF)+2) /= MUNKNO .AND. MWK(START(MF)+3) /= 0)  &
          MWK(START(MF)) = -1
      MWK(START(MG)) = 1
      IF (MAS*MDS < 0 .AND. MWK(START(MG)+2) /= MUNKNO .AND. MWK(START(MG)+3) /= 0)  &
          MWK(START(MG)) = -1

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(ME)+3))+1))/0.69315)
          MWK(START(ME)+1) = MIN(MACCA,MACCB,MD2B)
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MF)+3))+1))/0.69315)
          MWK(START(MF)+1) = MIN(MACCA,MACCC,MD2B)
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MG)+3))+1))/0.69315)
          MWK(START(MG)+1) = MIN(MACCA,MACCD,MD2B)
      ELSE
          MWK(START(ME)+1) = MIN(MACCA,MACCB)
          MWK(START(MF)+1) = MIN(MACCA,MACCC)
          MWK(START(MG)+1) = MIN(MACCA,MACCD)
      ENDIF

  150 IF (NTRACE /= 0) THEN
          CALL FMNTR(1,ME,ME,1,1)
          IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL FMNTRJ(MF,NDIG)
                  CALL FMNTRJ(MG,NDIG)
              ELSE
                  CALL FMPRNT(MF)
                  CALL FMPRNT(MG)
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(ME) == -1) TEMPV(ME) = -2
          IF (TEMPV(MF) == -1) TEMPV(MF) = -2
          IF (TEMPV(MG) == -1) TEMPV(MG) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYE

      RECURSIVE SUBROUTINE FMMPYFFT(MA,MB)

!  Internal multiplication routine MA*MB for very high precision.
!  The result is returned in the internal work area MWA.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the FFT is faster when N has only small prime factors.

!  Use one of two methods, depending on the base MBASE.  When precision is high enough, the size of
!  the digits being convolved using FFT's must be reduced in order to keep the convolution products
!  from being too big to exactly recover the integer results.  The FFT operation has double
!  precision rounding errors, but the result of the convolution of two lists of integers is really
!  an integer.

!  For example, assume double precision carries 53 bits giving about 16 significant digit accuracy,
!  all the (positive) numbers in the two lists are less than K, and there are N numbers in each
!  list.  Then the convolution is an integer less than N*K*K.  A typical case might have MA and MB
!  in base 10**7 with 50,000 digits for about 350,000 significant digit precision.  This means
!  K = 10**7 and N = 5*10**4, so N*K*K = 5*10**18.  That is too big for this double precision.

!  Method 1:  If the base is a power of a small base ( MBASE = B**L for 2 <= B <= 19 ), then change
!             MA and MB to a base that is a smaller power of B to reduce the size of the individual
!             digits.  Changing to this smaller base is a fast O(N) operation.

!             In the example above, MA and MB could be changed to numbers with about 120,000 digits
!             in base 10**3.  Then N*K*K = 1.2*10**11, so even after losing 2 or 3 digits to
!             rounding in the FFT the results could be reliably rounded to the nearest integer.

!             This is the method used for the default FM power-of-ten base chosen in FMSET.
!             It is faster than method 2.

!  Method 2:  Here a fast change to a smaller base is not available, so each of MA and MB is split
!             into two pieces.  Each piece is a number with the same base and precision as MA and
!             MB have, but has artificially small digits.

!             Suppose the base is near 10**7 but not a power, say MBASE = B = 12345678, and MA or
!             MB is
!                       X = 1234567/B + 2345678/B**2 + ... + 9876543/B**N

!             Let K = SQRT(B) = 3513 be the upper bound on the size of the digits in the two
!             pieces, X1 and X2.  We write X = X1 + K*X2 by defining the digits of X1 to be the
!             digits of X mod K, and the digits of X2 to be the digits of X / K.  That gives

!                       X1 = 1504/B + 2507/B**2 + ... + 1500/B**N
!                       X2 =  351/B +  667/B**2 + ... + 2811/B**N

!             Now, X*Y = ( X1 + K*X2 ) ( Y1 + K*Y2 )
!                      =   X1*Y1 + K*(X1*Y2 + X2*Y1) + K**2*X2*Y2

!             Since the digits of X1 and X2 are formed one at a time from the corresponding digits
!             of X, generating X1 and X2 is a fast O(N) operation.

!             The terms in these products are still written in base b, but the digits are small,
!             no more than K.  These four multiplications are reduced to three, computing
!             X1*Y1, X2*Y2, and (X1+X2)*(Y1+Y2).
!             Then X1*Y2 + X2*Y1 = (X1+X2)*(Y1+Y2) - X1*Y1 - X2*Y2.  See Knuth, V 2, section 4.3.3.

!             Method 2 is recursive, since if N is large enough N*K*K may still be too large for
!             the double precision rounding errors.  In that case another splitting is done, giving
!             digits less than SQRT(AINT(SQRT(B))) = 59 in this example.

!             For B = 12345678 and 53-bit double precision, the first splitting is done for all N,
!             since B**2 > 10**14 is already too close to 16-digit integers.
!             A second splitting is done for N larger than about 4*10**5 (about 2.8 million decimal
!             digits), and a third for N > 1.4*10**9 (about 10 billion decimals).

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: J,K,L,MXY(8),NDSAVE
      DOUBLE PRECISION :: B,BL,D,DMAX

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2

!             Check to see if the base is a power of a small integer.

      DO J = 2, 19
         IF (J == 2 .OR. J == 10) THEN
             B = 12 - J
         ELSE
             B = J
         ENDIF
         BL = 1
         DO L = 1, 100
            BL = BL*B
            IF (MBASE == BL) THEN
                CALL FMMPYFFT1(MA,MB,B,L)
                MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
                TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                RETURN
            ENDIF
            IF (MBASE < BL) EXIT
         ENDDO
      ENDDO

!             Use method 2.

!             Find the maximum size of the digits in MA and MB.

      DMAX = 0
      DO J = 1, NDIG
         D = MWK(START(MA)+J+2)
         IF (D > DMAX) DMAX = D
         D = MWK(START(MB)+J+2)
         IF (D > DMAX) DMAX = D
      ENDDO

!             Check to see if splitting is needed.

      IF (DMAX**2 > 1/(4.0D3*NDIG*EPSILON(1.0D0))) THEN
          K = INT(SQRT(DMAX))
          NDSAVE = NDIG
          NDIG = 2*NDIG + 2
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(4),NDSAVE,NDIG)
          CALL FMIM(0,MXY(5))
          CALL FMIM(0,MXY(6))
          CALL FMIM(0,MXY(7))
          CALL FMIM(0,MXY(8))
          DO J = 1, NDIG
             L = MWK(START(MXY(1))+J+2)
             MWK(START(MXY(1))+J+2) = MOD(L,K)
             MWK(START(MXY(2))+J+2) = L/K
             L = MWK(START(MXY(3))+J+2)
             MWK(START(MXY(3))+J+2) = MOD(L,K)
             MWK(START(MXY(4))+J+2) = L/K
          ENDDO

!             Normalize any of these having a zero leading digit.

          IF (MWK(START(MXY(1))+3) == 0) CALL FMMPYFFT_NORM(MXY(1))
          IF (MWK(START(MXY(2))+3) == 0) CALL FMMPYFFT_NORM(MXY(2))
          IF (MWK(START(MXY(3))+3) == 0) CALL FMMPYFFT_NORM(MXY(3))
          IF (MWK(START(MXY(4))+3) == 0) CALL FMMPYFFT_NORM(MXY(4))

          NDIG = NDSAVE
          CALL FMMPYFFT(MXY(1),MXY(3))
          NDIG = 2*NDIG + 2
          CALL FMMOVE(MWA,MXY(5))
          NDIG = NDSAVE
          CALL FMMPYFFT(MXY(2),MXY(4))
          NDIG = 2*NDIG + 2
          CALL FMMOVE(MWA,MXY(6))
          CALL FMADD2(MXY(1),MXY(2),MXY(7))
          CALL FMADD2(MXY(3),MXY(4),MXY(8))
          NDIG = NDSAVE
          CALL FMMPYFFT(MXY(7),MXY(8))
          NDIG = 2*NDIG + 2
          CALL FMMOVE(MWA,MXY(7))
          KSUB = 1
          CALL FMADD2(MXY(7),MXY(5),MXY(1))
          CALL FMADD2(MXY(1),MXY(6),MXY(2))
          KSUB = 0
          CALL FMMPYFFTI(MXY(6),K,MXY(3))
          CALL FMADD2(MXY(3),MXY(2),MXY(4))
          CALL FMMPYFFTI(MXY(4),K,MXY(3))
          CALL FMADD2(MXY(3),MXY(5),MXY(4))
          MWK(START(MWA)) = MWK(START(MXY(4)))
          MWK(START(MWA)+1) = MWK(START(MXY(4))+1)
          MWK(START(MWA)+2) = MWK(START(MXY(4))+2)
          IF (MWK(START(MWA)+3) == 0) MWK(START(MWA)+2) = MWK(START(MWA)+2) + 1
          NDIG = NDSAVE
      ELSE
          CALL FMMPYFFT2(MA,MB)
          MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
      ENDIF

      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYFFT

      SUBROUTINE FMMPYFFT1(MA,MB,B,L)

      USE FMVALS
      IMPLICIT NONE

!  Internal multiplication routine MA*MB for very high precision.
!  The base for the arithmetic (MBASE) is a power of B, B**L, for 2 <= B <= 19.  This includes the
!  usual case where the default base chosen in FMSET is a power of 10.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the FFT is faster when N has only small prime factors.

      INTEGER :: MA,MB
      INTEGER :: J,K,K2,K3,K5,KA,L,L2,L3,L5,N,N2,ND,NUM,NUMAR,NUMAI,NUMBR,NUMBI
      REAL (KIND(0.0D0)) :: D2,D3,DMIN,DPROD
      REAL (KIND(0.0D0)) :: B,BASE,C,D,T,T2,THETA,TMA,TMB
      COMPLEX (KIND(0.0D0)), DIMENSION(:), ALLOCATABLE :: CX,CY,CZ
      COMPLEX (KIND(0.0D0)) :: CI,H1,H2,ST,W0,W

!             Initialize guard digits in MWA.

      DO J = 2*NDIG, MIN(2*NDIG+30,SIZE_OF(MWA)-3)
         MWK(START(MWA)+J+2) = 0
      ENDDO

!             If the base and/or number of digits is too large, rounding errors in the FFT
!             calculation will cause the result to be wrong.
!             Reduce the base if necessary.

      ND = NDIG
      BASE = MBASE
      IF (MBASE**2 > 1/(1.0D3*ND*EPSILON(1.0D0))) THEN
          BASE = 1/SQRT(1.0D3*ND*EPSILON(1.0D0))
          K = LOG(BASE)/LOG(B)
          BASE = B**K
          ND = NDIG*DBLE(L)/K + 1
      ENDIF

!             Choose the number of digits to use for the FFT.  Make the size of the array have no
!             prime factors other than 2, 3, or 5.

      L2 = LOG(10.0D0*ND)/LOG(2.0D0) + 2
      L3 = LOG(10.0D0*ND)/LOG(3.0D0) + 2
      L5 = LOG(10.0D0*ND)/LOG(5.0D0) + 2
      DMIN = HUGE(2.0D0)
      D2 = 2.0D0
      DO K2 = 1, L2
         D3 = 1.0D0
         DO K3 = 0, L3
            DPROD = D2*D3
            DO K5 = 0, L5
               IF (DPROD > DMIN) EXIT
               IF (DPROD >= ND) THEN
                   IF (DPROD < DMIN) DMIN = DPROD
               ENDIF
               DPROD = 5*DPROD
            ENDDO
            D3 = 3*D3
         ENDDO
         D2 = 2*D2
      ENDDO
      N = DMIN
      N2 = N*2
      ALLOCATE(CX(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      ALLOCATE(CY(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      ALLOCATE(CZ(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF

!             Pad the lists of digits with zeros, then pack the length 2*N real arrays into
!             length N complex arrays to speed up the FFT operations.

      IF (BASE == MBASE) THEN
          DO J = NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          DO J = 2, NDIG, 2
             CX(J/2) = CMPLX( MWK(START(MA)+J+1) , MWK(START(MA)+J+2) , KIND(0.0D0) )
             CY(J/2) = CMPLX( MWK(START(MB)+J+1) , MWK(START(MB)+J+2) , KIND(0.0D0) )
          ENDDO
          IF (MOD(NDIG,2) == 1) THEN
              CX(NDIG/2+1) = MWK(START(MA)+NDIG+2)
              CY(NDIG/2+1) = MWK(START(MB)+NDIG+2)
          ENDIF
      ELSE
          DO J = NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          D = MBASE/BASE
          C = MBASE*D
          TMA = MWK(START(MA)+3)*MBASE + MWK(START(MA)+4)
          NUMAR = TMA/C
          TMA = TMA - C*NUMAR
          TMB = MWK(START(MB)+3)*MBASE + MWK(START(MB)+4)
          NUMBR = TMB/C
          TMB = TMB - C*NUMBR
          K = 0
          DO J = 3, NDIG
  110        IF (C >= BASE) THEN
                 C = C/BASE
             ELSE
                 TMA = TMA*MBASE + MWK(START(MA)+J+2)
                 TMB = TMB*MBASE + MWK(START(MB)+J+2)
                 C = C*MBASE
                 CYCLE
             ENDIF
             NUMAI = TMA/C
             TMA = TMA - C*NUMAI
             NUMBI = TMB/C
             TMB = TMB - C*NUMBI
             IF (NUMAR < 0) THEN
                 NUMAR = NUMAI
                 NUMBR = NUMBI
             ELSE
                 K = K + 1
                 CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                 CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 NUMAR = -1
             ENDIF
             GO TO 110
          ENDDO
          DO
             IF (C >= BASE) THEN
                 C = C/BASE
             ELSE
                 NUMAI = TMA*(BASE/C)
                 NUMBI = TMB*(BASE/C)
                 IF (NUMAR < 0) THEN
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAI) , 0.0D0 , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBI) , 0.0D0 , KIND(0.0D0) )
                 ELSE
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 ENDIF
                 EXIT
             ENDIF
             NUMAI = TMA/C
             TMA = TMA - C*NUMAI
             NUMBI = TMB/C
             TMB = TMB - C*NUMBI
             IF (NUMAR < 0) THEN
                 NUMAR = NUMAI
                 NUMBR = NUMBI
             ELSE
                 K = K + 1
                 CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                 CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 NUMAR = -1
             ENDIF
          ENDDO
      ENDIF

!             Transform.

      CALL FMFFT(CX,N,CZ)
      IF (KSQR /= 1) THEN
          CALL FMFFT(CY,N,CZ)
      ENDIF

!             Unpack the two transforms.

      THETA = ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CX(J)+CONJG(CX(N+2-J)))
         H2 = -0.5D0*CI*(CX(J)-CONJG(CX(N+2-J)))
         CX(J) = H1 + W*H2
         CX(N+2-J) = CONJG(H1 - W*H2)
         IF (KSQR /= 1) THEN
             H1 = 0.5D0*(CY(J)+CONJG(CY(N+2-J)))
             H2 = -0.5D0*CI*(CY(J)-CONJG(CY(N+2-J)))
             CY(J) = H1 + W*H2
             CY(N+2-J) = CONJG(H1 - W*H2)
         ENDIF
         W = W + ST*W
      ENDDO
      CX(1) = CMPLX( REAL(CX(1))+AIMAG(CX(1)) , REAL(CX(1))-AIMAG(CX(1)) , KIND(0.0D0) )
      IF (KSQR /= 1) THEN
          CY(1) = CMPLX( REAL(CY(1))+AIMAG(CY(1)) , REAL(CY(1))-AIMAG(CY(1)) , KIND(0.0D0) )
      ENDIF

!             Multiply.

      IF (KSQR /= 1) THEN
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CY(1)) , AIMAG(CX(1))*AIMAG(CY(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CY(J)
          ENDDO
      ELSE
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CX(1)) , AIMAG(CX(1))*AIMAG(CX(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CX(J)
          ENDDO
      ENDIF

!             Pack the product for input to the final FFT.

      THETA = -ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CZ(J)+CONJG(CZ(N+2-J)))
         H2 = 0.5D0*CI*(CZ(J)-CONJG(CZ(N+2-J)))
         CZ(J) = H1 + W*H2
         CZ(N+2-J) = CONJG(H1 - W*H2)
         W = W + ST*W
      ENDDO
      CZ(1) = CMPLX( REAL(CZ(1))+AIMAG(CZ(1)) , REAL(CZ(1))-AIMAG(CZ(1)) , KIND(0.0D0) )*0.5D0

!             Transform the product to get the convolution of the original inputs.

      CALL FMFFT(CZ,N,CY)
      T = 1.0D0/N
      DO J = 1, N
         CZ(J) = CZ(J)*T
      ENDDO

!             Normalize the digits.

!             The CZ array holds the result in scrambled order, with unnormalized digits.
!             The leading two digits of the convolution are in CZ(1), then the next two
!             are in CZ(N), then CZ(N-1), ..., CZ(2).
!             The imaginary part of CZ(2) is zero (up to roundoff), for a total of 2*N-1
!             digits in the convolution.
!             These digits can be as big as N*BASE^2 here.
!
!             First normalize and unscramble.

      IF (BASE == MBASE) THEN
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N2
          IF (KA <= SIZE_OF(MWA)-3) THEN
              MWK(START(MWA)+KA+2) = T2
          ENDIF
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE_OF(MWA)-3) THEN
                 MWK(START(MWA)+KA+2) = T2
             ENDIF
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE_OF(MWA)-3) THEN
                 MWK(START(MWA)+KA+2) = T2
             ENDIF
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T2
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T2
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T
      ELSE
          CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N
          CX(KA) = CI*T2
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             CX(KA) = T2 + CX(KA)
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             CX(KA) = CI*T2
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          CX(KA) = T2 + CX(KA)
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          CX(KA) = T + CI*T2
          TMA = 0
          C = 1
          K = 0
          DO J = 1, N2
             IF (MOD(J,2) == 1) THEN
                 NUM = REAL(CX((J+1)/2))
             ELSE
                 NUM = AIMAG(CX((J+1)/2))
             ENDIF
             TMA = TMA*BASE + NUM
             C = C*BASE
             IF (C < MBASE) CYCLE
             C = C/MBASE
             NUM = TMA/C
             TMA = TMA - C*NUM
             K = K + 1
             IF (K <= SIZE_OF(MWA)-3 .AND. K <= 2*NDIG+2) THEN
                 MWK(START(MWA)+K+2) = NUM
             ELSE
                 EXIT
             ENDIF
          ENDDO
          K = K + 1
          IF (K <= SIZE_OF(MWA)-3 .AND. K <= 2*NDIG+2) MWK(START(MWA)+K+2) = TMA*(MBASE/C)
      ENDIF

      DEALLOCATE(CX,CY,CZ)
      RETURN
      END SUBROUTINE FMMPYFFT1

      SUBROUTINE FMMPYFFT2(MA,MB)
      USE FMVALS
      IMPLICIT NONE

!  Internal multiplication routine MA*MB for very high precision.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the FFT is faster when N has only small prime factors.
!  This routine is used for method 2 of FMMPYFFT, where the base is not a power of a small number
!  and a different kind of splitting is used to avoid fft convolutions becoming too large.

      INTEGER :: MA,MB
      INTEGER :: J,K,K2,K3,K5,KA,L2,L3,L5,N,N2,ND,NUM,NUMAR,NUMAI,NUMBR,NUMBI
      REAL (KIND(0.0D0)) :: D2,D3,DMIN,DPROD
      REAL (KIND(0.0D0)) :: BASE,C,D,T,T2,THETA,TMA,TMB
      COMPLEX (KIND(0.0D0)), DIMENSION(:), ALLOCATABLE :: CX,CY,CZ
      COMPLEX (KIND(0.0D0)) :: CI,H1,H2,ST,W0,W

      ND = NDIG
      BASE = MBASE

!             Initialize guard digits in MWA.

      DO J = 2*NDIG, MIN(2*NDIG+30,SIZE_OF(MWA)-3)
         MWK(START(MWA)+J+2) = 0
      ENDDO

!             Choose the number of digits to use for the FFT.  Make the size of the array have no
!             prime factors other than 2, 3, or 5.

      L2 = LOG(10.0D0*ND)/LOG(2.0D0) + 2
      L3 = LOG(10.0D0*ND)/LOG(3.0D0) + 2
      L5 = LOG(10.0D0*ND)/LOG(5.0D0) + 2
      DMIN = HUGE(2.0D0)
      D2 = 2.0D0
      DO K2 = 1, L2
         D3 = 1.0D0
         DO K3 = 0, L3
            DPROD = D2*D3
            DO K5 = 0, L5
               IF (DPROD > DMIN) EXIT
               IF (DPROD >= ND) THEN
                   IF (DPROD < DMIN) DMIN = DPROD
               ENDIF
               DPROD = 5*DPROD
            ENDDO
            D3 = 3*D3
         ENDDO
         D2 = 2*D2
      ENDDO
      N = DMIN
      N2 = N*2
      ALLOCATE(CX(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      ALLOCATE(CY(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF
      ALLOCATE(CZ(N),STAT=J)
      IF (J /= 0) THEN
          CALL FMDEFINE_ERROR(1)
      ENDIF

!             Pad the lists of digits with zeros, then pack the length 2*N real arrays into
!             length N complex arrays to speed up the FFT operations.

      IF (BASE == MBASE) THEN
          DO J = NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          DO J = 2, NDIG, 2
             CX(J/2) = CMPLX( MWK(START(MA)+J+1) , MWK(START(MA)+J+2) , KIND(0.0D0) )
             CY(J/2) = CMPLX( MWK(START(MB)+J+1) , MWK(START(MB)+J+2) , KIND(0.0D0) )
          ENDDO
          IF (MOD(NDIG,2) == 1) THEN
              CX(NDIG/2+1) = MWK(START(MA)+NDIG+2)
              CY(NDIG/2+1) = MWK(START(MB)+NDIG+2)
          ENDIF
      ELSE
          DO J = NDIG/2, N
             CX(J) = 0
             CY(J) = 0
          ENDDO
          D = MBASE/BASE
          C = MBASE*D
          TMA = MWK(START(MA)+3)*MBASE + MWK(START(MA)+4)
          NUMAR = TMA/C
          TMA = TMA - C*NUMAR
          TMB = MWK(START(MB)+3)*MBASE + MWK(START(MB)+4)
          NUMBR = TMB/C
          TMB = TMB - C*NUMBR
          K = 0
          DO J = 3, NDIG
  110        IF (C >= BASE) THEN
                 C = C/BASE
             ELSE
                 TMA = TMA*MBASE + MWK(START(MA)+J+2)
                 TMB = TMB*MBASE + MWK(START(MB)+J+2)
                 C = C*MBASE
                 CYCLE
             ENDIF
             NUMAI = TMA/C
             TMA = TMA - C*NUMAI
             NUMBI = TMB/C
             TMB = TMB - C*NUMBI
             IF (NUMAR < 0) THEN
                 NUMAR = NUMAI
                 NUMBR = NUMBI
             ELSE
                 K = K + 1
                 CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                 CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 NUMAR = -1
             ENDIF
             GO TO 110
          ENDDO
          DO
             IF (C >= BASE) THEN
                 C = C/BASE
             ELSE
                 NUMAI = TMA*(BASE/C)
                 NUMBI = TMB*(BASE/C)
                 IF (NUMAR < 0) THEN
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAI) , 0.0D0 , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBI) , 0.0D0 , KIND(0.0D0) )
                 ELSE
                     K = K + 1
                     CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                     CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 ENDIF
                 EXIT
             ENDIF
             NUMAI = TMA/C
             TMA = TMA - C*NUMAI
             NUMBI = TMB/C
             TMB = TMB - C*NUMBI
             IF (NUMAR < 0) THEN
                 NUMAR = NUMAI
                 NUMBR = NUMBI
             ELSE
                 K = K + 1
                 CX(K) = CMPLX( DBLE(NUMAR) , DBLE(NUMAI) , KIND(0.0D0) )
                 CY(K) = CMPLX( DBLE(NUMBR) , DBLE(NUMBI) , KIND(0.0D0) )
                 NUMAR = -1
             ENDIF
          ENDDO
      ENDIF

!             Transform.

      CALL FMFFT(CX,N,CZ)
      IF (KSQR /= 1) THEN
          CALL FMFFT(CY,N,CZ)
      ENDIF

!             Unpack the two transforms.

      THETA = ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CX(J)+CONJG(CX(N+2-J)))
         H2 = -0.5D0*CI*(CX(J)-CONJG(CX(N+2-J)))
         CX(J) = H1 + W*H2
         CX(N+2-J) = CONJG(H1 - W*H2)
         IF (KSQR /= 1) THEN
             H1 = 0.5D0*(CY(J)+CONJG(CY(N+2-J)))
             H2 = -0.5D0*CI*(CY(J)-CONJG(CY(N+2-J)))
             CY(J) = H1 + W*H2
             CY(N+2-J) = CONJG(H1 - W*H2)
         ENDIF
         W = W + ST*W
      ENDDO
      CX(1) = CMPLX( REAL(CX(1))+AIMAG(CX(1)) , REAL(CX(1))-AIMAG(CX(1)) , KIND(0.0D0) )
      IF (KSQR /= 1) THEN
          CY(1) = CMPLX( REAL(CY(1))+AIMAG(CY(1)) , REAL(CY(1))-AIMAG(CY(1)) , KIND(0.0D0) )
      ENDIF

!             Multiply.

      IF (KSQR /= 1) THEN
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CY(1)) , AIMAG(CX(1))*AIMAG(CY(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CY(J)
          ENDDO
      ELSE
          CZ(1) = CMPLX( REAL(CX(1))*REAL(CX(1)) , AIMAG(CX(1))*AIMAG(CX(1)) , KIND(0.0D0) )
          DO J = 2, N
             CZ(J) = CX(J)*CX(J)
          ENDDO
      ENDIF

!             Pack the product for input to the final FFT.

      THETA = -ACOS(-1.0D0)/N
      W0 = CMPLX( COS(THETA) , SIN(THETA) , KIND(0.0D0) )
      W = W0
      ST = CMPLX( -2*SIN(THETA/2)**2 , SIN(THETA) , KIND(0.0D0) )
      CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
      DO J = 2, N/2
         H1 = 0.5D0*(CZ(J)+CONJG(CZ(N+2-J)))
         H2 = 0.5D0*CI*(CZ(J)-CONJG(CZ(N+2-J)))
         CZ(J) = H1 + W*H2
         CZ(N+2-J) = CONJG(H1 - W*H2)
         W = W + ST*W
      ENDDO
      CZ(1) = CMPLX( REAL(CZ(1))+AIMAG(CZ(1)) , REAL(CZ(1))-AIMAG(CZ(1)) , KIND(0.0D0) )*0.5D0

!             Transform the product to get the convolution of the original inputs.

      CALL FMFFT(CZ,N,CY)
      T = 1.0D0/N
      DO J = 1, N
         CZ(J) = CZ(J)*T
      ENDDO

!             Normalize the digits.

!             The CZ array holds the result in scrambled order, with unnormalized digits.
!             The leading two digits of the convolution are in CZ(1), then the next two
!             are in CZ(N), then CZ(N-1), ..., CZ(2).
!             The imaginary part of CZ(2) is zero (up to roundoff), for a total of 2*N-1
!             digits in the convolution.
!             These digits can be as big as N*BASE^2 here.
!
!             First normalize and unscramble.

      IF (BASE == MBASE) THEN
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N2
          IF (KA <= SIZE_OF(MWA)-3) THEN
              MWK(START(MWA)+KA+2) = T2
          ENDIF
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE_OF(MWA)-3) THEN
                 MWK(START(MWA)+KA+2) = T2
             ENDIF
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             IF (KA <= SIZE_OF(MWA)-3) THEN
                 MWK(START(MWA)+KA+2) = T2
             ENDIF
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T2
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T2
          KA = KA - 1
          MWK(START(MWA)+KA+2) = T
      ELSE
          CI = CMPLX( 0.0D0 , 1.0D0 , KIND(0.0D0) )
          D = AINT( 0.5D0+REAL(CZ(2)) , KIND(0.0D0) )
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = N
          CX(KA) = CI*T2
          DO J = 3, N
             D = AINT( 0.5D0+AIMAG(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             CX(KA) = T2 + CX(KA)
             D = AINT( 0.5D0+REAL(CZ(J)) , KIND(0.0D0) ) + T
             T = AINT( D/BASE, KIND(0.0D0) )
             T2 = D - T*BASE
             KA = KA - 1
             CX(KA) = CI*T2
          ENDDO
          D = AINT( 0.5D0+AIMAG(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          CX(KA) = T2 + CX(KA)
          D = AINT( 0.5D0+REAL(CZ(1)) , KIND(0.0D0) ) + T
          T = AINT( D/BASE, KIND(0.0D0) )
          T2 = D - T*BASE
          KA = KA - 1
          CX(KA) = T + CI*T2
          TMA = 0
          C = 1
          K = 0
          DO J = 1, N2
             IF (MOD(J,2) == 1) THEN
                 NUM = REAL(CX((J+1)/2))
             ELSE
                 NUM = AIMAG(CX((J+1)/2))
             ENDIF
             TMA = TMA*BASE + NUM
             C = C*BASE
             IF (C < MBASE) CYCLE
             C = C/MBASE
             NUM = TMA/C
             TMA = TMA - C*NUM
             K = K + 1
             IF (K <= SIZE_OF(MWA)-3 .AND. K <= 2*NDIG+2) THEN
                 MWK(START(MWA)+K+2) = NUM
             ELSE
                 EXIT
             ENDIF
          ENDDO
          K = K + 1
          IF (K <= SIZE_OF(MWA)-3 .AND. K <= 2*NDIG+2) MWK(START(MWA)+K+2) = TMA*(MBASE/C)
      ENDIF

      DEALLOCATE(CX,CY,CZ)
      RETURN
      END SUBROUTINE FMMPYFFT2

      SUBROUTINE FMMPYFFTI(MA,IVAL,MB)

!  MB = MA * IVAL

!  Multiply FM number MA by one word integer IVAL.

!  This routine is used during fft-based multiplication.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MAS,MCARRY,MD2B,MKT,MLR,MVAL
      INTEGER :: J,JRSSAV,KA,KB,KC,KSHIFT,N1,NGUARD
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MACCA = MWK(START(MA)+1)
      NCALL = NCALL + 1
      KFLAG = 0
      N1 = NDIG + 1

!             Check for special cases.

      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(MWK(START(MA)+2)) < MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (MWK(START(MA)+2) == MUNKNO) THEN
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          KFLAG = -4
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(0,MB)
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          DO J = -1, N1
             MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
          ENDDO
          IF (MWK(START(MA)+2) == MEXPOV) KFLAG = -5
          IF (MWK(START(MA)+2) == MEXPUN) KFLAG = -6
          MWK(START(MB)) = MWK(START(MA))*IVAL
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          MAS = MWK(START(MA))
          KFLAG = -5
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MEXPOV
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MWK(START(MB)) = -1
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          KFLAG = -4
          CALL FMIM(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Work with positive numbers.

  110 MAS = MWK(START(MA))
      MVAL = ABS(IVAL)

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places in MWA.

      KSHIFT = INT((LOG(DBLE(MWK(START(MA)+3)+1)*DBLE(MVAL)))/DLOGMB)
      MWK(START(MWA)+2) = MWK(START(MA)+2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = NDIG + 5
      DO J = KB, KC
         MWK(START(MWA)+J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MWK(START(MA)+J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/MBASE)
         MWK(START(MWA)+J+1) = MKT - MCARRY*MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/MBASE)
         MWK(START(MWA)+J+1) = MCARRY - MKT*MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWK(START(MWA)+3) or MWK(START(MWA)+4).
!             Round the result and move it to MB.

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWA)+3) == 0) THEN
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              NGUARD = KSHIFT - 1
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  NGUARD = KSHIFT - 1
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,KSHIFT,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,KSHIFT,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

!             Put the sign on the result.

      MWK(START(MB)) = JRSIGN
      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MB)+1) = MACCA
      ENDIF

      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYFFTI

      SUBROUTINE FMMPYFFT_NORM(MA)

!  Normalize a number formed by the x1,x2 splitting done in FMMPYFFT.

      USE FMVALS
      IMPLICIT NONE
      INTEGER :: J,KZ,MA

      KZ = 0
      DO J = 1, NDIG
         IF (MWK(START(MA)+J+2) == 0) THEN
             KZ = J
         ELSE
             EXIT
         ENDIF
      ENDDO
      IF (KZ == 0) RETURN
      IF (KZ == NDIG) THEN
          CALL FMIM(0,MA)
          RETURN
      ENDIF
      DO J = 1, NDIG-KZ
         MWK(START(MA)+J+2) = MWK(START(MA)+J+KZ+2)
      ENDDO
      DO J = NDIG-KZ+1, NDIG
         MWK(START(MA)+J+2) = 0
      ENDDO
      MWK(START(MA)+2) = MWK(START(MA)+2) - KZ

      RETURN
      END SUBROUTINE FMMPYFFT_NORM

      SUBROUTINE FMMPYI(MA,IVAL,MB)

!  MB = MA * IVAL

!  Multiply FM number MA by one word integer IVAL.

!  This routine is faster than FMMPY when IVAL*MBASE is a one word integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MAS,MCARRY,MD2B,MKT,MLR,MVAL
      INTEGER :: J,JRSSAV,KA,KB,KC,KSHIFT,N1,NGUARD,NMVAL,NV2
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MACCA = MWK(START(MA)+1)
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPYI'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1

!             Check for special cases.

      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(MWK(START(MA)+2)) < MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (MWK(START(MA)+2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MB)
          KFLAG = -4
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(0,MB)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          DO J = -1, N1
             MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
          ENDDO
          IF (MWK(START(MA)+2) == MEXPOV) KFLAG = -5
          IF (MWK(START(MA)+2) == MEXPUN) KFLAG = -6
          MWK(START(MB)) = MWK(START(MA))*IVAL
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          MAS = MWK(START(MA))
          KFLAG = -5
          CALL FMST2M('OVERFLOW',MB)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MWK(START(MB)) = -1
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          NAMEST(NCALL) = 'FMMPYI'
          KFLAG = -4
          CALL FMWARN
          CALL FMST2M('UNKNOWN',MB)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Work with positive numbers.

  110 MAS = MWK(START(MA))
      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places in MWA.

      KSHIFT = INT((LOG(DBLE(MWK(START(MA)+3)+1)*DBLE(MVAL)))/DLOGMB)

!             If IVAL is too big use FMMPY.

      IF (KSHIFT > NDIG .OR. MVAL > MAXINT/MBASE .OR.  &
          NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1))
          CALL FMMPY2(MA,MXY(1),MB)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MB,MB,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MWK(START(MWA)+2) = MWK(START(MA)+2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = NDIG + 5
      DO J = KB, KC
         MWK(START(MWA)+J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MWK(START(MA)+J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/MBASE)
         MWK(START(MWA)+J+1) = MKT - MCARRY*MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/MBASE)
         MWK(START(MWA)+J+1) = MCARRY - MKT*MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWK(START(MWA)+3) or MWK(START(MWA)+4).
!             Round the result and move it to MB.

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWA)+3) == 0) THEN
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              NGUARD = KSHIFT - 1
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  NGUARD = KSHIFT - 1
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,KSHIFT,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,KSHIFT,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPYI'
          CALL FMWARN
      ENDIF

!             Put the sign on the result.

      MWK(START(MB)) = JRSIGN
      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MB)+1) = MACCA
      ENDIF

      IF (NTRACE /= 0) THEN
          CALL FMNTR(1,MB,MB,1,1)
      ENDIF
      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYI

      SUBROUTINE FMMPYI_R1(MA,IVAL)

!  MA = MA * IVAL

!  Multiply FM number MA by one word integer IVAL.

!  This routine is faster than FMMPY when IVAL*MBASE is a one word integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      REAL (KIND(1.0D0)) :: MACCA,MAS,MCARRY,MD2B,MKT,MLR,MVAL
      INTEGER :: J,JRSSAV,KA,KB,KC,KSHIFT,N1,NGUARD,NMVAL,NV2
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      JRSSAV = JRSIGN
      MACCA = MWK(START(MA)+1)
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMMPYI_R1'
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
      ENDIF
      KFLAG = 0
      N1 = NDIG + 1

!             Check for special cases.

      IF (MWK(START(MA)+3) == 0) THEN
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(MWK(START(MA)+2)) < MEXPOV .AND. ABS(IVAL) > 1) GO TO 110

      IF (MWK(START(MA)+2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MA)
          KFLAG = -4
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL FMIM(0,MA)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (ABS(IVAL) == 1) THEN
          IF (MWK(START(MA)+2) == MEXPOV) KFLAG = -5
          IF (MWK(START(MA)+2) == MEXPUN) KFLAG = -6
          MWK(START(MA)) = MWK(START(MA))*IVAL
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          MAS = MWK(START(MA))
          KFLAG = -5
          CALL FMST2M('OVERFLOW',MA)
          IF ((MAS < 0 .AND. IVAL > 0) .OR. (MAS > 0 .AND. IVAL < 0)) MWK(START(MA)) = -1
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+2) == MEXPUN) THEN
          NAMEST(NCALL) = 'FMMPYI_R1'
          KFLAG = -4
          CALL FMWARN
          CALL FMST2M('UNKNOWN',MA)
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Work with positive numbers.

  110 MAS = MWK(START(MA))
      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1

!             To leave room for the normalization, shift the product to the right KSHIFT
!             places in MWA.

      KSHIFT = INT((LOG(DBLE(MWK(START(MA)+3)+1)*DBLE(MVAL)))/DLOGMB)

!             If IVAL is too big use FMMPY.

      IF (KSHIFT > NDIG .OR. MVAL > MAXINT/MBASE .OR.  &
          NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL FMIM(IVAL,MXY(1))
          CALL FMMPY2_R1(MA,MXY(1))
          IF (NTRACE /= 0) THEN
              CALL FMNTR(1,MA,MA,1,1)
          ENDIF
          NCALL = NCALL - 1
          JRSIGN = JRSSAV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MWK(START(MWA)+2) = MWK(START(MA)+2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = NDIG + 5
      DO J = KB, KC
         MWK(START(MWA)+J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MWK(START(MA)+J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/MBASE)
         MWK(START(MWA)+J+1) = MKT - MCARRY*MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/MBASE)
         MWK(START(MWA)+J+1) = MCARRY - MKT*MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWK(START(MWA)+3) or MWK(START(MWA)+4).
!             Round the result and move it to MA.

      IF ((MAS > 0 .AND. IVAL > 0) .OR. (MAS < 0 .AND. IVAL < 0)) THEN
          JRSIGN = 1
      ELSE
          JRSIGN = -1
      ENDIF
      IF (MWK(START(MWA)+3) == 0) THEN
          MLR = 2*MWK(START(MWA)+NDIG+4) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              NGUARD = KSHIFT - 1
              CALL FMRND(MWA,NDIG,NGUARD,1)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+2) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+2) = MWK(START(MWA)+N1+2) + 1
                      MWK(START(MWA)+N1+3) = 0
                  ENDIF
              ELSE
                  NGUARD = KSHIFT - 1
                  CALL FMRND(MWA,NDIG,NGUARD,1)
              ENDIF
          ENDIF
      ELSE
          MLR = 2*MWK(START(MWA)+NDIG+3) + 1
          IF (KROUND == -1 .OR. KROUND == 2) THEN
              CALL FMRND(MWA,NDIG,KSHIFT,0)
          ELSE IF (MLR >= MBASE) THEN
              IF (MLR-1 > MBASE .AND. MWK(START(MWA)+N1+1) < MBASE-1) THEN
                  IF (KROUND /= 0) THEN
                      MWK(START(MWA)+N1+1) = MWK(START(MWA)+N1+1) + 1
                      MWK(START(MWA)+N1+2) = 0
                  ENDIF
              ELSE
                  CALL FMRND(MWA,NDIG,KSHIFT,0)
              ENDIF
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMMPYI_R1'
          CALL FMWARN
      ENDIF

!             Put the sign on the result.

      MWK(START(MA)) = JRSIGN
      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          MWK(START(MA)+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MA)+1) = MACCA
      ENDIF

      IF (NTRACE /= 0) THEN
          CALL FMNTR(1,MA,MA,1,1)
      ENDIF
      NCALL = NCALL - 1
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMMPYI_R1

      SUBROUTINE FMNINT(MA,MB)

!  MB = NINT(MA)  --  MB is returned as the nearest integer to MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MA2,MXSAVE
      INTEGER :: K,KASAVE,KOVUN,KRESLT,KWRNSV,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMENTR('FMNINT   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMNINT'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

      KWRNSV = KWARN
      KWARN = 0
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      IF (NDSAVE > INT(MWK(START(MA)+2))) THEN
          MA2 = MWK(START(MA))
          MWK(START(MXY(2))) = 1
          CALL FMI2M(1,MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMADD(MXY(2),MXY(1),MXY(3))
          CALL FMINT(MXY(3),MXY(2))
          IF (MA2 < 0 .AND. MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
              MWK(START(MXY(2))) = -MWK(START(MXY(2)))
      ENDIF
      KWARN = KWRNSV

!             Round the result and return.

      CALL FMEXIT(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMNINT

      SUBROUTINE FMNTR(NTR,MA,MB,NARG,KNAM)

!  Print FM numbers in base 10 format using FMOUT for conversion.
!  This is used for trace output from the FM routines.

!  NTR =  1 if a result of an FM call is to be printed.
!      =  2 to print input argument(s) to an FM call.

!  MA  -  the FM number to be printed.

!  MB  -  an optional second FM number to be printed.

!  NARG - the number of arguments.  NARG = 1 if only MA is to be printed, and NARG = 2 if
!         both MA and MB are to be printed.

!  KNAM - positive if the routine name is to be printed.


!  NTRACE and LVLTRC (in module FMVALS) control trace printout.

!  NTRACE = 0        No printout except warnings and errors.

!  NTRACE = 1        The result of each call to one of the routines is printed in base 10,
!                    using FMOUT.

!  NTRACE = -1       The result of each call to one of the routines is printed in internal
!                    base MBASE format.

!  NTRACE = 2        The input arguments and result of each call to one of the routines is
!                    printed in base 10, using FMOUT.

!  NTRACE = -2       The input arguments and result of each call to one of the routines is
!                    printed in base MBASE format.

!  LVLTRC defines the call level to which the trace is done.  LVLTRC = 1 means only FM routines
!         called directly by the user are traced, LVLTRC = K prints traces for FM routines with
!         call levels up to and including level K.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: KNAM,NTR,NARG

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,MA,MB,NARG,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          IF (KNAM > 0) THEN
              NAME = NAMEST(NCALL)
              IF (KROUND == 1) THEN
                  WRITE (KW,"(' Input to ',A)") TRIM(NAME)
              ELSE IF (KROUND == 2) THEN
                  WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
              ELSE IF (KROUND == 0) THEN
                  WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
              ELSE IF (KROUND == -1) THEN
                  WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
              ELSE
                  WRITE (KW,"(' Input to ',A)") TRIM(NAME)
              ENDIF
          ENDIF
      ELSE
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,  &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,  &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

!             Check for base MBASE internal format trace.

      IF (NTRACE < 0) THEN
          CALL FMNTRJ(MA,NDIG)
          IF (NARG == 2) CALL FMNTRJ(MB,NDIG)
      ENDIF

!             Check for base 10 trace using FMOUT.

      IF (NTRACE > 0) THEN
          CALL FMPRNT(MA)

          IF (NARG == 2) THEN
              CALL FMPRNT(MB)
          ENDIF
      ENDIF

      RETURN
      END SUBROUTINE FMNTR

      SUBROUTINE FMNTRI(NTR,N,KNAM)

!  Internal routine for trace output of integer variables.

!  NTR = 1 for output values
!        2 for input values

!  N     Integer to be printed.

!  KNAM  is positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,N,KNAM

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,N,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,  &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,  &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,I18)") N

      RETURN
      END SUBROUTINE FMNTRI

      SUBROUTINE FMNTRJ(MA,ND)

!  Print trace output in internal base MBASE format.  The number to be printed is in MA.

!  ND is the number of base MBASE digits to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: ND

      CHARACTER(50) :: FORM
      INTEGER :: J,L,N
      INTENT (IN) :: MA,ND

      L = INT(LOG10(DBLE(MBASE-1))) + 2
      N = (KSWIDE-23)/L
      IF (N > 10) N = 5*(N/5)
      IF (ND <= N) THEN
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,') ')") L+2, N-1, L
      ELSE
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,'/"  //  &
                      "(22X,',I3,'I',I2,')) ')"                &
                ) L+2, N-1, L, N, L
      ENDIF

      WRITE (KW,*) '            Sign = ',INT(MWK(START(MA))),'  Accuracy = ',  &
                   INT(MWK(START(MA)+1)),'  Exponent = ',INT(MWK(START(MA)+2)),'  Digits:'
      WRITE (FORM,*) '(13X,', N, 'I', L, ')'
      WRITE (KW,FORM) (INT(MWK(START(MA)+J)),J=3,ND+2)

      RETURN
      END SUBROUTINE FMNTRJ

      SUBROUTINE FMNTRR(NTR,X,KNAM)

!  Internal routine for trace output of real variables.

!  NTR - 1 for output values
!        2 for input values

!  X   - Double precision value to be printed if NX == 1

!  KNAM - Positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,KNAM
      DOUBLE PRECISION :: X

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,X,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,  &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,  &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,D30.20)") X

      RETURN
      END SUBROUTINE FMNTRR

      SUBROUTINE FMOUT(MA,LINE,LB)

!  Convert a floating multiple precision number to a character array for output.

!  MA   is an FM number to be converted to an A1 character array in base 10 format.
!  LINE is the character(1) array in which the result is returned.
!  LB   is the length of LINE.

! JFORM1 and JFORM2 (in module FMVALS) determine the format of LINE.

! JFORM1 = 0  normal setting  ( .314159M+6 )
!        = 1  ES  format      ( 3.14159M+5 )
!        = 2  F   format      ( 314159.000 )

! JFORM2 = number of significant digits to display (if JFORM1 = 0, 1)
!        = number of digits after the decimal point (if JFORM1 = 2)

!          If JFORM2 == 0 and JFORM1 /= 2 then a default number of digits is chosen.
!          The default is roughly the full precision of MA.

!          If JFORM2 == 0 and JFORM1 == 2 then the number is returned in integer format with no
!          decimal point.  Rounding is done as with other settings, so the value displayed is the
!          nearest integer to MA.

!  If JFORM1 == 2 and MA is too large or too small to display in the requested format, it is
!  converted using JFORM1=0, JFORM2=0.

!  LINE should be dimensioned at least LOG10(MBASE)*NDIG + 15 on a 32-bit machine to allow for up to
!  10 digit exponents.  Replace 15 by 20 if 48-bit integers are used, 25 for 64-bit integers, ....

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: LB
      CHARACTER :: LINE(LB)

      CHARACTER :: KCHAR
      REAL (KIND(1.0D0)) :: MBSAVE,MEXP,MEXP10,MKT,MS1,MS2,MSD2,MT10,MXSAVE
      INTEGER :: J,JDPT,JF1SAV,JF2SAV,K,K1,K2,KA,KASAVE,KB,KC,KDIGIT,KEXP,KMS2SD,KWRNSV,L,  &
                 NEW_MBASE,NEW_NDIG,ND,NDE,NDE2,NDSAVE,NPOWER,NSD1,NSD2,NVAL,NTRSAV,        &
                 NWORD,NWORD1,NWORD2
      DOUBLE PRECISION :: X

      CHARACTER :: NUMB(10) = (/ '0','1','2','3','4','5','6','7','8','9' /)
      CHARACTER :: NUNKNO(12) = (/ ' ',' ',' ','U','N','K','N','O','W','N',' ',' ' /)
      CHARACTER :: NEXPOV(12) = (/ ' ',' ',' ','O','V','E','R','F','L','O','W',' ' /)
      CHARACTER :: NEXPUN(12) = (/ ' ',' ',' ','U','N','D','E','R','F','L','O','W' /)
      CHARACTER(9) :: NAMEST_SAVE(0:50)
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

!             To avoid recursion, FMOUT calls only internal arithmetic routines
!             (FMADD2, FMMPY2, ...), so no trace printout is done during a call to FMOUT.

      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMOUT'
      KWRNSV = KWARN
      KWARN = 0
      DO J = 1, LB
         LINE(J) = ' '
      ENDDO

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO) THEN
          DO J = 1, 12
             LINE(J) = NUNKNO(J)
          ENDDO
          KWARN = KWRNSV
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          RETURN
      ENDIF
      IF (MWK(START(MA)+2) == MEXPOV) THEN
          DO J = 1, 12
             LINE(J) = NEXPOV(J)
          ENDDO
          LINE(2) = '+'
          IF (MWK(START(MA)) < 0) LINE(2) = '-'
          KWARN = KWRNSV
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          RETURN
      ENDIF
      IF (MWK(START(MA)+2) == MEXPUN) THEN
          DO J = 1, 12
             LINE(J) = NEXPUN(J)
          ENDDO
          LINE(2) = '+'
          IF (MWK(START(MA)) < 0) LINE(2) = '-'
          KWARN = KWRNSV
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          RETURN
      ENDIF
      IF (MWK(START(MA)+3) == 0 .AND. JFORM1 == 2 .AND. JFORM2 == 0) THEN
          LINE(2) = '0'
          KWARN = KWRNSV
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          RETURN
      ENDIF

      KASAVE = KACCSW
      KACCSW = 0
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      MBSAVE = MBASE
      NDSAVE = NDIG
      MXSAVE = MXEXP

!             ND is the number of base 10 digits required.

  110 ND = JFORM2
      IF (JFORM1 == 2 .AND. MWK(START(MA)+2) > 0) THEN
          ND = JFORM2 + INT(REAL(MWK(START(MA)+2))*LOG10(REAL(MBASE))) + 1
          IF (ND <= 1 .AND. JFORM2 == 0) ND = 10
      ENDIF
      IF (ND <= 1) THEN
          K = INT(REAL(NDIG)*LOG10(REAL(MBASE)))
          ND = MAX(K,JFORM2)
      ENDIF
      IF (JFORM2 <= 0 .AND. JFORM1 <= 1) ND = INT(1.1 + REAL(NDIG-1)*LOG10(REAL(MBASE)))
      IF (ND < 2) ND = 2

      IF (LB < ND+6) THEN
          IF (JFORM1 == 2) THEN
              JFORM1 = 0
              JFORM2 = 0
              GO TO 110
          ENDIF
          GO TO 170
      ENDIF

!             Convert to the base that is the largest power of 10 less than MXBASE and build the
!             output number.

      NPOWER = INT(LOG10(REAL(MXBASE)/4))
      MXEXP = MXEXP2
      MBASE = 10**NPOWER
      IF (MBLOGS /= MBASE) CALL FMCONS
      NDIG = ND/NPOWER + 3
      K = NDSAVE*LOG(DBLE(MBSAVE))/LOG(DBLE(MBASE))
      IF (NDIG + 3000 < K) THEN
          NDIG = ND/NPOWER + 3000
      ELSE IF (NDIG < K) THEN
          NDIG = K
      ENDIF
      IF (NDIG < 2) NDIG = 2

      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMIM(0,MXY(3))
          GO TO 120
      ENDIF

!             Check to see if MA is already in a base that is a power of ten.
!             If so, the conversion can be skipped.

      K = NPOWER
      DO J = 1, K
         MBASE = 10**J
         IF (MBASE == MBSAVE) THEN
             IF (MBLOGS /= MBASE) CALL FMCONS
             NPOWER = J
             NDIG = MAX(NDSAVE,ND/NPOWER+3)
             IF (NDIG < 2) NDIG = 2
             IF (NDIG > NDSAVE) THEN
                 CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
             ELSE
                 CALL FMIM(0,MXY(3))
                 DO K1 = 1, MIN(NDIG,Size_of(MA)-3)
                    MWK(START(MXY(3))+K1+2) = MWK(START(MA)+K1+2)
                 ENDDO
                 MWK(START(MXY(3))) = MWK(START(MA))
                 MWK(START(MXY(3))+1) = MWK(START(MA)+1)
                 MWK(START(MXY(3))+2) = MWK(START(MA)+2)
             ENDIF
             MWK(START(MXY(3))) = 1
             GO TO 120
         ENDIF
      ENDDO

      NEW_MBASE = MBASE
      NEW_NDIG = NDIG
      MBASE = MBSAVE
      NDIG = MIN(NDSAVE,NINT(NEW_NDIG*LOG(DBLE(NEW_MBASE))/LOG(DBLE(MBASE))))
      IF (MBLOGS /= MBASE) CALL FMCONS
      NTRSAV = NTRACE
      NTRACE = 0
      J = NCALL
      NAMEST_SAVE(0:NCALL) = NAMEST(0:NCALL)
      NCALL = 0
      CALL FMCHANGEBASE(MA,MXY(3),NEW_MBASE,NEW_NDIG)
      NCALL = J
      NAMEST(0:NCALL) = NAMEST_SAVE(0:NCALL)
      NTRACE = NTRSAV
      MBASE = NEW_MBASE
      NDIG = NEW_NDIG
      IF (MBLOGS /= MBASE) CALL FMCONS

!             Now MXY(3) is the value of MA converted to a power of ten base.

!             Convert it to a character string base 10 for output.

!             MEXP10 is the base 10 exponent.
!             KMS2SD is the number of base 10 significant digits in the first digit of MXY(3).

  120 MS1 = MWK(START(MXY(3))+2)
  130 MEXP10 = NPOWER*MWK(START(MXY(3))+2)
      KMS2SD = NPOWER
      K = INT(MBASE)
      DO J = 1, NPOWER
         K = K/10
         IF (MWK(START(MXY(3))+3) < K .AND. MWK(START(MXY(3))+3) /= 0) THEN
             MEXP10 = MEXP10 - 1
             KMS2SD = KMS2SD - 1
         ENDIF
      ENDDO

!             For printing using JFORM1 = 1, reduce the exponent to account for the fact that the
!             decimal point and first significant digit will later be swapped.

      IF (JFORM1 == 1 .AND. MWK(START(MXY(3))+3) /= 0) MEXP10 = MEXP10 - 1

!             Find the position in the unpacked number for rounding.
!             NWORD is the word in which rounding is done, or zero if no rounding is necessary.
!                   NWORD is set to -1 if JFORM1 is 2 (F format) but no significant digits would
!                   be printed.  This case defaults to JFORM1 = 0.
!             NVAL gives the position within that word where rounding occurs.
!             NSD1 is the maximum number of base 10 S.D.'s in NWORD digits of base 10**NPOWER.
!             NSD2 is the number of base 10 S.D.'s needed to get ND base 10 digits after
!                  the decimal.

      NSD2 = ND
      IF (JFORM1 == 2) THEN
          MSD2 = JFORM2 + MEXP10
          IF (MSD2 > ND) THEN
              NSD2 = ND
          ELSE
              NSD2 = INT(MSD2)
          ENDIF
          NWORD = (NSD2-KMS2SD-1+NPOWER)/NPOWER + 2
          IF (NWORD < 2) NWORD = -1
          IF (NWORD > NDIG) NWORD = 0
          IF (NWORD >= 2 .AND. NSD2 <= 0) NWORD = -1
      ELSE
          NWORD = (ND-KMS2SD-1+NPOWER)/NPOWER + 2
      ENDIF
      NSD1 = KMS2SD + NPOWER*(NWORD-2)
      IF (NWORD < 2) THEN
          NVAL = 0
      ELSE
          NVAL = 10**(NSD1-NSD2)
      ENDIF

!             Now do the base 10 rounding.

      IF (NWORD >= 2) THEN
          X = 0
          IF (NVAL > 1) X = MOD(INT(MWK(START(MXY(3))+NWORD+1)),NVAL)
          IF (NWORD < NDIG+1) THEN
              X = X + DBLE(MWK(START(MXY(3))+NWORD+2))/DBLE(MBASE)
          ENDIF
          X = X/NVAL
          IF (KROUND == 1 .AND. X < 0.5) GO TO 150
          IF (KROUND == 1 .AND. X == 0.5) THEN
              DO J = NWORD+1, NDIG
                 IF (MWK(START(MXY(3))+J+2) /= 0) GO TO 140
              ENDDO
              J = MOD(INT(MWK(START(MXY(3))+NWORD+1))/NVAL,10)
              IF (MOD(J,2) /= 0) GO TO 140
              GO TO 150
          ENDIF
          IF (KROUND == 0) GO TO 150
          IF (KROUND == -1 .AND. MWK(START(MA)) > 0) GO TO 150
          IF (KROUND ==  2 .AND. MWK(START(MA)) < 0) GO TO 150
          IF (KROUND == -1 .AND. X == 0.0) THEN
              DO J = NWORD+1, NDIG
                 IF (MWK(START(MXY(3))+J+2) /= 0) GO TO 140
              ENDDO
              GO TO 150
          ENDIF
          IF (KROUND ==  2 .AND. X == 0.0) THEN
              DO J = NWORD+1, NDIG
                 IF (MWK(START(MXY(3))+J+2) /= 0) GO TO 140
              ENDDO
              GO TO 150
          ENDIF
  140     MS2 = MWK(START(MXY(3))+3)
          MWK(START(MXY(3))+NWORD+1) = INT(MWK(START(MXY(3))+NWORD+1)/NVAL)*NVAL
          IF (NWORD+3 <= SIZE_OF(MXY(3))) THEN
              MWK(START(MXY(3))+NWORD+2) = 0
              IF (NWORD+4 <= SIZE_OF(MXY(3))) THEN
                  MWK(START(MXY(3))+NWORD+3) = 0
              ENDIF
              IF (KROUND /= 1) THEN
                  DO J = NWORD, SIZE_OF(MXY(3))-3
                     MWK(START(MXY(3))+J+2) = 0
                  ENDDO
              ENDIF
          ENDIF
          MWK(START(MXY(3))+NWORD+1) = MWK(START(MXY(3))+NWORD+1) + NVAL
          IF (MWK(START(MXY(3))+NWORD+1) >= MBASE) THEN
              NWORD1 = NWORD - 1
              NWORD2 = NWORD - 2
              IF (NWORD > 2) THEN
                  CALL FMEQU_R1(MXY(3),NWORD1,NWORD2)
              ELSE
                  MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + 1
                  MWK(START(MXY(3))+3) = INT(MWK(START(MXY(3))+3)/MBASE)
                  MWK(START(MXY(3))+4) = 0
              ENDIF
          ENDIF
          IF (MWK(START(MXY(3))+2) /= MS1 .OR. MWK(START(MXY(3))+3) /= MS2) GO TO 130
      ENDIF

!             Build the base 10 character string.

  150 IF (MWK(START(MA)) < 0) LINE(1) = '-'
      LINE(2) = '.'
      K = 10**KMS2SD
      L = 2
      IF (NWORD == -1) NSD2 = ND
      DO J = 1, NSD2
         K = K/10
         IF (K == 0) THEN
             K = INT(MBASE)/10
             L = L + 1
         ENDIF
         KDIGIT = INT(MWK(START(MXY(3))+L+1))/K
         MWK(START(MXY(3))+L+1) = MOD(INT(MWK(START(MXY(3))+L+1)),K)
         LINE(J+2) = NUMB(KDIGIT+1)
      ENDDO

      KA = NSD2 + 3
      KB = ND + 2
      IF (KB >= KA) THEN
          DO J = KA, KB
             LINE(J) = NUMB(1)
          ENDDO
      ENDIF

      LINE(ND+3) = CMCHAR
      LINE(ND+4) = '+'
      IF (MEXP10 < 0) LINE(ND+4) = '-'
      IF (MWK(START(MA)+3) == 0) LINE(ND+4) = ' '

!             Build the digits of the base 10 exponent backwards, then reverse them.

      NDE = 1
      MEXP = ABS(MEXP10)
      MT10 = 10
      DO J = 1, LB
         MKT = AINT (MEXP/MT10)
         KDIGIT = INT(MEXP-MKT*MT10)
         LINE(ND+4+J) = NUMB(KDIGIT+1)
         MEXP = MKT
         IF (MEXP == 0) EXIT

         IF (ND+5+J > LB) THEN
             DO K = 1, LB
                LINE(K) = '*'
             ENDDO
             GO TO 160
         ENDIF

         NDE = NDE + 1
      ENDDO

      NDE2 = NDE/2
      IF (NDE2 < 1) GO TO 160
      K1 = ND + 4
      K2 = ND + 5 + NDE
      DO J = 1, NDE2
         K1 = K1 + 1
         K2 = K2 - 1
         KCHAR = LINE(K1)
         LINE(K1) = LINE(K2)
         LINE(K2) = KCHAR
      ENDDO

!             If JFORM1 is 1 put the first digit left of the decimal.

  160 IF (JFORM1 == 1) THEN
          KCHAR = LINE(2)
          LINE(2) = LINE(3)
          LINE(3) = KCHAR
      ENDIF

!             If JFORM1 is 2 put the number into fixed format.

      IF (JFORM1 == 2 .AND. JFORM2 >= 0) THEN
          IF (MEXP10 <= -JFORM2 .OR. MEXP10+2 > LB .OR. LINE(1) == '*') THEN
              JFORM1 = 0
              JFORM2 = 0
              MBASE = MBSAVE
              IF (MBLOGS /= MBASE) CALL FMCONS
              NDIG = NDSAVE
              MXEXP = MXSAVE
              DO J = 1, LB
                 LINE(J) = ' '
              ENDDO
              GO TO 110
          ENDIF
          KA = ND + 3
          DO J = KA, LB
             LINE(J) = NUMB(1)
          ENDDO

          KEXP = INT(MEXP10)
          IF (MEXP10 > 0) THEN
              DO J = 1, KEXP
                 LINE(J+1) = LINE(J+2)
              ENDDO
              LINE(KEXP+2) = '.'
          ENDIF

          IF (MEXP10 < 0) THEN
              KEXP = -INT(MEXP10)
              KA = 3 + KEXP
              KB = LB + 1
              KC = KB - KEXP
              DO J = KA, LB
                 KB = KB - 1
                 KC = KC - 1
                 LINE(KB) = LINE(KC)
                 LINE(KC) = NUMB(1)
              ENDDO
          ENDIF

          JDPT = 0
          DO J = 1, LB
             IF (LINE(J) == '.') JDPT = J
             IF (JDPT > 0 .AND. J > JDPT+JFORM2) LINE(J) = ' '
          ENDDO
          IF (JFORM2 == 0 .AND. JDPT > 0) LINE(KEXP+2) = ' '

      ENDIF

!             Restore values and return

      GO TO 180

!             LINE is not big enough to hold the number of digits specified.

  170 KFLAG = -8
      DO J = 1, LB
         LINE(J) = '*'
      ENDDO
      KWARN = KWRNSV
      CALL FMWARN

  180 MBASE = MBSAVE
      IF (MBLOGS /= MBASE) CALL FMCONS
      NDIG = NDSAVE
      MXEXP = MXSAVE
      KWARN = KWRNSV
      NCALL = NCALL - 1
      KACCSW = KASAVE
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FMOUT

      SUBROUTINE FMPACK(MA,MP)

!  MA is packed two base MBASE digits per word and returned in MP.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MP

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MP <= 0) THEN
          CALL FMDEFINE(MP)
      ELSE IF (SIZE_OF(MP) < NDIG/2+4) THEN
          CALL FMDEFINE(MP)
      ENDIF

      KP = 2
      MWK(START(MP)) = MWK(START(MA))
      MWK(START(MP)+1) = MWK(START(MA)+1)
      MWK(START(MP)+2) = MWK(START(MA)+2)
      MWK(START(MP)+3) = ABS(MWK(START(MA)+3))*MBASE + MWK(START(MA)+4)
      IF (NDIG >= 4) THEN
          DO J = 4, NDIG, 2
             KP = KP + 1
             MWK(START(MP)+KP+1) = MWK(START(MA)+J+1)*MBASE + MWK(START(MA)+J+2)
          ENDDO
      ENDIF
      IF (MOD(NDIG,2) == 1) MWK(START(MP)+KP+2) = MWK(START(MA)+NDIG+2)*MBASE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPACK

      SUBROUTINE FMPI(MA)

!  MA = pi

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      CHARACTER(155) :: STRING
      INTEGER :: K,KASAVE,L,NDMB,NDSAVE,NDSV
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMPI'
      IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
          WRITE (KW,"(' Input to FMPI')")
      ENDIF
      KASAVE = KACCSW
      KACCSW = 0

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = NGRD52
          NDIG = MAX(NDIG+K,2)
      ENDIF

!             Check to see if pi has previously been computed in base MBASE with
!             sufficient precision.

      IF (MBSPI == MBASE .AND. NDIGPI >= NDIG) THEN
          KACCSW = KASAVE
          CALL FMEQU(MPISAV,MA,NDIGPI,NDSAVE)
      ELSE
          NDMB = INT(150.0*2.302585/ALOGMB)
          IF (NDMB >= NDIG) THEN
              NDSV = NDIG
              NDIG = NDMB
              STRING = '3.141592653589793238462643383279502884197169'//  &
              '39937510582097494459230781640628620899862803482534211'//  &
              '7067982148086513282306647093844609550582231725359408128'
              IF (MPISAV > 0) THEN
                  IF (SIZE_OF(MPISAV) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MPISAV) = -6
                      MPISAV = L
                  ENDIF
              ENDIF
              CALL FMST2M(STRING,MPISAV)
              MWK(START(MPISAV)+1) = NINT(NDIG*ALOGM2)
              MBSPI = MBASE
              NDIGPI = NDIG
              IF (ABS(MWK(START(MPISAV)+2)) > 10) NDIGPI = 0
          ELSE
              NDSV = NDIG
              NDIG = NDIG + 2 + NDIG/100
              IF (MPISAV > 0) THEN
                  IF (SIZE_OF(MPISAV) < NDIG+3) THEN
                      L = -3
                      CALL FMDEFINE(L)
                      TEMPV(MPISAV) = -6
                      MPISAV = L
                  ENDIF
              ENDIF
              CALL FMPI2(MPISAV)
              MWK(START(MPISAV)+1) = NINT(NDIG*ALOGM2)
              MBSPI = MBASE
              NDIGPI = NDIG
              IF (ABS(MWK(START(MPISAV)+2)) > 10) NDIGPI = 0
          ENDIF
          KACCSW = KASAVE
          CALL FMEQU(MPISAV,MA,NDIG,NDSAVE)
          NDIG = NDSV
      ENDIF

      NDIG = NDSAVE
      KACCSW = KASAVE
      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPI

      SUBROUTINE FMPI2(MPI)

!  Internal routine to compute pi.
!  The formula used is due to S. Ramanujan.  For low to moderate precision, this routine uses
!  the series
!                                                (4n)!(1103+26390n)
!  1/pi = (sqrt(8)/9801) * sum(n=0 to infinity) --------------------
!                                               ((n!)**4)(396**(4n))
!
!  For higher precision, see routine FMPI3.
!
!  The result is returned in MPI.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MPI
      INTENT (INOUT) :: MPI
      DOUBLE PRECISION :: X
      REAL (KIND(1.0D0)) :: MX
      INTEGER :: NSTACK(49),J,K,KST,LARGE,N,NDIGRD,NDSAVE,NMETHD
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MPI <= 0) THEN
          CALL FMDEFINE(MPI)
      ELSE IF (SIZE_OF(MPI) < NDIG+3) THEN
          CALL FMDEFINE(MPI)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Check for using binary splitting if precision is high.

      IF (NDIG >= 100) THEN
          NMETHD = 2
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMPI3(MPI)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MPI) == -1) TEMPV(MPI) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      NDSAVE = NDIG
      N = -1
      CALL FMI2M(1103,MPI)
      CALL FMI2M(0,MXY(1))
      CALL FMI2M(1,MXY(2))
      CALL FMI2M(26390,MXY(3))
      CALL FMI2M(1103,MXY(4))
      MX = MXBASE**2/MBASE
      IF (MX > MXEXP2) MX = MXEXP2

  110 N = N + 1
      LARGE = INT(MX)/(4*N + 3)
      J = 4*N + 1
      IF (J > LARGE) THEN
          CALL FMMPYI_R1(MXY(2),J)
          J = J + 1
          CALL FMMPYI_R1(MXY(2),J)
          J = J + 1
          CALL FMMPYI_R1(MXY(2),J)
      ELSE IF (J*(J+1) > LARGE) THEN
          K = J*(J+1)
          CALL FMMPYI_R1(MXY(2),K)
          J = J + 2
          CALL FMMPYI_R1(MXY(2),J)
      ELSE
          K = J*(J+1)*(J+2)
          CALL FMMPYI_R1(MXY(2),K)
      ENDIF

      J = N + 1
      LARGE = INT(MXBASE)/J
      IF (J > LARGE) THEN
          CALL FMDIVI_R1(MXY(2),J)
          CALL FMDIVI_R1(MXY(2),J)
          CALL FMDIVI_R1(MXY(2),J)
      ELSE IF (J*J > LARGE) THEN
          K = J*J
          CALL FMDIVI_R1(MXY(2),K)
          CALL FMDIVI_R1(MXY(2),J)
      ELSE
          K = J*J*J
          CALL FMDIVI_R1(MXY(2),K)
      ENDIF

!             Break 4/396**4 into 1/(2178*2178*1296).

      J = 2178
      LARGE = INT(MXBASE)/J
      IF (J > LARGE) THEN
          CALL FMDIVI_R1(MXY(2),J)
          CALL FMDIVI_R1(MXY(2),J)
          CALL FMDIVI_R1(MXY(2),1296)
      ELSE
          K = J*J
          CALL FMDIVI_R1(MXY(2),K)
          CALL FMDIVI_R1(MXY(2),1296)
      ENDIF

      NDIGRD = NDIG
      NDIG = NDSAVE
      CALL FMADD_R2(MXY(3),MXY(4))
      NDIG = NDIGRD
      CALL FMMPY(MXY(2),MXY(4),MXY(1))

      NDIG = NDSAVE
      CALL FMADD_R1(MPI,MXY(1))
      NDIG = MAX(NGRD22,NDSAVE - INT(MWK(START(MPI)+2) - MWK(START(MXY(1))+2)))
      IF (KFLAG /= 1) GO TO 110
      NDIG = NDSAVE

      CALL FMI2M(8,MXY(2))
      X = 8
      X = SQRT(X)
      CALL FMDPM(X,MXY(4))
      CALL FMDIG(NSTACK,KST)
      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMDIV(MXY(2),MXY(4),MXY(1))
         CALL FMADD_R1(MXY(4),MXY(1))
         CALL FMDIVI_R1(MXY(4),2)
      ENDDO
      MWK(START(MXY(4))+1) = NINT(NDIG*ALOGM2)
      CALL FMI2M(9801,MXY(3))
      CALL FMMPY_R1(MPI,MXY(4))
      CALL FMDIV_R2(MXY(3),MPI)

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MPI) == -1) TEMPV(MPI) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPI2

      SUBROUTINE FMPI3(MPI)
      USE FMVALS
      IMPLICIT NONE

!  Internal pi routine for very high precision.

!  The algorithm used is Chudnovskys' Ramanujan-style series with binary splitting.

!                                                  (-1)**n*(6n)!(13591409+545140134*n)
!  1/pi = (12/640320**(3/2)) * sum(n=0 to infinity) -----------------------------------
!                                                     (n!)**3*(3*n)!*(640320**(3n))
!  The result is returned in MPI.

      INTEGER :: MPI
      INTENT (INOUT) :: MPI
      INTEGER :: K
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NDIG = NDIG + 100
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG + 30) THEN
          CALL FMDEFINE(MWA)
      ENDIF
      NDIG = NDIG - 100
      NUMBER_USED_SAVE = NUMBER_USED

!             Determine K, the number of terms to sum in the series for pi.

      K = NDIG*DLOGMB/3.2654441D+1 + 10
      CALL FMPI3_PQT(0,K,MXY(1),MXY(2),MXY(3))

      IF (MWK(START(MXY(2))+2) >= NDIG .AND. MWK(START(MXY(3))+2) >= NDIG) THEN
          CALL FMDIV(MXY(2),MXY(3),MXY(1))
          CALL FMI2M(640320,MXY(2))
          CALL FMSQRT(MXY(2),MXY(3))
          CALL FMMPYI_R1(MXY(3),53360)
          CALL FMMPY(MXY(1),MXY(3),MPI)
      ELSE
          IF (MWK(START(MXY(2))+2) >= NDIG) THEN
              CALL FMEQ(MXY(2),MXY(1))
          ELSE
              CALL IMI2FM(MXY(2),MXY(1))
          ENDIF
          IF (MWK(START(MXY(3))+2) >= NDIG) THEN
              CALL FMEQ(MXY(3),MXY(4))
          ELSE
              CALL IMI2FM(MXY(3),MXY(4))
          ENDIF
          CALL FMDIV(MXY(1),MXY(4),MXY(3))
          CALL FMI2M(640320,MXY(1))
          CALL FMSQRT(MXY(1),MXY(2))
          CALL FMMPYI_R1(MXY(2),53360)
          CALL FMMPY(MXY(2),MXY(3),MPI)
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPI3

      RECURSIVE SUBROUTINE FMPI3_PQT(A,B,MP,MQ,MT)

!  This routine does the binary splitting for computing the constant pi.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MP,MQ,MT
      INTEGER :: A,B
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MP,MQ,MT
      INTEGER :: MXY(6),NUMBER_USED_SAVE,J,KA,KP,KQ,KT,M
      REAL (KIND(0.0D0)) :: DA,DB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      NUMBER_USED_SAVE = NUMBER_USED
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION + 1

      IF (B-A < 10) THEN
          RESULT_SIZE = ( (DB-DA)*4.276666 + 3*( (DB+0.5D0)*LOG(DB+1) - DB + 1/(12*(DB+1)) -  &
                        ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) ) ) * 1.01 / DLOGMB + 15
          RESULT_SIZE = MAX(5,RESULT_SIZE) + 5*LOG(DBLE(NDIG))/DLOGMB + 15
          IF (MP <= 0) THEN
              CALL IMDEFINE(MP,RESULT_SIZE)
          ELSE IF (SIZE_OF(MP) < RESULT_SIZE) THEN
              CALL IMDEFINE(MP,RESULT_SIZE)
          ENDIF
          RESULT_SIZE = ( (DB-DA)*36.93111 + 3*( (DB+0.5D0)*LOG(DB+1) - DB + 1/(12*(DB+1)) -  &
                        ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) ) ) * 1.01 / DLOGMB + 15
          RESULT_SIZE = MAX(5,RESULT_SIZE) + 5*LOG(DBLE(NDIG))/DLOGMB + 15
          IF (MQ <= 0) THEN
              CALL IMDEFINE(MQ,RESULT_SIZE)
          ELSE IF (SIZE_OF(MQ) < RESULT_SIZE) THEN
              CALL IMDEFINE(MQ,RESULT_SIZE)
          ENDIF
          IF (MT <= 0) THEN
              CALL IMDEFINE(MT,RESULT_SIZE)
          ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
              CALL IMDEFINE(MT,RESULT_SIZE)
          ENDIF
          NUMBER_USED_SAVE = NUMBER_USED
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          CALL IMDEFINE(MXY(3),RESULT_SIZE)
          CALL IMDEFINE(MXY(4),RESULT_SIZE)
          CALL IMDEFINE(MXY(5),RESULT_SIZE)
          CALL IMI2M(1,MP)
          KA = A
          IF (KA == 0) KA = 1
          DO J = KA, B
             CALL IMMPYI(MP,-(6*J-5),MXY(2))
             CALL IMMPYI(MXY(2),2*J-1,MXY(1))
             CALL IMMPYI(MXY(1),6*J-1,MP)
          ENDDO

          CALL IMI2M(640320,MXY(1))
          CALL IMSQR(MXY(1),MXY(3))
          CALL IMMPY(MXY(3),MXY(1),MXY(2))
          CALL IMDIVI(MXY(2),24,MXY(1))
          CALL IMI2M(1,MQ)
          DO J = KA, B
             CALL IMMPYI(MQ,J,MXY(3))
             CALL IMMPYI(MXY(3),J,MXY(2))
             CALL IMMPYI(MXY(2),J,MXY(3))
             CALL IMMPY(MXY(3),MXY(1),MQ)
          ENDDO

          CALL IMI2M(0,MT)
          IF (A == 0) THEN
              CALL IMMPYI(MQ,13591409,MT)
          ENDIF
          CALL IMEQ(MQ,MXY(2))
          DO J = KA, B
             CALL IMMPYI(MXY(2),-(6*J-5),MXY(3))
             CALL IMMPYI(MXY(3),2*J-1,MXY(4))
             CALL IMMPYI(MXY(4),6*J-1,MXY(2))
             CALL IMDIVI(MXY(2),J,MXY(3))
             CALL IMDIVI(MXY(3),J,MXY(4))
             CALL IMDIVI(MXY(4),J,MXY(3))
             CALL IMDIV(MXY(3),MXY(1),MXY(2))
             CALL IMI2M(545140134,MXY(3))
             CALL IMMPYI(MXY(3),J,MXY(4))
             CALL IMI2M(13591409,MXY(3))
             CALL IMADD(MXY(3),MXY(4),MXY(5))
             CALL IMMPY(MXY(2),MXY(5),MXY(3))
             CALL IMADD(MT,MXY(3),MXY(4))
             CALL IMEQ(MXY(4),MT)
          ENDDO

          GO TO 110
      ENDIF

      M = (A+B)/2
      CALL FMPI3_PQT(A,M-1,MXY(1),MXY(2),MXY(3))
      CALL FMPI3_PQT(M,B,MXY(4),MXY(5),MXY(6))

!             MP is not needed in FMPI3, so this multiplication can be skipped at the top level
!             of the recursion.

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IM_OR_FM_MPY(MXY(1),MXY(4),MP)
      ELSE
          CALL IMI2M(0,MP)
      ENDIF
      CALL IM_OR_FM_MPY(MXY(2),MXY(5),MQ)

      CALL IM_OR_FM_MPY(MXY(5),MXY(3),MXY(2))
      CALL IM_OR_FM_MPY(MXY(1),MXY(6),MXY(4))
      CALL IM_OR_FM_ADD(MXY(2),MXY(4),MT)

!             Move MP, MQ, and MT to the front of the unused area of MWK and save them.

      NUMBER_USED = NUMBER_USED_SAVE + 1
      KP = MP
      MP = NUMBER_USED
      IF (NUMBER_USED <= 1) THEN
          START(MP) = 1
      ELSE
          START(MP) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
      ENDIF
      SIZE_OF(MP) = SIZE_OF(KP)
      IF (SIZE_OF(MQ) == NDIG+3 .AND. SIZE_OF(MP) < NDIG+3) THEN
          SIZE_OF(MP) = SIZE_OF(MQ)
      ENDIF
      DO J = 1, SIZE_OF(KP)
         MWK(START(MP)+J-1) = MWK(START(KP)+J-1)
      ENDDO
      TEMPV(MP) = -2
      NUMBER_USED = NUMBER_USED + 1
      KQ = MQ
      MQ = NUMBER_USED
      START(MQ) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
      SIZE_OF(MQ) = SIZE_OF(KQ)
      DO J = 1, SIZE_OF(MQ)
         MWK(START(MQ)+J-1) = MWK(START(KQ)+J-1)
      ENDDO
      TEMPV(MQ) = -2
      NUMBER_USED = NUMBER_USED + 1
      KT = MT
      MT = NUMBER_USED
      START(MT) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
      SIZE_OF(MT) = SIZE_OF(KT)
      DO J = 1, SIZE_OF(MT)
         MWK(START(MT)+J-1) = MWK(START(KT)+J-1)
      ENDDO
      TEMPV(MT) = -2
      IF (SIZE_OF(MQ) == NDIG+3 .AND. SIZE_OF(KP) < NDIG+3) THEN
          DO J = SIZE_OF(KP)+1, SIZE_OF(MP)
             MWK(START(MP)+J-1) = 0
          ENDDO
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
          IF (TEMPV(MQ) == -1) TEMPV(MQ) = -2
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION - 1
      RETURN
      END SUBROUTINE FMPI3_PQT

      SUBROUTINE FMPRNT(MA)

!  Print MA in base 10 format.

!  FMPRNT can be called directly by the user for easy output in M format.
!  MA is converted using FMOUT and printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA

      CHARACTER(20) :: FORM
      INTEGER :: J,K,KSAVE,L,LAST,LB,ND,NEXP
      INTENT (IN) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMPRNT'
      KSAVE = KFLAG
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = MAX(JFORM2+NEXP,ND+NEXP)
      IF (LB+50 > LMBUFF) THEN
          IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
          ALLOCATE(CMBUFF(LB+50),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFF = LB + 50
      ENDIF
      CALL FMOUT(MA,CMBUFF,LB)
      KFLAG = KSAVE
      LAST = LB + 1
      WRITE (FORM,"(' (6X,',I3,'A1) ')") KSWIDE-7
      DO J = 1, LB
         IF (CMBUFF(LAST-J) /= ' ' .OR. J == LB) THEN
             L = LAST - J
             WRITE (KW,FORM) (CMBUFF(K),K=1,L)
             NCALL = NCALL - 1
             IF (TEMPV_CALL_STACK == 1) THEN
                 IF (TEMPV(MA) == -1) TEMPV(MA) = -2
             ENDIF
             TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
             RETURN
         ENDIF
      ENDDO
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPRNT

      SUBROUTINE FMPWR(MA,MB,MC)

!  MC = MA ** MB

!  If MB can be expressed exactly as a one word integer, then FMIPWR is used.  This is much faster
!  when MB is small, and using FMIPWR allows MA to be negative.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTMB,J,K,KASAVE,KFL,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Convert MB to an integer before changing NDIG.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMMI(MB,INTMB)
      KWARN = KWRNSV
      KFL = KFLAG
      KR_RETRY = 0

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)) >= 0 .AND. MWK(START(MA)+3) > 0 .AND.  &
          MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          NCALL = NCALL + 1
          IF (MWK(START(MB)+2) == MEXPUN) THEN
              CALL FMEQ(MB,MXY(3))
              IF (MWK(START(MA)+2) <= 0) CALL FMMPYI_R1(MXY(3),-1)
          ELSE
              CALL FMLN(MA,MXY(1))
              CALL FMMPY(MXY(1),MB,MXY(3))
          ENDIF
          NCALL = NCALL - 1
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (MWK(START(MXY(3))+2) < -NDIG) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPWR'
                  CALL FMNTR(2,MA,MB,2,1)
                  NCALL = NCALL - 1
              ENDIF
              J = NTRACE
              NTRACE = 0
              K = KWARN
              KWARN = 0
              CALL FMI2M(1,MXY(1))
              CALL FMSUB(MA,MXY(1),MXY(2))
              IF (MWK(START(MXY(2))+3) == 0) THEN
                  CALL FMI2M(1,MXY(2))
              ELSE
                  CALL FMADD(MXY(1),MXY(3),MXY(2))
              ENDIF
              IF (MWK(START(MXY(2))+2) /= MUNKNO) THEN
                  KFLAG = 0
                  NTRACE = J
                  KWARN = K
                  CALL FMEQ(MXY(2),MC)
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMPWR'
                      CALL FMNTR(1,MC,MC,1,1)
                      NCALL = NCALL - 1
                  ENDIF
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. ABS(MWK(START(MB)+2)) > MEXPAB .OR.  &
          MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) < 0) THEN
          CALL FMENTR('FMPWR    ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMPWR'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

!             If the exponent is large or the base is very large, raise the precision.

      IF (MWK(START(MA)+2) /= 0) THEN
          IEXTRA = MAX(0,INT(MWK(START(MB)+2)))+INT(LOG(ABS(REAL(MWK(START(MA)+2))))/ALOGMB)
      ELSE
          IEXTRA = MAX(0,INT(MWK(START(MB)+2)))
      ENDIF
      IF (MWK(START(MB)+2)-NDIG > LOG(ALOGMB*REAL(MXEXP2))) THEN
          IEXTRA = 0
      ENDIF
      NDIG = NDIG + IEXTRA

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF

!             If the exponent is a small integer, call FMIPWR.

      KWRNSV = KWARN
      KWARN = 0

      MACCA = MWK(START(MA)+1)
      MACCB = NINT(NDIG*ALOGM2)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

      IF (KFL == 0) THEN
          CALL FMIPWR(MXY(2),INTMB,MXY(4))
      ELSE IF (MWK(START(MXY(2))+3) == 0 .OR. MWK(START(MXY(2))) < 0) THEN
          CALL FMST2M('UNKNOWN',MXY(4))
          KFLAG = -4
      ELSE
          CALL FMLN(MXY(2),MXY(3))
          MACCB = MWK(START(MB)+1)
          CALL FMEQU(MB,MXY(1),NDSAVE,NDIG)
          MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
          CALL FMMPY_R1(MXY(3),MXY(1))
          CALL FMEXP(MXY(3),MXY(4))
      ENDIF
      KWARN = KWRNSV

!             Round the result and return.

      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(4))+3))+1))/0.69315)
      MWK(START(MXY(4))+1) = MIN(MWK(START(MXY(4))+1),MACCA,MACCB,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(4))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(4),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPWR

      SUBROUTINE FMRDC(MA,JSIN,JCOS,JSWAP)

!  Reduce MA using various trigonometric identities to an equivalent angle between 0 and 45 degrees.
!  The reduction is done in radians if KRAD (in module FMVALS) is 1, in degrees if KRAD is 0.
!  JSIN and JCOS are returned +1 or -1 and JSWAP is returned to indicate that the sin and cos
!  functions have been interchanged as follows:

!  JSWAP = 0 means   SIN(MA) = JSIN*SIN(returned value of MA)
!                    COS(MA) = JCOS*COS(returned value of MA)

!  JSWAP = 1 means   SIN(MA) = JSIN*COS(returned value of MA)
!                    COS(MA) = JCOS*SIN(returned value of MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: JSIN,JCOS,JSWAP
      REAL (KIND(1.0D0)) :: MA0
      DOUBLE PRECISION :: X
      INTEGER :: J,KASAVE,NDSAVE,NDSV
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (INOUT) :: MA
      INTENT (INOUT) :: JSIN,JCOS,JSWAP
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      JSIN = 1
      JCOS = 1
      JSWAP = 0
      NDSAVE = NDIG
      IF (KRAD == 0) THEN
          CALL FMI2M(360,MXY(2))
          CALL FMEQ(MA,MXY(4))
          CALL FMMOD(MXY(4),MXY(2),MA)
      ENDIF

      NDIG = NDIG + MAX(0,INT(MWK(START(MA)+2)))

      MA0 = MWK(START(MA)+1) + NINT(ALOGM2*REAL(MAX(0,INT(MWK(START(MA)+2)))))

!             If MA is less than 1/MBASE, no reduction is needed.

      IF (MWK(START(MA)+2) < 0) THEN
          NDIG = NDSAVE
          IF (MWK(START(MA)) < 0) THEN
              MWK(START(MA)) = 1
              JSIN = -1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          RETURN
      ENDIF

      J = 1
      IF (KRAD == 1) THEN
  110     IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              KASAVE = KACCSW
              KACCSW = 0
              CALL FMPI(MXY(4))
              KACCSW = KASAVE
              NDIG = NDSV
          ENDIF
          CALL FMEQU(MA,MXY(4),NDSAVE,NDIG)
          MWK(START(MXY(4))+1) = MA0
          IF (MWK(START(MA)) < 0) JSIN = -1
          MWK(START(MXY(4))) = 1
          IF (MWK(START(MXY(4))+2) == 0) THEN
              CALL FMM2DP(MXY(4),X)
              IF (X <= 0.75) THEN
                  NDIG = NDSAVE
                  CALL FMEQ(MXY(4),MA)
                  NUMBER_USED = NUMBER_USED_SAVE
                  RETURN
              ENDIF
          ENDIF
          CALL FMADD(MPISAV,MPISAV,MXY(2))
          IF (FMCOMP(MXY(4),'>=',MXY(2))) THEN
              CALL FMDIV(MXY(4),MXY(2),MXY(1))
              CALL FMINT(MXY(1),MXY(5))
              CALL FMMPY_R1(MXY(5),MXY(2))
              CALL FMSUB_R1(MXY(4),MXY(5))
          ENDIF
          CALL FMEQ(MPISAV,MXY(3))
          IF (FMCOMP(MXY(4),'>=',MXY(3))) THEN
              JSIN = -JSIN
              CALL FMSUB_R2(MXY(2),MXY(4))
          ENDIF
          CALL FMDIVI_R1(MXY(2),4)
          IF (FMCOMP(MXY(4),'>=',MXY(2))) THEN
              JCOS = -JCOS
              CALL FMSUB_R2(MXY(3),MXY(4))
          ENDIF
          CALL FMDIVI_R1(MXY(3),4)
          IF (FMCOMP(MXY(4),'>=',MXY(3))) THEN
              JSWAP = 1
              CALL FMSUB_R2(MXY(2),MXY(4))
          ENDIF

!             If the reduced argument is close to zero, then cancellation has produced an
!             inaccurate value.
!             Raise NDIG and do the reduction again.

          IF (J == 1 .AND. (MWK(START(MXY(4))+2) < 0 .OR. MWK(START(MXY(4))+3) == 0)) THEN
              J = 2
              IF (MWK(START(MXY(4))+3) == 0) THEN
                  NDIG = 2*NDIG
              ELSE
                  NDIG = NDIG - INT(MWK(START(MXY(4))+2))
              ENDIF
              JSIN = 1
              JCOS = 1
              JSWAP = 0
              MA0 = MWK(START(MA)+1) + NINT(ALOGM2*REAL(-MWK(START(MXY(4))+2)))
              MXY = -2
              GO TO 110
          ENDIF

      ELSE

          CALL FMEQU(MA,MXY(4),NDSAVE,NDIG)
          MWK(START(MXY(4))+1) = MA0
          IF (MWK(START(MA)) < 0) JSIN = -1
          MWK(START(MXY(4))) = 1
          IF (MWK(START(MXY(4))+2) == 0) THEN
              CALL FMM2DP(MXY(4),X)
              IF (X <= 44.0) THEN
                  NDIG = NDSAVE
                  CALL FMEQ(MXY(4),MA)
                  NUMBER_USED = NUMBER_USED_SAVE
                  RETURN
              ENDIF
          ENDIF
          CALL FMI2M(360,MXY(2))
          IF (FMCOMP(MXY(4),'>=',MXY(2))) THEN
              CALL FMDIV(MXY(4),MXY(2),MXY(1))
              CALL FMINT(MXY(1),MXY(5))
              CALL FMMPY_R1(MXY(5),MXY(2))
              CALL FMSUB_R1(MXY(4),MXY(5))
          ENDIF
          CALL FMI2M(180,MXY(3))
          IF (FMCOMP(MXY(4),'>=',MXY(3))) THEN
              JSIN = -JSIN
              CALL FMSUB_R2(MXY(2),MXY(4))
          ENDIF
          CALL FMI2M(90,MXY(2))
          IF (FMCOMP(MXY(4),'>=',MXY(2))) THEN
              JCOS = -JCOS
              CALL FMSUB_R2(MXY(3),MXY(4))
          ENDIF
          CALL FMI2M(45,MXY(3))
          IF (FMCOMP(MXY(4),'>=',MXY(3))) THEN
              JSWAP = 1
              CALL FMSUB_R2(MXY(2),MXY(4))
          ENDIF

      ENDIF

!             Round the result and return.

      CALL FMEQU(MXY(4),MA,NDIG,NDSAVE)
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FMRDC

      SUBROUTINE FMREAD(KREAD,MA)

!  Read MA on unit KREAD.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: KREAD

      CHARACTER :: LINE(132)
      INTEGER :: J,K,L2,LB,NDSAVE
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMREAD'
      NDSAVE = NDIG
      NDIG = MAX(NDIG+NGRD52,2)
      LB = 0

  110 READ (KREAD,"(132A1)",ERR=120,END=120) LINE

!             Scan the line and look for '&'

      DO J = 1, 132
         IF (LINE(J) == '&') GO TO 110
         IF (LINE(J) /= ' ') THEN
             LB = LB + 1
             IF (LB > LMBUFF) THEN

!                If CMBUFF runs out of space, try to re-allocate it with a bigger size.

                 IF (LMBUFF > 0) THEN
                     ALLOCATE(MOVE_CMBUFF(LMBUFF),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, LMBUFF
                        MOVE_CMBUFF(K) = CMBUFF(K)
                     ENDDO
                     DEALLOCATE(CMBUFF)
                     L2 = MAX(10000,2*LMBUFF)
                     ALLOCATE(CMBUFF(L2),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, L2
                        CMBUFF(K) = ' '
                     ENDDO
                     DO K = 1, LMBUFF
                        CMBUFF(K) = MOVE_CMBUFF(K)
                     ENDDO
                     DEALLOCATE(MOVE_CMBUFF)
                     LMBUFF = L2
                 ELSE
                     ALLOCATE(CMBUFF(10000),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     LMBUFF = 10000
                 ENDIF
             ENDIF
             CMBUFF(LB) = LINE(J)
         ENDIF
      ENDDO

      NCALL = NCALL - 1
      CALL FMINP(CMBUFF,MXY(1),1,LB)
      NCALL = NCALL + 1

      CALL FMEQU(MXY(1),MA,NDIG,NDSAVE)
      NDIG = NDSAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

!             If there is an error, return UNKNOWN.

  120 KFLAG = -4
      CALL FMWARN
      NDIG = NDSAVE
      CALL FMST2M('UNKNOWN',MA)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMREAD

      SUBROUTINE FMRND(MW,ND,NGUARD,KSHIFT)

!  Round MW to ND digits (base MBASE).

!  MW is non-negative and has ND+NGUARD+KSHIFT digits.

!  NGUARD is the number of guard digits carried.
!  KSHIFT is 1 if a left shift is pending when MWK(START(MW)+3)=0.

!  Round to position MWK(START(MW)+1+ND+1+KSHIFT) using the guard digits
!  MWK(START(MW)+1+ND+2+KSHIFT), ..., MWK(START(MW)+1+ND+1+NGUARD+KSHIFT).

!  This routine is designed to be called only from within the FM package.
!  The user should call FMEQU to round numbers.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MW
      INTEGER :: ND,NGUARD,KSHIFT

      REAL (KIND(1.0D0)) :: M2,MKT
      INTEGER :: J,K,KB,L
      INTENT (IN) :: ND,KSHIFT,NGUARD
      INTENT (INOUT) :: MW

      IF (KROUND == -1) THEN
          IF (JRSIGN == 1) RETURN
          DO J = ND+2+KSHIFT, ND+1+NGUARD+KSHIFT
             IF (MWK(START(MW)+J+1) > 0) THEN
                 MWK(START(MW)+KSHIFT+ND+2) = MWK(START(MW)+KSHIFT+ND+2) + 1
                 MWK(START(MW)+KSHIFT+ND+3) = 0
                 IF (MWK(START(MW)+KSHIFT+ND+2) < MBASE) RETURN
                 L = ND + 2 + KSHIFT
                 GO TO 120
             ENDIF
          ENDDO
          RETURN
      ENDIF

      IF (KROUND == 2) THEN
          IF (JRSIGN == -1) RETURN
          DO J = ND+2+KSHIFT, ND+1+NGUARD+KSHIFT
             IF (MWK(START(MW)+J+1) > 0) THEN
                 MWK(START(MW)+KSHIFT+ND+2) = MWK(START(MW)+KSHIFT+ND+2) + 1
                 MWK(START(MW)+KSHIFT+ND+3) = 0
                 IF (MWK(START(MW)+KSHIFT+ND+2) < MBASE) RETURN
                 L = ND + 2 + KSHIFT
                 GO TO 120
             ENDIF
          ENDDO
          RETURN
      ENDIF

      IF (KROUND == 0) RETURN
      L = ND + 2 + KSHIFT
      IF (2*(MWK(START(MW)+L+1)+1) < MBASE) RETURN
      IF (2*MWK(START(MW)+L+1) > MBASE) THEN
          MWK(START(MW)+L) = MWK(START(MW)+L) + 1
          MWK(START(MW)+L+1) = 0
          IF (MWK(START(MW)+L) < MBASE) RETURN
          GO TO 120
      ENDIF

!             If the first guard digit gives a value close to 1/2 then further guard digits must
!             be examined.

      M2 = 2
      IF (INT(MBASE-AINT (MBASE/M2)*M2) == 0) THEN
          IF (2*MWK(START(MW)+L+1) < MBASE) RETURN
          IF (2*MWK(START(MW)+L+1) == MBASE) THEN
              IF (NGUARD >= 2) THEN
                  DO J = 2, NGUARD
                     IF (MWK(START(MW)+J+L) > 0) GO TO 110
                  ENDDO
              ENDIF

!                       Round to even.

              IF (INT(MWK(START(MW)+L)-AINT (MWK(START(MW)+L)/M2)*M2) == 0) RETURN
          ENDIF
      ELSE
          IF (2*MWK(START(MW)+L+1)+1 == MBASE) THEN
              IF (NGUARD >= 2) THEN
                  DO J = 2, NGUARD
                     IF (2*(MWK(START(MW)+J+L)+1) < MBASE) RETURN
                     IF (2*MWK(START(MW)+J+L) > MBASE) GO TO 110
                  ENDDO
                  IF (NGUARD <= NDIG) RETURN
                  M2 = 2
                  IF (INT(MWK(START(MW)+L)-AINT (MWK(START(MW)+L)/M2)*M2) == 0) THEN
                      RETURN
                  ELSE
                      GO TO 110
                  ENDIF
              ENDIF
          ENDIF
      ENDIF

!             Round up.

  110 MWK(START(MW)+L) = MWK(START(MW)+L) + 1
      MWK(START(MW)+L+1) = 0

!             Check whether there was a carry in the rounded digit.

  120 KB = L - 1
      IF (KB >= 3) THEN
          K = KB + 1
          DO J = 3, KB
             K = K - 1
             IF (MWK(START(MW)+K+1) < MBASE) RETURN
             MKT = AINT (MWK(START(MW)+K+1)/MBASE)
             MWK(START(MW)+K) = MWK(START(MW)+K) + MKT
             MWK(START(MW)+K+1) = MWK(START(MW)+K+1) - MKT*MBASE
          ENDDO
      ENDIF

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

      IF (MWK(START(MW)+3) >= MBASE) THEN
          IF (KB >= 4) THEN
              K = KB + 1
              DO J = 4, KB
                 K = K - 1
                 MWK(START(MW)+K+1) = MWK(START(MW)+K)
              ENDDO
          ENDIF

          MKT = AINT (MWK(START(MW)+3)/MBASE)
          IF (KB >= 3) MWK(START(MW)+4) = MWK(START(MW)+3) - MKT*MBASE
          MWK(START(MW)+3) = MKT
          MWK(START(MW)+2) = MWK(START(MW)+2) + 1
      ENDIF

      RETURN
      END SUBROUTINE FMRND

      SUBROUTINE FMRPWR(MA,IVAL,JVAL,MB)

!  MB = MA ** (IVAL/JVAL)   rational exponentiation.

!  This routine is faster than FMPWR when IVAL and JVAL are small integers.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL,JVAL
      DOUBLE PRECISION :: X,F
      REAL (KIND(1.0D0)) :: MA1,MA2,MAS,MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: NSTACK(49),IJSIGN,INVERT,IVAL2,J,JVAL2,K,KASAVE,KL,KOVUN,KR_RETRY,KST,  &
                 KWRNSV,L,LVAL,NDSAVE
      REAL :: XVAL
      INTENT (IN) :: MA,IVAL,JVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      KR_RETRY = 0

      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMRPWR'
      IF (NTRACE /= 0) THEN
          CALL FMNTR(2,MA,MA,1,1)
          CALL FMNTRI(2,IVAL,0)
          CALL FMNTRI(2,JVAL,0)
      ENDIF
      KOVUN = 0
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
      NDSAVE = NDIG
      KASAVE = KACCSW
      KACCSW = 0
      MXSAVE = MXEXP
      MXEXP = MXEXP2

  110 IF (NCALL == 1) THEN
          XVAL = MAX(ABS(IVAL),ABS(JVAL))
          IF (XVAL == 0.0) XVAL = 1.0
          K = INT((5.0*REAL(DLOGTN) + 2.0*LOG(XVAL))/ALOGMB + 2.0)
          NDIG = MAX(NDIG+K,2)
          IF (KR_RETRY >= 1) THEN
              NDIG = MAX(NDIG,2*NDSAVE+10)
          ENDIF
      ELSE
          XVAL = MAX(ABS(IVAL),ABS(JVAL))
          IF (XVAL == 0.0) XVAL = 1.0
          K = INT(LOG(XVAL)/ALOGMB + 1.0)
          NDIG = NDIG + K
      ENDIF

      MAS = MWK(START(MA))
      MA1 = MWK(START(MA)+2)
      MA2 = MWK(START(MA)+3)
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

!             Use GCD-reduced positive exponents.

      IJSIGN = 1
      IVAL2 = ABS(IVAL)
      JVAL2 = ABS(JVAL)
      IF (IVAL > 0 .AND. JVAL < 0) IJSIGN = -1
      IF (IVAL < 0 .AND. JVAL > 0) IJSIGN = -1
      IF (IVAL2 > 0 .AND. JVAL2 > 0) CALL FMGCDI(IVAL2,JVAL2)

!             Check for special cases.

  120 IF (MA1 == MUNKNO .OR. JVAL2 == 0 .OR. (IJSIGN <= 0 .AND. MA2 == 0)) THEN
          CALL FMST2M('UNKNOWN',MXY(4))
          KFLAG = -4
          GO TO 130
      ENDIF

      IF (IVAL2 == 0) THEN
          CALL FMIM(1,MXY(4))
          GO TO 130
      ENDIF

      IF (JVAL2 == 1) THEN
          CALL FMIPWR(MXY(2),IJSIGN*IVAL2,MXY(4))
          GO TO 130
      ENDIF

      IF (MA2 == 0) THEN
          CALL FMEQ(MA,MXY(4))
          GO TO 130
      ENDIF

      IF (MAS < 0) THEN
          IF (MOD(JVAL2,2) == 0) THEN
              JVAL2 = 0
              GO TO 120
          ENDIF
      ENDIF

      IF (MA1 == MEXPOV) THEN
          IF (IVAL2 < JVAL2) THEN
              JVAL2 = 0
              GO TO 120
          ENDIF
          CALL FMIM(0,MXY(4))
          IF (IJSIGN == 1 .AND. MAS > 0) THEN
              CALL FMST2M('OVERFLOW',MXY(4))
              KFLAG = -5
          ELSE IF (IJSIGN == -1 .AND. MAS > 0) THEN
              CALL FMST2M('UNDERFLOW',MXY(4))
              KFLAG = -6
          ELSE IF (IJSIGN == 1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(4))
                  KFLAG = -5
              ELSE
                  CALL FMST2M('-OVERFLOW',MXY(4))
                  KFLAG = -5
              ENDIF
          ELSE IF (IJSIGN == -1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('UNDERFLOW',MXY(4))
                  KFLAG = -6
              ELSE
                  CALL FMST2M('-UNDERFLOW',MXY(4))
                  KFLAG = -6
              ENDIF
          ENDIF
          GO TO 130
      ENDIF

      IF (MA1 == MEXPUN) THEN
          IF (IVAL2 < JVAL2) THEN
              JVAL2 = 0
              GO TO 120
          ENDIF
          CALL FMIM(0,MXY(4))
          IF (IJSIGN == 1 .AND. MAS > 0) THEN
              CALL FMST2M('UNDERFLOW',MXY(4))
              KFLAG = -6
          ELSE IF (IJSIGN == -1 .AND. MAS > 0) THEN
              CALL FMST2M('OVERFLOW',MXY(4))
              KFLAG = -5
          ELSE IF (IJSIGN == 1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('UNDERFLOW',MXY(4))
                  KFLAG = -6
              ELSE
                  CALL FMST2M('-UNDERFLOW',MXY(4))
                  KFLAG = -6
              ENDIF
          ELSE IF (IJSIGN == -1 .AND. MAS < 0) THEN
              IF (MOD(IVAL2,2) == 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(4))
                  KFLAG = -5
              ELSE
                  CALL FMST2M('-OVERFLOW',MXY(4))
                  KFLAG = -5
              ENDIF
          ENDIF
          GO TO 130
      ENDIF

!             Invert MA if MA > 1 and IVAL or JVAL is large.

      INVERT = 0
      IF (MWK(START(MA)+2) > 0) THEN
          IF (IVAL > 5 .OR. JVAL > 5) THEN
              INVERT = 1
              CALL FMI2M(1,MXY(1))
              CALL FMDIV_R2(MXY(1),MXY(2))
          ENDIF
      ENDIF

!             Generate the first approximation to ABS(MA)**(1/JVAL2).

      MA1 = MWK(START(MXY(2))+2)
      MWK(START(MXY(2))+2) = 0
      MWK(START(MXY(2))) = 1
      CALL FMM2DP(MXY(2),X)
      L = INT(MA1/JVAL2)
      F = MA1/DBLE(JVAL2) - L
      X = X**(1.0D0/JVAL2) * DBLE(MBASE)**F
      CALL FMDPM(X,MXY(4))
      MWK(START(MXY(4))+2) = MWK(START(MXY(4))+2) + L
      MWK(START(MXY(2))+2) = MA1

!             Initialize.

      CALL FMI2M(0,MXY(3))
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         IF (J < KST) NDIG = NDIG + 1
         LVAL = JVAL2 - 1
         CALL FMIPWR(MXY(4),LVAL,MXY(3))
         CALL FMDIV_R2(MXY(2),MXY(3))
         CALL FMMPYI_R1(MXY(4),LVAL)
         CALL FMADD_R1(MXY(4),MXY(3))
         CALL FMDIVI_R1(MXY(4),JVAL2)
      ENDDO

      IF (MWK(START(MXY(4))+2) /= MUNKNO .AND. MWK(START(MXY(4))+3) /= 0 .AND. MAS < 0)  &
          MWK(START(MXY(4))) = -MWK(START(MXY(4)))
      CALL FMIPWR(MXY(4),IJSIGN*IVAL2,MXY(3))
      CALL FMEQ(MXY(3),MXY(4))
      IF (INVERT == 1) THEN
          CALL FMI2M(1,MXY(1))
          CALL FMDIV_R2(MXY(1),MXY(4))
      ENDIF

!             Round the result and return.

  130 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(4))+3))+1))/0.69315)
      MWK(START(MXY(4))+1) = MIN(MACCA,MACMAX)
      KWRNSV = KWARN
      IF (MA1 == MUNKNO) KWARN = 0

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(4))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(4),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KWARN = KWRNSV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMRPWR

      SUBROUTINE FMRSLT(MA,MB,MC,KRESLT)

!  Handle results that are special cases, such as overflow, underflow, and unknown.

!  MA and MB are the input arguments to an FM subroutine.

!  MC is the result that is returned.

!  KRESLT is the result code from FMARGS.  Result codes handled here:

!   0 - Perform the normal operation
!   1 - The result is the first input argument
!   2 - The result is the second input argument
!   3 - The result is -OVERFLOW
!   4 - The result is +OVERFLOW
!   5 - The result is -UNDERFLOW
!   6 - The result is +UNDERFLOW
!   7 - The result is -1.0
!   8 - The result is +1.0
!  11 - The result is 0.0
!  12 - The result is UNKNOWN

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: KRESLT

      REAL (KIND(1.0D0)) :: MACCAB,MACCSV
      INTEGER :: KFSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      KFSAVE = KFLAG
      MACCAB = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
      IF (KRESLT == 1) THEN
          MACCSV = MWK(START(MA)+1)
          CALL FMEQ(MA,MC)
          MWK(START(MC)+1) = MACCAB
          IF (NAMEST(NCALL) == 'FMADD' .OR. NAMEST(NCALL) == 'FMADD_R1' .OR.  &
              NAMEST(NCALL) == 'FMADD_R2' .OR. NAMEST(NCALL) == 'FMSUB' .OR.  &
              NAMEST(NCALL) == 'FMSUB_R1' .OR. NAMEST(NCALL) == 'FMSUB_R2') THEN
              KFLAG = 1
              MWK(START(MC)+1) = MACCSV
          ELSE
              KFLAG = KFSAVE
          ENDIF
          RETURN
      ENDIF

      IF (KRESLT == 2) THEN
          MACCSV = MWK(START(MB)+1)
          CALL FMEQ(MB,MC)
          MWK(START(MC)+1) = MACCAB
          IF (NAMEST(NCALL) == 'FMADD' .OR. NAMEST(NCALL) == 'FMADD_R1' .OR.  &
              NAMEST(NCALL) == 'FMADD_R2') THEN
              KFLAG = 1
              MWK(START(MC)+1) = MACCSV
          ELSE
              KFLAG = KFSAVE
          ENDIF
          IF (NAMEST(NCALL) == 'FMSUB' .OR. NAMEST(NCALL) == 'FMSUB_R1' .OR.  &
              NAMEST(NCALL) == 'FMSUB_R2') THEN
              IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
                  MWK(START(MC)) = -MWK(START(MC))
              KFLAG = KFSAVE
              MWK(START(MC)+1) = MACCSV
          ENDIF
          RETURN
      ENDIF

      IF (KRESLT == 3 .OR. KRESLT == 4) THEN
          CALL FMIM(0,MC)
          MWK(START(MC)+2) = MEXPOV
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          IF (KRESLT == 3) MWK(START(MC)) = -1
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 5 .OR. KRESLT == 6) THEN
          CALL FMIM(0,MC)
          MWK(START(MC)+2) = MEXPUN
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          IF (KRESLT == 5) MWK(START(MC)) = -1
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 7) THEN
          CALL FMIM(-1,MC)
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 8) THEN
          CALL FMIM(1,MC)
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 11) THEN
          CALL FMIM(0,MC)
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      IF (KRESLT == 12 .OR. KRESLT < 0 .OR. KRESLT > 15) THEN
          CALL FMIM(0,MC)
          MWK(START(MC)+2) = MUNKNO
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = MACCAB
          KFLAG = KFSAVE
          RETURN
      ENDIF

      RETURN
      END SUBROUTINE FMRSLT

      SUBROUTINE FMSETVAR(STRING)

!  Change the value of one of the internal FM variables.
!  STRING must have the format  ' variablename = value ', with no embedded blanks in variablename.

      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      CHARACTER(9) :: VARNAME
      INTEGER :: IVAL,J,KPTEQ,KPT1,KPT2
      DOUBLE PRECISION :: DVAL
      REAL (KIND(1.0D0)) :: MVAL

      CHARACTER(52) :: LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
      INTENT (IN) :: STRING

!             Find the equal sign.

      KPTEQ = INDEX(STRING,'=')
      IF (KPTEQ <= 0) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Cannot find the equal sign in FMSETVAR.'
          WRITE (KW,*) ' Input string:  ',STRING
          RETURN
      ENDIF

!             Find the variable name.

      KPT1 = 0
      KPT2 = 0
      DO J = 1, KPTEQ-1
         IF (KPT1 == 0 .AND. STRING(J:J) /= ' ') KPT1 = J
      ENDDO
      DO J = KPTEQ-1, 1, -1
         IF (KPT2 == 0 .AND. STRING(J:J) /= ' ') KPT2 = J
      ENDDO
      IF (KPT1 == 0) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Cannot find the variable name in FMSETVAR.'
          WRITE (KW,*) ' Input string:  ',STRING
          RETURN
      ENDIF
      VARNAME = ' '
      DO J = KPT1, KPT2
         IVAL = INDEX(LETTERS,STRING(J:J))
         IF (IVAL > 26 .AND. IVAL <= 52) THEN
             VARNAME(J-KPT1+1:J-KPT1+1) = LETTERS(IVAL-26:IVAL-26)
         ELSE
             VARNAME(J-KPT1+1:J-KPT1+1) = STRING(J:J)
         ENDIF
      ENDDO

!             CMCHAR is a special case, since the value is a character.

      IF (VARNAME == 'CMCHAR') THEN
          KPT1 = 0
          KPT2 = 0
          DO J = KPTEQ+1, LEN(STRING)
             IF (KPT1 == 0 .AND. STRING(J:J) /= ' ') KPT1 = J
          ENDDO
          DO J = LEN(STRING), KPTEQ+1, -1
             IF (KPT2 == 0 .AND. STRING(J:J) /= ' ') KPT2 = J
          ENDDO
          IF (KPT1 == KPT2 .AND. INDEX(LETTERS,STRING(KPT1:KPT2)) > 0) THEN
              CMCHAR = STRING(KPT1:KPT2)
              RETURN
          ELSE
              WRITE (KW,*) ' '
              WRITE (KW,*) ' Only a single letter is allowed after the equal sign in FMSETVAR.'
              WRITE (KW,*) ' Input string:  ',STRING
              RETURN
          ENDIF
      ENDIF

!             Convert the value after the equal sign.

      IF (KPTEQ+1 <= LEN(STRING)) THEN
          IF (INDEX(STRING(KPTEQ+1:LEN(STRING)),'=') /= 0) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' Only a single equal sign is allowed in FMSETVAR.'
              WRITE (KW,*) ' Input string:  ',STRING
              RETURN
          ENDIF
          CALL FMST2D(STRING(KPTEQ+1:LEN(STRING)),DVAL)
          IF (KFLAG /= 0) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' Invalid value after the equal sign in FMSETVAR.'
              WRITE (KW,*) ' Input string:  ',STRING
              RETURN
          ENDIF
      ELSE
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Cannot find a value after the equal sign in FMSETVAR.'
          WRITE (KW,*) ' Input string:  ',STRING
          RETURN
      ENDIF

!             Check the list of variable names.

      IF (VARNAME == 'JFORM1') THEN
          JFORM1 = NINT(DVAL)
          IF (JFORM1 < 0 .OR. JFORM1 > 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',JFORM1,' is an invalid value for JFORM1'
              JFORM1 = 1
              WRITE (KW,*) '            Valid values are 0,1,2.  JFORM1 was set to ',JFORM1
          ENDIF
      ELSE IF (VARNAME == 'JFORM2') THEN
          JFORM2 = NINT(DVAL)
          IF (JFORM2 < 0) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',JFORM2,' is an invalid value for JFORM2'
              JFORM2 = 1
              WRITE (KW,*) '            It should be nonnegative.  JFORM2 was set to ',JFORM2
          ENDIF
      ELSE IF (VARNAME == 'JFORMZ') THEN
          JFORMZ = NINT(DVAL)
          IF (JFORMZ < 1 .OR. JFORMZ > 3) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',JFORMZ,' is an invalid value for JFORMZ'
              JFORMZ = 1
              WRITE (KW,*) '            Valid values are 1,2,3.  JFORMZ was set to ',JFORMZ
          ENDIF
      ELSE IF (VARNAME == 'JPRNTZ') THEN
          JPRNTZ = NINT(DVAL)
          IF (JPRNTZ < 1 .OR. JPRNTZ > 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',JPRNTZ,' is an invalid value for JPRNTZ'
              JPRNTZ = 1
              WRITE (KW,*) '            Valid values are 1,2.  JPRNTZ was set to ',JPRNTZ
          ENDIF
      ELSE IF (VARNAME == 'KACCSW') THEN
          KACCSW = NINT(DVAL)
          IF (KACCSW < 0 .OR. KACCSW > 1) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KACCSW,' is an invalid value for KACCSW'
              KACCSW = 0
              WRITE (KW,*) '            Valid values are 0,1.  KACCSW was set to ',KACCSW
          ENDIF
      ELSE IF (VARNAME == 'KDEBUG') THEN
          KDEBUG = NINT(DVAL)
          IF (KDEBUG < 0 .OR. KDEBUG > 1) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KDEBUG,' is an invalid value for KDEBUG'
              KDEBUG = 1
              WRITE (KW,*) '            Valid values are 0,1.  KDEBUG was set to ',KDEBUG
          ENDIF
      ELSE IF (VARNAME == 'KESWCH') THEN
          KESWCH = NINT(DVAL)
          IF (KESWCH < 0 .OR. KESWCH > 1) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KESWCH,' is an invalid value for KESWCH'
              KESWCH = 1
              WRITE (KW,*) '            Valid values are 0,1.  KESWCH was set to ',KESWCH
          ENDIF
      ELSE IF (VARNAME == 'KRAD') THEN
          KRAD = NINT(DVAL)
          IF (KRAD < 0 .OR. KRAD > 1) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KRAD,' is an invalid value for KRAD'
              KRAD = 1
              WRITE (KW,*) '            Valid values are 0,1.  KRAD was set to ',KRAD
          ENDIF
      ELSE IF (VARNAME == 'KROUND') THEN
          KROUND = NINT(DVAL)
          IF (KROUND < -1 .OR. KROUND > 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KROUND,' is an invalid value for KROUND'
              KROUND = 1
              WRITE (KW,*) '            Valid values are -1,0,1,2.  KROUND was set to ',KROUND
          ENDIF
      ELSE IF (VARNAME == 'KRPERF') THEN
          KRPERF = NINT(DVAL)
          IF (KRPERF < 0 .OR. KRPERF > 1) THEN
              KRPERF = 0
          ENDIF
          WRITE (KW,*) ' '
          WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
          WRITE (KW,*) '            KRPERF is no longer used.  Now perfect rounding is ',  &
                       'always done.'
          WRITE (KW,*) ' '
      ELSE IF (VARNAME == 'KSWIDE') THEN
          KSWIDE = NINT(DVAL)
          IF (KSWIDE < 10) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KSWIDE,' is an invalid value for KSWIDE'
              KSWIDE = 80
              WRITE (KW,*) '            It should be 10 or more.  KSWIDE was set to ',KSWIDE
          ENDIF
      ELSE IF (VARNAME == 'KW') THEN
          KW = NINT(DVAL)
      ELSE IF (VARNAME == 'KWARN') THEN
          KWARN = NINT(DVAL)
          IF (KWARN < 0 .OR. KWARN > 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',KWARN,' is an invalid value for KWARN'
              KWARN = 1
              WRITE (KW,*) '            Valid values are 0,1,2.  KWARN was set to ',KWARN
          ENDIF
      ELSE IF (VARNAME == 'LVLTRC') THEN
          LVLTRC = NINT(DVAL)
          IF (LVLTRC < 0) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',LVLTRC,' is an invalid value for LVLTRC'
              LVLTRC = 1
              WRITE (KW,*) '            It should be nonnegative.  LVLTRC was set to ',LVLTRC
          ENDIF
      ELSE IF (VARNAME == 'NDIG') THEN
          IVAL = NDIG
          NDIG = NINT(DVAL)
          IF (NDIG < 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',NDIG,' is an invalid value for NDIG'
              NDIG = IVAL
              WRITE (KW,*) '            It should be > 1.  NDIG was not changed from ',NDIG
          ENDIF
      ELSE IF (VARNAME == 'NTRACE') THEN
          NTRACE = NINT(DVAL)
          IF (NTRACE < -2 .OR. NTRACE > 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',NTRACE,' is an invalid value for NTRACE'
              NTRACE = 0
              WRITE (KW,*) '            Valid values are -2,-1,0,1,2.  NTRACE was set to ',NTRACE
          ENDIF
      ELSE IF (VARNAME == 'MBASE') THEN
          MVAL = MBASE
          MBASE = AINT (0.5 + DVAL)
          IF (MBASE < 2) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',MBASE,' is an invalid value for MBASE'
              MBASE = MVAL
              WRITE (KW,*) '            It should be > 1.  MBASE was not changed from ',MBASE
          ENDIF
          IF (MBASE > MXBASE) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',MBASE,' is an invalid value for MBASE'
              MBASE = MVAL
              WRITE (KW,*) '            It should be <= ',MXBASE,  &
                           '.  MBASE was not changed from ',MBASE
          ENDIF
      ELSE IF (VARNAME == 'MXEXP') THEN
          MXEXP = AINT (DVAL)
          IF (MXEXP < 10 .OR. MXEXP > MXEXP2/2.01D0) THEN
              WRITE (KW,*) ' '
              WRITE (KW,*) ' FMSETVAR:  Input string:  ',STRING
              WRITE (KW,*) '            ',MXEXP,' is an invalid value for MXEXP'
              MXEXP = INT(MXEXP2/2.01D0)
              WRITE (KW,*) '            Valid values are 10 to ',  &
                           INT(MXEXP2/2.01D0),'  MXEXP was set to ',MXEXP
          ENDIF
      ELSE
          WRITE (KW,*) ' Variable name not recognized in FMSETVAR.'
          WRITE (KW,*) ' Input string:  ',STRING
          RETURN
      ENDIF

      CALL FMCONS
      RETURN
      END SUBROUTINE FMSETVAR

      SUBROUTINE FMSIGN(MA,MB,MC)

!  MC = SIGN(MA,MB)

!  MC is set to ABS(MA) if MB is positive or zero, or -ABS(MA) if MB is negative.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: KWRNSV

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMSIGN'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL FMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (MWK(START(MB)) >= 0) THEN
          CALL FMEQ(MA,MC)
          MWK(START(MC)) = 1
      ELSE
          CALL FMEQ(MA,MC)
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1
      ENDIF

      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSIGN

      SUBROUTINE FMSIN(MA,MB)

!  MB = SIN(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE,NDSV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. KRAD == 1) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSIN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),-6,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE IF (MWK(START(MA)) >= 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSIN'
              KFLAG = -4
              CALL FMWARN
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSIN'
              IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
              CALL FMWARN
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSIN'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMSIN    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMSIN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      MAS = MWK(START(MA))
      CALL FMEQU(MA,MXY(6),NDSAVE,NDIG)
      MWK(START(MXY(6))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(6))) = 1
      CALL FMEQ(MXY(6),MXY(5))
      IF (MWK(START(MA)+2) > 3*10**5 .AND. KRAD == 1) THEN
          KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(6))
          GO TO 120
      ENDIF

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMI2M(30,MXY(1))
          CALL FMSUB(MXY(6),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0 .AND. JSWAP == 0) THEN
              CALL FMST2M('0.5',MXY(1))
              CALL FMMPYI(MXY(1),JSIN,MXY(6))
              GO TO 120
          ENDIF
      ENDIF
      KWARN = KWRNSV
      IF (MWK(START(MXY(6))+2) == MUNKNO) THEN
          IF (KRAD /= 1 .OR. JSWAP == 0) THEN
              CALL FMEQ(MXY(5),MXY(6))
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
              GO TO 120
          ENDIF
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(3))
              NDIG = NDSV
          ENDIF
          CALL FMDIV(MXY(5),MPISAV,MXY(3))
          CALL FMMPYI_R1(MXY(3),2)
          CALL FMNINT(MXY(3),MXY(2))
          CALL FMMPY(MXY(2),MPISAV,MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMSUB_R2(MXY(5),MXY(1))
          IF (MWK(START(MXY(1))+3) == 0) CALL FMULP(MXY(5),MXY(1))
          CALL FMI2M(1,MXY(3))
          CALL FMSQR_R1(MXY(1))
          CALL FMDIVI_R1(MXY(1),2)
          CALL FMSUB_R2(MXY(3),MXY(1))
          CALL FMSUB_R1(MXY(1),MXY(3))
          IF (MWK(START(MXY(1))+3) == 0) THEN
              CALL FMI2M(JSIN,MXY(6))
          ELSE
              CALL FMEQ(MXY(5),MXY(6))
              CALL FMRDC(MXY(6),JSIN,JCOS,JSWAP)
          ENDIF
          GO TO 120
      ENDIF
      IF (KRAD == 0) THEN
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(4))
              NDIG = NDSV
          ENDIF
          CALL FMMPY_R1(MXY(6),MPISAV)
          CALL FMDIVI_R1(MXY(6),180)
      ENDIF
      IF (MWK(START(MXY(6))+2) /= MUNKNO) THEN
          IF (JSWAP == 0) THEN
              IF (MWK(START(MXY(6))+2) < 0 .OR. NDIG <= 50) THEN
                  CALL FMSIN2(MXY(6),MXY(4))
                  CALL FMEQ(MXY(4),MXY(6))
              ELSE
                  CALL FMCOS2(MXY(6),MXY(4))
                  CALL FMI2M(1,MXY(2))
                  CALL FMSQR_R1(MXY(4))
                  CALL FMSUB_R2(MXY(2),MXY(4))
                  CALL FMSQRT(MXY(4),MXY(6))
              ENDIF
          ELSE
              CALL FMCOS2(MXY(6),MXY(4))
              CALL FMEQ(MXY(4),MXY(6))
          ENDIF
      ENDIF

!             Append the sign, round, and return.

      IF (JSIN == -1 .AND. MWK(START(MXY(6))+2) /= MUNKNO .AND. MWK(START(MXY(6))+3) /= 0)  &
          MWK(START(MXY(6))) = -MWK(START(MXY(6)))
  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(6))+3))+1))/0.69315)
      MWK(START(MXY(6))+1) = MIN(MWK(START(MXY(6))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(6))+2) /= MUNKNO .AND. MWK(START(MXY(6))+3) /= 0)  &
          MWK(START(MXY(6))) = -MWK(START(MXY(6)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(6))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(6),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSIN

      SUBROUTINE FMSIN2(MA,MB)

!  Internal subroutine for MB = SIN(MA) where 0 <= MA <= 1.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAXVAL
      INTEGER :: J,J2,K,K2,KTHREE,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG3,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      NDSAVE = NDIG
      KWRNSV = KWARN
      KWARN = 0

!             Use the direct series
!                  SIN(X) = X - X**3/3! + X**5/5! - ...

!             The argument will be divided by 3**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.  The approximately optimal values of K2 and J2 are now
!             computed to try to minimize the time required. N2/2 is the approximate number of terms
!             of the series that will be needed, and L2 guard digits will be carried.

      B = REAL(MBASE)
      K = NGRD52
      T = MAX(NDIG-K,2)
      ALOG3 = LOG(3.0)
      ALOGT = LOG(T)
      TJ = 0.05*ALOGMB*T**0.3333 + 1.85
      J2 = INT(TJ)
      J2 = MAX(1,MIN(J2,LJSUMS))
      K2 = INT(0.1*SQRT(T*ALOGMB/TJ) - 0.05*ALOGT + 2.5)

      L = INT(-(REAL(MWK(START(MA)+2))*ALOGMB+LOG(REAL(MWK(START(MA)+3))/B +  &
            REAL(MWK(START(MA)+4))/(B*B)))/ALOG3 - 0.3)
      K2 = K2 - L
      IF (L < 0) L = 0
      IF (K2 < 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*ALOGMB/(ALOGT+REAL(L)*ALOG3)) + .33)
      ENDIF
      IF (J2 <= 1) J2 = 1

      N2 = INT(T*ALOGMB/(ALOGT+REAL(L)*ALOG3))
      L2 = INT((LOG(1+REAL(N2)/3.0D0**K2)+K2*LOG(3.0D0))/ALOGMB)
      NDIG = NDIG + L2
      NDSAV1 = NDIG

!             Divide the argument by 3**K2.

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      KTHREE = 1
      MAXVAL = MXBASE/3
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTHREE = 3*KTHREE
             IF (KTHREE > MAXVAL) THEN
                 CALL FMDIVI_R1(MXY(1),KTHREE)
                 KTHREE = 1
             ENDIF
          ENDDO
          IF (KTHREE > 1) CALL FMDIVI_R1(MXY(1),KTHREE)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum
!             as the terms get smaller.

      CALL FMEQ(MXY(1),MXY(2))
      NTERM = 1
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         IF (NBOT > 1) CALL FMDIVI_R1(MXY(2),NBOT)
         NTERM = NTERM + 2
         CALL FMEQ(MXY(2),MJSUMS(J))
         IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
             MWK(START(MXY(2))) = -MWK(START(MXY(2)))
      ENDDO
      CALL FMSQR_R1(MXY(1))
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 120
      CALL FMIPWR(MXY(1),J2,MXY(3))

  110 CALL FMMPY_R1(MXY(2),MXY(3))
      LARGE = INT(INTMAX/NTERM)
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMDIVI_R1(MXY(2),NTERM)
             NBOT = NTERM - 1
             CALL FMDIVI_R1(MXY(2),NBOT)
         ELSE
             CALL FMDIVI_R1(MXY(2),NBOT)
         ENDIF
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 120
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(2))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
             MWK(START(MXY(2))) = -MWK(START(MXY(2)))
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(3))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(1),MXY(3))
             CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))
          ENDDO
      ENDIF

!             Reverse the effect of reducing the argument to compute SIN(MA).

      NDIG = NDSAV1
      IF (K2 > 0) THEN
          CALL FMI2M(3,MXY(1))
          DO J = 1, K2
             CALL FMSQR(MXY(3),MXY(2))
             CALL FMMPYI_R1(MXY(2),-4)
             CALL FMADD_R2(MXY(1),MXY(2))
             CALL FMMPY_R2(MXY(2),MXY(3))
          ENDDO
      ENDIF

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE)
      NDIG = NDSAVE
      KWARN = KWRNSV

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSIN2

      SUBROUTINE FMSINH(MA,MB)

!  MB = SINH(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NMETHD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSINH'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),6,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. KROUND == -1) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE IF (MWK(START(MA)) >= 0 .AND. KROUND == 2) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMSINH'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMENTR('FMSINH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMSINH'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      MAS = MWK(START(MA))
      CALL FMEQU(MA,MXY(3),NDSAVE,NDIG)
      IF (MWK(START(MA)+3) == 0) THEN
          GO TO 120
      ENDIF
      MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(3))) = 1

!             Use a series for small arguments, FMEXP for large ones.

      IF (MWK(START(MXY(3))+2) == MUNKNO) GO TO 120
      IF (MBASE > 99) THEN
          IF (MWK(START(MXY(3))+2) <= 0) THEN
              NMETHD = 1
          ELSE IF (MWK(START(MXY(3))+2) >= 2) THEN
              NMETHD = 2
          ELSE IF (ABS(MWK(START(MXY(3))+3)) < 10) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MWK(START(MXY(3))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 1) THEN
          IF (MWK(START(MXY(3))+2) < 0 .OR. NDIG <= 50) THEN
              CALL FMSNH2(MXY(3),MXY(4))
              CALL FMEQ(MXY(4),MXY(3))
          ELSE
              CALL FMCSH2(MXY(3),MXY(4))
              CALL FMI2M(1,MXY(2))
              CALL FMSQR_R1(MXY(4))
              CALL FMSUB_R1(MXY(4),MXY(2))
              CALL FMSQRT(MXY(4),MXY(3))
          ENDIF
      ELSE
          CALL FMEXP(MXY(3),MXY(5))
          CALL FMEQ(MXY(5),MXY(3))
          IF (MWK(START(MXY(3))+2) == MEXPOV) THEN
              GO TO 120
          ELSE IF (MWK(START(MXY(3))+2) == MEXPUN) THEN
              MWK(START(MXY(3))+2) = MEXPOV
              GO TO 120
          ENDIF
          IF (INT(MWK(START(MXY(3))+2)) <= (NDIG+1)/2) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMDIV_R1(MXY(1),MXY(3))
              CALL FMSUB_R1(MXY(3),MXY(1))
          ENDIF
          CALL FMDIVI_R1(MXY(3),2)
      ENDIF

!             Round and return.

  120 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(3))+3))+1))/0.69315)
      MWK(START(MXY(3))+1) = MIN(MWK(START(MXY(3))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
          MWK(START(MXY(3))) = -MWK(START(MXY(3)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(3),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSINH

      SUBROUTINE FMSNH2(MA,MB)

!  Internal subroutine for MB = SINH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAXVAL
      INTEGER :: J,J2,K,K2,KTHREE,KWRNSV,L,L2,LARGE,N2,NBOT,NDSAV1,NDSAVE,NTERM
      REAL :: ALOG3,ALOGT,B,T,TJ
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      NDSAVE = NDIG
      KWRNSV = KWARN
      KWARN = 0

!             Use the direct series
!                  SINH(X) = X + X**3/3! + X**5/5! - ...

!             The argument will be divided by 3**K2 before the series is summed.  The series will be
!             added as J2 concurrent series.  The approximately optimal values of K2 and J2 are now
!             computed to try to minimize the time required. N2/2 is the approximate number of terms
!             of the series that will be needed, and L2 guard digits will be carried.

      B = REAL(MBASE)
      K = NGRD52
      T = MAX(NDIG-K,2)
      ALOG3 = LOG(3.0)
      ALOGT = LOG(T)
      TJ = 0.05*ALOGMB*T**0.3333 + 1.85
      J2 = INT(TJ)
      J2 = MAX(1,MIN(J2,LJSUMS))
      K2 = INT(0.1*SQRT(T*ALOGMB/TJ) - 0.05*ALOGT + 2.5)

      L = INT(-(REAL(MWK(START(MA)+2))*ALOGMB+LOG(REAL(MWK(START(MA)+3))/B +  &
            REAL(MWK(START(MA)+4))/(B*B)))/ALOG3 - 0.3)
      K2 = K2 - L
      IF (L < 0) L = 0
      IF (K2 < 0) THEN
          K2 = 0
          J2 = INT(.43*SQRT(T*ALOGMB/(ALOGT+REAL(L)*ALOG3)) + .33)
      ENDIF
      IF (J2 <= 1) J2 = 1

      N2 = INT(T*ALOGMB/(ALOGT+REAL(L)*ALOG3))
      L2 = INT(LOG(REAL(N2)+3.0D0**K2)/ALOGMB)
      NDIG = NDIG + L2
      NDSAV1 = NDIG

!             Divide the argument by 3**K2.

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      KTHREE = 1
      MAXVAL = MXBASE/3
      IF (K2 > 0) THEN
          DO J = 1, K2
             KTHREE = 3*KTHREE
             IF (KTHREE > MAXVAL) THEN
                 CALL FMDIVI_R1(MXY(1),KTHREE)
                 KTHREE = 1
             ENDIF
          ENDDO
          IF (KTHREE > 1) CALL FMDIVI_R1(MXY(1),KTHREE)
      ENDIF

!             Split into J2 concurrent sums and reduce NDIG while computing each term in the sum
!             as the terms get smaller.

      CALL FMEQ(MXY(1),MXY(2))
      NTERM = 1
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         IF (NBOT > 1) CALL FMDIVI_R1(MXY(2),NBOT)
         NTERM = NTERM + 2
         CALL FMEQ(MXY(2),MJSUMS(J))
      ENDDO
      CALL FMSQR_R1(MXY(1))
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 120
      CALL FMIPWR(MXY(1),J2,MXY(3))

  110 CALL FMMPY_R1(MXY(2),MXY(3))
      LARGE = INT(INTMAX/NTERM)
      DO J = 1, J2
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMDIVI_R1(MXY(2),NTERM)
             NBOT = NTERM - 1
             CALL FMDIVI_R1(MXY(2),NBOT)
         ELSE
             CALL FMDIVI_R1(MXY(2),NBOT)
         ENDIF
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 120
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(2))+2))
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 2
      ENDDO
      GO TO 110

!             Put the J2 separate sums back together.

  120 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(3))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(1),MXY(3))
             CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))
          ENDDO
      ENDIF

!             Reverse the effect of reducing the argument to compute SINH(MA).

      NDIG = NDSAV1
      IF (K2 > 0) THEN
          CALL FMI2M(3,MXY(1))
          DO J = 1, K2
             CALL FMSQR(MXY(3),MXY(2))
             CALL FMMPYI_R1(MXY(2),4)
             CALL FMADD_R2(MXY(1),MXY(2))
             CALL FMMPY_R2(MXY(2),MXY(3))
          ENDDO
      ENDIF

      CALL FMEQU(MXY(3),MB,NDSAV1,NDSAVE)
      NDIG = NDSAVE
      KWARN = KWRNSV

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSNH2

      SUBROUTINE FMSP2M(X,MA)

!  MA = X

!  Convert a single precision number to FM format.

!  This version tries to convert the single precision machine number to FM with accuracy of nearly
!  full FM precision.
!  If conversion to FM with approximately double precision accuracy is good enough, it is faster to
!  CALL FMDPM(DBLE(X),MA)

      USE FMVALS
      IMPLICIT NONE

      REAL :: X
      INTEGER :: MA

      DOUBLE PRECISION :: XDP,Y,YT
      INTEGER :: J,K
      INTENT (IN) :: X
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMSP2M'
      XDP = DBLE(X)
      IF (NTRACE /= 0) CALL FMNTRR(2,XDP,1)

!             Check for X = + or - Infinity, or NaN.  Return unknown if so.

      IF (EXPONENT(X) > EXPONENT(HUGE(X))) THEN
          DO J = 2, NDIG
             MWK(START(MA)+J+2) = 0
          ENDDO
          KFLAG = -4
          MWK(START(MA)+2) = MUNKNO
          MWK(START(MA)+3) = 1
          MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          MWK(START(MA)) = 1
          CALL FMWARN
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Check to see if X is exactly a small integer.  If so, converting as an integer
!             is better.  Also see if X is exactly a small integer divided by a small power of two.

      Y = MXEXP2
      IF (ABS(XDP) < Y) THEN
          K = INT(XDP)
          Y = K
          IF (Y == XDP) THEN
              CALL FMIM(K,MA)
              GO TO 110
          ENDIF
      ENDIF
      IF (ABS(XDP) < 1.0D0) THEN
          Y = 4096.0D0 * XDP
          K = INT(Y)
          YT = K
          IF (Y == YT) THEN
              CALL FMIM(K,MA)
              CALL FMDIVI_R1(MA,4096)
              GO TO 110
          ENDIF
      ENDIF

      CALL FMDM2(XDP,MA)

  110 IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSP2M

      SUBROUTINE FMSQR(MA,MB)

!  MB = MA*MA    Faster than using FMMPY.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMSQR'
          CALL FMNTR(2,MA,MA,1,1)

          CALL FMSQR2(MA,MB)

          CALL FMNTR(1,MB,MB,1,1)
      ELSE
          CALL FMSQR2(MA,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQR

      SUBROUTINE FMSQR2(MA,MB)

!  MB = MA*MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MACCA,MAXMAX,MAXMWA,MBJ,MBKJ,MBM1,MBNORM,MD2B,MK,MKA,MKT,MMAX,MR,MT
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JM1,JMA,JMWA,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KR_RETRY,KSHIFT,KWA,L,N1,NGUARD,  &
                 NMETHD,NZDA
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      KSQR = 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      KR_RETRY = 0
      JRSSAV = JRSIGN
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. KDEBUG == 1 .OR. MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL FMMPY2(MA,MA,MB)
          NCALL = NCALL - 1
          IF ((KFLAG < 0 .AND. KOVUN == 0) .OR. (KFLAG == -4 .AND. KOVUN == 1)) THEN
              NAMEST(NCALL) = 'FMSQR'
              CALL FMWARN
          ENDIF
          GO TO 130
      ELSE IF (MWK(START(MA)+3) == 0) THEN
          CALL FMEQ(MA,MB)
          GO TO 130
      ENDIF
      KFLAG = 0

!             Check for using an FFT-based method if precision is very high.

      IF (NDIG >= 2200) THEN
          NZDA = 0
          DO J = 2, NDIG
             IF (MWK(START(MA)+J+2) == 0) NZDA = NZDA + 1
          ENDDO
          IF (NDIG-NZDA < 50 .OR. REAL(NZDA)/NDIG > 0.8) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMMPY2(MA,MA,MB)
          GO TO 130
      ENDIF

      MAXMAX = 0
      MACCA = MWK(START(MA)+1)
      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MA)+2)

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 2
          ELSE IF (MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,NDIG+2)
          ENDIF
      ENDIF
      IF (MWK(START(MA)+3)*MWK(START(MA)+3) < MBASE .AND. NGUARD < 3) NGUARD = 3

      L = N1 + NGUARD
      MWK(START(MWA)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBM1 = MBASE - 1
      MBNORM = (MAXINT/(MBM1*MBM1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBM1 - MBM1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MA)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = NDIG, 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 120
                 ENDIF
              ENDDO
          ENDIF

  120     MWK(START(MWA)+3) = 0
          MWK(START(MWA)+4) = 0
          DO K = NDIG+2, L
             MWK(START(MWA)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          DO K = 3, N1
             MWK(JMWA+K) = MWK(JMA+K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, MIN(L/2,N1)
             MBJ = MWK(START(MA)+J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 JMA = START(MA) + 1 - JM1
                 JMWA = START(MWA) + 1
                 DO K = 2*J, JM1+KL
                    MWK(JMWA+K) = MWK(JMWA+K) + MWK(JMA+K)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMAX = MAX(MAXMAX,MAXMWA)
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, 2*J, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Double MWA, add the square terms, and perform the final normalization.  (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1
          IF (2*MAX(MAXMAX,MAXMWA)+MBASE > MMAX) THEN
              DO KB = L, 4, -1
                 MKT = INT (MWK(JMWA+KB)/MBASE)
                 MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
                 MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
              ENDDO
          ENDIF

          DO J = 3, L-1, 2
             IF ((J+1)/2 <= N1) THEN
                 MKA = MWK(JMA+(J+1)/2)
                 MWK(JMWA+J) = 2*MWK(JMWA+J) + MKA*MKA
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ELSE
                 MWK(JMWA+J) = 2*MWK(JMWA+J)
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ENDIF
          ENDDO
          IF (MOD(L,2) == 1) THEN
              IF ((L+1)/2 <= N1) THEN
                  MKA = MWK(JMA+(L+1)/2)
                  MWK(JMWA+L) = 2*MWK(JMWA+L) + MKA*MKA
              ELSE
                  MWK(JMWA+L) = 2*MWK(JMWA+L)
              ENDIF
          ENDIF

          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MA)+KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MK
                MK = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MK
             ENDDO
             MWK(START(MWA)+KWA-KL) = MK
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWK(START(MWA)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplication is complete.  Round the result and move it to MB.

      JRSIGN = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MB)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMSQR'
          CALL FMWARN
      ENDIF

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MB)+3))+1))/0.69315)
          MWK(START(MB)+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MB)+1) = MACCA
      ENDIF
  130 MWK(START(MB)) = 1
      KSQR = 0
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQR2

      SUBROUTINE FMSQR_R1(MA)

!  MA = MA*MA    Faster than using FMMPY.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMSQR_R1'
          CALL FMNTR(2,MA,MA,1,1)

          CALL FMSQR2_R1(MA)

          NAMEST(NCALL) = 'FMSQR_R1'
          CALL FMNTR(1,MA,MA,1,1)
      ELSE
          CALL FMSQR2_R1(MA)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQR_R1

      SUBROUTINE FMSQR2_R1(MA)

!  MA = MA*MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA

      REAL (KIND(1.0D0)) :: MACCA,MAXMAX,MAXMWA,MBJ,MBKJ,MBM1,MBNORM,MD2B,MK,MKA,MKT,MMAX,MR,MT
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JM1,JMA,JMWA,JRSSAV,K,KB,KI,KJ,KL,KNZ,KOVUN,KR_RETRY,KSHIFT,KWA,L,N1,NGUARD,  &
                 NMETHD,NZDA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      KSQR = 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      KR_RETRY = 0
      JRSSAV = JRSIGN
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. KDEBUG == 1 .OR. MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL FMMPY2(MA,MA,MXY(1))
          CALL FMEQ(MXY(1),MA)
          NCALL = NCALL - 1
          IF ((KFLAG < 0 .AND. KOVUN == 0) .OR. (KFLAG == -4 .AND. KOVUN == 1)) THEN
              NAMEST(NCALL) = 'FMSQR_R1'
              CALL FMWARN
          ENDIF
          GO TO 130
      ELSE IF (MWK(START(MA)+3) == 0) THEN
          GO TO 130
      ENDIF
      KFLAG = 0

!             Check for using an FFT-based method if precision is very high.

      IF (NDIG >= 2200) THEN
          NZDA = 0
          DO J = 2, NDIG
             IF (MWK(START(MA)+J+2) == 0) NZDA = NZDA + 1
          ENDDO
          IF (NDIG-NZDA < 50 .OR. REAL(NZDA)/NDIG > 0.8) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL FMMPY2(MA,MA,MXY(1))
          CALL FMEQ(MXY(1),MA)
          GO TO 130
      ENDIF

      MAXMAX = 0
      MACCA = MWK(START(MA)+1)
      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MA)+2)

!             NGUARD is the number of guard digits used.

  110 IF (NCALL > 1) THEN
          NGUARD = NGRD22
          IF (NGUARD > NDIG) NGUARD = NDIG
      ELSE
          NGUARD = NGRD52
          IF (NGUARD > NDIG) NGUARD = NDIG
          IF (KR_RETRY >= 1) THEN
              NGUARD = NDIG + 2
          ELSE IF (MBASE < 10**6) THEN
              NGUARD = MIN(NGUARD+1,NDIG+2)
          ENDIF
      ENDIF
      IF (MWK(START(MA)+3)*MWK(START(MA)+3) < MBASE .AND. NGUARD < 3) NGUARD = 3

      L = N1 + NGUARD
      MWK(START(MWA)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBM1 = MBASE - 1
      MBNORM = (MAXINT/(MBM1*MBM1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBM1 - MBM1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MA)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = NDIG, 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 120
                 ENDIF
              ENDDO
          ENDIF

  120     MWK(START(MWA)+3) = 0
          MWK(START(MWA)+4) = 0
          DO K = NDIG+2, L
             MWK(START(MWA)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          DO K = 3, N1
             MWK(JMWA+K) = MWK(JMA+K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, MIN(L/2,N1)
             MBJ = MWK(START(MA)+J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 JMA = START(MA) + 1 - JM1
                 JMWA = START(MWA) + 1
                 DO K = 2*J, JM1+KL
                    MWK(JMWA+K) = MWK(JMWA+K) + MWK(JMA+K)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMAX = MAX(MAXMAX,MAXMWA)
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, 2*J, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Double MWA, add the square terms, and perform the final normalization.  (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1
          IF (2*MAX(MAXMAX,MAXMWA)+MBASE > MMAX) THEN
              DO KB = L, 4, -1
                 MKT = INT (MWK(JMWA+KB)/MBASE)
                 MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
                 MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
              ENDDO
          ENDIF

          DO J = 3, L-1, 2
             IF ((J+1)/2 <= N1) THEN
                 MKA = MWK(JMA+(J+1)/2)
                 MWK(JMWA+J) = 2*MWK(JMWA+J) + MKA*MKA
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ELSE
                 MWK(JMWA+J) = 2*MWK(JMWA+J)
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ENDIF
          ENDDO
          IF (MOD(L,2) == 1) THEN
              IF ((L+1)/2 <= N1) THEN
                  MKA = MWK(JMA+(L+1)/2)
                  MWK(JMWA+L) = 2*MWK(JMWA+L) + MKA*MKA
              ELSE
                  MWK(JMWA+L) = 2*MWK(JMWA+L)
              ENDIF
          ENDIF

          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize
!             as the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MA)+KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MK
                MK = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MK
             ENDDO
             MWK(START(MWA)+KWA-KL) = MK
          ENDDO

      ENDIF

!             Set KSHIFT = 1 if a shift left is necessary.

      IF (MWK(START(MWA)+3) == 0) THEN
          KSHIFT = 1
      ELSE
          KSHIFT = 0
      ENDIF

!             The multiplication is complete.  Round the result and move it to MA.

      JRSIGN = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NGUARD,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MWA)+J+KSHIFT+NDIG+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NGUARD < NDIG+2) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MR = 2*MWK(START(MWA)+KSHIFT+NDIG+3) + 1
      IF (KROUND == -1 .OR. KROUND == 2) THEN
          CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
      ELSE IF (MR >= MBASE) THEN
          IF (MR-1 > MBASE .AND. MWK(START(MWA)+KSHIFT+N1+1) < MBASE-1) THEN
              IF (KROUND /= 0) THEN
                  MWK(START(MWA)+KSHIFT+N1+1) = MWK(START(MWA)+KSHIFT+N1+1) + 1
                  MWK(START(MWA)+KSHIFT+N1+2) = 0
              ENDIF
          ELSE
              CALL FMRND(MWA,NDIG,NGUARD,KSHIFT)
          ENDIF
      ENDIF
      CALL FMMOVE(MWA,MA)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'FMSQR_R1'
          CALL FMWARN
      ENDIF

      IF (KACCSW == 1) THEN
          MD2B = NINT((NDIG-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MA)+3))+1))/0.69315)
          MWK(START(MA)+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MA)+1) = MACCA
      ENDIF
  130 MWK(START(MA)) = 1
      KSQR = 0
      JRSIGN = JRSSAV
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQR2_R1

      SUBROUTINE FMSQRT(MA,MB)

!  MB = SQRT(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,XB
      REAL (KIND(1.0D0)) :: MA1,MACCA,MD2B,MKE,MXSAVE
      INTEGER :: NSTACK(49),J,K,KASAVE,KL,KMA1,KOVUN,KRESLT,KST,KR_RETRY,NDSAVE,NMETHD
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) < 0) THEN
          CALL FMENTR2('FMSQRT   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'FMSQRT'
              CALL FMNTR(2,MA,MA,1,1)
          ENDIF
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0
  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF

      MA1 = MWK(START(MA)+2)

      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

      NMETHD = 1
      IF (NDSAVE > 300) NMETHD = 2
      IF (NDSAVE > 10000) NMETHD = 3
      IF (NMETHD == 2) GO TO 120
      IF (NMETHD == 3) GO TO 130

!             Method 1.  Ordinary Newton iteration.

!             Generate the first approximation.

      MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMDIV(MXY(2),MXY(3),MXY(1))
         CALL FMADD_R1(MXY(3),MXY(1))
         CALL FMDIVI_R1(MXY(3),2)
      ENDDO

      GO TO 140

!             Method 2.  Modified Newton iteration.
!                        x2 = x1 - (x1^2 - a) / (2*x1)
!                        where the square is done at full current precision,
!                        and the division is done at half current precision.

!             Generate the first approximation.

  120 MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1))
      CALL FMI2M(0,MXY(4))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(1))
         CALL FMSUB_R1(MXY(1),MXY(2))
         IF (J > 1) NDIG = NSTACK(J-1)
         CALL FMADD(MXY(3),MXY(3),MXY(4))
         CALL FMDIV_R2(MXY(1),MXY(4))
         NDIG = NSTACK(J)
         CALL FMSUB_R1(MXY(3),MXY(4))
      ENDDO

      GO TO 140

!             Method 3.  Karp's method.  Newton iteration for 1/sqrt(a)
!                        x2 = x1 + (1 - a*x1**2)*x1/2
!                        where a*x1**2 is done at full current precision,
!                        and *x1/2 is done at half current precision.

!             Generate the first approximation to 1/sqrt(a).

  130 MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = 1.0D0/SQRT(X)
      MKE = -MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = -(MA1+1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(1,MXY(1))
      CALL FMI2M(0,MXY(4))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration for 1/sqrt(a).

      DO J = 1, KST-1
         NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(4))
         CALL FMMPY_R2(MXY(2),MXY(4))
         CALL FMSUB_R2(MXY(1),MXY(4))
         IF (J > 1) NDIG = NSTACK(J-1)
         CALL FMMPY_R2(MXY(3),MXY(4))
         CALL FMDIVI_R1(MXY(4),2)
         NDIG = NSTACK(J)
         CALL FMADD_R1(MXY(3),MXY(4))
      ENDDO

!             Karp's method for speeding up the last iteration and getting sqrt(a).
!             For the last iteration, combine a*x1 to get
!             a*x1 + x1*(a - (a*x1)**2)/2
!             where only the square, -, and + need full precision.

      NDIG = NSTACK(KST)
      IF (KST > 1) NDIG = NSTACK(KST-1)
      CALL FMMPY(MXY(2),MXY(3),MXY(4))
      NDIG = NSTACK(KST)
      CALL FMSQR(MXY(4),MXY(1))
      CALL FMSUB_R2(MXY(2),MXY(1))
      IF (KST > 1) NDIG = NSTACK(KST-1)
      CALL FMMPY_R2(MXY(3),MXY(1))
      CALL FMDIVI_R1(MXY(1),2)
      NDIG = NSTACK(KST)
      CALL FMADD(MXY(4),MXY(1),MXY(3))

!             Round the result and return.

  140 IF (KASAVE == 1) THEN
          MD2B = NINT((NDSAVE-1)*ALOGM2+LOG(REAL(ABS(MWK(START(MXY(3))+3))+1))/0.69315)
          MWK(START(MXY(3))+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MXY(3))+1) = MACCA
      ENDIF
      MWK(START(MXY(3))) = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(3),MB,NDSAVE,MXSAVE,KASAVE,0)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQRT

      SUBROUTINE FMSQRT_R1(MA)

!  MA = SQRT(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      DOUBLE PRECISION :: ERR,X,XB
      REAL (KIND(1.0D0)) :: MA1,MACCA,MD2B,MKE,MXSAVE
      INTEGER :: NSTACK(49),J,K,KASAVE,KL,KMA1,KOVUN,KRESLT,KR_RETRY,KST,NDSAVE,NMETHD
      INTENT (INOUT) :: MA
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) < 0) THEN
          CALL FMENTR2('FMSQRT_R1',MA,MA,1,1,MXY(3),KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              CALL FMEQ(MXY(3),MA)
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MA) == -1) TEMPV(MA) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'FMSQRT_R1'
              CALL FMNTR(2,MA,MA,1,1)
          ENDIF
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF
      KR_RETRY = 0
  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF

      MA1 = MWK(START(MA)+2)

      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

      NMETHD = 1
      IF (NDSAVE > 300) NMETHD = 2
      IF (NDSAVE > 10000) NMETHD = 3
      IF (NMETHD == 2) GO TO 120
      IF (NMETHD == 3) GO TO 130

!             Method 1.  Ordinary Newton iteration.

!             Generate the first approximation.

      MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMDIV(MXY(2),MXY(3),MXY(1))
         CALL FMADD_R1(MXY(3),MXY(1))
         CALL FMDIVI_R1(MXY(3),2)
      ENDDO

      GO TO 140

!             Method 2.  Modified Newton iteration.
!                        x2 = x1 - (x1^2 - a) / (2*x1)
!                        where the square is done at full current precision,
!                        and the division is done at half current precision.

!             Generate the first approximation.

  120 MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = SQRT(X)
      MKE = MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = (MA1-1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(0,MXY(1))
      CALL FMI2M(0,MXY(4))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(1))
         CALL FMSUB_R1(MXY(1),MXY(2))
         IF (J > 1) NDIG = NSTACK(J-1)
         CALL FMADD(MXY(3),MXY(3),MXY(4))
         CALL FMDIV_R2(MXY(1),MXY(4))
         NDIG = NSTACK(J)
         CALL FMSUB_R1(MXY(3),MXY(4))
      ENDDO

      GO TO 140

!             Method 3.  Karp's method.  Newton iteration for 1/sqrt(a)
!                        x2 = x1 + (1 - a*x1**2)*x1/2
!                        where a*x1**2 is done at full current precision,
!                        and *x1/2 is done at half current precision.

!             Generate the first approximation to 1/sqrt(a).

  130 MWK(START(MXY(2))+2) = 0
      CALL FMM2DP(MXY(2),X)
      X = 1.0D0/SQRT(X)
      MKE = -MA1/2
      KMA1 = INT(ABS(MA1))
      IF (MOD(KMA1,2) == 1) THEN
          XB = MBASE
          X = X*SQRT(XB)
          MKE = -(MA1+1)/2
      ENDIF
      CALL FMDPM(X,MXY(3))
      MWK(START(MXY(3))+2) = MWK(START(MXY(3))+2) + MKE

!             Initialize.

      CALL FMI2M(1,MXY(1))
      CALL FMI2M(0,MXY(4))
      MWK(START(MXY(2))+2) = MA1
      CALL FMDIG(NSTACK,KST)

!             Newton iteration for 1/sqrt(a).

      DO J = 1, KST-1
         NDIG = NSTACK(J)
         CALL FMSQR(MXY(3),MXY(4))
         CALL FMMPY_R2(MXY(2),MXY(4))
         CALL FMSUB_R2(MXY(1),MXY(4))
         IF (J > 1) NDIG = NSTACK(J-1)
         CALL FMMPY_R2(MXY(3),MXY(4))
         CALL FMDIVI_R1(MXY(4),2)
         NDIG = NSTACK(J)
         CALL FMADD_R1(MXY(3),MXY(4))
      ENDDO

!             Karp's method for speeding up the last iteration and getting sqrt(a).
!             For the last iteration, combine a*x1 to get
!             a*x1 + x1*(a - (a*x1)**2)/2
!             where only the square, -, and + need full precision.

      NDIG = NSTACK(KST)
      IF (KST > 1) NDIG = NSTACK(KST-1)
      CALL FMMPY(MXY(2),MXY(3),MXY(4))
      NDIG = NSTACK(KST)
      CALL FMSQR(MXY(4),MXY(1))
      CALL FMSUB_R2(MXY(2),MXY(1))
      IF (KST > 1) NDIG = NSTACK(KST-1)
      CALL FMMPY_R2(MXY(3),MXY(1))
      CALL FMDIVI_R1(MXY(1),2)
      NDIG = NSTACK(KST)
      CALL FMADD(MXY(4),MXY(1),MXY(3))

!             Round the result and return.

  140 IF (KASAVE == 1) THEN
          MD2B = NINT((NDSAVE-1)*ALOGM2+LOG(REAL(ABS(MWK(START(MXY(3))+3))+1))/0.69315)
          MWK(START(MXY(3))+1) = MIN(MACCA,MD2B)
      ELSE
          MWK(START(MXY(3))+1) = MACCA
      ENDIF
      MWK(START(MXY(3))) = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(3),MA,NDSAVE,MXSAVE,KASAVE,0)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSQRT_R1

      SUBROUTINE FMST2D(STRING,X)

!  STRING contains a free-format number that is converted to double precision and returned in X.

!  The input number may be in integer or any real format. The convention is made that if no digits
!  appear before 'E' then 1.0 is assumed.  For example 'E6' is converted as '1.0E+6'.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      INTEGER :: J,JSTATE,KDIGFL,KEXP,KPT,KSIGN,KSIGNX,KSTART,KSTOP,KTYPE,KVAL,N2
      DOUBLE PRECISION :: X,F1,F2

      INTEGER :: JTRANS(8,4) = RESHAPE(  (/    &
                   2, 9, 7, 7, 7, 7, 9, 9,  &
                   3, 3, 3, 5, 5, 8, 8, 8,  &
                   4, 4, 4, 9, 9, 9, 9, 9,  &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8,4 /) )

      CHARACTER :: KBLANK = ' '
      INTENT (IN) :: STRING
      INTENT (INOUT) :: X

      JSTATE = 1
      KSIGN = 1
      F1 = 0.0D0
      F2 = 0.0D0
      N2 = 0
      KSIGNX = 1
      KEXP = 0
      KSTART = 1
      KSTOP = LEN(STRING)
      KFLAG = 0

!             KDIGFL will be 1 if any digits are found before 'E'.

      KDIGFL = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (LHASH == 0) CALL FMHTBL

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (STRING(J:J) == KBLANK) CYCLE
         KPT = ICHAR(STRING(J:J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,  &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) STRING(J:J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = KHASHT(KPT)
             KVAL  = KHASHV(KPT)
         ENDIF
         IF (KTYPE >= 5) GO TO 110

         JSTATE = JTRANS(JSTATE,KTYPE)

         SELECT CASE (JSTATE)

!             State 2.  Sign of the number.

         CASE (2)
             KSIGN = KVAL

!             State 3.  Digits before a decimal point.

         CASE (3)
             KDIGFL = 1
             F1 = 10.0D0*F1 + KVAL

!             State 4.  Decimal point

         CASE (4)
             CYCLE

!             State 5.  Digits after a decimal point.

         CASE (5)
             KDIGFL = 1
             F2 = 10.0D0*F2 + KVAL
             N2 = N2 + 1

!             State 6.  Precision indicator.

         CASE (6)
             IF (KDIGFL == 0) F1 = 1.0D0

!             State 7.  Sign of the exponent.

         CASE (7)
             KSIGNX = KVAL

!             State 8.  Digits of the exponent.

         CASE (8)
             KEXP = 10*KEXP + KVAL

         CASE DEFAULT
             GO TO 110

         END SELECT

      ENDDO

!             Form the number and return.

      KEXP = KSIGNX*KEXP
      X = KSIGN*(F1 + F2/10.0D0**N2)*10.0D0**KEXP

      RETURN

!             Error in converting the number.

  110 X = -1.0D+31
      KFLAG = -4
      RETURN
      END SUBROUTINE FMST2D

      SUBROUTINE FMST2M(STRING,MA)

!  MA = STRING

!  Convert a character string to FM format.
!  This is often more convenient than using FMINP, which converts an array of character(1) values.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      INTEGER :: MA

      INTEGER :: J,LB,KFSAVE
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMST2M'
      LB = LEN(STRING)
      IF (LB > LMBUFF) THEN
          IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
          ALLOCATE(CMBUFF(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFF = LB
      ENDIF
      KFSAVE = KFLAG

      DO J = 1, LB
         CMBUFF(J) = STRING(J:J)
      ENDDO
      NCALL = NCALL - 1
      CALL FMINP(CMBUFF,MA,1,LB)
      NCALL = NCALL + 1

      IF (KFSAVE /= 0) KFLAG = KFSAVE
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMST2M

      SUBROUTINE FMSUB(MA,MB,MC)

!  MC = MA - MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KFLG1
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF

      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMSUB'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0

!             FMADD2 will negate MB and add.

          KSUB = 1
          CALL FMADD2(MA,MB,MC)
          KSUB = 0

!             If MA was smaller than MB, then KFLAG = 1 returned from FMADD means the result from
!             FMSUB is the opposite of the input argument of larger magnitude, so reset KFLAG.

          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0

          IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      ELSE
          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0
          KSUB = 1
          CALL FMADD2(MA,MB,MC)
          KSUB = 0
          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSUB

      SUBROUTINE FMSUB_R1(MA,MB)

!  MA = MA - MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: KFLG1
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMSUB_R1'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0

!             FMADD2 will negate MB and add.

          KSUB = 1
          CALL FMADD2_R1(MA,MB)
          KSUB = 0

!             If MA was smaller than MB, then KFLAG = 1 returned from FMADD means the result from
!             FMSUB is the opposite of the input argument of larger magnitude, so reset KFLAG.

          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0

          IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      ELSE
          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0
          KSUB = 1
          CALL FMADD2_R1(MA,MB)
          KSUB = 0
          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSUB_R1

      SUBROUTINE FMSUB_R2(MA,MB)

!  MB = MA - MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: KFLG1

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'FMSUB_R2'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,2,1)

          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0

!             FMADD2 will negate MB and add.

          KSUB = 1
          CALL FMADD2_R2(MA,MB)
          KSUB = 0

!             If MA was smaller than MB, then KFLAG = 1 returned from FMADD means the result from
!             FMSUB is the opposite of the input argument of larger magnitude, so reset KFLAG.

          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0

          IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
      ELSE
          KFLG1 = 0
          IF (MWK(START(MB)+2) > MWK(START(MA)+2) .OR. MWK(START(MA)+3) == 0) KFLG1 = 1
          IF (MWK(START(MB)+3) == 0) KFLG1 = 0
          KSUB = 1
          CALL FMADD2_R2(MA,MB)
          KSUB = 0
          IF (KFLAG == 1 .AND. KFLG1 == 1) KFLAG = 0
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSUB_R2

      SUBROUTINE FMTAN(MA,MB)

!  MB = TAN(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JCOS,JSIN,JSWAP,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NDSV,NTRY
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      KR_RETRY = 0

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. KRAD == 1) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTAN'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),3,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. KROUND == -1) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE IF (MWK(START(MA)) >= 0 .AND. KROUND == 2) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMADD(MXY(1),MXY(2),MB)
              MWK(START(MB)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTAN'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMENTR('FMTAN    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMTAN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52-1,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

      MACCA = MWK(START(MA)+1)
      MAS = MWK(START(MA))
      NTRY = 1
      IF (MWK(START(MA)+2) > 3*10**5 .AND. KRAD == 1) THEN
          KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(5))
          GO TO 130
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
  120 CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(5))) = 1

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      CALL FMRDC(MXY(5),JSIN,JCOS,JSWAP)
      IF (KROUND /= 1 .AND. KRAD /= 1) THEN
          CALL FMI2M(45,MXY(1))
          CALL FMSUB(MXY(5),MXY(1),MXY(2))
          IF (MWK(START(MXY(2))+3) == 0) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMMPYI(MXY(1),JSIN/JCOS,MXY(5))
              GO TO 130
          ENDIF
      ENDIF
      IF (MWK(START(MXY(5))+2) == MUNKNO) GO TO 130
      IF (MWK(START(MXY(5))+3) == 0) THEN
          IF (JSWAP == 1) THEN
              KFLAG = -4
              CALL FMWARN
              CALL FMST2M('UNKNOWN',MXY(5))
          ENDIF
          GO TO 130
      ENDIF
      IF (KRAD == 0) THEN
          IF (MBSPI /= MBASE .OR. NDIGPI < NDIG)  THEN
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(4))
              NDIG = NDSV
          ENDIF
          CALL FMMPY_R1(MXY(5),MPISAV)
          CALL FMDIVI_R1(MXY(5),180)
      ENDIF
      IF (MWK(START(MXY(5))+2) /= MUNKNO) THEN
          IF (JSWAP == 0) THEN
              IF (MWK(START(MXY(5))+2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(4))
                  MWK(START(MXY(4))) = JSIN*MWK(START(MXY(4)))
                  CALL FMSQR(MXY(4),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  IF (MWK(START(MXY(2))+2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      NDIG = NDIG - MWK(START(MXY(2))+2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3))
                  MWK(START(MXY(3))) = JCOS*MWK(START(MXY(3)))
                  CALL FMDIV(MXY(4),MXY(3),MXY(5))
              ELSE
                  CALL FMCOS2(MXY(5),MXY(4))
                  MWK(START(MXY(4))) = JCOS*MWK(START(MXY(4)))
                  CALL FMSQR(MXY(4),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  IF (MWK(START(MXY(2))+2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      NDIG = NDIG - MWK(START(MXY(2))+2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3))
                  MWK(START(MXY(3))) = JSIN*MWK(START(MXY(3)))
                  CALL FMDIV(MXY(3),MXY(4),MXY(5))
              ENDIF
          ELSE
              IF (MWK(START(MXY(5))+2) < 0) THEN
                  CALL FMSIN2(MXY(5),MXY(4))
                  MWK(START(MXY(4))) = JCOS*MWK(START(MXY(4)))
                  CALL FMSQR(MXY(4),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  IF (MWK(START(MXY(2))+2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      NDIG = NDIG - MWK(START(MXY(2))+2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3))
                  MWK(START(MXY(3))) = JSIN*MWK(START(MXY(3)))
                  CALL FMDIV(MXY(3),MXY(4),MXY(5))
              ELSE
                  CALL FMCOS2(MXY(5),MXY(4))
                  MWK(START(MXY(4))) = JSIN*MWK(START(MXY(4)))
                  CALL FMSQR(MXY(4),MXY(2))
                  CALL FMI2M(1,MXY(1))
                  CALL FMSUB_R2(MXY(1),MXY(2))
                  IF (MWK(START(MXY(2))+2) < 0 .AND. NTRY == 1) THEN
                      NTRY = 2
                      NDIG = NDIG - MWK(START(MXY(2))+2)
                      GO TO 120
                  ENDIF
                  CALL FMSQRT(MXY(2),MXY(3))
                  MWK(START(MXY(3))) = JCOS*MWK(START(MXY(3)))
                  CALL FMDIV(MXY(4),MXY(3),MXY(5))
              ENDIF
          ENDIF
      ENDIF

!             Round and return.

  130 MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND. MWK(START(MXY(5))+3) /= 0)  &
          MWK(START(MXY(5))) = -MWK(START(MXY(5)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMTAN

      SUBROUTINE FMTANH(MA,MB)

!  MB = TANH(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE
      LOGICAL :: LCOMP
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: X,XT
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      KR_RETRY = 0

      IF (MBLOGS /= MBASE) CALL FMCONS

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(2))
          CALL FMDIVI(MXY(2),-3,MXY(3))
          IF (MWK(START(MXY(3))+2) > MEXPUN) THEN
              CALL FMADD(MA,MXY(3),MB)
          ELSE IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMEQ(MA,MB)
          ELSE IF (MWK(START(MA)) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE IF (MWK(START(MA)) >= 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
              CALL FMEQ(MA,MXY(1))
              MWK(START(MXY(1))+2) = 0
              CALL FMULP(MXY(1),MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
              MWK(START(MXY(3))+2) = MWK(START(MA)+2) + MWK(START(MXY(3))+2)
              CALL FMEQ(MXY(3),MB)
          ELSE
              CALL FMEQ(MA,MB)
          ENDIF
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              KFLAG = -4
              CALL FMWARN
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
              CALL FMWARN
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      J = NTRACE
      NTRACE = 0
      CALL FMABS(MA,MXY(1))
      CALL FMDP2M(DLOGMB*NDIG,MXY(2))
      LCOMP = FMCOMP(MXY(1),'>',MXY(2))
      NTRACE = J
      IF (KROUND /= 1 .AND. LCOMP .AND. MWK(START(MA)+2) /= MUNKNO) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          IF (MWK(START(MA)) < 0 .AND. (KROUND == 0 .OR. KROUND == 2)) THEN
              CALL FMI2M(-1,MXY(1))
              CALL FMTINY(MXY(2))
              CALL FMADD(MXY(1),MXY(2),MXY(3))
          ELSE IF (MWK(START(MA)) > 0 .AND. (KROUND == 0 .OR. KROUND == -1)) THEN
              CALL FMI2M(1,MXY(1))
              CALL FMTINY(MXY(2))
              CALL FMSUB(MXY(1),MXY(2),MXY(3))
          ELSE IF (MWK(START(MA)) < 0) THEN
              CALL FMI2M(-1,MXY(3))
          ELSE
              CALL FMI2M(1,MXY(3))
          ENDIF
          CALL FMEQ(MXY(3),MB)
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMTANH'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMENTR('FMTANH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMTANH'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = MAX(NGRD52,2)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

      KWRNSV = KWARN
      KWARN = 0
      MAS = MWK(START(MA))

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      MACCA = MWK(START(MA)+1)
      CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      IF (MWK(START(MA)+3) == 0) THEN
          GO TO 120
      ENDIF
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(5))) = 1

      IF (MWK(START(MA)+2) >= 1) THEN
          XT = REAL((NDIG+1)/2)*ALOGMB
          K = INT(LOG(XT)/ALOGMB)
          IF (MWK(START(MA)+2) > K+1) THEN
              CALL FMI2M(1,MXY(5))
              GO TO 120
          ELSE
              X = REAL(MWK(START(MXY(5))+3)*MBASE+MWK(START(MXY(5))+4))*  &
                  REAL(MBASE)**INT(MWK(START(MXY(5))+2)-2)
              IF (X > XT+5.0) THEN
                  CALL FMI2M(1,MXY(5))
                  GO TO 120
              ENDIF
          ENDIF
      ENDIF
      IF (MWK(START(MXY(5))+2) == 0 .AND. NDIG < 50) THEN
          CALL FMEXP2(MXY(5),MXY(3))
          CALL FMSQR_R1(MXY(3))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB(MXY(3),MXY(1),MXY(2))
          CALL FMADD_R2(MXY(3),MXY(1))
          CALL FMDIV(MXY(2),MXY(1),MXY(5))
          GO TO 120
      ENDIF
      IF (MWK(START(MXY(5))+2) >= 0 .AND. MWK(START(MXY(5))+3) /= 0) THEN
          CALL FMCOSH(MXY(5),MXY(4))
          IF (MWK(START(MXY(4))+2) > NDIG) THEN
              IF (MAS > 0) THEN
                  CALL FMI2M(1,MXY(5))
                  GO TO 120
              ELSE
                  CALL FMI2M(-1,MXY(5))
                  GO TO 120
              ENDIF
          ENDIF
          CALL FMSQR(MXY(4),MXY(2))
          CALL FMI2M(-1,MXY(1))
          CALL FMADD_R1(MXY(2),MXY(1))
          CALL FMSQRT_R1(MXY(2))
          CALL FMDIV(MXY(2),MXY(4),MXY(5))
      ELSE
          CALL FMSINH(MXY(5),MXY(4))
          CALL FMSQR(MXY(4),MXY(2))
          CALL FMI2M(1,MXY(1))
          CALL FMADD_R1(MXY(2),MXY(1))
          CALL FMSQRT_R1(MXY(2))
          CALL FMDIV(MXY(4),MXY(2),MXY(5))
      ENDIF

!             Round and return.

  120 KWARN = KWRNSV
      MACMAX = NINT((NDSAVE-1)*ALOGM2 + LOG(REAL(ABS(MWK(START(MXY(5))+3))+1))/0.69315)
      MWK(START(MXY(5))+1) = MIN(MWK(START(MXY(5))+1),MACCA,MACMAX)
      IF (MAS < 0 .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND. MWK(START(MXY(5))+3) /= 0)  &
          MWK(START(MXY(5))) = -MWK(START(MXY(5)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(5))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXIT(MXY(5),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMTANH

      SUBROUTINE FMTINY(MA)

!     MA = The smallest positive representable FM number using the current base and precision.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTEGER :: J,N1

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMTINY'

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      N1 = NDIG + 1
      DO J = 3, N1
         MWK(START(MA)+J+1) = 0
      ENDDO
      MWK(START(MA)+2) = -MXEXP
      MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
      MWK(START(MA)) = 1
      MWK(START(MA)+3) = 1

      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMTINY

      SUBROUTINE FMTRAP(MA)

!  If MA has overflowed or underflowed, replace it by the appropriate symbol.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTENT (INOUT) :: MA

      IF (NCALL <= 0) RETURN
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MWK(START(MA)+2) > MXEXP+1) THEN
          IF (MWK(START(MA)) > 0) THEN
              CALL FMIM(0,MA)
              MWK(START(MA)+2) = MEXPOV
              MWK(START(MA)+3) = 1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          ELSE
              CALL FMIM(0,MA)
              MWK(START(MA)+2) = MEXPOV
              MWK(START(MA)+3) = 1
              MWK(START(MA)) = -1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          ENDIF
          KFLAG = -5
      ENDIF
      IF (MWK(START(MA)+2) < -MXEXP) THEN
          IF (MWK(START(MA)) > 0) THEN
              CALL FMIM(0,MA)
              MWK(START(MA)+2) = MEXPUN
              MWK(START(MA)+3) = 1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          ELSE
              CALL FMIM(0,MA)
              MWK(START(MA)+2) = MEXPUN
              MWK(START(MA)+3) = 1
              MWK(START(MA)) = -1
              MWK(START(MA)+1) = NINT(NDIG*ALOGM2)
          ENDIF
          KFLAG = -6
      ENDIF

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMTRAP

      SUBROUTINE FMULP(MA,MB)

!  MB = The value of one Unit in the Last Place of MA at the current base and precision.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MA1
      INTEGER :: J,KWRNSV,N1
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MWA <= 0) THEN
          CALL FMDEFINE(MWA)
      ELSE IF (SIZE_OF(MWA) < 2*NDIG+30) THEN
          CALL FMDEFINE(MWA)
      ENDIF

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMULP'
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,1)

      MA1 = MWK(START(MA)+2)
      N1 = NDIG + 1
      DO J = 3, N1
         MWK(START(MWA)+J+1) = 0
      ENDDO
      MWK(START(MWA)+3) = 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) - NDIG + 1
      IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MA)+2) >= MEXPOV) THEN
          KFLAG = -4
          IF (MA1 /= MUNKNO) CALL FMWARN
          CALL FMST2M('UNKNOWN',MB)
      ELSE
          KWRNSV = KWARN
          IF (MA1 == MEXPUN) KWARN = 0
          IF (MWK(START(MA)) < 0) THEN
              CALL FMMOVE(MWA,MB)
              MWK(START(MB)) = 1
              IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0) MWK(START(MB)) = -1
          ELSE
              CALL FMMOVE(MWA,MB)
              MWK(START(MB)) = 1
          ENDIF
          IF (KFLAG < 0) THEN
              NAMEST(NCALL) = 'FMULP'
              CALL FMWARN
          ENDIF
          KWARN = KWRNSV
      ENDIF
      MWK(START(MB)+1) = NINT(NDIG*ALOGM2)

      IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMULP

      SUBROUTINE FMUNPK(MP,MA)

!  MP is unpacked and the value returned in MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP
      INTENT (IN) :: MP
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF

      KP = 2
      MWK(START(MA)) = MWK(START(MP))
      MWK(START(MA)+1) = MWK(START(MP)+1)
      MWK(START(MA)+2) = MWK(START(MP)+2)
      MWK(START(MA)+3) = AINT (ABS(MWK(START(MP)+3))/MBASE)
      MWK(START(MA)+4) = ABS(MWK(START(MP)+3)) - MWK(START(MA)+3)*MBASE
      IF (NDIG >= 4) THEN
          DO J = 4, NDIG, 2
             KP = KP + 1
             MWK(START(MA)+J+1) = AINT (MWK(START(MP)+KP+1)/MBASE)
             MWK(START(MA)+J+2) = MWK(START(MP)+KP+1) - MWK(START(MA)+J+1)*MBASE
          ENDDO
      ENDIF
      IF (MOD(NDIG,2) == 1) THEN
          MWK(START(MA)+NDIG+2) = AINT (MWK(START(MP)+KP+2)/MBASE)
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMUNPK

      SUBROUTINE FMVARS

!  Write the values of the FM global variables in module FMVALS.

      USE FMVALS
      IMPLICIT NONE

      WRITE (KW,*) ' '
      WRITE (KW,*) ' Current values of the FM global variables.'
      WRITE (KW,*) ' '
      WRITE (KW,*) ' ALOGM2 = ',ALOGM2
      WRITE (KW,*) ' ALOGMB = ',ALOGMB
      WRITE (KW,*) ' ALOGMT = ',ALOGMT
      WRITE (KW,*) ' ALOGMX = ',ALOGMX
      WRITE (KW,*) ' CMCHAR = ',CMCHAR
      WRITE (KW,*) ' DLOGEB = ',DLOGEB
      WRITE (KW,*) ' DLOGMB = ',DLOGMB
      WRITE (KW,*) ' DLOGPI = ',DLOGPI
      WRITE (KW,*) ' DLOGTN = ',DLOGTN
      WRITE (KW,*) ' DLOGTP = ',DLOGTP
      WRITE (KW,*) ' DLOGTW = ',DLOGTW
      WRITE (KW,*) ' DPEPS  = ',DPEPS
      WRITE (KW,*) ' DPMAX  = ',DPMAX
      WRITE (KW,*) ' DPPI   = ',DPPI
      WRITE (KW,*) ' INTMAX = ',INTMAX
      WRITE (KW,*) ' IUNKNO = ',IUNKNO
      WRITE (KW,*) ' JFORM1 = ',JFORM1
      WRITE (KW,*) ' JFORM2 = ',JFORM2
      WRITE (KW,*) ' JFORMZ = ',JFORMZ
      WRITE (KW,*) ' JPRNTZ = ',JPRNTZ
      WRITE (KW,*) ' KACCSW = ',KACCSW
      WRITE (KW,*) ' KDEBUG = ',KDEBUG
      WRITE (KW,*) ' KESWCH = ',KESWCH
      WRITE (KW,*) ' KFLAG  = ',KFLAG
      WRITE (KW,*) ' KRAD   = ',KRAD
      WRITE (KW,*) ' KROUND = ',KROUND
      WRITE (KW,*) ' KSUB   = ',KSUB
      WRITE (KW,*) ' KSWIDE = ',KSWIDE
      WRITE (KW,*) ' KW     = ',KW
      WRITE (KW,*) ' KWARN  = ',KWARN
      WRITE (KW,*) ' LHASH  = ',LHASH
      WRITE (KW,*) ' LHASH1 = ',LHASH1
      WRITE (KW,*) ' LHASH2 = ',LHASH2
      WRITE (KW,*) ' LJSUMS = ',LJSUMS
      WRITE (KW,*) ' LMBERN = ',LMBERN
      WRITE (KW,*) ' LMBUFF = ',LMBUFF
      WRITE (KW,*) ' LMBUFZ = ',LMBUFZ
      WRITE (KW,*) ' LVLTRC = ',LVLTRC
      WRITE (KW,*) ' MAXINT = ',MAXINT
      WRITE (KW,*) ' MBASE  = ',MBASE
      WRITE (KW,*) ' MBLOGS = ',MBLOGS
      WRITE (KW,*) ' MBS2PI = ',MBS2PI
      WRITE (KW,*) ' MBSBRN = ',MBSBRN
      WRITE (KW,*) ' MBSE   = ',MBSE
      WRITE (KW,*) ' MBSEUL = ',MBSEUL
      WRITE (KW,*) ' MBSGAM = ',MBSGAM
      WRITE (KW,*) ' MBSLB  = ',MBSLB
      WRITE (KW,*) ' MBSLI  = ',MBSLI
      WRITE (KW,*) ' MBSPI  = ',MBSPI
      WRITE (KW,*) ' MEXPAB = ',MEXPAB
      WRITE (KW,*) ' MEXPOV = ',MEXPOV
      WRITE (KW,*) ' MEXPUN = ',MEXPUN
      WRITE (KW,*) ' MUNKNO = ',MUNKNO
      WRITE (KW,*) ' MXBASE = ',MXBASE
      WRITE (KW,*) ' MXEXP  = ',MXEXP
      WRITE (KW,*) ' MXEXP2 = ',MXEXP2
      WRITE (KW,*) ' NCALL  = ',NCALL
      WRITE (KW,*) ' NDG2PI = ',NDG2PI
      WRITE (KW,*) ' NDGEUL = ',NDGEUL
      WRITE (KW,*) ' NDGGAM = ',NDGGAM
      WRITE (KW,*) ' NDIG   = ',NDIG
      WRITE (KW,*) ' NDIGE  = ',NDIGE
      WRITE (KW,*) ' NDIGLB = ',NDIGLB
      WRITE (KW,*) ' NDIGLI = ',NDIGLI
      WRITE (KW,*) ' NDIGPI = ',NDIGPI
      WRITE (KW,*) ' NGRD21 = ',NGRD21
      WRITE (KW,*) ' NGRD22 = ',NGRD22
      WRITE (KW,*) ' NGRD52 = ',NGRD52
      WRITE (KW,*) ' NTRACE = ',NTRACE
      WRITE (KW,*) ' NUMBRN = ',NUMBRN
      WRITE (KW,*) ' RUNKNO = ',RUNKNO
      WRITE (KW,*) ' SPMAX  = ',SPMAX
      WRITE (KW,*) ' '
      WRITE (KW,*) ' RADIX(1) = ',RADIX(1),'    DIGITS(1) = ',DIGITS(1)
      WRITE (KW,*) ' RADIX(1.0) = ',RADIX(1.0),'    DIGITS(1.0) = ',DIGITS(1.0)
      WRITE (KW,*) ' RADIX(1.0D0) = ',RADIX(1.0D0),'    DIGITS(1.0D0) = ',DIGITS(1.0D0)
      WRITE (KW,*) ' HUGE(1) = ',HUGE(1)
      WRITE (KW,*) ' HUGE(1.0) = ',HUGE(1.0),'    EPSILON(1.0) = ',EPSILON(1.0)
      WRITE (KW,*) ' HUGE(1.0D0) = ',HUGE(1.0D0),'    EPSILON(1.0D0) = ',EPSILON(1.0D0)
      WRITE (KW,*) ' '

      RETURN
      END SUBROUTINE FMVARS

      SUBROUTINE FMWARN

!  Called by one of the FM routines to print a warning message if any error condition arises
!  in that routine.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NAME
      INTEGER :: NCS

      IF (KFLAG >= 0 .OR. NCALL /= 1 .OR. KWARN <= 0) RETURN
      NCS = NCALL
      NAME = NAMEST(NCALL)
      WRITE (KW,  &
             "(/' Error of type KFLAG =',I3,"  //  &
             "' in FM package in routine ',A/)"   &
            ) KFLAG,TRIM(NAME)

  110 NCALL = NCALL - 1
      IF (NCALL > 0) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"( ' called from ',A)") TRIM(NAME)
          GO TO 110
      ENDIF

      IF (KFLAG == -1) THEN
          WRITE (KW,"(' NDIG must be at least 2'/)")
      ELSE IF (KFLAG == -2) THEN
          WRITE (KW,"(' MBASE must be between 2 and',I10/)") INT(MXBASE)
      ELSE IF (KFLAG == -3) THEN
          WRITE (KW,  &
                 "(' An input argument is not a valid FM number.',"  //  &
                 "'  Its exponent is out of range.'/)"                   &
                )
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -4 .OR. KFLAG == -7) THEN
          WRITE (KW,"(' Invalid input argument for this routine.'/)")
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -5) THEN
          WRITE (KW,"(' The result has overflowed.'/)")
      ELSE IF (KFLAG == -6) THEN
          WRITE (KW,"(' The result has underflowed.'/)")
      ELSE IF (KFLAG == -8 .AND. NAME == 'FMOUT') THEN
          WRITE (KW,  &
                 "(' The result array is not big enough to hold the',"    //  &
                 "' output character string'/' in the current format.'/"  //  &
                 "' The result ''***...***'' has been returned.'/)"           &
                )
      ELSE IF (KFLAG == -8 .AND. NAME == 'FMREAD') THEN
          WRITE (KW,  &
                 "(' The CMBUFF array is not big enough to hold the',"  //  &
                 "' input character string'/"                           //  &
                 "' UNKNOWN has been returned.'/)"                          &
                )
      ELSE IF (KFLAG == -9) THEN
          WRITE (KW,  &
                 "(' Precision could not be raised enough to'"  //  &
                 ",' provide all requested guard digits.'/)"        &
                )
          WRITE (KW,  &
                 "(I23,' digits were requested (NDIG).'/)"          &
                ) NDIG
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -10) THEN
          IF (NAMEST(NCS) == 'FMM2SP') THEN
              WRITE (KW,  &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to single precision.'/)"                      &
                    )
          ELSE
              WRITE (KW,  &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to double precision.'/)"                      &
                    )
          ENDIF
          WRITE (KW,"(' Zero has been returned.'/)")
      ENDIF

      NCALL = NCS
      IF (KWARN >= 2) THEN
          STOP
      ENDIF
      RETURN
      END SUBROUTINE FMWARN

      SUBROUTINE FMWRIT(KWRITE,MA)

!  Write MA on unit KWRITE.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  These numbers can then be read easily using FMREAD.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KWRITE
      INTEGER :: MA

      INTEGER :: J,JF1SAV,JF2SAV,K,KSAVE,L,LAST,LB,ND,NDSAVE,NEXP
      INTENT (IN) :: MA,KWRITE

      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMWRIT'
      NDSAVE = NDIG
      NDIG = MAX(NDIG+NGRD52,2)

      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      KSAVE = KFLAG
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = ND + NEXP

      JF1SAV = JFORM1
      JF2SAV = JFORM2
      JFORM1 = 1
      JFORM2 = ND + 6
      IF (LB > LMBUFF) THEN
          IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
          ALLOCATE(CMBUFF(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFF = LB
      ENDIF

      CALL FMOUT(MXY(1),CMBUFF,LB)

      KFLAG = KSAVE
      NDIG = NDSAVE
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      LAST = LB + 1
      DO J = 1, LB
         IF (CMBUFF(LAST-J) /= ' ' .OR. J == LB) THEN
             L = LAST - J
             IF (MOD(L,73) /= 0) THEN
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L)
             ELSE
                 IF (L > 73) WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L-73)
                 WRITE (KWRITE,"(4X,73A1)") (CMBUFF(K),K=L-72,L)
             ENDIF
             NCALL = NCALL - 1
             IF (TEMPV_CALL_STACK == 1) THEN
                 IF (TEMPV(MA) == -1) TEMPV(MA) = -2
             ENDIF
             NUMBER_USED = NUMBER_USED_SAVE
             TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
             RETURN
         ENDIF
      ENDDO
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMWRIT


!  Here are the routines that work with packed FM numbers.  All names are the same as unpacked
!  versions with 'FM' replaced by 'FP'.

!  This packed format is not available when using the FM, IM, or ZM derived types.

      SUBROUTINE FPABS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMABS(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPABS

      SUBROUTINE FPACOS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMACOS(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPACOS

      SUBROUTINE FPADD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMADD(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPADD

      SUBROUTINE FPADD_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMADD_R1(MPA,MPB)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPADD_R1

      SUBROUTINE FPADD_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMADD_R2(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPADD_R2

      SUBROUTINE FPADDI(MA,L)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: L
      INTEGER :: L
      CALL FMUNPK(MA,MPA)
      CALL FMADDI(MPA,L)
      CALL FMPACK(MPA,MA)
      RETURN
      END SUBROUTINE FPADDI

      SUBROUTINE FPASIN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMASIN(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPASIN

      SUBROUTINE FPATAN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMATAN(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPATAN

      SUBROUTINE FPATN2(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMATN2(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPATN2

      SUBROUTINE FPBIG(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMBIG(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBIG

      SUBROUTINE FPCHSH(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCHSH(MPA,MPB,MPC)
      CALL FMPACK(MPB,MB)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCHSH

      FUNCTION FPCOMP(MA,LREL,MB)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: FPCOMP
      LOGICAL, EXTERNAL :: FMCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      INTENT (IN) :: MA,MB,LREL
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      FPCOMP = FMCOMP(MPA,LREL,MPB)
      RETURN
      END FUNCTION FPCOMP

      SUBROUTINE FPCOS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCOS(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCOS

      SUBROUTINE FPCOSH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCOSH(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCOSH

      SUBROUTINE FPCSSN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCSSN(MPA,MPB,MPC)
      CALL FMPACK(MPB,MB)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCSSN

      SUBROUTINE FPDIG(NSTACK,KST)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: NSTACK(49),KST
      CALL FMDIG(NSTACK,KST)
      RETURN
      END SUBROUTINE FPDIG

      SUBROUTINE FPDIM(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMDIM(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIM

      SUBROUTINE FPDIV(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMDIV(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIV

      SUBROUTINE FPDIV_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMDIV_R1(MPA,MPB)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIV_R1

      SUBROUTINE FPDIV_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMDIV_R2(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIV_R2

      SUBROUTINE FPDIVI(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMDIVI(MPA,IVAL,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIVI

      SUBROUTINE FPDIVI_R1(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      INTEGER :: IVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMDIVI_R1(MPA,IVAL)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDIVI_R1

      SUBROUTINE FPDP2M(X,MA)
      USE FMVALS
      IMPLICIT NONE
      DOUBLE PRECISION :: X
      INTEGER :: MA
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMDP2M(X,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDP2M

      SUBROUTINE FPDPM(X,MA)
      USE FMVALS
      IMPLICIT NONE
      DOUBLE PRECISION :: X
      INTEGER :: MA
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMDPM(X,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPDPM

      SUBROUTINE FPEQ(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMEQ(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEQ

      SUBROUTINE FPEQU(MA,MB,NDA,NDB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: NDA,NDB
      INTENT (IN) :: MA,NDA,NDB
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FPEQU_UNPCK(MA,NDA,MPA)
      CALL FMEQU_R1(MPA,NDA,NDB)
      CALL FPEQU_PACK(MPA,NDB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEQU

      SUBROUTINE FPEQU_R1(MA,NDA,NDB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: NDA,NDB
      INTENT (INOUT) :: MA
      INTENT (IN) :: NDA,NDB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FPEQU_UNPCK(MA,NDA,MPA)
      CALL FMEQU_R1(MPA,NDA,NDB)
      CALL FPEQU_PACK(MPA,NDB,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEQU_R1

      SUBROUTINE FPEQU_PACK(MA,ND,MP)

!  MA (with ND digits) is packed two base MBASE digits per word and returned in MP.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP,ND
      INTENT (IN) :: MA,ND
      INTENT (INOUT) :: MP

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MP <= 0) THEN
          CALL IMDEFINE(MP,ND+3)
      ELSE IF (SIZE_OF(MP) < ND/2+4) THEN
          CALL IMDEFINE(MP,ND+3)
      ENDIF

      KP = 2
      MWK(START(MP)) = MWK(START(MA))
      MWK(START(MP)+1) = MWK(START(MA)+1)
      MWK(START(MP)+2) = MWK(START(MA)+2)
      MWK(START(MP)+3) = ABS(MWK(START(MA)+3))*MBASE + MWK(START(MA)+4)
      IF (ND >= 4) THEN
          DO J = 4, ND, 2
             KP = KP + 1
             MWK(START(MP)+KP+1) = MWK(START(MA)+J+1)*MBASE + MWK(START(MA)+J+2)
          ENDDO
      ENDIF
      IF (MOD(ND,2) == 1) MWK(START(MP)+KP+2) = MWK(START(MA)+ND+2)*MBASE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEQU_PACK

      SUBROUTINE FPEQU_UNPCK(MP,ND,MA)

!  MP (with ND digits) is unpacked and the value returned in MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP,ND
      INTENT (IN) :: MP,ND
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL IMDEFINE(MA,ND+3)
      ELSE IF (SIZE_OF(MA) < ND+3) THEN
          CALL IMDEFINE(MA,ND+3)
      ENDIF

      KP = 2
      MWK(START(MA)) = MWK(START(MP))
      MWK(START(MA)+1) = MWK(START(MP)+1)
      MWK(START(MA)+2) = MWK(START(MP)+2)
      MWK(START(MA)+3) = AINT (ABS(MWK(START(MP)+3))/MBASE)
      MWK(START(MA)+4) = ABS(MWK(START(MP)+3)) - MWK(START(MA)+3)*MBASE
      IF (ND >= 4) THEN
          DO J = 4, ND, 2
             KP = KP + 1
             MWK(START(MA)+J+1) = AINT (MWK(START(MP)+KP+1)/MBASE)
             MWK(START(MA)+J+2) = MWK(START(MP)+KP+1) - MWK(START(MA)+J+1)*MBASE
          ENDDO
      ENDIF
      IF (MOD(ND,2) == 1) THEN
          MWK(START(MA)+ND+2) = AINT (MWK(START(MP)+KP+2)/MBASE)
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEQU_UNPCK

      SUBROUTINE FPEXP(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMEXP(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEXP

      SUBROUTINE FPFLAG(K)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: K
      K = KFLAG
      RETURN
      END SUBROUTINE FPFLAG

      SUBROUTINE FPFORM(FORM,MA,STRING)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: FORM,STRING
      INTEGER :: MA
      INTENT (IN) :: MA,FORM
      INTENT (INOUT) :: STRING
      CALL FMUNPK(MA,MPA)
      CALL FMFORM(FORM,MPA,STRING)
      RETURN
      END SUBROUTINE FPFORM

      SUBROUTINE FPFPRT(FORM,MA)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      INTENT (IN) :: MA,FORM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMFPRT(FORM,MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPFPRT

      SUBROUTINE FPI2M(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: IVAL
      INTEGER :: MA
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMI2M(IVAL,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPI2M

      SUBROUTINE FPINP(LINE,MA,LA,LB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMINP(LINE,MPA,LA,LB)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPINP

      SUBROUTINE FPINT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMINT(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPINT

      SUBROUTINE FPIPWR(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMIPWR(MPA,IVAL,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPIPWR

      SUBROUTINE FPLG10(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMLG10(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLG10

      SUBROUTINE FPLN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMLN(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLN

      SUBROUTINE FPLNI(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: IVAL
      INTEGER :: MA
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMLNI(IVAL,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLNI

      SUBROUTINE FPM2DP(MA,X)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      DOUBLE PRECISION :: X
      INTENT (IN) :: MA
      INTENT (INOUT) :: X
      CALL FMUNPK(MA,MPA)
      CALL FMM2DP(MPA,X)
      RETURN
      END SUBROUTINE FPM2DP

      SUBROUTINE FPM2I(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL
      INTEGER :: IVAL
      CALL FMUNPK(MA,MPA)
      CALL FMM2I(MPA,IVAL)
      RETURN
      END SUBROUTINE FPM2I

      SUBROUTINE FPM2SP(MA,X)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (IN) :: MA
      INTENT (INOUT) :: X
      REAL :: X
      CALL FMUNPK(MA,MPA)
      CALL FMM2SP(MPA,X)
      RETURN
      END SUBROUTINE FPM2SP

      SUBROUTINE FPMAX(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMAX(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMAX

      SUBROUTINE FPMIN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMIN(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMIN

      SUBROUTINE FPMOD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMOD(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMOD

      SUBROUTINE FPMPY(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMPY(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMPY

      SUBROUTINE FPMPY_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMPY_R1(MPA,MPB)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMPY_R1

      SUBROUTINE FPMPY_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMMPY_R2(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMPY_R2

      SUBROUTINE FPMPYI(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: IVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMMPYI(MPA,IVAL,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMPYI

      SUBROUTINE FPMPYI_R1(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: IVAL
      INTEGER :: IVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMMPYI_R1(MPA,IVAL)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPMPYI_R1

      SUBROUTINE FPNINT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMNINT(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPNINT

      SUBROUTINE FPOUT(MA,LINE,LB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE
      INTEGER :: LB
      CHARACTER :: LINE(LB)
      CALL FMUNPK(MA,MPA)
      CALL FMOUT(MPA,LINE,LB)
      RETURN
      END SUBROUTINE FPOUT

      SUBROUTINE FPPI(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMPI(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPI

      SUBROUTINE FPPRNT(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (IN) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMPRNT(MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPRNT

      SUBROUTINE FPPWR(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMPWR(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPWR

      SUBROUTINE FPREAD(KREAD,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KREAD
      INTEGER :: MA
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMREAD(KREAD,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPREAD

      SUBROUTINE FPRPWR(MA,KVAL,JVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA,KVAL,JVAL
      INTENT (INOUT) :: MB
      INTEGER :: KVAL,JVAL
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMRPWR(MPA,KVAL,JVAL,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPRPWR

      SUBROUTINE FPSET(NPREC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: NPREC
      INTENT (IN) :: NPREC
      CALL FMSET(NPREC)
      RETURN
      END SUBROUTINE FPSET

      SUBROUTINE FPSETVAR(STRING)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      INTENT (IN) :: STRING
      CALL FMSETVAR(STRING)
      RETURN
      END SUBROUTINE FPSETVAR

      SUBROUTINE FPSIGN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMSIGN(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSIGN

      SUBROUTINE FPSIN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSIN(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSIN

      SUBROUTINE FPSINH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSINH(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSINH

      SUBROUTINE FPSP2M(X,MA)
      USE FMVALS
      IMPLICIT NONE
      REAL :: X
      INTEGER :: MA
      INTENT (IN) :: X
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMSP2M(X,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSP2M

      SUBROUTINE FPSQR(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSQR(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSQR

      SUBROUTINE FPSQR_R1(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSQR_R1(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSQR_R1

      SUBROUTINE FPSQRT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSQRT(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSQRT

      SUBROUTINE FPSQRT_R1(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSQRT_R1(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSQRT_R1

      SUBROUTINE FPST2M(STRING,MA)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      INTEGER :: MA
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMST2M(STRING,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPST2M

      SUBROUTINE FPSUB(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMSUB(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSUB

      SUBROUTINE FPSUB_R1(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (INOUT) :: MA
      INTENT (IN) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMSUB_R1(MPA,MPB)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSUB_R1

      SUBROUTINE FPSUB_R2(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMSUB_R2(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSUB_R2

      SUBROUTINE FPTAN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMTAN(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPTAN

      SUBROUTINE FPTANH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMTANH(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPTANH

      SUBROUTINE FPTINY(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMTINY(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPTINY

      SUBROUTINE FPULP(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMULP(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPULP

      SUBROUTINE FPVARS
      USE FMVALS
      CALL FMVARS
      RETURN
      END SUBROUTINE FPVARS

      SUBROUTINE FPWRIT(KWRITE,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      INTENT (IN) :: MA,KWRITE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMWRIT(KWRITE,MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPWRIT


!  The random number routines use integer multiple precision arithmetic.

      SUBROUTINE FM_RANDOM_NUMBER(VALUE)

!  FM_RANDOM_NUMBER generates pseudo-random numbers uniform on (0,1).
!  VALUE is returned as the next random (double precision) number.
!  Neither zero nor one will be returned in VALUE.

!  This version uses the FM package to implement a multiplicative congruential generator.
!  Both the modulus and the multiplier are 49-digit primes, and the period is over 1.0E+49.

!  This generator passes the spectral test, with mu(2), ..., mu(6) =
!    3.40,   4.35,   3.98,   3.19,   3.20.
!  It also has passed Marsaglia's DieHard test suite for random generators.

!  The typical usage is to call FM_RANDOM_SEED_PUT once with SEED defined as an integer array of
!  length 7 containing seven seed values used to initialize the generator.  A default seed is used
!  if no call to FM_RANDOM_SEED_PUT is done.  Then each call to FM_RANDOM_NUMBER returns the next
!  random value.

!  This example seeds the generator and then fills the array R with random values between 0 and 1.

!        SEED = (/ 314159,265358,979323,846264,338327,950288,419716 /)
!        CALL FM_RANDOM_SEED_PUT(SEED)
!        DO J = 1, N
!           CALL FM_RANDOM_NUMBER(R(J))
!        ENDDO

!  In a FM_RANDOM_SEED_GET call, the seed array is returned that would later restart the generator
!  in FM_RANDOM_NUMBER at the same place in the sequence.

!      SEED = (/ 314159,265358,979323,846264,338327,950288,419716 /)
!      CALL FM_RANDOM_SEED_PUT(SEED)
!      DO J = 1, 100
!         CALL FM_RANDOM_NUMBER(R(J))
!      ENDDO

!      CALL FM_RANDOM_SEED_GET(SEED)
!      DO J = 101, 200
!         CALL FM_RANDOM_NUMBER(R(J))
!      ENDDO

!      CALL FM_RANDOM_SEED_PUT(SEED)
!      DO J = 201, 300
!         CALL FM_RANDOM_NUMBER(R(J))
!      ENDDO

!  Here the seed is saved after 100 calls.  The seed is used to re-set the generator after 200 calls
!  to the same state it had after 100 calls, and R(201), ..., R(300) is the same sequence as
!  R(101), ..., R(200).

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: VALUE,DPX
      INTEGER :: POS_OF_LAST_DIGIT,J,JBASE,LAST_DIGIT_OF_X
      INTEGER :: SEED(7) = (/314159,265358,979323,846264,338327,950288,419716/)
      SAVE JBASE,SEED
      REAL (KIND(1.0D0)) :: MSAVE
      LOGICAL, EXTERNAL :: IMCOMP
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 2) THEN
          NAMEST(NCALL) = 'FM_RANDOM'
          WRITE (KW,"(' Input to FM_RANDOM_NUMBER')")
      ENDIF

!             Variables (in module FMVALS).

!             MBRAND is the base (value of MBASE) used for computing the random numbers.  This
!                    allows the user to change MBASE without causing problems in FM_RANDOM_NUMBER.

!             The multiplicative congruence used by the generator is
!                 X = ( A*X + C ) mod M
!             where all four are integers.
!             MRNX is X  (the current random integer)
!             MRNA is A  (the multiplier, defined in FM_RANDOM_SEED_PUT)
!             MRNC is C  (C = 1 for this generator)
!             MRNM is M  (the modulus, defined in FM_RANDOM_SEED_PUT)

!             X is the current value of the random sequence.
!             VALUE is then returned as approximately X/M.

      MSAVE = MBASE
      MBASE = MBRAND
      IF (MSAVE /= MBASE) CALL FMCONS

!             START_RANDOM_SEQUENCE =  0  for normal operation. Get the next  random value.
!                                   =  1  for the first call after the user has called
!                                         FM_RANDOM_SEED. Use that value in MRNX to initialize.
!                                   = -1  for the first user call if there was no initializing call
!                                         to FM_RANDOM_SEED.  Use a default seed to initialize MRNX.

      IF (START_RANDOM_SEQUENCE /= 0) THEN
          IF (START_RANDOM_SEQUENCE == -1) THEN
              CALL FM_RANDOM_SEED_PUT(SEED)
          ENDIF
          START_RANDOM_SEQUENCE = 0
      ENDIF
      JBASE = INT(MBASE) - 1

!             Get the next number in the sequence.

  110 CALL IMMPYM(MRNA,MRNX,MRNM,MXY(2))
      POS_OF_LAST_DIGIT = INT(MWK(START(MXY(2))+2)) + 1
      DO J = -1, POS_OF_LAST_DIGIT
         MWK(START(MRNX)+J+1) = MWK(START(MXY(2))+J+1)
      ENDDO
      LAST_DIGIT_OF_X = INT(MWK(START(MRNX)+POS_OF_LAST_DIGIT+1))
      IF (LAST_DIGIT_OF_X == LAST_DIGIT_OF_M_M1) THEN
          CALL IMADD(MRNX,MRNC,MXY(1))
          CALL IMEQ(MXY(1),MRNX)
          IF (IMCOMP(MRNX,'>=',MRNM)) THEN
              CALL IMSUB(MRNX,MRNM,MXY(1))
              CALL IMEQ(MXY(1),MRNX)
          ENDIF
      ELSE IF (LAST_DIGIT_OF_X < JBASE) THEN
          MWK(START(MRNX)+POS_OF_LAST_DIGIT+1) = MWK(START(MRNX)+POS_OF_LAST_DIGIT+1) + 1
      ELSE
          CALL IMADD(MRNX,MRNC,MXY(1))
          CALL IMEQ(MXY(1),MRNX)
      ENDIF

!            Convert to double precision.

      DPX = MWK(START(MRNX)+3)
      DO J = 3, POS_OF_LAST_DIGIT
         DPX = MBASE*DPX + MWK(START(MRNX)+J+1)
      ENDDO

      DPX = DPX*DPM
      IF (DPX >= 1.0D0 .OR. DPX <= 0.0D0) GO TO 110

      VALUE = DPX

      IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 1) THEN
          WRITE (KW,  &
                 "(' ',A,5X,'Call level =',I2,5X,'MBASE =',I10)"  &
                ) 'FM_RANDOM_NUMBER',NCALL,INT(MBASE)
          WRITE (KW,"(1X,D30.20)") VALUE
      ENDIF
      NCALL = NCALL - 1

      IF (MSAVE /= MBASE) THEN
          MBASE = MSAVE
          CALL FMCONS
      ENDIF
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FM_RANDOM_NUMBER

      SUBROUTINE FM_RANDOM_SEED_GET(SEED)

!  Return SEED(1) through SEED(7) as the current state of the generator.
!  See the comments in routine FM_RANDOM_NUMBER.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: SEED(7)
      REAL (KIND(1.0D0)) :: MSAVE
      INTEGER :: SCR(7) = (/462643,383279,502884,197163,141592,653589,793238/)
      INTEGER :: J,K
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      MSAVE = MBASE
      MBASE = MBRAND
      IF (MBLOGS /= MBASE) CALL FMCONS
      K = 10**7
      CALL IMI2M(K,MXY(2))
      CALL IMEQ(MRNX,MXY(1))
      DO J = 7, 1, -1
         CALL IMMOD(MXY(1),MXY(2),MXY(3))
         CALL IMM2I(MXY(3),SEED(J))
         SEED(J) = SEED(J) - SCR(J)
         IF (SEED(J) < 0) THEN
             SEED(J) = SEED(J) + K
         ENDIF
         CALL IMDIVI(MXY(1),K,MXY(3))
         CALL IMEQ(MXY(3),MXY(1))
      ENDDO
      MBASE = MSAVE
      IF (MBLOGS /= MBASE) CALL FMCONS
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FM_RANDOM_SEED_GET

      SUBROUTINE FM_RANDOM_SEED_PUT(SEED)

!  Use SEED(1) through SEED(7) to initialize the FM_RANDOM_NUMBER generator.
!  See the comments in routine FM_RANDOM_NUMBER.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: SEED(7)
      REAL (KIND(1.0D0)) :: MSAVE
      INTEGER :: SCR(7) = (/462643,383279,502884,197163,141592,653589,793238/)
      INTEGER :: J,K,L
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      MSAVE = MBASE
      MBASE = MBRAND
      IF (MBLOGS /= MBASE) CALL FMCONS
      CALL IMST2M('1424133622579837639401183671018194926834820238197',MRNA)
      CALL IMST2M('2070613773952029032014000773560846464373793273739',MRNM)
      K = 10**7
      L = ABS(SEED(1)) + SCR(1)
      IF (L <= K) THEN
          CALL IMI2M(L,MRNX)
      ELSE
          CALL IMI2M(L-K,MRNX)
      ENDIF
      DO J = 2, 7
         CALL IMMPYI(MRNX,K,MXY(2))
         L = ABS(SEED(J)) + SCR(J)
         IF (L <= K) THEN
             CALL IMI2M(L,MXY(1))
         ELSE
             CALL IMI2M(L-K,MXY(1))
         ENDIF
         CALL IMADD(MXY(2),MXY(1),MRNX)
      ENDDO
      CALL IMMOD(MRNX,MRNM,MXY(2))
      CALL IMEQ(MXY(2),MRNX)
      START_RANDOM_SEQUENCE = 1
      J = MWK(START(MRNM)+2)
      LAST_DIGIT_OF_M_M1 = INT(MWK(START(MRNM)+J+2)) - 1
      CALL IMI2M(1,MRNC)
      CALL IMM2DP(MRNM,DPM)
      DPM = 1.0D0/DPM

      MBASE = MSAVE
      IF (MBLOGS /= MBASE) CALL FMCONS
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE FM_RANDOM_SEED_PUT

      SUBROUTINE FM_RANDOM_SEED_SIZE(SIZE)

!  Return the size of the SEED array used by the FM_RANDOM_NUMBER generator.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: SIZE

      SIZE = 7
      RETURN
      END SUBROUTINE FM_RANDOM_SEED_SIZE


!  The IM routines perform integer multiple-precision arithmetic.

      SUBROUTINE IMABS(MA,MB)

!  MB = ABS(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: KWRNSV,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MAX(5,INT(MWK(START(MA)+2)+3))
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMABS    ',1,MA,MA)
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMABS'
          CALL IMNTR(2,MA,MA,1)
      ENDIF

      KFLAG = 0
      KWRNSV = KWARN
      KWARN = 0
      CALL IMEQ(MA,MB)
      MWK(START(MB)) = 1
      KWARN = KWRNSV

      IF (NTRACE /= 0) CALL IMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMABS

      SUBROUTINE IMADD(MA,MB,MC)

!  MC = MA + MB

!  This routine performs the trace printing.  IMADD2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMADD'
          CALL IMNTR(2,MA,MB,2)

          CALL IMADD2(MA,MB,MC)

          CALL IMNTR(1,MC,MC,1)
      ELSE
          CALL IMADD2(MA,MB,MC)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMADD

      SUBROUTINE IMADD2(MA,MB,MC)

!  MC = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MDA,MDAB,MDB
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF

      IF (KDEBUG == 1) CALL IMARGS('IMADD    ',2,MA,MB)
      NDSAVE = NDIG
      KFLAG = 0

      IF (MWK(START(MA)+2) <= 2) THEN
          IF (MWK(START(MB)+2) > 2 .OR. MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) GO TO 110
          IF (MWK(START(MA)+2) <= 1) THEN
              MDA = MWK(START(MA)) * MWK(START(MA)+3)
          ELSE
              MDA = MWK(START(MA)) * (MWK(START(MA)+3)*MBASE + MWK(START(MA)+4))
          ENDIF
          IF (MWK(START(MB)+2) <= 1) THEN
              MDB = MWK(START(MB)) * MWK(START(MB)+3)
          ELSE
              MDB = MWK(START(MB)) * (MWK(START(MB)+3)*MBASE + MWK(START(MB)+4))
          ENDIF
          MDAB = MDA + MDB
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 1
              IF (MDAB == 0) MWK(START(MC)+2) = 0
              IF (MDAB < 0) THEN
                  MWK(START(MC)+3) = -MDAB
                  MWK(START(MC)) = -1
              ELSE
                  MWK(START(MC)+3) = MDAB
                  MWK(START(MC)) = 1
              ENDIF
              MWK(START(MC)+4) = 0
              IF (MDA == 0 .OR. MDB == 0) KFLAG = 1
              GO TO 120
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 2
              IF (MDAB < 0) THEN
                  MWK(START(MC)+3) = AINT (-MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(-MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = -1
              ELSE
                  MWK(START(MC)+3) = AINT (MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = 1
              ENDIF
              IF (MDA == 0 .OR. MDB == 0) KFLAG = 1
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR.  &
          MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
              CALL IMI2M2(0,MC)
              MWK(START(MC)+2) = MUNKNO
              MWK(START(MC)+3) = 1
              MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
              KFLAG = -4
              GO TO 120
          ENDIF
          IF (MWK(START(MA)+2) == MEXPOV) THEN
              IF (MWK(START(MA)) == MWK(START(MB)) .OR. MWK(START(MB)+3) == 0) THEN
                  MWK(START(MC)) = MWK(START(MA))
                  MWK(START(MC)+1) = MWK(START(MA)+1)
                  MWK(START(MC)+2) = MWK(START(MA)+2)
                  MWK(START(MC)+3) = MWK(START(MA)+3)
                  MWK(START(MC)+4) = MWK(START(MA)+4)
                  KFLAG = -5
                  GO TO 120
              ELSE
                  KFLAG = -4
                  NAMEST(NCALL) = 'IMADD'
                  CALL FMWARN
                  CALL IMI2M2(0,MC)
                  MWK(START(MC)+2) = MUNKNO
                  MWK(START(MC)+3) = 1
                  MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
                  GO TO 120
              ENDIF
          ENDIF
          IF (MWK(START(MB)+2) == MEXPOV) THEN
              IF (MWK(START(MB)) == MWK(START(MA)) .OR. MWK(START(MA)+3) == 0) THEN
                  MWK(START(MC)) = MWK(START(MB))
                  MWK(START(MC)+1) = MWK(START(MB)+1)
                  MWK(START(MC)+2) = MWK(START(MB)+2)
                  MWK(START(MC)+3) = MWK(START(MB)+3)
                  MWK(START(MC)+4) = MWK(START(MB)+4)
                  KFLAG = -5
                  GO TO 120
              ELSE
                  KFLAG = -4
                  NAMEST(NCALL) = 'IMADD'
                  CALL FMWARN
                  CALL IMI2M2(0,MC)
                  MWK(START(MC)+2) = MUNKNO
                  MWK(START(MC)+3) = 1
                  MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
                  GO TO 120
              ENDIF
          ENDIF
          KFLAG = -4
          NAMEST(NCALL) = 'IMADD'
          CALL FMWARN
          CALL IMI2M2(0,MC)
          MWK(START(MC)+2) = MUNKNO
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          GO TO 120
      ENDIF

      CALL IMADD3(MA,MB,MC)

  120 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMADD2

      SUBROUTINE IMADD3(MA,MB,MC)

!  Internal addition routine.  MC = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MAS,MBS
      INTEGER :: J,JCOMP,JSIGN,N1
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (MWK(START(MA)+3) == 0) THEN
          CALL IMEQ(MB,MC)
          KFLAG = 1
          IF (KSUB == 1) THEN
              IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
                  MWK(START(MC)) = -MWK(START(MC))
              KFLAG = 0
          ENDIF
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (MWK(START(MB)+3) == 0) THEN
          CALL IMEQ(MA,MC)
          KFLAG = 1
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KFLAG = 0
      N1 = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 1

!             JSIGN is the sign of the result of MA + MB.

      JSIGN = 1
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      IF (KSUB == 1) MBS = -MBS

!             See which one is larger in absolute value.

      JCOMP = 2
      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
      ELSE IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
      ELSE
          DO J = 2, N1
             IF (MWK(START(MA)+J+1) > MWK(START(MB)+J+1)) THEN
                 JCOMP = 1
                 EXIT
             ENDIF
             IF (MWK(START(MB)+J+1) > MWK(START(MA)+J+1)) THEN
                 JCOMP = 3
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (JCOMP < 3) THEN
          IF (MAS < 0) JSIGN = -1
          IF (MAS*MBS > 0) THEN
              CALL IMADDP(MA,MB)
          ELSE
              CALL IMADDN(MA,MB)
          ENDIF
      ELSE
          IF (MBS < 0) JSIGN = -1
          IF (MAS*MBS > 0) THEN
              CALL IMADDP(MB,MA)
          ELSE
              CALL IMADDN(MB,MA)
          ENDIF
      ENDIF

!             Transfer to MC and fix the sign of the result.

      NDIG = MWK(START(MWA)+2)
      IF (NDIG < 2) NDIG = 2
      CALL FMMOVE(MWA,MC)
      MWK(START(MC)+1) = NINT(10**7*ALOGM2)
      MWK(START(MC)) = 1
      IF (JSIGN < 0 .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1

      IF (KFLAG < 0) THEN
          IF (KSUB == 1) THEN
              NAMEST(NCALL) = 'IMSUB'
          ELSE
              NAMEST(NCALL) = 'IMADD'
          ENDIF
          CALL FMWARN
      ENDIF

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMADD3

      SUBROUTINE IMADDN(MA,MB)

!  Internal addition routine.  MWA = MA - MB
!  The arguments are such that MA >= MB >= 0.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MK
      INTEGER :: J,JMA,JMB,JMWA,K,KL,KP1,KP2,KPT,KSH,N1
      INTENT (IN) :: MA,MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = 2*MWK(START(MA)+2) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPOV) THEN
          KFLAG = -4
          MWK(START(MWA)+2) = MUNKNO
          MWK(START(MWA)+3) = 1
          MWK(START(MWA)+4) = 0
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      N1 = MWK(START(MA)+2) + 1
      MK = MWK(START(MA)+2) - MWK(START(MB)+2)
      K = INT(MK)

!             Subtract MB from MA.

      KP1 = MIN(N1,K+1)
      DO J = 1, KP1
         MWK(START(MWA)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      JMA = START(MA) + 1
      JMB = START(MB) + 1 - K
      JMWA = START(MWA) + 1
      DO J = KP2, N1
         MWK(JMWA+J) = MWK(JMA+J) - MWK(JMB+J)
      ENDDO

!             Normalize.  Fix the sign of any negative digit.

      IF (K > 0) THEN
          DO J = N1, KP2, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - 1
             ENDIF
          ENDDO
          KPT = KP2 - 1
  110     IF (MWK(START(MWA)+KPT+1) < 0 .AND. KPT >= 3) THEN
              MWK(START(MWA)+KPT+1) = MWK(START(MWA)+KPT+1) + MBASE
              MWK(START(MWA)+KPT) = MWK(START(MWA)+KPT) - 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
      ELSE
          DO J = N1, 3, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - 1
             ENDIF
          ENDDO
      ENDIF

!             Shift left if there are any leading zeros in the mantissa.

      DO J = 2, N1
         IF (MWK(START(MWA)+J+1) > 0) THEN
             KSH = J - 2
             GO TO 120
         ENDIF
      ENDDO
      MWK(START(MWA)+2) = 0
      MWK(START(MWA)+4) = 0
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

  120 IF (KSH > 0) THEN
          KL = N1 - KSH
          DO J = 2, KL
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+KSH+1)
          ENDDO
          DO J = KL+1, N1
             MWK(START(MWA)+J+1) = 0
          ENDDO
          MWK(START(MWA)+2) = MWK(START(MWA)+2) - KSH
      ENDIF

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMADDN

      SUBROUTINE IMADDP(MA,MB)

!  Internal addition routine.  MWA = MA + MB
!  The arguments are such that MA >= MB >= 0.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MK
      INTEGER :: J,JMA,JMB,JMWA,K,KP2,KPT,N1
      INTENT (IN) :: MA,MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = 2*(MWK(START(MA)+2)+1) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF

      N1 = MWK(START(MA)+2) + 1
      MK = MWK(START(MA)+2) - MWK(START(MB)+2)
      K = INT(MK)

!             Add MA and MB.

      MWK(START(MWA)+2) = MWK(START(MA)+2) + 1
      MWK(START(MWA)+3) = 0
      DO J = 2, K+1
         MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
      ENDDO
      KP2 = K + 2

!             (Inner Loop)

      JMA = START(MA) + 1
      JMB = START(MB) + 1 - K
      JMWA = START(MWA) + 2
      DO J = KP2, N1
         MWK(JMWA+J) = MWK(JMA+J) + MWK(JMB+J)
      ENDDO

!             Normalize.  Fix any digit not less than MBASE.

      IF (K > 0) THEN
          DO J = N1+1, KP2, -1
             IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) + 1
             ENDIF
          ENDDO
          KPT = KP2 - 1
  110     IF (MWK(START(MWA)+KPT+1) >= MBASE .AND. KPT >= 3) THEN
              MWK(START(MWA)+KPT+1) = MWK(START(MWA)+KPT+1) - MBASE
              MWK(START(MWA)+KPT) = MWK(START(MWA)+KPT) + 1
              KPT = KPT - 1
              GO TO 110
          ENDIF
      ELSE
          DO J = N1+1, 3, -1
             IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) + 1
             ENDIF
          ENDDO
      ENDIF

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMADDP

      SUBROUTINE IMARGS(KROUTN,NARGS,MA,MB)

!  Check the input arguments to a routine for special cases.

!  KROUTN - Name of the subroutine that was called
!  NARGS  - The number of input arguments (1 or 2)
!  MA     - First input argument
!  MB     - Second input argument (if NARGS is 2)

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: KROUTN
      INTEGER :: MA,MB
      INTEGER :: NARGS

      REAL (KIND(1.0D0)) :: MBS
      INTEGER :: J,KWRNSV,LAST
      INTENT (IN) :: KROUTN,NARGS,MA,MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = -4
      IF (MWK(START(MA)+2) == MUNKNO) THEN
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) == MUNKNO) THEN
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0

!             Check the validity of parameters.

      IF (NCALL > 1 .AND. KDEBUG == 0) THEN
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      NAMEST(NCALL) = KROUTN

!             Check MBASE.

      IF (MBASE < 2 .OR. MBASE > MXBASE) THEN
          KFLAG = -2
          CALL FMWARN
          MBS = MBASE
          IF (MBASE < 2) MBASE = 2
          IF (MBASE > MXBASE) MBASE = MXBASE
          WRITE (KW,  &
                 "(' MBASE was',I10,'.  It has been changed to',I10,'.')"  &
                ) INT(MBS),INT(MBASE)
          CALL FMCONS
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Check exponent range.

      IF (MWK(START(MA)+2) < 0) THEN
          IF (ABS(MWK(START(MA)+2)) /= MEXPOV .OR. ABS(MWK(START(MA)+3)) /= 1) THEN
              KFLAG = -3
              CALL FMWARN
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) < 0) THEN
              IF (ABS(MWK(START(MB)+2)) /= MEXPOV .OR. ABS(MWK(START(MB)+3)) /= 1) THEN
                  KFLAG = -3
                  CALL FMWARN
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MB) == -1) TEMPV(MB) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
      ENDIF

!             Check for properly normalized digits in the input arguments.

      IF (ABS(MWK(START(MA)+2)-INT(MWK(START(MA)+2))) /= 0) KFLAG = 1
      IF (MWK(START(MA)+3) <= (-1) .OR. MWK(START(MA)+3) >= MBASE .OR.  &
          ABS(MWK(START(MA)+3)-INT(MWK(START(MA)+3))) /= 0) KFLAG = 2
      IF (KDEBUG == 0) GO TO 110
      LAST = INT(MWK(START(MA)+2)) + 1
      IF (MWK(START(MA)+2) > SIZE_OF(MA)-2) LAST = 3
      DO J = 3, LAST
         IF (MWK(START(MA)+J+1) < 0 .OR. MWK(START(MA)+J+1) >= MBASE .OR.  &
             ABS(MWK(START(MA)+J+1)-INT(MWK(START(MA)+J+1))) /= 0) THEN
             KFLAG = J
             GO TO 110
         ENDIF
      ENDDO
  110 IF (KFLAG /= 0) THEN
          J = KFLAG
          KFLAG = -4
          KWRNSV = KWARN
          IF (KWARN >= 2) KWARN = 1
          CALL FMWARN
          KWARN = KWRNSV
          IF (KWARN >= 1) THEN
              WRITE (KW,*) ' First invalid array element:  MA(',J,') = ',MWK(START(MA)+J+1)
          ENDIF
          IF (KWARN >= 2) THEN
              STOP
          ENDIF
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (NARGS == 2) THEN
          IF (ABS(MWK(START(MB)+2)-INT(MWK(START(MB)+2))) /= 0) KFLAG = 1
          IF (MWK(START(MB)+3) <= (-1) .OR. MWK(START(MB)+3) >= MBASE .OR.  &
              ABS(MWK(START(MB)+3)-INT(MWK(START(MB)+3))) /= 0) KFLAG = 2
          IF (KDEBUG == 0) GO TO 120
          LAST = INT(MWK(START(MB)+2)) + 1
          IF (MWK(START(MB)+2) > SIZE_OF(MB)-2) LAST = 3
          DO J = 3, LAST
             IF (MWK(START(MB)+J+1) < 0 .OR. MWK(START(MB)+J+1) >= MBASE .OR.  &
                 ABS(MWK(START(MB)+J+1)-INT(MWK(START(MB)+J+1))) /= 0) THEN
                 KFLAG = J
                 GO TO 120
             ENDIF
          ENDDO
  120     IF (KFLAG /= 0) THEN
              J = KFLAG
              KFLAG = -4
              KWRNSV = KWARN
              IF (KWARN >= 2) KWARN = 1
              CALL FMWARN
              KWARN = KWRNSV
              IF (KWARN >= 1) THEN
                  WRITE (KW,*) ' First invalid array element:  MB(',J,') = ',MWK(START(MB)+J+1)
              ENDIF
              IF (KWARN >= 2) THEN
                  STOP
              ENDIF
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMARGS

      SUBROUTINE IMBIG(MA)

!  MA = A very large IM integer.

!  Before version 1.3 of FM, this routine returned the largest representable IM integer.
!  Starting with version 1.3 the size of IM integers is limited only by the space available
!  in the working array MWK in FMSAVE.f95.
!  But if this routine set MA as large as possible, it would leave no room for other
!  FM/IM/ZM numbers.  So a result of 10**(10**6) is returned here.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: L
      INTENT (INOUT) :: MA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      L = 1.05D+6*LOG(10.0D0)/LOG(DBLE(MBASE)) + 3
      RESULT_SIZE = L + 3
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MA <= 0) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'IMBIG'

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      CALL IMI2M(10,MXY(1))
      CALL IMI2M(10**6,MXY(2))
      CALL IMPWR(MXY(1),MXY(2),MA)

      IF (NTRACE /= 0 .AND. NCALL <= LVLTRC) THEN
          WRITE (KW,  &
                 "(' ',A,12X,'Call level =',I2,5X,'MBASE =',I10)"  &
                ) 'IMBIG',NCALL,INT(MBASE)
          WRITE (KW,*) '       1.0M+1000000'
      ENDIF
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMBIG

      FUNCTION IMCOMP(MA,LREL,MB)

!  Logical comparison of FM numbers MA and MB.

!  LREL is a CHARACTER description of the comparison to be done:
!  LREL = 'EQ' returns IMCOMP = .TRUE. if MA == MB
!       = 'NE', 'GE', 'GT', 'LE', 'LT' also work like a logical IF.
!       = '==', '/=', '<', '<=', '>', '>=' may be used.

      USE FMVALS
      IMPLICIT NONE

      LOGICAL :: IMCOMP
      CHARACTER(*) :: LREL
      CHARACTER(2) :: JREL
      INTEGER :: MA,MB

      INTEGER :: J,JCOMP,NDSAVE,NLAST,NTRSAV
      INTENT (IN) :: MA,LREL,MB

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMCOMP   ',2,MA,MB)
      NAMEST(NCALL) = 'IMCOMP'

      IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 2) THEN
          WRITE (KW,"(' Input to IMCOMP')")
          NDSAVE = NDIG
          IF (NTRACE > 0) THEN
              CALL IMPRNT(MA)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              CALL IMPRNT(MB)
          ELSE
              NDIG = MAX(2,INT(MWK(START(MA)+2)))
              NTRSAV = NTRACE
              CALL IMNTRJ(MA,NDIG)
              IF (INDEX('=/<>',LREL(1:1)) > 0) THEN
                  WRITE (KW,"(8X,A)") LREL
              ELSE
                  WRITE (KW,"(7X,'.',A,'.')") LREL
              ENDIF
              NDIG = MAX(2,INT(MWK(START(MB)+2)))
              CALL IMNTRJ(MB,NDIG)
              NTRACE = NTRSAV
          ENDIF
          NDIG = NDSAVE
      ENDIF

!             JCOMP will be 1 if MA > MB
!                           2 if MA == MB
!                           3 if MA < MB

!             Check for special cases.

      JREL = LREL
      IF (LREL /= 'EQ' .AND. LREL /= 'NE' .AND. LREL /= 'LT' .AND.  &
          LREL /= 'GT' .AND. LREL /= 'LE' .AND. LREL /= 'GE') THEN
          IF (LREL == 'eq' .OR. LREL == '==') THEN
              JREL = 'EQ'
          ELSE IF (LREL == 'ne' .OR. LREL == '/=') THEN
              JREL = 'NE'
          ELSE IF (LREL == 'lt' .OR. LREL == '<') THEN
              JREL = 'LT'
          ELSE IF (LREL == 'gt' .OR. LREL == '>') THEN
              JREL = 'GT'
          ELSE IF (LREL == 'le' .OR. LREL == '<=') THEN
              JREL = 'LE'
          ELSE IF (LREL == 'ge' .OR. LREL == '>=') THEN
              JREL = 'GE'
          ELSE
              IMCOMP = .FALSE.
              KFLAG = -4
              IF (NCALL /= 1 .OR. KWARN <= 0) GO TO 120
              IF (KWARN <= 0) GO TO 120
              WRITE (KW,  &
                     "(/' Error of type KFLAG = -4 in FM package in',"   //  &
                     "' routine IMCOMP'//1X,A,' is not one of the six'," //  &
                     "' recognized comparisons.'//' .FALSE. has been',"  //  &
                     "' returned.'/)"                                        &
                    ) LREL
              IF (KWARN >= 2) THEN
                  STOP
              ENDIF
              GO TO 120
          ENDIF
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          IMCOMP = .FALSE.
          KFLAG = -4
          GO TO 120
      ENDIF

      IF (ABS(MWK(START(MA)+2)) == MEXPOV .AND. MWK(START(MA)+2) == MWK(START(MB)+2) .AND.  &
          MWK(START(MA)+3) == MWK(START(MB)+3) .AND. MWK(START(MA)) == MWK(START(MB))) THEN
          IMCOMP = .FALSE.
          KFLAG = -4
          IF (NCALL /= 1 .OR. KWARN <= 0) GO TO 120
          IF (KWARN <= 0) GO TO 120
          WRITE (KW,  &
                 "(/' Error of type KFLAG = -4 in FM package in ',"  //  &
                 "'routine IMCOMP'//' Two numbers in the same ',"    //  &
                 "'overflow category cannot be compared.'//"         //  &
                 "' .FALSE. has been returned.'/)"                       &
                )
          IF (KWARN >= 2) THEN
              STOP
          ENDIF
          GO TO 120
      ENDIF

!             Check for zero.

      KFLAG = 0
      IF (MWK(START(MA)+3) == 0) THEN
          JCOMP = 2
          IF (MWK(START(MB)+3) == 0) GO TO 110
          IF (MWK(START(MB)) < 0) JCOMP = 1
          IF (MWK(START(MB)) > 0) JCOMP = 3
          GO TO 110
      ENDIF
      IF (MWK(START(MB)+3) == 0) THEN
          JCOMP = 1
          IF (MWK(START(MA)) < 0) JCOMP = 3
          GO TO 110
      ENDIF

!             Check for opposite signs.

      IF (MWK(START(MA)) > 0 .AND. MWK(START(MB)) < 0) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MWK(START(MB)) > 0 .AND. MWK(START(MA)) < 0) THEN
          JCOMP = 3
          GO TO 110
      ENDIF

!             See which one is larger in absolute value.

      IF (MWK(START(MA)+2) > MWK(START(MB)+2)) THEN
          JCOMP = 1
          GO TO 110
      ENDIF
      IF (MWK(START(MB)+2) > MWK(START(MA)+2)) THEN
          JCOMP = 3
          GO TO 110
      ENDIF
      NLAST = INT(MWK(START(MA)+2)) + 1

      DO J = 2, NLAST
         IF (ABS(MWK(START(MA)+J+1)) > ABS(MWK(START(MB)+J+1))) THEN
             JCOMP = 1
             GO TO 110
         ENDIF
         IF (ABS(MWK(START(MB)+J+1)) > ABS(MWK(START(MA)+J+1))) THEN
             JCOMP = 3
             GO TO 110
         ENDIF
      ENDDO

      JCOMP = 2

!             Now match the JCOMP value to the requested comparison.

  110 IF (JCOMP == 1 .AND. MWK(START(MA)) < 0) THEN
          JCOMP = 3
      ELSE IF (JCOMP == 3 .AND. MWK(START(MB)) < 0) THEN
          JCOMP = 1
      ENDIF

      IMCOMP = .FALSE.
      IF (JCOMP == 1 .AND. (JREL == 'GT' .OR. JREL == 'GE' .OR. JREL == 'NE')) IMCOMP = .TRUE.
      IF (JCOMP == 2 .AND. (JREL == 'EQ' .OR. JREL == 'GE' .OR. JREL == 'LE')) IMCOMP = .TRUE.
      IF (JCOMP == 3 .AND. (JREL == 'NE' .OR. JREL == 'LT' .OR. JREL == 'LE')) IMCOMP = .TRUE.

  120 CONTINUE
      IF (NTRACE /= 0) THEN
          IF (NCALL <= LVLTRC .AND. ABS(NTRACE) >= 1) THEN
              IF (KFLAG == 0) THEN
                  WRITE (KW,  &
                         "(' IMCOMP',15X,'Call level =',I2,5X,"  //  &
                         "'MBASE =',I10)"                            &
                        ) NCALL,INT(MBASE)
              ELSE
                  WRITE (KW,  &
                         "(' IMCOMP',6X,'Call level =',I2,4X,"  //  &
                         "'MBASE =',I10,4X,'KFLAG =',I3)"           &
                        ) NCALL,INT(MBASE),KFLAG
              ENDIF
              IF (IMCOMP) THEN
                  WRITE (KW,"(7X,'.TRUE.')")
              ELSE
                  WRITE (KW,"(7X,'.FALSE.')")
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      RETURN
      END FUNCTION IMCOMP

      SUBROUTINE IMDEFINE(MA,SIZE_MA)

!  Assign space in the FM work area, MWK, for a new multiple precision number.
!  Before being defined the first time, MA must have one of these values, to indicate what
!  type of multiple precision number MA will represent, and how much space it will need:

!      -1 for derived type FM, IM, ZM temporary numbers
!      -2 for internal FM temporary multiple precision numbers
!      -3 for user saved derived type variables or FM saved constants (MPI, ...)
!      -4 for bigger saved FM work areas (MWA, ...)
!      -5 for multiple precision temporary numbers in packed format
!      -6 and -7 for internal bookkeeping of assigned space.

!  After calling FMDEFINE with MA from -5 to -1, the returned value of MA is positive, giving an
!  "index" value.  Then START(MA) gives the starting location in array MWK for the multiple
!  precision number, and SIZE_OF(MA) gives the number of array elements in MWK that are assigned
!  to multiple precision number MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,SIZE_MA
      INTENT (INOUT) :: MA
      INTENT (IN) :: SIZE_MA
      INTEGER :: J,K,L,L1,L2,LAST_J,NEW_K,NEW_START,NEW_SIZE,NFREE,N_RESIZE

      NEW_SIZE = SIZE_MA
      N_RESIZE = 0
      IF (MA > SIZE_OF_START) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  In IMDEFINE the index value of MA is too large.'
          WRITE (KW,*) '               Index =',MA,' cannot be greater than ',SIZE_OF_START,'.'
          WRITE (KW,*) '               Usually this means type (FM), (ZM), or (IM) variables in'
          WRITE (KW,*) "               the user's program were declared but not initialized to -3."
          WRITE (KW,*) ' '
          STOP
      ENDIF

!             If MA has already been defined at a lower precision, MA will be positive here.
!             Re-define it with a new index and more space in MWK.

!             TEMPV(L) is set to the -1, ..., -5 input value of MA when MA is defined (= L) the
!             first time, so that a record is preserved of which type of multiple precision number
!             MA represents.
!             TEMPV(L) is set to -6 if MA gets re-defined at higher precision.  MA then has a new
!             index value and more space in MWK, and the -6 TEMPV value marks the old index as
!             unused.
!             If MWK runs out of space for new multiple precision numbers, it is re-allocated at a
!             bigger size.  When that is done, the unused space in MWK corresponding to any
!             TEMPV = -6 index values is deleted, and then those TEMPV elements are set to -7 to
!             mark those indexes as deleted.

      IF (MA > 0) THEN
          N_RESIZE = RESIZE(MA)
          RESIZE(MA) = 0
          L = MA
          MA = TEMPV(L)
          TEMPV(L) = -6
          N_RESIZE = N_RESIZE + 1
          IF (N_RESIZE > 10) NEW_SIZE = 2*SIZE_MA
      ELSE IF (MA == 0 .OR. MA < -5) THEN
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Error in FM.  In IMDEFINE the index value of MA must be positive or in'
          WRITE (KW,*) '               the range -5, ..., -1.  MA is ',MA
          WRITE (KW,*) ' '
          STOP
      ENDIF

!             L1    is the last word used on the left of MWK.
!             L2    is the first word used on the right of MWK.
!             NFREE is the number of free words in the middle.

      L1 = 1
      IF (NUMBER_USED > 0) L1 = START(NUMBER_USED)+SIZE_OF(NUMBER_USED)
      L2 = SIZE_OF_MWK
      IF (START_OF_SAVED_CONSTANTS <= SIZE_OF_START) L2 = START(START_OF_SAVED_CONSTANTS)
      NFREE = L2 - L1 - 1

!             If MWK runs out of space, try to re-allocate it with a bigger size.

      IF (NEW_SIZE > NFREE) THEN
          IF (SIZE_OF_MWK > 0) THEN
              ALLOCATE(MOVE_MWK(SIZE_OF_MWK),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              DO J = 1, SIZE_OF_MWK
                 MOVE_MWK(J) = MWK(J)
              ENDDO
              DEALLOCATE(MWK)
              L2 = MAX(10000,2*SIZE_OF_MWK,SIZE_OF_MWK+NEW_SIZE+30)
              ALLOCATE(MWK(L2),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              DO J = 1, L2
                 MWK(J) = MUNKNO
              ENDDO
              IF (NUMBER_USED > 0) THEN
                  NEW_K = 0
                  DO J = 1, NUMBER_USED
                     IF (TEMPV(J) > -6) THEN
                         NEW_START = NEW_K + 1
                         DO K = START(J), START(J)+SIZE_OF(J)-1
                            NEW_K = NEW_K + 1
                            MWK(NEW_K) = MOVE_MWK(K)
                         ENDDO
                         START(J) = NEW_START
                         LAST_J = J
                     ELSE
                         TEMPV(J) = -7
                     ENDIF
                  ENDDO
                  START(NUMBER_USED) = NEW_START
                  SIZE_OF(NUMBER_USED) = SIZE_OF(LAST_J)
              ENDIF
              IF (START_OF_SAVED_CONSTANTS <= SIZE_OF_START) THEN
                  NEW_K = L2 + 1
                  DO J = SIZE_OF_START, START_OF_SAVED_CONSTANTS, -1
                     IF (TEMPV(J) > -6) THEN
                         DO K = START(J)+SIZE_OF(J)-1, START(J), -1
                            NEW_K = NEW_K - 1
                            MWK(NEW_K) = MOVE_MWK(K)
                         ENDDO
                         START(J) = NEW_K
                         LAST_J = J
                     ELSE
                         TEMPV(J) = -7
                     ENDIF
                  ENDDO
                  START(START_OF_SAVED_CONSTANTS) = NEW_K
                  SIZE_OF(START_OF_SAVED_CONSTANTS) = SIZE_OF(LAST_J)
              ENDIF
              DEALLOCATE(MOVE_MWK)
              SIZE_OF_MWK = L2
          ELSE
              L2 = MAX(10000,NEW_SIZE+30)
              ALLOCATE(MWK(L2),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              SIZE_OF_MWK = L2
              DO J = 1, SIZE_OF_MWK
                 MWK(J) = MUNKNO
              ENDDO
          ENDIF
      ENDIF

      IF (MA == -3 .OR. MA == -4) GO TO 110

!             Store temporary variables from the beginning of MWK.

      IF (NUMBER_USED <= 0) THEN
          NUMBER_USED = 1
          START(1) = 1
          SIZE_OF(1) = NEW_SIZE
      ELSE
          IF (START_OF_SAVED_CONSTANTS <= SIZE_OF_START) THEN
              L1 = START(START_OF_SAVED_CONSTANTS)
          ELSE
              L1 = SIZE_OF_MWK
          ENDIF
          IF (NUMBER_USED+1 >= START_OF_SAVED_CONSTANTS) THEN
              CALL FMDEFINE_ERROR(2)
          ENDIF
          NUMBER_USED = NUMBER_USED + 1
          START(NUMBER_USED) = START(NUMBER_USED-1) + SIZE_OF(NUMBER_USED-1)
          SIZE_OF(NUMBER_USED) = NEW_SIZE
      ENDIF
      MAXIMUM_NUMBER_USED = MAX(MAXIMUM_NUMBER_USED,NUMBER_USED)
      MAXIMUM_MWK_USED = MAX(MAXIMUM_MWK_USED,START(NUMBER_USED)+NEW_SIZE)
      TEMPV(NUMBER_USED) = MA

      MA = NUMBER_USED
      RESIZE(MA) = N_RESIZE
      RETURN

!             Store saved variables from the end of MWK.

  110 IF (START_OF_SAVED_CONSTANTS > SIZE_OF_START) THEN
          START_OF_SAVED_CONSTANTS = SIZE_OF_START
          START(START_OF_SAVED_CONSTANTS) = SIZE_OF_MWK - NEW_SIZE + 1
          SIZE_OF(START_OF_SAVED_CONSTANTS) = NEW_SIZE
          TEMPV(START_OF_SAVED_CONSTANTS) = MA
          MA = START_OF_SAVED_CONSTANTS
      ELSE
          IF (START_OF_SAVED_CONSTANTS <= SIZE_OF_START) THEN
              L1 = START(START_OF_SAVED_CONSTANTS)
          ELSE
              L1 = SIZE_OF_MWK
          ENDIF
          IF (NUMBER_USED > 0) THEN
              L2 = START(NUMBER_USED) + SIZE_OF(NUMBER_USED)
          ELSE
              L2 = 1
          ENDIF
          L = -1
          DO J = START_OF_SAVED_CONSTANTS, SIZE_OF_START
             IF (TEMPV(J) /= -6) CYCLE
             IF (SIZE_OF(J) >= NEW_SIZE) THEN
                 IF (L < 0) THEN
                     L = J
                 ELSE
                     IF (SIZE_OF(J) < SIZE_OF(L)) THEN
                         L = J
                     ENDIF
                 ENDIF
             ENDIF
          ENDDO
          IF (L < 0) THEN
              IF (NUMBER_USED+1 >= START_OF_SAVED_CONSTANTS .OR. L2+NEW_SIZE >= L1) THEN
                  CALL FMDEFINE_ERROR(2)
              ENDIF
              START_OF_SAVED_CONSTANTS = START_OF_SAVED_CONSTANTS - 1
              START(START_OF_SAVED_CONSTANTS) = START(START_OF_SAVED_CONSTANTS+1) - (NEW_SIZE)
              SIZE_OF(START_OF_SAVED_CONSTANTS) = NEW_SIZE
              TEMPV(START_OF_SAVED_CONSTANTS) = MA
              MA = START_OF_SAVED_CONSTANTS
          ELSE
              TEMPV(L) = MA
              MA = L
          ENDIF
      ENDIF
      MINIMUM_SAVED_CONSTANTS_USED = MIN(MINIMUM_SAVED_CONSTANTS_USED,START_OF_SAVED_CONSTANTS)
      RESIZE(MA) = N_RESIZE
      RETURN
      END SUBROUTINE IMDEFINE

      SUBROUTINE IMDIM(MA,MB,MC)

!  MC = DIM(MA,MB)

!  Positive difference.  MC = MA - MB  if MA >= MB,
!                           = 0        otherwise.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KOVFL
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMDIM    ',2,MA,MB)
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMDIM'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
          GO TO 110
      ENDIF
      IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMDIM'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MC)
          GO TO 110
      ENDIF
      KOVFL = 0
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPOV) THEN
          KOVFL = 1
          IF (MWK(START(MA)+2) == MEXPOV .AND. MWK(START(MB)+2) == MEXPOV .AND.  &
              MWK(START(MA)+3) == MWK(START(MB)+3) .AND. MWK(START(MA)) == MWK(START(MB))) THEN
              KFLAG = -4
              NAMEST(NCALL) = 'IMDIM'
              CALL FMWARN
              CALL IMST2M('UNKNOWN',MC)
              GO TO 110
          ENDIF
      ENDIF

      IF (IMCOMP(MA,'>=',MB)) THEN
          CALL IMSUB(MA,MB,MC)
          IF (KFLAG == 1) KFLAG = 0
      ELSE
          MWK(START(MC)+2) = 0
          MWK(START(MC)+3) = 0
          MWK(START(MC)+4) = 0
          MWK(START(MC)) = 1
          MWK(START(MC)+1) = NINT(10**7*ALOGM2)
      ENDIF

      IF (MWK(START(MC)+2) >= MEXPOV) THEN
          IF (MWK(START(MC)+2) == MUNKNO) THEN
              KFLAG = -4
              NAMEST(NCALL) = 'IMDIM'
              CALL FMWARN
          ELSE IF (NCALL == 1 .OR. MWK(START(MC)+2) >= MEXPOV) THEN
              IF (MWK(START(MC)) > 0) THEN
                  CALL IMST2M('OVERFLOW',MC)
              ELSE
                  CALL IMST2M('-OVERFLOW',MC)
              ENDIF
              KFLAG = -5
              NAMEST(NCALL) = 'IMDIM'
              IF (KOVFL /= 1) CALL FMWARN
          ENDIF
      ENDIF

  110 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMDIM

      SUBROUTINE IMDIV(MA,MB,MC)

!  MC = INT(MA/MB)

!  Use IMDIVR if both INT(MA/MB) and MOD(MA,MB) are needed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = MWK(START(MA)+2) - MWK(START(MB)+2) + 6
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMDIV    ',2,MA,MB)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMDIV'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
          GO TO 110
      ENDIF

      KREM = 0
      CALL IMDIVR(MA,MB,MC,MXY(1))
      KREM = 1

      IF (MWK(START(MC)+2) == MUNKNO) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMDIV'
          CALL FMWARN
      ENDIF

  110 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMDIV

      SUBROUTINE IMDIVI(MA,IDIV,MB)

!  MB = INT(MA/IDIV)

!  Use IMDVIR if both INT(MA/IDIV) and MOD(MA,IDIV) are needed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IDIV,IREM,NDSAVE
      INTENT (IN) :: MA,IDIV
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MAX(5,INT(MWK(START(MA)+2)+3))
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMDIVI   ',1,MA,MA)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMDIVI'
          CALL IMNTR(2,MA,MA,1)
          CALL IMNTRI(2,IDIV,0)
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MB)
          KFLAG = -4
          GO TO 110
      ENDIF

      CALL IMDVIR(MA,IDIV,MB,IREM)

      IF (MWK(START(MB)+2) == MUNKNO) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMDIVI'
          CALL FMWARN
      ENDIF

  110 IF (MWK(START(MB)+2) <= 1) MWK(START(MB)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMDIVI

      SUBROUTINE IMDIVR(MA,MB,MC,MD)

!  MC = INT(MA / MB),    MD = Remainder from the division.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD
      REAL (KIND(1.0D0)) :: MDA,MDAB,MDB,MDR
      DOUBLE PRECISION :: XB,XBR,XBASE,XMWA
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MAXMWA,MB1,MBM1,MBS,MCARRY,MKT,MLMAX,MQD
      INTEGER :: J,JB,JL,JMB,JMWA,K,KA,KB,KL,KLTFLG,KPTMWA,LCRRCT,NA1,NB1,ND,NDSAVE,NGUARD,NL,  &
                 NMBWDS,NMETHD,NTRSAV
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC,MD
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = MWK(START(MA)+2) - MWK(START(MB)+2) + 6
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = MAX(5,INT(MWK(START(MB)+2)+3)) + 2
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = MWK(START(MA)+2) + 5
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      IF (MD <= 0) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ELSE IF (SIZE_OF(MD) < RESULT_SIZE) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      RESULT_SIZE = 2*MWK(START(MA)+2) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMDIVR   ',2,MA,MB)
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMDIVR'
          CALL IMNTR(2,MA,MB,2)
      ENDIF
      KFLAG = 0
      NTRSAV = NTRACE
      NTRACE = 0
      IF (MBLOGS /= MBASE) CALL FMCONS

!             Check for special cases.

      IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MA)+2) /= MUNKNO) THEN
          IF (MWK(START(MB))*MWK(START(MB)+3) == 1) THEN
              CALL IMEQ(MA,MC)
              MWK(START(MD)+2) = 0
              MWK(START(MD)+3) = 0
              MWK(START(MD)+4) = 0
              MWK(START(MD)) = 1
              MWK(START(MD)+1) = NINT(10**7*ALOGM2)
              GO TO 170
          ELSE IF (MWK(START(MB))*MWK(START(MB)+3) == -1) THEN
              CALL IMEQ(MA,MC)
              IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
                  MWK(START(MC)) = -MWK(START(MC))
              MWK(START(MD)+2) = 0
              MWK(START(MD)+3) = 0
              MWK(START(MD)+4) = 0
              MWK(START(MD)) = 1
              MWK(START(MD)+1) = NINT(10**7*ALOGM2)
              GO TO 170
          ENDIF
      ENDIF
      IF (MWK(START(MA)+2) < MWK(START(MB)+2) .AND. MWK(START(MB)+2) /= MUNKNO) GO TO 110
      IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR. MWK(START(MB)+3) == 0 .OR.  &
          MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO) THEN
              NAMEST(NCALL) = 'IMDIVR'
              CALL FMWARN
          ENDIF
          CALL IMST2M('UNKNOWN',MC)
          CALL IMST2M('UNKNOWN',MD)
          GO TO 170
      ENDIF
      IF (MWK(START(MA)+2) <= 2) THEN
          IF (MWK(START(MB)+2) > 2) GO TO 110
          IF (MWK(START(MB)+3) == 0) GO TO 110
          IF (MWK(START(MA)+2) <= 1) THEN
              MDA = MWK(START(MA)) * MWK(START(MA)+3)
          ELSE
              MDA = MWK(START(MA)) * (MWK(START(MA)+3)*MBASE + MWK(START(MA)+4))
          ENDIF
          IF (MWK(START(MB)+2) <= 1) THEN
              MDB = MWK(START(MB)) * MWK(START(MB)+3)
          ELSE
              MDB = MWK(START(MB)) * (MWK(START(MB)+3)*MBASE + MWK(START(MB)+4))
          ENDIF
          MDAB = AINT (MDA / MDB)
          MDR = MDA - MDAB*MDB
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MC)+1) = NINT(10**7*ALOGM2)
              MWK(START(MC)+2) = 1
              IF (MDAB == 0) MWK(START(MC)+2) = 0
              IF (MDAB >= 0) THEN
                  MWK(START(MC)+3) = MDAB
                  MWK(START(MC)) = 1
              ELSE
                  MWK(START(MC)+3) = -MDAB
                  MWK(START(MC)) = -1
              ENDIF
              MWK(START(MC)+4) = 0
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MC)+1) = NINT(10**7*ALOGM2)
              MWK(START(MC)+2) = 2
              IF (MDAB >= 0) THEN
                  MWK(START(MC)+3) = AINT (MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = 1
              ELSE
                  MWK(START(MC)+3) = AINT (-MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(-MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = -1
              ENDIF
          ELSE
              GO TO 110
          ENDIF
          IF (ABS(MDR) < MBASE) THEN
              MWK(START(MD)+1) = MWK(START(MC)+1)
              MWK(START(MD)+2) = 1
              IF (MDR == 0) MWK(START(MD)+2) = 0
              IF (MDR >= 0) THEN
                  MWK(START(MD)+3) = MDR
                  MWK(START(MD)) = 1
              ELSE
                  MWK(START(MD)+3) = -MDR
                  MWK(START(MD)) = -1
              ENDIF
              MWK(START(MD)+4) = 0
              GO TO 170
          ELSE IF (ABS(MDR) < MBASE*MBASE) THEN
              MWK(START(MD)+1) = MWK(START(MC)+1)
              MWK(START(MD)+2) = 2
              IF (MDR >= 0) THEN
                  MWK(START(MD)+3) = AINT (MDR/MBASE)
                  MWK(START(MD)+4) = ABS(MDR - MBASE*MWK(START(MD)+3))
                  MWK(START(MD)) = 1
              ELSE
                  MWK(START(MD)+3) = AINT (-MDR/MBASE)
                  MWK(START(MD)+4) = ABS(-MDR - MBASE*MWK(START(MD)+3))
                  MWK(START(MD)) = -1
              ENDIF
              GO TO 170
          ENDIF
      ENDIF

  110 KLTFLG = 0
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      KL = INT(MWK(START(MB)+2))
      IF (ABS(KL) >= MEXPOV) KL = 2
      RESULT_SIZE = ABS(MWK(START(MB)+2)) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      CALL IMDEFINE(MXY(1),RESULT_SIZE)
      DO J = 0, KL+1
         MWK(START(MXY(1))+J+1) = MWK(START(MB)+J+1)
      ENDDO
      MWK(START(MXY(1))) = 1
      IF (KL == 1) MWK(START(MXY(1))+4) = 0
      IF (MWK(START(MA)+2) == MWK(START(MXY(1))+2) .AND.  &
          ABS(MWK(START(MA)+3)) <= MWK(START(MXY(1))+3)) THEN
          DO J = 2, KL+1
             IF (MWK(START(MA)+J+1) /= MWK(START(MXY(1))+J+1)) GO TO 120
          ENDDO
          KLTFLG = 2
  120     IF (KLTFLG == 0) THEN
              DO J = 2, KL+1
                 IF (MWK(START(MA)+J+1) < MWK(START(MXY(1))+J+1)) THEN
                     KLTFLG = 1
                     EXIT
                 ELSE IF (MWK(START(MA)+J+1) > MWK(START(MXY(1))+J+1)) THEN
                     EXIT
                 ENDIF
              ENDDO
          ENDIF
      ENDIF
      IF (MWK(START(MA)+2) < MWK(START(MB)+2) .OR. KLTFLG >= 1) THEN
          IF (KLTFLG /= 2) THEN
              CALL IMEQ(MA,MD)
              MWK(START(MD)) = ABS(MWK(START(MD)))
              CALL IMI2M(0,MC)
          ELSE
              CALL IMI2M(1,MC)
              CALL IMI2M(0,MD)
          ENDIF
          GO TO 160
      ENDIF

      NDIG = INT(MWK(START(MA)+2)) + 2
      IF (NDIG < 2) NDIG = 2

!             Check for using an FFT-based method if precision is very high.

      ND = 1000
      IF (INT(MWK(START(MA)+2))-INT(MWK(START(MB)+2)) >= ND) THEN
          NMETHD = 2
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          CALL IMI2FM(MA,MXY(1))
          MWK(START(MXY(1))) = 1
          CALL IMI2FM(MB,MXY(2))
          MWK(START(MXY(2))) = 1
          CALL FMDIV(MXY(1),MXY(2),MXY(3))
          CALL IMFM2I(MXY(3),MC)
          IF (KREM /= 1) THEN
              CALL IMI2M(0,MD)
          ELSE
              CALL IMABS(MA,MXY(1))
              CALL IMABS(MB,MXY(2))
              CALL IMMPY(MC,MXY(2),MXY(3))
              CALL IMSUB(MXY(1),MXY(3),MXY(4))
              CALL IMEQ(MXY(4),MD)
              IF (MWK(START(MD)) == -1) THEN
                  CALL IMI2M(1,MXY(3))
                  CALL IMSUB(MC,MXY(3),MXY(4))
                  CALL IMEQ(MXY(4),MC)
                  CALL IMADD(MD,MXY(2),MXY(4))
                  CALL IMEQ(MXY(4),MD)
              ELSE IF (IMCOMP(MD,'>=',MXY(2))) THEN
                  CALL IMI2M(1,MXY(3))
                  CALL IMADD(MC,MXY(3),MXY(4))
                  CALL IMEQ(MXY(4),MC)
                  CALL IMSUB(MD,MXY(2),MXY(4))
                  CALL IMEQ(MXY(4),MD)
              ENDIF
          ENDIF
          GO TO 160
      ENDIF

      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)

!             NGUARD is the number of guard digits used.

      NGUARD = 1
      NA1 = INT(MWK(START(MA)+2)) + 1
      NB1 = INT(MWK(START(MB)+2)) + 1

!             Copy MA into the working array.

      DO J = 3, NA1
         MWK(START(MWA)+J+2) = MWK(START(MA)+J+1)
      ENDDO
      MWK(START(MWA)+2) = MWK(START(MA)+2) - MWK(START(MB)+2) + 1
      MWK(START(MWA)+3) = 0
      NL = NA1 + NGUARD + 3
      DO J = NA1+2, NL
         MWK(START(MWA)+J+1) = 0
      ENDDO

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MB1 = MWK(START(MB)+2)
      MBS = MWK(START(MB))
      MWK(START(MWA)+4) = MWK(START(MA)+3)

!             NMBWDS is the number of words of MB used to compute the estimated quotient digit MQD.

      NMBWDS = 4
      IF (MBASE < 100) NMBWDS = 7

!             XB is an approximation of MB used in estimating the quotient digits.

      XBASE = DBLE(MBASE)
      XB = 0
      JL = NMBWDS
      IF (JL <= NB1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MWK(START(MB)+J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= NB1) THEN
                 XB = XB*XBASE + DBLE(MWK(START(MB)+J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= NB1) THEN
          XB = XB + DBLE(MWK(START(MB)+JL+2))/XBASE
      ENDIF
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBM1 = MBASE - 1
      MLMAX = MAXINT/MBM1
      MKT = INTMAX - MBASE
      MLMAX = MIN(MLMAX,MKT)

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.
!             It is used to determine whether normalization can be postponed.

      MAXMWA = 0

!             KPTMWA points to the next digit in the quotient.

      KPTMWA = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in estimating quotient digits.

  130 KL = KPTMWA + NMBWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMWA+1))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMWA+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQD is the estimated quotient digit.

      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1

      IF (MQD > 0) THEN
          MAXMWA = MAXMWA + MQD
      ELSE
          MAXMWA = MAXMWA - MQD
      ENDIF

!             See if MWA must be normalized.

      KA = KPTMWA + 1
      KB = KA + INT(MB1) - 1
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          IF (KL <= NL) THEN
              DO J = KPTMWA, KL
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
              ENDDO
          ELSE
              DO J = KPTMWA, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQD = AINT(XMWA*XBR)
          IF (MQD < 0) MQD = MQD - 1
          IF (MQD > 0) THEN
              MAXMWA = MQD
          ELSE
              MAXMWA = -MQD
          ENDIF
      ENDIF

!             Subtract MQD*MB from MWA.

      JB = KA - 2
      IF (MQD /= 0) THEN

!             Major (Inner Loop)

          JMB = START(MB) + 1 - JB
          JMWA = START(MWA) + 1
          DO J = KA, KB
             MWK(JMWA+J) = MWK(JMWA+J) - MQD*MWK(JMB+J)
          ENDDO
      ENDIF

      MWK(START(MWA)+KA+1) = MWK(START(MWA)+KA+1) + MWK(START(MWA)+KA)*MBASE
      MWK(START(MWA)+KPTMWA+1) = MQD

      KPTMWA = KPTMWA + 1
      IF (KPTMWA-2 < MWK(START(MWA)+2)) GO TO 130

!             Final normalization.

      KPTMWA = KPTMWA - 1
      DO J = KPTMWA, 3, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
      ENDDO

      LCRRCT = 0
  140 DO J = KPTMWA+INT(MB1), KPTMWA+2, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
      ENDDO

!             Due to rounding, the remainder may not be between 0 and ABS(MB) here.
!             Correct if necessary.

      IF (MWK(START(MWA)+KA+1) < 0) THEN
          LCRRCT = LCRRCT - 1
          DO J = KA, KB
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MWK(START(MB)+J-JB+1)
          ENDDO
          GO TO 140
      ELSE IF (MWK(START(MWA)+KA+1) >= MBASE) THEN
          LCRRCT = LCRRCT + 1
          DO J = KA, KB
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MWK(START(MB)+J-JB+1)
          ENDDO
          GO TO 140
      ENDIF
      IF (MWK(START(MWA)+3) /= 0 .OR. KPTMWA == 2) THEN
          DO J = 1, INT(MWK(START(MWA)+2))+1
             MWK(START(MC)+J+1) = MWK(START(MWA)+J+1)
          ENDDO
      ELSE
          DO J = 3, INT(MWK(START(MWA)+2))+1
             MWK(START(MC)+J) = MWK(START(MWA)+J+1)
          ENDDO
          IF (MWK(START(MC)+3) /= 0) THEN
              MWK(START(MC)+2) = MWK(START(MWA)+2) - 1
          ELSE
              MWK(START(MC)+2) = 0
          ENDIF
      ENDIF
      IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      MWK(START(MC)+1) = MIN(MACCA,MACCB)
      MWK(START(MC)) = 1

      IF (MWK(START(MWA)+KPTMWA+2) /= 0) THEN
          DO J = 1, INT(MB1)
             MWK(START(MD)+J+2) = MWK(START(MWA)+J+KPTMWA+1)
          ENDDO
          MWK(START(MD)+2) = MB1
      ELSE
          DO J = 1, INT(MB1)
             IF (MWK(START(MWA)+J+KPTMWA+1) /= 0) THEN
                 DO K = J, INT(MB1)
                    MWK(START(MD)+K-J+3) = MWK(START(MWA)+K+KPTMWA+1)
                 ENDDO
                 MWK(START(MD)+2) = MB1 + 1 - J
                 GO TO 150
             ENDIF
          ENDDO
          MWK(START(MD)+2) = 0
          MWK(START(MD)+3) = 0
      ENDIF
  150 IF (MWK(START(MD)+2) <= 1) MWK(START(MD)+4) = 0
      MWK(START(MD)+1) = MIN(MACCA,MACCB)
      MWK(START(MD)) = 1

!             If the remainder had to be corrected, make the corresponding adjustment in
!             the quotient.

      IF (MWK(START(MD)+2) > MWK(START(MXY(1))+2) .OR.    &
         (MWK(START(MD)+2) == MWK(START(MXY(1))+2) .AND.  &
          ABS(MWK(START(MD)+3)) >= MWK(START(MXY(1))+3))) THEN
          IF (IMCOMP(MD,'>=',MXY(1))) THEN
              CALL IMSUB(MD,MXY(1),MXY(3))
              CALL IMEQ(MXY(3),MD)
              LCRRCT = LCRRCT + 1
          ENDIF
      ENDIF
      IF (LCRRCT /= 0) THEN
          CALL IMI2M(LCRRCT,MXY(2))
          CALL IMADD(MXY(2),MC,MXY(3))
          CALL IMEQ(MXY(3),MC)
      ENDIF

  160 MWK(START(MC)) = 1
      MWK(START(MD)) = 1
      IF (MAS < 0 .AND. MBS > 0) THEN
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1
          IF (MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0) MWK(START(MD)) = -1
      ELSE IF (MAS > 0 .AND. MBS < 0)  THEN
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1
      ELSE IF (MAS < 0 .AND. MBS < 0)  THEN
          IF (MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0) MWK(START(MD)) = -1
      ENDIF

  170 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (MWK(START(MD)+2) <= 1) MWK(START(MD)+4) = 0
      NTRACE = NTRSAV
      IF (NTRACE /= 0) THEN
          CALL IMNTR(1,MC,MC,1)
          IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  NDIG = MAX(2,INT(MWK(START(MD)+2)))
                  NTRSAV = NTRACE
                  CALL IMNTRJ(MD,NDIG)
                  NTRACE = NTRSAV
              ELSE
                  CALL IMPRNT(MD)
              ENDIF
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMDIVR

      SUBROUTINE IMDVIR(MA,IDIV,MB,IREM)

!  MB = INT(MA / IDIV),    IREM = Remainder from the division.

!  Division by a one word integer.  The remainder is also a one word integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAS,MDA,MDAB,MDB,MDR,MKT,MODINT,MVALP
      INTEGER :: IDIV,IREM,J,JDIV,JMA,JMWA,KA,KL,KLTFLG,KPT,N1,NDSAVE,NMVAL,NTRSAV,NV2
      INTENT (IN) :: MA,IDIV
      INTENT (INOUT) :: MB,IREM
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MAX(5,INT(MWK(START(MA)+2)+5))
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      RESULT_SIZE = 2*MWK(START(MA)+2) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMDVIR   ',1,MA,MA)
      KFLAG = 0
      NDSAVE = NDIG
      KLTFLG = 0
      NTRSAV = NTRACE
      NTRACE = 0
      MKT = ABS(IDIV)
      IF (MKT < MBASE) THEN
          CALL IMDEFINE(MXY(1),5)
          MWK(START(MXY(1))+1) = MWK(START(MA)+1)
          MWK(START(MXY(1))+2) = 1
          MWK(START(MXY(1))+3) = ABS(IDIV)
          MWK(START(MXY(1))+4) = 0
          MWK(START(MXY(1))) = 1
          IF (IDIV < 0) MWK(START(MXY(1))) = -1
      ELSE IF (MKT < MBASE*MBASE) THEN
          CALL IMDEFINE(MXY(1),6)
          MWK(START(MXY(1))+1) = MWK(START(MA)+1)
          MWK(START(MXY(1))+2) = 2
          MWK(START(MXY(1))+3) = INT(MKT/MBASE)
          MWK(START(MXY(1))+4) = MKT - MWK(START(MXY(1))+3)*MBASE
          MWK(START(MXY(1))+5) = 0
          MWK(START(MXY(1))) = 1
          IF (IDIV < 0) MWK(START(MXY(1))) = -1
      ELSE
          CALL IMI2M(IDIV,MXY(1))
      ENDIF
      NTRACE = NTRSAV
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMDVIR'
          CALL IMNTR(2,MA,MA,1)
          CALL IMNTRI(2,IDIV,0)
      ENDIF
      JDIV = ABS(IDIV)

!             Check for special cases.

      IF (MWK(START(MA)+2) < 0) THEN
          IREM = IUNKNO
          KFLAG = -4
          NAMEST(NCALL) = 'IMDVIR'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MB)
          GO TO 150
      ENDIF
      IF (JDIV == 1 .AND. MWK(START(MA)+2) /= MUNKNO) THEN
          IF (IDIV == 1) THEN
              CALL IMEQ(MA,MB)
              IREM = 0
              GO TO 150
          ELSE
              CALL IMEQ(MA,MB)
              IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
                  MWK(START(MB)) = -MWK(START(MB))
              IREM = 0
              GO TO 150
          ENDIF
      ENDIF
      IF (MWK(START(MA)+2) >= MEXPOV .OR. IDIV == 0) THEN
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO) THEN
              NAMEST(NCALL) = 'IMDVIR'
              CALL FMWARN
          ENDIF
          CALL IMST2M('UNKNOWN',MB)
          IREM = IUNKNO
          GO TO 150
      ENDIF
      IF (MWK(START(MA)+2) <= 2) THEN
          IF (MWK(START(MA)+2) <= 1) THEN
              MDA = MWK(START(MA)) * MWK(START(MA)+3)
          ELSE
              MDA = MWK(START(MA)) * (MWK(START(MA)+3)*MBASE + MWK(START(MA)+4))
          ENDIF
          MDB = IDIV
          MDAB = AINT (MDA/MDB)
          MDR = MDA - MDAB*MDB
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 1
              IF (MDAB == 0) MWK(START(MB)+2) = 0
              IF (MDAB < 0) THEN
                  MWK(START(MB)+3) = -MDAB
                  MWK(START(MB)) = -1
              ELSE
                  MWK(START(MB)+3) = MDAB
                  MWK(START(MB)) = 1
              ENDIF
              MWK(START(MB)+4) = 0
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 2
              IF (MDAB < 0) THEN
                  MWK(START(MB)+3) = AINT (-MDAB/MBASE)
                  MWK(START(MB)+4) = ABS(-MDAB - MBASE*MWK(START(MB)+3))
                  MWK(START(MB)) = -1
              ELSE
                  MWK(START(MB)+3) = AINT (MDAB/MBASE)
                  MWK(START(MB)+4) = ABS(MDAB - MBASE*MWK(START(MB)+3))
                  MWK(START(MB)) = 1
              ENDIF
          ELSE
              GO TO 110
          ENDIF
          IREM = INT(MDR)
          GO TO 150
      ENDIF

  110 MAS = MWK(START(MA))
      MWK(START(MXY(1))) = 1
      KL = MWK(START(MXY(1))+2)
      IF (MWK(START(MA)+2) <= MWK(START(MXY(1))+2)) THEN
          IF (MWK(START(MA)+2) == MWK(START(MXY(1))+2) .AND.  &
              ABS(MWK(START(MA)+3)) <= MWK(START(MXY(1))+3)) THEN
              DO J = 2, KL+1
                 IF (MWK(START(MA)+J+1) /= MWK(START(MXY(1))+J+1)) THEN
                     IF (MWK(START(MA)+J+1) < MWK(START(MXY(1))+J+1)) KLTFLG = 1
                     GO TO 120
                 ENDIF
              ENDDO
              KLTFLG = 2
          ENDIF
  120     IF (MWK(START(MA)+2) < MWK(START(MXY(1))+2) .OR. KLTFLG >= 1) THEN
              IF (KLTFLG /= 2) THEN
                  CALL IMM2I(MA,IREM)
                  IREM = ABS(IREM)
                  CALL IMI2M(0,MB)
              ELSE
                  CALL IMI2M(1,MB)
                  IREM = 0
              ENDIF
              GO TO 140
          ENDIF
      ENDIF
      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      N1 = INT(MWK(START(MA)+2)) + 1

!             If ABS(IDIV) >= MXBASE use IMDIVR.

      MVALP = ABS(IDIV)
      NMVAL = INT(MVALP)
      NV2 = NMVAL - 1
      IF (ABS(IDIV) > MXBASE .OR. NMVAL /= ABS(IDIV) .OR. NV2 /= ABS(IDIV)-1) THEN
          CALL IMI2M(IDIV,MXY(2))
          CALL IMDIVR(MA,MXY(2),MB,MXY(3))
          CALL IMEQ(MXY(3),MXY(2))
          CALL IMM2I(MXY(2),IREM)
          GO TO 150
      ENDIF

!             Find the first significant digit of the quotient.

      MKT = MWK(START(MA)+3)
      IF (MKT >= MVALP) THEN
          KPT = 2
          GO TO 130
      ENDIF
      DO J = 3, N1
         MKT = MKT*MBASE + MWK(START(MA)+J+1)
         IF (MKT >= MVALP) THEN
             KPT = J
             GO TO 130
         ENDIF
      ENDDO

      CALL IMM2I(MA,IREM)
      CALL IMI2M(0,MB)
      GO TO 150

!             Do the rest of the division.

  130 KA = KPT + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + 2 - KPT
      MWK(START(MWA)+3) = INT (MKT/MVALP)
      MODINT = MKT - MWK(START(MWA)+3)*MVALP
      IF (KA <= N1) THEN
          KL = 3 - KA

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1 + KL
          DO J = KA, N1
             MKT = MODINT*MBASE + MWK(JMA+J)
             MWK(JMWA+J) = INT (MKT/MVALP)
             MODINT = MKT - MWK(JMWA+J)*MVALP
          ENDDO
      ENDIF

      MWK(START(MB)+1) = MWK(START(MA)+1)
      DO J = 1, INT(MWK(START(MWA)+2))+1
         MWK(START(MB)+J+1) = MWK(START(MWA)+J+1)
      ENDDO
      IREM = INT(MODINT)

  140 MWK(START(MB)) = 1
      IF (MAS < 0 .AND. IDIV > 0) THEN
          IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0) MWK(START(MB)) = -1
          IREM = -IREM
      ELSE IF (MAS > 0 .AND. IDIV < 0)  THEN
          IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0) MWK(START(MB)) = -1
      ELSE IF (MAS < 0 .AND. IDIV < 0)  THEN
          IREM = -IREM
      ENDIF

  150 IF (MWK(START(MB)+2) <= 1) MWK(START(MB)+4) = 0
      IF (NTRACE /= 0 .AND. NCALL <= LVLTRC) THEN
          CALL IMNTR(1,MB,MB,1)
          CALL IMNTRI(1,IREM,0)
      ENDIF

      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMDVIR

      SUBROUTINE IMEQ(MA,MB)

!  MB = MA

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: J,KDG
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MWK(START(MA)+2)+3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF

      KDG = MAX(2,INT(MWK(START(MA)+2))) + 1
      IF (KDG > SIZE_OF(MA)-2) KDG = 3
      DO J = -1, KDG
         MWK(START(MB)+J+1) = MWK(START(MA)+J+1)
      ENDDO
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMEQ

      SUBROUTINE IMFACT(N,MA)

!  MA = N!   (N factorial)  N is a machine precision integer and MA is an IM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N,MA
      INTENT (IN) :: N
      INTENT (INOUT) :: MA
      INTEGER :: J,K,NDSAVE,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      K = MAX(N,2)
      RESULT_SIZE = 10 + (LOG(2.0D0*DPPI*K)/2 + K*LOG(DBLE(K)) - K) / DLOGMB
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MA <= 0) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMFACT'
          CALL  IMNTRI(2,N,1)
      ENDIF

!             Check for special cases.

      IF (N < 0) THEN
          CALL IMST2M('UNKNOWN',MA)
          KFLAG = -4
          GO TO 110
      ELSE IF (N <= 12) THEN
          K = 1
          DO J = 2, N
             K = K*J
          ENDDO
          CALL IMI2M(K,MA)
          GO TO 110
      ENDIF

      CALL IMFACT_P(2,N,MA)

  110 IF (MWK(START(MA)+2) <= 1) MWK(START(MA)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMFACT

      RECURSIVE SUBROUTINE IMFACT_P(A,B,MP)

!  This routine does the binary splitting for computing N!
!  MP = A * (A+1) * ... * B.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MP
      INTEGER :: A,B
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MP
      INTEGER :: MXY(2),NUMBER_USED_SAVE,J,M
      REAL (KIND(0.0D0)) :: DA,DB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      RESULT_SIZE = ( (DB+0.5D0)*LOG(DB+1) - DB + 1/(12*(DB+1)) -  &
                    ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) ) / DLOGMB + 7
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MP <= 0) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ELSE IF (SIZE_OF(MP) < RESULT_SIZE) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (B-A < 25) THEN
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMI2M(A,MP)
          DO J = A+1, B-1, 2
             CALL IMMPYI(MP,J,MXY(1))
             CALL IMMPYI(MXY(1),J+1,MP)
          ENDDO
          IF (MOD(B-A,2) == 1) THEN
              CALL IMMPYI(MP,B,MXY(1))
              CALL IMEQ(MXY(1),MP)
          ENDIF
          GO TO 110
      ENDIF

      M = (A+B)/2
      CALL IMFACT_P(A,M,MXY(1))
      CALL IMFACT_P(M+1,B,MXY(2))
      CALL IMMPY(MXY(1),MXY(2),MP)

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMFACT_P

      SUBROUTINE IMFM2I(MA,MB)

!  MB = INT(MA)

!  Convert from real (FM) format to integer (IM) format.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      INTEGER :: J,NTRSAV,NDGSAV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MAX(5,INT(MWK(START(MA)+2)+4))
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      KFLAG = 0
      NTRSAV = NTRACE
      NTRACE = 0
      NDGSAV = NDIG
      IF (ABS(MWK(START(MA)+2)+3) >= MEXPOV) THEN
          NDIG = 2
          CALL FMEQ(MA,MB)
          NDIG = NDGSAV
      ELSE
          NDIG = MIN(NDIG,RESULT_SIZE-3)
          CALL FMINT(MA,MXY(1))
          CALL FMEQ(MXY(1),MB)
          NDIG = NDGSAV
          DO J = NDIG+2, INT(MWK(START(MA)+2))+1
             MWK(START(MB)+J+1) = 0
          ENDDO
          IF (MWK(START(MB)+2) <= 1) MWK(START(MB)+4) = 0
      ENDIF
      NTRACE = NTRSAV
      NCALL = NCALL - 1

      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMFM2I

      SUBROUTINE IMFORM(FORM,MA,STRING)

!  Convert an IM number (MA) to a character string base 10 (STRING) using character string
!  FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM,STRING
      INTEGER :: MA
      INTEGER :: NDSAVE
      INTENT (IN) :: FORM,MA
      INTENT (INOUT) :: STRING

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMFORM   ',1,MA,MA)
      KFLAG = 0
      NAMEST(NCALL) = 'IMFORM'
      NDSAVE = NDIG
      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2

      CALL FMFORM(FORM,MA,STRING)

      NCALL = NCALL - 1
      NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMFORM

      SUBROUTINE IMFPRT(FORM,MA)

!  Print an IM number (MA) on unit KW using character string FORM format.

!  FORM can be one of these types:  Iw,  Fw.d,  Ew.d,  ESw.d,  1PEw.d  for positive integers w,d.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      INTEGER :: MA
      INTEGER :: NDSAVE
      INTENT (IN) :: FORM,MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMFPRT   ',1,MA,MA)
      KFLAG = 0
      NAMEST(NCALL) = 'IMFPRT'
      NDSAVE = NDIG
      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2

      CALL FMFPRT(FORM,MA)

      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMFPRT

      SUBROUTINE IMGCD(MA,MB,MC)

!  MC is returned as the greatest common divisor of MA and MB.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(4),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2))
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMGCD    ',2,MA,MB)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMGCD'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
          GO TO 120
      ELSE IF (MWK(START(MB)+3) == 0) THEN
          CALL IMABS(MA,MC)
          GO TO 120
      ELSE IF (MWK(START(MA)+3) == 0) THEN
          CALL IMABS(MB,MC)
          GO TO 120
      ELSE IF (MWK(START(MB)+2) == 1 .AND. ABS(MWK(START(MB)+3)) == 1) THEN
          CALL IMI2M(1,MC)
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == 1 .AND. ABS(MWK(START(MA)+3)) == 1) THEN
          CALL IMI2M(1,MC)
          GO TO 120
      ELSE IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR.  &
          MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMGCD'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MC)
          GO TO 120
      ENDIF

      CALL IMABS(MA,MXY(3))
      CALL IMABS(MB,MXY(2))
      CALL IMMAX(MXY(3),MXY(2),MXY(1))
      CALL IMMIN(MXY(3),MXY(2),MXY(4))
      CALL IMEQ(MXY(4),MXY(2))
  110 CALL IMDIVR(MXY(1),MXY(2),MXY(4),MXY(3))
      IF (MWK(START(MXY(3))+3) /= 0) THEN
          CALL IMEQ(MXY(2),MXY(1))
          CALL IMEQ(MXY(3),MXY(2))
          GO TO 110
      ENDIF
      CALL IMEQ(MXY(2),MC)

      IF (MWK(START(MC)+2) == MUNKNO) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMGCD'
          CALL FMWARN
      ENDIF

  120 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMGCD

      SUBROUTINE IMI2FM(MA,MB)

!  MB = MA

!  Convert from integer (IM) format to real (FM) format.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: KDG
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMI2FM   ',1,MA,MA)
      KFLAG = 0
      KDG = MAX(2,INT(MWK(START(MA)+2)))
      CALL FMEQU(MA,MB,KDG,NDIG)
      MWK(START(MB)+1) = NINT(10**7*ALOGM2)
      NCALL = NCALL - 1

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMI2FM

      SUBROUTINE IMI2M(IVAL,MA)

!  MA = IVAL

!  This routine performs the trace printing.  IMI2M2 is used to do the conversion.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMI2M'
          CALL IMNTRI(2,IVAL,1)

          CALL IMI2M2(IVAL,MA)

          CALL IMNTR(1,MA,MA,1)
      ELSE
          CALL IMI2M2(IVAL,MA)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMI2M

      SUBROUTINE IMI2M2(IVAL,MA)

!  MA = IVAL

!  Convert a one word integer to IM format.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: IVAL

      INTEGER :: NDSAVE
      DOUBLE PRECISION :: DT
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NDSAVE = NDIG
      IF (IVAL == 0) THEN
          NDIG = 2
      ELSE
          DT = LOG(DBLE(ABS(IVAL)))/DLOGMB + 2
          NDIG = MAX(2,INT(DT))
      ENDIF
      RESULT_SIZE = NDIG + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MA <= 0) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ENDIF
      CALL FMIM(IVAL,MA)
      IF (MWK(START(MA)+2) <= 1) MWK(START(MA)+4) = 0
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMI2M2

      SUBROUTINE IMINP(LINE,MA,LA,LB)

!  Convert an array of characters to multiple precision integer format.

!  LINE is an A1 character array of length LB to be converted to IM format and returned in MA.
!  LA is a pointer telling the routine where in the array to begin the conversion.
!  LB is a pointer to the last character of the field for that number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KFSAVE,NDSAVE,LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA
      INTEGER :: NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      KFLAG = 0
      NDSAVE = NDIG
      NAMEST(NCALL) = 'IMINP'

      NDIG = 50
      NCALL = NCALL - 1
      CALL FMINP(LINE,MWI,LA,LB)
      NCALL = NCALL + 1
      IF (MWK(START(MWI)+2) > 50 .AND. ABS(MWK(START(MWI)+2)) < MEXPOV) THEN
          NDIG = MWK(START(MWI)+2) + 1
          NCALL = NCALL - 1
          CALL FMINP(LINE,MWI,LA,LB)
          NCALL = NCALL + 1
      ENDIF
      KFSAVE = KFLAG
      NUMBER_USED = NUMBER_USED_SAVE
      CALL IMFM2I(MWI,MA)
      KFLAG = KFSAVE

      IF (MWK(START(MA)+2) <= 1) MWK(START(MA)+4) = 0
      NDIG = NDSAVE
      IF (NTRACE /= 0) CALL IMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMINP

      SUBROUTINE IMM2DP(MA,X)

!  X = MA

!  Convert an IM number to double precision.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's double
!  precision number system, change the definition of DPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      DOUBLE PRECISION :: X

      INTEGER :: KRESLT,ND2,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      NCALL = NCALL + 1
      KFLAG = 0
      NAMEST(NCALL) = 'IMM2DP'
      KRESLT = 0
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMARGS('IMM2DP   ',1,MA,MA,KRESLT)
      ENDIF
      IF (NTRACE /= 0) CALL IMNTR(2,MA,MA,1)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.  Set X to some value that the user is likely
!             to recognize as wrong.

          X = DBLE(RUNKNO)
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
          IF (NTRACE /= 0) CALL IMNTRR(1,X,1)
          NCALL = NCALL - 1
          RETURN
      ENDIF

      NDSAVE = NDIG
      NDIG = MAX(2,INT(MWK(START(MA)+2)))
      ND2 = 2 - LOG(EPSILON(1.0D0))/DLOGMB
      IF (NDIG >= ND2) NDIG = ND2
      CALL FMMD(MA,X)

      IF (NTRACE /= 0) CALL IMNTRR(1,X,1)
      NDIG = NDSAVE
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE IMM2DP

      SUBROUTINE IMM2I(MA,IVAL)

!  IVAL = MA

!  Convert an IM number to a one word integer.

!  KFLAG =  0 is returned if the conversion is exact.
!        = -4 is returned if MA is larger than INTMAX in magnitude.  IVAL = IUNKNO is returned as
!             an indication that IVAL could not be computed without integer overflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA

      INTEGER :: IVAL,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMM2I    ',1,MA,MA)
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMM2I'
          CALL IMNTR(2,MA,MA,1)
      ENDIF

      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
      KFLAG = 0
      CALL FMM2I(MA,IVAL)

      IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
          CALL IMNTRI(1,IVAL,1)
      ENDIF
      NCALL = NCALL - 1
      NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMM2I

      SUBROUTINE IMM2SP(MA,X)

!  X = MA

!  Convert an IM number to single precision.

!  If KFLAG = -4 is returned for a value of MA that is in the range of the machine's single
!  precision number system, change the definition of SPMAX in routine FMSET to reflect the
!  current machine's range.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      REAL :: X

      DOUBLE PRECISION :: Y
      INTEGER :: KRESLT,ND2,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: X

      NCALL = NCALL + 1
      KFLAG = 0
      NAMEST(NCALL) = 'IMM2SP'
      KRESLT = 0
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMARGS('IMM2SP   ',1,MA,MA,KRESLT)
      ENDIF
      IF (NTRACE /= 0) CALL IMNTR(2,MA,MA,1)
      IF (KRESLT /= 0) THEN

!             Here no valid result can be returned.  Set X to some value that the user is likely
!             to recognize as wrong.

          X = RUNKNO
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO) CALL FMWARN
          Y = X
          IF (NTRACE /= 0) CALL IMNTRR(1,Y,1)
          NCALL = NCALL - 1
          RETURN
      ENDIF

      NDSAVE = NDIG
      NDIG = MAX(2,INT(MWK(START(MA)+2)))
      ND2 = 2 - LOG(EPSILON(1.0D0))/DLOGMB
      IF (NDIG >= ND2) NDIG = ND2
      CALL FMMD(MA,Y)
      X = Y

      IF (NTRACE /= 0) CALL IMNTRR(1,Y,1)
      NDIG = NDSAVE
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE IMM2SP

      SUBROUTINE IMMAX(MA,MB,MC)

!  MC = MAX(MA,MB)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMMAX    ',2,MA,MB)
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMAX'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (IMCOMP(MA,'<',MB)) THEN
          CALL IMEQ(MB,MC)
      ELSE
          CALL IMEQ(MA,MC)
      ENDIF

      IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMAX

      SUBROUTINE IMMIN(MA,MB,MC)

!  MC = MIN(MA,MB)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KWRNSV
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMMIN    ',2,MA,MB)
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMIN'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (IMCOMP(MA,'>',MB)) THEN
          CALL IMEQ(MB,MC)
      ELSE
          CALL IMEQ(MA,MC)
      ENDIF

      IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMIN

      SUBROUTINE IMMOD(MA,MB,MC)

!  MC = MOD(MA,MB)

!  Use IMDIVR if both INT(MA/MB) and MOD(MA,MB) are needed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MIN(MWK(START(MA)+2),MWK(START(MB)+2)) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMMOD    ',2,MA,MB)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMOD'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
          GO TO 110
      ENDIF

      CALL IMDIVR(MA,MB,MXY(1),MXY(2))
      CALL IMEQ(MXY(2),MC)

      IF (MWK(START(MC)+2) == MUNKNO) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMMOD'
          CALL FMWARN
      ENDIF

  110 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMOD
      SUBROUTINE IMMPY(MA,MB,MC)

!  MC = MA * MB

!  This routine performs the trace printing.  IMMPY2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMPY'
          CALL IMNTR(2,MA,MB,2)

          CALL IMMPY2(MA,MB,MC)

          CALL IMNTR(1,MC,MC,1)
      ELSE
          CALL IMMPY2(MA,MB,MC)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPY

      SUBROUTINE IMMPY2(MA,MB,MC)

!  MC = MA * MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MDAB
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = MWK(START(MA)+2) + MWK(START(MB)+2) + 4
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF

      IF (KDEBUG == 1) CALL IMARGS('IMMPY    ',2,MA,MB)
      KFLAG = 0
      NDSAVE = NDIG

      IF (MWK(START(MA)+2) <= 1) THEN
          IF (MWK(START(MB)+2) > 1) GO TO 110
          MDAB = MWK(START(MA)) * MWK(START(MA)+3) * MWK(START(MB)) * MWK(START(MB)+3)
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 1
              IF (MDAB == 0) MWK(START(MC)+2) = 0
              IF (MDAB >= 0) THEN
                  MWK(START(MC)+3) = MDAB
                  MWK(START(MC)) = 1
              ELSE
                  MWK(START(MC)+3) = -MDAB
                  MWK(START(MC)) = -1
              ENDIF
              MWK(START(MC)+4) = 0
              GO TO 120
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 2
              IF (MDAB >= 0) THEN
                  MWK(START(MC)+3) = AINT (MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = 1
              ELSE
                  MWK(START(MC)+3) = AINT (-MDAB/MBASE)
                  MWK(START(MC)+4) = ABS(-MDAB - MBASE*MWK(START(MC)+3))
                  MWK(START(MC)) = -1
              ENDIF
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          KFLAG = -4
          CALL IMI2M2(0,MC)
          MWK(START(MC)+2) = MUNKNO
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          MWK(START(MC)) = 1
          MWK(START(MC)+1) = NINT(10**7*ALOGM2)
          MWK(START(MC)+2) = 0
          MWK(START(MC)+3) = 0
          MWK(START(MC)+4) = 0
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPOV) THEN
          KFLAG = -5
          IF (MWK(START(MA))*MWK(START(MB)) < 0) THEN
              CALL IMI2M2(-1,MC)
              MWK(START(MC)+2) = MEXPOV
              MWK(START(MC)+3) = 1
              MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          ELSE
              CALL IMI2M2(1,MC)
              MWK(START(MC)+2) = MEXPOV
              MWK(START(MC)+3) = 1
              MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          ENDIF
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMMPY'
          CALL FMWARN
          CALL IMI2M2(0,MC)
          MWK(START(MC)+2) = MUNKNO
          MWK(START(MC)+3) = 1
          MWK(START(MC)+1) = NINT(NDIG*ALOGM2)
          GO TO 120
      ENDIF
      IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MB)+3) == 1 .AND. MWK(START(MB)) == 1) THEN
          CALL IMEQ(MA,MC)
          GO TO 120
      ELSE IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MB)+3) == 1 .AND. MWK(START(MB)) == -1) THEN
          CALL IMEQ(MA,MC)
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
              MWK(START(MC)) = -MWK(START(MC))
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1 .AND. MWK(START(MA)) == 1) THEN
          CALL IMEQ(MB,MC)
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1 .AND. MWK(START(MA)) == -1) THEN
          CALL IMEQ(MB,MC)
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0)  &
              MWK(START(MC)) = -MWK(START(MC))
          GO TO 120
      ENDIF
      NDIG = INT(MWK(START(MA)+2) + MWK(START(MB)+2))

      IF (NDIG < 2) NDIG = 2
      CALL IMMPY3(MA,MB)

!             Transfer to MC and fix the sign of the result.

      NDIG = MWK(START(MWA)+2)
      IF (NDIG < 2) NDIG = 2
      IF (MWK(START(MA))*MWK(START(MB)) < 0) THEN
          CALL FMMOVE(MWA,MC)
          MWK(START(MC)+1) = NINT(10**7*ALOGM2)
          MWK(START(MC)) = -1
      ELSE
          CALL FMMOVE(MWA,MC)
          MWK(START(MC)+1) = NINT(10**7*ALOGM2)
          MWK(START(MC)) = 1
      ENDIF

  120 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPY2

      SUBROUTINE IMMPY3(MA,MB)

!  Internal multiplication of MA*MB.  The result is returned in MWA.  Both MA and MB are positive.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MAXMWA,MBJ,MBM1,MKT,MMAX
      INTEGER :: J,JM1,JMA,JMWA,K,KB,KL,KLMA,KLMB,N1,ND,NMETHD,NZDA,NZDB
      INTEGER :: MXY(2),NUMBER_USED_SAVE
      INTENT (IN) :: MA,MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = 2*(MWK(START(MA)+2)+MWK(START(MB)+2)) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      N1 = NDIG + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MB)+2)
      MWK(START(MWA)+N1+2) = 0

!             Check for using an FFT-based method if precision is very high.

      ND = MAX(MWK(START(MA)+2),MWK(START(MB)+2))
      IF (LOG(7.0D0*ND/3.0D0) < LOG(7.0D3/3.0D0)*MIN(MWK(START(MA)+2),MWK(START(MB)+2))/1.0D3) THEN
          NZDA = INT(MWK(START(MA)+2))
          NZDB = INT(MWK(START(MB)+2))
          DO J = 2, INT(MWK(START(MB)+2))
             IF (MWK(START(MB)+J+2) == 0) NZDB = NZDB - 1
          ENDDO
          IF (REAL(NZDA)*NZDB < 65.0*ND*LOG(REAL(ND))) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          ND = NDIG
          NDIG = MAX(MWK(START(MA)+2),MWK(START(MB)+2))
          CALL IMI2FM(MA,MXY(1))
          CALL IMI2FM(MB,MXY(2))
          CALL FMMPYFFT(MXY(1),MXY(2))
          NDIG = ND
          NUMBER_USED = NUMBER_USED_SAVE
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             The multiplication loop begins here.

!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBM1 = MBASE - 1
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBM1 - MBM1),MMAX)
      MBJ = MWK(START(MB)+3)
      MWK(START(MWA)+3) = 0
      KLMA = INT(MWK(START(MA)+2))
      DO K = KLMA+3, N1
         MWK(START(MWA)+K+1) = 0
      ENDDO

!             (Inner Loop)

      JMA = START(MA) + 1
      JMWA = START(MWA) + 2
      DO K = 2, KLMA+1
         MWK(JMWA+K) = MWK(JMA+K)*MBJ
      ENDDO
      MAXMWA = MBJ
      KLMB = INT(MWK(START(MB)+2))
      DO J = 3, KLMB+1
         MBJ = MWK(START(MB)+J+1)
         IF (MBJ /= 0) THEN
             MAXMWA = MAXMWA + MBJ
             JM1 = J - 1
             KL = KLMA + 1

!                       Major (Inner Loop)

             JMA = START(MA) + 1 - JM1
             JMWA = START(MWA) + 1
             DO K = J+1, J+KLMA
                MWK(JMWA+K) = MWK(JMWA+K) + MWK(JMA+K)*MBJ
             ENDDO
         ENDIF

         IF (MAXMWA > MMAX) THEN
             MAXMWA = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in MWA.

             DO KB = JM1+KL, JM1+2, -1
                MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
             ENDDO
         ENDIF
      ENDDO

!             Perform the final normalization.  (Inner Loop)

      JMWA = START(MWA) + 1
      DO KB = N1, 3, -1
         MKT = INT (MWK(JMWA+KB)/MBASE)
         MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
         MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
      ENDDO

      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPY3

      SUBROUTINE IMMPYI(MA,IVAL,MB)

!  MB = MA * IVAL

!  This routine performs the trace printing.  IMMPYI2 is used to do the arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMPYI'
          CALL IMNTR(2,MA,MA,1)
          CALL IMNTRI(2,IVAL,0)

          CALL IMMPYI2(MA,IVAL,MB)

          CALL IMNTR(1,MB,MB,1)
      ELSE
          CALL IMMPYI2(MA,IVAL,MB)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPYI

      SUBROUTINE IMMPYI2(MA,IVAL,MB)

!  MB = MA * IVAL

!  Multiplication by a one word integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MAS,MCARRY,MDAB,MKT,MVAL
      DOUBLE PRECISION :: DT
      INTEGER :: IVAL,J,KA,KB,KC,KSHIFT,N1,NDSAVE,NMVAL,NV2
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DT = LOG(DBLE(ABS(IVAL)+1))/DLOGMB + 1
      RESULT_SIZE = MWK(START(MA)+2) + DT + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = 2*RESULT_SIZE + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (KDEBUG == 1) CALL IMARGS('IMMPYI   ',1,MA,MA)
      KFLAG = 0
      NDSAVE = NDIG
      MAS = MWK(START(MA))

      IF (MWK(START(MA)+2) <= 1) THEN
          MDAB = MWK(START(MA)) * MWK(START(MA)+3) * IVAL
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 1
              IF (MDAB == 0) MWK(START(MB)+2) = 0
              MWK(START(MB)) = 1
              IF (MDAB < 0) MWK(START(MB)) = -1
              MWK(START(MB)+3) = ABS(MDAB)
              MWK(START(MB)+4) = 0
              GO TO 120
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 2
              MWK(START(MB)) = 1
              IF (MDAB < 0) MWK(START(MB)) = -1
              MDAB = ABS(MDAB)
              MWK(START(MB)+3) = AINT (MDAB/MBASE)
              MWK(START(MB)+4) = MDAB - MBASE*MWK(START(MB)+3)
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

      IF (MWK(START(MA)+2) < 0) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMMPYI'
          CALL FMWARN
          CALL IMI2M2(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+2) == MUNKNO) THEN
          KFLAG = -4
          CALL IMI2M2(0,MB)
          MWK(START(MB)+2) = MUNKNO
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          GO TO 120
      ELSE IF (IVAL == 0) THEN
          CALL IMI2M2(0,MB)
          GO TO 120
      ELSE IF (IVAL == 1) THEN
          CALL IMEQ(MA,MB)
          GO TO 120
      ELSE IF (IVAL == -1) THEN
          CALL IMEQ(MA,MB)
          IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
              MWK(START(MB)) = -MWK(START(MB))
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3)*MWK(START(MA)) == 1) THEN
          CALL IMI2M2(IVAL,MB)
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3)*MWK(START(MA)) == -1) THEN
          CALL IMI2M2(IVAL,MB)
          IF (MWK(START(MB)+2) /= MUNKNO .AND. MWK(START(MB)+3) /= 0)  &
              MWK(START(MB)) = -MWK(START(MB))
          GO TO 120
      ELSE IF (MWK(START(MA)+2) == MEXPOV) THEN
          KFLAG = -5
          CALL IMI2M2(1,MB)
          MWK(START(MB)+2) = MEXPOV
          MWK(START(MB)+3) = 1
          MWK(START(MB)+1) = NINT(NDIG*ALOGM2)
          GO TO 110
      ENDIF

!             Work with positive numbers.

      MVAL = ABS(IVAL)
      NMVAL = INT(MVAL)
      NV2 = NMVAL - 1
      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      N1 = NDIG + 1

!             To leave room for normalization, shift the product to the right KSHIFT places in MWA.

      KSHIFT = INT((LOG(DBLE(MWK(START(MA)+3)+1)*DBLE(MVAL)))/DLOGMB)

!             If IVAL is too big, use IMMPY2.

      IF (KSHIFT > NDIG .OR. MVAL > MAXINT/MBASE .OR.  &
          NMVAL /= ABS(IVAL) .OR. NV2 /= ABS(IVAL)-1) THEN
          CALL IMI2M2(IVAL,MXY(1))
          CALL IMMPY2(MA,MXY(1),MB)
          GO TO 120
      ENDIF

      MWK(START(MWA)+2) = MWK(START(MA)+2) + KSHIFT
      KA = 2 + KSHIFT
      KB = N1 + KSHIFT
      KC = NDIG + 5
      DO J = KB, KC
         MWK(START(MWA)+J+1) = 0
      ENDDO

      MCARRY = 0

!             This is the main multiplication loop.

      DO J = KB, KA, -1
         MKT = MWK(START(MA)+J-KSHIFT+1)*MVAL + MCARRY
         MCARRY = INT (MKT/MBASE)
         MWK(START(MWA)+J+1) = MKT - MCARRY*MBASE
      ENDDO

!             Resolve the final carry.

      DO J = KA-1, 2, -1
         MKT = INT (MCARRY/MBASE)
         MWK(START(MWA)+J+1) = MCARRY - MKT*MBASE
         MCARRY = MKT
      ENDDO

!             Now the first significant digit in the product is in
!             MWK(START(MWA)+3) or MWK(START(MWA)+4).

      MWK(START(MB)+1) = MWK(START(MA)+1)
      IF (MWK(START(MWA)+3) == 0) THEN
          MWK(START(MB)+2) = MWK(START(MWA)+2) - 1
          DO J = 3, KB
             MWK(START(MB)+J) = MWK(START(MWA)+J+1)
          ENDDO
      ELSE
          MWK(START(MB)+2) = MWK(START(MWA)+2)
          DO J = 2, KB
             MWK(START(MB)+J+1) = MWK(START(MWA)+J+1)
          ENDDO
      ENDIF

!             Put the sign on the result.

  110 MWK(START(MB)) = 1
      IF ((IVAL > 0 .AND. MAS < 0) .OR. (IVAL < 0 .AND.MAS > 0)) MWK(START(MB)) = -1

  120 IF (MWK(START(MB)+2) <= 1) MWK(START(MB)+4) = 0
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPYI2

      SUBROUTINE IMMPYM(MA,MB,MC,MD)

!  MD = MA * MB mod MC

!  This routine is slightly faster than calling IMMPY and IMMOD separately.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD
      REAL (KIND(1.0D0)) :: MAS,MAXMWA,MBM1,MBS,MC1,MCARRY,MDC,MDAB,MKT,MLMAX,MQD
      DOUBLE PRECISION  XB,XBASE,XBR,XMWA
      INTEGER :: J,JB,JL,JMC,JMWA,K,KA,KB,KL,KLTFLG,KPTMWA,N1,NA1,NC1,NDSAVE,NGUARD,NL,NMCWDS,NTRSAV
      LOGICAL, EXTERNAL :: IMCOMP
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MWK(START(MC)+2) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MD <= 0) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ELSE IF (SIZE_OF(MD) < RESULT_SIZE) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = 2*(MWK(START(MA)+2)+MWK(START(MB)+2)) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMMPYM   ',2,MA,MB)
      NDSAVE = NDIG
      KFLAG = 0
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMMPYM'
          CALL IMNTR(2,MA,MB,2)
          IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  NDIG = MAX(2,INT(MWK(START(MC)+2)))
                  IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
                  NTRSAV = NTRACE
                  CALL IMNTRJ(MC,NDIG)
                  NTRACE = NTRSAV
                  NDIG = NDSAVE
              ELSE
                  CALL IMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF

      IF (MWK(START(MA)+2) <= 1) THEN
          IF (MWK(START(MB)+2) > 1) GO TO 110
          IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) GO TO 110
          MDAB = MWK(START(MA)) * MWK(START(MA)+3) * MWK(START(MB)) * MWK(START(MB)+3)
          IF (MWK(START(MC)+2) <= 2) THEN
              IF (MWK(START(MC)+3) == 0) GO TO 110
              IF (MWK(START(MC)+2) <= 1) THEN
                  MDC = MWK(START(MC)) * MWK(START(MC)+3)
              ELSE
                  MDC = MWK(START(MC)) * (MWK(START(MC)+3)*MBASE + MWK(START(MC)+4))
              ENDIF
              MDAB = MOD(MDAB,MDC)
          ENDIF
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MD)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1),MWK(START(MC)+1))
              MWK(START(MD)+2) = 1
              IF (MDAB == 0) MWK(START(MD)+2) = 0
              MWK(START(MD)) = 1
              IF (MDAB < 0) MWK(START(MD)) = -1
              MWK(START(MD)+3) = ABS(MDAB)
              MWK(START(MD)+4) = 0
              GO TO 160
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MD)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1),MWK(START(MC)+1))
              MWK(START(MD)+2) = 2
              MWK(START(MD)) = 1
              IF (MDAB < 0) MWK(START(MD)) = -1
              MDAB = ABS(MDAB)
              MWK(START(MD)+3) = AINT (MDAB/MBASE)
              MWK(START(MD)+4) = MDAB - MBASE*MWK(START(MD)+3)
              GO TO 160
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
          MWK(START(MC)+2) == MUNKNO) THEN
          KFLAG = -4
          CALL IMST2M('UNKNOWN',MD)
          GO TO 170
      ELSE IF (MWK(START(MC)+3) == 0 .OR. MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR.  &
               MWK(START(MC)+2) < 0 .OR. MWK(START(MA)+2) >= MEXPOV .OR.  &
               MWK(START(MB)+2) >= MEXPOV .OR. MWK(START(MC)+2) >= MEXPOV) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMMPYM'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MD)
          GO TO 170
      ELSE IF (MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          CALL IMI2M(0,MD)
          GO TO 170
      ELSE IF (MWK(START(MC)+2) == 1 .AND. MWK(START(MC)+3) == 1) THEN
          CALL IMI2M(0,MD)
          GO TO 170
      ELSE IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MB)+3) == 1 .AND. MWK(START(MB)) == 1) THEN
          CALL IMMOD(MA,MC,MD)
          GO TO 160
      ELSE IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MB)+3) == 1 .AND. MWK(START(MB)) == -1) THEN
          CALL IMMOD(MA,MC,MD)
          IF (MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0)  &
              MWK(START(MD)) = -MWK(START(MD))
          GO TO 160
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1 .AND. MWK(START(MA)) == 1) THEN
          CALL IMMOD(MB,MC,MD)
          GO TO 160
      ELSE IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1 .AND. MWK(START(MA)) == -1) THEN
          CALL IMMOD(MB,MC,MD)
          IF (MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0)  &
              MWK(START(MD)) = -MWK(START(MD))
          GO TO 160
      ENDIF

      NDIG = INT(MWK(START(MA)+2) + MWK(START(MB)+2))
      IF (NDIG < 2) NDIG = 2

!             Check for using an FFT-based method if precision is very high.

      IF (NDIG >= 1000) THEN
          CALL IMMPY(MA,MB,MXY(1))
          CALL IMMOD(MXY(1),MC,MXY(2))
          CALL IMEQ(MXY(2),MD)
          GO TO 160
      ENDIF

!             Save the sign of MA and MB and then work only with positive numbers.

      MAS = MWK(START(MA))
      MBS = MWK(START(MB))

      N1 = NDIG + 1

!             It is faster if the second argument is the one with fewer digits.

      IF (MWK(START(MA)+2) < MWK(START(MB)+2)) THEN
          CALL IMMPY3(MB,MA)
      ELSE
          CALL IMMPY3(MA,MB)
      ENDIF

!             Now do the division to find MWA mod MC.

      KLTFLG = 0
      IF (MWK(START(MWA)+3) == 0) THEN
          MWK(START(MWA)+2) = MWK(START(MWA)+2) - 1
      ELSE
          DO J = N1, 2, -1
             MWK(START(MWA)+J+2) = MWK(START(MWA)+J+1)
          ENDDO
          MWK(START(MWA)+3) = 0
      ENDIF
      KL = INT(MWK(START(MC)+2))
      RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2),MWK(START(MC)+2)) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      CALL IMDEFINE(MXY(1),RESULT_SIZE)
      CALL IMDEFINE(MXY(2),RESULT_SIZE)
      DO J = -1, KL+1
         MWK(START(MXY(1))+J+1) = MWK(START(MC)+J+1)
      ENDDO
      MWK(START(MXY(1))) = 1
      IF (MWK(START(MWA)+2) == MWK(START(MXY(1))+2) .AND.  &
          ABS(MWK(START(MWA)+4)) <= MWK(START(MXY(1))+3)) THEN
          DO J = 4, N1+1
             MWK(START(MXY(2))+J) = MWK(START(MWA)+J+1)
          ENDDO
          MWK(START(MXY(2))+3) = ABS(MWK(START(MWA)+4))
          MWK(START(MXY(2))+2) = MWK(START(MWA)+2)
          MWK(START(MXY(2))+1) = MWK(START(MC)+1)
          MWK(START(MXY(2))) = 1
          IF (IMCOMP(MXY(2),'==',MXY(1))) THEN
              KLTFLG = 2
          ELSE IF (IMCOMP(MXY(2),'<',MXY(1))) THEN
              KLTFLG = 1
          ENDIF
      ENDIF
      IF (MWK(START(MWA)+2) < MWK(START(MC)+2) .OR. KLTFLG >= 1) THEN
          IF (KLTFLG /= 2) THEN
              DO J = 3, N1+1
                 MWK(START(MD)+J) = MWK(START(MWA)+J+1)
              ENDDO
              MWK(START(MD)+2) = MWK(START(MWA)+2)
              MWK(START(MD)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1),MWK(START(MC)+1))
          ELSE
              CALL IMI2M(0,MD)
          ENDIF
          GO TO 150
      ENDIF

      NDIG = INT(MWK(START(MWA)+2))
      IF (NDIG < 2) NDIG = 2

!             NGUARD is the number of guard digits used.

      NGUARD = 1
      NA1 = INT(MWK(START(MWA)+2)) + 1
      NC1 = INT(MWK(START(MC)+2)) + 1
      MWK(START(MWA)+2) = MWK(START(MWA)+2) - MWK(START(MC)+2) + 1
      NL = NA1 + NGUARD + 3
      DO J = NA1+2, NL
         MWK(START(MWA)+J+1) = 0
      ENDDO

!             Work only with positive numbers.

      MC1 = MWK(START(MC)+2)

!             NMCWDS is the number of words of MC used to compute the estimated quotient digit MQD.

      NMCWDS = 4
      IF (MBASE < 100) NMCWDS = 7

!             XB is an approximation of MC used in estimating the quotient digits.

      XBASE = DBLE(MBASE)
      XB = 0
      JL = NMCWDS
      IF (JL <= NC1) THEN
          DO J = 2, JL
             XB = XB*XBASE + DBLE(MWK(START(MC)+J+1))
          ENDDO
      ELSE
          DO J = 2, JL
             IF (J <= NC1) THEN
                 XB = XB*XBASE + DBLE(MWK(START(MC)+J+1))
             ELSE
                 XB = XB*XBASE
             ENDIF
          ENDDO
      ENDIF
      IF (JL+1 <= NC1) THEN
          XB = XB + DBLE(MWK(START(MC)+JL+2))/XBASE
      ENDIF
      XBR = 1.0D0/XB

!             MLMAX determines when to normalize all of MWA.

      MBM1 = MBASE - 1
      MLMAX = MAXINT/MBM1
      MKT = INTMAX - MBASE
      MLMAX = MIN(MLMAX,MKT)

!             MAXMWA is an upper bound on the size of values in MWA divided by MBASE-1.
!             It is used to determine whether normalization can be postponed.

      MAXMWA = 0

!             KPTMWA points to the next digit in the quotient.

      KPTMWA = 2

!             This is the start of the division loop.

!             XMWA is an approximation of the active part of MWA used in estimating quotient digits.

  120 KL = KPTMWA + NMCWDS - 1
      IF (KL <= NL) THEN
          XMWA = ((DBLE(MWK(START(MWA)+KPTMWA+1))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+2)))*XBASE  &
                 + DBLE(MWK(START(MWA)+KPTMWA+3)))*XBASE + DBLE(MWK(START(MWA)+KPTMWA+4))
          DO J = KPTMWA+4, KL
             XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
          ENDDO
      ELSE
          XMWA = DBLE(MWK(START(MWA)+KPTMWA+1))
          DO J = KPTMWA+1, KL
             IF (J <= NL) THEN
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
             ELSE
                 XMWA = XMWA*XBASE
             ENDIF
          ENDDO
      ENDIF

!             MQD is the estimated quotient digit.

      MQD = AINT(XMWA*XBR)
      IF (MQD < 0) MQD = MQD - 1

      IF (MQD > 0) THEN
          MAXMWA = MAXMWA + MQD
      ELSE
          MAXMWA = MAXMWA - MQD
      ENDIF

!             See if MWA must be normalized.

      KA = KPTMWA + 1
      KB = KA + INT(MC1) - 1
      IF (MAXMWA >= MLMAX) THEN
          DO J = KB, KA, -1
             IF (MWK(START(MWA)+J+1) < 0) THEN
                 MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
                 MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
                 MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
                 MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
             ENDIF
          ENDDO
          XMWA = 0
          IF (KL <= NL) THEN
              DO J = KPTMWA, KL
                 XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
              ENDDO
          ELSE
              DO J = KPTMWA, KL
                 IF (J <= NL) THEN
                     XMWA = XMWA*XBASE + DBLE(MWK(START(MWA)+J+1))
                 ELSE
                     XMWA = XMWA*XBASE
                 ENDIF
              ENDDO
          ENDIF
          MQD = AINT(XMWA*XBR)
          IF (MQD < 0) MQD = MQD - 1
          IF (MQD > 0) THEN
              MAXMWA = MQD
          ELSE
              MAXMWA = -MQD
          ENDIF
      ENDIF

!             Subtract MQD*MC from MWA.

      JB = KA - 2
      IF (MQD /= 0) THEN

!             Major (Inner Loop)

          JMC = START(MC) + 1 - JB
          JMWA = START(MWA) + 1
          DO J = KA, KB
             MWK(JMWA+J) = MWK(JMWA+J) - MQD*MWK(JMC+J)
          ENDDO
      ENDIF

      MWK(START(MWA)+KA+1) = MWK(START(MWA)+KA+1) + MWK(START(MWA)+KA)*MBASE
      MWK(START(MWA)+KPTMWA+1) = MQD

      KPTMWA = KPTMWA + 1
      IF (KPTMWA-2 < MWK(START(MWA)+2)) GO TO 120

!             Final normalization.

      KPTMWA = KPTMWA - 1
      DO J = KPTMWA, 3, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
      ENDDO

  130 DO J = KPTMWA+INT(MC1), KPTMWA+2, -1
         IF (MWK(START(MWA)+J+1) < 0) THEN
             MCARRY = INT((-MWK(START(MWA)+J+1)-1)/MBASE) + 1
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ELSE IF (MWK(START(MWA)+J+1) >= MBASE) THEN
             MCARRY = -INT(MWK(START(MWA)+J+1)/MBASE)
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MCARRY*MBASE
             MWK(START(MWA)+J) = MWK(START(MWA)+J) - MCARRY
         ENDIF
      ENDDO

!             Due to rounding, the remainder may not be between 0 and ABS(MC) here.
!             Correct if necessary.

      IF (MWK(START(MWA)+KA+1) < 0) THEN
          DO J = KA, KB
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) + MWK(START(MC)+J-JB+1)
          ENDDO
          GO TO 130
      ELSE IF (MWK(START(MWA)+KA+1) >= MBASE) THEN
          DO J = KA, KB
             MWK(START(MWA)+J+1) = MWK(START(MWA)+J+1) - MWK(START(MC)+J-JB+1)
          ENDDO
          GO TO 130
      ENDIF

      IF (MWK(START(MWA)+KPTMWA+2) /= 0) THEN
          DO J = 1, INT(MC1)
             MWK(START(MD)+J+2) = MWK(START(MWA)+J+KPTMWA+1)
          ENDDO
          MWK(START(MD)+2) = MC1
      ELSE
          DO J = 1, INT(MC1)
             IF (MWK(START(MWA)+J+KPTMWA+1) /= 0) THEN
                 DO K = J, INT(MC1)
                    MWK(START(MD)+K-J+3) = MWK(START(MWA)+K+KPTMWA+1)
                 ENDDO
                 MWK(START(MD)+2) = MC1 + 1 - J
                 GO TO 140
             ENDIF
          ENDDO
          MWK(START(MD)+2) = 0
          MWK(START(MD)+3) = 0
      ENDIF
  140 IF (MWK(START(MD)+2) <= 1) MWK(START(MD)+4) = 0
      MWK(START(MD)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1),MWK(START(MC)+1))

      IF (MWK(START(MD)+2) > MWK(START(MXY(1))+2) .OR.    &
         (MWK(START(MD)+2) == MWK(START(MXY(1))+2) .AND.  &
          ABS(MWK(START(MD)+3)) >= MWK(START(MXY(1))+3))) THEN
          MWK(START(MD)) = 1
          IF (IMCOMP(MD,'>=',MXY(1))) THEN
              CALL IMSUB(MD,MXY(1),MXY(3))
              CALL IMEQ(MXY(3),MD)
          ENDIF
      ENDIF

  150 MWK(START(MD)) = 1
      IF (MAS*MBS < 0) THEN
          IF (MWK(START(MD)+2) /= MUNKNO .AND. MWK(START(MD)+3) /= 0)  &
              MWK(START(MD)) = -MWK(START(MD))
      ENDIF

  160 IF (MWK(START(MD)+2) == MUNKNO) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMMPYM'
          CALL FMWARN
      ENDIF

  170 IF (MWK(START(MD)+2) <= 1) MWK(START(MD)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMMPYM

      SUBROUTINE IMNTR(NTR,MA,MB,NARG)

!  Print IM numbers in base 10 format.  This is used for trace output from the IM routines.

!  NTR =  1 if a result of an IM call is to be printed.
!      =  2 to print input argument(s) to an IM call.

!  MA  -  the IM number to be printed.

!  MB  -  an optional second IM number to be printed.

!  NARG - the number of arguments.  NARG = 1 if only MA is to be printed, and NARG = 2 if both
!         MA and MB are to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: NARG,NDSAVE,NTR,NTRSAV
      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,MA,MB,NARG

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"(' Input to ',A)") TRIM(NAME)
      ELSE
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,  &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10)"                                            &
                    ) NAME,NCALL,INT(MBASE)
          ELSE
              WRITE (KW,  &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'KFLAG =',I3)"                           &
                    ) NAME,NCALL,INT(MBASE),KFLAG
          ENDIF
      ENDIF

      NDSAVE = NDIG
      IF (NTRACE < 0) THEN
          NDIG = MAX(2,INT(MWK(START(MA)+2)))
          IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
          NTRSAV = NTRACE
          CALL IMNTRJ(MA,NDIG)
          IF (NARG == 2) THEN
              NDIG = MAX(2,INT(MWK(START(MB)+2)))
              IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
              CALL IMNTRJ(MB,NDIG)
          ENDIF
          NTRACE = NTRSAV
      ENDIF

      IF (NTRACE > 0) THEN
          CALL IMPRNT(MA)
          IF (NARG == 2) CALL IMPRNT(MB)
      ENDIF

      NDIG = NDSAVE
      RETURN
      END SUBROUTINE IMNTR

      SUBROUTINE IMNTRI(NTR,N,KNAM)

!  Internal routine for trace output of integer variables.

!  NTR = 1 for output values
!        2 for input values

!  N     Integer to be printed.

!  KNAM  is positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,N,KNAM

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,N,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"(' Input to ',A)") TRIM(NAME)
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,"(' ',A,12X,'Call level =',I2,5X,'MBASE =',I10)")  &
                     NAME,NCALL,INT(MBASE)
          ELSE
              WRITE (KW,  &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'KFLAG =',I3)"                           &
                    ) NAME,NCALL,INT(MBASE),KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,I18)") N

      RETURN
      END SUBROUTINE IMNTRI

      SUBROUTINE IMNTRJ(MA,ND)

!  Print trace output in internal base MBASE format.  The number to be printed is in MA.

!  ND is the number of base MBASE digits to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: ND

      CHARACTER(50) :: FORM
      INTEGER :: J,L,N,N1
      INTENT (IN) :: MA,ND

      N1 = ND + 1

      L = INT(LOG10(DBLE(MBASE-1))) + 2
      N = (KSWIDE-23)/L
      IF (N > 10) N = 5*(N/5)
      IF (ND <= N) THEN
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,') ')") L+2, N-1, L
      ELSE
          WRITE (FORM,  &
                 "(' (1X,I19,I',I2,',',I3,'I',I2,'/(22X,',I3,'I',I2,')) ')"  &
                ) L+2, N-1, L, N, L
      ENDIF
      IF (INT(MWK(START(MA)+2)) >= 2) THEN
          WRITE (KW,FORM) INT(MWK(START(MA)+2)),INT(MWK(START(MA))*MWK(START(MA)+3)),  &
                          (INT(MWK(START(MA)+J+1)),J=3,N1)
      ELSE
          WRITE (KW,FORM) INT(MWK(START(MA)+2)),INT(MWK(START(MA))*MWK(START(MA)+3)),  &
                          (0,J=3,N1)
      ENDIF

      RETURN
      END SUBROUTINE IMNTRJ

      SUBROUTINE IMNTRR(NTR,X,KNAM)

!  Internal routine for trace output of real variables.

!  NTR - 1 for output values
!        2 for input values

!  X   - Double precision value to be printed if NX == 1

!  KNAM - Positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,KNAM
      DOUBLE PRECISION :: X

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,X,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"(' Input to ',A)") TRIM(NAME)
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,"(' ',A,12X,'Call level =',I2,5X,'MBASE =',I10)") NAME,NCALL,INT(MBASE)
          ELSE
              WRITE (KW,  &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'KFLAG =',I3)"                           &
                    ) NAME,NCALL,INT(MBASE),KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,D30.20)") X

      RETURN
      END SUBROUTINE IMNTRR

      SUBROUTINE IMOUT(MA,LINE,LB)

!  Convert an integer multiple precision number to a character array for output.

!  MA   is an IM number to be converted to an A1 character array in base 10 format.
!  LINE is the character(1) array in which the result is returned.
!  LB   is the length of LINE.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: JF1SAV,JF2SAV,LB,NDSAVE
      CHARACTER :: LINE(LB)
      INTEGER :: MA
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMOUT    ',1,MA,MA)
      KFLAG = 0
      NDSAVE = NDIG
      NAMEST(NCALL) = 'IMOUT'

      NDSAVE = NDIG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      JFORM1 = 2
      JFORM2 = 0
      NDIG = MAX(2,INT(MWK(START(MA)+2)))
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
      CALL FMOUT(MA,LINE,LB)

      NDIG = NDSAVE
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE IMOUT

      SUBROUTINE IMPACK(MA,MP)

!  MA is packed two base MBASE digits per word and returned in MP.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP,KMA1
      INTENT (IN) :: MA
      INTENT (INOUT) :: MP

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MWK(START(MA)+2)/2 + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV/2) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MP <= 0) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ELSE IF (SIZE_OF(MP) < RESULT_SIZE) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ENDIF

      KMA1 = INT(MWK(START(MA)+2))
      IF (KMA1 <= 2) KMA1 = 2
      IF (ABS(KMA1) >= MEXPOV) KMA1 = 2
      KP = 2
      MWK(START(MP)+1) = MWK(START(MA)+1)
      MWK(START(MP)+2) = MWK(START(MA)+2)
      MWK(START(MP)+3) = ABS(MWK(START(MA)+3))*MBASE + MWK(START(MA)+4)
      MWK(START(MP)) = 1
      IF (MWK(START(MA)) < 0) MWK(START(MP)) = -1
      IF (KMA1 >= 4) THEN
          DO J = 4, KMA1, 2
             KP = KP + 1
             MWK(START(MP)+KP+1) = MWK(START(MA)+J+1)*MBASE + MWK(START(MA)+J+2)
          ENDDO
      ENDIF
      IF (MOD(KMA1,2) == 1) MWK(START(MP)+KP+2) = MWK(START(MA)+KMA1+2)*MBASE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMPACK

      SUBROUTINE IMPMOD(MA,MB,MC,MD)

!  MD = MOD(MA**MB,MC)

!  The binary multiplication method used requires an average of 1.5 * LOG2(MB) operations.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC,MD
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MBS
      INTEGER :: IREM,KWRNSV,NDSAVE,NTRSAV
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      INTEGER :: MXY(6),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = MWK(START(MC)+2) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MD <= 0) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ELSE IF (SIZE_OF(MD) < RESULT_SIZE) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMPMOD   ',2,MA,MB)
      IF (KDEBUG == 1) CALL IMARGS('IMPMOD   ',1,MC,MC)
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMPMOD'
          CALL IMNTR(2,MA,MB,2)
          IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  NDIG = MAX(2,INT(MWK(START(MC)+2)))
                  IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
                  NTRSAV = NTRACE
                  CALL IMNTRJ(MC,NDIG)
                  NTRACE = NTRSAV
                  NDIG = NDSAVE
              ELSE
                  CALL IMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF
      MBS = MWK(START(MB))
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
          MWK(START(MC)+2) == MUNKNO .OR. MWK(START(MA)+2) == MEXPOV .OR.  &
          MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MC)+2) == MEXPOV .OR.  &
          MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR. MWK(START(MC)+2) < 0 .OR.  &
          (MWK(START(MB))*MWK(START(MB)+3) <= 0 .AND. MWK(START(MA)+3) == 0) .OR.  &
          MWK(START(MC)+3) == 0) THEN
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO .AND.  &
              MWK(START(MC)+2) /=MUNKNO) THEN
              NAMEST(NCALL) = 'IMPMOD'
              CALL FMWARN
          ENDIF
          CALL IMST2M('UNKNOWN',MD)
          IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
          NDIG = NDSAVE
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MB)+3) == 0) THEN
          CALL IMI2M(1,MD)
          IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
          NDIG = NDSAVE
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MB)+2) == 1 .AND. ABS(MWK(START(MB)+3)) == 1) THEN
          KWRNSV = KWARN
          KWARN = 0
          IF (MWK(START(MB)) == 1) THEN
              CALL IMMOD(MA,MC,MXY(6))
          ELSE
              CALL IMI2M(1,MXY(2))
              CALL IMDIVR(MXY(2),MA,MXY(1),MXY(3))
              CALL IMMOD(MXY(1),MC,MXY(6))
          ENDIF
          CALL IMEQ(MXY(6),MD)
          IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
          NDIG = NDSAVE
          NCALL = NCALL - 1
          KWARN = KWRNSV
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          CALL IMI2M(0,MD)
          IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
          NDIG = NDSAVE
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Initialize.

      KWRNSV = KWARN
      KWARN = 0
      CALL IMABS(MB,MXY(3))
      CALL IMDIVR(MA,MC,MXY(1),MXY(2))
      CALL IMEQ(MC,MXY(1))
      CALL IMDVIR(MXY(3),2,MXY(6),IREM)
      IF (IREM == 0) THEN
          CALL IMI2M(1,MXY(6))
      ELSE
          CALL IMEQ(MXY(2),MXY(6))
      ENDIF
      CALL IMDVIR(MXY(3),2,MXY(4),IREM)
      CALL IMEQ(MXY(4),MXY(3))

!             This is the multiplication loop.

  110 CALL IMDVIR(MXY(3),2,MXY(4),IREM)
      CALL IMEQ(MXY(4),MXY(3))
      CALL IMMPYM(MXY(2),MXY(2),MXY(1),MXY(5))
      CALL IMEQ(MXY(5),MXY(2))
      IF (IREM == 1) THEN
          CALL IMMPYM(MXY(2),MXY(6),MXY(1),MXY(5))
          CALL IMEQ(MXY(5),MXY(6))
      ENDIF
      IF (MWK(START(MXY(3))+3) > 0 .AND. MWK(START(MXY(6))+3) /= 0) GO TO 110

      IF (MBS < 0) THEN
          CALL IMI2M(1,MXY(2))
          KREM = 0
          CALL IMDIVR(MXY(2),MXY(6),MXY(4),MXY(3))
          KREM = 1
          CALL IMEQ(MXY(4),MXY(6))
      ENDIF
      KWARN = KWRNSV
      CALL IMEQ(MXY(6),MD)
      MWK(START(MD)+1) = MIN(MACCA,MACCB)
      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'IMPMOD'
          CALL FMWARN
      ENDIF
      IF (MWK(START(MD)+2) <= 1) MWK(START(MD)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MD,MD,1)
      NDIG = NDSAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMPMOD

      SUBROUTINE IMPRNT(MA)

!  Print MA in base 10 format.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA

      INTEGER :: JF1SAV,JF2SAV,NDSAVE
      INTENT (IN) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NDSAVE = NDIG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      JFORM1 = 2
      JFORM2 = 0
      NDIG = MAX(2,INT(MWK(START(MA)+2)))
      IF (ABS(MWK(START(MA)+2)) >= MEXPOV) NDIG = 2
      CALL FMPRNT(MA)
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMPRNT

      SUBROUTINE IMPWR(MA,MB,MC)

!  MC = MA ** MB

!  The binary multiplication method used requires an average of 1.5 * LOG2(MB) multiplications.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MAS,MBS
      DOUBLE PRECISION :: DA,DB
      INTEGER :: IREM,IREMB,JSIGN,KOVFL,KWRNSV
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(5),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED
      IF ((MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1) .OR.  &
          MWK(START(MA)+3) == 0 .OR. MWK(START(MB)+3) == 0) THEN
          RESULT_SIZE = 5
      ELSE
          RESULT_SIZE = 5
          KOVFL = 1
          KWRNSV = KWARN
          KWARN = 0
          CALL IMM2DP(MA,DA)
          IF (KFLAG == 0) THEN
              CALL IMM2DP(MB,DB)
              IF (KFLAG == 0) THEN
                  RESULT_SIZE = ABS(DB)*LOG(ABS(DA)+1)/DLOGMB + 5
                  KOVFL = 0
                  IF (ABS(RESULT_SIZE) >= MEXPOV) THEN
                      RESULT_SIZE = 5
                      KOVFL = 1
                  ENDIF
              ENDIF
          ELSE
              CALL IMM2DP(MB,DB)
              IF (KFLAG == 0) THEN
                  RESULT_SIZE = MIN(HUGE(1)/10.0D0,ABS(DB)*(ABS(MWK(START(MA)+2))+1) + 5)
                  KOVFL = 0
                  IF (ABS(RESULT_SIZE) >= MEXPOV .OR. ABS(MWK(START(MA)+2)) >= MEXPOV) THEN
                      RESULT_SIZE = 5
                      KOVFL = 1
                  ENDIF
              ENDIF
          ENDIF
          KWARN = KWRNSV
          NUMBER_USED = NUMBER_USED_SAVE
      ENDIF
      IF (MWK(START(MB)) < 0 .AND. MWK(START(MA)+3) /= 0) THEN
          RESULT_SIZE = 5
      ENDIF
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMPWR    ',2,MA,MB)
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMPWR'
          CALL IMNTR(2,MA,MB,2)
      ENDIF
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KWRNSV = KWARN

!             Check for special cases.

      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO .OR.  &
          MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR. ((MWK(START(MB)) < 0 .OR.  &
          MWK(START(MB)+3) == 0) .AND. MWK(START(MA)+3) == 0)) THEN
          KFLAG = -4
          IF (MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO) THEN
              KWARN = KWRNSV
              NAMEST(NCALL) = 'IMPWR'
              CALL FMWARN
          ENDIF
          CALL IMST2M('UNKNOWN',MC)
          GO TO 130
      ENDIF

      IF (MWK(START(MB)+3) == 0) THEN
          CALL IMI2M(1,MC)
          GO TO 130
      ENDIF

      IF (MWK(START(MA)+2) == 1 .AND. MWK(START(MA)+3) == 1) THEN
          KWARN = 0
          IF (MAS == 1) THEN
              CALL IMI2M(1,MC)
          ELSE
              CALL IMI2M(2,MXY(1))
              CALL IMDIVR(MB,MXY(1),MXY(4),MXY(2))
              CALL IMEQ(MXY(4),MXY(1))
              IF (MWK(START(MXY(2))+2) == MUNKNO) THEN
                  KFLAG = -4
                  KWARN = KWRNSV
                  NAMEST(NCALL) = 'IMPWR'
                  CALL FMWARN
                  CALL IMST2M('UNKNOWN',MC)
              ELSE IF (MWK(START(MXY(2))+3) == 0) THEN
                  CALL IMI2M(1,MC)
              ELSE
                  CALL IMI2M(-1,MC)
              ENDIF
          ENDIF
          GO TO 130
      ENDIF

      IF (MWK(START(MB)+2) == 1 .AND. MWK(START(MB)+3) == 1) THEN
          KWARN = 0
          IF (MBS == 1) THEN
              CALL IMEQ(MA,MC)
          ELSE
              CALL IMI2M(1,MXY(1))
              KREM = 0
              CALL IMDIVR(MXY(1),MA,MXY(3),MXY(2))
              CALL IMEQ(MXY(3),MC)
              KREM = 1
          ENDIF
          GO TO 130
      ENDIF

      IF (MWK(START(MA)+3) == 0) THEN
          CALL IMI2M(0,MC)
          GO TO 130
      ENDIF

      IF (MWK(START(MB)) < 0) THEN
          CALL IMI2M(0,MC)
          GO TO 130
      ENDIF

      IF (MWK(START(MB)+2) == MEXPOV) THEN
          IF (MBS < 0) THEN
              CALL IMI2M(0,MC)
          ELSE IF (MAS > 0) THEN
              CALL IMST2M('OVERFLOW',MC)
              KFLAG = -5
          ELSE
              KFLAG = -4
              KWARN = KWRNSV
              NAMEST(NCALL) = 'IMPWR'
              CALL FMWARN
              CALL IMST2M('UNKNOWN',MC)
          ENDIF
          GO TO 130
      ENDIF

      IF (MWK(START(MA)+2) == MEXPOV) THEN
          JSIGN = 1
          IF (MWK(START(MA)) < 0) JSIGN = -1
          IF (MBS > 0) THEN
              CALL IMDVIR(MB,2,MC,IREM)
              CALL IMST2M('OVERFLOW',MC)
              MWK(START(MC)) = JSIGN**IREM
              KFLAG = -5
          ELSE
              CALL IMI2M(0,MC)
          ENDIF
          GO TO 130
      ENDIF

      IF (KOVFL == 1) THEN
          IF (MBS <= 0) THEN
              CALL IMI2M(0,MC)
          ELSE IF (MWK(START(MA)) >= 0) THEN
              CALL IMST2M('OVERFLOW',MC)
              KFLAG = -5
              KWARN = KWRNSV
              NAMEST(NCALL) = 'IMPWR'
              CALL FMWARN
          ELSE
              CALL IMDVIR(MB,2,MC,IREM)
              CALL IMST2M('OVERFLOW',MC)
              MWK(START(MC)) = (-1)**IREM
              KFLAG = -5
              KWARN = KWRNSV
              NAMEST(NCALL) = 'IMPWR'
              CALL FMWARN
          ENDIF
          GO TO 130
      ENDIF

!             Initialize.

      CALL IMDEFINE(MXY(1),RESULT_SIZE)
      CALL IMDEFINE(MXY(3),RESULT_SIZE)
      CALL IMDEFINE(MXY(5),RESULT_SIZE)
      KWARN = 0
      CALL IMABS(MB,MXY(2))

      CALL IMEQ(MA,MXY(1))

      CALL IMDVIR(MB,2,MC,IREMB)
      IF (IREMB == 0) THEN
          CALL IMI2M(1,MC)
      ELSE
          CALL IMEQ(MXY(1),MC)
      ENDIF
      CALL IMDVIR(MXY(2),2,MXY(4),IREM)
      CALL IMEQ(MXY(4),MXY(2))

!             This is the multiplication loop.

  110 CALL IMDVIR(MXY(2),2,MXY(4),IREM)
      CALL IMEQ(MXY(4),MXY(2))
      CALL IMSQR(MXY(1),MXY(5))
      CALL IMEQ(MXY(5),MXY(1))
      IF (IREM == 1) THEN
          CALL IMMPY(MXY(1),MC,MXY(3))
          CALL IMEQ(MXY(3),MC)
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL IMEQ(MXY(1),MC)
          IF (MAS < 0 .AND. IREMB == 1) MWK(START(MC)) = -1
          GO TO 120
      ENDIF
      IF (MWK(START(MXY(2))+3) > 0) GO TO 110

  120 IF (MBS < 0) THEN
          CALL IMI2M(1,MXY(1))
          KREM = 0
          CALL IMDIVR(MXY(1),MC,MXY(4),MXY(2))
          KREM = 1
          CALL IMEQ(MXY(4),MC)
      ENDIF

      MWK(START(MC)+1) = MIN(MACCA,MACCB)
      IF (MWK(START(MC)+2) >= MEXPOV) THEN
          IF (NCALL == 1 .OR. MWK(START(MC)+2) >= MEXPOV) THEN
              IF (MWK(START(MC)) > 0) THEN
                  CALL IMST2M('OVERFLOW',MC)
              ELSE
                  CALL IMST2M('-OVERFLOW',MC)
              ENDIF
              KFLAG = -5
              KWARN = KWRNSV
              NAMEST(NCALL) = 'IMPWR'
              CALL FMWARN
          ENDIF
      ENDIF

  130 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      KWARN = KWRNSV
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMPWR'
          CALL IMNTR(1,MC,MC,1)
      ENDIF
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMPWR

      SUBROUTINE IMREAD(KREAD,MA)

!  Read MA on unit KREAD.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      INTEGER :: KREAD

      CHARACTER :: LINE(132)
      INTEGER :: J,K,L2,LB
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'IMREAD'
      LB = 0

  110 READ (KREAD,"(132A1)",ERR=120,END=120) LINE

!             Scan the line and look for '&'

      DO J = 1, 132
         IF (LINE(J) == '&') GO TO 110
         IF (LINE(J) /= ' ') THEN
             LB = LB + 1
             IF (LB > LMBUFF) THEN

!                If CMBUFF runs out of space, try to re-allocate it with a bigger size.

                 IF (LMBUFF > 0) THEN
                     ALLOCATE(MOVE_CMBUFF(LMBUFF),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, LMBUFF
                        MOVE_CMBUFF(K) = CMBUFF(K)
                     ENDDO
                     DEALLOCATE(CMBUFF)
                     L2 = MAX(10000,2*LMBUFF)
                     ALLOCATE(CMBUFF(L2),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, L2
                        CMBUFF(K) = ' '
                     ENDDO
                     DO K = 1, LMBUFF
                        CMBUFF(K) = MOVE_CMBUFF(K)
                     ENDDO
                     DEALLOCATE(MOVE_CMBUFF)
                     LMBUFF = L2
                 ELSE
                     ALLOCATE(CMBUFF(10000),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     LMBUFF = 10000
                 ENDIF
             ENDIF
             CMBUFF(LB) = LINE(J)
         ENDIF
      ENDDO

      CALL IMINP(CMBUFF,MA,1,LB)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

!             If there is an error, return UNKNOWN.

  120 KFLAG = -4
      CALL FMWARN
      CALL FMST2M('UNKNOWN',MA)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMREAD

      SUBROUTINE IMSIGN(MA,MB,MC)

!  MC = SIGN(MA,MB)

!  MC is set to ABS(MA) if MB is positive or zero, or -ABS(MA) if MB is negative.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      INTEGER :: KWRNSV,NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MWK(START(MA)+2) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMSIGN   ',2,MA,MB)
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMSIGN'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      NDIG = INT(MWK(START(MA)+2))
      IF (NDIG < 2) NDIG = 2
      KWRNSV = KWARN
      KWARN = 0
      IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
          CALL IMST2M('UNKNOWN',MC)
          KFLAG = -4
      ELSE IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMSIGN'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MC)
      ELSE IF (MWK(START(MB)) >= 0) THEN
          CALL IMEQ(MA,MC)
          MWK(START(MC)) = 1
      ELSE
          CALL IMEQ(MA,MC)
          IF (MWK(START(MC)+2) /= MUNKNO .AND. MWK(START(MC)+3) /= 0) MWK(START(MC)) = -1
      ENDIF

      IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      KWARN = KWRNSV
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMSIGN

      SUBROUTINE IMSQR(MA,MB)

!  MB = MA * MA

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MDAB
      INTEGER :: NDSAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = 2*MWK(START(MA)+2) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MB <= 0) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
          CALL IMDEFINE(MB,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMSQR    ',1,MA,MA)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMSQR'
          CALL IMNTR(2,MA,MA,1)
      ENDIF

      IF (MWK(START(MA)+2) <= 1) THEN
          IF (MWK(START(MA)+2) < 0) GO TO 110
          MDAB = MWK(START(MA)+3) * MWK(START(MA)+3)
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 1
              IF (MDAB == 0) MWK(START(MB)+2) = 0
              MWK(START(MB)+3) = MDAB
              MWK(START(MB)+4) = 0
              GO TO 120
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MB)+1) = MWK(START(MA)+1)
              MWK(START(MB)+2) = 2
              MWK(START(MB)+3) = AINT (MDAB/MBASE)
              MWK(START(MB)+4) = MDAB - MBASE*MWK(START(MB)+3)
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MWK(START(MA)+2) == MUNKNO) THEN
          KFLAG = -4
          CALL IMST2M('UNKNOWN',MB)
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+3) == 0) THEN
          MWK(START(MB)) = 1
          MWK(START(MB)+1) = NINT(10**7*ALOGM2)
          MWK(START(MB)+2) = 0
          MWK(START(MB)+3) = 0
          MWK(START(MB)+4) = 0
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+2) == MEXPOV) THEN
          KFLAG = -5
          CALL IMST2M('OVERFLOW',MB)
          GO TO 120
      ENDIF
      IF (MWK(START(MA)+2) == 1 .AND. ABS(MWK(START(MA)+3)) == 1) THEN
          CALL IMI2M(1,MB)
          GO TO 120
      ELSE IF (MWK(START(MA)+2) < 0) THEN
          KFLAG = -4
          NAMEST(NCALL) = 'IMSQR'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MB)
          GO TO 120
      ENDIF

      NDIG = INT(MWK(START(MA)+2) + MWK(START(MA)+2))

      IF (NDIG < 2) NDIG = 2

      CALL IMSQR2(MA,MB)

  120 IF (MWK(START(MB)+2) <= 1) MWK(START(MB)+4) = 0
      MWK(START(MB)) = 1
      IF (NTRACE /= 0) CALL IMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMSQR

      SUBROUTINE IMSQR2(MA,MB)

!  MB = MA*MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB

      REAL (KIND(1.0D0)) :: MAXMAX,MAXMWA,MBJ,MBKJ,MBM1,MBNORM,MK,MKA,MKT,MMAX,MT
      INTEGER :: J,JM1,JMA,JMWA,K,KB,KI,KJ,KL,KNZ,KOVUN,KWA,L,N1,ND,NMETHD,NZDA
      INTEGER :: MXY(2),NUMBER_USED_SAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      RESULT_SIZE = 2*MWK(START(MA)+2) + 30
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 32
      RESULT_SIZE = MAX(32,RESULT_SIZE)
      IF (MWA <= 0) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MWA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MWA,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             KSQR is used to tell FMMPYFFT that only one input fft is needed.

      KSQR = 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (KDEBUG == 1 .OR. MBASE*MBASE <= MXBASE/(4*MBASE)) THEN
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          IF (MWK(START(MA)+2) == MUNKNO) KOVUN = 2
          NCALL = NCALL + 1
          CALL IMMPY(MA,MA,MB)
          NCALL = NCALL - 1
          IF ((KFLAG < 0 .AND. KOVUN == 0) .OR. (KFLAG == -4 .AND. KOVUN == 1)) THEN
              NAMEST(NCALL) = 'IMSQR'
              CALL FMWARN
          ENDIF
          GO TO 130
      ELSE IF (MWK(START(MA)+3) == 0) THEN
          CALL IMEQ(MA,MB)
          GO TO 130
      ENDIF
      KFLAG = 0
      MAXMAX = 0
      N1 = INT(MWK(START(MA)+2)) + 1
      MWK(START(MWA)+2) = MWK(START(MA)+2) + MWK(START(MA)+2)

!             Check for using an FFT-based method if precision is very high.

      ND = 1000
      IF (NDIG >= ND) THEN
          NZDA = 0
          DO J = 2, INT(MWK(START(MA)+2))
             IF (MWK(START(MA)+J+2) == 0) NZDA = NZDA + 1
          ENDDO
          IF (MWK(START(MA)+2)-NZDA < 50 .OR. REAL(NZDA)/MWK(START(MA)+2) > 0.8) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) THEN
          ND = NDIG
          NDIG = MWK(START(MA)+2)
          CALL IMI2FM(MA,MXY(1))
          CALL IMI2FM(MA,MXY(2))
          CALL FMMPYFFT(MXY(1),MXY(2))
          NDIG = ND
          GO TO 120
      ENDIF

      L = N1 + INT(MWK(START(MA)+2))
      MWK(START(MWA)+L+2) = 0

!             The multiplication loop begins here.

!             MBNORM is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             MAXMWA is an upper bound on the size of values in MWA divided by (MBASE-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      MBM1 = MBASE - 1
      MBNORM = (MAXINT/(MBM1*MBM1))
      MMAX = INTMAX - MBASE
      MMAX = MIN((MAXINT/MBM1 - MBM1),MMAX)
      IF (MBNORM >= 2) THEN
          MBJ = MWK(START(MA)+3)

!             Count the trailing zeros in MA.

          IF (MWK(START(MA)+N1+1) /= 0) THEN
              KNZ = N1
          ELSE
              DO J = INT(MWK(START(MA)+2)), 2, -1
                 IF (MWK(START(MA)+J+1) /= 0) THEN
                     KNZ = J
                     GO TO 110
                 ENDIF
              ENDDO
          ENDIF

  110     MWK(START(MWA)+3) = 0
          MWK(START(MWA)+4) = 0
          DO K = N1+1, L
             MWK(START(MWA)+K+1) = 0
          ENDDO

!             (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 2
          DO K = 3, N1
             MWK(JMWA+K) = MWK(JMA+K)*MBJ
          ENDDO
          MAXMWA = MBJ
          DO J = 3, N1
             MBJ = MWK(START(MA)+J+1)
             IF (MBJ /= 0) THEN
                 MAXMWA = MAXMWA + MBJ
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Major (Inner Loop)

                 JMA = START(MA) + 1 - JM1
                 JMWA = START(MWA) + 1
                 DO K = 2*J, JM1+KL
                    MWK(JMWA+K) = MWK(JMWA+K) + MWK(JMA+K)*MBJ
                 ENDDO
             ENDIF

             IF (MAXMWA > MMAX) THEN
                 MAXMAX = MAX(MAXMAX,MAXMWA)
                 MAXMWA = 0
                 JM1 = J - 1
                 KL = MIN(KNZ,L-JM1)

!                       Normalization is only required for the range of digits currently
!                       changing in MWA.

                 DO KB = JM1+KL, 2*J, -1
                    MKT = INT (MWK(START(MWA)+KB+1)/MBASE)
                    MWK(START(MWA)+KB) = MWK(START(MWA)+KB) + MKT
                    MWK(START(MWA)+KB+1) = MWK(START(MWA)+KB+1) - MKT*MBASE
                 ENDDO
             ENDIF
          ENDDO

!             Double MWA, add the square terms, and perform the final normalization.  (Inner Loop)

          JMA = START(MA) + 1
          JMWA = START(MWA) + 1
          IF (2*MAX(MAXMAX,MAXMWA)+MBASE > MMAX) THEN
              DO KB = L, 4, -1
                 MKT = INT (MWK(JMWA+KB)/MBASE)
                 MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
                 MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
              ENDDO
          ENDIF

          DO J = 3, L-1, 2
             IF ((J+1)/2 <= N1) THEN
                 MKA = MWK(JMA+(J+1)/2)
                 MWK(JMWA+J) = 2*MWK(JMWA+J) + MKA*MKA
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ELSE
                 MWK(JMWA+J) = 2*MWK(JMWA+J)
                 MWK(JMWA+J+1) = 2*MWK(JMWA+J+1)
             ENDIF
          ENDDO
          IF (MOD(L,2) == 1) THEN
              IF ((L+1)/2 <= N1) THEN
                  MKA = MWK(JMA+(L+1)/2)
                  MWK(JMWA+L) = 2*MWK(JMWA+L) + MKA*MKA
              ELSE
                  MWK(JMWA+L) = 2*MWK(JMWA+L)
              ENDIF
          ENDIF

          DO KB = L, 3, -1
             MKT = INT (MWK(JMWA+KB)/MBASE)
             MWK(JMWA+KB-1) = MWK(JMWA+KB-1) + MKT
             MWK(JMWA+KB) = MWK(JMWA+KB) - MKT*MBASE
          ENDDO

      ELSE

!             If normalization must be done for each digit, combine the two loops and normalize
!             as the digits are multiplied.

          DO J = 2, L
             MWK(START(MWA)+J+1) = 0
          ENDDO
          KJ = NDIG + 2
          DO J = 2, N1
             KJ = KJ - 1
             MBKJ = MWK(START(MA)+KJ+1)
             IF (MBKJ == 0) CYCLE
             KL = L - KJ + 1
             IF (KL > N1) KL = N1
             KI = KL + 2
             KWA = KL+ KJ + 1
             MK = 0
             DO K = 2, KL
                MT = MWK(START(MA)+KI-K+1)*MBKJ + MWK(START(MWA)+KWA-K+1) + MK
                MK = INT (MT/MBASE)
                MWK(START(MWA)+KWA-K+1) = MT - MBASE*MK
             ENDDO
             MWK(START(MWA)+KWA-KL) = MK
          ENDDO

      ENDIF

!             The multiplication is complete.

  120 NDIG = MWK(START(MWA)+2)
      IF (NDIG < 2) NDIG = 2
      CALL FMMOVE(MWA,MB)
      MWK(START(MB)+1) = NINT(10**7*ALOGM2)

      IF (KFLAG < 0) THEN
          NAMEST(NCALL) = 'IMSQR'
          CALL FMWARN
      ENDIF

  130 MWK(START(MB)) = 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      KSQR = 0
      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMSQR2

      SUBROUTINE IMST2M(STRING,MA)

!  MA = STRING

!  Convert a character string to IM format.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      INTEGER :: MA

      INTEGER :: J,LB,KFSAVE
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'IMST2M'
      LB = LEN(STRING)
      IF (LB > LMBUFF) THEN
          IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
          ALLOCATE(CMBUFF(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFF = LB
      ENDIF
      KFSAVE = KFLAG

      DO J = 1, LB
         CMBUFF(J) = STRING(J:J)
      ENDDO

      CALL IMINP(CMBUFF,MA,1,LB)

      IF (MWK(START(MA)+2) <= 1) MWK(START(MA)+4) = 0
      IF (KFSAVE /= 0) KFLAG = KFSAVE
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMST2M

      SUBROUTINE IMSUB(MA,MB,MC)

!  MC = MA - MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC

      REAL (KIND(1.0D0)) :: MDA,MDAB,MDB
      INTEGER :: NDSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 4
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF

      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMSUB    ',2,MA,MB)
      KFLAG = 0
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          NAMEST(NCALL) = 'IMSUB'
          CALL IMNTR(2,MA,MB,2)
      ENDIF

      IF (MWK(START(MA)+2) <= 2) THEN
          IF (MWK(START(MB)+2) > 2 .OR. MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0) GO TO 110
          IF (MWK(START(MA)+2) <= 1) THEN
              MDA = MWK(START(MA)) * MWK(START(MA)+3)
          ELSE
              MDA = MWK(START(MA)) * (MWK(START(MA)+3)*MBASE + MWK(START(MA)+4))
          ENDIF
          IF (MWK(START(MB)+2) <= 1) THEN
              MDB = MWK(START(MB)) * MWK(START(MB)+3)
          ELSE
              MDB = MWK(START(MB)) * (MWK(START(MB)+3)*MBASE + MWK(START(MB)+4))
          ENDIF
          MDAB = MDA - MDB
          IF (ABS(MDAB) < MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 1
              IF (MDAB == 0) MWK(START(MC)+2) = 0
              MWK(START(MC)) = 1
              IF (MDAB < 0) MWK(START(MC)) = -1
              MWK(START(MC)+3) = ABS(MDAB)
              MWK(START(MC)+4) = 0
              IF (MDA == 0 .OR. MDB == 0) KFLAG = 1
              GO TO 120
          ELSE IF (ABS(MDAB) < MBASE*MBASE) THEN
              MWK(START(MC)+1) = MIN(MWK(START(MA)+1),MWK(START(MB)+1))
              MWK(START(MC)+2) = 2
              MWK(START(MC)) = 1
              IF (MDAB < 0) MWK(START(MC)) = -1
              MDAB = ABS(MDAB)
              MWK(START(MC)+3) = AINT (MDAB/MBASE)
              MWK(START(MC)+4) = MDAB - MBASE*MWK(START(MC)+3)
              IF (MDA == 0 .OR. MDB == 0) KFLAG = 1
              GO TO 120
          ENDIF
      ENDIF

!             Check for special cases.

  110 IF (MWK(START(MA)+2) < 0 .OR. MWK(START(MB)+2) < 0 .OR.  &
          MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
          IF (MWK(START(MA)+2) == MUNKNO .OR. MWK(START(MB)+2) == MUNKNO) THEN
              CALL IMST2M('UNKNOWN',MC)
              KFLAG = -4
              GO TO 120
          ENDIF
          IF (MWK(START(MA)+2) == MEXPOV) THEN
              IF (MWK(START(MA)) == -MWK(START(MB)) .OR. MWK(START(MB)+3) == 0) THEN
                  MWK(START(MC)) = MWK(START(MA))
                  MWK(START(MC)+1) = MWK(START(MA)+1)
                  MWK(START(MC)+2) = MWK(START(MA)+2)
                  MWK(START(MC)+3) = MWK(START(MA)+3)
                  MWK(START(MC)+4) = MWK(START(MA)+4)
                  KFLAG = -5
                  GO TO 120
              ELSE
                  KFLAG = -4
                  NAMEST(NCALL) = 'IMSUB'
                  CALL FMWARN
                  CALL IMST2M('UNKNOWN',MC)
                  GO TO 120
              ENDIF
          ENDIF
          IF (MWK(START(MB)+2) == MEXPOV) THEN
              IF (-MWK(START(MB)) == MWK(START(MA)) .OR. MWK(START(MA)+3) == 0) THEN
                  MWK(START(MC)) = -MWK(START(MB))
                  MWK(START(MC)+1) = MWK(START(MB)+1)
                  MWK(START(MC)+2) = MWK(START(MB)+2)
                  MWK(START(MC)+3) = MWK(START(MB)+3)
                  MWK(START(MC)+4) = MWK(START(MB)+4)
                  KFLAG = -5
                  GO TO 120
              ELSE
                  KFLAG = -4
                  NAMEST(NCALL) = 'IMSUB'
                  CALL FMWARN
                  CALL IMST2M('UNKNOWN',MC)
                  GO TO 120
              ENDIF
          ENDIF
          KFLAG = -4
          NAMEST(NCALL) = 'IMSUB'
          CALL FMWARN
          CALL IMST2M('UNKNOWN',MC)
          GO TO 120
      ENDIF

!             IMADD3 will negate MB and add.

      KSUB = 1
      CALL IMADD3(MA,MB,MC)
      KSUB = 0

  120 IF (MWK(START(MC)+2) <= 1) MWK(START(MC)+4) = 0
      IF (NTRACE /= 0) CALL IMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      NDIG = NDSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMSUB

      SUBROUTINE IMUNPK(MP,MA)

!  MP is unpacked and the value returned in MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MP

      INTEGER :: J,KP,KMA1
      INTENT (IN) :: MP
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      RESULT_SIZE = MWK(START(MP)+2) + 3
      IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      IF (MA <= 0) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ELSE IF (SIZE_OF(MA) < RESULT_SIZE) THEN
          CALL IMDEFINE(MA,RESULT_SIZE)
      ENDIF

      KMA1 = INT(MWK(START(MP)+2))
      IF (KMA1 <= 2) KMA1 = 2
      IF (ABS(KMA1) >= MEXPOV) KMA1 = 2
      KP = 2
      MWK(START(MA)+1) = MWK(START(MP)+1)
      MWK(START(MA)+2) = MWK(START(MP)+2)
      MWK(START(MA)+3) = AINT (ABS(MWK(START(MP)+3))/MBASE)
      MWK(START(MA)+4) = ABS(MWK(START(MP)+3)) - MWK(START(MA)+3)*MBASE
      MWK(START(MA)) = 1
      IF (MWK(START(MP)) < 0) MWK(START(MA)) = -1
      IF (KMA1 >= 4) THEN
          DO J = 4, KMA1, 2
             KP = KP + 1
             MWK(START(MA)+J+1) = AINT (MWK(START(MP)+KP+1)/MBASE)
             MWK(START(MA)+J+2) = MWK(START(MP)+KP+1) - MWK(START(MA)+J+1)*MBASE
          ENDDO
      ENDIF
      IF (MOD(KMA1,2) == 1) MWK(START(MA)+KMA1+2) = AINT (MWK(START(MP)+KP+2)/MBASE)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMUNPK

      SUBROUTINE IMWRIT(KWRITE,MA)

!  Write MA on unit KWRITE.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  These numbers can then be read easily using IMREAD.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KWRITE
      INTEGER :: MA

      INTEGER :: J,K,KSAVE,L,LAST,LB,ND,NDSAVE,NEXP
      INTENT (IN) :: KWRITE,MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      IF (KDEBUG == 1) CALL IMARGS('IMWRIT   ',1,MA,MA)
      NAMEST(NCALL) = 'IMWRIT'
      NDSAVE = NDIG
      NDIG = MAX(2,INT(MWK(START(MA)+2)))
      IF (MWK(START(MA)+2) >= MEXPOV) NDIG = 2

      KSAVE = KFLAG
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = ND + NEXP
      IF (LB > LMBUFF) THEN
          IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
          ALLOCATE(CMBUFF(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFF = LB
      ENDIF

      CALL IMOUT(MA,CMBUFF,LB)

      KFLAG = KSAVE
      NDIG = NDSAVE
      LAST = LB + 1
      DO J = 1, LB
         IF (CMBUFF(LAST-J) /= ' ' .OR. J == LB) THEN
             L = LAST - J
             IF (MOD(L,73) /= 0) THEN
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L)
             ELSE
                 IF (L > 73) WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFF(K),K=1,L-73)
                 WRITE (KWRITE,"(4X,73A1)") (CMBUFF(K),K=L-72,L)
             ENDIF
             NCALL = NCALL - 1
             IF (TEMPV_CALL_STACK == 1) THEN
                 IF (TEMPV(MA) == -1) TEMPV(MA) = -2
             ENDIF
             TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
             RETURN
         ENDIF
      ENDDO
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IMWRIT

      SUBROUTINE IM_OR_FM_ADD(MA,MB,MC)

!  Internal routine used by binary splitting algorithms.
!  MA and MB are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: M1,M2,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      M1 = -2
      M2 = -2
      IF (MAX(MWK(START(MA)+2),MWK(START(MB)+2)) > NDIG) THEN
          IF (MC <= 0) THEN
              CALL FMDEFINE(MC)
          ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
              CALL FMDEFINE(MC)
          ENDIF
      ELSE
          RESULT_SIZE = MAX(MWK(START(MA)+2),MWK(START(MB)+2)) + 4
          IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
          RESULT_SIZE = MAX(5,RESULT_SIZE)
          IF (MC <= 0) THEN
              CALL IMDEFINE(MC,RESULT_SIZE)
          ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
              CALL IMDEFINE(MC,RESULT_SIZE)
          ENDIF
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MAX(MWK(START(MA)+2),MWK(START(MB)+2)) > NDIG) THEN
          IF (MWK(START(MA)+2) >= NDIG .AND. MWK(START(MB)+2) >= NDIG) THEN
              CALL FMADD(MA,MB,MC)
          ELSE IF (MWK(START(MA)+2) >= NDIG .AND. MWK(START(MB)+2) < NDIG) THEN
              CALL IMI2FM(MB,M2)
              CALL FMADD(MA,M2,MC)
          ELSE IF (MWK(START(MA)+2) < NDIG .AND. MWK(START(MB)+2) >= NDIG) THEN
              CALL IMI2FM(MA,M1)
              CALL FMADD(M1,MB,MC)
          ELSE IF (MWK(START(MA)+2) < NDIG .AND. MWK(START(MB)+2) < NDIG) THEN
              CALL IMI2FM(MA,M1)
              CALL IMI2FM(MB,M2)
              CALL FMADD(M1,M2,MC)
          ENDIF
      ELSE
          CALL IMADD(MA,MB,MC)
      ENDIF

      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IM_OR_FM_ADD

      SUBROUTINE IM_OR_FM_EQ(MA,MB)

!  Internal routine used by binary splitting algorithms.
!  MA is an integer, but if it gets bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      IF (MWK(START(MA)+2) >= NDIG) THEN
          CALL FMEQ(MA,MB)
      ELSE
          CALL IMEQ(MA,MB)
      ENDIF
      RETURN
      END SUBROUTINE IM_OR_FM_EQ

      SUBROUTINE IM_OR_FM_MPY(MA,MB,MC)

!  Internal routine used by binary splitting algorithms.
!  MA and MB are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: M1,M2,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      M1 = -2
      M2 = -2
      IF (MWK(START(MA)+2)+MWK(START(MB)+2) > NDIG) THEN
          IF (MC <= 0) THEN
              CALL FMDEFINE(MC)
          ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
              CALL FMDEFINE(MC)
          ENDIF
      ELSE
          IF (MWK(START(MA)+2) >= MEXPOV .OR. MWK(START(MB)+2) >= MEXPOV) THEN
              RESULT_SIZE = 5
          ELSE
              RESULT_SIZE = MWK(START(MA)+2) + MWK(START(MB)+2) + 4
          ENDIF
          RESULT_SIZE = MAX(5,RESULT_SIZE)
          IF (MC <= 0) THEN
              CALL IMDEFINE(MC,RESULT_SIZE)
          ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
              CALL IMDEFINE(MC,RESULT_SIZE)
          ENDIF
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MWK(START(MA)+2)+MWK(START(MB)+2) > NDIG) THEN
          IF (MWK(START(MA)+2) >= NDIG .AND. MWK(START(MB)+2) >= NDIG) THEN
              CALL FMMPY(MA,MB,MC)
          ELSE IF (MWK(START(MA)+2) >= NDIG .AND. MWK(START(MB)+2) < NDIG) THEN
              CALL IMI2FM(MB,M2)
              CALL FMMPY(MA,M2,MC)
          ELSE IF (MWK(START(MA)+2) < NDIG .AND. MWK(START(MB)+2) >= NDIG) THEN
              CALL IMI2FM(MA,M1)
              CALL FMMPY(M1,MB,MC)
          ELSE IF (MWK(START(MA)+2) < NDIG .AND. MWK(START(MB)+2) < NDIG) THEN
              CALL IMI2FM(MA,M1)
              CALL IMI2FM(MB,M2)
              CALL FMMPY(M1,M2,MC)
          ENDIF
      ELSE
          CALL IMMPY(MA,MB,MC)
      ENDIF

      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IM_OR_FM_MPY

      SUBROUTINE IM_OR_FM_SQR(MA,MB)

!  Internal routine used by binary splitting algorithms.
!  MA and MB are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use FM routines in place of IM routines.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: M1,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      M1 = -2
      IF (2*MWK(START(MA)+2) > NDIG) THEN
          IF (MB <= 0) THEN
              CALL FMDEFINE(MB)
          ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
              CALL FMDEFINE(MB)
          ENDIF
      ELSE
          RESULT_SIZE = 2*MWK(START(MA)+2) + 4
          IF (ABS(RESULT_SIZE) >= MEXPOV) RESULT_SIZE = 5
          RESULT_SIZE = MAX(5,RESULT_SIZE)
          IF (MB <= 0) THEN
              CALL IMDEFINE(MB,RESULT_SIZE)
          ELSE IF (SIZE_OF(MB) < RESULT_SIZE) THEN
              CALL IMDEFINE(MB,RESULT_SIZE)
          ENDIF
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (2*MWK(START(MA)+2) > NDIG) THEN
          IF (MWK(START(MA)+2) >= NDIG) THEN
              CALL FMSQR(MA,MB)
          ELSE
              CALL IMI2FM(MA,M1)
              CALL FMSQR(M1,MB)
          ENDIF
      ELSE
          CALL IMSQR(MA,MB)
      ENDIF

      NUMBER_USED = NUMBER_USED_SAVE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IM_OR_FM_SQR


!  These versions of the IM routines use packed IM numbers.

      SUBROUTINE IPABS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMABS(MPA,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPABS

      SUBROUTINE IPADD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMADD(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPADD

      SUBROUTINE IPBIG(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMBIG(MPB)
      CALL IMPACK(MPB,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPBIG

      FUNCTION IPCOMP(MA,LREL,MB)
      USE FMVALS
      IMPLICIT NONE
      LOGICAL :: IPCOMP
      LOGICAL, EXTERNAL ::IMCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      INTENT (IN) :: MA,MB,LREL
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      IPCOMP = IMCOMP(MPA,LREL,MPB)
      RETURN
      END FUNCTION IPCOMP

      SUBROUTINE IPDIM(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMDIM(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPDIM

      SUBROUTINE IPDIV(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMDIV(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPDIV

      SUBROUTINE IPDIVI(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMDIVI(MPA,IVAL,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPDIVI

      SUBROUTINE IPDIVR(MA,MB,MC,MD)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC,MD
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMDIVR(MPA,MPB,MPC,MPD)
      CALL IMPACK(MPC,MC)
      CALL IMPACK(MPD,MD)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPDIVR

      SUBROUTINE IPDVIR(MA,IVAL,MB,IREM)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL,IREM
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB,IREM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMDVIR(MPA,IVAL,MPB,IREM)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPDVIR

      SUBROUTINE IPEQ(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMEQ(MPA,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPEQ

      SUBROUTINE IPFACT(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: IVAL,MA
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMFACT(IVAL,MPA)
      CALL IMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPFACT

      SUBROUTINE IPFM2I(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL IMFM2I(MPA,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPFM2I

      SUBROUTINE IPFORM(FORM,MA,STRING)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: FORM,STRING
      INTEGER :: MA
      INTENT (IN) :: MA,FORM
      INTENT (INOUT) :: STRING
      CALL IMUNPK(MA,MPA)
      CALL IMFORM(FORM,MPA,STRING)
      RETURN
      END SUBROUTINE IPFORM

      SUBROUTINE IPFPRT(FORM,MA)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      INTENT (IN) :: MA,FORM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMFPRT(FORM,MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPFPRT

      SUBROUTINE IPGCD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMGCD(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPGCD

      SUBROUTINE IPI2FM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMI2FM(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPI2FM

      SUBROUTINE IPI2M(IVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: IVAL
      INTENT (IN) :: IVAL
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMI2M(IVAL,MPA)
      CALL IMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPI2M

      SUBROUTINE IPINP(LINE,MA,LA,LB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMINP(LINE,MPA,LA,LB)
      CALL IMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPINP

      SUBROUTINE IPM2DP(MA,DVAL)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      DOUBLE PRECISION :: DVAL
      INTENT (IN) :: MA
      INTENT (INOUT) :: DVAL
      CALL IMUNPK(MA,MPA)
      CALL IMM2DP(MPA,DVAL)
      RETURN
      END SUBROUTINE IPM2DP

      SUBROUTINE IPM2I(MA,IVAL)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: IVAL
      INTENT (IN) :: MA
      INTENT (INOUT) :: IVAL
      CALL IMUNPK(MA,MPA)
      CALL IMM2I(MPA,IVAL)
      RETURN
      END SUBROUTINE IPM2I

      SUBROUTINE IPMAX(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMMAX(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMAX

      SUBROUTINE IPMIN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMMIN(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMIN

      SUBROUTINE IPMOD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMMOD(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMOD

      SUBROUTINE IPMPY(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMMPY(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMPY

      SUBROUTINE IPMPYI(MA,IVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMMPYI(MPA,IVAL,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMPYI

      SUBROUTINE IPMPYM(MA,MB,MC,MD)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMUNPK(MC,MPC)
      CALL IMMPYM(MPA,MPB,MPC,MPD)
      CALL IMPACK(MPD,MD)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPMPYM

      SUBROUTINE IPOUT(MA,LINE,LB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: LB
      CHARACTER :: LINE(LB)
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE
      CALL IMUNPK(MA,MPA)
      CALL IMOUT(MPA,LINE,LB)
      RETURN
      END SUBROUTINE IPOUT

      SUBROUTINE IPPMOD(MA,MB,MC,MD)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMUNPK(MC,MPC)
      CALL IMPMOD(MPA,MPB,MPC,MPD)
      CALL IMPACK(MPD,MD)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPPMOD

      SUBROUTINE IPPRNT(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (IN) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMPRNT(MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPPRNT

      SUBROUTINE IPPWR(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMPWR(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPPWR

      SUBROUTINE IPREAD(KREAD,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: KREAD
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMREAD(KREAD,MPA)
      CALL IMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPREAD

      SUBROUTINE IPSIGN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMSIGN(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPSIGN

      SUBROUTINE IPSQR(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMSQR(MPA,MPB)
      CALL IMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPSQR

      SUBROUTINE IPST2M(STRING,MA)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      INTEGER :: MA
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMST2M(STRING,MPA)
      CALL IMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPST2M

      SUBROUTINE IPSUB(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMUNPK(MB,MPB)
      CALL IMSUB(MPA,MPB,MPC)
      CALL IMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPSUB

      SUBROUTINE IPWRIT(KWRITE,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      INTENT (IN) :: MA,KWRITE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL IMUNPK(MA,MPA)
      CALL IMWRIT(KWRITE,MPA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE IPWRIT


!  The ZM routines perform complex multiple-precision arithmetic.

      SUBROUTINE ZMSET(NPREC)

!  Set precision to at least NPREC significant digits for using ZM arithmetic.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NPREC
      INTENT (IN) :: NPREC

!             Set JFORMZ to ' 1.23 + 4.56 i ' format.

      JFORMZ = 1

!             Set JPRNTZ to print real and imaginary parts on one line whenever possible.

      JPRNTZ = 1

!             Use FMSET to initialize the other variables.

      CALL FMSET(NPREC)

      RETURN
      END SUBROUTINE ZMSET

      SUBROUTINE ZMABS(MA,MBFM)

!  MBFM = ABS(MA)

!  Complex absolute value.  The result is a real FM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MBFM
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXEXP1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NTRSAV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      INTEGER :: MXY(3),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MBFM <= 0) THEN
          CALL FMDEFINE(MBFM)
      ELSE IF (SIZE_OF(MBFM) < NDIG+3) THEN
          CALL FMDEFINE(MBFM)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NTRSAV = NTRACE
      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'ZMABS'
          CALL ZMNTR(2,MA,MA,1)
          NCALL = NCALL - 1
      ENDIF
      NTRACE = 0
      CALL ZMENTR('ZMABS    ',MA,MA,1,MZ01,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NTRACE = NTRSAV
      IF (KRESLT /= 0) THEN
          CALL FMEQ(MZ01(1),MBFM)
          NCALL = NCALL + 1
          IF (NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      MXEXP1 = INT(MXEXP2/2.01D0)
      IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMABS(MZ02(2),MXY(3))
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMABS(MZ02(1),MXY(3))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) == MEXPOV .OR. MWK(START(MA(2))+2) == MEXPOV) THEN
          CALL FMI2M(1,MXY(3))
          MWK(START(MXY(3))+2) = MAX(MWK(START(MZ02(1))+2),MWK(START(MZ02(2))+2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) == MEXPUN) THEN
          IF (MWK(START(MA(2))+2) > -MXEXP1+NDIG+1) THEN
              CALL FMABS(MZ02(2),MXY(3))
          ELSE
              CALL FMST2M('UNKNOWN',MXY(3))
              KFLAG = -4
          ENDIF
          GO TO 120
      ELSE IF (MWK(START(MA(2))+2) == MEXPUN) THEN
          IF (MWK(START(MA(1))+2) > -MXEXP1+NDIG+1) THEN
              CALL FMABS(MZ02(1),MXY(3))
          ELSE
              CALL FMST2M('UNKNOWN',MXY(3))
              KFLAG = -4
          ENDIF
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) /= MUNKNO .AND. MWK(START(MA(2))+2) /= MUNKNO) THEN
          IF (MWK(START(MA(1))+2) > MWK(START(MA(2))+2)+NDIG+1) THEN
              CALL FMABS(MZ02(1),MXY(3))
              GO TO 120
          ELSE IF (MWK(START(MA(2))+2) > MWK(START(MA(1))+2)+NDIG+1) THEN
              CALL FMABS(MZ02(2),MXY(3))
              GO TO 120
          ENDIF
      ENDIF

      CALL FMSQR(MZ02(1),MXY(1))
      CALL FMSQR(MZ02(2),MXY(2))
      CALL FMADD(MXY(1),MXY(2),MXY(3))
      CALL FMSQRT_R1(MXY(3))

  120 MACCMB = MWK(START(MXY(3))+1)
      MWK(START(MXY(3))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXI2(MXY(3),MBFM,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMABS

      SUBROUTINE ZMACOS(MA,MB)

!  MB = ACOS(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMACOS   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL FMPI(MZ01(1))
          CALL FMDIVI_R1(MZ01(1),2)
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          KRSAVE = KRAD
          KRAD = 1
          CALL FMACOS(MZ04(1),MZ01(1))
          KRAD = KRSAVE
          IF (KFLAG == 0) THEN
              CALL FMI2M(0,MZ01(2))
              GO TO 120
          ENDIF
      ENDIF
      IF ((MWK(START(MA(1))+3) == 0 .OR. MWK(START(MA(1))+2)*2 <= -NDIG) .AND.  &
          (MWK(START(MA(2))+3) == 0 .OR. MWK(START(MA(2))+2)*2 <= -NDIG)) THEN
          CALL FMPI(MZ02(1))
          CALL FMDIVI_R1(MZ02(1),2)
          CALL FMI2M(0,MZ02(2))
          CALL ZMSUB(MZ02,MZ04,MZ01)
          GO TO 120
      ENDIF

      CALL ZMI2M(0,MZ01)
      CALL ZMI2M(1,MZ03)
      CALL ZMSUB(MZ03,MZ04,MZ02)
      CALL ZMADD(MZ03,MZ04,MZ05)
      CALL ZMMPY(MZ02,MZ05,MZ03)
      CALL ZMSQRT(MZ03,MZ02)
      DO J = -1, NDIG+1
         MWK(START(MZ03(1))+J+1) = MWK(START(MZ02(2))+J+1)
         MWK(START(MZ03(2))+J+1) = MWK(START(MZ02(1))+J+1)
      ENDDO
      IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
          MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))

      IF ((MWK(START(MA(1))+3) /= 0 .AND. MWK(START(MZ03(1))+2) == MWK(START(MA(1))+2) .AND.   &
          MWK(START(MZ03(1)))*MWK(START(MZ03(1))+3) == MWK(START(MA(1)))*MWK(START(MA(1))+3)) .OR. &
          (MWK(START(MA(2))+3) /= 0 .AND. MWK(START(MZ03(2))+2) == MWK(START(MA(2))+2) .AND.   &
          MWK(START(MZ03(2)))*MWK(START(MZ03(2))+3) == MWK(START(MA(2)))*MWK(START(MA(2))+3)) ) THEN
          CALL ZMADD(MZ04,MZ03,MZ05)
          CALL FMSQR(MZ05(1),MXY(2))
          CALL FMSQR(MZ05(2),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(4))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB_R2(MXY(4),MXY(1))
          IF (MWK(START(MXY(1))+2) < 0) THEN
              NDIG = NDIG - INT(MWK(START(MXY(1))+2))
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZMI2M(0,MZ01)
              CALL ZMI2M(1,MZ03)
              CALL ZMSUB(MZ03,MZ04,MZ02)
              CALL ZMADD(MZ03,MZ04,MZ05)
              CALL ZMMPY(MZ02,MZ05,MZ03)
              CALL ZMSQRT(MZ03,MZ02)
              DO J = -1, NDIG+1
                 MWK(START(MZ03(1))+J+1) = MWK(START(MZ02(2))+J+1)
                 MWK(START(MZ03(2))+J+1) = MWK(START(MZ02(1))+J+1)
              ENDDO
              IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
                  MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
              CALL ZMADD(MZ04,MZ03,MZ05)
          ENDIF

          CALL ZMLN(MZ05,MZ03)
          DO J = -1, NDIG+1
             MWK(START(MZ01(1))+J+1) = MWK(START(MZ03(2))+J+1)
             MWK(START(MZ01(2))+J+1) = MWK(START(MZ03(1))+J+1)
          ENDDO
          IF (MWK(START(MZ01(2))+2) /= MUNKNO .AND. MWK(START(MZ01(2))+3) /= 0)  &
              MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))
      ELSE
          CALL ZMSUB(MZ04,MZ03,MZ05)
          CALL FMSQR(MZ05(1),MXY(2))
          CALL FMSQR(MZ05(2),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(4))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB_R2(MXY(4),MXY(1))
          IF (MWK(START(MXY(1))+2) < 0) THEN
              NDIG = NDIG - INT(MWK(START(MXY(1))+2))
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZMI2M(0,MZ01)
              CALL ZMI2M(1,MZ03)
              CALL ZMSUB(MZ03,MZ04,MZ02)
              CALL ZMADD(MZ03,MZ04,MZ05)
              CALL ZMMPY(MZ02,MZ05,MZ03)
              CALL ZMSQRT(MZ03,MZ02)
              DO J = -1, NDIG+1
                 MWK(START(MZ03(1))+J+1) = MWK(START(MZ02(2))+J+1)
                 MWK(START(MZ03(2))+J+1) = MWK(START(MZ02(1))+J+1)
              ENDDO
              IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
                  MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
              CALL ZMSUB(MZ04,MZ03,MZ05)
          ENDIF

          CALL ZMLN(MZ05,MZ03)
          DO J = -1, NDIG+1
             MWK(START(MZ01(1))+J+1) = MWK(START(MZ03(2))+J+1)
             MWK(START(MZ01(2))+J+1) = MWK(START(MZ03(1))+J+1)
          ENDDO
          IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
              MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
      ENDIF

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMACOS

      SUBROUTINE ZMADD(MA,MB,MC)

!  MC = MA + MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      INTEGER :: KASAVE,KF1,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MAR,MAI,MBR,MBI,MXSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MB(1))+2)) > MEXPAB .OR. ABS(MWK(START(MB(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMADD    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
                  IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NTRSAV = NTRACE
          NTRACE = 0
      ELSE
          NCALL = NCALL + 1
          NTRSAV = NTRACE
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMADD'
              CALL ZMNTR(2,MA,MB,2)
              NTRACE = 0
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMADD to use more guard digits for user calls.

      NCALL = NCALL - 1

      KWRNSV = KWARN
      KWARN = 0
      MAR = MWK(START(MA(1))+2)
      IF (MWK(START(MA(1))+3) == 0) MAR = MEXPUN - 1
      MAI = MWK(START(MA(2))+2)
      IF (MWK(START(MA(2))+3) == 0) MAI = MEXPUN - 1
      MBR = MWK(START(MB(1))+2)
      IF (MWK(START(MB(1))+3) == 0) MBR = MEXPUN - 1
      MBI = MWK(START(MB(2))+2)
      IF (MWK(START(MB(2))+3) == 0) MBI = MEXPUN - 1

      CALL FMADD(MA(1),MB(1),MC(1))
      KF1 = KFLAG
      CALL FMADD(MA(2),MB(2),MC(2))

      NCALL = NCALL + 1
      IF (NTRSAV /= 0) THEN
          NTRACE = NTRSAV
          NAMEST(NCALL) = 'ZMADD'
      ENDIF
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = KF1
      IF (KFLAG == 1) THEN
          KFLAG = 0
          IF (MAR <= MBR .AND. MAI <= MBI) KFLAG = 1
          IF (MAR >= MBR .AND. MAI >= MBI) KFLAG = 1
      ENDIF

      IF (MWK(START(MC(1))+2) == MUNKNO .OR. MWK(START(MC(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MC(1))+2) == MEXPOV .OR. MWK(START(MC(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MC(1))+2) == MEXPUN .OR. MWK(START(MC(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MC(1))+2) == MUNKNO) .OR. (MWK(START(MC(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MC(1))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MC(2))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MC(1))+2) == MEXPOV .AND. KOVUN == 0)      &
         .OR. (MWK(START(MC(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMADD'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) THEN
          CALL ZMNTR(1,MC,MC,1)
      ENDIF
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMADD

      SUBROUTINE ZMADDI(MA,INTEG)

!  MA = MA + INTEG        Increment by one-word (real) integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      INTEGER :: INTEG

      INTEGER :: KASAVE,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (INOUT) :: MA
      INTENT (IN) :: INTEG
      INTEGER :: MZ01(2),NUMBER_USED_SAVE

      MZ01 = -2
      NUMBER_USED_SAVE = NUMBER_USED

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          NTRSAV = NTRACE
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'ZMADDI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
              NCALL = NCALL - 1
          ENDIF
          NTRACE = 0
          CALL ZMENTR('ZMADDI   ',MA,MA,1,MZ01,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          NTRACE = NTRSAV
          IF (KRESLT /= 0) THEN
              CALL FMEQ(MZ01(1),MA(1))
              NCALL = NCALL + 1
              IF (NTRACE /= 0) CALL ZMNTR(1,MA,MA,1)
              NCALL = NCALL - 1
              NUMBER_USED = NUMBER_USED_SAVE
              RETURN
          ENDIF
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NTRSAV = NTRACE
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMADDI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMADDI to use more guard digits for user calls.

      NCALL = NCALL - 1
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

      CALL FMADDI(MA(1),INTEG)

      NTRACE = NTRSAV
      KWARN = KWRNSV
      NCALL = NCALL + 1
      IF (NTRACE /= 0) NAMEST(NCALL) = 'ZMADDI'
      IF (MWK(START(MA(1))+2) == MUNKNO .OR. MWK(START(MA(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MA(1))+2) == MEXPOV .OR. MWK(START(MA(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MA(1))+2) == MEXPUN .OR. MWK(START(MA(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MA(1))+2) == MUNKNO) .OR. (MWK(START(MA(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MA(1))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MA(2))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MA(1))+2) == MEXPOV .AND. KOVUN == 0)      &
         .OR. (MWK(START(MA(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMADDI'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE ZMADDI

      SUBROUTINE ZMARG(MA,MBFM)

!  MBFM = ARG(MA)

!  Complex argument.  The result is a real FM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MBFM
      REAL (KIND(1.0D0)) :: MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE,NTRSAV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      INTEGER :: MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MZ01 = -2
      MZ02 = -2
      IF (MBFM <= 0) THEN
          CALL FMDEFINE(MBFM)
      ELSE IF (SIZE_OF(MBFM) < NDIG+3) THEN
          CALL FMDEFINE(MBFM)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NTRSAV = NTRACE
      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'ZMARG'
          CALL ZMNTR(2,MA,MA,1)
          NCALL = NCALL - 1
      ENDIF
      NTRACE = 0
      CALL ZMENTR('ZMARG    ',MA,MA,1,MZ01,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NTRACE = NTRSAV
      IF (KRESLT /= 0) THEN
          CALL FMEQ(MZ01(1),MBFM)
          NCALL = NCALL + 1
          IF (NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

      CALL FMATN2(MZ02(2),MZ02(1),MZ01(1))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXI2(MZ01(1),MBFM,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMARG

      SUBROUTINE ZMASIN(MA,MB)

!  MB = ASIN(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMASIN   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF ((MWK(START(MA(1))+3) == 0 .OR. MWK(START(MA(1))+2)*2 <= -NDIG) .AND.  &
               (MWK(START(MA(2))+3) == 0 .OR. MWK(START(MA(2))+2)*2 <= -NDIG)) THEN
          CALL ZMEQ(MZ04,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          KRSAVE = KRAD
          KRAD = 1
          CALL FMASIN(MZ04(1),MZ01(1))
          KRAD = KRSAVE
          IF (KFLAG == 0) THEN
              CALL FMI2M(0,MZ01(2))
              GO TO 120
          ENDIF
      ENDIF

      CALL ZMI2M(0,MZ01)
      CALL ZMI2M(1,MZ03)
      CALL ZMSUB(MZ03,MZ04,MZ02)
      CALL ZMADD(MZ03,MZ04,MZ05)
      CALL ZMMPY(MZ02,MZ05,MZ03)
      CALL ZMSQRT(MZ03,MZ02)
      DO J = -1, NDIG+1
         MWK(START(MZ03(1))+J+1) = MWK(START(MZ04(2))+J+1)
         MWK(START(MZ03(2))+J+1) = MWK(START(MZ04(1))+J+1)
      ENDDO
      IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
          MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))

      IF ((MWK(START(MZ02(1))+3) /= 0 .AND. MWK(START(MZ03(1))+2) == MWK(START(MZ02(1))+2) .AND.   &
          MWK(START(MZ03(1)))*MWK(START(MZ03(1))+3) == MWK(START(MZ02(1)))*MWK(START(MZ02(1))+3))  &
          .OR. (MWK(START(MZ02(2))+3) /= 0 .AND. MWK(START(MZ03(2))+2) == MWK(START(MZ02(2))+2)    &
          .AND.  MWK(START(MZ03(2)))*MWK(START(MZ03(2))+3) ==  &
                 MWK(START(MZ02(2)))*MWK(START(MZ02(2))+3)) ) THEN
          CALL ZMADD(MZ02,MZ03,MZ05)
          CALL FMSQR(MZ05(1),MXY(2))
          CALL FMSQR(MZ05(2),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(4))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB_R2(MXY(4),MXY(1))
          IF (MWK(START(MXY(1))+2) < 0) THEN
              NDIG = NDIG - INT(MWK(START(MXY(1))+2))
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZMI2M(0,MZ01)
              CALL ZMI2M(1,MZ03)
              CALL ZMSUB(MZ03,MZ04,MZ02)
              CALL ZMADD(MZ03,MZ04,MZ05)
              CALL ZMMPY(MZ02,MZ05,MZ03)
              CALL ZMSQRT(MZ03,MZ02)
              DO J = -1, NDIG+1
                 MWK(START(MZ03(1))+J+1) = MWK(START(MZ04(2))+J+1)
                 MWK(START(MZ03(2))+J+1) = MWK(START(MZ04(1))+J+1)
              ENDDO
              IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
                  MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
              CALL ZMADD(MZ02,MZ03,MZ05)
          ENDIF

          CALL ZMLN(MZ05,MZ03)
          DO J = -1, NDIG+1
             MWK(START(MZ01(1))+J+1) = MWK(START(MZ03(2))+J+1)
             MWK(START(MZ01(2))+J+1) = MWK(START(MZ03(1))+J+1)
          ENDDO
          IF (MWK(START(MZ01(2))+2) /= MUNKNO .AND. MWK(START(MZ01(2))+3) /= 0)  &
              MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))
      ELSE
          CALL ZMSUB(MZ02,MZ03,MZ05)
          CALL FMSQR(MZ05(1),MXY(2))
          CALL FMSQR(MZ05(2),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(4))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB_R2(MXY(4),MXY(1))
          IF (MWK(START(MXY(1))+2) < 0) THEN
              NDIG = NDIG - INT(MWK(START(MXY(1))+2))
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZMI2M(0,MZ01)
              CALL ZMI2M(1,MZ03)
              CALL ZMSUB(MZ03,MZ04,MZ02)
              CALL ZMADD(MZ03,MZ04,MZ05)
              CALL ZMMPY(MZ02,MZ05,MZ03)
              CALL ZMSQRT(MZ03,MZ02)
              DO J = -1, NDIG+1
                 MWK(START(MZ03(1))+J+1) = MWK(START(MZ04(2))+J+1)
                 MWK(START(MZ03(2))+J+1) = MWK(START(MZ04(1))+J+1)
              ENDDO
              IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
                  MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
              CALL ZMSUB(MZ02,MZ03,MZ05)
          ENDIF
          CALL ZMLN(MZ05,MZ03)
          DO J = -1, NDIG+1
             MWK(START(MZ01(1))+J+1) = MWK(START(MZ03(2))+J+1)
             MWK(START(MZ01(2))+J+1) = MWK(START(MZ03(1))+J+1)
          ENDDO
          IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
              MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
      ENDIF

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMASIN

      SUBROUTINE ZMATAN(MA,MB)

!  MB = ATAN(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JTERM,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: X
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMATAN   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ03)
          GO TO 130
      ELSE IF ((MWK(START(MA(1))+3) == 0 .OR. MWK(START(MA(1))+2)*2 <= -NDIG) .AND.  &
               (MWK(START(MA(2))+3) == 0 .OR. MWK(START(MA(2))+2)*2 <= -NDIG)) THEN
          CALL ZMEQ(MZ04,MZ03)
          GO TO 130
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          KRSAVE = KRAD
          KRAD = 1
          CALL FMATAN(MZ04(1),MZ03(1))
          KRAD = KRSAVE
          IF (KFLAG == 0) THEN
              CALL FMI2M(0,MZ03(2))
              GO TO 130
          ENDIF
      ENDIF

      X = 1.0E+5
      CALL FMDPM(DBLE(X),MXY(1))
      CALL FMABS(MZ04(1),MXY(2))
      CALL FMABS(MZ04(2),MXY(3))
      CALL FMADD_R2(MXY(2),MXY(3))

      IF (FMCOMP(MXY(3),'>=',MXY(1))) THEN
          CALL ZMI2M(0,MZ03)
          CALL FMPI(MZ03(1))
          CALL FMDIVI_R1(MZ03(1),2)
          IF (MWK(START(MA(1))) < 0 .AND. MWK(START(MZ03(1))+2) /= MUNKNO .AND.  &
              MWK(START(MZ03(1))+3) /= 0) MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
          CALL ZMI2M(1,MZ01)
          CALL ZMDIV(MZ01,MZ04,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          CALL ZMSUB(MZ03,MZ05,MZ01)
          CALL ZMEQ(MZ01,MZ03)
          IF (MWK(START(MA(1))+2) > NDIG .OR. MWK(START(MA(2))+2) > NDIG) GO TO 130
          CALL ZMSQR(MZ05,MZ01)
          JTERM = 1
  120     CALL ZMMPY(MZ02,MZ01,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          JTERM = JTERM + 2
          CALL FMEQ(MZ02(1),MXY(4))
          CALL FMEQ(MZ02(2),MXY(5))
          CALL ZMDIVI(MZ02,JTERM,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          CALL ZMADD(MZ03,MZ02,MZ05)
          CALL ZMEQ(MZ05,MZ03)
          IF (KFLAG /= 0) GO TO 130
          CALL FMEQ(MXY(4),MZ02(1))
          CALL FMEQ(MXY(5),MZ02(2))
          CALL ZMMPY(MZ02,MZ01,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          JTERM = JTERM + 2
          CALL FMEQ(MZ02(1),MXY(4))
          CALL FMEQ(MZ02(2),MXY(5))
          CALL ZMDIVI(MZ02,JTERM,MZ05)
          CALL ZMEQ(MZ05,MZ02)
          CALL ZMSUB(MZ03,MZ02,MZ05)
          CALL ZMEQ(MZ05,MZ03)
          IF (KFLAG /= 0) GO TO 130
          CALL FMEQ(MXY(4),MZ02(1))
          CALL FMEQ(MXY(5),MZ02(2))
          GO TO 120
      ELSE
          CALL ZMI2M(0,MZ03)
          CALL ZM2I2M(0,1,MZ01)
          CALL ZMSUB(MZ01,MZ04,MZ02)
          CALL ZMADD(MZ01,MZ04,MZ05)
          CALL ZMDIV(MZ05,MZ02,MZ02)
          CALL FMSQR(MZ02(1),MXY(3))
          CALL FMSQR(MZ02(2),MXY(4))
          CALL FMADD(MXY(3),MXY(4),MXY(5))
          CALL FMI2M(1,MXY(2))
          CALL FMSUB_R2(MXY(5),MXY(2))
          IF (MWK(START(MXY(2))+2) < 0) THEN
              NDIG = NDIG - INT(MWK(START(MXY(2))+2))
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZM2I2M(0,1,MZ01)
              CALL ZMSUB(MZ01,MZ04,MZ03)
              CALL ZMADD(MZ01,MZ04,MZ05)
              CALL ZMDIV(MZ05,MZ03,MZ02)
          ENDIF
          CALL ZMLN(MZ02,MZ05)
          CALL ZMDIVI(MZ05,2,MZ02)
          DO J = -1, NDIG+1
             MWK(START(MZ03(1))+J+1) = MWK(START(MZ02(2))+J+1)
             MWK(START(MZ03(2))+J+1) = MWK(START(MZ02(1))+J+1)
          ENDDO
          IF (MWK(START(MZ03(1))+2) /= MUNKNO .AND. MWK(START(MZ03(1))+3) /= 0)  &
              MWK(START(MZ03(1))) = -MWK(START(MZ03(1)))
      ENDIF

  130 MACCMB = MWK(START(MZ03(1))+1)
      MWK(START(MZ03(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ03(2))+1)
      MWK(START(MZ03(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ03(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ03(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ03,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMATAN

      SUBROUTINE ZMCHSH(MA,MB,MC)

!  MB = COSH(MA),    MC = SINH(MA).

!  If both the hyperbolic sine and cosine are needed, this routine is faster than calling both
!  ZMCOSH and ZMSINH.

!  MB and MC must be distinct arrays.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NCSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCSAVE = NCALL
      CALL ZMENTR('ZMCHSH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NCALL = NCSAVE + 1
      IF (KRESLT /= 0) THEN
          CALL ZMEQ(MB,MC)
          IF (NTRACE /= 0) THEN
              CALL ZMNTR(1,MB,MB,1)
              IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
                  IF (NTRACE < 0) THEN
                      CALL ZMNTRJ(MC,NDIG)
                  ELSE
                      CALL ZMPRNT(MC)
                  ENDIF
              ENDIF
          ENDIF
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
              IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(1,MZ01)
          CALL ZMI2M(0,MZ05)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMCHSH(MZ04(1),MZ01(1),MZ05(1))
          CALL FMI2M(0,MZ01(2))
          CALL FMI2M(0,MZ05(2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMCSSN(MZ04(2),MZ01(1),MZ05(2))
          CALL FMI2M(0,MZ01(2))
          CALL FMI2M(0,MZ05(1))
          GO TO 120
      ENDIF

!             Find SINH(REAL(MA)) and COSH(REAL(MA)).

      CALL FMCHSH(MZ04(1),MZ02(1),MZ02(2))

!             Find SIN(IMAG(MA)) and COS(IMAG(MA)).

      CALL FMCSSN(MZ04(2),MZ03(1),MZ03(2))

!             COSH(MA) =  COSH(REAL(MA))*COS(IMAG(MA)) + SINH(REAL(MA))*SIN(IMAG(MA)) i

      CALL FMMPY(MZ02(1),MZ03(1),MZ01(1))
      CALL FMMPY(MZ02(2),MZ03(2),MZ01(2))

!             SINH(MA) =  SINH(REAL(MA))*COS(IMAG(MA)) + COSH(REAL(MA))*SIN(IMAG(MA)) i

      CALL FMMPY(MZ02(2),MZ03(1),MZ05(1))
      CALL FMMPY(MZ02(1),MZ03(2),MZ05(2))

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      MWK(START(MZ05(1))+1) = MWK(START(MZ01(1))+1)
      MWK(START(MZ05(2))+1) = MWK(START(MZ01(2))+1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      KACCSW = KASAVE
      CALL ZMEQU(MZ05,MC,NDIG,NDSAVE)
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (NTRACE /= 0) THEN
          IF (ABS(NTRACE) >= 1 .AND. NCALL+1 <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL ZMNTRJ(MC,NDIG)
              ELSE
                  CALL ZMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCHSH

      SUBROUTINE ZMCMPX(MAFM,MBFM,MC)

!  MC = COMPLEX( MAFM , MBFM )

!  MAFM and MBFM are real FM numbers, MC is a complex ZM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MAFM,MBFM,MC(2)
      INTENT (IN) :: MAFM,MBFM
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF

      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMCMPX'
      IF (NTRACE /= 0) CALL FMNTR(2,MAFM,MBFM,2,1)

      CALL FMEQ(MAFM,MC(1))
      CALL FMEQ(MBFM,MC(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCMPX

      SUBROUTINE ZMCONJ(MA,MB)

!  MB = CONJG(MA)

!  Complex conjugate.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMCONJ'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMEQ(MA(1),MB(1))
      CALL FMEQ(MA(2),MB(2))
      IF (MWK(START(MB(2))+2) /= MUNKNO .AND. MWK(START(MB(2))+3) /= 0)  &
          MWK(START(MB(2))) = -MWK(START(MB(2)))

      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCONJ

      SUBROUTINE ZMCOS(MA,MB)

!  MB = COS(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMCOS    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(1,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMCOS(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMCOSH(MZ02(2),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ENDIF

!             Find COS(REAL(MA)) and SIN(REAL(MA)).

      CALL FMCSSN(MZ02(1),MZ01(1),MZ01(2))

!             Find COSH(IMAG(MA)) and SINH(IMAG(MA)).

      CALL FMCHSH(MZ02(2),MXY(1),MXY(2))

!             COS(MA) =  COS(REAL(MA))*COSH(IMAG(MA)) - SIN(REAL(MA))*SINH(IMAG(MA)) i

      CALL FMMPY_R1(MZ01(1),MXY(1))
      IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
          MWK(START(MXY(2))) = -MWK(START(MXY(2)))
      CALL FMMPY_R1(MZ01(2),MXY(2))

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCOS

      SUBROUTINE ZMCOSH(MA,MB)

!  MB = COSH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMCOSH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(1,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMCOS(MZ02(2),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMCOSH(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ENDIF

!             Find COS(IMAG(MA)) and SIN(IMAG(MA)).

      CALL FMCSSN(MZ02(2),MZ01(1),MZ01(2))

!             Find COSH(REAL(MA)) and SINH(REAL(MA)).

      CALL FMCHSH(MZ02(1),MXY(1),MXY(2))

!             COSH(MA) =  COSH(REAL(MA))*COS(IMAG(MA)) + SINH(REAL(MA))*SIN(IMAG(MA)) i

      CALL FMMPY_R1(MZ01(1),MXY(1))
      CALL FMMPY_R1(MZ01(2),MXY(2))

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCOSH

      SUBROUTINE ZMCSSN(MA,MB,MC)

!  MB = COS(MA),    MC = SIN(MA).

!  If both the sine and cosine are needed, this routine is faster than calling both ZMCOS and ZMSIN.

!  MB and MC must be distinct arrays.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NCSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCSAVE = NCALL
      CALL ZMENTR('ZMCSSN   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NCALL = NCSAVE + 1
      IF (KRESLT /= 0) THEN
          CALL ZMEQ(MB,MC)
          IF (NTRACE /= 0) THEN
              CALL ZMNTR(1,MB,MB,1)
              IF (ABS(NTRACE) >= 1 .AND. NCALL <= LVLTRC) THEN
                  IF (NTRACE < 0) THEN
                      CALL ZMNTRJ(MC,NDIG)
                  ELSE
                      CALL ZMPRNT(MC)
                  ENDIF
              ENDIF
          ENDIF
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
              IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(1,MZ01)
          CALL ZMI2M(0,MZ05)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMCSSN(MZ04(1),MZ01(1),MZ05(1))
          CALL FMI2M(0,MZ01(2))
          CALL FMI2M(0,MZ05(2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMCHSH(MZ04(2),MZ01(1),MZ05(2))
          CALL FMI2M(0,MZ01(2))
          CALL FMI2M(0,MZ05(1))
          GO TO 120
      ENDIF

!             Find SIN(REAL(MA)) and COS(REAL(MA)).

      CALL FMCSSN(MZ04(1),MZ02(1),MZ02(2))

!             Find SINH(IMAG(MA)) and COSH(IMAG(MA)).

      CALL FMCHSH(MZ04(2),MZ03(1),MZ03(2))

!             COS(MA) =  COS(REAL(MA))*COSH(IMAG(MA)) - SIN(REAL(MA))*SINH(IMAG(MA)) i

      CALL FMMPY(MZ02(1),MZ03(1),MZ01(1))
      CALL FMMPY(MZ02(2),MZ03(2),MZ01(2))
      IF (MWK(START(MZ01(2))+2) /= MUNKNO .AND. MWK(START(MZ01(2))+3) /= 0)  &
          MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))

!             SIN(MA) =  SIN(REAL(MA))*COSH(IMAG(MA)) + COS(REAL(MA))*SINH(IMAG(MA)) i

      CALL FMMPY(MZ02(2),MZ03(1),MZ05(1))
      CALL FMMPY(MZ02(1),MZ03(2),MZ05(2))

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      MWK(START(MZ05(1))+1) = MWK(START(MZ01(1))+1)
      MWK(START(MZ05(2))+1) = MWK(START(MZ01(2))+1)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      KACCSW = KASAVE
      CALL ZMEQU(MZ05,MC,NDIG,NDSAVE)
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (NTRACE /= 0) THEN
          IF (ABS(NTRACE) >= 1 .AND. NCALL+1 <= LVLTRC) THEN
              IF (NTRACE < 0) THEN
                  CALL ZMNTRJ(MC,NDIG)
              ELSE
                  CALL ZMPRNT(MC)
              ENDIF
          ENDIF
      ENDIF
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMCSSN

      SUBROUTINE ZMDIV(MA,MB,MC)

!  MC = MA / MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MBIZ,MBRZ,MXSAVE,MZ11SV,MZ1KSV
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDGSV2,NDSAVE,NGOAL,NTRSAV
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(8),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MB(1))+2)) > MEXPAB .OR. ABS(MWK(START(MB(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMDIV    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
                  IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMDIV'
              CALL ZMNTR(2,MA,MB,2)
          ENDIF
          NDSAVE = NDIG
          NDIG = MAX(NDIG+NGRD52,2)
          IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR. MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
              NDIG = NDIG + 1
          ELSE IF (MBASE >= 100*ABS(MWK(START(MB(1))+3)) .OR.  &
              MBASE >= 100*ABS(MWK(START(MB(2))+3))) THEN
              NDIG = NDIG + 1
          ENDIF
          KASAVE = KACCSW
          KACCSW = 1
          MXSAVE = MXEXP
          MXEXP = MXEXP2
          KOVUN = 0
      ENDIF

      NTRSAV = NTRACE
      NTRACE = 0
      MARZ = MWK(START(MA(1))+1)
      MBRZ = MWK(START(MB(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      MBIZ = MWK(START(MB(2))+1)
      KR_RETRY = 0
      KWRNSV = KWARN
      KWARN = 0
      IEXTRA = 0
      MZ11SV = -MUNKNO
      MZ1KSV = -MUNKNO

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA(1),MXY(5),NDSAVE,NDIG)
      CALL FMEQU(MA(2),MXY(6),NDSAVE,NDIG)
      CALL FMEQU(MB(1),MXY(7),NDSAVE,NDIG)
      CALL FMEQU(MB(2),MXY(8),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(7))+1) = MWK(START(MXY(5))+1)
      MWK(START(MXY(6))+1) = MWK(START(MXY(5))+1)
      MWK(START(MXY(8))+1) = MWK(START(MXY(5))+1)

!             Check for special cases.

      IF (MWK(START(MB(2))+3) == 0) THEN
          CALL FMDIVD(MXY(5),MXY(6),MXY(7),MZ01(1),MZ01(2))
          GO TO 130
      ELSE IF (MWK(START(MB(1))+3) == 0) THEN
          CALL FMDIVD(MXY(6),MXY(5),MXY(8),MZ01(1),MZ01(2))
          IF (MWK(START(MZ01(2))+2) /= MUNKNO .AND. MWK(START(MZ01(2))+3) /= 0)  &
              MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))
          GO TO 130
      ENDIF
      IF (MWK(START(MA(1))+2) == MWK(START(MB(1))+2) .AND.  &
          MWK(START(MA(1))+3) == MWK(START(MB(1))+3) .AND.  &
          MWK(START(MA(1))) == MWK(START(MB(1)))) THEN
          IF (MWK(START(MA(2))+2) == MWK(START(MB(2))+2) .AND.  &
              MWK(START(MA(2))+3) == MWK(START(MB(2))+3) .AND.  &
              MWK(START(MA(2))) == MWK(START(MB(2)))) THEN
              DO J = 3, NDSAVE+1
                 IF (MWK(START(MA(1))+J+1) /= MWK(START(MB(1))+J+1)) GO TO 120
                 IF (MWK(START(MA(2))+J+1) /= MWK(START(MB(2))+J+1)) GO TO 120
              ENDDO
              IF (ABS(MWK(START(MA(1))+2)) < MEXPOV .AND. ABS(MWK(START(MA(2))+2)) < MEXPOV  &
                  .AND. ABS(MWK(START(MB(1))+2)) < MEXPOV .AND.  &
                  ABS(MWK(START(MB(2))+2)) < MEXPOV) THEN
                  CALL ZMI2M(1,MZ01)
                  GO TO 130
              ENDIF
          ENDIF
      ENDIF
      IF (MWK(START(MA(1))+2) == MWK(START(MB(1))+2) .AND.  &
          MWK(START(MA(1))+3) == MWK(START(MB(1))+3) .AND.  &
          (-MWK(START(MA(1)))) == MWK(START(MB(1)))) THEN
          IF (MWK(START(MA(2))+2) == MWK(START(MB(2))+2) .AND.  &
              MWK(START(MA(2))+3) == MWK(START(MB(2))+3) .AND.  &
              (-MWK(START(MA(2)))) == MWK(START(MB(2)))) THEN
              DO J = 3, NDSAVE+1
                 IF (MWK(START(MA(1))+J+1) /= MWK(START(MB(1))+J+1)) GO TO 120
                 IF (MWK(START(MA(2))+J+1) /= MWK(START(MB(2))+J+1)) GO TO 120
              ENDDO
              IF (ABS(MWK(START(MA(1))+2)) < MEXPOV .AND. ABS(MWK(START(MA(2))+2)) < MEXPOV  &
                  .AND. ABS(MWK(START(MB(1))+2)) < MEXPOV .AND.  &
                  ABS(MWK(START(MB(2))+2)) < MEXPOV) THEN
                  CALL ZMI2M(-1,MZ01)
                  GO TO 130
              ENDIF
          ENDIF
      ENDIF
  120 IF (MZ11SV /= -MUNKNO) THEN

!             If a retry is being done due to cancellation, try a slower but more stable form of
!             the division formula.

!               ( a + b i ) / ( c + d i ) =
!
!               ( a*c + b*d) / ( c*c + d*d ) + ( b*c - a*d) / ( c*c + d*d ) i

          CALL FMMPYE(MXY(7),MXY(5),MXY(6),MXY(7), MZ01(1),MZ01(2),MXY(3))
          CALL FMMPYE(MXY(8),MXY(6),MXY(5),MXY(8), MXY(1),MXY(2),MXY(4))
          CALL FMADD_R2(MXY(3),MXY(4))
          CALL FMADD_R1(MZ01(1),MXY(1))
          CALL FMSUB_R1(MZ01(2),MXY(2))
          CALL FMDIVD(MZ01(1),MZ01(2),MXY(4),MZ02(1),MZ02(2))
          CALL ZMEQ(MZ02,MZ01)
          IF (ABS(MWK(START(MZ01(1))+2)) < MEXPOV .AND.  &
              ABS(MWK(START(MZ01(2))+2)) < MEXPOV) GO TO 130
      ENDIF

!             Normal method for  ( a + b i ) / ( c + d i ):

!             If  abs(c) << abs(d)  Then

!                 P = c / d
!                 result = ( a*P + b )/( c*P + d ) + ( b*P - a )/( c*P + d ) i

!             Else

!                 P = d / c
!                 result = ( b*P + a )/( d*P + c ) + ( b - a*P )/( d*P + c ) i

      KACCSW = 0
      IF (MWK(START(MB(1))+2) <= MWK(START(MB(2))+2)) THEN
          CALL FMDIV(MXY(7),MXY(8),MXY(4))
          CALL FMMPYE(MXY(4),MXY(5),MXY(6),MXY(7),MZ01(1),MZ01(2),MXY(3))
          IF (MWK(START(MA(2)))*MWK(START(MZ01(1))) < 0) THEN
              KACCSW = 1
          ELSE
              KACCSW = 0
          ENDIF
          CALL FMADD_R2(MXY(6),MZ01(1))
          IF (MWK(START(MXY(3)))*MWK(START(MB(2))) < 0) THEN
              KACCSW = 1
          ELSE
              KACCSW = 0
          ENDIF
          CALL FMADD_R1(MXY(3),MXY(8))
          IF (MWK(START(MZ01(2)))*MWK(START(MA(1))) < 0) THEN
              KACCSW = 0
          ELSE
              KACCSW = 1
          ENDIF
          CALL FMSUB_R1(MZ01(2),MXY(5))
          KACCSW = 0
          CALL FMDIVD(MZ01(1),MZ01(2),MXY(3),MZ02(1),MZ02(2))
          CALL ZMEQ(MZ02,MZ01)
      ELSE
          CALL FMDIV(MXY(8),MXY(7),MXY(4))
          CALL FMMPYE(MXY(4),MXY(6),MXY(5),MXY(8), MZ01(1),MZ01(2),MXY(3))
          IF (MWK(START(MA(1)))*MWK(START(MZ01(1))) < 0) THEN
              KACCSW = 1
          ELSE
              KACCSW = 0
          ENDIF
          CALL FMADD_R2(MXY(5),MZ01(1))
          IF (MWK(START(MXY(3)))*MWK(START(MB(1))) < 0) THEN
              KACCSW = 1
          ELSE
              KACCSW = 0
          ENDIF
          CALL FMADD_R1(MXY(3),MXY(7))
          IF (MWK(START(MZ01(2)))*MWK(START(MA(2))) < 0) THEN
              KACCSW = 0
          ELSE
              KACCSW = 1
          ENDIF
          CALL FMSUB_R2(MXY(6),MZ01(2))
          KACCSW = 0
          CALL FMDIVD(MZ01(1),MZ01(2),MXY(3),MZ02(1),MZ02(2))
          CALL ZMEQ(MZ02,MZ01)
      ENDIF
      KACCSW = 1

!             If one of the two parts of the result is unknown, re-try using the more
!             stable formula.

      IF (MZ11SV == -MUNKNO) THEN
          IF (MWK(START(MZ01(1))+2) == MUNKNO .OR. MWK(START(MZ01(2))+2) == MUNKNO) THEN
              MZ11SV = MWK(START(MZ01(1))+2)
              MZ1KSV = MWK(START(MZ01(2))+2)
              GO TO 110
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
      IF (MWK(START(MZ01(1))+1) <= NGOAL .OR. MWK(START(MZ01(2))+1) <= NGOAL) THEN
          IF (MZ11SV-MWK(START(MZ01(1))+2) >= IEXTRA-1 .AND. MWK(START(MZ01(2))+1) > NGOAL)  &
              GO TO 140
          IF (MZ1KSV-MWK(START(MZ01(2))+2) >= IEXTRA-1 .AND. MWK(START(MZ01(1))+1) > NGOAL)  &
              GO TO 140
          IF (MZ11SV > -MUNKNO .AND. MWK(START(MZ01(1))+1) > NGOAL .AND.  &
              MWK(START(MZ01(2))+3) == 0) GO TO 140
          IF (MZ11SV > -MUNKNO .AND. MWK(START(MZ01(2))+1) > NGOAL .AND.  &
              MWK(START(MZ01(1))+3) == 0) GO TO 140
          IEXTRA = INT(REAL(MAX(NGOAL-MWK(START(MZ01(1))+1),NGOAL-MWK(START(MZ01(2))+1)))  &
                   /ALOGM2 + 23.03/ALOGMB) + 1
          MZ11SV = MWK(START(MZ01(1))+2)
          MZ1KSV = MWK(START(MZ01(2))+2)
          NDIG = NDIG + IEXTRA
          GO TO 110
      ENDIF

  140 MXEXP = MXSAVE
      NTRACE = NTRSAV
      NDGSV2 = NDIG
      NDIG = NDSAVE
      KWARN = KWRNSV
      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)
      CALL ZMEQU(MZ01,MC,NDGSV2,NDSAVE)
      IF (MWK(START(MC(1))+2) >= MEXPOV .OR. MWK(START(MC(1))+2) <= -MEXPOV .OR.  &
          MWK(START(MC(2))+2) >= MEXPOV .OR. MWK(START(MC(2))+2) <= -MEXPOV) THEN
          IF (MWK(START(MC(1))+2) == MUNKNO .OR. MWK(START(MC(2))+2) == MUNKNO) THEN
              KFLAG = -4
          ELSE IF (MWK(START(MC(1))+2) == MEXPOV .OR. MWK(START(MC(2))+2) == MEXPOV) THEN
              KFLAG = -5
          ELSE IF (MWK(START(MC(1))+2) == MEXPUN .OR. MWK(START(MC(2))+2) == MEXPUN) THEN
              KFLAG = -6
          ENDIF
          IF ((MWK(START(MC(1))+2) == MUNKNO) .OR. (MWK(START(MC(2))+2) == MUNKNO)  &
             .OR. (MWK(START(MC(1))+2) == MEXPUN .AND. KOVUN == 0)  &
             .OR. (MWK(START(MC(2))+2) == MEXPUN .AND. KOVUN == 0)  &
             .OR. (MWK(START(MC(1))+2) == MEXPOV .AND. KOVUN == 0)  &
             .OR. (MWK(START(MC(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
                  NAMEST(NCALL) = 'ZMDIV'
                  CALL ZMWARN
          ENDIF
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
      KACCSW = KASAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMDIV

      SUBROUTINE ZMDIVI(MA,INTEG,MB)

!  MB = MA / INTEG        Divide by one-word (real) integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTEGER :: INTEG

      INTEGER :: KASAVE,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          NTRSAV = NTRACE
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'ZMDIVI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
              NCALL = NCALL - 1
          ENDIF
          NTRACE = 0
          CALL ZMENTR('ZMDIVI   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          NTRACE = NTRSAV
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
              NCALL = NCALL - 1
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
                  IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMDIVI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMDIVI to use more guard digits for user calls.

      NCALL = NCALL - 1
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

      CALL FMDIVI(MA(1),INTEG,MB(1))
      CALL FMDIVI(MA(2),INTEG,MB(2))

      NTRACE = NTRSAV
      KWARN = KWRNSV
      NCALL = NCALL + 1
      IF (NTRACE /= 0) NAMEST(NCALL) = 'ZMDIVI'
      IF (MWK(START(MB(1))+2) == MUNKNO .OR. MWK(START(MB(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MB(1))+2) == MEXPOV .OR. MWK(START(MB(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MB(1))+2) == MEXPUN .OR. MWK(START(MB(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MB(1))+2) == MUNKNO) .OR. (MWK(START(MB(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MB(1))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MB(2))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MB(1))+2) == MEXPOV .AND. KOVUN == 0)      &
         .OR. (MWK(START(MB(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMDIVI'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMDIVI

      SUBROUTINE ZMENTR(NROUTN,MA,MB,NARGS,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Do the argument checking and increasing of precision, overflow threshold, etc., upon entry to
!  a ZM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result immediately
!           (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KASAVE - saves the value of KACCSW
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow or underflow.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      INTEGER :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NARGS,KRESLT,NDSAVE,KASAVE,KOVUN

      REAL (KIND(1.0D0)) :: MBS
      INTEGER :: J,KWRNSV,NDS
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      KRESLT = 0
      NCALL = NCALL + 1
      KFLAG = 0
      NAMEST(NCALL) = NROUTN
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MB,NARGS)

      IF (MBLOGS /= MBASE) CALL FMCONS
      KOVUN = 0
      IF (MWK(START(MA(1))+2) == MEXPOV .OR. MWK(START(MA(1))+2) == MEXPUN .OR.  &
          MWK(START(MA(2))+2) == MEXPOV .OR. MWK(START(MA(2))+2) == MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MWK(START(MB(1))+2) == MEXPOV .OR. MWK(START(MB(1))+2) == MEXPUN .OR.  &
          MWK(START(MB(2))+2) == MEXPOV .OR. MWK(START(MB(2))+2) == MEXPUN) KOVUN = 1
      ENDIF
      KASAVE = KACCSW
      MXSAVE = MXEXP

!             Check the validity of parameters if this is a user call.

      IF (NCALL > 1 .AND. KDEBUG == 0) GO TO 130

!             Check NDIG.

      IF (NDIG < 2) THEN
          KFLAG = -1
          CALL ZMWARN
          NDS = NDIG
          IF (NDIG < 2) NDIG = 2
          WRITE (KW,  &
                 "(' NDIG was',I10,'.  It has been changed to',I10,'.')"  &
                ) NDS,NDIG
          KRESLT = 12
          GO TO 130
      ENDIF

!             Check MBASE.

      IF (MBASE < 2 .OR. MBASE > MXBASE) THEN
          KFLAG = -2
          CALL ZMWARN
          MBS = MBASE
          IF (MBASE < 2) MBASE = 2
          IF (MBASE > MXBASE) MBASE = MXBASE
          WRITE (KW,  &
                 "(' MBASE was',I10,'.  It has been changed to',I10,'.')"  &
                ) INT(MBS),INT(MBASE)
          CALL FMCONS
          KRESLT = 12
          GO TO 130
      ENDIF

!             Check exponent range.

      IF (MWK(START(MA(1))+2) > MXEXP+1 .OR. MWK(START(MA(1))+2) < -MXEXP) THEN
          IF ((ABS(MWK(START(MA(1))+2)) /= MEXPOV .AND. ABS(MWK(START(MA(1))+2)) /= MUNKNO) .OR.  &
              ABS(MWK(START(MA(1))+3)) /= 1) THEN
              KFLAG = -3
              CALL ZMWARN
              KRESLT = 12
              GO TO 130
          ENDIF
      ENDIF
      IF (MWK(START(MA(2))+2) > MXEXP+1 .OR. MWK(START(MA(2))+2) < -MXEXP) THEN
          IF ((ABS(MWK(START(MA(2))+2)) /= MEXPOV .AND. ABS(MWK(START(MA(2))+2)) /= MUNKNO) .OR.  &
              ABS(MWK(START(MA(2))+3)) /= 1) THEN
              KFLAG = -3
              CALL ZMWARN
              KRESLT = 12
              GO TO 130
          ENDIF
      ENDIF
      IF (NARGS == 2) THEN
          IF (MWK(START(MB(1))+2) > MXEXP+1 .OR. MWK(START(MB(1))+2) < -MXEXP) THEN
              IF ((ABS(MWK(START(MB(1))+2)) /= MEXPOV .AND.  &
                   ABS(MWK(START(MB(1))+2)) /= MUNKNO) .OR. ABS(MWK(START(MB(1))+3)) /= 1) THEN
                  KFLAG = -3
                  CALL ZMWARN
                  KRESLT = 12
                  GO TO 130
              ENDIF
          ENDIF
          IF (MWK(START(MB(2))+2) > MXEXP+1 .OR. MWK(START(MB(2))+2) < -MXEXP) THEN
              IF ((ABS(MWK(START(MB(2))+2)) /= MEXPOV .AND.  &
                   ABS(MWK(START(MB(2))+2)) /= MUNKNO) .OR. ABS(MWK(START(MB(2))+3)) /= 1) THEN
                  KFLAG = -3
                  CALL ZMWARN
                  KRESLT = 12
                  GO TO 130
              ENDIF
          ENDIF
      ENDIF

!             Check for properly normalized digits in the input arguments.

      IF (ABS(MWK(START(MA(1))+2)-INT(MWK(START(MA(1))+2))) /= 0) KFLAG = 1
      IF (ABS(MWK(START(MA(2))+2)-INT(MWK(START(MA(2))+2))) /= 0) KFLAG = 1 + NDIG + 1
      IF (MWK(START(MA(1))+3) <= (-1) .OR. MWK(START(MA(1))+3) >= MBASE .OR.  &
          ABS(MWK(START(MA(1))+3)-INT(MWK(START(MA(1))+3))) /= 0) KFLAG = 2
      IF (MWK(START(MA(2))+3) <= (-1) .OR. MWK(START(MA(2))+3) >= MBASE .OR.  &
          ABS(MWK(START(MA(2))+3)-INT(MWK(START(MA(2))+3))) /= 0) KFLAG = 2 + NDIG + 1
      IF (KDEBUG == 0) GO TO 110
      DO J = 3, NDIG+1
         IF (MWK(START(MA(1))+J+1) < 0 .OR. MWK(START(MA(1))+J+1) >= MBASE .OR.  &
             ABS(MWK(START(MA(1))+J+1)-INT(MWK(START(MA(1))+J+1))) /= 0) THEN
             KFLAG = J
             GO TO 110
         ENDIF
      ENDDO
      DO J = 3, NDIG+1
         IF (MWK(START(MA(2))+J+1) < 0 .OR. MWK(START(MA(2))+J+1) >= MBASE .OR.  &
             ABS(MWK(START(MA(2))+J+1)-INT(MWK(START(MA(2))+J+1))) /= 0) THEN
             KFLAG = J + NDIG + 1
             GO TO 110
         ENDIF
      ENDDO
  110 IF (KFLAG /= 0) THEN
          J = KFLAG
          KFLAG = -4
          KWRNSV = KWARN
          IF (KWARN >= 2) KWARN = 1
          CALL ZMWARN
          KWARN = KWRNSV
          IF (KWARN >= 1) THEN
              IF (J < NDIG+1) THEN
                  WRITE (KW,*) ' First invalid array element:  MA(',  &
                               J,',1) = ',MWK(START(MA(1))+J+1)
              ELSE
                  WRITE (KW,*) ' First invalid array element:  MA(',  &
                               J-NDIG-1,',2) = ',MWK(START(MA(2))+J+1)
              ENDIF
          ENDIF
          IF (KWARN >= 2) THEN
              STOP
          ENDIF
          KRESLT = 12
          GO TO 130
      ENDIF
      IF (NARGS == 2) THEN
          IF (ABS(MWK(START(MB(1))+2)-INT(MWK(START(MB(1))+2))) /= 0) KFLAG = 1
          IF (ABS(MWK(START(MB(2))+2)-INT(MWK(START(MB(2))+2))) /= 0) KFLAG = 1 + NDIG + 1
          IF (MWK(START(MB(1))+3) <= (-1) .OR. MWK(START(MB(1))+3) >= MBASE .OR.  &
              ABS(MWK(START(MB(1))+3)-INT(MWK(START(MB(1))+3))) /= 0) KFLAG = 2
          IF (MWK(START(MB(2))+3) <= (-1) .OR. MWK(START(MB(2))+3) >= MBASE .OR.  &
              ABS(MWK(START(MB(2))+3)-INT(MWK(START(MB(2))+3))) /= 0) KFLAG = 2 + NDIG + 1
          IF (KDEBUG == 0) GO TO 120
          DO J = 3, NDIG+1
             IF (MWK(START(MB(1))+J+1) < 0 .OR. MWK(START(MB(1))+J+1) >= MBASE .OR.  &
                 ABS(MWK(START(MB(1))+J+1)-INT(MWK(START(MB(1))+J+1))) /= 0) THEN
                 KFLAG = J
                 GO TO 120
             ENDIF
          ENDDO
          DO J = 3, NDIG+1
             IF (MWK(START(MB(2))+J+1) < 0 .OR. MWK(START(MB(2))+J+1) >= MBASE .OR.  &
                 ABS(MWK(START(MB(2))+J+1)-INT(MWK(START(MB(2))+J+1))) /= 0) THEN
                 KFLAG = J + NDIG + 1
                 GO TO 120
             ENDIF
          ENDDO
  120     IF (KFLAG /= 0) THEN
              J = KFLAG
              KFLAG = -4
              KWRNSV = KWARN
              IF (KWARN >= 2) KWARN = 1
              CALL ZMWARN
              KWARN = KWRNSV
              IF (KWARN >= 1) THEN
                  IF (J < NDIG+1) THEN
                      WRITE (KW,*) ' First invalid array element:  MB(',  &
                                   J,',1) = ',MWK(START(MB(1))+J+1)
                  ELSE
                      WRITE (KW,*) ' First invalid array element:  MB(',  &
                                   J-NDIG-1,',2) = ',MWK(START(MB(2))+J+1)
                  ENDIF
              ENDIF
              IF (KWARN >= 2) THEN
                  STOP
              ENDIF
              KRESLT = 12
              GO TO 130
          ENDIF
      ENDIF

!             Increase the working precision.

  130 NDSAVE = NDIG
      IF (NCALL == 1) THEN
          NDIG = MAX(NDIG+NGRD52,2)
          IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR. MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
              NDIG = NDIG + 1
          ELSE IF (NARGS == 2 .AND. (MBASE >= 100*ABS(MWK(START(MB(1))+3)) .OR.  &
              MBASE >= 100*ABS(MWK(START(MB(2))+3)))) THEN
              NDIG = NDIG + 1
          ENDIF
      ENDIF
      IF ((MWK(START(MA(1))+2) == MUNKNO .AND. MWK(START(MA(2))+2) == MUNKNO) .OR.  &
          (MWK(START(MB(1))+2) == MUNKNO .AND. MWK(START(MB(2))+2) == MUNKNO)) THEN
          KFLAG = -4
          KRESLT = 12
      ENDIF
      IF (KRESLT /= 0) THEN
          NDIG = NDSAVE
          CALL ZMRSLT(MC,KRESLT)
          IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
          NCALL = NCALL - 1
          RETURN
      ENDIF

      KACCSW = 1

!             Extend the overflow/underflow threshold.

      MXEXP = MXEXP2
      RETURN
      END SUBROUTINE ZMENTR

      SUBROUTINE ZMEQ(MA,MB)

!  MB = MA

!  This is the standard form of equality, where MA and MB both have precision NDIG.
!  Use ZMEQU for assignments that also change precision.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMEQ(MA(1),MB(1))
      CALL FMEQ(MA(2),MB(2))
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMEQ

      SUBROUTINE ZMEQU(MA,MB,NDA,NDB)

!  Set MB (having NDB digits) equal to MA (having NDA digits).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTEGER :: NDA,NDB
      INTENT (IN) :: NDA,NDB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMEQU(MA(1),MB(1),NDA,NDB)
      CALL FMEQU(MA(2),MB(2),NDA,NDB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMEQU

      SUBROUTINE ZMEQU_R1(MA,NDA,NDB)

!  Change precision of MA from NDA digits on input to NDB digits on output.

!  If NDB is less than NDA the result is rounded to NDB digits.

!  If NDB is greater than NDA the result has zero digits padded on the right.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      INTEGER :: NDA,NDB
      INTENT (IN) :: NDA,NDB
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMEQU_R1(MA(1),NDA,NDB)
      CALL FMEQU_R1(MA(2),NDA,NDB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMEQU_R1

      SUBROUTINE ZMEXIT(MT,MC,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Upon exit from an ZM routine the result MT (having precision NDIG) is rounded and returned in
!  MC (having precision NDSAVE).
!  The values of NDIG, MXEXP, and KACCSW are restored to the values NDSAVE,MXSAVE,KASAVE.
!  KOVUN is nonzero if one of the routine's input arguments was overflow or underflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MT(2),MC(2)
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KASAVE,KOVUN

      INTEGER :: KFSAVE,KWRNSV
      INTENT (IN) :: MT
      INTENT (INOUT) :: MC,NDSAVE,MXSAVE,KASAVE,KOVUN

      KWRNSV = KWARN
      KWARN = 0
      MXEXP = MXSAVE
      KFSAVE = KFLAG
      KACCSW = KASAVE
      CALL ZMEQU(MT,MC,NDIG,NDSAVE)
      IF (KFLAG /= -5 .AND. KFLAG /= -6) KFLAG = KFSAVE
      NDIG = NDSAVE
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = 0
      IF (MWK(START(MC(1))+2) == MEXPUN .OR. MWK(START(MC(2))+2) == MEXPUN) KFLAG = -6
      IF (MWK(START(MC(1))+2) == MEXPOV .OR. MWK(START(MC(2))+2) == MEXPOV) KFLAG = -5
      IF (MWK(START(MC(1))+2) == MUNKNO .OR. MWK(START(MC(2))+2) == MUNKNO) THEN
          IF (KFLAG /= -9) KFLAG = -4
      ENDIF
      IF ((MWK(START(MC(1))+2) == MUNKNO .AND. KFLAG /= -9) .OR.  &
          (MWK(START(MC(2))+2) == MUNKNO .AND. KFLAG /= -9) .OR.  &
          (MWK(START(MC(1))+2) == MEXPUN .AND. KOVUN == 0)  .OR.  &
          (MWK(START(MC(2))+2) == MEXPUN .AND. KOVUN == 0)  .OR.  &
          (MWK(START(MC(1))+2) == MEXPOV .AND. KOVUN == 0)  .OR.  &
          (MWK(START(MC(2))+2) == MEXPOV .AND. KOVUN == 0)) CALL ZMWARN
      IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE ZMEXIT

      SUBROUTINE ZMEXI2(MXFM,MYFM,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  This routine is used upon exit for complex functions that return real FM results.
!  Round MXFM and return the result in MYFM.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MXFM,MYFM
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KASAVE,KOVUN
      INTENT (IN) :: MXFM
      INTENT (INOUT) :: MYFM,NDSAVE,MXSAVE,KASAVE,KOVUN

      INTEGER :: KFSAVE,KWRNSV

      KWRNSV = KWARN
      KWARN = 0
      MXEXP = MXSAVE
      KFSAVE = KFLAG
      KACCSW = KASAVE
      CALL FMEQU(MXFM,MYFM,NDIG,NDSAVE)
      IF (KFLAG /= -5 .AND. KFLAG /= -6) KFLAG = KFSAVE
      NDIG = NDSAVE
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = 0
      IF (MWK(START(MYFM)+2) == MUNKNO) THEN
          IF (KFLAG >= 0) KFLAG = -4
      ELSE IF (MWK(START(MYFM)+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MYFM)+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MYFM)+2) == MUNKNO .AND. KFLAG /= -9)     &
         .OR. (MWK(START(MYFM)+2) == MEXPUN .AND. KOVUN == 0)  &
         .OR. (MWK(START(MYFM)+2) == MEXPOV .AND. KOVUN == 0)) CALL ZMWARN
      IF (NTRACE /= 0) CALL ZMNTR2(1,MYFM,MYFM,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE ZMEXI2

      SUBROUTINE ZMEXP(MA,MB)

!  MB = EXP(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,KWRNSV,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMEXP    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(1,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMI2M(1,MXY(1))
      ELSE
          CALL FMEXP(MZ02(1),MXY(1))
      ENDIF

      CALL FMCSSN(MZ02(2),MZ01(1),MZ01(2))

      KWRNSV = KWARN
      KWARN = 0
      CALL FMMPYD(MXY(1),MZ01(1),MZ01(2),MZ02(1),MZ02(2))
      CALL ZMEQ(MZ02,MZ01)
      KWARN = KWRNSV

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMEXP

      SUBROUTINE ZMFORM(FORM1,FORM2,MA,STRING)

!  Convert MA to STRING using FORM1 format for the real part and FORM2 format for the
!  imaginary part.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM1,FORM2,STRING
      INTEGER :: MA(2)

      INTEGER :: J,KWIDIM,KWIDRE,LAST,LSIGN
      INTENT (IN) :: MA,FORM1,FORM2
      INTENT (INOUT) :: STRING
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMFORM'
      STRING = ' '
      CALL ZMFPCZ(FORM1,MA(1),KWIDRE)
      CALL FMEQ(MA(2),MXY(1))
      IF (MWK(START(MXY(1))) > 0) THEN
          LSIGN = 1
      ELSE
          LSIGN = -1
          IF (MWK(START(MXY(1))+2) /= MUNKNO .AND. MWK(START(MXY(1))+3) /= 0)  &
              MWK(START(MXY(1))) = -MWK(START(MXY(1)))
      ENDIF
      CALL ZMFPCM(FORM2,MXY(1),KWIDIM)

      IF (KWIDRE+KWIDIM+50 > LMBUFZ) THEN
          IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
          ALLOCATE(CMBUFZ(KWIDRE+KWIDIM+50),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFZ = KWIDRE + KWIDIM + 50
          CALL ZMFPCZ(FORM1,MA(1),KWIDRE)
      ENDIF

      CMBUFZ(KWIDRE+1) = ' '
      IF (LSIGN == 1) THEN
          CMBUFZ(KWIDRE+2) = '+'
      ELSE
          CMBUFZ(KWIDRE+2) = '-'
      ENDIF
      CMBUFZ(KWIDRE+3) = ' '
      DO J = 1, KWIDIM
         CMBUFZ(KWIDRE+3+J) = CMBUFF(J)
      ENDDO
      CMBUFZ(KWIDRE+4+KWIDIM) = ' '
      CMBUFZ(KWIDRE+5+KWIDIM) = 'i'
      IF (JFORMZ == 2) CMBUFZ(KWIDRE+5+KWIDIM) = 'I'
      LAST = KWIDRE + KWIDIM + 5

      IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(1))+2) == MEXPUN) THEN
          DO J = KWIDRE+3, LAST
             IF (CMBUFZ(J) == 'O' .OR. CMBUFZ(J) == 'U') THEN
                 CMBUFZ(J-2) = ' '
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      IF (LAST <= LEN(STRING)) THEN
          DO J = 1, LAST
             STRING(J:J) = CMBUFZ(J)
          ENDDO
      ELSE
          DO J = 1, LAST
             STRING(J:J) = '*'
          ENDDO
      ENDIF
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE ZMFORM

      SUBROUTINE ZMFPCM(FORM,MA,KWI)

!  Internal routine to convert MA to base 10 using FORM format. The result is returned in CMBUFF and
!  the field width is KWI.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      INTEGER :: MA
      INTEGER :: KWI
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K1,K2,K3,KD,KWD,KSAVE,LAST,LB,LENGFM,LFIRST,ND,NEXP
      INTENT (IN) :: MA,FORM
      INTENT (INOUT) :: KWI
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      KSAVE = KFLAG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      LENGFM = LEN(FORM)
      KWI = 75
      KWD = 40
      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          KWI = MAX(1,KWI)
          JFORM1 = 2
          JFORM2 = 0
          KWD = KWI + 11
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMNINT(MA,MXY(1))
          IF (MWK(START(MXY(1))+3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFF,KWD)
          ELSE
              DO J = 1, KWD
                 CMBUFF(J) = ' '
              ENDDO
              CMBUFF(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 2
          JFORM2 = KD
          ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWD + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWD)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFF(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFF(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid
!             showing no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(MWK(START(MA)+2))+1)*LOG10(DBLE(MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  JFORM1 = 0
                  JFORM2 = ND
                  IF (KWI+50 > LMBUFF) THEN
                      IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
                      ALLOCATE(CMBUFF(KWI+50),STAT=J)
                      IF (J /= 0) THEN
                          CALL FMDEFINE_ERROR(1)
                      ENDIF
                      LMBUFF = KWI + 50
                  ENDIF
                  CALL FMOUT(MA,CMBUFF,KWI)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFF(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFF(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFF(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFF(JPT) = CMBUFF(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 1
          JFORM2 = KD + 1
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 0
          JFORM2 = KD
          IF (KWI+50 > LMBUFF) THEN
              IF (LMBUFF > 0) DEALLOCATE(CMBUFF)
              ALLOCATE(CMBUFF(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFF = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFF,KWI)
      ELSE
          GO TO 110
      ENDIF

      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      KFLAG = KSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN

!             Error condition.

  110 KFLAG = -8
      DO J = 1, KWI
         CMBUFF(J) = '*'
      ENDDO
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      KFLAG = KSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE ZMFPCM

      SUBROUTINE ZMFPCZ(FORM,MA,KWI)

!  Internal routine to convert MA to base 10 using FORM format. The result is returned in CMBUFZ and
!  the field width is KWI.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM
      INTEGER :: MA
      INTEGER :: KWI
      DOUBLE PRECISION :: VAL
      INTEGER :: J,JF1SAV,JF2SAV,JPT,K1,K2,K3,KD,KWD,KSAVE,LAST,LB,LENGFM,LFIRST,ND,NEXP
      INTENT (IN) :: MA,FORM
      INTENT (INOUT) :: KWI
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      KSAVE = KFLAG
      JF1SAV = JFORM1
      JF2SAV = JFORM2
      LENGFM = LEN(FORM)
      KWI = 75
      KWD = 40
      IF (INDEX(FORM,'I') > 0 .OR. INDEX(FORM,'i') > 0) THEN
          K1 = MAX(INDEX(FORM,'I'),INDEX(FORM,'i')) + 1
          K2 = LENGFM
          IF (K2 >= K1) THEN
              CALL FMST2D(FORM(K1:K2),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          KWI = MAX(1,KWI)
          JFORM1 = 2
          JFORM2 = 0
          KWD = KWI + 11
          IF (KWD+50 > LMBUFZ) THEN
              IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
              ALLOCATE(CMBUFZ(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFZ = KWD + 50
          ENDIF
          CALL FMNINT(MA,MXY(1))
          IF (MWK(START(MXY(1))+3) /= 0) THEN
              CALL FMOUT(MXY(1),CMBUFZ,KWD)
          ELSE
              DO J = 1, KWD
                 CMBUFZ(J) = ' '
              ENDDO
              CMBUFZ(2) = '0'
          ENDIF
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFZ(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFZ(J) /= ' ') LAST = J
          ENDDO
          JPT = 1
          IF (LAST-LFIRST+1 > KWI) GO TO 110
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFZ(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'F') > 0 .OR. INDEX(FORM,'f') > 0) THEN
          K1 = MAX(INDEX(FORM,'F'),INDEX(FORM,'f')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 2
          JFORM2 = KD
          ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
          IF (ND < 2) ND = 2
          NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
          LB = MAX(JFORM2+NEXP,ND+NEXP)
          KWD = LB
          IF (KWD+50 > LMBUFZ) THEN
              IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
              ALLOCATE(CMBUFZ(KWD+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFZ = KWD + 50
          ENDIF
          CALL FMOUT(MA,CMBUFZ,KWD)
          LFIRST = 1
          LAST = 1
          DO J = 1, KWD
             IF (CMBUFZ(KWD+1-J) /= ' ') LFIRST = KWD+1-J
             IF (CMBUFZ(J) /= ' ') LAST = J
          ENDDO
          IF (LAST-LFIRST+1 > KWI) THEN

!             Not enough room for this F format, or FMOUT converted it to E format to avoid
!             showing no significant digits.  See if a shortened form will fit in E format.

              NEXP = INT(LOG10((ABS(MWK(START(MA)+2))+1)*LOG10(DBLE(MBASE))+1)+1)
              ND = KWI - NEXP - 5
              IF (ND < 1) THEN
                  GO TO 110
              ELSE
                  JFORM1 = 0
                  JFORM2 = ND
                  IF (KWI+50 > LMBUFZ) THEN
                      IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
                      ALLOCATE(CMBUFZ(KWI+50),STAT=J)
                      IF (J /= 0) THEN
                          CALL FMDEFINE_ERROR(1)
                      ENDIF
                      LMBUFZ = KWI + 50
                  ENDIF
                  CALL FMOUT(MA,CMBUFZ,KWI)
                  LFIRST = 1
                  LAST = 1
                  DO J = 1, KWI
                     IF (CMBUFZ(KWI+1-J) /= ' ') LFIRST = KWI+1-J
                     IF (CMBUFZ(J) /= ' ') LAST = J
                  ENDDO
              ENDIF
          ENDIF
          JPT = 1
          IF (LAST <= KWI) THEN
              DO J = LAST, LFIRST, -1
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
              DO J = 1, JPT-1
                 CMBUFZ(J) = ' '
              ENDDO
          ELSE
              DO J = LFIRST, LAST
                 JPT = KWI - LAST + J
                 CMBUFZ(JPT) = CMBUFZ(J)
              ENDDO
          ENDIF
      ELSE IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0 .OR. INDEX(FORM,'ES') > 0 .OR.  &
               INDEX(FORM,'es') > 0) THEN
          IF (INDEX(FORM,'1PE') > 0 .OR. INDEX(FORM,'1pe') > 0) THEN
              K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          ELSE
              K1 = MAX(INDEX(FORM,'S'),INDEX(FORM,'s')) + 1
          ENDIF
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 1
          JFORM2 = KD + 1
          IF (KWI+50 > LMBUFZ) THEN
              IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
              ALLOCATE(CMBUFZ(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFZ = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFZ,KWI)
      ELSE IF (INDEX(FORM,'E') > 0 .OR. INDEX(FORM,'e') > 0) THEN
          K1 = MAX(INDEX(FORM,'E'),INDEX(FORM,'e')) + 1
          K2 = INDEX(FORM(1:LENGFM),'.')
          K3 = LENGFM
          IF (K2 > K1) THEN
              CALL FMST2D(FORM(K1:K2-1),VAL)
              KWI = NINT(VAL)
          ELSE
              KWI = 50
          ENDIF
          IF (K3 > K2) THEN
              CALL FMST2D(FORM(K2+1:K3),VAL)
              KD = NINT(VAL)
          ELSE
              KD = 0
          ENDIF
          KWI = MAX(1,KWI)
          KD = MAX(0,MIN(KD,KWI-2))
          JFORM1 = 0
          JFORM2 = KD
          IF (KWI+50 > LMBUFZ) THEN
              IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
              ALLOCATE(CMBUFZ(KWI+50),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFZ = KWI + 50
          ENDIF
          CALL FMOUT(MA,CMBUFZ,KWI)
      ELSE
          GO TO 110
      ENDIF

      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      KFLAG = KSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN

!             Error condition.

  110 KFLAG = -8
      DO J = 1, KWI
         CMBUFZ(J) = '*'
      ENDDO
      JFORM1 = JF1SAV
      JFORM2 = JF2SAV
      KFLAG = KSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE ZMFPCZ

      SUBROUTINE ZMFPRT(FORM1,FORM2,MA)

!  Print MA in base 10 using FORM1 format for the real part and FORM2 format for the imaginary part.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: FORM1,FORM2
      INTEGER :: MA(2)

      CHARACTER(20) :: FORM
      INTEGER :: J,K,KWIDIM,KWIDRE,LAST,LSIGN
      INTENT (IN) :: MA,FORM1,FORM2
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMFPRT'

      CALL ZMFPCZ(FORM1,MA(1),KWIDRE)
      CALL FMEQ(MA(2),MXY(1))
      IF (MWK(START(MXY(1))) >= 0) THEN
          LSIGN = 1
      ELSE
          LSIGN = -1
          IF (MWK(START(MXY(1))+2) /= MUNKNO .AND. MWK(START(MXY(1))+3) /= 0)  &
              MWK(START(MXY(1))) = -MWK(START(MXY(1)))
      ENDIF
      CALL ZMFPCM(FORM2,MXY(1),KWIDIM)

      IF (KWIDRE+KWIDIM+50 > LMBUFZ) THEN
          IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
          ALLOCATE(CMBUFZ(KWIDRE+KWIDIM+50),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFZ = KWIDRE + KWIDIM + 50
          CALL ZMFPCZ(FORM1,MA(1),KWIDRE)
      ENDIF

      CMBUFZ(KWIDRE+1) = ' '
      IF (LSIGN == 1) THEN
          CMBUFZ(KWIDRE+2) = '+'
      ELSE
          CMBUFZ(KWIDRE+2) = '-'
      ENDIF
      CMBUFZ(KWIDRE+3) = ' '
      DO J = 1, KWIDIM
         CMBUFZ(KWIDRE+3+J) = CMBUFF(J)
      ENDDO
      CMBUFZ(KWIDRE+4+KWIDIM) = ' '
      CMBUFZ(KWIDRE+5+KWIDIM) = 'i'
      IF (JFORMZ == 2) CMBUFZ(KWIDRE+5+KWIDIM) = 'I'
      LAST = KWIDRE + KWIDIM + 5

      IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(1))+2) == MEXPUN) THEN
          DO J = KWIDRE+3, LAST
             IF (CMBUFZ(J) == 'O' .OR. CMBUFZ(J) == 'U') THEN
                 CMBUFZ(J-2) = ' '
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      WRITE (FORM,"(' (6X,',I3,'A1) ')") KSWIDE-7
      WRITE (KW,FORM) (CMBUFZ(K),K=1,LAST)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMFPRT

      SUBROUTINE ZMI2M(INTEG,MA)

!  MA = INTEG

!  The real part of MA is set to the one word integer value INTEG.
!  The imaginary part is set to zero.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: INTEG
      INTEGER :: MA(2)
      INTENT (IN) :: INTEG
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMI2M'
      IF (NTRACE /= 0) CALL ZMNTRI(2,INTEG,1)

      CALL FMI2M(INTEG,MA(1))
      CALL FMI2M(0,MA(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMI2M

      SUBROUTINE ZM2I2M(INTEG1,INTEG2,MA)

!  MA = INTEG1 + INTEG2 i

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: INTEG1,INTEG2
      INTEGER :: MA(2)
      INTENT (IN) :: INTEG1,INTEG2
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZM2I2M'
      IF (NTRACE /= 0) THEN
          CALL ZMNTRI(2,INTEG1,1)
          CALL ZMNTRI(2,INTEG2,0)
      ENDIF

      CALL FMI2M(INTEG1,MA(1))
      CALL FMI2M(INTEG2,MA(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZM2I2M

      SUBROUTINE ZMIMAG(MA,MBFM)

!  MBFM = IMAG(MA)        imaginary part of MA

!  MA is a complex ZM number, MBFM is a real FM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMIMAG'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMEQ(MA(2),MBFM)

      IF (NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMIMAG

      SUBROUTINE ZMINP(LINE,MA,LA,LB)

!  Convert an A1 character string to floating point multiple precision complex format.

!  LINE is an A1 character array of length LB to be converted to ZM format and returned in MA.
!  LA is a pointer telling the routine where in the array to begin the conversion.  This allows more
!     than one number to be stored in an array and converted in place.
!  LB is a pointer to the last character of the field for that number.

!  The input numbers may be in integer or any real format.
!  In exponential format the 'E' may also be 'D', 'Q', or 'M'.

!  The following are all valid input strings:

!  1.23 + 4.56 I
!  1.23 + 4.56*I
!  2 + i
!  -i
!  1.23
!  4.56i
!  ( 1.23 , 4.56 )

!  So that ZMINP will convert any output from ZMOUT, LINE is tested to see if the input contains any
!  of the special symbols +OVERFLOW, -OVERFLOW, +UNDERFLOW, -UNDERFLOW, or UNKNOWN.
!  For user input the abbreviations OVFL, UNFL, UNKN may be used.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA(2)
      INTEGER :: J,JSTATE,K,KASAVE,KDIGFL,KFLAG1,KIFLAG,KPT,KRSAVE,KSIGN,KSTART,KSTOP,KSTOPI,  &
                 KSTOPR,KSTRTI,KSTRTR,KTYPE,KVAL,NDSAVE,NTRSAV

!  Simulate a finite-state automaton to scan the input line and build the number.
!  States 2-8 refer to the real part, states 10-16 refer to the imaginary part.
!  States of the machine:

!   1.  Initial entry to the subroutine
!   2.  Sign of the number
!   3.  Scanning digits before a decimal point
!   4.  Decimal point
!   5.  Scanning digits after a decimal point
!   6.  E, D, Q, or M - precision indicator before the exponent
!   7.  Sign of the exponent
!   8.  Scanning exponent
!   9.  Comma between the real and imaginary part
!  10.  Sign of the number
!  11.  Scanning digits before a decimal point
!  12.  Decimal point
!  13.  Scanning digits after a decimal point
!  14.  E, D, Q, or M - precision indicator before the exponent
!  15.  Sign of the exponent
!  16.  Scanning exponent
!  17.  Syntax error

!  Character types recognized by the machine:

!  1.  Sign (+,-)
!  2.  Numeral (0,1,...,9)
!  3.  Decimal point (.)
!  4.  Precision indicator (E,D,Q,M)
!  5.  Illegal character for number
!  6.  Comma (,)
!  7.  Character to be ignored   ' '    '('    ')'    '*'

!  All blanks are ignored.  The analysis of the number proceeds as follows:  If the simulated
!  machine is in state JSTATE and a character of type JTYPE is encountered the new state of the
!  machine is given by JTRANS(JSTATE,JTYPE).

!  State  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16

      INTEGER :: JTRANS(16,4) = RESHAPE(  (/    &
          2, 17, 10, 10, 10,  7, 17, 10, 10, 17, 17, 17, 17, 15, 17, 17,  &
          3,  3,  3,  5,  5,  8,  8,  8, 11, 11, 11, 13, 13, 16, 16, 16,  &
          4,  4,  4, 17, 17, 17, 17, 17, 12, 12, 12, 17, 17, 17, 17, 17,  &
          6,  6,  6,  6,  6,  8, 17, 17, 14, 14, 14, 14, 14, 16, 17, 17   /)  &
        , (/ 16,4 /) )
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MA(1) <= 0) THEN
          CALL FMDEFINE(MA(1))
      ELSE IF (SIZE_OF(MA(1)) < NDIG+3) THEN
          CALL FMDEFINE(MA(1))
      ENDIF
      IF (MA(2) <= 0) THEN
          CALL FMDEFINE(MA(2))
      ELSE IF (SIZE_OF(MA(2)) < NDIG+3) THEN
          CALL FMDEFINE(MA(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMINP'
      NDSAVE = NDIG
      KASAVE = KACCSW
      KRSAVE = KROUND
      KROUND = 1
      KFLAG = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      IF (LHASH == 0) CALL FMHTBL

!             Since arithmetic tracing is not usually desired during I/O conversion, disable
!             tracing during this routine.

      NTRSAV = NTRACE
      NTRACE = 0

!             Increase the working precision.

      IF (NCALL <= 2) THEN
          K = NGRD52
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KSTART = LA
      KSTOP = LB
      JSTATE = 1
      KSTRTR = 0
      KSTOPR = 0
      KSTRTI = 0
      KSTOPI = 0
      KDIGFL = 0
      KIFLAG = 0
      KSIGN = 1

!             Scan the number.

      DO J = KSTART, KSTOP
         IF (LINE(J) == ' ' .OR. LINE(J) == '(' .OR. LINE(J) == ')'  &
             .OR. LINE(J) == '*') CYCLE
         IF (LINE(J) == 'I' .OR. LINE(J) == 'i') THEN
             KIFLAG = 1
             IF (KSTRTI == 0) THEN
                 KSTRTI = KSTRTR
                 KSTOPI = KSTOPR
                 KSTRTR = 0
                 KSTOPR = 0
             ENDIF
             CYCLE
         ENDIF

         KPT = ICHAR(LINE(J))
         IF (KPT < LHASH1 .OR. KPT > LHASH2) THEN
             WRITE (KW,  &
                "(/' Error in input conversion.'/"                        //  &
                "' ICHAR function was out of range for the current',"     //  &
                "' dimensions.'/' ICHAR(''',A,''') gave the value ',"     //  &
                "I12,', which is outside the currently'/' dimensioned',"  //  &
                "' bounds of (',I5,':',I5,') for variables KHASHT ',"     //  &
                "'and KHASHV.'/' Re-define the two parameters ',"         //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain',"  //  &
                "' all possible output values from ICHAR.'//)"                &
                   ) LINE(J),KPT,LHASH1,LHASH2
             KTYPE = 5
             KVAL  = 0
         ELSE
             KTYPE = KHASHT(KPT)
             KVAL  = KHASHV(KPT)
         ENDIF
         IF (KTYPE == 2 .OR. KTYPE == 5) KDIGFL = 1
         IF (LINE(J) == ',') THEN
             IF (JSTATE < 9) THEN
                 JSTATE = 9
             ELSE
                 GO TO 110
             ENDIF
         ELSE
             IF (KTYPE >= 5) KTYPE = 2
             IF (JSTATE < 17) JSTATE = JTRANS(JSTATE,KTYPE)
         ENDIF
         IF (JSTATE == 9 .OR. JSTATE == 10) KDIGFL = 0
         IF (JSTATE == 2 .OR. JSTATE == 10) KSIGN = KVAL

         IF (JSTATE >= 2 .AND. JSTATE <= 8) THEN
             IF (KSTRTR == 0) KSTRTR = J
             KSTOPR = J
         ENDIF
         IF (JSTATE >= 10 .AND. JSTATE <= 16) THEN
             IF (KSTRTI == 0) KSTRTI = J
             KSTOPI = J
         ENDIF

      ENDDO

!             Form the number and return.

      IF (KSTRTR > 0) THEN
          NCALL = NCALL - 1
          CALL FMINP(LINE,MXY(1),KSTRTR,KSTOPR)
          NCALL = NCALL + 1
      ELSE
          CALL FMIM(0,MXY(1))
      ENDIF
      KFLAG1 = KFLAG

      IF (KSTRTI > 0) THEN
          IF (KIFLAG == 1 .AND. KDIGFL == 0) THEN
              CALL FMIM(KSIGN,MXY(2))
          ELSE
              NCALL = NCALL - 1
              CALL FMINP(LINE,MXY(2),KSTRTI,KSTOPI)
              NCALL = NCALL + 1
          ENDIF
      ELSE IF (KIFLAG == 1) THEN
          CALL FMIM(1,MXY(2))
      ELSE
          CALL FMIM(0,MXY(2))
      ENDIF

      IF (KFLAG1 /= 0 .OR. KFLAG /= 0 .OR. JSTATE == 17) GO TO 110
      CALL FMEQU(MXY(1),MA(1),NDIG,NDSAVE)
      CALL FMEQU(MXY(2),MA(2),NDIG,NDSAVE)
      GO TO 120

!             Error in converting the number.

  110 KFLAG = -7
      CALL ZMWARN
      MWK(START(MA(1))) = 1
      MWK(START(MA(1))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MA(1))+2) = MUNKNO
      MWK(START(MA(1))+3) = 1
      MWK(START(MA(2))) = 1
      MWK(START(MA(2))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MA(2))+2) = MUNKNO
      MWK(START(MA(2))+3) = 1
      DO J = 2, NDSAVE
         MWK(START(MA(1))+J+2) = 0
         MWK(START(MA(2))+J+2) = 0
      ENDDO

  120 NDIG = NDSAVE
      KACCSW = KASAVE
      NTRACE = NTRSAV
      KROUND = KRSAVE
      IF (KFLAG /= -7) KFLAG = 0
      MWK(START(MA(1))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MA(2))+1) = MWK(START(MA(1))+1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMINP

      SUBROUTINE ZMINT(MA,MB)

!  MB = INT(MA)

!  The integer parts of both real and imaginary values are returned.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMINT'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMINT(MA(1),MB(1))
      CALL FMINT(MA(2),MB(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMINT

      SUBROUTINE ZMIPWR(MA,IVAL,MB)

!  MB = MA ** IVAL

!  Raise a ZM number to an integer power.
!  The binary multiplication method used requires an average of 1.5 * LOG2(IVAL) multiplications.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: IVAL
      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MA2,MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: I2N,J,K,KASAVE,KL,KOVUN,KR_RETRY,KWRNSV,LVLSAV,NDSAVE
      REAL :: XVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      INTEGER :: MZ02(2),MZ03(2),MZ04(2),MZ05(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMIPWR'
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          CALL ZMNTR(2,MA,MA,1)
          CALL FMNTRI(2,IVAL,0)
      ENDIF
      KOVUN = 0
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      IF (MWK(START(MA(1))+2) == MEXPOV .OR. MWK(START(MA(1))+2) == MEXPUN .OR.  &
          MWK(START(MA(2))+2) == MEXPOV .OR. MWK(START(MA(2))+2) == MEXPUN) KOVUN = 1

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      KASAVE = KACCSW
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Check for special cases.

      IF (MWK(START(MA(1))+2) == MUNKNO .OR. MWK(START(MA(2))+2) == MUNKNO .OR.  &
          (IVAL <= 0 .AND. MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0)) THEN
          MA2 = MWK(START(MA(1))+3)
          KFLAG = -4
          IF (IVAL <= 0 .AND. MA2 == 0) CALL ZMWARN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          MXEXP = MXSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL ZMI2M(1,MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          MXEXP = MXSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          MXEXP = MXSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA(2))+3) == 0) THEN
          NCALL = NCALL - 1
          LVLSAV = LVLTRC
          LVLTRC = LVLTRC - 1
          CALL FMIPWR(MA(1),IVAL,MB(1))
          CALL FMIM(0,MB(2))
          NCALL = NCALL + 1
          LVLTRC = LVLSAV
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMIPWR'
              CALL ZMNTR(1,MB,MB,1)
          ENDIF
          NCALL = NCALL - 1
          MXEXP = MXSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (MWK(START(MA(1))+3) == 0) THEN
          NCALL = NCALL - 1
          LVLSAV = LVLTRC
          LVLTRC = LVLTRC - 1
          IF (IVAL >= 0) THEN
              I2N = MOD(IVAL,4)
          ELSE
              I2N = MOD(4 - MOD(ABS(IVAL),4),4)
          ENDIF
          IF (I2N == 0) THEN
              CALL FMIPWR(MA(2),IVAL,MB(1))
              CALL FMIM(0,MB(2))
          ELSE IF (I2N == 1) THEN
              CALL FMIPWR(MA(2),IVAL,MB(2))
              CALL FMIM(0,MB(1))
          ELSE IF (I2N == 2) THEN
              CALL FMIPWR(MA(2),IVAL,MB(1))
              CALL FMIM(0,MB(2))
              IF (MWK(START(MB(1))+2) /= MUNKNO .AND. MWK(START(MB(1))+3) /= 0)  &
                  MWK(START(MB(1))) = -MWK(START(MB(1)))
          ELSE IF (I2N == 3) THEN
              CALL FMIPWR(MA(2),IVAL,MB(2))
              CALL FMIM(0,MB(1))
              IF (MWK(START(MB(2))+2) /= MUNKNO .AND. MWK(START(MB(2))+3) /= 0)  &
                  MWK(START(MB(2))) = -MWK(START(MB(2)))
          ENDIF
          NCALL = NCALL + 1
          LVLTRC = LVLSAV
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMIPWR'
              CALL ZMNTR(1,MB,MB,1)
          ENDIF
          NCALL = NCALL - 1
          MXEXP = MXSAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(2*NDIG,2*NDSAVE+10)
      ENDIF
      IF (ABS(IVAL) == 1) THEN
          KWRNSV = KWARN
          KWARN = 0
          IF (IVAL == 1) THEN
              CALL ZMEQ(MA,MZ05)
          ELSE
              K = INT((5.0D0*DLOGTN)/DLOGMB + 2.0D0)
              NDIG = MAX(NDIG+K,2)
              CALL ZMI2M(1,MZ02)
              CALL ZMEQU(MA,MZ03,NDSAVE,NDIG)
              CALL ZMDIV(MZ02,MZ03,MZ05)
          ENDIF
          KWARN = KWRNSV
          GO TO 130
      ENDIF

!             Increase the working precision.

      IF (NCALL == 1) THEN
          XVAL = ABS(IVAL) + 1
          K = INT((5.0*REAL(DLOGTN) + 2.5*LOG(XVAL))/ALOGMB + 3.0)
          IF (MBASE <= 1000) K = 2*K
          NDIG = MAX(NDIG+K,2)
      ELSE
          XVAL = ABS(IVAL) + 1
          K = INT(LOG(XVAL)/ALOGMB + 1.0)
          NDIG = NDIG + K
      ENDIF

!             Initialize.

      KWRNSV = KWARN
      KWARN = 0
      K = ABS(IVAL)

      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

      IF (MOD(K,2) == 0) THEN
          CALL ZMI2M(1,MZ05)
      ELSE
          CALL ZMEQ(MZ02,MZ05)
      ENDIF

!             This is the multiplication loop.

  120 K = K/2
      CALL ZMSQR(MZ02,MZ04)
      CALL ZMEQ(MZ04,MZ02)
      IF (MOD(K,2) == 1) THEN
          CALL ZMMPY(MZ02,MZ05,MZ04)
          CALL ZMEQ(MZ04,MZ05)
      ENDIF
      IF (K > 1) GO TO 120

!             Invert if the exponent is negative.

      IF (IVAL < 0) THEN
          CALL ZMI2M(1,MZ02)
          CALL ZMDIV(MZ02,MZ05,MZ04)
          CALL ZMEQ(MZ04,MZ05)
      ENDIF
      KWARN = KWRNSV

!             Round the result and return.

  130 MACCMB = MWK(START(MZ05(1))+1)
      MWK(START(MZ05(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ05(2))+1)
      MWK(START(MZ05(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ05(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ05,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMIPWR

      SUBROUTINE ZMLG10(MA,MB)

!  MB = LOG10(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),MZ03(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMLG10   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ03,NDSAVE,NDIG)
      CALL ZMLN(MZ03,MZ02)
      CALL FMLNI(10,MXY(1))
      CALL FMDIVD(MZ02(1),MZ02(2),MXY(1),MZ01(1),MZ01(2))

      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMLG10

      SUBROUTINE ZMLN(MA,MB)

!  MB = LN(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KF1,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(4),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMLN     ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          KFLAG = -4
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          IF (MWK(START(MA(1))) < 0) THEN
              CALL FMEQ(MZ02(1),MZ01(1))
              IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
                  MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
              CALL FMLN(MZ01(1),MXY(4))
              CALL FMEQ(MXY(4),MZ01(1))
              CALL FMPI(MZ01(2))
          ELSE
              CALL FMLN(MZ02(1),MZ01(1))
              CALL FMI2M(0,MZ01(2))
          ENDIF
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          IF (MWK(START(MA(2))) < 0) THEN
              CALL FMEQ(MZ02(2),MZ01(1))
              IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
                  MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
              CALL FMLN(MZ01(1),MXY(4))
              CALL FMEQ(MXY(4),MZ01(1))
              CALL FMPI(MZ01(2))
              CALL FMDIVI_R1(MZ01(2),-2)
          ELSE
              CALL FMLN(MZ02(2),MZ01(1))
              CALL FMPI(MZ01(2))
              CALL FMDIVI_R1(MZ01(2),2)
          ENDIF
          GO TO 120
      ENDIF

!             Ln(a + b i) = Ln(Abs(a + b i)) + Arg(a + b i) i.

      CALL FMABS(MZ02(1),MXY(1))
      CALL FMABS(MZ02(2),MXY(2))

!             Check for cancellation in Ln(x).

      CALL FMI2M(1,MXY(3))
      KF1 = 0
      IF (FMCOMP(MXY(1),'==',MXY(3)) .AND. MWK(START(MXY(2))+2) <= (-NDIG)) KF1 = 1
      IF (FMCOMP(MXY(2),'==',MXY(3)) .AND. MWK(START(MXY(1))+2) <= (-NDIG)) KF1 = 1

      IF (FMCOMP(MXY(1),'>=',MXY(2))) THEN
          CALL FMSUB(MZ02(1),MXY(3),MXY(1))
          CALL FMADD(MZ02(1),MXY(3),MXY(2))
          CALL FMMPY_R1(MXY(1),MXY(2))
          CALL FMSQR(MZ02(2),MXY(2))
          CALL FMADD_R2(MXY(1),MXY(2))
      ELSE
          CALL FMSUB(MZ02(2),MXY(3),MXY(1))
          CALL FMADD(MZ02(2),MXY(3),MXY(2))
          CALL FMMPY_R1(MXY(1),MXY(2))
          CALL FMSQR(MZ02(1),MXY(2))
          CALL FMADD_R2(MXY(1),MXY(2))
      ENDIF
      CALL ZMABS(MZ02,MZ01(1))
      CALL FMADD(MZ01(1),MXY(3),MXY(1))
      CALL FMDIV_R2(MXY(2),MXY(1))
      IF (KF1 == 1) THEN
          CALL FMEQ(MXY(1),MZ01(1))
          CALL FMATN2(MZ02(2),MZ02(1),MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MXY(1))+2) < 0) THEN
          NDIG = NDIG - INT(MWK(START(MXY(1))+2))
          CALL ZMEQU_R1(MZ02,NDSAVE,NDIG)
          CALL ZMABS(MZ02,MZ01(1))
      ENDIF

      CALL FMLN(MZ01(1),MXY(4))
      CALL FMEQ(MXY(4),MZ01(1))
      CALL FMATN2(MZ02(2),MZ02(1),MZ01(2))

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMLN

      SUBROUTINE ZMM2I(MA,INTEG)

!  INTEG = MA

!  INTEG is set to the integer value of the real part of MA

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      INTEGER :: INTEG
      INTENT (IN) :: MA
      INTENT (INOUT) :: INTEG

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMM2I'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMM2I(MA(1),INTEG)

      IF (NTRACE /= 0) CALL ZMNTRI(1,INTEG,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE ZMM2I

      SUBROUTINE ZMM2Z(MA,ZVAL)

!  ZVAL = MA

!  Complex variable ZVAL is set to MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      COMPLEX :: ZVAL

      REAL :: DI,DR
      INTENT (IN) :: MA
      INTENT (INOUT) :: ZVAL

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMM2Z'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMM2SP(MA(1),DR)
      CALL FMM2SP(MA(2),DI)
      ZVAL = CMPLX(DR,DI)

      IF (NTRACE /= 0) CALL ZMNTRZ(1,ZVAL,1)
      NCALL = NCALL - 1
      RETURN
      END SUBROUTINE ZMM2Z

      SUBROUTINE ZMMPY(MA,MB,MC)

!  MC = MA * MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MBIZ,MBRZ,MXSAVE,MZ11SV
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,KASAVE,KL,KMETHD,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDGSV2,NDSAVE,NGOAL,NTRSAV
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(7),MZ01(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MB(1))+2)) > MEXPAB .OR. ABS(MWK(START(MB(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMMPY    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
                  IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMMPY'
              CALL ZMNTR(2,MA,MB,2)
          ENDIF
          NDSAVE = NDIG
          NDIG = MAX(NDIG+NGRD52,2)
          IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR. MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
              NDIG = NDIG + 1
          ELSE IF (MBASE >= 100*ABS(MWK(START(MB(1))+3)) .OR.  &
              MBASE >= 100*ABS(MWK(START(MB(2))+3))) THEN
              NDIG = NDIG + 1
          ENDIF
          KASAVE = KACCSW
          KACCSW = 1
          MXSAVE = MXEXP
          MXEXP = MXEXP2
          KOVUN = 0
      ENDIF

      MARZ = MWK(START(MA(1))+1)
      MBRZ = MWK(START(MB(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      MBIZ = MWK(START(MB(2))+1)
      KR_RETRY = 0
      MZ11SV = -MUNKNO
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA(1),MXY(4),NDSAVE,NDIG)
      CALL FMEQU(MA(2),MXY(5),NDSAVE,NDIG)
      CALL FMEQU(MB(1),MXY(6),NDSAVE,NDIG)
      CALL FMEQU(MB(2),MXY(7),NDSAVE,NDIG)
      MWK(START(MXY(4))+1) = NINT(NDIG*ALOGM2)
      MWK(START(MXY(6))+1) = MWK(START(MXY(4))+1)
      MWK(START(MXY(5))+1) = MWK(START(MXY(4))+1)
      MWK(START(MXY(7))+1) = MWK(START(MXY(4))+1)

!             Check for special cases.

      KMETHD = 1

!             If precision is low or a retry is being done due to cancellation,
!             use a slower but more stable form of the multiplication formula.

      IF (NDIG >= 35 .AND. MZ11SV == -MUNKNO) KMETHD = 2

      IF (MWK(START(MB(2))+3) == 0) THEN
          CALL FMMPYD(MXY(6),MXY(4),MXY(5),MZ01(1),MZ01(2))
      ELSE IF (MWK(START(MB(1))+3) == 0) THEN
          CALL FMMPYD(MXY(7),MXY(5),MXY(4),MZ01(1),MZ01(2))
          IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
              MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMMPYD(MXY(4),MXY(6),MXY(7),MZ01(1),MZ01(2))
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMMPYD(MXY(5),MXY(7),MXY(6),MZ01(1),MZ01(2))
          IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
              MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
      ELSE IF (KMETHD == 1) THEN

!             Method 1 for  ( a + b i ) * ( c + d i )

!             result = a*c - b*d + ( a*d + b*c ) i

          KACCSW = 0
          CALL FMMPYD(MXY(4),MXY(6),MXY(7),MZ01(1),MZ01(2))
          CALL FMMPYD(MXY(5),MXY(7),MXY(6),MXY(1),MXY(2))
          IF (MWK(START(MZ01(1)))*MWK(START(MXY(1))) < 0) THEN
              KACCSW = 0
          ELSE
              KACCSW = 1
          ENDIF
          CALL FMSUB_R1(MZ01(1),MXY(1))
          IF (MWK(START(MZ01(2)))*MWK(START(MXY(2))) < 0) THEN
              KACCSW = 1
          ELSE
              KACCSW = 0
          ENDIF
          CALL FMADD_R1(MZ01(2),MXY(2))
          KACCSW = 1
      ELSE

!             Method 2 for  ( a + b i ) * ( c + d i )

!             P = ( a + b )*( c + d )
!             result = a*c - b*d + ( P - a*c - b*d ) i

          CALL FMADD(MXY(4),MXY(5),MXY(1))
          CALL FMADD(MXY(6),MXY(7),MXY(2))
          CALL FMMPY_R1(MXY(1),MXY(2))

          CALL FMMPY(MXY(4),MXY(6),MXY(2))
          CALL FMMPY(MXY(5),MXY(7),MXY(3))

          CALL FMSUB(MXY(2),MXY(3),MZ01(1))
          CALL FMSUB(MXY(1),MXY(2),MZ01(2))
          CALL FMSUB_R1(MZ01(2),MXY(3))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
      IF (MWK(START(MZ01(1))+1) <= NGOAL .OR. MWK(START(MZ01(2))+1) <= NGOAL) THEN
          IF (MZ11SV > -MUNKNO .AND. MWK(START(MZ01(1))+1) > NGOAL .AND.  &
              MWK(START(MZ01(2))+3) == 0) GO TO 120
          IF (MZ11SV > -MUNKNO .AND. MWK(START(MZ01(2))+1) > NGOAL .AND.  &
              MWK(START(MZ01(1))+3) == 0) GO TO 120
          IEXTRA = INT(REAL(MAX(NGOAL-MWK(START(MZ01(1))+1),NGOAL-MWK(START(MZ01(2))+1)))  &
                   /ALOGM2 + 23.03/ALOGMB) + 1
          NDIG = NDIG + IEXTRA
          MZ11SV = MWK(START(MZ01(1))+2)
          GO TO 110
      ENDIF

  120 MXEXP = MXSAVE
      NTRACE = NTRSAV
      NDGSV2 = NDIG
      NDIG = NDSAVE
      KWARN = KWRNSV
      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)
      CALL ZMEQU(MZ01,MC,NDGSV2,NDSAVE)
      IF (MWK(START(MC(1))+2) >= MEXPOV .OR. MWK(START(MC(1))+2) <= -MEXPOV .OR.  &
          MWK(START(MC(2))+2) >= MEXPOV .OR. MWK(START(MC(2))+2) <= -MEXPOV) THEN
          IF (MWK(START(MC(1))+2) == MUNKNO .OR. MWK(START(MC(2))+2) == MUNKNO) THEN
              KFLAG = -4
          ELSE IF (MWK(START(MC(1))+2) == MEXPOV .OR. MWK(START(MC(2))+2) == MEXPOV) THEN
              KFLAG = -5
          ELSE IF (MWK(START(MC(1))+2) == MEXPUN .OR. MWK(START(MC(2))+2) == MEXPUN) THEN
              KFLAG = -6
          ENDIF
          IF ((MWK(START(MC(1))+2) == MUNKNO) .OR. (MWK(START(MC(2))+2) == MUNKNO)  &
             .OR. (MWK(START(MC(1))+2) == MEXPUN .AND. KOVUN == 0)      &
             .OR. (MWK(START(MC(2))+2) == MEXPUN .AND. KOVUN == 0)      &
             .OR. (MWK(START(MC(1))+2) == MEXPOV .AND. KOVUN == 0)      &
             .OR. (MWK(START(MC(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
              NAMEST(NCALL) = 'ZMMPY'
              CALL ZMWARN
          ENDIF
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
      KACCSW = KASAVE
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMMPY

      SUBROUTINE ZMMPYI(MA,INTEG,MB)

!  MB = MA * INTEG        Multiply by one-word (real) integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTEGER :: INTEG
      INTEGER :: KASAVE,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          NTRSAV = NTRACE
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'ZMMPYI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
              NCALL = NCALL - 1
          ENDIF
          NTRACE = 0
          CALL ZMENTR('ZMMPYI   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          NTRACE = NTRSAV
          IF (KRESLT /= 0) THEN
              NCALL = NCALL + 1
              IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
              NCALL = NCALL - 1
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
                  IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NTRSAV = NTRACE
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMMPYI'
              CALL ZMNTR(2,MA,MA,1)
              CALL FMNTRI(2,INTEG,0)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMMPYI to use more guard digits for user calls.

      NCALL = NCALL - 1
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

      CALL FMMPYI(MA(1),INTEG,MB(1))
      CALL FMMPYI(MA(2),INTEG,MB(2))

      NTRACE = NTRSAV
      KWARN = KWRNSV
      NCALL = NCALL + 1
      IF (NTRACE /= 0) NAMEST(NCALL) = 'ZMMPYI'
      IF (MWK(START(MB(1))+2) == MUNKNO .OR. MWK(START(MB(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MB(1))+2) == MEXPOV .OR. MWK(START(MB(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MB(1))+2) == MEXPUN .OR. MWK(START(MB(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MB(1))+2) == MUNKNO) .OR. (MWK(START(MB(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MB(1))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MB(2))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MB(1))+2) == MEXPOV .AND. KOVUN == 0)      &
         .OR. (MWK(START(MB(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMMPYI'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMMPYI

      SUBROUTINE ZMNINT(MA,MB)

!  MB = NINT(MA)

!  The nearest integers to both real and imaginary parts are returned.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMNINT'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMNINT(MA(1),MB(1))
      CALL FMNINT(MA(2),MB(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMNINT

      SUBROUTINE ZMNTR(NTR,MA,MB,NARG)

!  Print ZM numbers in base 10 format using ZMOUT for conversion.
!  This is used for trace output from the ZM routines.

!  NTR =  1 if a result of an ZM call is to be printed.
!      =  2 to print input argument(s) to an ZM call.

!  MA  -  the ZM number to be printed.

!  MB  -  an optional second ZM number to be printed.

!  NARG - the number of arguments.  NARG = 1 if only MA is to be
!         printed, and NARG = 2 if both MA and MB are to be printed.


!  NTRACE and LVLTRC (in module FMVALS) control trace printout.

!  NTRACE = 0        No printout except warnings and errors.

!  NTRACE = 1        The result of each call to one of the routines
!                    is printed in base 10, using ZMOUT.

!  NTRACE = -1       The result of each call to one of the routines
!                    is printed in internal base MBASE format.

!  NTRACE = 2        The input arguments and result of each call to one
!                    of the routines is printed in base 10, using ZMOUT.

!  NTRACE = -2       The input arguments and result of each call to one
!                    of the routines is printed in base MBASE format.

!  LVLTRC defines the call level to which the trace is done.  LVLTRC = 1 means only FM routines
!         called directly by the user are traced, LVLTRC = K prints traces for ZM or FM routines
!         with call levels up to and including level K.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTEGER :: NTR,NARG
      CHARACTER(9) :: NAME
      INTENT (IN) :: MA,MB

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ELSE
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,  &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,  &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

!             Check for base MBASE internal format trace.

      IF (NTRACE < 0) THEN
          CALL ZMNTRJ(MA,NDIG)
          IF (NARG == 2) CALL ZMNTRJ(MB,NDIG)
      ENDIF

!             Check for base 10 trace using ZMOUT.

      IF (NTRACE > 0) THEN
          CALL ZMPRNT(MA)

          IF (NARG == 2) THEN
              CALL ZMPRNT(MB)
          ENDIF
      ENDIF

      RETURN
      END SUBROUTINE ZMNTR

      SUBROUTINE ZMNTR2(NTR,MAFM,MBFM,NARG)

!  Print real FM numbers in base 10 format using FMOUT for conversion.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MAFM,MBFM
      INTEGER :: NTR,NARG

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,MAFM,MBFM,NARG

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ELSE
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,  &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,  &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

!             Check for base MBASE internal format trace.

      IF (NTRACE < 0) THEN
          CALL FMNTRJ(MAFM,NDIG)
          IF (NARG == 2) CALL FMNTRJ(MBFM,NDIG)
      ENDIF

!             Check for base 10 trace using FMOUT.

      IF (NTRACE > 0) THEN
          CALL FMPRNT(MAFM)

          IF (NARG == 2) THEN
              CALL FMPRNT(MBFM)
          ENDIF
      ENDIF

      RETURN
      END SUBROUTINE ZMNTR2

      SUBROUTINE ZMNTRI(NTR,N,KNAM)

!  Internal routine for trace output of integer variables.

!  NTR = 1 for output values
!        2 for input values

!  N     Integer to be printed.

!  KNAM  is positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,N,KNAM

      CHARACTER(9) :: NAME
      INTENT (IN) :: NTR,N,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,  &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,  &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

      WRITE (KW,"(1X,I18)") N

      RETURN
      END SUBROUTINE ZMNTRI

      SUBROUTINE ZMNTRJ(MA,ND)

!  Print trace output in internal base MBASE format.  The number to be printed is in MA.

!  ND is the number of base MBASE digits to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      INTEGER :: ND

      CHARACTER(50) :: FORM
      INTEGER :: J,L,N
      INTENT (IN) :: MA,ND

      L = INT(LOG10(DBLE(MBASE-1))) + 2
      N = (KSWIDE-23)/L
      IF (N > 10) N = 5*(N/5)
      IF (ND <= N) THEN
          WRITE (FORM,"(' (1X,I19,I',I2,',',I3,'I',I2,') ')") L+2, N-1, L
      ELSE
          WRITE (FORM,  &
                 "(' (1X,I19,I',I2,',',I3,'I',I2,"  //  &
                 "'/(22X,',I3,'I',I2,')) ')"            &
                ) L+2, N-1, L, N, L
      ENDIF
      WRITE (KW,*) '            Sign = ',INT(MWK(START(MA(1)))),'  Accuracy = ',        &
                   INT(MWK(START(MA(1))+1)),'  Exponent = ',INT(MWK(START(MA(1))+2)),  &
                   '  Digits of real part:'
      WRITE (FORM,*) '(13X,', N, 'I', L, ')'
      WRITE (KW,FORM) (INT(MWK(START(MA(1))+J)),J=3,ND+2)
      WRITE (KW,*) '            Sign = ',INT(MWK(START(MA(2)))),'  Accuracy = ',        &
                   INT(MWK(START(MA(2))+1)),'  Exponent = ',INT(MWK(START(MA(2))+2)),  &
                   '  Digits of imaginary part:'
      WRITE (KW,FORM) (INT(MWK(START(MA(2))+J)),J=3,ND+2)

      RETURN
      END SUBROUTINE ZMNTRJ

      SUBROUTINE ZMNTRZ(NTR,X,KNAM)

!  Internal routine for trace output of complex variables.

!  NTR - 1 for output values
!        2 for input values

!  X   - Complex value to be printed if NX == 1

!  KNAM - Positive if the routine name is to be printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NTR,KNAM
      COMPLEX X

      CHARACTER(9) :: NAME
      DOUBLE PRECISION :: XREAL,XIMAG
      INTENT (IN) :: NTR,X,KNAM

      IF (NTRACE == 0) RETURN
      IF (NCALL > LVLTRC) RETURN
      IF (NTR == 2 .AND. ABS(NTRACE) == 1) RETURN

      IF (NTR == 2 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KROUND == 1) THEN
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ELSE IF (KROUND == 2) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward +infinity)'
          ELSE IF (KROUND == 0) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward zero)'
          ELSE IF (KROUND == -1) THEN
              WRITE (KW,"(' Input to ',A,A)") NAME,'      (round toward -infinity)'
          ELSE
              WRITE (KW,"(' Input to ',A)") TRIM(NAME)
          ENDIF
      ENDIF
      IF (NTR == 1 .AND. KNAM > 0) THEN
          NAME = NAMEST(NCALL)
          IF (KFLAG == 0) THEN
              WRITE (KW,  &
                     "(' ',A,12X,'Call level =',I2,5X,'MBASE =',"  //  &
                     "I10,5X,'NDIG =',I10)"                            &
                    ) NAME,NCALL,INT(MBASE),NDIG
          ELSE
              WRITE (KW,  &
                     "(' ',A,3X,'Call level =',I2,4X,'MBASE =',"  //  &
                     "I10,4X,'NDIG =',I10,4X,'KFLAG =',I3)"           &
                    ) NAME,NCALL,INT(MBASE),NDIG,KFLAG
          ENDIF
      ENDIF

      XREAL = DBLE(X)
      XIMAG = DBLE(AIMAG(X))
      IF (XIMAG >= 0.0D0) THEN
          WRITE (KW,"(1X,D30.20,' +',D30.20,' i')") XREAL,XIMAG
      ELSE
          WRITE (KW,"(1X,D30.20,' -',D30.20,' i')") XREAL,ABS(XIMAG)
      ENDIF

      RETURN
      END SUBROUTINE ZMNTRZ

      SUBROUTINE ZMOUT(MA,LINE,LB,LAST1,LAST2)

!  Convert a floating multiple precision number to a character array for output.

!  MA    is an ZM number to be converted to an A1 character array in base 10 format
!  LINE  is the character(1) array in which the result is returned.
!  LB    is the length of LINE.
!  LAST1 is returned as the position of the last nonblank character of the real part of the
!        number in LINE.
!  LAST2 is returned as the position of the last nonblank character of the imaginary part of
!        the number in LINE.

!  JFORM1 and JFORM2 determine the format of the two FM numbers making up the complex value MA.
!  See FMOUT for details.

!  JFORMZ determines the format of the real and imaginary parts.

!  JFORMZ = 1  normal setting :       1.23 - 4.56 i
!         = 2  use capital I  :       1.23 - 4.56 I
!         = 3  parenthesis format   ( 1.23 , -4.56 )

!  LINE should be dimensioned at least 4*(LOG10(MBASE)*NDIG + 15) on a 32-bit machine to allow
!  for up to 10 digit exponents.  Replace 15 by 20 if 48-bit integers are used, 25 for 64-bit
!  integers, etc.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)
      INTEGER :: LB,LAST1,LAST2
      CHARACTER :: LINE(LB)

      REAL (KIND(1.0D0)) :: MAIMS
      INTEGER :: J,KPT,LB2,ND,NEXP
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE,LAST1,LAST2
      INTEGER :: MXY(2),NUMBER_USED_SAVE

      MXY = -2
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMOUT'
      DO J = 1, LB
         LINE(J) = ' '
      ENDDO
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      KPT = 1
      IF (JFORMZ == 3) KPT = 3
      LB2 = MAX(JFORM2+NEXP,ND+NEXP)
      LB2 = MIN(LB+1-KPT,LB2)
      CALL FMOUT(MA(1),LINE(KPT),LB2)

      IF (JFORMZ == 3) LINE(1) = '('
      LAST1 = 1
      DO J = LB2, 1, -1
         IF (LINE(J) /= ' ') THEN
             LAST1 = J
             GO TO 110
         ENDIF
      ENDDO

  110 MAIMS = MWK(START(MA(2)))
      CALL FMDEFINE(MXY(1))
      DO J = -1, NDIG+1
         MWK(START(MXY(1))+J+1) = MWK(START(MA(2))+J+1)
      ENDDO
      LINE(LAST1+1) = ' '
      IF (JFORMZ == 3) THEN
          LINE(LAST1+2) = ','
      ELSE
          IF (MAIMS < 0) THEN
              MWK(START(MXY(1))) = 1
              LINE(LAST1+2) = '-'
          ELSE
              LINE(LAST1+2) = '+'
          ENDIF
      ENDIF

      KPT = LAST1 + 3
      LB2 = MAX(JFORM2+NEXP,ND+NEXP)
      LB2 = MIN(LB+1-KPT,LB2+2)
      CALL FMOUT(MXY(1),LINE(KPT),LB2)
      LAST1 = KPT
      DO J = LB2+KPT-1, KPT, -1
         IF (LINE(J) /= ' ') THEN
             LAST2 = J
             GO TO 120
         ENDIF
      ENDDO

  120 LAST2 = LAST2 + 2
      LINE(LAST2) = 'i'
      IF (JFORMZ == 2) LINE(LAST2) = 'I'
      IF (JFORMZ == 3) LINE(LAST2) = ')'

      IF (LINE(KPT) == ' ' .AND. LINE(KPT+1) == '+') THEN
          DO J = KPT+2, LAST2
             LINE(J-2) = LINE(J)
          ENDDO
          LINE(LAST2-1) = ' '
          LINE(LAST2) = ' '
          LAST2 = LAST2 - 2
      ENDIF

      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      RETURN
      END SUBROUTINE ZMOUT

      SUBROUTINE ZMPACK(MA,MP)

!  MA is packed two base MBASE digits per word and returned in MP.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MP(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MP
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMPACK(MA(1),MP(1))
      CALL FMPACK(MA(2),MP(2))
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP(1)) == -1) TEMPV(MP(1)) = -2
          IF (TEMPV(MP(2)) == -1) TEMPV(MP(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMPACK

      SUBROUTINE ZMPRNT(MA)

!  Print MA in base 10 format.

!  ZMPRNT can be called directly by the user for easy output in M format.
!  MA is converted using ZMOUT and printed.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2)

      CHARACTER(20) :: FORM
      INTEGER :: J,K,KSAVE,LAST1,LAST2,LB,LBZ,ND,NEXP
      INTENT (IN) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KSAVE = KFLAG
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = MAX(JFORM2+NEXP,ND+NEXP)

      IF (JPRNTZ == 1) THEN
          LBZ = 2*LB + 7
          IF (LBZ > LMBUFZ) THEN
              IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
              ALLOCATE(CMBUFZ(LBZ),STAT=J)
              IF (J /= 0) THEN
                  CALL FMDEFINE_ERROR(1)
              ENDIF
              LMBUFZ = LBZ
          ENDIF
          CALL ZMOUT(MA,CMBUFZ,LBZ,LAST1,LAST2)
          WRITE (FORM,"(' (6X,',I3,'A1) ')") KSWIDE-7
          WRITE (KW,FORM) (CMBUFZ(K),K=1,LAST2)
      ELSE
          CALL FMPRNT(MA(1))
          CALL FMPRNT(MA(2))
      ENDIF
      KFLAG = KSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMPRNT

      SUBROUTINE ZMPWR(MA,MB,MC)

!  MC = MA ** MB.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)

      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MBIZ,MBRZ,MXSAVE,MTEMP
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTMB,J,JSIN,JCOS,JSWAP,K,KASAVE,KL,KOVUN,KR_RETRY,KRADSV,  &
                 KRESLT,KWRNSV,NDSAVE
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: XVAL
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(5),MZ01(2),MZ02(2),MZ03(2),MZ04(2),MZ05(2),MZ06(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      MZ05 = -2
      MZ06 = -2
      IF (MC(1) <= 0) THEN
          CALL FMDEFINE(MC(1))
      ELSE IF (SIZE_OF(MC(1)) < NDIG+3) THEN
          CALL FMDEFINE(MC(1))
      ENDIF
      IF (MC(2) <= 0) THEN
          CALL FMDEFINE(MC(2))
      ELSE IF (SIZE_OF(MC(2)) < NDIG+3) THEN
          CALL FMDEFINE(MC(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMPWR    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
              IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MBRZ = MWK(START(MB(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      MBIZ = MWK(START(MB(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      K = MAX(MWK(START(MB(1))+2),MWK(START(MB(2))+2))
      IF (K < 25000) THEN
          NDIG = NDIG + MAX(K,0) + 1
      ELSE
          NDIG = NDIG + 1
      ENDIF

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ04,NDSAVE,NDIG)
      CALL ZMEQU(MB,MZ05,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          IF (MWK(START(MB(1))) > 0 .AND. MWK(START(MB(2))+3) == 0) THEN
              CALL ZMI2M(0,MZ02)
              GO TO 130
          ELSE
              KFLAG = -4
              CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ02)
              GO TO 130
          ENDIF
      ENDIF
      IF (MWK(START(MB(2))+3) == 0) THEN
          KWRNSV = KWARN
          KWARN = 0
          CALL FMMI(MZ05(1),INTMB)
          KWARN = KWRNSV
          IF (KFLAG == 0) THEN
              IF (NCALL == 1) THEN
                  XVAL = ABS(INTMB) + 1
                  K = INT((1.5*LOG(XVAL))/ALOGMB + 2.0)
                  NDIG = MAX(NDIG+K,2)
                  IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR.  &
                      MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
                      NDIG = NDIG + 1
                  ENDIF
              ENDIF
              CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
              CALL ZMIPWR(MZ04,INTMB,MZ03)
              CALL ZMEQ(MZ03,MZ02)
              GO TO 120
          ENDIF
      ENDIF

!             Check for cases where ABS(MA) is very close to 1, and avoid cancellation.

      CALL FMABS(MZ04(1),MXY(1))
      CALL FMABS(MZ04(2),MXY(2))
      CALL FMI2M(1,MXY(3))
      IF (FMCOMP(MXY(1),'==',MXY(3)) .AND.  &
          (MWK(START(MXY(2))+2) <= (-NDIG).OR.MWK(START(MXY(2))+3) == 0)) THEN
          IF (MWK(START(MA(1))) > 0) THEN

!                 (1+c)**b = 1 + b*c + ...

              CALL ZMI2M(1,MZ02)
              CALL ZMSUB(MZ04,MZ02,MZ06)
              CALL ZMMPY(MZ05,MZ06,MZ02)
              CALL FMADD_R1(MZ02(1),MXY(3))
          ELSE

!                 (-1+c)**b = (-1)**b * (1 - b*c + ... )

              CALL ZMI2M(-1,MZ02)
              CALL ZMSUB(MZ04,MZ02,MZ01)
              CALL ZMMPY(MZ05,MZ01,MZ06)
              CALL ZMMPYI(MZ06,-1,MZ02)
              CALL FMADD_R1(MZ02(1),MXY(3))
              KRADSV = KRAD
              KRAD = 0
              IF (MWK(START(MA(2))) >= 0) THEN
                  CALL FMMPYI(MZ05(1),180,MXY(4))
              ELSE
                  CALL FMMPYI(MZ05(1),-180,MXY(4))
              ENDIF
              CALL FMCSSN(MXY(4),MZ03(1),MZ03(2))
              KRAD = KRADSV
              CALL FMPI(MXY(3))
              CALL FMMPY_R1(MXY(3),MZ05(2))
              IF (MWK(START(MA(2))) >= 0) CALL FMMPYI_R1(MXY(3),-1)
              CALL FMEXP(MXY(3),MXY(5))
              CALL FMEQ(MXY(5),MXY(3))
              CALL FMMPYD(MXY(3),MZ03(1),MZ03(2),MZ06(1),MZ06(2))
              CALL ZMMPY(MZ02,MZ06,MZ01)
              CALL ZMEQ(MZ01,MZ02)
          ENDIF
          GO TO 120
      ENDIF
      IF (FMCOMP(MXY(2),'==',MXY(3)) .AND.  &
          (MWK(START(MXY(1))+2) <= (-NDIG).OR.MWK(START(MXY(1))+3) == 0)) THEN
          IF (MWK(START(MA(2))) > 0) THEN

!                 (i+c)**b = i**b * (1 - b*c*i - ... )

              CALL ZM2I2M(0,1,MZ02)
              CALL ZMSUB(MZ04,MZ02,MZ06)
              CALL ZMMPY(MZ05,MZ06,MZ02)
              DO J = -1, NDIG+1
                 MTEMP = MWK(START(MZ02(1))+J+1)
                 MWK(START(MZ02(1))+J+1) = MWK(START(MZ02(2))+J+1)
                 MWK(START(MZ02(2))+J+1) = MTEMP
              ENDDO
              IF (MWK(START(MZ02(2))+2) /= MUNKNO .AND. MWK(START(MZ02(2))+3) /= 0)  &
                  MWK(START(MZ02(2))) = -MWK(START(MZ02(2)))
              CALL FMADD_R1(MZ02(1),MXY(3))
              KRADSV = KRAD
              KRAD = 0
              CALL FMMPYI(MZ05(1),90,MXY(4))
              CALL FMCSSN(MXY(4),MZ03(1),MZ03(2))
              KRAD = KRADSV
              CALL FMPI(MXY(3))
              CALL FMMPY_R1(MXY(3),MZ05(2))
              CALL FMDIVI_R1(MXY(3),-2)
              CALL FMEXP(MXY(3),MXY(5))
              CALL FMEQ(MXY(5),MXY(3))
              CALL FMMPYD(MXY(3),MZ03(1),MZ03(2),MZ06(1),MZ06(2))
              CALL ZMMPY(MZ02,MZ06,MZ01)
              CALL ZMEQ(MZ01,MZ02)
          ELSE

!                 (-i+c)**b = (-i)**b * (1 + b*c*i - ... )

              CALL ZM2I2M(0,-1,MZ02)
              CALL ZMSUB(MZ04,MZ02,MZ06)
              CALL ZMMPY(MZ05,MZ06,MZ02)
              DO J = -1, NDIG+1
                 MTEMP = MWK(START(MZ02(1))+J+1)
                 MWK(START(MZ02(1))+J+1) = MWK(START(MZ02(2))+J+1)
                 MWK(START(MZ02(2))+J+1) = MTEMP
              ENDDO
              IF (MWK(START(MZ02(1))+2) /= MUNKNO .AND. MWK(START(MZ02(1))+3) /= 0)  &
                  MWK(START(MZ02(1))) = -MWK(START(MZ02(1)))
              CALL FMADD_R1(MZ02(1),MXY(3))
              KRADSV = KRAD
              KRAD = 0
              CALL FMMPYI(MZ05(1),-90,MXY(4))
              CALL FMCSSN(MXY(4),MZ03(1),MZ03(2))
              KRAD = KRADSV
              CALL FMPI(MXY(3))
              CALL FMMPY_R1(MXY(3),MZ05(2))
              CALL FMDIVI_R1(MXY(3),2)
              CALL FMEXP(MXY(3),MXY(5))
              CALL FMEQ(MXY(5),MXY(3))
              CALL FMMPYD(MXY(3),MZ03(1),MZ03(2),MZ06(1),MZ06(2))
              CALL ZMMPY(MZ02,MZ06,MZ01)
              CALL ZMEQ(MZ01,MZ02)
          ENDIF
          GO TO 120
      ENDIF

      CALL ZMLN(MZ04,MZ06)
      CALL ZMMPY(MZ05,MZ06,MZ02)
      CALL FMEQ(MZ02(2),MZ01(1))
      IF (MWK(START(MZ01(1))+2) > 25000) THEN
          KFLAG = -4
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MZ02)
          GO TO 130
      ENDIF
      KWRNSV = KWARN
      KWARN = 0
      CALL FMRDC(MZ01(1),JSIN,JCOS,JSWAP)
      KWARN = KWRNSV
      IEXTRA = INT(MWK(START(MZ02(2))+2) - MWK(START(MZ01(1))+2))
      IF (NDIG >= NDSAVE+NGRD52+MAX(0,IEXTRA)) IEXTRA = 0
      IF (IEXTRA > 1) THEN
          NDIG = NDIG + IEXTRA
          CALL ZMEQU_R1(MZ04,NDSAVE,NDIG)
          CALL ZMEQU_R1(MZ05,NDSAVE,NDIG)
          CALL ZMLN(MZ04,MZ06)
          CALL ZMMPY(MZ05,MZ06,MZ02)
      ENDIF

      CALL ZMEXP(MZ02,MZ04)
      CALL ZMEQ(MZ04,MZ02)

  120 MACCMB = MWK(START(MZ02(1))+1)
      MWK(START(MZ02(1))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)
      MACCMB = MWK(START(MZ02(2))+1)
      MWK(START(MZ02(2))+1) = MIN(MACCMB,MARZ,MAIZ,MBRZ,MBIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ02(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ02(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
  130 CALL ZMEXIT(MZ02,MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMPWR

      SUBROUTINE ZMREAD(KREAD,MA)

!  Read MA on unit KREAD.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KREAD
      INTEGER :: MA(2)

      CHARACTER :: LINE(80)
      INTEGER :: J,K,L2,LB
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMREAD'
      LB = 0

  110 READ (KREAD,"(80A1)",ERR=120,END=120) LINE

!             Scan the line and look for '&'

      DO J = 1, 80
         IF (LINE(J) == '&') GO TO 110
         IF (LINE(J) /= ' ') THEN
             LB = LB + 1
             IF (LB > LMBUFZ) THEN

!                If CMBUFZ runs out of space, try to re-allocate it with a bigger size.

                 IF (LMBUFZ > 0) THEN
                     ALLOCATE(MOVE_CMBUFF(LMBUFZ),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, LMBUFZ
                        MOVE_CMBUFF(K) = CMBUFZ(K)
                     ENDDO
                     DEALLOCATE(CMBUFZ)
                     L2 = MAX(10000,2*LMBUFZ)
                     ALLOCATE(CMBUFZ(L2),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     DO K = 1, L2
                        CMBUFZ(K) = ' '
                     ENDDO
                     DO K = 1, LMBUFZ
                        CMBUFZ(K) = MOVE_CMBUFF(K)
                     ENDDO
                     DEALLOCATE(MOVE_CMBUFF)
                     LMBUFZ = L2
                 ELSE
                     ALLOCATE(CMBUFZ(10000),STAT=K)
                     IF (K /= 0) THEN
                         CALL FMDEFINE_ERROR(1)
                     ENDIF
                     LMBUFZ = 10000
                 ENDIF
             ENDIF
             CMBUFZ(LB) = LINE(J)
          ENDIF
      ENDDO

      NCALL = NCALL - 1
      CALL ZMINP(CMBUFZ,MA,1,LB)

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN

!             If there is an error, return UNKNOWN.

  120 KFLAG = -4
      CALL ZMWARN
      CALL ZMST2M('UNKNOWN+UNKNOWN*i',MA)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMREAD

      SUBROUTINE ZMREAL(MA,MBFM)

!  MBFM = REAL(MA)

!  MA is a complex ZM number, MBFM is a real FM number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMREAL'
      IF (NTRACE /= 0) CALL ZMNTR(2,MA,MA,1)

      CALL FMEQ(MA(1),MBFM)

      IF (NTRACE /= 0) CALL FMNTR(1,MBFM,MBFM,1,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMREAL

      SUBROUTINE ZMRPWR(MA,IVAL,JVAL,MB)

!  MB = MA ** (IVAL/JVAL)

!  Raise a ZM number to a rational power.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL,JVAL
      REAL (KIND(1.0D0)) :: MA2,MACCMB,MAIZ,MARZ,MR1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IJSIGN,INVERT,IVAL2,J,JVAL2,K,KASAVE,KL,KOVUN,KR_RETRY,KST,L,LVAL,NDSAVE
      REAL :: XVAL

      DOUBLE PRECISION :: AR,BR,F,THETA,X
      INTEGER :: NSTACK(49)
      INTENT (IN) :: MA,IVAL,JVAL
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),MZ03(2),MZ04(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      MZ04 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMRPWR'
      NDSAVE = NDIG
      IF (NTRACE /= 0) THEN
          CALL ZMNTR(2,MA,MA,1)
          CALL FMNTRI(2,IVAL,0)
          CALL FMNTRI(2,JVAL,0)
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KOVUN = 0
      IF (MWK(START(MA(1))+2) == MEXPOV .OR. MWK(START(MA(1))+2) == MEXPUN .OR.  &
          MWK(START(MA(2))+2) == MEXPOV .OR. MWK(START(MA(2))+2) == MEXPUN) KOVUN = 1

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      IJSIGN = 1
      IVAL2 = ABS(IVAL)
      JVAL2 = ABS(JVAL)
      IF (IVAL > 0 .AND. JVAL < 0) IJSIGN = -1
      IF (IVAL < 0 .AND. JVAL > 0) IJSIGN = -1
      IF (IVAL2 > 0 .AND. JVAL2 > 0) CALL FMGCDI(IVAL2,JVAL2)

!             Check for special cases.

      IF (MWK(START(MA(1))+2) == MUNKNO .OR. MWK(START(MA(2))+2) == MUNKNO .OR.             &
          (IJSIGN <= 0 .AND. MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) .OR.  &
          JVAL == 0) THEN
          MA2 = MWK(START(MA(1))+3)
          KFLAG = -4
          IF (IVAL <= 0 .AND. MA2 == 0) CALL ZMWARN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      IF (IVAL == 0) THEN
          CALL ZMI2M(1,MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KASAVE = KACCSW
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Increase the working precision.

  110 IF (NCALL == 1) THEN
          XVAL = MAX(ABS(IVAL),ABS(JVAL)) + 1
          K = INT((5.0*REAL(DLOGTN) + LOG(XVAL))/ALOGMB + 2.0)
          NDIG = MAX(NDIG+K,2)
          IF (KR_RETRY >= 1) THEN
              NDIG = MAX(NDIG,2*NDSAVE+10)
          ENDIF
      ELSE
          XVAL = MAX(ABS(IVAL),ABS(JVAL)) + 1
          K = INT(LOG(XVAL)/ALOGMB + 1.0)
          NDIG = NDIG + K
      ENDIF
      IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR.  &
          MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
          NDIG = NDIG + 1
      ENDIF

      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)
      IF (IVAL2 == 1 .AND. JVAL2 == 2) THEN
          CALL ZMSQRT(MZ02,MZ04)
          IF (IJSIGN < 0) THEN
              CALL ZMI2M(1,MZ01)
              CALL ZMDIV(MZ01,MZ04,MZ02)
              CALL ZMEQ(MZ02,MZ04)
          ENDIF
          GO TO 120
      ENDIF

!             Generate the first approximation to MA**(1/JVAL2).

      CALL ZMI2M(0,MZ04)
      CALL FMDIG(NSTACK,KST)
      NDIG = NSTACK(1)
      CALL FMSQR(MZ02(1),MZ01(1))
      CALL FMSQR(MZ02(2),MXY(1))
      CALL FMADD_R1(MZ01(1),MXY(1))
      CALL FMSQRT_R1(MZ01(1))
      IF (MWK(START(MZ01(1))+2) >= MEXPOV) THEN
          KFLAG = -4
          CALL ZMWARN
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NDIG = NDSAVE
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Invert MA if ABS(MA) >= 1 and IVAL or JVAL is large.

      INVERT = 0
      IF (IVAL > 5 .OR. JVAL > 5) THEN
          IF (MWK(START(MZ01(1))+2) > 0 .AND. (MWK(START(MZ02(2))+3) /= 0 .OR.  &
              MWK(START(MZ02(1))) > 0)) THEN
              INVERT = 1
              NDIG = NSTACK(KST)
              CALL ZMI2M(1,MZ04)
              CALL ZMDIV(MZ04,MZ02,MZ03)
              CALL ZMEQ(MZ03,MZ02)
              NDIG = NSTACK(1)
              CALL FMDIV_R2(MZ04(1),MZ01(1))
          ENDIF
      ENDIF

      CALL FMDIV(MZ02(1),MZ01(1),MXY(1))
      IF (MWK(START(MXY(1))+2) == MUNKNO) THEN
          KFLAG = -4
          CALL ZMWARN
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NDIG = NDSAVE
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      CALL FMM2DP(MXY(1),AR)
      CALL FMDIV(MZ02(2),MZ01(1),MXY(1))
      IF (MWK(START(MXY(1))+2) == MUNKNO) THEN
          KFLAG = -4
          CALL ZMWARN
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NDIG = NDSAVE
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MB)
          IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      CALL FMM2DP(MXY(1),BR)
      MR1 = MWK(START(MZ01(1))+2)
      MWK(START(MZ01(1))+2) = 0
      CALL FMM2DP(MZ01(1),X)
      L = INT(MR1/JVAL2)
      F = MR1/DBLE(JVAL2) - L
      X = X**(1.0D0/JVAL2) * DBLE(MBASE)**F
      CALL FMDPM(X,MXY(1))
      MWK(START(MXY(1))+2) = MWK(START(MXY(1))+2) + L

      THETA = ATAN2(BR,AR)
      X = COS(THETA/JVAL2)
      CALL FMDPM(X,MZ04(1))
      X = SIN(THETA/JVAL2)
      CALL FMDPM(X,MZ04(2))
      CALL FMMPY_R2(MXY(1),MZ04(1))
      CALL FMMPY_R2(MXY(1),MZ04(2))

!             Newton iteration.

      DO J = 1, KST
         NDIG = NSTACK(J)
         IF (J < KST) NDIG = NDIG + 1
         LVAL = JVAL2 - 1
         CALL ZMIPWR(MZ04,LVAL,MZ01)
         CALL ZMDIV(MZ02,MZ01,MZ03)
         CALL ZMMPYI(MZ04,LVAL,MZ01)
         CALL ZMADD(MZ01,MZ03,MZ04)
         CALL ZMDIVI(MZ04,JVAL2,MZ03)
         CALL ZMEQ(MZ03,MZ04)
      ENDDO

      CALL ZMIPWR(MZ03,IJSIGN*IVAL2,MZ04)
      IF (INVERT == 1) THEN
          CALL ZMI2M(1,MZ01)
          CALL ZMDIV(MZ01,MZ04,MZ03)
          CALL ZMEQ(MZ03,MZ04)
      ENDIF

!             Round the result and return.

  120 MACCMB = MWK(START(MZ04(1))+1)
      MWK(START(MZ04(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ04(2))+1)
      MWK(START(MZ04(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ04(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ04(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ04,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMRPWR

      SUBROUTINE ZMRSLT(MC,KRESLT)

!  Handle results that are special cases, such as overflow, underflow, and unknown.

!  MC is the result that is returned

!  KRESLT is the result code.  Result codes handled here:

!   0 - Perform the normal operation
!  12 - The result is 'UNKNOWN'

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MC(2)
      INTEGER :: KRESLT

      INTEGER :: KFSAVE
      INTENT (IN) :: KRESLT
      INTENT (INOUT) :: MC

      KFSAVE = KFLAG

      IF (KRESLT == 12 .OR. KRESLT < 0 .OR. KRESLT > 15) THEN
          CALL ZMST2M('UNKNOWN+UNKNOWN*i',MC)
          KFLAG = KFSAVE
          RETURN
      ENDIF

      RETURN
      END SUBROUTINE ZMRSLT

      SUBROUTINE ZMSIN(MA,MB)

!  MB = SIN(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMSIN    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) < (-NDIG) .AND. MWK(START(MA(2))+2) < (-NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMSIN(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMSINH(MZ02(2),MZ01(2))
          CALL FMI2M(0,MZ01(1))
          GO TO 120
      ENDIF

!             Find COS(REAL(MA)) and SIN(REAL(MA)).

      CALL FMCSSN(MZ02(1),MZ01(2),MZ01(1))

!             Find COSH(IMAG(MA)) and SINH(IMAG(MA)).

      CALL FMCHSH(MZ02(2),MXY(1),MXY(2))

!             SIN(MA) =  SIN(REAL(MA))*COSH(IMAG(MA)) + COS(REAL(MA))*SINH(IMAG(MA)) i

      CALL FMMPY_R1(MZ01(1),MXY(1))
      CALL FMMPY_R1(MZ01(2),MXY(2))

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMSIN

      SUBROUTINE ZMSINH(MA,MB)

!  MB = SINH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMSINH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KACCSW = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) < (-NDIG) .AND. MWK(START(MA(2))+2) < (-NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMSIN(MZ02(2),MZ01(2))
          CALL FMI2M(0,MZ01(1))
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMSINH(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ENDIF

!             Find SIN(IMAG(MA)) and COS(IMAG(MA)).

      CALL FMCSSN(MZ02(2),MZ01(1),MZ01(2))

!             Find SINH(REAL(MA)) and COSH(REAL(MA)).

      CALL FMCHSH(MZ02(1),MXY(1),MXY(2))

!             SINH(MA) =  SINH(REAL(MA))*COS(IMAG(MA)) + COSH(REAL(MA))*SIN(IMAG(MA)) i

      CALL FMMPY_R1(MZ01(1),MXY(2))
      CALL FMMPY_R1(MZ01(2),MXY(1))

  120 MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMSINH

      SUBROUTINE ZMSQR(MA,MB)

!  MB = MA * MA

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDGSV2,NDSAVE,NTRSAV
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(2),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMSQR    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
                  IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMSQR'
              CALL ZMNTR(2,MA,MA,1)
          ENDIF
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              NDIG = MAX(NDIG+NGRD52,2)
              IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR.  &
                  MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
                  NDIG = NDIG + 1
              ENDIF
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
          KOVUN = 0
      ENDIF

      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)
      IF (NCALL == 1) THEN
          MWK(START(MZ02(1))+1) = NINT(NDIG*ALOGM2)
          MWK(START(MZ02(2))+1) = MWK(START(MZ02(1))+1)
      ENDIF

!             Check for special cases.

      IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMSQR(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMSQR(MZ02(2),MZ01(1))
          IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
              MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
          CALL FMI2M(0,MZ01(2))
      ELSE
          CALL FMADD(MZ02(1),MZ02(2),MXY(1))
          CALL FMSUB(MZ02(1),MZ02(2),MXY(2))
          CALL FMMPY(MXY(1),MXY(2),MZ01(1))
          CALL FMMPY(MZ02(1),MZ02(2),MXY(2))
          CALL FMADD(MXY(2),MXY(2),MZ01(2))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

      MXEXP = MXSAVE
      NTRACE = NTRSAV
      NDGSV2 = NDIG
      NDIG = NDSAVE
      KWARN = KWRNSV
      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      KACCSW = KASAVE
      CALL ZMEQU(MZ01,MB,NDGSV2,NDSAVE)
      IF (MWK(START(MB(1))+2) >= MEXPOV .OR. MWK(START(MB(1))+2) <= -MEXPOV .OR.  &
          MWK(START(MB(2))+2) >= MEXPOV .OR. MWK(START(MB(2))+2) <= -MEXPOV) THEN
          IF (MWK(START(MB(1))+2) == MUNKNO .OR. MWK(START(MB(2))+2) == MUNKNO) THEN
              KFLAG = -4
          ELSE IF (MWK(START(MB(1))+2) == MEXPOV .OR. MWK(START(MB(2))+2) == MEXPOV) THEN
              KFLAG = -5
          ELSE IF (MWK(START(MB(1))+2) == MEXPUN .OR. MWK(START(MB(2))+2) == MEXPUN) THEN
              KFLAG = -6
          ENDIF
          IF ((MWK(START(MB(1))+2) == MUNKNO) .OR. (MWK(START(MB(2))+2) == MUNKNO)  &
             .OR. (MWK(START(MB(1))+2) == MEXPUN .AND. KOVUN == 0)      &
             .OR. (MWK(START(MB(2))+2) == MEXPUN .AND. KOVUN == 0)      &
             .OR. (MWK(START(MB(1))+2) == MEXPOV .AND. KOVUN == 0)      &
             .OR. (MWK(START(MB(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
              NAMEST(NCALL) = 'ZMSQR'
              CALL ZMWARN
          ENDIF
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMSQR

      SUBROUTINE ZMSQRT(MA,MB)

!  MB = SQRT(MA).  Principal Square Root.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXEXP1,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KWRNSV,NDSAVE,NTRSAV

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MZ01(2),MZ02(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMSQRT   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
                  IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMSQRT'
              CALL ZMNTR(2,MA,MA,1)
          ENDIF
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              NDIG = MAX(NDIG+NGRD52,2)
              IF (MBASE >= 100*ABS(MWK(START(MA(1))+3)) .OR.  &
                  MBASE >= 100*ABS(MWK(START(MA(2))+3))) THEN
                  NDIG = NDIG + 1
              ENDIF
          ENDIF
          KASAVE = KACCSW
          KACCSW = 0
          MXSAVE = MXEXP
          MXEXP = MXEXP2
          KOVUN = 0
      ENDIF

      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      MXEXP1 = INT(MXEXP2/2.01D0)
      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMABS(MZ02(2),MXY(1))
          CALL FMDIVI(MXY(1),2,MXY(3))
          CALL FMSQRT_R1(MXY(3))
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMABS(MZ02(1),MXY(3))
          CALL FMSQRT_R1(MXY(3))
      ELSE IF (MWK(START(MA(1))+2) == MEXPUN) THEN
          IF (MWK(START(MA(2))+2) <= -MXEXP1+NDIG+1) THEN
              CALL ZMST2M('UNKNOWN + UNKNOWN i',MZ01)
              GO TO 120
          ENDIF
      ELSE IF (MWK(START(MA(2))+2) == MEXPUN) THEN
          IF (MWK(START(MA(1))+2) <= -MXEXP1+NDIG+1) THEN
              CALL ZMST2M('UNKNOWN + UNKNOWN i',MZ01)
              GO TO 120
          ENDIF
      ELSE
          CALL FMSQR(MZ02(1),MXY(1))
          CALL FMSQR(MZ02(2),MXY(2))
          CALL FMADD(MXY(1),MXY(2),MXY(3))
          CALL FMSQRT_R1(MXY(3))
          CALL FMABS(MZ02(1),MXY(2))
          CALL FMADD_R2(MXY(2),MXY(3))
          CALL FMDIVI_R1(MXY(3),2)
          CALL FMSQRT_R1(MXY(3))
      ENDIF

      CALL FMADD(MXY(3),MXY(3),MXY(2))
      IF (MWK(START(MA(1))) >= 0) THEN
          CALL FMDIV(MZ02(2),MXY(2),MZ01(2))
          CALL FMEQ(MXY(3),MZ01(1))
      ELSE
          IF (MWK(START(MA(2))) >= 0) THEN
              CALL FMDIV(MZ02(2),MXY(2),MZ01(1))
              CALL FMEQ(MXY(3),MZ01(2))
          ELSE
              CALL FMDIV(MZ02(2),MXY(2),MZ01(1))
              CALL FMEQ(MXY(3),MZ01(2))
              IF (MWK(START(MZ01(1))+2) /= MUNKNO .AND. MWK(START(MZ01(1))+3) /= 0)  &
                  MWK(START(MZ01(1))) = -MWK(START(MZ01(1)))
              IF (MWK(START(MZ01(2))+2) /= MUNKNO .AND. MWK(START(MZ01(2))+3) /= 0)  &
                  MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))
          ENDIF
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      MXEXP = MXSAVE
      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      KACCSW = KASAVE
      CALL ZMEQU(MZ01,MB,NDIG,NDSAVE)

      IF (MWK(START(MB(1))+2) == MUNKNO .OR. MWK(START(MB(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MB(1))+2) == MEXPOV .OR. MWK(START(MB(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MB(1))+2) == MEXPUN .OR. MWK(START(MB(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      NTRACE = NTRSAV
      NDIG = NDSAVE
      KWARN = KWRNSV
      IF ((MWK(START(MB(1))+2) == MUNKNO) .OR. (MWK(START(MB(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MB(1))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MB(2))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MB(1))+2) == MEXPOV .AND. KOVUN == 0)      &
         .OR. (MWK(START(MB(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMSQRT'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MB,MB,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMSQRT

      SUBROUTINE ZMST2M(STRING,MA)

!  MA = STRING

!  Convert a character string to FM format.
!  This is often more convenient than using ZMINP, which converts an array of character(1) values.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(*) :: STRING
      INTEGER :: MA(2)

      INTEGER :: J,LB,KFSAVE
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMST2M'
      LB = LEN(STRING)
      KFSAVE = KFLAG

      IF (LB > LMBUFZ) THEN
          IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
          ALLOCATE(CMBUFZ(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFZ = LB
      ENDIF
      DO J = 1, LB
         CMBUFZ(J) = STRING(J:J)
      ENDDO

      NCALL = NCALL - 1
      CALL ZMINP(CMBUFZ,MA,1,LB)

      IF (KFSAVE /= 0) KFLAG = KFSAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMST2M

      SUBROUTINE ZMSUB(MA,MB,MC)

!  MC = MA - MB

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2),MC(2)
      INTEGER :: KASAVE,KF1,KOVUN,KRESLT,KWRNSV,NDSAVE,NTRSAV
      REAL (KIND(1.0D0)) :: MXSAVE
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (ABS(MWK(START(MA(1))+2)) > MEXPAB .OR. ABS(MWK(START(MA(2))+2)) > MEXPAB .OR.  &
          ABS(MWK(START(MB(1))+2)) > MEXPAB .OR. ABS(MWK(START(MB(2))+2)) > MEXPAB .OR.  &
          KDEBUG >= 1) THEN
          CALL ZMENTR('ZMSUB    ',MA,MB,2,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
                  IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
          NDIG = NDSAVE
          MXEXP = MXSAVE
          KACCSW = KASAVE
      ELSE
          NCALL = NCALL + 1
          IF (NTRACE /= 0) THEN
              NAMEST(NCALL) = 'ZMSUB'
              CALL ZMNTR(2,MA,MB,2)
          ENDIF
          KOVUN = 0
      ENDIF

!             Force FMSUB to use more guard digits for user calls.

      NCALL = NCALL - 1
      NTRSAV = NTRACE
      NTRACE = 0
      KWRNSV = KWARN
      KWARN = 0

      CALL FMSUB(MA(1),MB(1),MC(1))
      KF1 = KFLAG
      CALL FMSUB(MA(2),MB(2),MC(2))

      NTRACE = NTRSAV
      KWARN = KWRNSV
      NCALL = NCALL + 1
      IF (NTRACE /= 0) NAMEST(NCALL) = 'ZMSUB'
      IF (KFLAG == 1) KFLAG = KF1

      IF (MWK(START(MC(1))+2) == MUNKNO .OR. MWK(START(MC(2))+2) == MUNKNO) THEN
          KFLAG = -4
      ELSE IF (MWK(START(MC(1))+2) == MEXPOV .OR. MWK(START(MC(2))+2) == MEXPOV) THEN
          KFLAG = -5
      ELSE IF (MWK(START(MC(1))+2) == MEXPUN .OR. MWK(START(MC(2))+2) == MEXPUN) THEN
          KFLAG = -6
      ENDIF
      IF ((MWK(START(MC(1))+2) == MUNKNO) .OR. (MWK(START(MC(2))+2) == MUNKNO)  &
         .OR. (MWK(START(MC(1))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MC(2))+2) == MEXPUN .AND. KOVUN == 0)      &
         .OR. (MWK(START(MC(1))+2) == MEXPOV .AND. KOVUN == 0)      &
         .OR. (MWK(START(MC(2))+2) == MEXPOV .AND. KOVUN == 0)) THEN
          NAMEST(NCALL) = 'ZMSUB'
          CALL ZMWARN
      ENDIF
      IF (NTRACE /= 0) CALL ZMNTR(1,MC,MC,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMSUB

      SUBROUTINE ZMTAN(MA,MB)

!  MB = TAN(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE,NGOAL
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MZ01(2),MZ02(2),MZ03(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMTAN    ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) < (-NDIG) .AND. MWK(START(MA(2))+2) < (-NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMTAN(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMTANH(MZ02(2),MZ01(2))
          CALL FMI2M(0,MZ01(1))
          GO TO 120
      ENDIF

!             Find SIN(2*REAL(MA)) and COS(2*REAL(MA)).

      CALL FMADD(MZ02(1),MZ02(1),MZ01(1))
      CALL FMCSSN(MZ01(1),MZ01(2),MXY(2))
      CALL FMEQ(MXY(2),MZ01(1))

!             Find SINH(2*IMAG(MA)) and COSH(2*IMAG(MA)).

      CALL FMADD(MZ02(2),MZ02(2),MXY(2))
      CALL FMCHSH(MXY(2),MXY(1),MXY(3))
      CALL FMEQ(MXY(3),MXY(2))

!             TAN(MA) =  SIN(2*REAL(MA))  / (COS(2*REAL(MA))+COSH(2*IMAG(MA)) +
!                        SINH(2*IMAG(MA)) / (COS(2*REAL(MA))+COSH(2*IMAG(MA)) i

      CALL FMADD_R2(MZ01(2),MXY(1))
      IF (MWK(START(MXY(1))+3) == 0) THEN
          MWK(START(MZ01(1))+1) = 0
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
          GO TO 130
      ELSE IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMDIV_R1(MZ01(1),MXY(1))
          CALL FMIM(1,MZ01(2))
          IF (MWK(START(MXY(2))) < 0 .AND. MWK(START(MZ01(2))+2) /= MUNKNO .AND.  &
              MWK(START(MZ01(2))+3) /= 0) MWK(START(MZ01(2))) = -MWK(START(MZ01(2)))
      ELSE
          CALL FMDIVD(MZ01(1),MXY(2),MXY(1),MZ03(1),MZ03(2))
          CALL ZMEQ(MZ03,MZ01)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
  130 IF (MWK(START(MZ01(1))+1) <= NGOAL .OR. MWK(START(MZ01(2))+1) <= NGOAL) THEN
          IEXTRA = INT(REAL(MAX(NGOAL-MWK(START(MZ01(1))+1),NGOAL-MWK(START(MZ01(2))+1)))  &
                   /ALOGM2 + 23.03/ALOGMB) + 1
          NDIG = NDIG + IEXTRA
          GO TO 110
      ENDIF

      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMTAN

      SUBROUTINE ZMTANH(MA,MB)

!  MB = TANH(MA).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MB(2)
      REAL (KIND(1.0D0)) :: MACCMB,MAIZ,MARZ,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE,NGOAL
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),MZ01(2),MZ02(2),MZ03(2),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MZ01 = -2
      MZ02 = -2
      MZ03 = -2
      IF (MB(1) <= 0) THEN
          CALL FMDEFINE(MB(1))
      ELSE IF (SIZE_OF(MB(1)) < NDIG+3) THEN
          CALL FMDEFINE(MB(1))
      ENDIF
      IF (MB(2) <= 0) THEN
          CALL FMDEFINE(MB(2))
      ELSE IF (SIZE_OF(MB(2)) < NDIG+3) THEN
          CALL FMDEFINE(MB(2))
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL ZMENTR('ZMTANH   ',MA,MA,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
              IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MARZ = MWK(START(MA(1))+1)
      MAIZ = MWK(START(MA(2))+1)
      KR_RETRY = 0
      KRSAVE = KRAD
      KRAD = 1

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL ZMEQU(MA,MZ02,NDSAVE,NDIG)

!             Check for special cases.

      IF (MWK(START(MA(1))+3) == 0 .AND. MWK(START(MA(2))+3) == 0) THEN
          CALL ZMI2M(0,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+2) < (-NDIG) .AND. MWK(START(MA(2))+2) < (-NDIG)) THEN
          CALL ZMEQ(MZ02,MZ01)
          GO TO 120
      ELSE IF (MWK(START(MA(1))+3) == 0) THEN
          CALL FMTAN(MZ02(2),MZ01(2))
          CALL FMI2M(0,MZ01(1))
          GO TO 120
      ELSE IF (MWK(START(MA(2))+3) == 0) THEN
          CALL FMTANH(MZ02(1),MZ01(1))
          CALL FMI2M(0,MZ01(2))
          GO TO 120
      ENDIF

!             Find SIN(2*IMAG(MA)) and COS(2*IMAG(MA)).

      CALL FMADD(MZ02(2),MZ02(2),MZ01(1))
      CALL FMCSSN(MZ01(1),MZ01(2),MXY(2))
      CALL FMEQ(MXY(2),MZ01(1))

!             Find SINH(2*REAL(MA)) and COSH(2*REAL(MA)).

      CALL FMADD(MZ02(1),MZ02(1),MXY(2))
      CALL FMCHSH(MXY(2),MXY(1),MXY(3))
      CALL FMEQ(MXY(3),MXY(2))

!             TANH(MA) =  SINH(2*REAL(MA)) / (COS(2*IMAG(MA))+COSH(2*REAL(MA)) +
!                         SIN(2*IMAG(MA))  / (COS(2*IMAG(MA))+COSH(2*REAL(MA)) i

      CALL FMADD_R2(MZ01(2),MXY(1))
      IF (MWK(START(MXY(1))+3) == 0) THEN
          MWK(START(MZ01(1))+1) = 0
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
          GO TO 130
      ELSE IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMDIV(MZ01(1),MXY(1),MZ01(2))
          CALL FMIM(1,MZ01(1))
          IF (MWK(START(MXY(2))) < 0) MWK(START(MZ01(1))) = -1
      ELSE
          CALL FMDIVD(MZ01(1),MXY(2),MXY(1),MZ03(2),MZ03(1))
          CALL ZMEQ(MZ03,MZ01)
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  120 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(1))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MZ01(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 7
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
  130 IF (MWK(START(MZ01(1))+1) <= NGOAL .OR. MWK(START(MZ01(2))+1) <= NGOAL) THEN
          IEXTRA = INT(REAL(MAX(NGOAL-MWK(START(MZ01(1))+1),NGOAL-MWK(START(MZ01(2))+1)))  &
                   /ALOGM2 + 23.03/ALOGMB) + 1
          NDIG = NDIG + IEXTRA
          GO TO 110
      ENDIF

      MACCMB = MWK(START(MZ01(1))+1)
      MWK(START(MZ01(1))+1) = MIN(MACCMB,MARZ,MAIZ)
      MACCMB = MWK(START(MZ01(2))+1)
      MWK(START(MZ01(2))+1) = MIN(MACCMB,MARZ,MAIZ)
      CALL ZMEXIT(MZ01,MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      KRAD = KRSAVE
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMTANH

      SUBROUTINE ZMUNPK(MP,MA)

!  MP is unpacked and the value returned in MA.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA(2),MP(2)
      INTENT (IN) :: MP
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MP(1),MA(1))
      CALL FMUNPK(MP(2),MA(2))
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMUNPK

      SUBROUTINE ZMWARN

!  Called by one of the ZM routines to print a warning message if any error condition arises in
!  that routine.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NAME

      INTEGER :: NCS

      IF (KFLAG >= 0 .OR. NCALL /= 1 .OR. KWARN <= 0) RETURN
      NCS = NCALL
      NAME = NAMEST(NCALL)
      WRITE (KW,"(/' Error of type KFLAG =',I3,"   //  &
                "' in FM package in routine ',A/)"     &
            ) KFLAG,TRIM(NAME)

  110 NCALL = NCALL - 1
      IF (NCALL > 0) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"( ' called from ',A)") TRIM(NAME)
          GO TO 110
      ENDIF

      IF (KFLAG == -1) THEN
          WRITE (KW,"(' NDIG must be at least 2'/)")
      ELSE IF (KFLAG == -2) THEN
          WRITE (KW,"(' MBASE must be between 2 and',I10/)") INT(MXBASE)
      ELSE IF (KFLAG == -3) THEN
          WRITE (KW,  &
                 "(' An input argument is not a valid FM number.',"  //  &
                 "'  Its exponent is out of range.'/)"                   &
                )
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -4 .OR. KFLAG == -7) THEN
          WRITE (KW,"(' Invalid input argument for this routine.'/)")
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -5) THEN
          WRITE (KW,"(' The result has overflowed.'/)")
      ELSE IF (KFLAG == -6) THEN
          WRITE (KW,"(' The result has underflowed.'/)")
      ELSE IF (KFLAG == -8 .AND. NAME == 'ZMOUT') THEN
          WRITE (KW,  &
                 "(' The result array is not big enough to hold the',"    //  &
                 "' output character string'/' in the current format.'/"  //  &
                 "' The result ''***...***'' has been returned.'/)"           &
                )
      ELSE IF (KFLAG == -8 .AND. NAME == 'ZMREAD') THEN
          WRITE (KW,  &
                 "(' The CMBUFF array is not big enough to hold the',"  //  &
                 "' input character string'/"                           //  &
                 "' UNKNOWN has been returned.'/)"                          &
                )
      ELSE IF (KFLAG == -9) THEN
          WRITE (KW,  &
                 "(' Precision could not be raised enough to'"  //  &
                 ",' provide all requested guard digits.'/)"        &
                )
          WRITE (KW,  &
                 "(I23,' digits were requested (NDIG).'/)"          &
                ) NDIG
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ENDIF

      NCALL = NCS
      IF (KWARN >= 2) THEN
          STOP
      ENDIF
      RETURN
      END SUBROUTINE ZMWARN

      SUBROUTINE ZMWRIT(KWRITE,MA)

!  Write MA on unit KWRITE under the current format.  Multi-line numbers will have '&' as the last
!  nonblank character on all but the last line of the real part and the imaginary part.
!  These numbers can then be read easily using ZMREAD.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: KWRITE
      INTEGER :: MA(2)

      INTEGER :: J,K,KSAVE,L,LAST,LAST1,LAST2,LB,ND,NEXP
      INTENT (IN) :: MA,KWRITE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMWRIT'
      KSAVE = KFLAG
      ND = INT(REAL(NDIG)*LOG10(REAL(MBASE))) + 1
      IF (ND < 2) ND = 2
      NEXP = INT(2.0*LOG10(REAL(MXBASE))) + 16
      LB = 2*MAX(JFORM2+NEXP,ND+NEXP) + 3
      IF (LB > LMBUFZ) THEN
          IF (LMBUFZ > 0) DEALLOCATE(CMBUFZ)
          ALLOCATE(CMBUFZ(LB),STAT=J)
          IF (J /= 0) THEN
              CALL FMDEFINE_ERROR(1)
          ENDIF
          LMBUFZ = LB
      ENDIF
      CALL ZMOUT(MA,CMBUFZ,LB,LAST1,LAST2)
      KFLAG = KSAVE
      LAST = LAST2 + 1
      DO J = 1, LAST2
         IF (CMBUFZ(LAST-J) /= ' ' .OR. J == LAST2) THEN
             L = LAST - J
             IF (MOD(L,73) /= 0) THEN
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFZ(K),K=1,L)
             ELSE
                 WRITE (KWRITE,"(4X,73A1,' &')") (CMBUFZ(K),K=1,L-73)
                 WRITE (KWRITE,"(4X,73A1)") (CMBUFZ(K),K=L-72,L)
             ENDIF
             NCALL = NCALL - 1
             IF (TEMPV_CALL_STACK == 1) THEN
                 IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
                 IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
             ENDIF
             TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
             RETURN
         ENDIF
      ENDDO
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMWRIT

      SUBROUTINE ZMZ2M(ZVAL,MA)

!  MA = ZVAL

!  ZVAL is complex and is converted to ZM form.

      USE FMVALS
      IMPLICIT NONE

      COMPLEX ZVAL
      INTEGER :: MA(2)
      INTENT (IN) :: ZVAL
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'ZMZ2M'
      IF (NTRACE /= 0) CALL ZMNTRZ(2,ZVAL,1)

      CALL FMSP2M(REAL(ZVAL),MA(1))
      CALL FMSP2M(AIMAG(ZVAL),MA(2))

      IF (NTRACE /= 0) CALL ZMNTR(1,MA,MA,1)
      NCALL = NCALL - 1
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZMZ2M


!  Here are the routines which work with packed ZM numbers.
!  All names are the same as unpacked versions with 'ZM' replaced by 'ZP'.

!  This packed format is not available when using the FM, IM, or ZM derived types.

      SUBROUTINE ZPABS(MA,MBFM)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMABS(MPX,MPA)
      CALL FMPACK(MPA,MBFM)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPABS

      SUBROUTINE ZPACOS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMACOS(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPACOS

      SUBROUTINE ZPADD(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMUNPK(MB,MPY)
      CALL ZMADD(MPX,MPY,MPZ)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPADD

      SUBROUTINE ZPADDI(MA,INTEG)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      INTEGER :: INTEG
      INTENT (IN) :: INTEG
      INTENT (INOUT) :: MA
      CALL ZMUNPK(MA,MPX)
      CALL ZMADDI(MPX,INTEG)
      CALL ZMPACK(MPX,MA)
      RETURN
      END SUBROUTINE ZPADDI

      SUBROUTINE ZPARG(MA,MBFM)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMARG(MPX,MPA)
      CALL FMPACK(MPA,MBFM)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPARG

      SUBROUTINE ZPASIN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMASIN(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPASIN

      SUBROUTINE ZPATAN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMATAN(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPATAN

      SUBROUTINE ZPCHSH(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMCHSH(MPX,MPY,MPZ)
      CALL ZMPACK(MPY,MB)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCHSH

      SUBROUTINE ZPCMPX(MAFM,MBFM,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MAFM,MBFM,MC(2)
      INTENT (IN) :: MAFM,MBFM
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MAFM,MPA)
      CALL FMUNPK(MBFM,MPB)
      CALL ZMCMPX(MPA,MPB,MPX)
      CALL ZMPACK(MPX,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCMPX

      SUBROUTINE ZPCONJ(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMCONJ(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCONJ

      SUBROUTINE ZPCOS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMCOS(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCOS

      SUBROUTINE ZPCOSH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMCOSH(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCOSH

      SUBROUTINE ZPCSSN(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMCSSN(MPX,MPY,MPZ)
      CALL ZMPACK(MPY,MB)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPCSSN

      SUBROUTINE ZPDIV(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMUNPK(MB,MPY)
      CALL ZMDIV(MPX,MPY,MPZ)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPDIV

      SUBROUTINE ZPDIVI(MA,INTEG,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: INTEG
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMDIVI(MPX,INTEG,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPDIVI

      SUBROUTINE ZPEQ(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FPEQ(MA(1),MB(1))
      CALL FPEQ(MA(2),MB(2))
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPEQ

      SUBROUTINE ZPEQU(MA,MB,NDA,NDB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: NDA,NDB
      INTENT (IN) :: MA,NDA,NDB
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FPEQU(MA(1),MB(1),NDA,NDB)
      CALL FPEQU(MA(2),MB(2),NDA,NDB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPEQU

      SUBROUTINE ZPEQU_R1(MA,NDA,NDB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      INTEGER :: NDA,NDB
      INTENT (IN) :: NDA,NDB
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FPEQU_R1(MA(1),NDA,NDB)
      CALL FPEQU_R1(MA(2),NDA,NDB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPEQU_R1

      SUBROUTINE ZPEXP(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMEXP(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPEXP

      SUBROUTINE ZPFORM(FORM1,FORM2,MA,STRING)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      CHARACTER(*) :: FORM1,FORM2,STRING
      INTENT (IN) :: MA,FORM1,FORM2
      INTENT (INOUT) :: STRING
      CALL ZMUNPK(MA,MPX)
      CALL ZMFORM(FORM1,FORM2,MPX,STRING)
      RETURN
      END SUBROUTINE ZPFORM

      SUBROUTINE ZPFPRT(FORM1,FORM2,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      CHARACTER(*) :: FORM1,FORM2
      INTENT (IN) :: MA,FORM1,FORM2
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMFPRT(FORM1,FORM2,MPX)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPFPRT

      SUBROUTINE ZP2I2M(INTEG1,INTEG2,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: INTEG1,INTEG2
      INTEGER :: MA(2)
      INTENT (IN) :: INTEG1,INTEG2
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZM2I2M(INTEG1,INTEG2,MPX)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZP2I2M

      SUBROUTINE ZPI2M(INTEG,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: INTEG
      INTEGER :: MA(2)
      INTENT (IN) :: INTEG
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMI2M(INTEG,MPX)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPI2M

      SUBROUTINE ZPIMAG(MA,MBFM)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMIMAG(MPX,MPA)
      CALL FMPACK(MPA,MBFM)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPIMAG

      SUBROUTINE ZPINT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMINT(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPINT

      SUBROUTINE ZPINP(LINE,MA,LA,LB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: LA,LB
      CHARACTER :: LINE(LB)
      INTEGER :: MA(2)
      INTENT (IN) :: LINE,LA,LB
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMINP(LINE,MPX,LA,LB)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPINP

      SUBROUTINE ZPIPWR(MA,INTEG,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: INTEG
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMIPWR(MPX,INTEG,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPIPWR

      SUBROUTINE ZPLG10(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMLG10(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPLG10

      SUBROUTINE ZPLN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMLN(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPLN

      SUBROUTINE ZPM2I(MA,INTEG)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      INTEGER :: INTEG
      INTENT (IN) :: MA
      INTENT (INOUT) :: INTEG
      CALL ZMUNPK(MA,MPX)
      CALL ZMM2I(MPX,INTEG)
      RETURN
      END SUBROUTINE ZPM2I

      SUBROUTINE ZPM2Z(MA,ZVAL)
      USE FMVALS
      IMPLICIT NONE
      COMPLEX ZVAL
      INTEGER :: MA(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: ZVAL
      CALL ZMUNPK(MA,MPX)
      CALL ZMM2Z(MPX,ZVAL)
      RETURN
      END SUBROUTINE ZPM2Z

      SUBROUTINE ZPMPY(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMUNPK(MB,MPY)
      CALL ZMMPY(MPX,MPY,MPZ)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPMPY

      SUBROUTINE ZPMPYI(MA,INTEG,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: INTEG
      INTENT (IN) :: MA,INTEG
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMMPYI(MPX,INTEG,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPMPYI

      SUBROUTINE ZPNINT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMNINT(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPNINT

      SUBROUTINE ZPOUT(MA,LINE,LB,LAST1,LAST2)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      INTEGER :: LB,LAST1,LAST2
      CHARACTER :: LINE(LB)
      INTENT (IN) :: MA,LB
      INTENT (INOUT) :: LINE,LAST1,LAST2
      CALL ZMUNPK(MA,MPX)
      CALL ZMOUT(MPX,LINE,LB,LAST1,LAST2)
      RETURN
      END SUBROUTINE ZPOUT

      SUBROUTINE ZPPRNT(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2)
      INTENT (IN) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMPRNT(MPX)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPPRNT

      SUBROUTINE ZPPWR(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMUNPK(MB,MPY)
      CALL ZMPWR(MPX,MPY,MPZ)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPPWR

      SUBROUTINE ZPREAD(KREAD,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KREAD
      INTEGER :: MA(2)
      INTENT (IN) :: KREAD
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMREAD(KREAD,MPX)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPREAD

      SUBROUTINE ZPREAL(MA,MBFM)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MBFM
      INTENT (IN) :: MA
      INTENT (INOUT) :: MBFM
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMREAL(MPX,MPA)
      CALL FMPACK(MPA,MBFM)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MBFM) == -1) TEMPV(MBFM) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPREAL

      SUBROUTINE ZPRPWR(MA,IVAL,JVAL,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL,JVAL
      INTENT (IN) :: MA,IVAL,JVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMRPWR(MPX,IVAL,JVAL,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPRPWR

      SUBROUTINE ZPSET(NPREC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: NPREC
      INTENT (IN) :: NPREC
      CALL ZMSET(NPREC)
      RETURN
      END SUBROUTINE ZPSET

      SUBROUTINE ZPSIN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMSIN(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPSIN

      SUBROUTINE ZPSINH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMSINH(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPSINH

      SUBROUTINE ZPSQR(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMSQR(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPSQR

      SUBROUTINE ZPSQRT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMSQRT(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPSQRT

      SUBROUTINE ZPST2M(STRING,MA)
      USE FMVALS
      IMPLICIT NONE
      CHARACTER(*) :: STRING
      INTEGER :: MA(2)
      INTENT (IN) :: STRING
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMST2M(STRING,MPX)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPST2M

      SUBROUTINE ZPSUB(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMUNPK(MB,MPY)
      CALL ZMSUB(MPX,MPY,MPZ)
      CALL ZMPACK(MPZ,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC(1)) == -1) TEMPV(MC(1)) = -2
          IF (TEMPV(MC(2)) == -1) TEMPV(MC(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPSUB

      SUBROUTINE ZPTAN(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMTAN(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPTAN

      SUBROUTINE ZPTANH(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMTANH(MPX,MPY)
      CALL ZMPACK(MPY,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB(1)) == -1) TEMPV(MB(1)) = -2
          IF (TEMPV(MB(2)) == -1) TEMPV(MB(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPTANH

      SUBROUTINE ZPWRIT(KWRITE,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA(2)
      INTENT (IN) :: MA,KWRITE
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMUNPK(MA,MPX)
      CALL ZMWRIT(KWRITE,MPX)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPWRIT

      SUBROUTINE ZPZ2M(ZVAL,MA)
      USE FMVALS
      IMPLICIT NONE
      COMPLEX ZVAL
      INTEGER :: MA(2)
      INTENT (IN) :: ZVAL
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL ZMZ2M(ZVAL,MPX)
      CALL ZMPACK(MPX,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA(1)) == -1) TEMPV(MA(1)) = -2
          IF (TEMPV(MA(2)) == -1) TEMPV(MA(2)) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE ZPZ2M


!  These FM routines perform gamma and related functions.

!  FMBERNOULLI(N,MA)    MA = B(N)  Nth Bernoulli number

!  FMBETA(MA,MB,MC)     MC = Beta(MA,MB)

!  FMCOMB(MA,MB,MC)     MC = Combination MA choose MB  (Binomial coeff.)

!  FMEULER(MA)          MA = Euler's constant ( 0.5772156649... )     < old name: FMEULR >

!  FMFACT(MA,MB)        MB = MA Factorial  (Gamma(MA+1))

!  FMGAM(MA,MB)         MB = Gamma(MA)

!  FMIBTA(MX,MA,MB,MC)  MC = Incomplete Beta(MX,MA,MB)

!  FMIGM1(MA,MB,MC)     MC = Incomplete Gamma(MA,MB).  Lower case Gamma(a,x)

!  FMIGM2(MA,MB,MC)     MC = Incomplete Gamma(MA,MB).  Upper case Gamma(a,x)

!  FMLNGM(MA,MB)        MB = Ln(Gamma(MA))

!  FMPGAM(N,MA,MB)      MB = Polygamma(N,MA)  (Nth derivative of Psi)

!  FMPOCH(MA,N,MB)      MB = MA*(MA+1)*(MA+2)*...*(MA+N-1)  (Pochhammer)

!  FMPSI(MA,MB)         MB = Psi(MA)      (Derivative of Ln(Gamma(MA))

!  For each of these routines there is also a version available for which the argument list is the
!  same but all FM numbers are in packed format.  The packed versions have the same names except
!  'FM' is replaced by 'FP' at the start of each name.

! --------------------------------------------------------------------------------------------------

      SUBROUTINE FMARG2(KROUTN,NARGS,MA,MB,KRESLT)

!  Check the input arguments to a routine for special cases.

!  KROUTN - Name of the subroutine that was called
!  NARGS  - The number of input arguments (1 or 2)
!  MA     - First input argument
!  MB     - Second input argument (if NARGS is 2)
!  KRESLT - Result code returned to the calling routine.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: KROUTN
      INTEGER :: MA,MB
      INTEGER :: NARGS,KRESLT

      INTEGER :: NCATMA,NCATMB

      INTEGER, PARAMETER ::  &
               KFACT(15) = (/ 12,12, 0,12, 0, 0, 8, 8, 8, 0, 0, 8, 0, 4, 4 /), &
               KGAM(15)  = (/ 12,12, 0,12, 0, 0, 3,12, 4, 0, 0, 8, 0, 4, 4 /), &
               KLNGM(15) = (/ 12,12, 0,12,12,12,12,12,12, 0, 0,11, 0, 0, 4 /), &
               KPSI(15)  = (/ 12,12, 0,12, 0, 0, 4,12, 3, 0, 0, 0, 0, 0,12 /)
      INTENT (IN) :: MA,MB

      CALL FMARGS(KROUTN,NARGS,MA,MB,KRESLT)
      IF (KFLAG /= 0) RETURN

!             Check for special cases.

      CALL FMCAT(MA,NCATMA)
      NCATMB = 0
      IF (NARGS == 2) CALL FMCAT(MB,NCATMB)

      IF (KROUTN == 'FMFACT') THEN
          KRESLT = KFACT(NCATMA)
          GO TO 110
      ENDIF

      IF (KROUTN == 'FMGAM') THEN
          KRESLT = KGAM(NCATMA)
          GO TO 110
      ENDIF

      IF (KROUTN == 'FMLNGM') THEN
          KRESLT = KLNGM(NCATMA)
          GO TO 110
      ENDIF

      IF (KROUTN == 'FMPSI') THEN
          KRESLT = KPSI(NCATMA)
          GO TO 110
      ENDIF

      KRESLT = 0
      RETURN

  110 IF (KRESLT == 12) THEN
          KFLAG = -4
          CALL FMWRN2
      ENDIF
      IF (KRESLT == 3 .OR. KRESLT == 4) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              KFLAG = -5
          ELSE
              KFLAG = -5
              CALL FMWRN2
          ENDIF
      ENDIF
      IF (KRESLT == 5 .OR. KRESLT == 6) THEN
          IF (NCATMA == 1 .OR. NCATMA == 7 .OR. NCATMA == 9 .OR. NCATMA == 15 .OR.  &
              NCATMB == 1 .OR. NCATMB == 7 .OR. NCATMB == 9 .OR. NCATMB == 15) THEN
              KFLAG = -6
          ELSE
              KFLAG = -6
              CALL FMWRN2
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMARG2

      SUBROUTINE FMBERNOULLI(N,MA)

!  MA = B(N)  where B(N) is the Nth Bernoulli number.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA

      DOUBLE PRECISION :: B
      REAL (KIND(1.0D0)) :: MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,K,KASAVE,KL,KOVUN,KR_RETRY,NDGOAL,NDSAVE,NGOAL,NUMTRY
      INTENT (IN) :: N
      INTENT (INOUT) :: MA
      INTEGER :: MXY(5),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NCALL = NCALL + 1
      NAMEST(NCALL) = 'BERNOULLI'
      IF (NTRACE /= 0) THEN
          CALL FMNTRI(2,N,1)
      ENDIF
      IF (MBLOGS /= MBASE) CALL FMCONS
      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = INT(5.0/ALOGMT + 2.0 + (REAL(NDIG)*ALOGMT)**0.35/ALOGMT)
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KASAVE = KACCSW
      KOVUN = 0
      MXSAVE = MXEXP
      MXEXP = MXEXP2
      KACCSW = 1
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      NUMTRY = 0

!             For functions that sum series using Bernoulli numbers, N will normally be NUMBRN+2
!             here, or possibly 28 when NUMBRN is zero.  Check to see if this N is much larger than
!             NUMBRN and can be computed directly from the zeta(N) series without computing
!             and saving the intermediate Bernoulli numbers, otherwise call FMBERN.

  120 B = NDIG*LOG(DBLE(MBASE))/6.91
      IF (N > NUMBRN+100 .AND. N > B) THEN
          CALL FMI2M(1,MXY(1))
          DO J = 2, 10000
             CALL FMI2M(J,MXY(2))
             CALL FMIPWR(MXY(2),-N,MXY(3))
             CALL FMADD_R1(MXY(1),MXY(3))
             IF (KFLAG == 1) EXIT
          ENDDO
          CALL FMI2M(N,MXY(3))
          CALL FMFACT(MXY(3),MXY(2))
          CALL FMMPY_R1(MXY(1),MXY(2))
          CALL FMMPYI_R1(MXY(1),2*(-1)**(N/2+1))
          CALL FMPI(MXY(2))
          CALL FMMPYI_R1(MXY(2),2)
          CALL FMIPWR(MXY(2),N,MXY(3))
          CALL FMDIV(MXY(1),MXY(3),MXY(4))
      ELSE
          CALL FMI2M(1,MXY(1))
          CALL FMBERN(N,MXY(1),MXY(4))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(4))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(4))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(4))+J+1)) GO TO 130
              ENDDO
              GO TO 140
          ENDIF
  130     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(4))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDIG = NDIG + IEXTRA
          NUMTRY = NUMTRY + 1
          GO TO 120
      ENDIF

  140 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(4))+1) = MIN(MWK(START(MXY(4))+1),MACMAX)
      CALL FMEXT2(MXY(4),MA,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBERNOULLI

      SUBROUTINE FMBERN(N,MA,MB)

!  MB = MA*B(N)      B(N) is the Nth Bernoulli number.  (Internal routine used by special functions)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA,MB

!             MBERN is the array used to save Bernoulli numbers so they do not have to be
!                   re-computed on subsequent calls.

!             Only the even-numbered Bernoulli numbers are stored.
!             B(2N) starts in MBERN(N) for 2N >= 28.
!             The first few numbers have small numerators and denominators, and they are done using
!             FMMPYI and FMDIVI, and are not stored in MBERN.

      DOUBLE PRECISION :: U,UJ,X,B
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MNEXP,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTNDG,J,J2,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,L,LARGE,LARGED,N2,NBOT,   &
                 NDGOAL,NDIV,NDOLD,NDP,NDSAV1,NDSAV2,NDSAVE,NEXTD,NEXTN,NGOAL,NMPY,NSTART,NTD,  &
                 NTN,NTOP,NUMTRY,NX
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(5),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMBERN'
          CALL FMNTRI(2,N,1)
          NCALL = NCALL - 1
      ENDIF
      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (ABS(MWK(START(MA)+2)) > MEXPAB) THEN
          CALL FMENT2('FMBERN   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
          IF (KRESLT /= 0) THEN
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
              RETURN
          ENDIF
      ELSE
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMBERN'
          IF (NTRACE /= 0) CALL FMNTR(2,MA,MA,1,0)
          KOVUN = 0
          IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
          NDSAVE = NDIG
          IF (NCALL == 1) THEN
              K = INT(5.0/ALOGMT + 2.0 + (REAL(NDIG)*ALOGMT)**0.35/ALOGMT)
              NDIG = MAX(NDIG+K,2)
          ENDIF
          KASAVE = KACCSW
          MXSAVE = MXEXP
          MXEXP = MXEXP2
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(5),NDSAVE,NDIG)
      MWK(START(MXY(5))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             Check for special cases.

  120 IF (N >= 2 .AND. N <= 26) THEN
          CALL FMBER2(N,MXY(5),MXY(4))
          GO TO 130
      ELSE IF (N == 0) THEN
          CALL FMEQ(MXY(5),MXY(4))
          GO TO 130
      ELSE IF (N == 1) THEN
          CALL FMDIVI(MXY(5),-2,MXY(4))
          GO TO 130
      ELSE IF (MWK(START(MA)+3) == 0) THEN
          CALL FMI2M(0,MXY(4))
          GO TO 130
      ENDIF

      IF (MOD(N,2) == 1 .OR. N < 0) THEN
          CALL FMI2M(0,MXY(4))
          GO TO 130
      ELSE IF (N/2 > LMBERN) THEN
          KFLAG = -11
          CALL FMWRN2
          WRITE (KW,*) ' '
          WRITE (KW,*) ' Too many Bernoulli numbers were needed in FMBERN.'
          WRITE (KW,*) ' B(',N,') was requested, and the current maximum is B(',LMBERN*2,').'
          WRITE (KW,*) ' '
          MXEXP = MXSAVE
          NDIG = NDSAVE
          CALL FMST2M('UNKNOWN',MB)
          IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
          NCALL = NCALL - 1
          KACCSW = KASAVE
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             See if B(N) has already been computed with sufficient precision.

      N2 = N/2
      IF (MBASE == MBSBRN) THEN
          IF (N <= NUMBRN) THEN
              IF (MBERN(N2) > 0) THEN
                  IF (SIZE_OF(MBERN(N2)) >= NDIG+3) THEN
                      IF (NDBERN(N2) >= NDIG) THEN
                          CALL FMMPY(MBERN(N2),MXY(5),MXY(4))
                          GO TO 130
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
      ELSE
          DO J = 28, NUMBRN, 2
             NDBERN(J/2) = 0
          ENDDO
          NUMBRN = 0
      ENDIF

!             Compute more Bernoulli numbers.

      X = 1.0D0
      B = DBLE(MBASE)
      NDP = 0
      DO J = 1, 80
         X = X/B
         IF ((1.0D0+X) <= 1.0D0) THEN
             NDP = J-1
             IF (NDIG <= NDP) X = 4.0D0*DPPI*DPPI
             EXIT
         ENDIF
      ENDDO
      INTNDG = INT(ALOGMX/ALOGMB + 1.0)
      NX = INT(DBLE(NDIG)*DLOGMB/DLOGTW + 2.0D0)
      NSTART = 28
      IF (MBSBRN == MBASE .AND. NUMBRN >= 28) THEN
          NSTART = NUMBRN + 2
          DO J = 28, NUMBRN, 2
             IF (SIZE_OF(MBERN(J/2)) < NDIG+3 .OR. NDBERN(J/2) < NDIG) THEN
                 NSTART = J
                 EXIT
             ENDIF
          ENDDO
      ENDIF

      DO J = NSTART, N, 2

!             Check to see if J is large enough so that the formula
!             B(J) = -B(J-2)*(J-1)*J/(2*pi)**2 can be used.

         IF (J >= NX .AND. NDIG <= NDP .AND. J > 28) THEN
             J2 = J/2
             MNEXP = MWK(START(MBERN(J2-1))+2)
             MWK(START(MBERN(J2-1))+2) = 0
             CALL FMM2DP(MBERN(J2-1),U)
             MWK(START(MBERN(J2-1))+2) = MNEXP
             UJ = J
             U = -U*(UJ*UJ-UJ)/X
             NUMBRN = J
             MBSBRN = MBASE
             CALL FMDPM(U,MBERN(J2))
             MWK(START(MBERN(J2))+2) = MWK(START(MBERN(J2))+2) + MNEXP
             NDBERN(J2) = NDIG
             CYCLE
         ENDIF

         IF (J >= NX .AND. J > 28) THEN
             LARGE = INT(INTMAX/J)
             J2 = J/2
             NUMBRN = J
             MBSBRN = MBASE
             CALL FMPI(MXY(2))
             CALL FMSQR_R1(MXY(2))
             IF (MOD(J,4) == 0 .OR. MOD(J,4) == 1) THEN
                 IF (J < LARGE) THEN
                     L = -(J*J-J)/4
                     CALL FMMPYI(MBERN(J2-1),L,MXY(3))
                 ELSE
                     CALL FMMPYI(MBERN(J2-1),-J,MXY(3))
                     CALL FMMPYI_R1(MXY(3),J-1)
                     CALL FMDIVI_R1(MXY(3),4)
                 ENDIF
             ELSE
                 IF (J < LARGE) THEN
                     L = -(J*J-J)
                     CALL FMMPYI(MBERN(J2-1),L,MXY(3))
                     CALL FMDIVI_R1(MXY(3),4)
                 ELSE
                     CALL FMMPYI(MBERN(J2-1),-J,MXY(3))
                     CALL FMMPYI_R1(MXY(3),J-1)
                     CALL FMDIVI_R1(MXY(3),4)
                 ENDIF
             ENDIF
             CALL FMDIV(MXY(3),MXY(2),MBERN(J2))
             NDBERN(J2) = NDIG
             CYCLE
         ENDIF

!             Use the recurrence involving a sum of binomial coefficients times previous B's.

         NTOP = J + 3
         NBOT = J - 6
         LARGE = INT(INTMAX/NTOP)
         LARGED = MIN(LARGE,INT(MXBASE))
         CALL FMCMBI(NTOP,NBOT,MXY(2))
         IF (NBOT <= 26) THEN
             CALL FMBER2(NBOT,MXY(2),MXY(3))
         ELSE
             CALL FMMPY(MBERN(NBOT/2),MXY(2),MXY(3))
         ENDIF
         NDSAV1 = NDIG
         DO NBOT = J-12, 0, -6
            NTN = NBOT + 6
            NTD = NTOP - NBOT - 5
            NEXTN = NTN
            NEXTD = NTD
            IF (NBOT >= 6) THEN
                NDSAV2 = NDIG
                DO K = 1, 5
                   NEXTN = NEXTN - 1
                   NEXTD = NEXTD + 1
                   NMPY = NTN*NEXTN
                   NDIV = NTD*NEXTD
                   IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
                       NTN = NMPY
                       NTD = NDIV
                   ELSE
                       CALL FMGCDI(NMPY,NDIV)
                       IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
                           NTN = NMPY
                           NTD = NDIV
                       ELSE
                           NDIG = MAX(NGRD22,MIN(NDSAV2,INT(MWK(START(MXY(2))+2))+INTNDG))
                           CALL FMMPYI_R1(MXY(2),NTN)
                           CALL FMDIVI_R1(MXY(2),NTD)
                           NTN = NEXTN
                           NTD = NEXTD
                       ENDIF
                   ENDIF
                ENDDO
                NDIG = MAX(NGRD22,MIN(NDSAV2,INT(MWK(START(MXY(2))+2))+INTNDG))
                CALL FMMPYI_R1(MXY(2),NTN)
                CALL FMDIVI_R1(MXY(2),NTD)
                NDIG = NDSAV2
            ELSE
                CALL FMCMBI(NTOP,NBOT,MXY(2))
            ENDIF
            MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)

!             Now MXY(2) is the combination NTOP choose NBOT.

            IF (NBOT <= 26) THEN
                CALL FMBER2(NBOT,MXY(2),MXY(4))
            ELSE
                CALL FMMPY(MBERN(NBOT/2),MXY(2),MXY(4))
            ENDIF
            NDIG = NDSAV1
            CALL FMADD_R1(MXY(3),MXY(4))
            NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(3))+2)-MWK(START(MXY(4))+2)))
         ENDDO

         NDIG = NDSAV1
         IF (MOD(J,6) == 4) THEN
             CALL FMI2M(NTOP,MXY(1))
             CALL FMDIVI(MXY(1),-6,MXY(4))
             CALL FMSUB_R2(MXY(4),MXY(3))
         ELSE
             CALL FMI2M(NTOP,MXY(1))
             CALL FMDIVI(MXY(1),3,MXY(4))
             CALL FMSUB_R2(MXY(4),MXY(3))
         ENDIF

         J2 = J/2
         NUMBRN = J
         MBSBRN = MBASE

         CALL FMMPYI_R1(MXY(3),6)
         NTN = NTOP*(NTOP-1)
         LARGE = INT(INTMAX/NTOP)
         IF (NTN > MXBASE .OR. NTOP > LARGE) THEN
             CALL FMDIVI_R1(MXY(3),NTOP)
             NTN = NTOP - 1
             CALL FMDIVI_R1(MXY(3),NTN)
             NTN = NTOP - 2
             CALL FMDIVI(MXY(3),NTN,MBERN(J2))
         ELSE IF (NTN*(NTOP-2) > MXBASE .OR. NTN > LARGE) THEN
             CALL FMDIVI_R1(MXY(3),NTN)
             NTN = NTOP - 2
             CALL FMDIVI(MXY(3),NTN,MBERN(J2))
         ELSE
             NTN = NTN*(NTOP-2)
             CALL FMDIVI(MXY(3),NTN,MBERN(J2))
         ENDIF
         NDBERN(J2) = NDIG
      ENDDO

      CALL FMMPY(MBERN(N2),MXY(5),MXY(4))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(4))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(4))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(4))+J+1)) GO TO 140
              ENDDO
              GO TO 150
          ENDIF
  140     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(4))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(5),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(4),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  150 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(4))+1) = MIN(MWK(START(MXY(4))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(4),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBERN

      SUBROUTINE FMBER2(N,MA,MB)

!  Internal routine for small Bernoulli numbers.

!  MB = MA*B(N) for N an even integer between 2 and 26.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA,MB
      INTEGER :: N2
      INTEGER :: NBTOP(13) = (/  &
              1,   1,  1,   1,  5, -691, 7, -3617, 43867, -174611, 854513, -236364091, 8553103 /)
      INTEGER :: NBBOT(13) = (/  &
              6, -30, 42, -30, 66, 2730, 6,   510,   798,     330,    138,       2730,       6 /)
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (N <= 0) THEN
          CALL FMEQ(MA,MB)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ELSE IF (N == 1) THEN
          CALL FMDIVI(MA,-2,MB)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ELSE IF (MOD(N,2) == 1) THEN
          CALL FMI2M(0,MB)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      N2 = N/2

      IF (N <= 26) THEN
          IF (NBTOP(N2) == 1) THEN
              CALL FMDIVI(MA,NBBOT(N2),MB)
          ELSE
              CALL FMMPYI(MA,NBTOP(N2),MB)
              CALL FMDIVI_R1(MB,NBBOT(N2))
          ENDIF
      ENDIF
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBER2

      SUBROUTINE FMBETA(MA,MB,MC)

!  MC = beta(MA,MB).  beta(MA,MB) = gamma(MA) * gamma(MB) / gamma(MA+MB)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MXSAVE,MZERO
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,JR,K,K10,K11,KASAVE,KB,KC,KFLKB,KFLNKB,KL,KOVUN,KR_RETRY,KRESLT,  &
                 KWRNSV,N,NB,NBOT,NDGOAL,NDOLD,NDSAVE,NGOAL,NK,NKB,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: X
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(22),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. (MWK(START(MA)+2) < -NDIG .OR. MWK(START(MB)+2) < -NDIG) .AND.  &
          MWK(START(MA)+2) > (-MXEXP) .AND. MWK(START(MB)+2) > (-MXEXP)              .AND.  &
          MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          NDSAVE = NDIG
          NDIG = 2*NDIG + NGRD52
          IF (MWK(START(MA)+2) <= MWK(START(MB)+2)) THEN
              CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
              CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          ELSE
              CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
              CALL FMEQU(MB,MXY(1),NDSAVE,NDIG)
          ENDIF
          CALL FMABS(MXY(1),MXY(3))
          CALL FMABS(MXY(2),MXY(4))
          CALL FMADD(MXY(3),MXY(4),MXY(7))
          CALL FMSQR(MXY(7),MXY(3))
          IF (MWK(START(MXY(3))+2) <= MWK(START(MXY(7))+2) - NDSAVE) THEN
              CALL FMI2M(1,MXY(3))
              CALL FMDIV(MXY(3),MXY(1),MXY(4))
              CALL FMDIV(MXY(3),MXY(2),MXY(6))
              IF (MWK(START(MXY(4))+2) < MEXPOV) THEN
                  CALL FMADD(MXY(1),MXY(2),MXY(7))
                  CALL FMPI(MXY(8))
                  CALL FMSQR_R1(MXY(8))
                  CALL FMMPY(MXY(7),MXY(8),MXY(9))
                  CALL FMDIVI_R1(MXY(9),6)
                  CALL FMSUB(MXY(6),MXY(9),MXY(10))
                  CALL FMADD_R2(MXY(4),MXY(10))
                  CALL FMEQU(MXY(10),MC,NDIG,NDSAVE)
                  KFLAG = 0
                  NTRACE = J
                  KWARN = K
                  NDIG = NDSAVE
                  IF (MWK(START(MC)+2) < (-MXEXP) .OR. MWK(START(MC)+2) > MXEXP+1) GO TO 110
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(2,MA,MB,2,1)
                      NCALL = NCALL - 1
                  ENDIF
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(1,MC,MC,1,1)
                      NCALL = NCALL - 1
                  ENDIF
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ELSE
              CALL FMI2M(1,MXY(3))
              CALL FMSUB(MXY(2),MXY(3),MXY(4))
              IF (MWK(START(MXY(4))+3) == 0) THEN
                  NDIG = NDSAVE
                  CALL FMDIV(MXY(3),MXY(1),MC)
                  KFLAG = 0
                  NTRACE = J
                  KWARN = K
                  IF (MWK(START(MC)+2) < (-MXEXP) .OR. MWK(START(MC)+2) > MXEXP+1) GO TO 110
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(2,MA,MB,2,1)
                      NCALL = NCALL - 1
                  ENDIF
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(1,MC,MC,1,1)
                      NCALL = NCALL - 1
                  ENDIF
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ELSE
                  CALL FMDIV(MXY(3),MXY(1),MXY(4))
                  CALL FMEULR(MXY(5))
                  CALL FMPSI(MXY(2),MXY(6))
                  CALL FMADD(MXY(5),MXY(6),MXY(7))
                  CALL FMSUB(MXY(4),MXY(7),MXY(8))
                  CALL FMEQU(MXY(8),MC,NDIG,NDSAVE)
                  KFLAG = 0
                  NTRACE = J
                  KWARN = K
                  NDIG = NDSAVE
                  IF (MWK(START(MC)+2) < (-MXEXP) .OR. MWK(START(MC)+2) > MXEXP+1) GO TO 110
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(2,MA,MB,2,1)
                      NCALL = NCALL - 1
                  ENDIF
                  IF (NTRACE /= 0) THEN
                      NCALL = NCALL + 1
                      NAMEST(NCALL) = 'FMBETA'
                      CALL FMNTR(1,MC,MC,1,1)
                      NCALL = NCALL - 1
                  ENDIF
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MC) == -1) TEMPV(MC) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
      ENDIF

  110 CALL FMENT2('FMBETA   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0

  120 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQ(MXY(1),MXY(21))
      NUMTRY = 0

  130 JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(1),MXY(2),MXY(17))
      KROUND = JR
      IF (MWK(START(MXY(1))+3) == 0 .OR. MWK(START(MXY(2))+3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(22))
          KFLAG = -4
          GO TO 160
      ENDIF

!             See if any of the terms are negative integers.

      CALL FMINT(MXY(1),MXY(8))
      IF (MWK(START(MXY(1))) < 0) THEN
          IF (FMCOMP(MXY(1),'==',MXY(8))) THEN
              CALL FMST2M('UNKNOWN',MXY(22))
              KFLAG = -4
              GO TO 160
          ENDIF
      ENDIF
      CALL FMINT(MXY(2),MXY(9))
      IF (MWK(START(MXY(2))) < 0) THEN
          IF (FMCOMP(MXY(2),'==',MXY(9))) THEN
              CALL FMST2M('UNKNOWN',MXY(22))
              KFLAG = -4
              GO TO 160
          ENDIF
      ENDIF
      IF (FMCOMP(MXY(17),'==',MXY(1))) THEN
          IF (MWK(START(MXY(2))+2) > MEXPAB) THEN
              CALL FMABS(MXY(2),MXY(13))
              CALL FMDPM(DLOGMB,MXY(6))
              CALL FMMPY_R2(MXY(6),MXY(13))
              J = (MWK(START(MXY(1))+2)+1)
              CALL FMMPYI_R1(MXY(13),J)
          ELSE
              CALL FMABS(MXY(2),MXY(13))
          ENDIF
          CALL FMI2M(1,MXY(6))
          CALL FMULP(MXY(6),MXY(7))
          IF (FMCOMP(MXY(13),'<=',MXY(7))) THEN
              CALL FMGAM(MXY(2),MXY(22))
              GO TO 160
          ENDIF
      ENDIF
      IF (FMCOMP(MXY(17),'==',MXY(2))) THEN
          IF (MWK(START(MXY(1))+2) > MEXPAB) THEN
              CALL FMABS(MXY(1),MXY(13))
              CALL FMDPM(DLOGMB,MXY(6))
              CALL FMMPY_R2(MXY(6),MXY(13))
              J = (MWK(START(MXY(2))+2)+1)
              CALL FMMPYI_R1(MXY(13),J)
          ELSE
              CALL FMABS(MXY(1),MXY(13))
          ENDIF
          CALL FMI2M(1,MXY(6))
          CALL FMULP(MXY(6),MXY(7))
          IF (FMCOMP(MXY(13),'<=',MXY(7))) THEN
              CALL FMGAM(MXY(1),MXY(22))
              GO TO 160
          ENDIF
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          IF (MWK(START(MXY(1)))*MWK(START(MXY(1))+3) > 0 .AND. MWK(START(MXY(2))) > 0 .AND.  &
              MWK(START(MXY(2))+2) >= 1) THEN
              CALL FMST2M('UNDERFLOW',MXY(22))
              KFLAG = -6
              GO TO 160
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))+2) == MEXPOV) THEN
          IF (MWK(START(MXY(2)))*MWK(START(MXY(2))+3) > 0 .AND. MWK(START(MXY(1))) > 0 .AND.  &
              MWK(START(MXY(1))+2) >= 1) THEN
              CALL FMST2M('UNDERFLOW',MXY(22))
              KFLAG = -6
              GO TO 160
          ENDIF
      ENDIF
      IF (MWK(START(MXY(17))+3) == 0) THEN
          CALL FMI2M(0,MXY(22))
          GO TO 140
      ELSE IF (MWK(START(MXY(17))) < 0) THEN
          CALL FMSUB(MXY(1),MXY(8),MXY(6))
          CALL FMSUB(MXY(2),MXY(9),MXY(13))
          CALL FMADD_R2(MXY(6),MXY(13))
          CALL FMINT(MXY(13),MXY(14))
          IF (FMCOMP(MXY(13),'==',MXY(14))) THEN
              CALL FMI2M(0,MXY(22))
              GO TO 140
          ENDIF
      ENDIF

!             See if any of the terms are small integers.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(1),N)
      KFLKB = KFLAG
      CALL FMM2I(MXY(2),K)
      KFLNKB = KFLAG
      CALL FMM2I(MXY(17),NK)
      KWARN = KWRNSV
      NB = N + K - 2
      KB = N - 1
      NKB = K - 1

      IF (KFLKB == 0 .AND. KFLNKB == 0) THEN
          IF (MIN(KB,NKB) <= 200) THEN
              CALL FMCMBI(NB,KB,MXY(22))
              CALL FMI2M(N+K-1,MXY(8))
              CALL FMMPY_R1(MXY(22),MXY(8))
              CALL FMI2M(1,MXY(6))
              CALL FMDIV_R2(MXY(6),MXY(22))
              GO TO 140
          ENDIF
      ENDIF
      NBOT = 0
      IF (KFLKB == 0 .AND. N <= 200) THEN
          CALL FMEQ(MXY(2),MXY(20))
          CALL FMPOCH(MXY(20),N,MXY(5))
          CALL FMFCTI(KB,MXY(11))
          CALL FMDIV(MXY(11),MXY(5),MXY(21))
          IF (ABS(MWK(START(MXY(21))+2)) < MXSAVE) THEN
              CALL FMEQ(MXY(21),MXY(22))
              GO TO 160
          ENDIF
          NBOT = 1
      ELSE IF (KFLNKB == 0 .AND. K <= 200) THEN
          CALL FMEQ(MXY(1),MXY(20))
          CALL FMPOCH(MXY(20),K,MXY(5))
          CALL FMFCTI(NKB,MXY(11))
          CALL FMDIV(MXY(11),MXY(5),MXY(21))
          IF (ABS(MWK(START(MXY(21))+2)) < MXSAVE) THEN
              CALL FMEQ(MXY(21),MXY(22))
              GO TO 160
          ENDIF
          NBOT = 1
      ENDIF
      IF (NBOT == 1) THEN
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
          CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
          CALL FMEQ(MXY(1),MXY(21))
          CALL FMADD(MXY(1),MXY(2),MXY(17))
      ENDIF

!             General case.  Use FMGAM, unless one of the numbers is too big.  If so, use FMLNGM.

      X = ALOGMB*REAL(MXEXP)
      CALL FMSP2M(X/LOG(X),MXY(7))
      CALL FMABS(MXY(17),MXY(18))
      CALL FMABS(MXY(1),MXY(19))
      CALL FMABS(MXY(2),MXY(3))
      IF (FMCOMP(MXY(18),'>=',MXY(7)) .OR. FMCOMP(MXY(19),'>=',MXY(7)) .OR.  &
          FMCOMP(MXY(3),'>=',MXY(7))) THEN

!             See if one argument is not very large and the other is
!             much larger.  For many of these cases, Stirling's formula
!             can be used to simplify Beta and avoid cancellation.

          IF (MWK(START(MXY(1))+2) > MWK(START(MXY(2))+2)) THEN
              CALL FMEQ(MXY(1),MXY(10))
              CALL FMEQ(MXY(2),MXY(11))
          ELSE
              CALL FMEQ(MXY(2),MXY(10))
              CALL FMEQ(MXY(1),MXY(11))
          ENDIF
          IF (MWK(START(MXY(10))+2) > NDIG .AND.  &
              MWK(START(MXY(10))+2) >= MWK(START(MXY(11))+2)+NDIG) THEN
              IF (MWK(START(MXY(11))) < 0) THEN
                  IF (MWK(START(MXY(11))+2) > NDIG) THEN
                      KFLAG = -9
                      CALL FMWRN2
                      NDIG = NDIG - IEXTRA
                      CALL FMST2M('UNKNOWN',MXY(22))
                      GO TO 160
                  ELSE
                      CALL FMI2M(2,MXY(18))
                      CALL FMEQ(MXY(11),MXY(19))
                      MWK(START(MXY(19))) = -MWK(START(MXY(19)))
                      CALL FMINT(MXY(19),MXY(6))
                      CALL FMMOD(MXY(6),MXY(18),MXY(12))
                      IF (MWK(START(MXY(12))+3) == 0) THEN
                          CALL FMADD(MXY(10),MXY(11),MXY(16))
                          CALL FMLN(MXY(16),MXY(6))
                          CALL FMMPY(MXY(11),MXY(6),MXY(16))
                          CALL FMI2M(1,MXY(6))
                          CALL FMADD(MXY(11),MXY(6),MXY(17))
                          CALL FMEQ(MXY(11),MXY(20))
                          CALL FMLNGM(MXY(17),MXY(4))
                          CALL FMSUB(MXY(4),MXY(16),MXY(6))
                          CALL FMEXP(MXY(6),MXY(13))
                          CALL FMDIV_R1(MXY(13),MXY(20))
                          CALL FMEQ(MXY(13),MXY(22))
                          GO TO 140
                      ENDIF
                  ENDIF
              ENDIF
              CALL FMADD(MXY(10),MXY(11),MXY(16))
              CALL FMLN(MXY(16),MXY(6))
              CALL FMMPY(MXY(11),MXY(6),MXY(16))
              CALL FMEQ(MXY(11),MXY(20))
              CALL FMLNGM(MXY(20),MXY(17))
              CALL FMSUB(MXY(17),MXY(16),MXY(6))
              CALL FMEXP(MXY(6),MXY(13))
              CALL FMEQ(MXY(13),MXY(22))
              GO TO 140
          ENDIF

!             See if both arguments are large.  For many of these cases, Stirling's formula can be
!             used to detect cases where the result will underflow.

          CALL FMDPM(1.0D7,MXY(6))
          IF (FMCOMP(MXY(1),'>',MXY(6)) .AND. FMCOMP(MXY(2),'>',MXY(6))) THEN
              CALL FMADD(MXY(1),MXY(2),MXY(6))
              CALL FMLN(MXY(6),MXY(15))
              CALL FMMPY_R2(MXY(6),MXY(15))
              IF (MWK(START(MXY(15))+2) /= MUNKNO .AND. MWK(START(MXY(15))+3) /= 0)  &
                  MWK(START(MXY(15))) = -MWK(START(MXY(15)))
              CALL FMLN(MXY(1),MXY(6))
              CALL FMMPY_R2(MXY(1),MXY(6))
              CALL FMADD_R1(MXY(15),MXY(6))
              CALL FMLN(MXY(2),MXY(6))
              CALL FMMPY_R2(MXY(2),MXY(6))
              CALL FMADD_R1(MXY(15),MXY(6))
              CALL FMEXP(MXY(15),MXY(16))
              IF (MWK(START(MXY(16))+2) == MEXPUN) THEN
                  CALL FMEQ(MXY(16),MXY(22))
                  GO TO 160
              ENDIF
          ENDIF

!             Compute IEXTRA, the number of extra digits required to compensate for
!             cancellation error.

          MZERO = 0
          IEXTRA = INT(MAX(MWK(START(MXY(17))+2),MWK(START(MXY(1))+2),MWK(START(MXY(2))+2),MZERO))
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA
          CALL FMADD(MXY(1),MXY(2),MXY(17))
          CALL FMI2M(1,MXY(10))
          CALL FMI2M(2,MXY(11))
          CALL FMEQ(MXY(17),MXY(22))
          K10 = 0
          K11 = 0
          KC = 0
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMINT(MXY(1),MXY(12))
              CALL FMMOD(MXY(12),MXY(11),MXY(13))
              IF (MWK(START(MXY(13))+3) == 0) THEN
                  K10 = 1
                  CALL FMADD_R1(MXY(1),MXY(10))
              ENDIF
          ENDIF
          IF (MWK(START(MXY(2))) < 0) THEN
              CALL FMINT(MXY(2),MXY(12))
              CALL FMMOD(MXY(12),MXY(11),MXY(13))
              IF (MWK(START(MXY(13))+3) == 0) THEN
                  K11 = 1
                  CALL FMADD_R1(MXY(2),MXY(10))
              ENDIF
          ENDIF
          IF (MWK(START(MXY(22))) < 0) THEN
              CALL FMINT(MXY(22),MXY(12))
              CALL FMMOD(MXY(12),MXY(11),MXY(13))
              IF (MWK(START(MXY(13))+3) == 0) THEN
                  KC = 1
                  CALL FMADD_R1(MXY(22),MXY(10))
              ENDIF
          ENDIF
          CALL FMLNGM(MXY(1),MXY(17))
          CALL FMLNGM(MXY(2),MXY(20))
          CALL FMADD_R1(MXY(17),MXY(20))
          CALL FMLNGM(MXY(22),MXY(20))
          CALL FMSUB(MXY(17),MXY(20),MXY(6))
          CALL FMEXP(MXY(6),MXY(17))
          IF (K10 == 1 .OR. K11 == 1 .OR. KC == 1) THEN
              CALL FMI2M(1,MXY(10))
              IF (K10 == 1) THEN
                  CALL FMSUB_R1(MXY(1),MXY(10))
                  CALL FMDIV_R1(MXY(17),MXY(1))
              ENDIF
              IF (K11 == 1) THEN
                  CALL FMSUB_R1(MXY(2),MXY(10))
                  CALL FMDIV_R1(MXY(17),MXY(2))
              ENDIF
              IF (KC == 1) THEN
                  CALL FMSUB_R1(MXY(22),MXY(10))
                  CALL FMMPY_R1(MXY(17),MXY(22))
              ENDIF
          ENDIF
          CALL FMEQ(MXY(17),MXY(22))
      ELSE
          CALL FMGAM(MXY(1),MXY(20))
          CALL FMGAM(MXY(2),MXY(1))
          CALL FMGAM(MXY(17),MXY(22))
          CALL FMMPY(MXY(20),MXY(1),MXY(8))
          CALL FMDIV_R2(MXY(8),MXY(22))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  140 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(22))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(22))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(22))+J+1)) GO TO 150
              ENDDO
              GO TO 160
          ENDIF
  150     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(22))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(22),MRETRY,NDOLD,NDIG)
          GO TO 130
      ENDIF

  160 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(22))+1) = MIN(MWK(START(MXY(22))+1),MACCA,MACCB,MACMAX)
      CALL FMEXT2(MXY(22),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBETA

      SUBROUTINE FMCMBI(N,K,MA)

!  Internal routine for computing binomial coefficients for integers.

!  MA = N choose K.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N,K
      INTEGER :: MA

      INTEGER :: INTNDG,J,KSTART,KT,L,LARGE,LARGED,NDIV,NDSAVE,NEXTD,NEXTN,NMPY,NTD,NTN
      INTENT (IN) :: N,K
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MBLOGS /= MBASE) CALL FMCONS
      L = MIN(K,N-K)
      IF (L <= 0) THEN
          CALL FMI2M(1,MA)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      IF (L <= 1) THEN
          CALL FMI2M(N,MA)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

!             Find the largest value for N choose J using integers.

      NTN = N
      NTD = 1
      LARGE = INT(INTMAX/N)
      DO J = 2, L
         IF (NTN <= LARGE) THEN
             NTN = (NTN*((N+1)-J))/J
         ELSE
             CALL FMI2M(NTN,MA)
             NTN = (N+1) - J
             NTD = J
             GO TO 110
         ENDIF
      ENDDO

  110 IF (NTD == 1) THEN
          CALL FMI2M(NTN,MA)
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      INTNDG = INT(ALOGMX/ALOGMB + 1.0)
      NEXTN = NTN
      NEXTD = NTD
      KSTART = NTD + 1
      NDSAVE = NDIG

!             Compute the rest of N choose K.

      LARGED = MIN(LARGE,INT(MXBASE))
      DO KT = KSTART, L
         NEXTN = NEXTN - 1
         NEXTD = NEXTD + 1
         IF (NTN >= LARGE .OR. NTD >= LARGED) THEN
             NDIG = MAX(2,MIN(NDSAVE,INT(MWK(START(MA)+2))+INTNDG))
             CALL FMMPYI_R1(MA,NTN)
             CALL FMDIVI_R1(MA,NTD)
             NTN = NEXTN
             NTD = NEXTD
             CYCLE
         ENDIF
         NMPY = NTN*NEXTN
         NDIV = NTD*NEXTD
         IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
             NTN = NMPY
             NTD = NDIV
         ELSE
             CALL FMGCDI(NMPY,NDIV)
             IF (NMPY <= LARGE .AND. NDIV <= LARGED) THEN
                 NTN = NMPY
                 NTD = NDIV
             ELSE
                 NDIG = MAX(2,MIN(NDSAVE,INT(MWK(START(MA)+2))+INTNDG))
                 CALL FMMPYI_R1(MA,NTN)
                 CALL FMDIVI_R1(MA,NTD)
                 NTN = NEXTN
                 NTD = NEXTD
             ENDIF
         ENDIF
      ENDDO
      NDIG = MAX(2,MIN(NDSAVE,INT(MWK(START(MA)+2))+INTNDG))
      CALL FMGCDI(NTN,NTD)
      CALL FMMPYI_R1(MA,NTN)
      CALL FMDIVI_R1(MA,NTD)
      NDIG = NDSAVE
      MWK(START(MA)+1) = NINT(ALOGM2*NDSAVE)

      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCMBI

      SUBROUTINE FMCOMB(MA,MB,MC)

!  MC = MA choose MB.  (Binomial coefficient -- uses gamma for non-integers)

!  MC = (MA)! / ( (MB)! * (MA-MB)! )

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MXSAVE,MZERO
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,JR,K,K09,K10,K11,KASAVE,KBOT,KC,KFLGK,KFLGN,KFLGNK,KL,KOVUN,KR_RETRY,  &
                 KRESLT,KSIGN,KWRNSV,LARGE,N,NBOT,NDGOAL,NDOLD,NDSAVE,NGOAL,NK,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      LOGICAL :: LC1,LC2,LC3
      REAL :: X
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(17),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K = 0
      IF (MWK(START(MA)) < 0) THEN
          K10 = NTRACE
          NTRACE = 0
          K11 = KWARN
          KWARN = 0
          CALL FMM2I(MA,J)
          IF (KFLAG == 0) K = 1
          NTRACE = K10
          KWARN = K11
      ENDIF

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MB)+2) < -NDIG .AND. K == 0) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOMB'
              CALL FMNTR(2,MA,MB,2,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMTINY(MXY(1))
              MWK(START(MXY(1))) = MWK(START(MA))
          ELSE
              CALL FMEQ(MA,MXY(1))
          ENDIF
          IF (MWK(START(MB)+2) == MEXPUN) THEN
              CALL FMTINY(MXY(2))
              MWK(START(MXY(2))) = MWK(START(MB))
          ELSE
              CALL FMEQ(MB,MXY(2))
          ENDIF
          CALL FMSUB(MXY(1),MXY(2),MXY(3))
          IF (MWK(START(MXY(3))+3) /= 0) THEN
              CALL FMPI(MXY(4))
              CALL FMSQR(MXY(4),MXY(5))
              CALL FMDIVI(MXY(5),6,MXY(4))
              CALL FMI2M(1,MXY(6))
              CALL FMPGAM(2,MXY(6),MXY(5))
              CALL FMMPY_R1(MXY(5),MXY(1))
              CALL FMDIVI_R1(MXY(5),2)
              CALL FMADD_R1(MXY(4),MXY(5))
              CALL FMMPY_R1(MXY(3),MXY(4))
              CALL FMMPY_R1(MXY(3),MXY(2))
              CALL FMADD_R2(MXY(6),MXY(3))
          ELSE
              CALL FMI2M(1,MXY(3))
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          CALL FMEQ(MXY(3),MC)
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMCOMB'
              CALL FMNTR(1,MC,MC,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      CALL FMENT2('FMCOMB   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KSIGN = 1
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

  120 CALL FMSUB(MXY(1),MXY(2),MXY(15))
      IF (MWK(START(MXY(2))+3) == 0) THEN
          CALL FMI2M(1,MXY(17))
          GO TO 130
      ENDIF
      CALL FMI2M(1,MXY(3))
      CALL FMSUB(MXY(2),MXY(3),MXY(4))
      IF (MWK(START(MXY(4))+3) == 0) THEN
          CALL FMEQ(MXY(1),MXY(17))
          GO TO 130
      ENDIF

!             See if any of the terms are negative integers.

      CALL FMI2M(1,MXY(11))
      K10 = 0
      IF (MWK(START(MXY(1))) < 0) THEN
          CALL FMINT(MXY(1),MXY(7))
          IF (FMCOMP(MXY(1),'==',MXY(7))) K10 = -1
          IF (MWK(START(MA)+2) == MEXPOV)  K10 = -1
      ENDIF
      K11 = 0
      IF (MWK(START(MXY(2))) < 0) THEN
          CALL FMINT(MXY(2),MXY(8))
          IF (FMCOMP(MXY(2),'==',MXY(8))) K11 = -1
          IF (MWK(START(MB)+2) == MEXPOV)  K11 = -1
      ENDIF
      K09 = 0
      IF (FMCOMP(MXY(1),'<',MXY(2))) THEN
          CALL FMMOD(MXY(1),MXY(11),MXY(9))
          CALL FMMOD(MXY(2),MXY(11),MXY(10))
          CALL FMSUB_R2(MXY(9),MXY(10))
          CALL FMINT(MXY(10),MXY(9))
          IF (FMCOMP(MXY(10),'==',MXY(9))) K09 = -1
      ENDIF

      CALL FMI2M(2,MXY(10))

      IF (K11 == -1) THEN
          CALL FMI2M(0,MXY(17))
          GO TO 130
      ELSE IF (MWK(START(MXY(15))+3) == 0) THEN
          CALL FMI2M(1,MXY(17))
          GO TO 130
      ELSE IF (K09 == -1 .AND. K10 == 0) THEN
          CALL FMI2M(0,MXY(17))
          GO TO 130
      ELSE IF (K10 == -1 .AND. K09 == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(17))
          KFLAG = -4
          GO TO 150
      ELSE IF (K10 == -1 .AND. K09 == -1) THEN
          JR = KROUND
          KROUND = 1
          CALL FMMOD(MXY(2),MXY(10),MXY(12))
          IF (MWK(START(MXY(12))+3) /= 0) KSIGN = -1
          CALL FMSUB(MXY(2),MXY(1),MXY(12))
          CALL FMSUB(MXY(12),MXY(11),MXY(1))
          CALL FMSUB(MXY(1),MXY(2),MXY(15))
          KROUND = JR
      ENDIF

!             Check for an obviously overflowed result.

      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          IF (MWK(START(MXY(1)))*MWK(START(MXY(1))+3) > 0 .AND. MWK(START(MXY(2))) > 0 .AND.  &
              MWK(START(MXY(2))+2) >= 1 .AND. MWK(START(MXY(2))+2) < MEXPOV) THEN
              CALL FMST2M('OVERFLOW',MXY(17))
              KFLAG = -5
              GO TO 150
          ENDIF
      ENDIF
      IF (MWK(START(MXY(1))+2) >= 10000) THEN
          CALL FMI2M(1,MXY(5))
          IF (FMCOMP(MXY(2),'>',MXY(5)) .AND. FMCOMP(MXY(2),'<',MXY(1))) THEN
              CALL FMSUB(MXY(1),MXY(2),MXY(5))
              CALL FMMIN(MXY(2),MXY(5),MXY(13))
              CALL FMSUB(MXY(1),MXY(13),MXY(5))
              CALL FMADDI(MXY(5),1)
              CALL FMDIV(MXY(5),MXY(13),MXY(12))
              CALL FMLN(MXY(12),MXY(5))
              CALL FMADDI(MXY(5),1)
              CALL FMMPY(MXY(13),MXY(5),MXY(12))
              CALL FMDPM(6.283185D0,MXY(3))
              CALL FMMPY(MXY(3),MXY(13),MXY(5))
              CALL FMLN(MXY(5),MXY(3))
              CALL FMDIVI(MXY(3),2,MXY(5))
              CALL FMSUB_R1(MXY(12),MXY(5))
              CALL FMEXP(MXY(12),MXY(4))
              IF (MWK(START(MXY(4))+2) == MEXPOV) THEN
                  CALL FMST2M('OVERFLOW',MXY(17))
                  KFLAG = -5
                  GO TO 150
              ENDIF
          ENDIF
      ENDIF

!             See if any of the terms are small integers.

      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(1),N)
      CALL FMM2I(MXY(2),K)
      KFLGK = KFLAG
      CALL FMM2I(MXY(15),NK)
      KFLGNK = KFLAG
      KWARN = KWRNSV

      CALL FMI2M(1,MXY(5))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(1),MXY(5),MXY(3))
      CALL FMSUB_R1(MXY(3),MXY(5))
      KROUND = JR
      IF (KFLGK == 0 .AND. MWK(START(MXY(3))+3) == 0) THEN
          CALL FMI2M(2,MXY(17))
          CALL FMMOD(MXY(2),MXY(17),MXY(5))
          CALL FMEQ(MXY(5),MXY(17))
          IF (MWK(START(MXY(17))+3) == 0) THEN
              CALL FMDIV(MXY(1),MXY(2),MXY(17))
              IF (MWK(START(MXY(17))+2) /= MUNKNO .AND. MWK(START(MXY(17))+3) /= 0)  &
                  MWK(START(MXY(17))) = -MWK(START(MXY(17)))
          ELSE
              CALL FMDIV(MXY(1),MXY(2),MXY(17))
          ENDIF
          GO TO 130
      ENDIF
      IF (KFLGK == 0 .AND. KFLGNK == 0 .AND. N /= 0) THEN
          IF (MIN(K,NK) <= 200) THEN
              CALL FMCMBI(N,K,MXY(17))
              GO TO 130
          ENDIF
      ENDIF
      NBOT = 0
      IF (KFLGK == 0 .AND. K <= 200) NBOT = K
      IF (KFLGNK == 0 .AND. NK <= 200) NBOT = NK
      IF (NBOT > 0) THEN
          LARGE = INT(MXBASE/NBOT)
          KBOT = 1
          CALL FMEQ(MXY(1),MXY(7))
          CALL FMEQ(MXY(1),MXY(8))
          CALL FMI2M(-1,MXY(9))
          DO J = 2, NBOT
             CALL FMADD_R1(MXY(7),MXY(9))
             CALL FMMPY_R2(MXY(7),MXY(8))
             KBOT = KBOT*J
             IF (KBOT >= LARGE) THEN
                 CALL FMDIVI_R1(MXY(8),KBOT)
                 KBOT = 1
             ENDIF
          ENDDO
          CALL FMDIVI(MXY(8),KBOT,MXY(17))
          GO TO 130
      ENDIF

!             General case.  Use FMFACT, unless one of the numbers is too big.  If so, use FMLNGM.

      X = ALOGMB*REAL(MXEXP)
      CALL FMSP2M(X/LOG(X),MXY(6))
      CALL FMABS(MXY(15),MXY(5))
      LC1 = FMCOMP(MXY(5),'>=',MXY(6))
      CALL FMABS(MXY(1),MXY(5))
      LC2 = FMCOMP(MXY(5),'>=',MXY(6))
      CALL FMABS(MXY(2),MXY(5))
      LC3 = FMCOMP(MXY(5),'>=',MXY(6))
      IF (LC1 .OR. LC2 .OR. LC3) THEN

!             See if the second argument is not very large and the first is much larger.
!             For many of these cases, Stirling's formula can be used to simplify Comb
!             and avoid cancellation.

          IF (MWK(START(MXY(1))+2) > MWK(START(MXY(2))+2) .AND. MWK(START(MXY(1))) > 0 .AND.  &
              MWK(START(MXY(2))) > 0) THEN
              CALL FMEQ(MXY(1),MXY(9))
              CALL FMEQ(MXY(2),MXY(10))
          ELSE
              CALL FMI2M(1,MXY(9))
              CALL FMI2M(1,MXY(10))
          ENDIF
          IF (MWK(START(MXY(9))+2) > NDIG .AND.  &
              MWK(START(MXY(9))+2) >= MWK(START(MXY(10))+2)+NDIG) THEN
              CALL FMI2M(1,MXY(5))
              CALL FMADD(MXY(10),MXY(5),MXY(16))
              CALL FMLN(MXY(9),MXY(5))
              CALL FMADDI(MXY(5),-1)
              CALL FMMPY(MXY(10),MXY(5),MXY(14))
              CALL FMADD_R2(MXY(10),MXY(14))
              CALL FMLNGM(MXY(16),MXY(15))
              CALL FMSUB(MXY(14),MXY(15),MXY(5))
              CALL FMEXP(MXY(5),MXY(12))
              CALL FMEQ(MXY(12),MXY(17))
              GO TO 130
          ENDIF

!             Compute IEXTRA, the number of extra digits required to compensate for
!             cancellation error.

          MZERO = 0
          IEXTRA = INT(MAX(MWK(START(MXY(15))+2),MWK(START(MXY(1))+2),MWK(START(MXY(2))+2),MZERO))
          IF (NDIG+IEXTRA > 3*10**5) THEN
              KFLAG = -4
              CALL FMST2M('UNKNOWN',MXY(17))
              GO TO 150
          ENDIF
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA
          KFLGN = 1
          IF (K10 == -1 .AND. K09 == -1) THEN
              JR = KROUND
              KROUND = 1
              CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
              CALL FMM2I(MXY(1),N)
              KFLGN = KFLAG
              CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
              CALL FMSUB(MXY(2),MXY(1),MXY(12))
              CALL FMI2M(1,MXY(11))
              CALL FMSUB(MXY(12),MXY(11),MXY(1))
              KROUND = JR
          ENDIF

          CALL FMSUB(MXY(1),MXY(2),MXY(15))
          IF (KFLGN == 0 .AND. N == -1) MWK(START(MXY(15))+1) = MWK(START(MXY(1))+1)
          CALL FMI2M(1,MXY(9))
          CALL FMI2M(2,MXY(10))
          CALL FMADD(MXY(15),MXY(9),MXY(17))
          CALL FMADD_R1(MXY(1),MXY(9))
          CALL FMADD_R1(MXY(2),MXY(9))
          K10 = 0
          K11 = 0
          KC = 0
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMINT(MXY(1),MXY(11))
              CALL FMMOD(MXY(11),MXY(10),MXY(12))
              IF (MWK(START(MXY(12))+3) == 0) THEN
                  K10 = 1
                  CALL FMADD_R1(MXY(1),MXY(9))
              ENDIF
          ENDIF
          IF (MWK(START(MXY(2))) < 0) THEN
              CALL FMINT(MXY(2),MXY(11))
              CALL FMMOD(MXY(11),MXY(10),MXY(12))
              IF (MWK(START(MXY(12))+3) == 0) THEN
                  K11 = 1
                  CALL FMADD_R1(MXY(2),MXY(9))
              ENDIF
          ENDIF
          IF (MWK(START(MXY(17))) < 0) THEN
              CALL FMINT(MXY(17),MXY(11))
              CALL FMMOD(MXY(11),MXY(10),MXY(12))
              IF (MWK(START(MXY(12))+3) == 0) THEN
                  KC = 1
                  CALL FMADD_R1(MXY(17),MXY(9))
              ENDIF
          ENDIF
          CALL FMLNGM(MXY(1),MXY(15))
          CALL FMLNGM(MXY(2),MXY(16))
          CALL FMSUB_R1(MXY(15),MXY(16))
          CALL FMLNGM(MXY(17),MXY(16))
          CALL FMSUB_R1(MXY(15),MXY(16))
          CALL FMEXP(MXY(15),MXY(4))
          IF (K10 == 1 .OR. K11 == 1 .OR. KC == 1) THEN
              CALL FMI2M(1,MXY(9))
              IF (K10 == 1) THEN
                  CALL FMSUB_R1(MXY(1),MXY(9))
                  CALL FMDIV_R1(MXY(4),MXY(1))
              ENDIF
              IF (K11 == 1) THEN
                  CALL FMSUB_R1(MXY(2),MXY(9))
                  CALL FMMPY_R1(MXY(4),MXY(2))
              ENDIF
              IF (KC == 1) THEN
                  CALL FMSUB_R1(MXY(17),MXY(9))
                  CALL FMMPY_R1(MXY(4),MXY(17))
              ENDIF
          ENDIF
          CALL FMEQ(MXY(4),MXY(17))
      ELSE
          CALL FMFACT(MXY(1),MXY(16))
          CALL FMFACT(MXY(2),MXY(3))
          CALL FMFACT(MXY(15),MXY(17))
          CALL FMMPY(MXY(17),MXY(3),MXY(7))
          CALL FMDIV(MXY(16),MXY(7),MXY(17))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  130 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(17))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(17))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(17))+J+1)) GO TO 140
              ENDDO
              GO TO 150
          ENDIF
  140     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(17))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(17),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  150 MWK(START(MXY(17))) = KSIGN*MWK(START(MXY(17)))
      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(17))+1) = MIN(MWK(START(MXY(17))+1),MACCA,MACCB,MACMAX)
      CALL FMEXT2(MXY(17),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCOMB

      FUNCTION FMDPLG(A)

!  Internal routine for computing an approximation to Log(Gamma(A)) using Stirling's formula.

      USE FMVALS
      IMPLICIT NONE

      DOUBLE PRECISION :: FMDPLG,A
      INTENT (IN) :: A

      IF (MBLOGS /= MBASE) CALL FMCONS
      IF (A > 0.0D0) THEN
          FMDPLG = -A + (A-0.5D0)*LOG(A) + DLOGTP/2.0D0
      ELSE IF (A < 0.0D0) THEN
          IF (ABS(A) < 1.0D+8) THEN
              FMDPLG = -(A-1.0D0) - (0.5D0-A)*LOG(1.0D0-A) - DLOGTP/2.0D0 -  &
                       LOG(ABS(SIN(DPPI*A))+1.0D-10) + DLOGPI
          ELSE
              FMDPLG = -(A-1.0D0) - (0.5D0-A)*LOG(1.0D0-A) - DLOGTP/2.0D0 + DLOGPI
          ENDIF
      ELSE

!             A = 0 is really an approximation for some value in [-1,1].

          FMDPLG = 0.0D0
      ENDIF
      RETURN
      END FUNCTION FMDPLG

      SUBROUTINE FMENT2(NROUTN,MA,MB,NARGS,KNAM,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Do the argument checking and increasing of precision, overflow threshold, etc., upon entry
!  to an FM routine.

!  NROUTN - routine name of calling routine
!  MA     - first input argument
!  MB     - second input argument (optional)
!  NARGS  - number of input arguments
!  KNAM   - positive if the routine name is to be printed.
!  MC     - result argument
!  KRESLT - returned nonzero if the input arguments give the result immediately
!           (e.g., MA*0 or OVERFLOW*MB)
!  NDSAVE - saves the value of NDIG after NDIG is increased
!  MXSAVE - saves the value of MXEXP
!  KASAVE - saves the value of KACCSW
!  KOVUN  - returned nonzero if an input argument is (+ or -) overflow or underflow.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NROUTN
      INTEGER :: MA,MB,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: KNAM,NARGS,KRESLT,NDSAVE,KASAVE,KOVUN
      INTEGER :: K
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC

      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NAMEST(NCALL) = NROUTN
      IF (NTRACE /= 0) CALL FMNTR(2,MA,MB,NARGS,KNAM)
      CALL FMARG2(NROUTN,NARGS,MA,MB,KRESLT)

      KOVUN = 0
      IF (MWK(START(MA)+2) == MEXPOV .OR. MWK(START(MA)+2) == MEXPUN) KOVUN = 1
      IF (NARGS == 2) THEN
          IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
      ENDIF

!             Increase the working precision.

      NDSAVE = NDIG
      MXSAVE = MXEXP
      KASAVE = KACCSW
      IF (NCALL == 1 .OR. RAISE_NDIG > 0) THEN
          K = INT(NGRD52 + 1 + (REAL(NDIG)*ALOGMT)**0.35/ALOGMT)
          NDIG = MAX(NDIG+K,2)
      ENDIF

      IF (KRESLT /= 0) THEN
          IF (KRESLT == 9 .OR. KRESLT == 10 .OR. KRESLT >= 13) THEN
              IF (KRAD == 1) THEN
                  CALL FMPI(MC)
              ELSE
                  CALL FMI2M(180,MC)
              ENDIF
              IF (KRESLT <= 10) CALL FMDIVI_R1(MC,2)
              IF (KRESLT >= 14) CALL FMDIVI_R1(MC,4)
              IF (KRESLT == 9 .OR. KRESLT == 14) MWK(START(MC)) = -1
              CALL FMEQU_R1(MC,NDIG,NDSAVE)
              NDIG = NDSAVE
              IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
              NCALL = NCALL - 1
              RETURN
          ENDIF

          NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT)
          IF (NTRACE /= 0 .AND. NROUTN /= 'FMIBTA') THEN
              CALL FMNTR(1,MC,MC,1,1)
          ENDIF
          NCALL = NCALL - 1
          RETURN
      ENDIF

!             Extend the overflow/underflow threshold.

      MXEXP = MXEXP2
      RETURN
      END SUBROUTINE FMENT2

      SUBROUTINE FMEULR(MA)

!  MA = Euler's constant ( 0.5772156649... )

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA
      CHARACTER(2315) :: STRING
      INTEGER :: K,KASAVE,NDMB,NDSAVE,NDSV
      INTEGER :: NUMBER_USED_SAVE
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      IF (MA <= 0) THEN
          CALL FMDEFINE(MA)
      ELSE IF (SIZE_OF(MA) < NDIG+3) THEN
          CALL FMDEFINE(MA)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (MBLOGS /= MBASE) CALL FMCONS
      KFLAG = 0
      NCALL = NCALL + 1
      NAMEST(NCALL) = 'FMEULR'
      IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
          WRITE (KW,"(' Input to FMEULR')")
      ENDIF
      KASAVE = KACCSW

!             Increase the working precision.

      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = INT(5.0/ALOGMT + 2.0 + (REAL(NDIG)*ALOGMT)**0.35/ALOGMT)
          NDIG = MAX(NDIG+K,2)
      ENDIF

!             Check to see if Euler's constant has previously been saved in base MBASE with
!             sufficient precision.

      IF (MBSEUL == MBASE .AND. NDGEUL >= NDIG) THEN
          CALL FMEQU(M_EULER,MA,NDGEUL,NDSAVE)
      ELSE

!             Euler's constant is slower to compute than the other saved constants, so more digits
!             are stored in STRING for quick conversion.

          NDMB = INT(2300.0*2.302585/ALOGMB)
          IF (NDMB >= NDIG) THEN
              NDSV = NDIG
              NDIG = NDMB
              STRING = '0.57721566490153286060651209008240243104215933593992359880576723488486'//  &
              '7726777664670936947063291746749514631447249807082480960504014486542836224173997'//  &
              '6449235362535003337429373377376739427925952582470949160087352039481656708532331'//  &
              '5177661152862119950150798479374508570574002992135478614669402960432542151905877'//  &
              '5535267331399254012967420513754139549111685102807984234877587205038431093997361'//  &
              '3725530608893312676001724795378367592713515772261027349291394079843010341777177'//  &
              '8088154957066107501016191663340152278935867965497252036212879226555953669628176'//  &
              '3887927268013243101047650596370394739495763890657296792960100901512519595092224'//  &
              '3501409349871228247949747195646976318506676129063811051824197444867836380861749'//  &
              '4551698927923018773910729457815543160050021828440960537724342032854783670151773'//  &
              '9439870030237033951832869000155819398804270741154222781971652301107356583396734'//  &
              '8717650491941812300040654693142999297779569303100503086303418569803231083691640'//  &
              '0258929708909854868257773642882539549258736295961332985747393023734388470703702'//  &
              '8441292016641785024873337908056275499843459076164316710314671072237002181074504'//  &
              '4418664759134803669025532458625442225345181387912434573501361297782278288148945'//  &
              '9098638460062931694718871495875254923664935204732436410972682761608775950880951'//  &
              '2620840454447799229915724829251625127842765965708321461029821461795195795909592'//  &
              '2704208989627971255363217948873764210660607065982561990102880756125199137511678'//  &
              '2176436190570584407835735015800560774579342131449885007864151716151945657061704'//  &
              '3245075008168705230789093704614306684817916496842549150496724312183783875356489'//  &
              '4950868454102340601622508515583867234944187880440940770106883795111307872023426'//  &
              '3952269209716088569083825113787128368204911789259447848619911852939102930990592'//  &
              '5526691727446892044386971114717457157457320393520912231608508682755889010945168'//  &
              '1181016874975470969366671210206304827165895049327314860874940207006742590918248'//  &
              '7596213738423114426531350292303175172257221628324883811245895743862398703757662'//  &
              '8551303314392999540185313414158621278864807611003015211965780068117773763501681'//  &
              '8389733896639868957932991456388644310370608078174489957958324579418962026049841'//  &
              '0439225078604603625277260229196829958609883390137871714226917883819529844560791'//  &
              '6051972797360475910251099577913351579177225150254929324632502874767794842158405'//  &
              '07599290401855764599018627262'
              CALL FMST2M(STRING,M_EULER)
              MWK(START(M_EULER)+1) = NINT(NDIG*ALOGM2)
              MBSEUL = MBASE
              NDGEUL = NDIG
              IF (ABS(MWK(START(M_EULER)+2)) > 10) NDGEUL = 0
              CALL FMEQU(M_EULER,MA,NDIG,NDSAVE)
              NDIG = NDSV
          ELSE
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMEULR_B(M_EULER)
              MWK(START(M_EULER)+1) = NINT(NDIG*ALOGM2)
              MBSEUL = MBASE
              NDGEUL = NDIG
              IF (ABS(MWK(START(M_EULER)+2)) > 10) NDGEUL = 0
              CALL FMEQU(M_EULER,MA,NDIG,NDSAVE)
              NDIG = NDSV
          ENDIF
      ENDIF

      NDIG = NDSAVE
      KACCSW = KASAVE
      IF (NTRACE /= 0) CALL FMNTR(1,MA,MA,1,1)
      NCALL = NCALL - 1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEULR

      SUBROUTINE FMEULR_B(MB)

!  MB = Euler's constant = .577215...

!  Binary splitting version.
!  Called by FMEULR for large NDIG.  Faster and saves memory by not using Bernoulli numbers.

!  Sum f(x) = 1 + x/(1!)^2 + x^2/(2!)^2 + ...
!  and g(x) = H(1)*x/(1!)^2 + H(2)*x^2/(2!)^2 + ...
!  where H(n) = 1 + 1/2 + ... + 1/n.

!  As x --> infinity, g(x)/f(x) - Ln(x)/2 --> Euler's constant.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MB
      REAL (KIND(1.0D0)) :: MD2B,MXSAVE
      INTEGER :: K,KASAVE,KT,N,NDSAVE
      INTENT (INOUT) :: MB
      INTEGER :: MXY(7),NUMBER_USED_SAVE,X

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      X = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      IF (MBLOGS /= MBASE) CALL FMCONS
      NCALL = NCALL + 1
      NDSAVE = NDIG
      IF (NCALL == 1) THEN
          K = MAX(NGRD52-1,2)
          NDIG = MAX(NDIG+K,2)
      ENDIF
      KASAVE = KACCSW
      KACCSW = 0
      MXSAVE = MXEXP
      MXEXP = MXEXP2

!             Determine X, variable in the series.

      N = NDIG*DLOGMB/4
      DO
         K = N
         DO
            KT = K/2
            IF (2*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         DO
            KT = K/3
            IF (3*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         DO
            KT = K/5
            IF (5*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         DO
            KT = K/7
            IF (7*KT == K) THEN
                K = KT
            ELSE
                EXIT
            ENDIF
         ENDDO
         IF (K == 1) EXIT
         N = N + 1
      ENDDO

      CALL IMI2M(N,MXY(1))
      CALL IMSQR(MXY(1),X)

!             Determine K, the number of terms to sum in the series.

      K = 3.5912D0*N
      CALL FMEULR_PTDCV(0,K,MXY(1),MXY(2),MXY(3),MXY(4),MXY(5),X)
      IF (MWK(START(MXY(3))+2) >= NDIG) THEN
          CALL FMEQ(MXY(3),MXY(7))
      ELSE
          CALL IMI2FM(MXY(3),MXY(7))
      ENDIF
      CALL FMSQR(MXY(7),MXY(4))
      IF (MWK(START(MXY(2))+2) >= NDIG) THEN
          CALL FMEQ(MXY(2),MXY(1))
      ELSE
          CALL IMI2FM(MXY(2),MXY(1))
      ENDIF
      CALL FMDIV(MXY(1),MXY(4),MXY(6))
      CALL FMADDI(MXY(6),1)

      CALL FMMPY(MXY(7),MXY(4),MXY(1))
      IF (MWK(START(MXY(5))+2) >= NDIG) THEN
          CALL FMEQ(MXY(5),MXY(4))
      ELSE
          CALL IMI2FM(MXY(5),MXY(4))
      ENDIF
      CALL FMDIV(MXY(4),MXY(1),MXY(2))

      CALL FMDIV(MXY(2),MXY(6),MXY(5))
      CALL FMLNI(N,MXY(1))
      CALL FMSUB(MXY(5),MXY(1),M_EULER)

!             Round the result and return.

      MD2B = NINT((NDSAVE-1)*ALOGM2+LOG(REAL(ABS(MWK(START(MXY(3))+3))+1))/0.69315)
      MWK(START(MXY(3))+1) = MD2B
      CALL FMEXIT(M_EULER,MB,NDSAVE,MXSAVE,KASAVE,0)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEULR_B

      RECURSIVE SUBROUTINE FMEULR_PTDCV(A,B,MP,MT,MD,MC,MV,MX)

!  This routine does the binary splitting for computing Euler's constant.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MP,MT,MD,MC,MV,MX
      INTEGER :: A,B
      INTENT (IN) :: A,B
      INTENT (INOUT) :: MP,MT,MD,MC,MV,MX
      INTEGER :: MXY(10),NUMBER_USED_SAVE,J,JP,JD,M
      REAL (KIND(0.0D0)) :: DA,DB

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      DA = A
      DB = B
      RESULT_SIZE = ( (DB - DA + 1)*MWK(START(MX)+2) ) + 5
      RESULT_SIZE = MAX(5,RESULT_SIZE)
      RESULT_SIZE = MIN(NDIG+10,RESULT_SIZE)
      IF (MP <= 0) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ELSE IF (SIZE_OF(MP) < RESULT_SIZE) THEN
          CALL IMDEFINE(MP,RESULT_SIZE)
      ENDIF
      JP = RESULT_SIZE
      RESULT_SIZE = ( (DB+1.5D0)*LOG(DB+2) - DB + 1/(12*(DB+2)) -  &
                    ( (DA+0.5D0)*LOG(DA+1) - DA + 1/(12*(DA+1)) ) - 1 ) / DLOGMB + 10
      RESULT_SIZE = MIN(NDIG+10,RESULT_SIZE)
      IF (MD <= 0) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ELSE IF (SIZE_OF(MD) < RESULT_SIZE) THEN
          CALL IMDEFINE(MD,RESULT_SIZE)
      ENDIF
      JD = RESULT_SIZE
      IF (MC <= 0) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ELSE IF (SIZE_OF(MC) < RESULT_SIZE) THEN
          CALL IMDEFINE(MC,RESULT_SIZE)
      ENDIF
      CALL IMI2M(A,MXY(1))
      IF (MWK(START(MXY(1))+2) > MWK(START(MX)+2)) THEN
          RESULT_SIZE = MWK(START(MX)+2) + 4*JD
      ELSE
          RESULT_SIZE = JP + 2*JD
      ENDIF
      RESULT_SIZE = MIN(NDIG+10,RESULT_SIZE)
      IF (MT <= 0) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ELSE IF (SIZE_OF(MT) < RESULT_SIZE) THEN
          CALL IMDEFINE(MT,RESULT_SIZE)
      ENDIF
      RESULT_SIZE = RESULT_SIZE + JD
      RESULT_SIZE = MIN(NDIG+10,RESULT_SIZE)
      IF (MV <= 0) THEN
          CALL IMDEFINE(MV,RESULT_SIZE)
      ELSE IF (SIZE_OF(MV) < RESULT_SIZE) THEN
          CALL IMDEFINE(MV,RESULT_SIZE)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION + 1

      IF (B-A < 12) THEN
          CALL IMDEFINE(MXY(1),RESULT_SIZE)
          CALL IMDEFINE(MXY(2),RESULT_SIZE)
          CALL IMDEFINE(MXY(3),RESULT_SIZE)
          CALL IMDEFINE(MXY(4),RESULT_SIZE)
          CALL IMDEFINE(MXY(5),RESULT_SIZE)

          CALL IMI2M(B-A+1,MXY(2))
          CALL IMPWR(MX,MXY(2),MP)

          CALL IMI2M(1,MD)
          DO J = A, B-1, 2
             CALL IMMPYI(MD,J+1,MXY(1))
             CALL IMMPYI(MXY(1),J+2,MD)
          ENDDO
          IF (MOD(B-A,2) == 0) THEN
              CALL IMMPYI(MD,B+1,MXY(1))
              CALL IMEQ(MXY(1),MD)
          ENDIF

          CALL IMI2M(0,MC)
          DO J = A, B
             CALL IMDIVI(MD,J+1,MXY(2))
             CALL IMADD(MC,MXY(2),MXY(3))
             CALL IMEQ(MXY(3),MC)
          ENDDO

!             MT is the T sum
!             MXY(1) is the next term
!             MV is the V sum
!             MXY(3) is the harmonic sum in the V terms

          CALL IMI2M(0,MT)
          CALL IMI2M(0,MV)
          CALL IMSQR(MD,MXY(1))
          CALL IMI2M(0,MXY(3))
          DO J = A, B
             CALL IMDIVI(MXY(1),J+1,MXY(2))
             CALL IMDIVI(MXY(2),J+1,MXY(1))
             CALL IMMPY(MXY(1),MX,MXY(2))
             CALL IMEQ(MXY(2),MXY(1))
             CALL IMADD(MT,MXY(1),MXY(2))
             CALL IMEQ(MXY(2),MT)

             CALL IMDIVI(MD,J+1,MXY(4))
             CALL IMADD(MXY(3),MXY(4),MXY(5))
             CALL IMEQ(MXY(5),MXY(3))
             CALL IMMPY(MXY(1),MXY(3),MXY(5))
             CALL IMADD(MV,MXY(5),MXY(2))
             CALL IMEQ(MXY(2),MV)
          ENDDO
          GO TO 110
      ENDIF

      M = (A+B)/2
      CALL FMEULR_PTDCV(A,M-1,MXY(1),MXY(2),MXY(3),MXY(4),MXY(5),MX)
      CALL FMEULR_PTDCV(M,B,MXY(6),MXY(7),MXY(8),MXY(9),MXY(10),MX)
      CALL IM_OR_FM_MPY(MXY(1),MXY(7),MT)
      CALL IM_OR_FM_SQR(MXY(8),MP)
      CALL IM_OR_FM_MPY(MXY(4),MXY(8),MD)

!             MP and MC are not needed in FMEULR_B, so their calculations can be skipped at the
!             top level of the recursion.

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IM_OR_FM_MPY(MXY(9),MXY(3),MXY(4))
          CALL IM_OR_FM_ADD(MD,MXY(4),MC)
      ELSE
          CALL IMI2M(0,MC)
      ENDIF

      CALL IM_OR_FM_MPY(MD,MT,MXY(4))
      CALL IM_OR_FM_MPY(MP,MXY(8),MV)
      CALL IM_OR_FM_MPY(MV,MXY(5),MXY(9))
      CALL IM_OR_FM_ADD(MXY(9),MXY(4),MV)
      CALL IM_OR_FM_MPY(MXY(3),MXY(1),MXY(4))
      CALL IM_OR_FM_MPY(MXY(4),MXY(10),MXY(9))
      CALL IM_OR_FM_ADD(MV,MXY(9),MXY(4))
      CALL IM_OR_FM_EQ(MXY(4),MV)

      CALL IM_OR_FM_MPY(MXY(3),MXY(8),MD)

      CALL IM_OR_FM_MPY(MP,MXY(2),MXY(3))
      CALL IM_OR_FM_ADD(MXY(3),MT,MXY(8))
      CALL IM_OR_FM_EQ(MXY(8),MT)

      IF (LEVEL_OF_RECURSION > 1) THEN
          CALL IM_OR_FM_MPY(MXY(1),MXY(6),MP)
      ELSE
          CALL IMI2M(0,MP)
      ENDIF

  110 NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MP) == -1) TEMPV(MP) = -2
          IF (TEMPV(MT) == -1) TEMPV(MT) = -2
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          IF (TEMPV(MV) == -1) TEMPV(MV) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      LEVEL_OF_RECURSION = LEVEL_OF_RECURSION - 1
      RETURN
      END SUBROUTINE FMEULR_PTDCV

      SUBROUTINE FMEXT2(MT,MC,NDSAVE,MXSAVE,KASAVE,KOVUN)

!  Upon exit from an FM routine, the result MT (having precision NDIG) is rounded and returned
!  in MC (having precision NDSAVE).  The values of NDIG, MXEXP, and KACCSW are restored.
!  KOVUN is nonzero if one of the routine's input arguments was overflow or underflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MT,MC
      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: NDSAVE,KASAVE,KOVUN

      INTEGER :: KFSAVE,KWRNSV
      INTENT (IN) :: MT
      INTENT (INOUT) :: MC,NDSAVE,MXSAVE,KASAVE,KOVUN
      KWRNSV = KWARN
      KWARN = 0
      MXEXP = MXSAVE
      KFSAVE = KFLAG
      CALL FMEQU(MT,MC,NDIG,NDSAVE)
      IF (KFLAG /= -5 .AND. KFLAG /= -6) KFLAG = KFSAVE
      NDIG = NDSAVE
      KWARN = KWRNSV
      IF (KFLAG == 1) KFLAG = 0
      IF ((MWK(START(MC)+2) == MUNKNO .AND. KFLAG /= -9)     &
         .OR. (MWK(START(MC)+2) == MEXPUN .AND. KOVUN == 0)  &
         .OR. (MWK(START(MC)+2) == MEXPOV .AND. KOVUN == 0)) CALL FMWRN2
      IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
      NCALL = NCALL - 1
      KACCSW = KASAVE
      RETURN
      END SUBROUTINE FMEXT2

      SUBROUTINE FMFACT(MA,MB)

!  MB = MA!  ( = GAMMA(MA+1))

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,K,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMFACT'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMEULR(MXY(1))
          CALL FMMPY(MXY(1),MA,MXY(3))
          CALL FMI2M(1,MXY(1))
          CALL FMSUB(MXY(1),MXY(3),MB)
          KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMFACT'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      CALL FMENT2('FMFACT   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMADDI(MXY(1),1)
      CALL FMGAM(MXY(1),MXY(2))
      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFACT

      SUBROUTINE FMFCTI(NUM,MA)

!  MA = NUM factorial, where NUM is an integer.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: NUM
      INTEGER :: MA

      INTEGER :: J,JK,K,LARGE
      INTENT (IN) :: NUM
      INTENT (INOUT) :: MA

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMI2M(1,MA)
      IF (NUM <= 1) THEN
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MA) == -1) TEMPV(MA) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      J = NUM
      K = 1
      LARGE = INT(INTMAX/J)
      DO JK = 2, J
         K = K*JK
         IF (K > LARGE) THEN
             CALL FMMPYI_R1(MA,K)
             K = 1
         ENDIF
      ENDDO
      IF (K > 1) CALL FMMPYI_R1(MA,K)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFCTI

      SUBROUTINE FMGAM(MA,MB)

!  MB = GAMMA(MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTA,J,K,K0,K1,K2,KASAVE,KDIFF,KFL,KL,KOVUN,KR_RETRY,KRESLT,KRFLCT,      &
                 KRSAVE,KSIGN,KWRNSV,KWSAVE,LARGE,LSHIFT,NDGOAL,NDOLD,NDSAV2,NDSAVE,NGOAL,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(15),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMGAM'
              CALL FMNTR(2,MA,MA,1,1)
              NCALL = NCALL - 1
          ENDIF
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          CALL FMI2M(1,MXY(1))
          CALL FMDIV(MXY(1),MA,MXY(2))
          CALL FMEULR(MXY(1))
          CALL FMSUB(MXY(2),MXY(1),MB)
          IF (KFLAG > 0) KFLAG = 0
          NTRACE = J
          KWARN = K
          IF (KFLAG == -5 .AND. MWK(START(MA)+2) > MEXPUN) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMGAM'
              CALL FMWRN2
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMGAM'
              CALL FMNTR(1,MB,MB,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      CALL FMENT2('FMGAM    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             See if there is a small integer separating this argument from the last one.

      IF (MBASE == MBSGAM .AND. NDIG <= NDGGAM) THEN
          IF (MWK(START(MA)) == -1) THEN
              CALL FMINT(MXY(1),MXY(10))
              IF (FMCOMP(MXY(1),'==',MXY(10))) THEN
                  CALL FMST2M('UNKNOWN',MXY(11))
                  KFLAG = -4
                  GO TO 160
              ENDIF
          ENDIF
          CALL FMSUB(MXY(1),M_GAMMA_MA,MXY(7))
          IF (MWK(START(MXY(7))+3) == 0) THEN
              CALL FMEQ(M_GAMMA_MB,MXY(11))
              GO TO 160
          ENDIF
          KWRNSV = KWARN
          KWARN = 0
          CALL FMM2I(MXY(7),KDIFF)
          KWARN = KWRNSV
          IF (KFLAG == 0 .AND. ABS(KDIFF) <= 50) THEN
              IF (KDIFF > 0) THEN
                  CALL FMEQ(M_GAMMA_MA,MXY(10))
              ELSE
                  CALL FMEQ(MXY(1),MXY(10))
              ENDIF
              CALL FMEQ(MXY(10),MXY(9))
              DO J = 1, ABS(KDIFF)-1
                 CALL FMI2M(1,MXY(5))
                 CALL FMADD_R1(MXY(10),MXY(5))
                 CALL FMMPY_R1(MXY(9),MXY(10))
              ENDDO
              IF (KDIFF > 0) THEN
                  CALL FMMPY(M_GAMMA_MB,MXY(9),MXY(11))
              ELSE
                  CALL FMDIV(M_GAMMA_MB,MXY(9),MXY(11))
              ENDIF
              GO TO 140
          ENDIF
      ENDIF
      CALL FMEQ(MXY(1),MXY(15))

!             Near zero Gamma(x) is about 1/x.

  120 IF (MWK(START(MXY(15))+2) < (-NDIG-3)) THEN
          CALL FMI2M(1,MXY(5))
          CALL FMDIV(MXY(5),MXY(15),MXY(11))
          GO TO 140
      ENDIF

!             Check for special cases.

      KRFLCT = 0
      CALL FMDPM(DBLE(-0.5),MXY(7))
      IF (FMCOMP(MXY(15),'<=',MXY(7))) THEN
          KRFLCT = 1
          KFL = 0
          IF (MWK(START(MXY(1))+2) <= NDSAVE) THEN
              CALL FMINT(MXY(15),MXY(10))
              IF (FMCOMP(MXY(15),'==',MXY(10))) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(11))
              KFLAG = -4
              GO TO 160
          ELSE
              CALL FMI2M(1,MXY(5))
              CALL FMSUB_R2(MXY(5),MXY(15))
          ENDIF
      ENDIF

!             To speed the asymptotic series calculation, increase the argument by LSHIFT.

      KWSAVE = KWARN
      KWARN = 0
      CALL FMM2I(MXY(15),INTA)
      KWARN = KWSAVE

      IF (KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(NDIG)*ALOGMB/4.46-REAL(INTA)))
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)
      IF (KFLAG == 0) THEN
          IF (INTA <= MAX(200,INT(DLOGMB*NDIG))) THEN
              IF (INTA <= 2) THEN
                  CALL FMI2M(1,MXY(11))
                  GO TO 130
              ENDIF
              INTA = INTA - 1
              CALL FMFCTI(INTA,MXY(11))
              GO TO 130
          ENDIF
      ENDIF

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(5))
          CALL FMADD(MXY(15),MXY(5),MXY(14))
      ELSE
          CALL FMEQ(MXY(15),MXY(14))
      ENDIF

!             Get Gamma for the shifted argument.

!             Compute IEXTRA, the number of extra digits required to compensate for cancellation
!             error when the argument is large.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(14))+2))-1,0),INT(1.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(14),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(15),NDIG,NDIG+IEXTRA)
      ENDIF
      NDSAV2 = NDIG
      NDIG = NDIG + IEXTRA
      CALL FMLNGM(MXY(14),MXY(4))
      CALL FMEXP(MXY(4),MXY(11))

      NDIG = NDSAV2

!             Reverse the shifting.
!             The product MA*(MA+1)*...*(MA+LSHIFT-1) is computed four terms at a time to reduce
!             the number of FMMPY calls.

!             MXY(6)  is Z
!             MXY(7)  is Z**2
!             MXY(8)  is Z**3
!             MXY(9)  is (Z+K)*...*(Z+K+3)
!             MXY(12) is the current product

      CALL FMEQ(MXY(15),MXY(6))
      IF (LSHIFT > 0) THEN
          CALL FMSQR(MXY(6),MXY(7))
          CALL FMMPY(MXY(6),MXY(7),MXY(8))
          CALL FMSQR(MXY(7),MXY(9))
          CALL FMMPYI(MXY(8),6,MXY(13))
          CALL FMADD_R1(MXY(9),MXY(13))
          CALL FMMPYI(MXY(7),11,MXY(13))
          CALL FMADD_R1(MXY(9),MXY(13))
          CALL FMMPYI(MXY(6),6,MXY(13))
          CALL FMADD_R1(MXY(9),MXY(13))
          CALL FMEQ(MXY(9),MXY(12))
          CALL FMMPYI_R1(MXY(8),16)
          LARGE = INTMAX
          DO K = 0, LSHIFT-8, 4
             CALL FMADD_R1(MXY(9),MXY(8))
             K2 = 24*(2*K + 7)
             CALL FMMPYI(MXY(7),K2,MXY(13))
             CALL FMADD_R1(MXY(9),MXY(13))
             IF (K <= SQRT(REAL(LARGE)/49.0)) THEN
                 K1 = 8*(6*K*K + 42*K + 79)
                 CALL FMMPYI(MXY(6),K1,MXY(13))
                 CALL FMADD_R1(MXY(9),MXY(13))
             ELSE
                 K1 = 48*K
                 CALL FMMPYI(MXY(6),K1,MXY(13))
                 CALL FMMPYI_R1(MXY(13),K)
                 CALL FMADD_R1(MXY(9),MXY(13))
                 K1 = 336*K + 632
                 CALL FMMPYI(MXY(6),K1,MXY(13))
                 CALL FMADD_R1(MXY(9),MXY(13))
             ENDIF
             IF (K <= (REAL(LARGE)/17.0)**0.3333) THEN
                 K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                 CALL FMADDI(MXY(9),K0)
             ELSE IF (K <= SQRT(REAL(LARGE)*0.9)) THEN
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(13))
                 K0 = K*K + 7*K + 15
                 CALL FMMPYI_R1(MXY(13),K0)
                 CALL FMADD_R1(MXY(9),MXY(13))
             ELSE
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(13))
                 CALL FMMPYI(MXY(13),K,MXY(10))
                 CALL FMMPYI_R1(MXY(10),K)
                 CALL FMADD_R1(MXY(9),MXY(10))
                 K0 = 7*K + 15
                 CALL FMMPYI_R1(MXY(13),K0)
                 CALL FMADD_R1(MXY(9),MXY(13))
             ENDIF
             CALL FMMPY_R1(MXY(12),MXY(9))
          ENDDO
          CALL FMDIV_R1(MXY(11),MXY(12))
      ENDIF

!             Use the reflection formula if MA was less than -1/2.

  130 IF (KRFLCT == 1) THEN

!             Reduce the argument before multiplying by Pi.

          CALL FMNINT(MXY(15),MXY(7))
          CALL FMDIVI(MXY(7),2,MXY(8))
          CALL FMINT(MXY(8),MXY(2))
          CALL FMMPYI(MXY(2),2,MXY(9))
          KSIGN = -1
          IF (FMCOMP(MXY(7),'==',MXY(9))) KSIGN = 1
          CALL FMSUB(MXY(15),MXY(7),MXY(10))
          MWK(START(MXY(10))+1) = MWK(START(MXY(15))+1)
          CALL FMPI(MXY(12))
          CALL FMMPY_R1(MXY(12),MXY(10))
          KRSAVE = KRAD
          KRAD = 1
          CALL FMSIN(MXY(12),MXY(3))
          MWK(START(MXY(3))) = KSIGN*MWK(START(MXY(3)))
          KRAD = KRSAVE
          CALL FMDIV_R2(MPISAV,MXY(3))
          CALL FMDIV_R2(MXY(3),MXY(11))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  140 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(11))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(11))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(11))+J+1)) GO TO 150
              ENDDO
              GO TO 160
          ENDIF
  150     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(11))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(15))
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(11),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  160 MACMAX = NINT(NDSAVE*ALOGM2)
      J = MWK(START(MXY(11))+1)
      MWK(START(MXY(11))+1) = MIN(MWK(START(MXY(11))+1),MACCA,MACMAX)

      CALL FMEQ(MXY(1),M_GAMMA_MA)
      CALL FMEQ(MXY(11),M_GAMMA_MB)
      MWK(START(M_GAMMA_MB)+1) = J
      NDGGAM = NDIG
      IF (ABS(MWK(START(M_GAMMA_MB)+2)) > MEXPOV) NDGGAM = 0
      MBSGAM = MBASE

      CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMGAM

      SUBROUTINE FMIBTA(MX,MA,MB,MC)

!  MC = Incomplete Beta(MX,MA,MB)

!  Integral from 0 to MX of  t**(MA-1) * (1-t)**(MB-1)  dt.

!  0 <= MX <= 1,    0 < MA,    0 <= MB.

!  Some comments below refer to this function and its arguments as B(x,a,b).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MX,MA,MB,MC
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACCX,MACMAX,MLA,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,JCHECK,JEXTRA,K,KASAVE,KASHIFT,KBIGAB,KBSHIFT,KFLAG1,KICK,KL,KOVUN,    &
                 KR_RETRY,KRESLT,KRS,KRSAVE,K_RETURN_CODE,NCSAVE,NDGOAL,NDIG2,NDOLD,NDS,NDSAV1,  &
                 NDSAVE,NGOAL,NMETHD,NTERMS,NUMTRY,NWDS1
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MX,MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(37),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0
      CALL FMIBTA3(MX,MA,MB,MC,MXY,K_RETURN_CODE)
      IF (K_RETURN_CODE == 1) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      NCSAVE = NCALL
      CALL FMENT2('FMIBTA   ',MX,MA,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NCALL = NCSAVE + 1
      KRS = KRESLT
      IF (MWK(START(MB)+2) == MEXPOV .OR. MWK(START(MB)+2) == MEXPUN) KOVUN = 1
      IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
          NDS = NDIG
          NDIG = NDSAVE
          IF (NTRACE < 0) THEN
              CALL FMNTRJ(MB,NDIG)
          ELSE
              CALL FMPRNT(MB)
          ENDIF
          NDIG = NDS
      ENDIF
      KRESLT = KRS
      IF (MWK(START(MB)+2) == MUNKNO .OR. MWK(START(MX)) < 0 .OR. MWK(START(MA)) < 0 .OR.  &
          MWK(START(MB)) < 0) THEN
          KRESLT = 12
          KFLAG = -4
      ENDIF
      IF (KRESLT /= 0) THEN
          NDIG = NDSAVE
          CALL FMRSLT(MA,MB,MC,KRESLT)
          IF (KFLAG == -4) THEN
              IF (MWK(START(MX)+2) /= MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO .AND.  &
                  MWK(START(MB)+2) /= MUNKNO) THEN
                  CALL FMWRN2
              ENDIF
          ENDIF
          IF (NTRACE /= 0) CALL FMNTR(1,MC,MC,1,1)
          MXEXP = MXSAVE
          KACCSW = KASAVE
          NCALL = NCALL - 1
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCX = MWK(START(MX)+1)
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MX,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
      MWK(START(MXY(3))+1) = NINT(NDIG*ALOGM2)

!             Handle cases where at least one of X, A, B is underflow or overflow.
!             Increasing any underflowed values to 1/HUGE makes the calculations more stable.
!             If A is underflow and the final result is overflow, it is safe to return overflow.
!             If X is underflow and the final result is underflow, it is safe to return underflow.
!             If B is underflow, it is replaced by zero.
!             Similarly, decreasing any overflowed A or B values to HUGE and then getting a final
!             result of underflow means it is safe to return underflow.
!             Any cases where the inequalities conflict, such as A = underflow, B = overflow,
!             will return unknown.

      KBIGAB = 0
      IF (MWK(START(MA)+2) == MEXPOV) THEN
          CALL FMBIG(MXY(2))
          MWK(START(MXY(2))+2) = MXSAVE + 1
          KBIGAB = -1
      ENDIF
      IF (MWK(START(MB)+2) == MEXPOV) THEN
          CALL FMBIG(MXY(3))
          MWK(START(MXY(3))+2) = MXSAVE + 1
          KBIGAB = -1
      ENDIF
      IF (MWK(START(MX)+2) == MEXPUN) THEN
          CALL FMBIG(MXY(1))
          MWK(START(MXY(1))+2) = MXSAVE + 1
          CALL FMI2M(1,MXY(12))
          CALL FMDIV_R2(MXY(12),MXY(1))
          KBIGAB = -1
      ENDIF
      IF (MWK(START(MA)+2) == MEXPUN) THEN
          CALL FMBIG(MXY(2))
          MWK(START(MXY(2))+2) = MXSAVE + 1
          CALL FMI2M(1,MXY(12))
          CALL FMDIV_R2(MXY(12),MXY(2))
          IF (KBIGAB < 0) THEN
              KBIGAB = -9
              CALL FMI2M(0,MXY(21))
              GO TO 200
          ELSE
              KBIGAB = 1
          ENDIF
      ENDIF
      IF (MWK(START(MB)+2) == MEXPUN) THEN
          CALL FMI2M(1,MXY(12))
          IF (FMCOMP(MXY(1),'/=',MXY(12))) THEN
              CALL FMI2M(0,MXY(3))
          ENDIF
      ENDIF
      NUMTRY = 0
      NDGOAL = 0
      NWDS1 = 0
      KASHIFT = 0
      KBSHIFT = 0

!             Check for special cases.

  120 KICK = 0
      CALL FMIBTA2(K_RETURN_CODE,MXY,MXSAVE,NTERMS,NUMTRY,NMETHD)
      IF (K_RETURN_CODE == 1) GO TO 180
      IF (K_RETURN_CODE == 2) GO TO 200

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series for B(x,a,b),
!                    = 2 means use continued fraction expansion 1 for B(x,a,b),
!                    = 3 means use the convergent series for B(1-x,b,a).
!                    = 4 means use continued fraction expansion 1 for B(1-x,b,a).
!                    = 5 means use continued fraction expansion 2 for B(x,a,b).
!                    = 6 means use continued fraction expansion 2 for B(1-x,b,a).

      CALL FMSQR(MXY(2),MXY(12))
      CALL FMDPM(DBLE(.00173),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(6))
      CALL FMSQR(MXY(3),MXY(12))
      CALL FMDPM(DBLE(.01253),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.21583),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.03891),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(9.14350),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))

      CALL FMDPM(DBLE(.11709),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMDPM(DBLE(.62633),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(4))
      CALL FMADD_R1(MXY(5),MXY(4))
      CALL FMADDI(MXY(5),1)

      CALL FMDIV(MXY(5),MXY(6),MXY(33))

      CALL FMDPM(DBLE(.29217),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(6))
      CALL FMDPM(DBLE(2.09304),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(1.53724),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))

      CALL FMDPM(DBLE(.29217),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMDPM(DBLE(2.09304),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(4))
      CALL FMADD_R1(MXY(5),MXY(4))
      CALL FMADDI(MXY(5),1)

      CALL FMDIV(MXY(5),MXY(6),MXY(34))

      CALL FMSQR(MXY(2),MXY(12))
      CALL FMDPM(DBLE(.04038),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(6))
      CALL FMSQR(MXY(3),MXY(12))
      CALL FMDPM(DBLE(.05754),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.02670),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.56206),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(0.13746),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))

      CALL FMDPM(DBLE(.87312),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMDPM(DBLE(.20334),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(4))
      CALL FMADD_R1(MXY(5),MXY(4))
      CALL FMADDI(MXY(5),1)

      CALL FMDIV(MXY(5),MXY(6),MXY(35))

      CALL FMDPM(DBLE(.64584),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(6))
      CALL FMDPM(DBLE(.64584),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(6.31958),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))

      CALL FMDPM(DBLE(.64584),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMADDI(MXY(5),1)

      CALL FMDIV(MXY(5),MXY(6),MXY(36))

      CALL FMSQR(MXY(2),MXY(12))
      CALL FMDPM(DBLE(.11637),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(6))
      CALL FMSQR(MXY(3),MXY(12))
      CALL FMDPM(DBLE(.10718),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.92626),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(.05518),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))
      CALL FMDPM(DBLE(0.28962),MXY(5))
      CALL FMADD_R1(MXY(6),MXY(5))

      CALL FMDPM(DBLE(.99773),MXY(7))
      CALL FMMPY(MXY(7),MXY(2),MXY(5))
      CALL FMDPM(DBLE(.56855),MXY(7))
      CALL FMMPY(MXY(7),MXY(3),MXY(4))
      CALL FMADD_R1(MXY(5),MXY(4))
      CALL FMADDI(MXY(5),1)

      CALL FMDIV(MXY(5),MXY(6),MXY(37))

      IF (FMCOMP(MXY(1),'<=',MXY(33))) THEN
          NMETHD = 1
      ELSE IF (FMCOMP(MXY(1),'>=',MXY(34))) THEN
          NMETHD = 3
      ELSE IF (FMCOMP(MXY(1),'<',MXY(37))) THEN
          IF (FMCOMP(MXY(1),'<',MXY(35))) THEN
              NMETHD = 2
          ELSE
              NMETHD = 4
          ENDIF
      ELSE
          IF (FMCOMP(MXY(1),'<',MXY(36))) THEN
              NMETHD = 5
          ELSE
              NMETHD = 6
          ENDIF
      ENDIF
      IF (MWK(START(MXY(3))+2) <= 0 .AND. MWK(START(MXY(2))+2)+NDIG < 0) THEN
          NMETHD = 1
      ENDIF
      IF (NMETHD == 2) GO TO 140
      IF (NMETHD == 5) GO TO 150
      IF (NMETHD == 3 .OR. NMETHD == 4 .OR. NMETHD == 6) GO TO 160

!             Method 1.  Use the Pochhammer(1-B,N)*X**N/((A+N)*N!) series.

!             MXY(15) and MXY(21) hold the positive and negative parts of the current sum.
!             MXY(17) is the current term.
!             MXY(18) is J-B.
!             MXY(19) is 1.
!             MXY(20) is A+J.

  130 JEXTRA = INT(0.06*NDIG)
      IF (NDIG+JEXTRA > NDIG) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      CALL FMI2M(1,MXY(17))
      CALL FMDIV(MXY(17),MXY(2),MXY(15))
      CALL FMI2M(0,MXY(21))
      CALL FMEQ(MXY(3),MXY(18))
      IF (MWK(START(MXY(18))+2) /= MUNKNO .AND. MWK(START(MXY(18))+3) /= 0)  &
          MWK(START(MXY(18))) = -MWK(START(MXY(18)))
      CALL FMEQ(MXY(2),MXY(20))
      CALL FMI2M(1,MXY(19))
      CALL FMI2M(0,MXY(16))
      CALL FMI2M(0,MXY(22))
      JCHECK = 5
      NDSAV1 = NDIG

!             Method 1 summation loop.

      KRSAVE = KROUND
      KROUND = 1
      METHOD1:    DO J = 1, NTERMS
         NDIG = NDSAV1
         CALL FMADD_R1(MXY(18),MXY(19))
         IF (MWK(START(MXY(18))+3) == 0) MWK(START(MXY(18))+1) = MWK(START(MXY(19))+1)
         NDIG2 = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(15))+2)-MWK(START(MXY(17))+2)),  &
                                       NDSAV1-INT(MWK(START(MXY(21))+2)-MWK(START(MXY(17))+2))))
         NDIG = NDIG2
         CALL FMMPY_R1(MXY(17),MXY(18))
         CALL FMMPY_R1(MXY(17),MXY(1))
         IF (J > 1) CALL FMDIVI_R1(MXY(17),J)
         NDIG = NDSAV1
         CALL FMADD_R1(MXY(20),MXY(19))
         NDIG = NDIG2
         CALL FMDIV(MXY(17),MXY(20),MXY(16))

         NDIG = NDSAV1
         IF (INT(MWK(START(MXY(16)))) < 0) THEN
             CALL FMADD_R2(MXY(16),MXY(21))
         ELSE
             CALL FMADD_R2(MXY(16),MXY(15))
         ENDIF

         IF (KFLAG < 0) EXIT
         IF (MOD(J,JCHECK) == 0) THEN
             CALL FMADD(MXY(15),MXY(21),MXY(16))
             DO K = NDIG+1, 1, -1
                IF (MWK(START(MXY(16))+K+1) /= MWK(START(MXY(22))+K+1)) THEN
                    CALL FMEQ(MXY(16),MXY(22))
                    CYCLE METHOD1
                ENDIF
             ENDDO
             EXIT
         ENDIF
      ENDDO METHOD1
      KROUND = KRSAVE

      CALL FMPWR(MXY(1),MXY(2),MXY(12))
      CALL FMADD(MXY(15),MXY(21),MXY(7))
      CALL FMMPY(MXY(7),MXY(12),MXY(21))

      IF (NMETHD == 1) THEN
          GO TO 180
      ELSE
          GO TO 170
      ENDIF

!             Method 2.  Continued fraction expansion for B(x,a,b).

!             MXY(22) is the current approximation.
!             MXY(21) is the term in the sum, S(k).
!             MXY(19), MXY(20) are the latest denominators, Q(k-1) and Q(k).

  140 JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0)) + NGRD52 + INT(0.152*NDIG)
      IF (NDIG+JEXTRA > NDIG) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      NDSAV1 = NDIG
      CALL FMI2M(1,MXY(19))
      CALL FMI2M(1,MXY(20))
      CALL FMI2M(1,MXY(21))
      CALL FMEQ(MXY(21),MXY(22))
      CALL FMEQ(MXY(2),MXY(24))
      CALL FMADD(MXY(2),MXY(3),MXY(25))
      CALL FMEQ(MXY(2),MXY(26))
      CALL FMI2M(1,MXY(12))
      CALL FMADD(MXY(2),MXY(12),MXY(27))
      CALL FMEQ(MXY(3),MXY(28))
      CALL FMSQR(MXY(2),MXY(29))
      CALL FMADD(MXY(29),MXY(26),MXY(30))
      CALL FMSUB(MXY(29),MXY(26),MXY(31))
      MWK(START(MXY(31))+1) = MWK(START(MXY(30))+1)
      CALL FMMPY(MXY(24),MXY(25),MXY(12))
      CALL FMMPY(MXY(12),MXY(1),MXY(7))
      CALL FMDIV(MXY(7),MXY(30),MXY(33))
      IF (MWK(START(MXY(33))+2) /= MUNKNO .AND. MWK(START(MXY(33))+3) /= 0)  &
          MWK(START(MXY(33))) = -MWK(START(MXY(33)))
      CALL FMMPY(MXY(33),MXY(19),MXY(18))
      CALL FMADD(MXY(20),MXY(18),MXY(17))
      CALL FMMPY(MXY(18),MXY(21),MXY(12))
      CALL FMDIV(MXY(12),MXY(17),MXY(21))
      IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
          MWK(START(MXY(21))) = -MWK(START(MXY(21)))
      CALL FMADD_R1(MXY(22),MXY(21))
      CALL FMEQ(MXY(20),MXY(19))
      CALL FMEQ(MXY(17),MXY(20))

!             Method 2 continued fraction loop.

      KRSAVE = KROUND
      KROUND = 1
      DO J = 1, NTERMS
         CALL FMADDI(MXY(24),1)
         CALL FMADDI(MXY(25),1)
         CALL FMADDI(MXY(26),2)
         CALL FMADDI(MXY(27),2)
         CALL FMADDI(MXY(28),-1)
         MWK(START(MXY(28))+1) = MWK(START(MXY(27))+1)
         CALL FMMPYI(MXY(26),4,MXY(15))
         CALL FMADDI(MXY(15),-4)
         CALL FMADD_R1(MXY(29),MXY(15))
         MWK(START(MXY(29))+1) = MWK(START(MXY(27))+1)
         CALL FMADD(MXY(29),MXY(26),MXY(30))
         CALL FMSUB(MXY(29),MXY(26),MXY(31))

         CALL FMMPY(MXY(28),MXY(1),MXY(15))
         CALL FMMPYI_R1(MXY(15),J)
         CALL FMDIV(MXY(15),MXY(31),MXY(33))

         CALL FMMPY(MXY(33),MXY(19),MXY(18))
         CALL FMADD(MXY(20),MXY(18),MXY(17))
         CALL FMMPY(MXY(18),MXY(21),MXY(15))
         CALL FMDIV(MXY(15),MXY(17),MXY(21))
         IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
             MWK(START(MXY(21))) = -MWK(START(MXY(21)))

         NDIG = NDSAV1
         CALL FMADD_R1(MXY(22),MXY(21))
         KFLAG1 = KFLAG

         CALL FMEQ(MXY(20),MXY(19))
         CALL FMEQ(MXY(17),MXY(20))
         NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-MWK(START(MXY(21))+2))))
         CALL FMMPY(MXY(24),MXY(25),MXY(15))
         CALL FMMPY_R1(MXY(15),MXY(1))
         CALL FMDIV(MXY(15),MXY(30),MXY(33))
         IF (MWK(START(MXY(33))+2) /= MUNKNO .AND. MWK(START(MXY(33))+3) /= 0)  &
             MWK(START(MXY(33))) = -MWK(START(MXY(33)))

         CALL FMMPY(MXY(33),MXY(19),MXY(18))
         CALL FMADD(MXY(20),MXY(18),MXY(17))
         CALL FMMPY(MXY(18),MXY(21),MXY(15))
         CALL FMDIV(MXY(15),MXY(17),MXY(21))
         IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
             MWK(START(MXY(21))) = -MWK(START(MXY(21)))

         NDIG = NDSAV1
         CALL FMADD_R1(MXY(22),MXY(21))

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(20),MXY(19))
         CALL FMEQ(MXY(17),MXY(20))
         NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-MWK(START(MXY(21))+2))))
      ENDDO
      KROUND = KRSAVE

      CALL FMLN(MXY(1),MXY(19))
      CALL FMMPY_R1(MXY(19),MXY(2))
      IF (MWK(START(MXY(1))+2)*(-10) >= NDIG) THEN
          CALL FMEQ(MXY(1),MXY(15))
          CALL FMEQ(MXY(1),MXY(20))
          DO K = 2, NTERMS
             CALL FMMPY_R1(MXY(15),MXY(1))
             CALL FMDIVI(MXY(15),K,MXY(12))
             CALL FMADD_R1(MXY(20),MXY(12))
             IF (KFLAG /= 0) EXIT
          ENDDO
          CALL FMMPY_R1(MXY(20),MXY(3))
          IF (MWK(START(MXY(20))+2) /= MUNKNO .AND. MWK(START(MXY(20))+3) /= 0)  &
              MWK(START(MXY(20))) = -MWK(START(MXY(20)))
      ELSE
          CALL FMI2M(1,MXY(12))
          CALL FMSUB_R1(MXY(12),MXY(1))
          CALL FMLN(MXY(12),MXY(20))
          CALL FMMPY_R1(MXY(20),MXY(3))
      ENDIF
      CALL FMADD(MXY(19),MXY(20),MXY(12))
      CALL FMEXP(MXY(12),MXY(21))
      CALL FMMPY_R2(MXY(22),MXY(21))
      IF (MWK(START(MXY(21))+2) == MUNKNO) THEN
          IF (MWK(START(MXY(22)))*MWK(START(MXY(22))+3) > 0) THEN
              CALL FMLN(MXY(22),MXY(12))
              CALL FMADD(MXY(12),MXY(19),MXY(7))
              CALL FMADD(MXY(7),MXY(20),MXY(12))
              CALL FMEXP(MXY(12),MXY(21))
          ELSE
              CALL FMEQ(MXY(22),MXY(13))
              IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
                  MWK(START(MXY(13))) = -MWK(START(MXY(13)))
              CALL FMLN(MXY(13),MXY(12))
              CALL FMADD(MXY(12),MXY(19),MXY(7))
              CALL FMADD(MXY(7),MXY(20),MXY(12))
              CALL FMEXP(MXY(12),MXY(21))
              IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
                  MWK(START(MXY(21))) = -MWK(START(MXY(21)))
          ENDIF
      ENDIF
      IF (ABS(MWK(START(MXY(21))+2)) < MEXPOV) CALL FMDIV_R1(MXY(21),MXY(2))
      IF (NMETHD == 2) THEN
          GO TO 180
      ELSE
          GO TO 170
      ENDIF

!             Method 5.  Continued fraction expansion 2 for B(x,a,b).

!             MXY(22) is the current approximation.
!             MXY(21) is the term in the sum, S(k).
!             MXY(19), MXY(20) are the latest denominators, Q(k-1) and Q(k).

  150 JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0)) + INT(0.07*NDIG)
      IF (NDIG+JEXTRA > NDIG) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+JEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      NDSAV1 = NDIG
      CALL FMSQR(MXY(1),MXY(23))
      CALL FMI2M(1,MXY(12))
      CALL FMSUB(MXY(2),MXY(12),MXY(24))
      MWK(START(MXY(24))+1) = MWK(START(MXY(23))+1)
      CALL FMADD(MXY(2),MXY(3),MXY(25))
      CALL FMADDI(MXY(25),-1)
      MWK(START(MXY(25))+1) = MWK(START(MXY(23))+1)
      CALL FMEQ(MXY(24),MXY(26))
      CALL FMI2M(1,MXY(12))
      CALL FMADD(MXY(2),MXY(12),MXY(27))
      CALL FMEQ(MXY(3),MXY(28))
      CALL FMI2M(1,MXY(7))
      CALL FMSUB(MXY(2),MXY(7),MXY(12))
      CALL FMSQR(MXY(12),MXY(29))
      MWK(START(MXY(29))+1) = MWK(START(MXY(23))+1)
      CALL FMI2M(2,MXY(12))
      CALL FMSUB(MXY(12),MXY(1),MXY(30))
      MWK(START(MXY(30))+1) = MWK(START(MXY(27))+1)
      IF (NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(19),NDSAVE,NDIG)
          CALL FMMPY(MXY(2),MXY(19),MXY(7))
          CALL FMMPY(MXY(3),MXY(1),MXY(12))
          CALL FMSUB(MXY(7),MXY(12),MXY(31))
          CALL FMADDI(MXY(31),1)
      ELSE
          CALL FMADD(MXY(2),MXY(3),MXY(7))
          CALL FMMPY(MXY(7),MXY(1),MXY(12))
          CALL FMSUB(MXY(2),MXY(12),MXY(31))
          CALL FMADDI(MXY(31),1)
      ENDIF
      MWK(START(MXY(31))+1) = MWK(START(MXY(27))+1)
      CALL FMEQ(MXY(2),MXY(35))
      CALL FMI2M(2,MXY(7))
      CALL FMSUB(MXY(2),MXY(7),MXY(12))
      CALL FMMPYI(MXY(12),4,MXY(36))
      MWK(START(MXY(36))+1) = MWK(START(MXY(36))+1)

      CALL FMI2M(1,MXY(33))
      CALL FMMPY(MXY(35),MXY(31),MXY(12))
      CALL FMDIV(MXY(12),MXY(27),MXY(34))

      CALL FMI2M(1,MXY(19))
      CALL FMEQ(MXY(34),MXY(20))
      CALL FMDIV(MXY(33),MXY(34),MXY(21))
      CALL FMEQ(MXY(21),MXY(22))

!             Method 5 continued fraction loop.

      KRSAVE = KROUND
      KROUND = 1
      DO J = 1, NTERMS
         CALL FMADDI(MXY(24),1)
         CALL FMADDI(MXY(25),1)
         CALL FMADDI(MXY(26),2)
         CALL FMADDI(MXY(27),2)
         CALL FMADDI(MXY(28),-1)
         MWK(START(MXY(28))+1) = MWK(START(MXY(27))+1)
         CALL FMADDI(MXY(36),8)
         CALL FMADD_R1(MXY(29),MXY(36))
         CALL FMADD_R1(MXY(31),MXY(30))
         CALL FMADDI(MXY(35),1)

         CALL FMMPY(MXY(24),MXY(25),MXY(15))
         CALL FMMPYI_R1(MXY(15),J)
         CALL FMMPY_R1(MXY(15),MXY(28))
         CALL FMMPY_R1(MXY(15),MXY(23))
         CALL FMDIV(MXY(15),MXY(29),MXY(33))

         CALL FMMPY(MXY(35),MXY(31),MXY(15))
         CALL FMDIV(MXY(15),MXY(27),MXY(34))
         CALL FMMPY(MXY(28),MXY(1),MXY(15))
         CALL FMMPYI_R1(MXY(15),J)
         CALL FMDIV_R1(MXY(15),MXY(26))
         CALL FMADD_R1(MXY(34),MXY(15))
         CALL FMADDI(MXY(34),J)

         CALL FMMPY(MXY(33),MXY(19),MXY(18))
         CALL FMMPY(MXY(34),MXY(20),MXY(15))
         CALL FMADD(MXY(15),MXY(18),MXY(17))
         CALL FMMPY(MXY(18),MXY(21),MXY(15))
         CALL FMDIV(MXY(15),MXY(17),MXY(21))
         IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
             MWK(START(MXY(21))) = -MWK(START(MXY(21)))

         NDIG = NDSAV1
         CALL FMADD_R1(MXY(22),MXY(21))

!             Check for convergence.

         IF (KFLAG == 1) THEN
             EXIT
         ENDIF

         CALL FMEQ(MXY(20),MXY(19))
         CALL FMEQ(MXY(17),MXY(20))
         NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-MWK(START(MXY(21))+2))))
      ENDDO
      KROUND = KRSAVE
      NDIG = NDSAV1

      CALL FMI2M(1,MXY(12))
      IF (FMCOMP(MXY(1),'==',MXY(12)) .AND. NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(19),NDSAVE,NDIG)
          CALL FMMPY_R1(MXY(19),MXY(2))
          IF (MWK(START(MXY(19))+2) /= MUNKNO .AND. MWK(START(MXY(19))+3) /= 0)  &
              MWK(START(MXY(19))) = -MWK(START(MXY(19)))
      ELSE IF (MWK(START(MX)+2) <= -1 .AND. NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(19),NDSAVE,NDIG)
          CALL FMEQ(MXY(19),MXY(15))
          CALL FMEQ(MXY(19),MXY(20))
          DO K = 2, NTERMS
             CALL FMMPY_R1(MXY(15),MXY(19))
             CALL FMDIVI(MXY(15),K,MXY(12))
             CALL FMADD_R1(MXY(20),MXY(12))
             IF (KFLAG /= 0) EXIT
          ENDDO
          CALL FMMPY(MXY(20),MXY(2),MXY(19))
          IF (MWK(START(MXY(19))+2) /= MUNKNO .AND. MWK(START(MXY(19))+3) /= 0)  &
              MWK(START(MXY(19))) = -MWK(START(MXY(19)))
      ELSE
          CALL FMLN(MXY(1),MXY(19))
          CALL FMMPY_R1(MXY(19),MXY(2))
      ENDIF
      IF (NMETHD == 6) THEN
          CALL FMEQU(MX,MXY(20),NDSAVE,NDIG)
          CALL FMLN(MXY(20),MXY(10))
          CALL FMMPY(MXY(10),MXY(3),MXY(20))
      ELSE IF (MWK(START(MXY(1))+2) <= -1) THEN
          CALL FMEQ(MXY(1),MXY(15))
          CALL FMEQ(MXY(1),MXY(20))
          DO K = 2, NTERMS
             CALL FMMPY_R1(MXY(15),MXY(1))
             CALL FMDIVI(MXY(15),K,MXY(12))
             CALL FMADD_R1(MXY(20),MXY(12))
             IF (KFLAG /= 0) EXIT
          ENDDO
          CALL FMMPY_R1(MXY(20),MXY(3))
          IF (MWK(START(MXY(20))+2) /= MUNKNO .AND. MWK(START(MXY(20))+3) /= 0)  &
              MWK(START(MXY(20))) = -MWK(START(MXY(20)))
      ELSE
          CALL FMI2M(1,MXY(12))
          CALL FMSUB_R1(MXY(12),MXY(1))
          CALL FMLN(MXY(12),MXY(20))
          CALL FMMPY_R1(MXY(20),MXY(3))
      ENDIF
      CALL FMADD(MXY(19),MXY(20),MXY(12))
      CALL FMEXP(MXY(12),MXY(21))
      CALL FMMPY_R1(MXY(21),MXY(22))
      IF (MWK(START(MXY(21))+2) == MUNKNO) THEN
          IF (MWK(START(MXY(22)))*MWK(START(MXY(22))+3) > 0) THEN
              CALL FMLN(MXY(22),MXY(12))
              CALL FMADD(MXY(12),MXY(19),MXY(7))
              CALL FMADD(MXY(7),MXY(20),MXY(12))
              CALL FMEXP(MXY(12),MXY(21))
          ELSE
              CALL FMEQ(MXY(22),MXY(13))
              IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
                  MWK(START(MXY(13))) = -MWK(START(MXY(13)))
              CALL FMLN(MXY(13),MXY(12))
              CALL FMADD(MXY(12),MXY(19),MXY(7))
              CALL FMADD(MXY(7),MXY(20),MXY(12))
              CALL FMEXP(MXY(12),MXY(21))
              IF (MWK(START(MXY(21))+2) /= MUNKNO .AND. MWK(START(MXY(21))+3) /= 0)  &
                  MWK(START(MXY(21))) = -MWK(START(MXY(21)))
          ENDIF
      ENDIF
      IF (NMETHD == 5) THEN
          GO TO 180
      ELSE
          GO TO 170
      ENDIF

!             Method 3, 4, or 6.  B(X,A,B) = B(A,B) - B(1-X,B,A).

  160 MLA = MWK(START(MXY(1))+1)
      CALL FMI2M(1,MXY(12))
      CALL FMSUB_R2(MXY(12),MXY(1))
      MWK(START(MXY(1))+1) = MLA
      DO J = -1, NDIG+1
         MLA = MWK(START(MXY(2))+J+1)
         MWK(START(MXY(2))+J+1) = MWK(START(MXY(3))+J+1)
         MWK(START(MXY(3))+J+1) = MLA
      ENDDO
      IF (NMETHD == 3) THEN
          GO TO 130
      ELSE IF (NMETHD == 4) THEN
          GO TO 140
      ELSE
          GO TO 150
      ENDIF
  170 K = NWDS1
      CALL FMEQ(MXY(21),MXY(30))
      CALL FMBETA(MXY(2),MXY(3),MXY(32))
      NWDS1 = INT(MAX(MWK(START(MXY(32))+2),MWK(START(MXY(30))+2)))
      CALL FMSUB(MXY(32),MXY(30),MXY(21))
      NWDS1 = MAX(0,NWDS1-INT(MWK(START(MXY(21))+2)))
      IF (K /= NWDS1 .AND. NUMTRY >= 1) THEN
          IF (KASHIFT == 0 .AND. KBSHIFT == 0) MWK(START(MXY(21))+1) = -1
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  180 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(21))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      K = KFLAG
      IF (KICK < 0) MWK(START(MXY(21))+1) = KICK

!             Reverse the translation if KASHIFT is positive.
!             This is used when a is small and a retry was required because of cancellation.

      IF (KASHIFT > 0 .AND. MWK(START(MXY(21))+1) > 0) THEN
          CALL FMEQU(MX,MXY(22),NDSAVE,NDIG)
          CALL FMEQU(MA,MXY(23),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(24),NDSAVE,NDIG)
          IF (KBSHIFT > 0) CALL FMADDI(MXY(24),KBSHIFT)
          CALL FMI2M(1,MXY(19))
          CALL FMADD(MXY(23),MXY(24),MXY(16))
          CALL FMI2M(1,MXY(12))
          CALL FMADD(MXY(23),MXY(12),MXY(7))
          CALL FMDIV(MXY(16),MXY(7),MXY(20))
          CALL FMI2M(1,MXY(12))
          CALL FMSUB(MXY(12),MXY(22),MXY(17))
          CALL FMEQ(MXY(22),MXY(18))
          CALL FMMPY(MXY(20),MXY(22),MXY(12))
          CALL FMADD_R1(MXY(19),MXY(12))
          CALL FMEQ(MXY(16),MXY(14))
          CALL FMEQ(MXY(23),MXY(15))
          CALL FMADDI(MXY(15),1)
          DO J = 2, KASHIFT-1
             CALL FMADDI(MXY(14),1)
             CALL FMADDI(MXY(15),1)
             CALL FMMPY_R1(MXY(20),MXY(14))
             CALL FMDIV_R1(MXY(20),MXY(15))
             CALL FMMPY_R1(MXY(18),MXY(22))
             CALL FMMPY(MXY(20),MXY(18),MXY(13))
             CALL FMADD_R1(MXY(19),MXY(13))
          ENDDO
          IF (MWK(START(MXY(22))+2)*(-10) >= NDIG) THEN
              CALL FMEQ(MXY(22),MXY(15))
              CALL FMEQ(MXY(22),MXY(17))
              DO K = 2, NTERMS
                 CALL FMMPY_R1(MXY(15),MXY(22))
                 CALL FMDIVI(MXY(15),K,MXY(12))
                 CALL FMADD_R1(MXY(17),MXY(12))
                 IF (KFLAG /= 0) EXIT
              ENDDO
              CALL FMMPY(MXY(17),MXY(24),MXY(12))
              IF (MWK(START(MXY(12))+2) /= MUNKNO .AND. MWK(START(MXY(12))+3) /= 0)  &
                  MWK(START(MXY(12))) = -MWK(START(MXY(12)))
              CALL FMEXP(MXY(12),MXY(18))
              CALL FMEQ(MXY(19),MXY(15))
              CALL FMPWR(MXY(22),MXY(23),MXY(12))
              CALL FMMPY(MXY(19),MXY(12),MXY(7))
              CALL FMMPY(MXY(7),MXY(18),MXY(12))
              CALL FMDIV(MXY(12),MXY(23),MXY(19))
              IF (MWK(START(MXY(19))+2) == MUNKNO) THEN
                  CALL FMLN(MXY(22),MXY(12))
                  CALL FMMPY(MXY(23),MXY(12),MXY(19))
                  CALL FMLN(MXY(15),MXY(12))
                  CALL FMADD_R2(MXY(12),MXY(19))
                  CALL FMMPY(MXY(17),MXY(24),MXY(12))
                  CALL FMSUB_R1(MXY(19),MXY(12))
                  CALL FMLN(MXY(23),MXY(12))
                  CALL FMSUB_R2(MXY(19),MXY(12))
                  CALL FMEXP(MXY(12),MXY(19))
              ENDIF
          ELSE
              CALL FMPWR(MXY(22),MXY(23),MXY(12))
              CALL FMMPY_R1(MXY(19),MXY(12))
              CALL FMPWR(MXY(17),MXY(24),MXY(12))
              CALL FMMPY_R1(MXY(19),MXY(12))
              CALL FMDIV_R1(MXY(19),MXY(23))
          ENDIF
          CALL FMMPY(MXY(21),MXY(20),MXY(12))
          CALL FMI2M(KASHIFT-1,MXY(7))
          CALL FMADD_R2(MXY(16),MXY(7))
          CALL FMMPY_R1(MXY(12),MXY(7))
          CALL FMDIV(MXY(12),MXY(23),MXY(20))
          CALL FMADD(MXY(20),MXY(19),MXY(21))
      ENDIF

!             Reverse the translation if KBSHIFT is positive.
!             This is used when x is close to 1, b is small, and a retry was required because
!             of cancellation.

      IF (KBSHIFT > 0 .AND. MWK(START(MXY(21))+1) > 0) THEN
          CALL FMEQU(MX,MXY(22),NDSAVE,NDIG)
          CALL FMEQU(MA,MXY(23),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(24),NDSAVE,NDIG)
          CALL FMI2M(1,MXY(19))
          CALL FMI2M(1,MXY(12))
          CALL FMADD(MXY(24),MXY(12),MXY(7))
          CALL FMADD(MXY(23),MXY(24),MXY(12))
          CALL FMDIV(MXY(12),MXY(7),MXY(20))
          CALL FMADD(MXY(23),MXY(24),MXY(16))
          CALL FMI2M(1,MXY(12))
          CALL FMSUB(MXY(12),MXY(22),MXY(17))
          CALL FMEQ(MXY(17),MXY(18))
          CALL FMMPY(MXY(20),MXY(18),MXY(12))
          CALL FMADD_R1(MXY(19),MXY(12))
          CALL FMEQ(MXY(16),MXY(14))
          CALL FMEQ(MXY(24),MXY(15))
          CALL FMADDI(MXY(15),1)
          DO J = 2, KBSHIFT-1
             CALL FMADDI(MXY(14),1)
             CALL FMADDI(MXY(15),1)
             CALL FMMPY_R1(MXY(20),MXY(14))
             CALL FMDIV_R1(MXY(20),MXY(15))
             CALL FMMPY_R1(MXY(18),MXY(17))
             CALL FMMPY(MXY(20),MXY(18),MXY(13))
             CALL FMADD_R1(MXY(19),MXY(13))
          ENDDO
          IF (MWK(START(MXY(22))+2)*(-10) >= NDIG) THEN
              CALL FMEQ(MXY(22),MXY(15))
              CALL FMEQ(MXY(22),MXY(17))
              DO K = 2, NTERMS
                 CALL FMMPY_R1(MXY(15),MXY(22))
                 CALL FMDIVI(MXY(15),K,MXY(12))
                 CALL FMADD_R1(MXY(17),MXY(12))
                 IF (KFLAG /= 0) EXIT
              ENDDO
              CALL FMMPY(MXY(17),MXY(24),MXY(12))
              IF (MWK(START(MXY(12))+2) /= MUNKNO .AND. MWK(START(MXY(12))+3) /= 0)  &
                  MWK(START(MXY(12))) = -MWK(START(MXY(12)))
              CALL FMEXP(MXY(12),MXY(17))
              CALL FMPWR(MXY(22),MXY(23),MXY(12))
              CALL FMMPY(MXY(19),MXY(12),MXY(7))
              CALL FMMPY(MXY(7),MXY(17),MXY(12))
              CALL FMDIV(MXY(12),MXY(24),MXY(19))
          ELSE
              CALL FMPWR(MXY(22),MXY(23),MXY(12))
              CALL FMMPY_R1(MXY(19),MXY(12))
              CALL FMPWR(MXY(17),MXY(24),MXY(12))
              CALL FMMPY_R1(MXY(19),MXY(12))
              CALL FMDIV_R1(MXY(19),MXY(24))
          ENDIF
          CALL FMMPY(MXY(21),MXY(20),MXY(12))
          CALL FMI2M(KBSHIFT-1,MXY(7))
          CALL FMADD_R2(MXY(16),MXY(7))
          CALL FMMPY_R1(MXY(12),MXY(7))
          CALL FMDIV(MXY(12),MXY(24),MXY(20))
          CALL FMSUB(MXY(20),MXY(19),MXY(21))
      ENDIF
      IF (NCALL <= 1) THEN
          NGOAL = 1.06*(INT(REAL(NDSAVE)*ALOGM2) + 29)
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
      IF (MWK(START(MXY(21))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              IF (MWK(START(MXY(21))+3) == 0 .OR. K < 0) GO TO 190
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(21))+J+1)) GO TO 190
              ENDDO
              CALL FMI2M(1,MXY(15))
              MWK(START(MXY(21))+1) = MWK(START(MXY(15))+1)
              GO TO 200
          ENDIF
  190     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(21))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          IF (MWK(START(MXY(21))+1) < 0) NDIG = NDOLD + 10*2**NUMTRY
          IF (ABS(MWK(START(MX)+2)) >= MEXPOV .OR. ABS(MWK(START(MA)+2)) >= MEXPOV .OR.  &
              ABS(MWK(START(MB)+2)) >= MEXPOV) THEN
              CALL FMST2M('UNKNOWN',MXY(21))
              KFLAG = -4
              GO TO 200
          ENDIF
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQU_R1(MXY(2),NDSAVE,NDIG)
          CALL FMEQU_R1(MXY(3),NDSAVE,NDIG)
          IF (NMETHD == 3 .OR. NMETHD == 4 .OR. NMETHD == 6) THEN
              CALL FMEQU(MX,MXY(1),NDSAVE,NDIG)
              DO J = -1, NDIG+1
                 MLA = MWK(START(MXY(2))+J+1)
                 MWK(START(MXY(2))+J+1) = MWK(START(MXY(3))+J+1)
                 MWK(START(MXY(3))+J+1) = MLA
              ENDDO
          ENDIF

          IF (KASHIFT > 0) THEN
              CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
              IF (KASHIFT <= 2000) THEN
                  KASHIFT = 9*KASHIFT
              ELSE
                  KASHIFT = NDIG
              ENDIF
              CALL FMADDI(MXY(2),KASHIFT)
          ENDIF
          IF (KBSHIFT > 0) THEN
              CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
              IF (KBSHIFT <= 2000) THEN
                  KBSHIFT = 9*KBSHIFT
              ELSE
                  KBSHIFT = NDIG
              ENDIF
              CALL FMADDI(MXY(3),KBSHIFT)
          ENDIF

!             Check to see if a retry is about to be done for small a and large b.
!             If so, raise a by 2*NDIG to reduce the potential cancellation error.

          CALL FMI2M(200,MXY(12))
          IF (NUMTRY == 0 .AND. FMCOMP(MXY(2),'<=',MXY(12)) .AND. FMCOMP(MXY(3),'>=',MXY(2))) THEN
              KASHIFT = 2*NDIG
              CALL FMADDI(MXY(2),2*NDIG)
          ENDIF

!             Check to see if a retry is about to be done for a > 100 and b < 2.
!             If so, raise b by 2*NDIG to reduce the potential cancellation error.

          CALL FMI2M(100,MXY(12))
          CALL FMI2M(2,MXY(7))
          IF (NUMTRY == 0 .AND. FMCOMP(MXY(2),'>=',MXY(12)) .AND. FMCOMP(MXY(3),'<=',MXY(7))) THEN
              KBSHIFT = 2*NDIG
              CALL FMADDI(MXY(3),2*NDIG)
          ENDIF

          CALL FMI2M(40*NUMTRY,MXY(12))
          CALL FMI2M(100,MXY(7))
          IF (NUMTRY > 0 .AND. KASHIFT == 0 .AND. FMCOMP(MXY(2),'<=',MXY(12))  &
              .AND. FMCOMP(MXY(3),'>=',MXY(7))) THEN
              KASHIFT = 2*NDIG
              CALL FMADDI(MXY(2),2*NDIG)
          ENDIF

          CALL FMI2M(40*NUMTRY,MXY(12))
          CALL FMI2M(100,MXY(7))
          IF (NUMTRY > 0 .AND. KBSHIFT == 0 .AND. FMCOMP(MXY(2),'>=',MXY(12))  &
              .AND. FMCOMP(MXY(3),'<=',MXY(7))) THEN
              KBSHIFT = 2*NDIG
              CALL FMADDI(MXY(3),2*NDIG)
          ENDIF

          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(21),MRETRY,NDOLD,NDIG)
          IF (KASHIFT == 2*NDIG .OR. KBSHIFT == 2*NDIG) THEN
              NDIG = MAX(NDIG,NDOLD+2)
          ENDIF
          GO TO 120
      ENDIF

  200 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(21))+1) = MIN(MWK(START(MXY(21))+1),MACCX,MACCA,MACCB,MACMAX)
      MXEXP = MXSAVE
      CALL FMEQU(MXY(21),MXY(20),NDIG,NDSAVE)
      IF (KBIGAB /= 0) THEN
          IF ((MWK(START(MXY(20))+2) >= -MXSAVE  .AND. KBIGAB == -1) .OR.  &
              (MWK(START(MXY(20))+2) <= MXSAVE+1 .AND. KBIGAB ==  1) .OR. (KBIGAB == -9)) THEN
              CALL FMST2M('UNKNOWN',MXY(21))
              KFLAG = -4
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(21),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIBTA

      SUBROUTINE FMIBTA2(K_RETURN_CODE,MXY,MXSAVE,NTERMS,NUMTRY,NMETHD)

!  Check for various special cases in Incomplete Beta.

      USE FMVALS
      IMPLICIT NONE

      REAL (KIND(1.0D0)) :: MXSAVE
      INTEGER :: IEXTRA,J,J4,JR,JSWITCH,K,KRSAVE,K_RETURN_CODE,N,NDSAV1,NMETHD,NTERMS,NUMTRY,NUP
      INTEGER, PARAMETER :: KPRIME(8) = (/ 2, 3, 5, 7, 11, 13, 17, 19 /)
      LOGICAL, EXTERNAL :: FMCOMP
      INTEGER :: MXY(37),MJSUMS(LJSUMS)
      INTENT (INOUT) :: K_RETURN_CODE,MXY,MXSAVE,NTERMS,NUMTRY,NMETHD

      MJSUMS = -2
      K_RETURN_CODE = 0
      CALL FMI2M(0,MXY(32))
      NDSAV1 = NDIG

!             If B is small, use more guard digits.

      CALL FMDPM(1.0D-10,MXY(12))
      IF (FMCOMP(MXY(3),'<=',MXY(12))) THEN
          IEXTRA = NGRD52
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+IEXTRA)
          NDIG = NDIG + IEXTRA
      ENDIF

      NTERMS = INT(INTMAX/10)
      NMETHD = 0

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMI2M(0,MXY(21))
          K_RETURN_CODE = 1
          RETURN
      ENDIF
      CALL FMI2M(1,MXY(28))
      IF (FMCOMP(MXY(28),'==',MXY(1))) THEN
          IEXTRA = NGRD52
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+IEXTRA)
          NDIG = NDIG + IEXTRA
          CALL FMBETA(MXY(2),MXY(3),MXY(31))
          CALL FMEQ(MXY(31),MXY(21))
          K_RETURN_CODE = 1
          RETURN
      ELSE IF (MWK(START(MXY(1))) < 0 .OR. FMCOMP(MXY(1),'>',MXY(28))) THEN
          CALL FMST2M('UNKNOWN',MXY(21))
          KFLAG = -4
          K_RETURN_CODE = 2
          RETURN
      ENDIF
      IF (MWK(START(MXY(2))) < 0 .OR. MWK(START(MXY(2))+3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(21))
          KFLAG = -4
          K_RETURN_CODE = 2
          RETURN
      ENDIF
      IF (MWK(START(MXY(3))) < 0) THEN
          CALL FMST2M('UNKNOWN',MXY(21))
          KFLAG = -4
          K_RETURN_CODE = 2
          RETURN
      ENDIF
      JR = NUMTRY
      IF (MWK(START(MXY(2))+2) < (-NDIG) .AND. MWK(START(MXY(3))+2) < (-NDIG)) THEN
          CALL FMSUB(MXY(28),MXY(1),MXY(12))
          CALL FMLN(MXY(12),MXY(21))
          CALL FMDIV(MXY(28),MXY(2),MXY(12))
          CALL FMSUB(MXY(12),MXY(21),MXY(13))
          CALL FMPWR(MXY(1),MXY(2),MXY(12))
          CALL FMMPY(MXY(13),MXY(12),MXY(21))
          K_RETURN_CODE = 1
          RETURN
      ENDIF
      CALL FMI2M(1,MXY(12))
      CALL FMSUB(MXY(12),MXY(3),MXY(7))
      CALL FMMPY(MXY(1),MXY(7),MXY(12))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(12),MXY(28),MXY(7))
      KROUND = JR
      IF (FMCOMP(MXY(7),'==',MXY(28))) THEN
          CALL FMLN(MXY(1),MXY(12))
          CALL FMMPY(MXY(2),MXY(12),MXY(21))
          CALL FMLN(MXY(2),MXY(12))
          CALL FMSUB_R2(MXY(21),MXY(12))
          CALL FMEXP(MXY(12),MXY(21))
          K_RETURN_CODE = 2
          RETURN
      ENDIF

!             When A or B is large, check for an underflowed result.

      CALL FMDPM(1.0D+7,MXY(12))
      IF (FMCOMP(MXY(2),'>',MXY(12)) .OR. FMCOMP(MXY(3),'>',MXY(12))) THEN

!             If B is much larger than A, approximate BETA(A,B) and use that as an upper bound.

          IF (MWK(START(MXY(3))+2) >= MWK(START(MXY(2))+2)+NDIG) THEN
              CALL FMADD(MXY(3),MXY(2),MXY(12))
              CALL FMLN(MXY(12),MXY(23))
              CALL FMMPY_R2(MXY(2),MXY(23))
              CALL FMEQ(MXY(2),MXY(27))
              CALL FMLNGM(MXY(27),MXY(24))
              CALL FMSUB(MXY(24),MXY(23),MXY(12))
              CALL FMEXP(MXY(12),MXY(21))
              IF (MWK(START(MXY(21))+2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
          ENDIF

!             If A > 2 > B, use the bound
!                C = min( X , (A-2)/(A+B-2) )
!                BETA(X,A,B) < (A-1)*X/B * C**(A-2) * (1-C)**B
!
!             An alternate bound is also tried:
!                C = min( X , (A-1)/(A+B-2) )
!                BETA(X,A,B) < C**A * (1-C)**(1-B)

          CALL FMI2M(2,MXY(12))
          IF (FMCOMP(MXY(2),'>',MXY(12)) .AND. FMCOMP(MXY(3),'<',MXY(12))) THEN
              CALL FMI2M(2,MXY(6))
              CALL FMSUB(MXY(2),MXY(6),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(7))
              CALL FMSUB_R1(MXY(7),MXY(6))
              CALL FMDIV_R1(MXY(12),MXY(7))
              CALL FMMIN(MXY(1),MXY(12),MXY(23))
              CALL FMI2M(1,MXY(12))
              CALL FMSUB_R2(MXY(2),MXY(12))
              CALL FMLN(MXY(12),MXY(27))
              CALL FMLN(MXY(1),MXY(12))
              CALL FMADD_R1(MXY(27),MXY(12))
              CALL FMLN(MXY(3),MXY(12))
              CALL FMSUB_R1(MXY(27),MXY(12))
              CALL FMI2M(2,MXY(7))
              CALL FMSUB(MXY(2),MXY(7),MXY(21))
              CALL FMLN(MXY(23),MXY(12))
              CALL FMMPY_R2(MXY(21),MXY(12))
              CALL FMADD_R1(MXY(27),MXY(12))
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(7),MXY(23),MXY(12))
              CALL FMLN(MXY(12),MXY(21))
              CALL FMMPY(MXY(3),MXY(21),MXY(12))
              CALL FMADD_R1(MXY(27),MXY(12))
              CALL FMEXP(MXY(27),MXY(21))
              IF (MWK(START(MXY(21))+2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(2),MXY(7),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(7))
              CALL FMI2M(2,MXY(6))
              CALL FMSUB_R1(MXY(7),MXY(6))
              CALL FMDIV_R1(MXY(12),MXY(7))
              CALL FMMIN(MXY(1),MXY(12),MXY(23))
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(7),MXY(23),MXY(12))
              CALL FMLN(MXY(12),MXY(27))
              CALL FMSUB(MXY(3),MXY(7),MXY(6))
              CALL FMMPY_R2(MXY(6),MXY(27))
              CALL FMLN(MXY(1),MXY(12))
              CALL FMMPY_R2(MXY(2),MXY(12))
              CALL FMADD_R2(MXY(12),MXY(27))
              CALL FMEXP(MXY(27),MXY(21))
              IF (MWK(START(MXY(21))+2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
          ENDIF

!             If A > 2 and B > 2, use the bound
!                C = min( X , (A-1)/(A+B-2) )
!                BETA(X,A,B) < X * C**(A-1) * (1-C)**(B-1)

          CALL FMI2M(2,MXY(12))
          IF (FMCOMP(MXY(2),'>',MXY(12)) .AND. FMCOMP(MXY(3),'>',MXY(12))) THEN
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(2),MXY(7),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(7))
              CALL FMI2M(2,MXY(6))
              CALL FMSUB_R1(MXY(7),MXY(6))
              CALL FMDIV_R1(MXY(12),MXY(7))
              CALL FMMIN(MXY(1),MXY(12),MXY(23))
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(7),MXY(23),MXY(12))
              CALL FMLN(MXY(12),MXY(27))
              CALL FMSUB(MXY(3),MXY(7),MXY(6))
              CALL FMMPY_R2(MXY(6),MXY(27))
              CALL FMLN(MXY(23),MXY(12))
              CALL FMSUB(MXY(2),MXY(7),MXY(6))
              CALL FMMPY_R2(MXY(6),MXY(12))
              CALL FMADD_R2(MXY(12),MXY(27))
              CALL FMLN(MXY(1),MXY(12))
              CALL FMADD_R2(MXY(12),MXY(27))
              CALL FMEXP(MXY(27),MXY(21))
              IF (MWK(START(MXY(21))+2) <= -MXSAVE-1) THEN
                  K_RETURN_CODE = 2
                  RETURN
              ENDIF
          ENDIF
      ENDIF

!             Check for cases where X is large enough so that at this precision, B(X,A,B) = B(A,B).
!             These are often unstable, so it is better to use Beta.

      CALL FMI2M(1,MXY(12))
      CALL FMI2M(2,MXY(6))
      CALL FMADD(MXY(2),MXY(3),MXY(7))
      IF (FMCOMP(MXY(2),'>',MXY(12)) .AND. FMCOMP(MXY(7),'>',MXY(6))) THEN
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(2),MXY(7),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(7))
              CALL FMI2M(2,MXY(6))
              CALL FMSUB_R1(MXY(7),MXY(6))
              CALL FMDIV(MXY(12),MXY(7),MXY(31))
          CALL FMI2M(1,MXY(12))
          CALL FMADD(MXY(2),MXY(3),MXY(7))
          CALL FMADDI(MXY(7),-3)
          IF (FMCOMP(MXY(31),'<',MXY(12)) .AND. FMCOMP(MXY(1),'>',MXY(31)) .AND.  &
              MWK(START(MXY(7))+3) /= 0) THEN
              CALL FMI2M(1,MXY(7))
              CALL FMSUB(MXY(2),MXY(7),MXY(6))
              CALL FMSUB(MXY(3),MXY(7),MXY(12))
              CALL FMMPY_R2(MXY(6),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(6))
              CALL FMI2M(3,MXY(7))
              CALL FMSUB_R2(MXY(6),MXY(7))
              CALL FMDIV(MXY(12),MXY(7),MXY(30))
              IF (MWK(START(MXY(30))) >= 0) THEN
                  CALL FMI2M(1,MXY(7))
                  CALL FMSUB_R2(MXY(2),MXY(7))
                  CALL FMSQRT(MXY(30),MXY(12))
                  CALL FMADD(MXY(7),MXY(12),MXY(30))
                  CALL FMADD(MXY(2),MXY(3),MXY(7))
                  CALL FMI2M(2,MXY(6))
                  CALL FMSUB_R1(MXY(7),MXY(6))
                  CALL FMDIV_R1(MXY(30),MXY(7))
              ELSE
                  CALL FMDPM(DBLE(1.1),MXY(30))
              ENDIF
              CALL FMI2M(1,MXY(12))
              IF (FMCOMP(MXY(30),'>',MXY(31)) .AND. FMCOMP(MXY(30),'<',MXY(12)) .AND.  &
                  FMCOMP(MXY(1),'>=',MXY(30))) THEN

!                 Approximate B(A,B).

                  JR = KROUND
                  KROUND = 1
                  CALL FMADD(MXY(2),MXY(3),MXY(12))
                  KROUND = JR
                  IF (FMCOMP(MXY(12),'==',MXY(2))) THEN
                      CALL FMLN(MXY(3),MXY(12))
                      CALL FMDPM(0.5D0,MXY(7))
                      CALL FMSUB_R2(MXY(3),MXY(7))
                      CALL FMMPY(MXY(7),MXY(12),MXY(29))
                      CALL FMSUB_R1(MXY(29),MXY(3))
                      CALL FMDPM(DLOGTP/2.0D0,MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                      CALL FMLN(MXY(2),MXY(12))
                      CALL FMMPY_R2(MXY(3),MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                  ELSE IF (FMCOMP(MXY(12),'==',MXY(3))) THEN
                      CALL FMLN(MXY(2),MXY(12))
                      CALL FMDP2M(0.5D0,MXY(7))
                      CALL FMSUB_R2(MXY(2),MXY(7))
                      CALL FMMPY(MXY(7),MXY(12),MXY(29))
                      CALL FMSUB_R1(MXY(29),MXY(2))
                      CALL FMDPM(DLOGTP/2.0D0,MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                      CALL FMLN(MXY(3),MXY(12))
                      CALL FMMPY_R2(MXY(2),MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                  ELSE
                      CALL FMLN(MXY(2),MXY(12))
                      CALL FMDP2M(0.5D0,MXY(7))
                      CALL FMSUB_R2(MXY(2),MXY(7))
                      CALL FMMPY(MXY(7),MXY(12),MXY(29))
                      CALL FMLN(MXY(3),MXY(12))
                      CALL FMDP2M(0.5D0,MXY(7))
                      CALL FMSUB_R2(MXY(3),MXY(7))
                      CALL FMMPY_R2(MXY(7),MXY(12))
                      CALL FMADD_R1(MXY(29),MXY(12))
                      CALL FMADD(MXY(2),MXY(3),MXY(12))
                      CALL FMLN(MXY(12),MXY(7))
                      CALL FMDP2M(0.5D0,MXY(6))
                      CALL FMSUB_R2(MXY(12),MXY(6))
                      CALL FMMPY(MXY(6),MXY(7),MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                      CALL FMDPM(DLOGTP/2.0D0,MXY(12))
                      CALL FMSUB_R1(MXY(29),MXY(12))
                  ENDIF
                  CALL FMEXP(MXY(29),MXY(9))
                  CALL FMEQ(MXY(9),MXY(29))

!                 Bound the area from X to 1.

                  CALL FMI2M(1,MXY(12))
                  JR = KROUND
                  KROUND = 1
                  CALL FMSUB(MXY(12),MXY(1),MXY(7))
                  KROUND = JR
                  IF (FMCOMP(MXY(7),'==',MXY(12))) THEN
                      CALL FMLN(MXY(1),MXY(12))
                      CALL FMI2M(1,MXY(6))
                      CALL FMSUB(MXY(2),MXY(6),MXY(7))
                      CALL FMMPY(MXY(7),MXY(12),MXY(28))
                      CALL FMSUB(MXY(3),MXY(6),MXY(7))
                      CALL FMMPY(MXY(1),MXY(7),MXY(12))
                      CALL FMSUB_R1(MXY(28),MXY(12))
                      CALL FMSUB(MXY(6),MXY(1),MXY(12))
                      CALL FMDIVI_R1(MXY(12),2)
                      CALL FMLN(MXY(12),MXY(13))
                      CALL FMSUB_R1(MXY(28),MXY(13))
                  ELSE
                      CALL FMLN(MXY(1),MXY(12))
                      CALL FMI2M(1,MXY(6))
                      CALL FMSUB(MXY(2),MXY(6),MXY(7))
                      CALL FMMPY(MXY(7),MXY(12),MXY(28))
                      CALL FMSUB(MXY(3),MXY(6),MXY(7))
                      CALL FMSUB(MXY(6),MXY(1),MXY(12))
                      CALL FMLN(MXY(12),MXY(13))
                      CALL FMMPY_R2(MXY(7),MXY(13))
                      CALL FMADD_R1(MXY(28),MXY(13))
                      CALL FMDIVI_R1(MXY(12),2)
                      CALL FMLN(MXY(12),MXY(13))
                      CALL FMADD_R1(MXY(28),MXY(13))
                  ENDIF
                  CALL FMEXP(MXY(28),MXY(9))
                  CALL FMEQ(MXY(9),MXY(28))
                  JR = KROUND
                  KROUND = 1
                  CALL FMSUB(MXY(29),MXY(28),MXY(12))
                  KROUND = JR
                  IF (FMCOMP(MXY(12),'==',MXY(29))) THEN
                      CALL FMEQ(MXY(28),MXY(33))
                      CALL FMBETA(MXY(2),MXY(3),MXY(31))
                      JR = KROUND
                      KROUND = 1
                      CALL FMSUB(MXY(31),MXY(33),MXY(12))
                      KROUND = JR
                      IF (FMCOMP(MXY(12),'==',MXY(31))) THEN
                          MWK(START(MXY(31))+1) = 1.06*MWK(START(MXY(31))+1)
                          CALL FMEQ(MXY(31),MXY(21))
                          K_RETURN_CODE = 1
                          RETURN
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
      ELSE IF (MWK(START(MXY(2))+2) < 1 .AND. FMCOMP(MXY(3),'>',MXY(12))) THEN

!                 Approximate B(A,B).

          JR = KROUND
          KROUND = 1
          CALL FMADD(MXY(2),MXY(3),MXY(12))
          KROUND = JR
          IF (FMCOMP(MXY(12),'==',MXY(2))) THEN
              CALL FMLN(MXY(3),MXY(12))
              CALL FMDP2M(0.5D0,MXY(7))
              CALL FMSUB_R2(MXY(3),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(29))
              CALL FMSUB_R1(MXY(29),MXY(3))
              CALL FMDPM(DLOGTP/2.0D0,MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
              CALL FMLN(MXY(2),MXY(12))
              CALL FMMPY_R2(MXY(3),MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
          ELSE IF (FMCOMP(MXY(12),'==',MXY(3))) THEN
              CALL FMLN(MXY(2),MXY(12))
              CALL FMDP2M(0.5D0,MXY(7))
              CALL FMSUB_R2(MXY(2),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(29))
              CALL FMSUB_R1(MXY(29),MXY(2))
              CALL FMDPM(DLOGTP/2.0D0,MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
              CALL FMLN(MXY(3),MXY(12))
              CALL FMMPY_R2(MXY(2),MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
          ELSE
              CALL FMLN(MXY(2),MXY(12))
              CALL FMDP2M(0.5D0,MXY(7))
              CALL FMSUB_R2(MXY(2),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(29))
              CALL FMLN(MXY(3),MXY(12))
              CALL FMDP2M(0.5D0,MXY(7))
              CALL FMSUB_R2(MXY(3),MXY(7))
              CALL FMMPY_R2(MXY(7),MXY(12))
              CALL FMADD_R1(MXY(29),MXY(12))
              CALL FMADD(MXY(2),MXY(3),MXY(12))
              CALL FMLN(MXY(12),MXY(7))
              CALL FMDP2M(0.5D0,MXY(6))
              CALL FMSUB_R2(MXY(12),MXY(6))
              CALL FMMPY(MXY(6),MXY(7),MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
              CALL FMDPM(DLOGTP/2.0D0,MXY(12))
              CALL FMSUB_R1(MXY(29),MXY(12))
          ENDIF
          CALL FMEXP(MXY(29),MXY(9))
          CALL FMEQ(MXY(9),MXY(29))

!                 Bound the area from X to 1.

          CALL FMI2M(1,MXY(12))
          JR = KROUND
          KROUND = 1
          CALL FMSUB(MXY(12),MXY(1),MXY(7))
          KROUND = JR
          IF (FMCOMP(MXY(7),'==',MXY(12))) THEN
              CALL FMLN(MXY(1),MXY(12))
              CALL FMI2M(1,MXY(6))
              CALL FMSUB(MXY(2),MXY(6),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(28))
              CALL FMSUB(MXY(3),MXY(6),MXY(7))
              CALL FMMPY(MXY(1),MXY(7),MXY(12))
              CALL FMSUB_R1(MXY(28),MXY(12))
              CALL FMSUB(MXY(6),MXY(1),MXY(12))
              CALL FMDIVI_R1(MXY(12),2)
              CALL FMLN(MXY(12),MXY(13))
              CALL FMSUB_R1(MXY(28),MXY(13))
              CALL FMEXP(MXY(28),MXY(9))
              CALL FMEQ(MXY(9),MXY(28))
          ELSE
              CALL FMLN(MXY(1),MXY(12))
              CALL FMI2M(1,MXY(6))
              CALL FMSUB(MXY(2),MXY(6),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(28))
              CALL FMSUB(MXY(3),MXY(6),MXY(7))
              CALL FMSUB(MXY(6),MXY(1),MXY(12))
              CALL FMLN(MXY(12),MXY(13))
              CALL FMMPY_R2(MXY(7),MXY(13))
              CALL FMADD_R1(MXY(28),MXY(13))
              CALL FMDIVI_R1(MXY(12),2)
              CALL FMLN(MXY(12),MXY(13))
              CALL FMADD_R1(MXY(28),MXY(13))
              CALL FMEXP(MXY(28),MXY(9))
              CALL FMEQ(MXY(9),MXY(28))
          ENDIF
          JR = KROUND
          KROUND = 1
          CALL FMSUB(MXY(29),MXY(28),MXY(12))
          KROUND = JR
          IF (FMCOMP(MXY(12),'==',MXY(29))) THEN
              CALL FMBETA(MXY(2),MXY(3),MXY(31))
              MWK(START(MXY(31))+1) = 1.06*MWK(START(MXY(31))+1)
              CALL FMEQ(MXY(31),MXY(21))
              K_RETURN_CODE = 1
              RETURN
          ENDIF
      ENDIF

!             If B is small enough, use one of two series or an asymptotic series,
!             depending on the size of X and A.

      CALL FMI2M(1,MXY(6))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(6),MXY(3),MXY(7))
      CALL FMADD(MXY(2),MXY(3),MXY(12))
      KROUND = JR
      IF ((FMCOMP(MXY(7),'==',MXY(6)) .AND. FMCOMP(MXY(12),'==',MXY(2))) ) THEN
          CALL FMDP2M(0.5D0,MXY(12))
          IF (FMCOMP(MXY(1),'<=',MXY(12))) THEN
              CALL FMI2M(0,MXY(22))
              CALL FMEQ(MXY(1),MXY(23))
              CALL FMI2M(1,MXY(7))
              CALL FMADD(MXY(2),MXY(7),MXY(12))
              CALL FMDIV(MXY(23),MXY(12),MXY(24))
              CALL FMEQ(MXY(2),MXY(14))
              CALL FMADDI(MXY(14),1)
              NDSAV1 = NDIG
              DO J = 2, NTERMS
                 CALL FMADD_R1(MXY(22),MXY(24))
                 IF (KFLAG /= 0 .AND. J >= 3) EXIT
                 NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-  &
                                                         MWK(START(MXY(24))+2))+1))
                 CALL FMMPY_R1(MXY(23),MXY(1))
                 CALL FMADDI(MXY(14),1)
                 CALL FMDIV(MXY(23),MXY(14),MXY(24))
                 NDIG = NDSAV1
              ENDDO
              CALL FMPWR(MXY(1),MXY(2),MXY(12))
              CALL FMI2M(1,MXY(6))
              CALL FMDIV(MXY(6),MXY(2),MXY(7))
              CALL FMADD(MXY(7),MXY(22),MXY(6))
              CALL FMMPY(MXY(12),MXY(6),MXY(22))
              CALL FMEQ(MXY(22),MXY(21))
              K_RETURN_CODE = 1
              RETURN
          ENDIF
          CALL FMDP2M(0.5D0,MXY(12))
          CALL FMI2M(20,MXY(7))
          IF ((FMCOMP(MXY(1),'>',MXY(12)) .AND. FMCOMP(MXY(2),'<',MXY(7)))) THEN
              CALL FMI2M(0,MXY(22))
              CALL FMI2M(1,MXY(12))
              CALL FMSUB(MXY(12),MXY(1),MXY(25))
              CALL FMI2M(1,MXY(7))
              CALL FMADD(MXY(3),MXY(7),MXY(12))
              CALL FMPWR(MXY(25),MXY(12),MXY(23))
              CALL FMI2M(1,MXY(12))
              CALL FMSUB(MXY(12),MXY(2),MXY(7))
              CALL FMMPY_R2(MXY(7),MXY(23))

              CALL FMEQ(MXY(23),MXY(24))
              NDSAV1 = NDIG
              DO J = 2, NTERMS
                 CALL FMADD_R1(MXY(22),MXY(24))
                 IF (KFLAG /= 0 .AND. J >= 3) EXIT
                 NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-  &
                                                         MWK(START(MXY(24))+2))+1))
                 CALL FMI2M(J,MXY(7))
                 CALL FMSUB(MXY(7),MXY(2),MXY(12))
                 CALL FMMPY(MXY(23),MXY(12),MXY(7))
                 CALL FMMPY(MXY(7),MXY(25),MXY(12))
                 CALL FMDIVI(MXY(12),J,MXY(23))
                 CALL FMDIVI(MXY(23),J,MXY(24))
                 NDIG = NDSAV1
              ENDDO
              CALL FMLN(MXY(25),MXY(12))
              CALL FMI2M(1,MXY(7))
              CALL FMDIV(MXY(7),MXY(2),MXY(6))
              CALL FMSUB(MXY(6),MXY(12),MXY(7))
              CALL FMSUB(MXY(7),MXY(22),MXY(23))
              CALL FMEULR(MXY(24))
              CALL FMI2M(1,MXY(12))
              CALL FMADD(MXY(2),MXY(12),MXY(25))
              CALL FMPSI(MXY(25),MXY(11))
              CALL FMEQ(MXY(11),MXY(25))
              CALL FMSUB(MXY(23),MXY(24),MXY(12))
              CALL FMSUB(MXY(12),MXY(25),MXY(21))
              K_RETURN_CODE = 1
              RETURN
          ENDIF

          CALL FMDP2M(0.5D0,MXY(12))
          CALL FMI2M(20,MXY(7))
          IF ((FMCOMP(MXY(1),'>',MXY(12)) .AND. FMCOMP(MXY(2),'>=',MXY(7)))) THEN
              CALL FMSP2M(0.7*REAL(NDIG)*ALOGMT,MXY(28))
              IF (FMCOMP(MXY(2),'>=',MXY(28))) THEN
                  NUP = 0
                  CALL FMEQ(MXY(2),MXY(32))
                  CALL FMI2M(0,MXY(33))
              ELSE
                  CALL FMSUB(MXY(28),MXY(2),MXY(12))
                  CALL FMADDI(MXY(12),1)
                  CALL FMM2I(MXY(12),NUP)
                  CALL FMI2M(NUP,MXY(12))
                  CALL FMADD(MXY(2),MXY(12),MXY(32))
                  CALL FMI2M(1,MXY(33))
                  CALL FMEQ(MXY(2),MXY(23))
                  NDSAV1 = NDIG
                  DO J = 1, NUP-1
                     CALL FMMPY_R1(MXY(23),MXY(1))
                     CALL FMI2M(J,MXY(12))
                     CALL FMADD(MXY(2),MXY(12),MXY(7))
                     CALL FMDIV(MXY(23),MXY(7),MXY(24))
                     NDIG = NDSAV1
                     CALL FMADD_R1(MXY(33),MXY(24))
                     NDIG = MIN(NDSAV1,  &
                            MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(33))+2)-MWK(START(MXY(24))+2))+1))
                  ENDDO
                  NDIG = NDSAV1
                  CALL FMPWR(MXY(1),MXY(2),MXY(12))
                  CALL FMMPY(MXY(33),MXY(12),MXY(13))
                  CALL FMI2M(1,MXY(7))
                  CALL FMSUB(MXY(7),MXY(1),MXY(12))
                  CALL FMPWR(MXY(12),MXY(3),MXY(33))
                  CALL FMMPY_R2(MXY(13),MXY(33))
                  CALL FMDIV_R1(MXY(33),MXY(2))
              ENDIF

              CALL FMI2M(1,MXY(7))
              CALL FMDIVI(MXY(7),2,MXY(12))
              CALL FMSUB(MXY(32),MXY(12),MXY(29))
              CALL FMLN(MXY(1),MXY(12))
              CALL FMMPY(MXY(29),MXY(12),MXY(30))
              IF (MWK(START(MXY(30))+2) /= MUNKNO .AND. MWK(START(MXY(30))+3) /= 0)  &
                  MWK(START(MXY(30))) = -MWK(START(MXY(30)))
              CALL FMIGM2(MXY(3),MXY(30),MXY(31))
              CALL FMPWR(MXY(30),MXY(3),MXY(12))
              CALL FMEQ(MXY(30),MXY(13))
              IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
                  MWK(START(MXY(13))) = -MWK(START(MXY(13)))
              CALL FMEXP(MXY(13),MXY(7))
              CALL FMMPY(MXY(7),MXY(12),MXY(13))
              CALL FMDIV_R1(MXY(31),MXY(13))
              CALL FMEQ(MXY(31),MXY(22))
              CALL FMSQR(MXY(29),MXY(12))
              CALL FMMPYI(MXY(12),4,MXY(23))
              CALL FMI2M(1,MXY(24))
              CALL FMI2M(1,MXY(25))
              CALL FMI2M(1,MXY(26))
              CALL FMLN(MXY(1),MXY(12))
              CALL FMDIVI(MXY(12),2,MXY(7))
              CALL FMSQR(MXY(7),MXY(28))
              NDSAV1 = NDIG
              J4 = 0
              KRSAVE = KROUND
              KROUND = 1
              DO J = 1, NTERMS
                 JSWITCH = MAX(2,INT(NDIG*DLOGMB/(2.0D0*LOG(23.0)) + 2))
                 IF (J < JSWITCH) THEN
                     J4 = 0
                     CALL FMMPYI_R1(MXY(25),4)
                     CALL FMMPYI(MXY(26),2*J-1,MXY(12))
                     CALL FMMPYI(MXY(12),2*J,MXY(26))
                     CALL FMI2M(2,MXY(7))
                     CALL FMSUB(MXY(7),MXY(25),MXY(12))
                     CALL FMDIV(MXY(12),MXY(26),MXY(27))
                     CALL FMBERN(2*J,MXY(27),MXY(8))
                     CALL FMEQ(MXY(8),MXY(27))
                 ELSE
                     IF (J4 == 0) THEN
                         J4 = 1
                         N = 2*J
                         DO K = 1, 8
                            CALL FMI2M(KPRIME(K),MJSUMS(K))
                            CALL FMIPWR(MJSUMS(K),N,MXY(12))
                            CALL FMEQ(MXY(12),MJSUMS(K))
                         ENDDO
                     ELSE
                         DO K = 1, 8
                            CALL FMMPYI_R1(MJSUMS(K),KPRIME(K)**2)
                         ENDDO
                     ENDIF
                     CALL FMPI(MXY(18))
                     CALL FMI2M(1,MXY(14))
                     CALL FMI2M(1,MXY(15))
                     DO K = 1, 8
                        CALL FMEQ(MJSUMS(K),MXY(17))
                        CALL FMI2M(KPRIME(K)**2-1,MXY(12))
                        JR = KROUND
                        KROUND = 1
                        CALL FMSUB(MXY(17),MXY(14),MXY(7))
                        CALL FMDIV_R2(MXY(12),MXY(7))
                        CALL FMSUB(MXY(14),MXY(7),MXY(16))
                        KROUND = JR
                        CALL FMI2M(1,MXY(12))
                        IF (FMCOMP(MXY(16),'==',MXY(12))) EXIT
                        CALL FMMPY_R1(MXY(15),MXY(16))
                     ENDDO
                     CALL FMEQ(MJSUMS(1),MXY(17))
                     CALL FMI2M(-1,MXY(7))
                     CALL FMSQR(MXY(18),MXY(13))
                     CALL FMDIV(MXY(7),MXY(13),MXY(12))
                     CALL FMI2M(2,MXY(7))
                     CALL FMSUB(MXY(7),MXY(17),MXY(6))
                     CALL FMI2M(8,MXY(7))
                     CALL FMSUB_R1(MXY(7),MXY(17))
                     CALL FMDIV(MXY(6),MXY(7),MXY(13))
                     CALL FMMPY(MXY(12),MXY(13),MXY(7))
                     CALL FMMPY(MXY(7),MXY(15),MXY(16))
                     CALL FMMPY_R2(MXY(16),MXY(27))
                 ENDIF
                 CALL FMI2M(2*J-2,MXY(7))
                 CALL FMADD(MXY(3),MXY(7),MXY(12))
                 CALL FMMPY(MXY(12),MXY(31),MXY(7))
                 CALL FMMPYI(MXY(7),2*J-1,MXY(31))
                 CALL FMI2M(2*J-1,MXY(7))
                 CALL FMADD(MXY(30),MXY(7),MXY(12))
                 CALL FMMPY(MXY(24),MXY(12),MXY(7))
                 CALL FMADD_R1(MXY(31),MXY(7))
                 CALL FMDIV_R1(MXY(31),MXY(23))
                 CALL FMMPY_R1(MXY(24),MXY(28))
                 CALL FMMPY(MXY(27),MXY(31),MXY(19))
                 NDIG = NDSAV1
                 CALL FMADD_R1(MXY(22),MXY(19))
                 IF (KFLAG /= 0 .AND. J >= 3) EXIT
                 NDIG = MIN(NDSAV1,MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(22))+2)-  &
                                                         MWK(START(MXY(19))+2))+1))
              ENDDO
              KROUND = KRSAVE
              NDIG = NDSAV1
              CALL FMPWR(MXY(1),MXY(29),MXY(12))
              CALL FMLN(MXY(1),MXY(13))
              IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
                  MWK(START(MXY(13))) = -MWK(START(MXY(13)))
              CALL FMPWR(MXY(13),MXY(3),MXY(21))
              CALL FMMPY(MXY(22),MXY(12),MXY(7))
              CALL FMMPY_R2(MXY(7),MXY(21))
              CALL FMADD_R2(MXY(33),MXY(21))
              K_RETURN_CODE = 1
              RETURN
          ENDIF
      ENDIF

!             If A or B is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(2))+2)),INT(MWK(START(MXY(3))+2)),0) ,  &
                   INT(1.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(3),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA
      RETURN
      END SUBROUTINE FMIBTA2

      SUBROUTINE FMIBTA3(MX,MA,MB,MC,MXY,K_RETURN_CODE)

!  Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MX,MA,MB,MC
      INTEGER :: J,J1,J2,K,K1,K2,K_RETURN_CODE,KRSAVE,NDS,NDSAVE
      INTENT (IN) :: MX,MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(37)

      J = NTRACE
      NTRACE = 0
      K = KWARN
      KWARN = 0
      NDSAVE = NDIG
      KRSAVE = KROUND
      KROUND = 1
      CALL FMI2M(1,MXY(1))
      CALL FMSUB(MXY(1),MX,MXY(2))
      IF (MWK(START(MX)) < 0 .OR. MWK(START(MXY(2))) < 0 .OR. MWK(START(MA)) < 0 .OR.  &
          MWK(START(MB)) < 0) GO TO 110
      IF (KRSAVE /= 1 .AND. (MWK(START(MXY(2))+3) == 0 .OR. MWK(START(MX)+2) < -NDIG .OR.  &
                             MWK(START(MA)+2) < -NDIG .OR. MWK(START(MB)+2) < -NDIG)) THEN
          IF (MWK(START(MXY(2))+3) == 0) THEN
              KROUND = KRSAVE
              CALL FMBETA(MA,MB,MC)
              K_RETURN_CODE = 1
          ELSE IF (MWK(START(MX)+3) == 0) THEN
              KROUND = KRSAVE
              CALL FMI2M(0,MC)
              K_RETURN_CODE = 1
          ELSE
              NDIG = NDIG + NGRD52
              CALL FMEQU(MX,MXY(1),NDSAVE,NDIG)
              CALL FMEQU(MA,MXY(2),NDSAVE,NDIG)
              CALL FMEQU(MB,MXY(3),NDSAVE,NDIG)
              CALL FMI2M(1,MXY(4))
              CALL FMSUB(MXY(4),MXY(3),MXY(5))
              CALL FMMPY(MXY(1),MXY(5),MXY(6))
              CALL FMADD(MXY(2),MXY(4),MXY(7))
              CALL FMDIV(MXY(6),MXY(7),MXY(8))
              CALL FMDIV(MXY(4),MXY(2),MXY(9))
              IF (MWK(START(MXY(9))+2) - MWK(START(MXY(8))+2) > NDIG) THEN
                  CALL FMPWR(MXY(1),MXY(2),MXY(10))
                  IF (MWK(START(MXY(10))+2) > MEXPUN .AND. MWK(START(MXY(10))+2) < MEXPOV) THEN
                      CALL FMDIV(MXY(10),MXY(2),MXY(11))
                      CALL FMMPY(MXY(10),MXY(8),MXY(12))
                      IF (MWK(START(MA)+2) < -NDSAVE) THEN
                          CALL FMLN(MXY(1),MXY(13))
                          CALL FMADD_R1(MXY(12),MXY(13))
                          CALL FMEQU(MXY(9),MXY(5),NDIG,NDSAVE)
                          CALL FMEQU(MXY(13),MXY(6),NDIG,NDSAVE)
                          NDIG = NDSAVE
                          KROUND = KRSAVE
                          CALL FMADD(MXY(5),MXY(6),MC)
                          K_RETURN_CODE = 1
                      ELSE IF (MWK(START(MXY(11))+2) < MEXPOV) THEN
                          CALL FMEQU(MXY(11),MXY(5),NDIG,NDSAVE)
                          CALL FMEQU(MXY(5),MXY(13),NDSAVE,NDIG)
                          CALL FMSUB(MXY(11),MXY(13),MXY(8))
                          IF (MWK(START(MXY(8))+3) == 0) THEN
                              CALL FMEQU(MXY(12),MXY(6),NDIG,NDSAVE)
                              NDIG = NDSAVE
                              KROUND = KRSAVE
                              CALL FMADD(MXY(5),MXY(6),MC)
                              IF (MWK(START(MC)+2) == MUNKNO) THEN
                                  J1 = MWK(START(MXY(5))+2)
                                  K1 = MWK(START(MXY(6))+2)
                                  J2 = J1
                                  IF (J1 /= MEXPUN .AND. J1 < 0) J2 = J1 + 2*NDIG
                                  IF (J1 /= MEXPOV .AND. J1 > 0) J2 = J1 - 2*NDIG
                                  K2 = K1
                                  IF (K1 /= MEXPUN .AND. K1 < 0) K2 = K1 + 2*NDIG
                                  IF (K1 /= MEXPOV .AND. K1 > 0) K2 = K1 - 2*NDIG
                                  MWK(START(MXY(5))+2) = J2
                                  MWK(START(MXY(6))+2) = K2
                                  CALL FMADD(MXY(5),MXY(6),MC)
                                  K2 = MWK(START(MC)+2) - (J2 - J1) - (K2 - K1)
                                  IF (MWK(START(MC)+2) /= MUNKNO) MWK(START(MC)+2) = K2
                              ENDIF
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQU(MXY(11),MC,NDIG,NDSAVE)
                          ENDIF
                          K_RETURN_CODE = 1
                      ENDIF
                  ENDIF
              ENDIF
              IF (K_RETURN_CODE /= 1) THEN
                  CALL FMI2M(1,MXY(4))
                  CALL FMSUB(MXY(4),MXY(1),MXY(5))
                  CALL FMPWR(MXY(5),MXY(3),MXY(6))
                  CALL FMDIV(MXY(4),MXY(3),MXY(7))
                  CALL FMSUB(MXY(4),MXY(2),MXY(8))
                  CALL FMMPY(MXY(1),MXY(8),MXY(9))
                  CALL FMADD(MXY(3),MXY(4),MXY(10))
                  CALL FMDIV(MXY(9),MXY(10),MXY(11))
                  IF (MWK(START(MXY(6))+2) <= MEXPUN) THEN
                      NDIG = NDSAVE
                      KROUND = KRSAVE
                      CALL FMBETA(MA,MB,MC)
                      K_RETURN_CODE = 1
                  ELSE
                      CALL FMADD(MXY(7),MXY(11),MXY(12))
                      CALL FMMPY(MXY(6),MXY(12),MXY(8))
                      NDIG = NDSAVE
                      KROUND = KRSAVE
                      CALL FMBETA(MA,MB,MC)
                      IF (MWK(START(MC)+2) - MWK(START(MXY(8))+2) > NDIG) K_RETURN_CODE = 1
                  ENDIF
              ENDIF
          ENDIF
      ENDIF

  110 KFLAG = 0
      NTRACE = J
      KWARN = K
      NDIG = NDSAVE
      KROUND = KRSAVE
      IF (K_RETURN_CODE == 1) THEN
          IF (MWK(START(MC)+2) == MUNKNO .AND. MWK(START(MX)+2) /= MUNKNO .AND.  &
              MWK(START(MA)+2) /= MUNKNO .AND. MWK(START(MB)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIBTA'
              KFLAG = -4
              CALL FMWRN2
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MC)+2)) == MEXPOV .AND. ABS(MWK(START(MX)+2)) < MEXPOV .AND.  &
                   ABS(MWK(START(MA)+2))  < MEXPOV .AND. ABS(MWK(START(MB)+2)) < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIBTA'
              IF (MWK(START(MC)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MC)+2) == MEXPUN) KFLAG = -6
              CALL FMWRN2
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIBTA'
              CALL FMNTR(2,MX,MA,2,1)
              IF (ABS(NTRACE) >= 2 .AND. NCALL <= LVLTRC) THEN
                  NDS = NDIG
                  NDIG = NDSAVE
                  IF (NTRACE < 0) THEN
                      CALL FMNTRJ(MB,NDIG)
                  ELSE
                      CALL FMPRNT(MB)
                  ENDIF
                  NDIG = NDS
              ENDIF
              CALL FMNTR(1,MC,MC,1,1)
              NCALL = NCALL - 1
          ENDIF
      ENDIF
      RETURN
      END SUBROUTINE FMIBTA3

      SUBROUTINE FMIGM1(MA,MB,MC)

!  MC = Incomplete Gamma(MA,MB)

!  Integral from 0 to MB of e**(-t) * t**(MA-1)  dt.

!  This is (lower case) gamma(a,x).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      DOUBLE PRECISION :: FMDPLG,X,A,B,ERR,SMALL,BIG,TOL,T1,BIGJ,YT
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MAXE,MODA2,MXSAVE
      INTEGER :: IEXTRA,INTA,INTG,J,JEXTRA,JR,JTERMS,K,KASAVE,KFLAG1,KFLAGA,KFLAGI,KFLAGX,KFLGOK,  &
                 KL,KOVUN,KR_RETRY,KRESLT,K_RETURN_CODE,KRSAVE,KWRNSV,KXNEG,LESS,NDGOAL,NDIG2,     &
                 NDOLD,NDSAV1,NDSAV2,NDSAVE,NGOAL,NMETHD,NMNNDG,NMXDIF,NT,NTERMS,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: C,C1,C2,D,T,TLNB,Y
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(15),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0
      IF (MWK(START(MB)+3) == 0) GO TO 110

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. (MWK(START(MA)+2) < -NDIG .OR. MWK(START(MB)+2) < -NDIG)) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          NDSAVE = NDIG
          KRSAVE = KROUND
          KROUND = 1
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          CALL FMI2M(1,MXY(3))
          CALL FMADD(MXY(1),MXY(3),MXY(4))
          IF (MWK(START(MXY(1))+3) /= 0 .AND. MWK(START(MXY(4))+3) /= 0) THEN
              CALL FMDIV(MXY(2),MXY(4),MXY(6))
              CALL FMMPY(MXY(6),MXY(1),MXY(5))
              IF (MWK(START(MXY(3))+2) - MWK(START(MXY(5))+2) > NDIG) THEN
                  CALL FMPWR(MXY(2),MXY(1),MXY(6))
                  CALL FMDIV(MXY(6),MXY(1),MXY(7))
                  CALL FMEQU(MXY(7),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
                  CALL FMSUB(MXY(7),MXY(8),MXY(6))
                  IF (MWK(START(MXY(6))+3) == 0) THEN
                      CALL FMMPY(MXY(5),MXY(7),MXY(8))
                      CALL FMEQU(MXY(7),MXY(9),NDIG,NDSAVE)
                      CALL FMEQU(MXY(8),MXY(6),NDIG,NDSAVE)
                      NDIG = NDSAVE
                      KROUND = KRSAVE
                      CALL FMSUB(MXY(9),MXY(6),MC)
                      IF (MWK(START(MC)+2) == MUNKNO) THEN
                          CALL FMI2M(2,MXY(9))
                          CALL FMMOD(MA,MXY(9),MXY(8))
                          IF (MWK(START(MB)) < 0 .AND. MWK(START(MXY(8))+3) /= 0) THEN
                              IF (KRSAVE ==  2) KROUND = -1
                              IF (KRSAVE == -1) KROUND =  2
                          ENDIF
                          CALL FMI2M(1,MXY(8))
                          CALL FMSUB(MXY(8),MXY(5),MXY(6))
                          CALL FMMPY(MXY(7),MXY(6),MC)
                      ENDIF
                  ELSE
                      CALL FMSUB(MXY(3),MXY(5),MXY(6))
                      CALL FMMPY(MXY(6),MXY(7),MXY(8))
                      KROUND = KRSAVE
                      CALL FMEQU(MXY(8),MC,NDIG,NDSAVE)
                  ENDIF
                  K_RETURN_CODE = 1
              ENDIF
              IF (K_RETURN_CODE /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
                  CALL FMDIV(MXY(3),MXY(1),MXY(4))
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(6),MXY(5),NDSAVE,NDIG)
                  CALL FMSUB(MXY(4),MXY(5),MXY(6))
                  IF (MWK(START(MXY(6))+3) == 0) THEN
                      CALL FMI2M(0,MXY(5))
                      CALL FMSUB(MXY(5),MXY(2),MXY(6))
                      CALL FMEI(MXY(6),MXY(7))
                      CALL FMLN(MXY(2),MXY(8))
                      CALL FMSUB(MXY(7),MXY(8),MXY(9))
                      CALL FMEULR(MXY(10))
                      CALL FMSUB(MXY(9),MXY(10),MXY(11))
                      CALL FMPWR(MXY(2),MXY(1),MXY(5))
                      CALL FMMPY(MXY(5),MXY(11),MXY(12))
                      CALL FMADD(MXY(8),MXY(12),MXY(13))
                      CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                      CALL FMEQU(MXY(13),MXY(7),NDIG,NDSAVE)
                      NDIG = NDSAVE
                      KROUND = KRSAVE
                      CALL FMADD(MXY(6),MXY(7),MC)
                      K_RETURN_CODE = 1
                  ENDIF
              ENDIF
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMIGM1'
                  CALL FMNTR(2,MA,MB,2,1)
                  NCALL = NCALL - 1
              ENDIF
              IF (MWK(START(MC)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO .AND.  &
                  MWK(START(MB)+2) /= MUNKNO) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMIGM1'
                  KFLAG = -4
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ELSE IF (ABS(MWK(START(MC)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV .AND.  &
                       ABS(MWK(START(MB)+2))  < MEXPOV) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMIGM1'
                  IF (MWK(START(MC)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MC)+2) == MEXPUN) KFLAG = -6
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ENDIF
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMIGM1'
                  CALL FMNTR(1,MC,MC,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MC) == -1) TEMPV(MC) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

  110 CALL FMENT2('FMIGM1   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0

  120 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

  130 NTERMS = INT(INTMAX/10)

!             Check for special cases.

!             See if A is small enough so that the result is X**A/A.

      CALL FMI2M(1,MXY(5))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(1),MXY(5),MXY(4))
      KROUND = JR
      IF (FMCOMP(MXY(4),'==',MXY(5))) THEN
          CALL FMPWR(MXY(2),MXY(1),MXY(5))
          CALL FMDIV(MXY(5),MXY(1),MXY(13))
          IF (MWK(START(MXY(13))+2) /= MUNKNO) GO TO 200
      ENDIF

!             Check to see if X is large enough so that the result is Gamma(A).

      CALL FMI2M(1,MXY(5))
      CALL FMDIV(MXY(1),MXY(2),MXY(4))
      MWK(START(MXY(4))) = 1
      CALL FMDPM(DBLE(0.001),MXY(3))
      IF (FMCOMP(MXY(2),'>',MXY(5)) .AND. FMCOMP(MXY(4),'<=',MXY(3))) THEN
          CALL FMI2M(1,MXY(4))
          CALL FMSUB(MXY(1),MXY(4),MXY(5))
          CALL FMLN(MXY(2),MXY(6))
          CALL FMMPY(MXY(5),MXY(6),MXY(4))
          CALL FMSUB(MXY(4),MXY(2),MXY(6))
          CALL FMEXP(MXY(6),MXY(15))
          IF (MWK(START(MXY(15))+2) /= MUNKNO) THEN
              CALL FMGAM(MXY(1),MXY(14))
              CALL FMSUB_R1(MXY(14),MXY(15))
              IF (MWK(START(MXY(14))+2) > MWK(START(MXY(15))+2)+NDIG .AND.  &
                  MWK(START(MXY(14))+2) /= MUNKNO) THEN
                  CALL FMEQ(MXY(14),MXY(13))
                  GO TO 200
              ENDIF
          ENDIF
      ENDIF

!             A,X are double precision approximations to the two arguments to this function.
!             INTA = A if A is a small integer.  It is used to limit the number of terms used in
!                    the asymptotic series and in the continued fraction expansion.

      INTA = NTERMS
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(1),INTG)
      KFLAGI = KFLAG
      IF (KFLAG == 0) INTA = INTG
      CALL FMM2DP(MXY(1),A)
      KFLAGA = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          A = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) A = -A
          KFLAGA = 0
      ENDIF
      CALL FMM2DP(MXY(2),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(2))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(2))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      KWARN = KWRNSV

!             If A or X is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),INT(MWK(START(MXY(2))+2)),0) ,  &
                   INT(1.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
      ENDIF
      NDOLD = NDIG
      NDIG = NDIG + IEXTRA

!             KXNEG = 1 if X is negative and A is a positive integer.

      KXNEG = 0

!             MODA2 = MOD(A,2) when KXNEG is 1.

      MODA2 = 0

      IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(2))+2) == MEXPOV) THEN
          IF (MWK(START(MXY(1))+2) == MEXPOV .AND. MWK(START(MXY(1))) > 0) THEN
              IF (MWK(START(MXY(2))+3) == 0) THEN
                  CALL FMI2M(0,MXY(13))
                  GO TO 180
              ENDIF
              IF (MWK(START(MXY(2))+2) == MEXPOV .AND. MWK(START(MXY(2))) > 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(13))
                  KFLAG = -5
                  GO TO 180
              ELSE IF (MWK(START(MXY(2))) > 0) THEN
                  CALL FMI2M(1,MXY(13))
                  IF (FMCOMP(MXY(2),'<=',MXY(13))) THEN
                      CALL FMST2M('UNDERFLOW',MXY(13))
                      KFLAG = -6
                      GO TO 180
                  ELSE
                      CALL FMST2M('OVERFLOW',MXY(13))
                      KFLAG = -5
                      GO TO 180
                  ENDIF
              ENDIF
          ENDIF
          IF (MWK(START(MXY(2))+2) == MEXPOV .AND. MWK(START(MXY(2))) > 0) THEN
              CALL FMGAM(MXY(1),MXY(15))
              CALL FMEQ(MXY(15),MXY(13))
              GO TO 180
          ENDIF
          IF (MWK(START(MXY(2))+2) == MEXPOV .AND. MWK(START(MXY(2))) < 0 .AND.  &
              MWK(START(MXY(1))) > 0.AND. MWK(START(MXY(1))+3) > 0) THEN
              IF (MWK(START(MXY(1))+2) /= MEXPOV) THEN
                  CALL FMINT(MXY(1),MXY(12))
                  IF (FMCOMP(MXY(1),'==',MXY(12))) THEN
                      CALL FMI2M(2,MXY(9))
                      CALL FMMOD(MXY(12),MXY(9),MXY(5))
                      CALL FMEQ(MXY(5),MXY(9))
                      IF (MWK(START(MXY(9))+3) /= 0) THEN
                          CALL FMST2M('-OVERFLOW',MXY(13))
                          KFLAG = -5
                          GO TO 180
                      ELSE
                          CALL FMST2M('OVERFLOW',MXY(13))
                          KFLAG = -5
                          GO TO 180
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
          CALL FMST2M('UNKNOWN',MXY(13))
          KFLAG = -4
          GO TO 200
      ENDIF

      IF (MWK(START(MXY(1))+2) == MEXPUN .OR. MWK(START(MXY(2))+2) == MEXPUN) THEN
          CALL FMABS(MXY(1),MXY(4))
          CALL FMI2M(1,MXY(5))
          IF (FMCOMP(MXY(4),'<',MXY(5)) .AND. MWK(START(MXY(2))+2) == MEXPUN) THEN
              CALL FMST2M('UNKNOWN',MXY(13))
              KFLAG = -4
              GO TO 200
          ENDIF
          CALL FMABS(MXY(1),MXY(4))
          CALL FMI2M(1,MXY(5))
          IF (FMCOMP(MXY(4),'>=',MXY(5)) .AND. MWK(START(MXY(2))+2) == MEXPUN .AND.  &
              MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(2))) > 0) THEN
              CALL FMST2M('UNDERFLOW',MXY(13))
              KFLAG = -6
              GO TO 200
          ENDIF
      ENDIF

      IF (MWK(START(MXY(1))) < 0 .OR. MWK(START(MXY(1))+3) == 0) THEN
          CALL FMINT(MXY(1),MXY(12))
          IF (FMCOMP(MXY(1),'==',MXY(12))) THEN
              CALL FMST2M('UNKNOWN',MXY(13))
              KFLAG = -4
              GO TO 200
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))+3) == 0) THEN
          IF (MWK(START(MXY(1))) <= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(13))
              KFLAG = -4
              GO TO 200
          ELSE
              CALL FMI2M(0,MXY(13))
              GO TO 200
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))) < 0) THEN
          CALL FMINT(MXY(1),MXY(12))
          IF (FMCOMP(MXY(1),'==',MXY(12))) THEN
              KXNEG = 1
              CALL FMI2M(2,MXY(9))
              CALL FMMOD(MXY(12),MXY(9),MXY(5))
              CALL FMEQ(MXY(5),MXY(9))
              IF (MWK(START(MXY(9))+3) /= 0) MODA2 = 1
          ELSE
              CALL FMST2M('UNKNOWN',MXY(13))
              KFLAG = -4
              GO TO 200
          ENDIF
      ENDIF
      CALL FMMAX(MXY(1),MXY(2),MXY(5))
      CALL FMMIN(MXY(1),MXY(2),MXY(6))
      CALL FMDPM(1.0D6,MXY(3))
      CALL FMDPM(1.0D2,MXY(4))
      IF (FMCOMP(MXY(5),'>=',MXY(3)) .AND. FMCOMP(MXY(6),'>=',MXY(4))) THEN
          CALL FMI2M(1,MXY(5))
          CALL FMSUB(MXY(1),MXY(5),MXY(7))
          CALL FMMIN(MXY(7),MXY(2),MXY(8))
          CALL FMADDI(MXY(8),-1)
          CALL FMLN(MXY(8),MXY(5))
          CALL FMMPY(MXY(7),MXY(5),MXY(4))
          CALL FMSUB(MXY(4),MXY(8),MXY(5))
          CALL FMEXP(MXY(5),MXY(10))
          IF ((MWK(START(MXY(10))+2) == MEXPOV .AND. MWK(START(MXY(10))) > 0) .OR.  &
              MWK(START(MXY(10))+2) > MXSAVE+1) THEN
              CALL FMST2M('OVERFLOW',MXY(13))
              KFLAG = -5
              GO TO 180
          ENDIF
      ENDIF
      CALL FMI2M(1,MXY(5))
      IF (FMCOMP(MXY(1),'==',MXY(5)) .AND. MWK(START(MXY(2))+2) >= 0) THEN
          IF (ABS(MWK(START(MXY(2))+2)) < MEXPOV) THEN
              CALL FMEQ(MXY(2),MXY(6))
              IF (MWK(START(MXY(6))+2) /= MUNKNO .AND. MWK(START(MXY(6))+3) /= 0)  &
                  MWK(START(MXY(6))) = -MWK(START(MXY(6)))
              CALL FMEXP(MXY(6),MXY(7))
              CALL FMSUB(MXY(5),MXY(7),MXY(13))
              IF (MWK(START(MXY(13))+2) /= MUNKNO) GO TO 200
          ENDIF
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion.

      CALL FMI2M(-10000,MXY(8))
      CALL FMI2M(10000,MXY(9))
      CALL FMABS(MXY(1),MXY(11))
      CALL FMABS(MXY(2),MXY(12))
      CALL FMSUB(MXY(12),MXY(11),MXY(10))

!             Check whether the smallest term in the asymptotic series is small enough to give
!             the required accuracy.

      IF (KFLAGA /= 0 .OR. KFLAGX /= 0) THEN
          CALL FMDIV(MXY(12),MXY(11),MXY(10))
          CALL FMI2M(1,MXY(8))
          CALL FMSUB(MXY(8),MXY(10),MXY(9))
          IF (MWK(START(MXY(9))) < 0) THEN
              NMETHD = 2
          ELSE
              NMETHD = 1
          ENDIF
      ELSE
          T1 = FMDPLG(A)
          SMALL = T1 - FMDPLG(-ABS(X)) - (A+ABS(X))*LOG(ABS(X))
          TOL = -DBLE(NDIG+2)*DLOGMB - 12.0D0
          B = 1.0D0
          IF (A > ABS(X)) B = A - ABS(X)
          BIG = T1 - FMDPLG(A-B) - B*LOG(ABS(X))

          IF (FMCOMP(MXY(10),'<=',MXY(8))) THEN
              NMETHD = 1
          ELSE IF (FMCOMP(MXY(10),'>=',MXY(9)) .AND. MWK(START(MXY(1))) > 0  &
                   .AND. MWK(START(MXY(2))) > 0) THEN
              NMETHD = 3
              IF (SMALL < TOL+BIG) NMETHD = 2
          ELSE IF (FMCOMP(MXY(10),'>=',MXY(9))) THEN
              NMETHD = 3
          ELSE IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(2))) > 0) THEN
              CALL FMDP2M(SQRT(DPMAX),MXY(8))
              IF (FMCOMP(MXY(2),'>=',MXY(8))) THEN
                  KFLAG = -5
                  CALL FMST2M('OVERFLOW',MXY(13))
                  GO TO 180
              ENDIF

              C2 = REAL(DBLE(NDSAVE)*DLOGMB)
              C1 = REAL(DBLE(C2)/10.0D0 + A + 10.0D0)
              C2 = REAL(MAX( 10.0D0 , DBLE(C2)/6.0D0 , A - 3.5D0*A/(SQRT(A)+1.0D0)))
              IF (X < C1) THEN
                  NMETHD = 1
              ELSE
                  NMETHD = 3
              ENDIF
              IF (X > C2) THEN
                  NMETHD = 3
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
          ELSE IF (MWK(START(MXY(1))) < 0 .AND. MWK(START(MXY(2))) > 0) THEN
              TLNB = REAL(NDIG)*ALOGMB
              C = 0.75/TLNB**0.35
              D = 0.80*TLNB**0.70
              IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                  T = REAL(-A) - D/C
                  Y = D + C*T/2.0 + (C/2.0)*SQRT(T**2 + T + (2.0/C)**2)
                  IF (X > Y) THEN
                      NMETHD = 3
                  ELSE
                      NMETHD = 1
                  ENDIF
              ELSE
                  CALL FMDPM(DBLE(C),MXY(5))
                  CALL FMMPY(MXY(5),MXY(1),MXY(8))
                  MWK(START(MXY(8))) = 1
                  IF (FMCOMP(MXY(2),'>',MXY(8))) THEN
                      NMETHD = 3
                  ELSE
                      NMETHD = 1
                  ENDIF
              ENDIF
          ELSE IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(2))) < 0) THEN
              CALL FMDPM(DBLE(-0.8),MXY(5))
              CALL FMMPY(MXY(5),MXY(1),MXY(8))
              IF (FMCOMP(MXY(8),'<',MXY(2))) THEN
                  NMETHD = 1
              ELSE
                  NMETHD = 3
              ENDIF
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150
      IF (NMETHD == 3) GO TO 170

!             Method 1.  Use the X**N/Pochhammer(A+1,N) series.

!             MXY(13) is the current sum.
!             MXY(9) is the current term.
!             MXY(8) is (A+N)/X.
!             MXY(14) is 1/X

!             Raise the precision if A is negative and near an integer, to compensate
!             for cancellation when (A+N)/X is near zero.

      IF (MWK(START(MXY(1))) < 0) THEN
          CALL FMNINT(MXY(1),MXY(13))
          CALL FMSUB(MXY(1),MXY(13),MXY(14))
          IEXTRA = MAX(-INT(MWK(START(MXY(14))+2)),0)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
      ENDIF

      JEXTRA = 0

  140 CALL FMI2M(1,MXY(13))
      CALL FMI2M(1,MXY(7))
      CALL FMADD(MXY(1),MXY(7),MXY(8))
      CALL FMDIV(MXY(2),MXY(8),MXY(9))
      CALL FMDIV_R1(MXY(8),MXY(2))
      CALL FMDIV(MXY(7),MXY(2),MXY(14))
      NDSAV1 = NDIG
      MAXE = 1

!             If A is negative and ABS(A) > ABS(X), the terms in the series first decrease,
!             then increase, then decrease.  Try to predict the number of extra digits required
!             to keep the precision from prematurely becoming too small.

      KFLGOK = 1
      IF (MWK(START(MXY(1))) < 0) THEN
          IF (KFLAGA == 0) THEN
              IF (ABS(A) > 1.0D3) THEN
                  NMETHD = 3
                  GO TO 170
              ENDIF
          ELSE
              NMETHD = 3
              GO TO 170
          ENDIF
          KFLGOK = 0
          CALL FMABS(MXY(1),MXY(3))
          CALL FMABS(MXY(2),MXY(4))
          IF (FMCOMP(MXY(3),'>',MXY(4))) THEN
              IF (JEXTRA == 0) THEN
                  IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                      T1 = FMDPLG(A+AINT(-ABS(X)-A)) - FMDPLG(A+1.0D0+AINT(ABS(X)-A))
                      T1 = (T1 + 2.0D0*ABS(X)*LOG(ABS(X)+1.0D-10))/DLOGMB
                      T1 = MAX(0.0D0,T1+1.0D0)
                      JEXTRA = T1
                  ENDIF
              ENDIF

!             If A is negative and ABS(A) is much bigger than ABS(X), the later increase in
!             the size of the terms can be ignored.

              IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                  T1 = (AINT(X-A)*LOG(ABS(X)+1.0D-10) + FMDPLG(A+1.0D0)  &
                       - FMDPLG(A+1.0D0+AINT(X-A))) / DLOGMB
                  IF (T1 < -DBLE(NDIG)) KFLGOK = 1
              ELSE
                  KFLGOK = 1
              ENDIF
          ENDIF
      ENDIF

      NMNNDG = NDSAV1
      NMXDIF = 0

!             Method 1 summation loop.

      DO J = 1, NTERMS
         NDIG = NDSAV1
         MAXE = MAX(MAXE,MWK(START(MXY(9))+2))
         CALL FMADD_R1(MXY(13),MXY(9))
         IF (KFLAG /= 0) THEN
             IF (KFLGOK == 0 .AND. KFLAGA == 0 .AND. KFLAGX == 0) THEN
                 IF (DBLE(J) > X-A) EXIT
             ELSE
                 EXIT
             ENDIF
         ENDIF

         CALL FMADD_R1(MXY(8),MXY(14))

         NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(13))+2)-MWK(START(MXY(9))+2)))
         NDIG = MIN(NDSAV1,NDIG2+JEXTRA)
         NMNNDG = MIN(NMNNDG,NDIG)
         NMXDIF = MAX(NMXDIF,NDIG-NMNNDG)
         CALL FMDIV_R1(MXY(9),MXY(8))
      ENDDO

      NDIG = NDSAV1
      IF (NMXDIF > JEXTRA+1) THEN
          JEXTRA = NMXDIF
          GO TO 140
      ENDIF

      CALL FMABS(MXY(2),MXY(5))
      CALL FMLN(MXY(5),MXY(6))
      CALL FMMPY(MXY(1),MXY(6),MXY(4))
      CALL FMSUB(MXY(4),MXY(2),MXY(14))
      CALL FMEXP(MXY(14),MXY(15))
      IF (MWK(START(MXY(15))+2) == MUNKNO) THEN
          CALL FMPWR(MXY(5),MXY(1),MXY(4))
          CALL FMEXP(MXY(2),MXY(6))
          CALL FMDIV(MXY(4),MXY(6),MXY(15))
      ENDIF
      CALL FMDIV(MXY(13),MXY(1),MXY(12))
      CALL FMMPY(MXY(15),MXY(12),MXY(11))
      IF (MWK(START(MXY(11))+2) == MUNKNO) THEN
          CALL FMLN(MXY(13),MXY(5))
          CALL FMLN(MXY(1),MXY(6))
          CALL FMADD(MXY(14),MXY(5),MXY(4))
          CALL FMSUB(MXY(4),MXY(6),MXY(14))
          CALL FMEXP(MXY(14),MXY(13))
      ELSE
          CALL FMEQ(MXY(11),MXY(13))
      ENDIF
      IF (KXNEG == 1 .AND. MODA2 == 1 .AND. MWK(START(MXY(13))+2) /= MUNKNO  &
          .AND. MWK(START(MXY(13))+3) /= 0) THEN
          MWK(START(MXY(13))) = -MWK(START(MXY(13)))
      ENDIF

      GO TO 180

!             Method 2.  Use the Pochhammer(A-N,N)/X**N series.

!             MXY(13) is the current sum.
!             MXY(9) is the current term.
!             MXY(8) is (A-N)/X.
!             MXY(14) is -1/X

!             Raise the precision if A is positive and near an integer, to compensate for
!             cancellation when (A-N)/X is near zero.

  150 IF (MWK(START(MXY(1))) > 0) THEN
          CALL FMNINT(MXY(1),MXY(13))
          CALL FMSUB(MXY(1),MXY(13),MXY(14))
          IEXTRA = MAX(-INT(MWK(START(MXY(14))+2)),0)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
      ENDIF

      CALL FMGAM(MXY(1),MXY(15))
      IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
          NT = INT(((A-1)*LOG(ABS(X)+1.0D-10) - X)/DLOGMB)
          LESS = MAX(0,INT(MWK(START(MXY(15))+2)) - NT - 1)
          IF (LESS > NDIG .AND. ABS(A) < ABS(X)) THEN
              CALL FMEQ(MXY(15),MXY(13))
              GO TO 180
          ENDIF
      ENDIF
      IF (KFLAG /= 0) THEN
          CALL FMEQ(MXY(15),MXY(13))
          GO TO 180
      ENDIF
      IF (KXNEG == 0) THEN
          CALL FMLN(MXY(2),MXY(14))
          CALL FMMPY(MXY(1),MXY(14),MXY(5))
          CALL FMSUB(MXY(5),MXY(2),MXY(13))
          CALL FMSUB_R2(MXY(13),MXY(14))
          CALL FMEXP(MXY(14),MXY(9))
      ELSE
          CALL FMI2M(1,MXY(5))
          CALL FMSUB(MXY(1),MXY(5),MXY(13))
          CALL FMPWR(MXY(2),MXY(13),MXY(14))
          CALL FMEXP(MXY(2),MXY(12))
          CALL FMDIV(MXY(14),MXY(12),MXY(9))
      ENDIF

!             Here MXY(9) is X**(A-1)/EXP(X).

      IF (MWK(START(MXY(9))+2) /= MUNKNO .AND. MWK(START(MXY(9))+3) /= 0)  &
          MWK(START(MXY(9))) = -MWK(START(MXY(9)))
      CALL FMEQ(MXY(15),MXY(13))
      CALL FMDIV(MXY(1),MXY(2),MXY(8))
      CALL FMI2M(1,MXY(5))
      CALL FMDIV(MXY(5),MXY(2),MXY(14))
      IF (MWK(START(MXY(14))+2) /= MUNKNO .AND. MWK(START(MXY(14))+3) /= 0)  &
          MWK(START(MXY(14))) = -MWK(START(MXY(14)))
      NDSAV1 = NDIG

!             Disable NDIG reduction until the terms in the sum begin to decrease in size.

      BIGJ = 0
      IF (KFLAGA == 0 .AND. KFLAGX == 0) BIGJ = ABS(A) - ABS(X)
      JTERMS = NTERMS
      IF (KFLAGI == 0 .AND. INTA > 0) THEN
          JTERMS = INTA
      ELSE IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
          T1 = A + ABS(X)
          IF (T1 > 0 .AND. T1 < DBLE(NTERMS)) JTERMS = INT(T1) + 2
      ENDIF

!             Method 2 summation loop.

      DO J = 1, JTERMS
         NDIG = NDSAV1
         CALL FMADD_R1(MXY(13),MXY(9))
         IF (KFLAG /= 0 .AND. J > 1) GO TO 160
         CALL FMADD_R1(MXY(8),MXY(14))
         IF (REAL(J) >= BIGJ) THEN
             NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(13))+2)-MWK(START(MXY(9))+2)))
             NDIG = MIN(NDSAV1,NDIG2)
         ENDIF
         CALL FMMPY_R1(MXY(9),MXY(8))
      ENDDO

  160 NDIG = NDSAV1
      GO TO 180

!             Method 3.  Use the continued fraction expansion.

!             MXY(14) is the current approximation.
!             MXY(13) is the term in the sum, S(k).
!             MXY(11), MXY(12) are the latest denominators, Q(k-1) and Q(k).

  170 CALL FMGAM(MXY(1),MXY(15))
      NDSAV1 = NDIG
      IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
          YT = MIN(DBLE(HUGE(1))/11,AINT(((A-1)*LOG(ABS(X)+1.0D-10) - X)/DLOGMB))
          NT = HUGE(1)/10
          NT = MIN(DBLE(NT),YT)
          LESS = MAX(0,INT(MWK(START(MXY(15))+2)) - NT - 1)
          IF (LESS > NDIG) THEN
              CALL FMEQ(MXY(15),MXY(13))
              GO TO 180
          ENDIF
          NDIG = MIN(NDSAV1,MAX(NGRD22,NDIG-LESS))
      ENDIF
      JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0))
      IF (NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA)
          CALL FMEQU_R1(MXY(2),NDSAV1,NDSAV1+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      CALL FMEQU(MXY(1),MXY(8),NDSAV1,NDIG)
      IF (MWK(START(MXY(8))+2) /= MUNKNO .AND. MWK(START(MXY(8))+3) /= 0)  &
          MWK(START(MXY(8))) = -MWK(START(MXY(8)))
      CALL FMI2M(1,MXY(11))
      CALL FMEQU(MXY(2),MXY(12),NDSAV1,NDIG)
      CALL FMI2M(1,MXY(5))
      CALL FMDIV(MXY(5),MXY(12),MXY(13))
      CALL FMEQ(MXY(13),MXY(14))

!             Method 3 continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, MIN(NTERMS,INTA-1)
         CALL FMADDI(MXY(8),1)
         CALL FMMPY(MXY(8),MXY(11),MXY(10))
         CALL FMADD(MXY(12),MXY(10),MXY(9))
         CALL FMMPY(MXY(10),MXY(13),MXY(6))
         CALL FMDIV(MXY(6),MXY(9),MXY(13))
         IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
             MWK(START(MXY(13))) = -MWK(START(MXY(13)))
         NDIG = NDSAV2
         CALL FMADD_R1(MXY(14),MXY(13))
         KFLAG1 = KFLAG
         CALL FMEQ(MXY(12),MXY(11))
         CALL FMEQ(MXY(9),MXY(12))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(13))+2))))
         CALL FMMPYI(MXY(11),J,MXY(10))
         CALL FMMPY(MXY(2),MXY(12),MXY(6))
         CALL FMADD(MXY(6),MXY(10),MXY(9))
         CALL FMMPY(MXY(10),MXY(13),MXY(6))
         CALL FMDIV(MXY(6),MXY(9),MXY(13))
         IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
             MWK(START(MXY(13))) = -MWK(START(MXY(13)))
         NDIG = NDSAV2
         CALL FMADD_R1(MXY(14),MXY(13))

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(12),MXY(11))
         CALL FMEQ(MXY(9),MXY(12))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(13))+2))))
      ENDDO

      NDIG = NDSAV2
      CALL FMEQU_R1(MXY(14),NDIG,NDSAV1)
      NDIG = NDSAV1
      IF (MWK(START(MXY(2))) > 0) THEN
          CALL FMLN(MXY(2),MXY(5))
          CALL FMMPY(MXY(1),MXY(5),MXY(4))
          CALL FMSUB(MXY(4),MXY(2),MXY(5))
          CALL FMEXP(MXY(5),MXY(12))
      ELSE IF (KFLAGI == 0) THEN
          CALL FMEXP(MXY(2),MXY(13))
          CALL FMIPWR(MXY(2),INTA,MXY(5))
          CALL FMDIV(MXY(5),MXY(13),MXY(12))
      ELSE
          CALL FMABS(MXY(2),MXY(5))
          CALL FMLN(MXY(5),MXY(6))
          CALL FMMPY(MXY(1),MXY(6),MXY(4))
          CALL FMSUB(MXY(4),MXY(2),MXY(5))
          CALL FMEXP(MXY(5),MXY(12))
          IF (MODA2 == 1 .AND. MWK(START(MXY(12))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(12))+3) /= 0) MWK(START(MXY(12))) = -MWK(START(MXY(12)))
      ENDIF

      IF (MWK(START(MXY(12))+2) /= MEXPOV) THEN
          CALL FMMPY(MXY(12),MXY(14),MXY(13))
      ELSE IF (MWK(START(MXY(12))+2)+MWK(START(MXY(14))+2) >= MXEXP2/2) THEN
          CALL FMEQ(MXY(12),MXY(13))
          IF (MWK(START(MXY(14))) < 0 .AND. MWK(START(MXY(13))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(13))+3) /= 0) MWK(START(MXY(13))) = -MWK(START(MXY(13)))
      ELSE
          CALL FMMPY(MXY(12),MXY(14),MXY(13))
      ENDIF
      CALL FMSUB_R2(MXY(15),MXY(13))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  180 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(13))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(13))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(13))+J+1)) GO TO 190
              ENDDO
              GO TO 200
          ENDIF
  190     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(13))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQU_R1(MXY(2),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(13),MRETRY,NDOLD,NDIG)
          GO TO 130
      ENDIF

  200 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(13))+1) = MIN(MWK(START(MXY(13))+1),MACCA,MACCB,MACMAX)
      CALL FMEXT2(MXY(13),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIGM1

      SUBROUTINE FMIGM2(MA,MB,MC)

!  MC = Incomplete Gamma(MA,MB)

!  Integral from MB to infinity of e**(-t) * t**(MA-1)  dt.

!  This is (upper case) Gamma(a,x).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      DOUBLE PRECISION :: FMDPLG,X,A,B,ERR,SMALL,BIG,TOL,T1,T2,BIGJ,C1,C2
      REAL (KIND(1.0D0)) :: MACCA,MACCB,MACMAX,MAS,MAXM09,MBS,MODA2,MXSAVE
      INTEGER :: IEXTRA,INTA,INTG,J,JEXTRA,JR,JTERMS,K,KABIGR,KASAVE,KFLAG1,KFLAGA,KFLAGI,KFLAGX,  &
                 KFLGOK,KL,KMETH4,KOVUN,KR_RETRY,KRESLT,KRSAVE,KWRNSV,KXNEG,N,NDGOAL,NDIG2,NDOLD,  &
                 NDSAV1,NDSAV2,NDSAVE,NGOAL,NMETHD,NMNNDG,NTERMS,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      INTEGER :: MXY(20),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MB)) > 0 .AND. MWK(START(MA)+3) /= 0 .AND.   &
          MWK(START(MB)+2) < -NDIG - NGRD52) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          NDSAVE = NDIG
          KRSAVE = KROUND
          KROUND = 1
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
          CALL FMGAM(MXY(1),MXY(3))
          IF (MWK(START(MXY(3))+2) /= MUNKNO) THEN
              CALL FMIGM1(MXY(1),MXY(2),MXY(4))
              KROUND = KRSAVE
              CALL FMSUB(MXY(3),MXY(4),MXY(5))
              IF (MWK(START(MXY(5))+3) == 0 .OR.  &
                  MWK(START(MXY(5))+2) < MWK(START(MXY(3))+2)-NGRD52) THEN
                  KFLAG = 0
                  NTRACE = J
                  KWARN = K
                  NDIG = NDSAVE
                  GO TO 110
              ENDIF
          ELSE
              CALL FMM2I(MXY(1),KL)
              CALL FMIPWR(MXY(2),KL,MXY(4))
              IF (MWK(START(MXY(4))+2) /= MEXPOV) THEN
                  CALL FMDIVI_R1(MXY(4),-KL)
              ENDIF
              CALL FMTINY(MXY(5))
              KROUND = KRSAVE
              CALL FMSUB_R2(MXY(4),MXY(5))
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          CALL FMEQU(MXY(5),MC,NDIG,NDSAVE)
          NDIG = NDSAVE
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIGM2'
              CALL FMNTR(2,MA,MB,2,1)
              NCALL = NCALL - 1
          ENDIF
          IF (MWK(START(MC)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO .AND.  &
              MWK(START(MB)+2) /= MUNKNO) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIGM2'
              KFLAG = -4
              CALL FMWRN2
              NCALL = NCALL - 1
          ELSE IF (ABS(MWK(START(MC)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV .AND.  &
                   ABS(MWK(START(MB)+2))  < MEXPOV) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIGM2'
              IF (MWK(START(MC)+2) == MEXPOV) KFLAG = -5
              IF (MWK(START(MC)+2) == MEXPUN) KFLAG = -6
              CALL FMWRN2
              NCALL = NCALL - 1
          ENDIF
          IF (NTRACE /= 0) THEN
              NCALL = NCALL + 1
              NAMEST(NCALL) = 'FMIGM2'
              CALL FMNTR(1,MC,MC,1,1)
              NCALL = NCALL - 1
          ENDIF
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

  110 CALL FMENT2('FMIGM2   ',MA,MB,2,1,MC,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MC) == -1) TEMPV(MC) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MAS = MWK(START(MA))
      MBS = MWK(START(MB))
      MACCA = MWK(START(MA)+1)
      MACCB = MWK(START(MB)+1)
      KR_RETRY = 0

  120 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQU(MB,MXY(2),NDSAVE,NDIG)
      MWK(START(MXY(2))+1) = NINT(NDIG*ALOGM2)
      KMETH4 = 0
      NUMTRY = 0

  130 NTERMS = INT(INTMAX/10)

!             A,X are double precision approximations to the two arguments to this function.
!             INTA = A if A is a small integer.  It is used to limit the number of terms used
!                    in the asymptotic series and in the continued fraction expansion.

      INTA = NTERMS
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(1),INTG)
      KFLAGI = KFLAG
      IF (KFLAG == 0) INTA = INTG
      CALL FMM2DP(MXY(1),A)
      KFLAGA = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          A = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) A = -A
          KFLAGA = 0
      ENDIF
      CALL FMM2DP(MXY(2),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(2))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(2))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      KWARN = KWRNSV

!             If A or X is large in magnitude use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),INT(MWK(START(MXY(2))+2)),0) ,  &
                   INT(1.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             KXNEG = 1 if X is negative and A is a positive integer.

      KXNEG = 0

!             MODA2 = MOD(A,2) when KXNEG is 1.

      MODA2 = 0

!             Check for special cases.

      IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(2))+2) == MEXPOV) THEN
          IF (MWK(START(MXY(1))+2) == MEXPOV .AND. MWK(START(MXY(1))+3) /= 0 .AND.  &
              MWK(START(MXY(1))) > 0) THEN
              IF (MWK(START(MXY(2))+2) /= MEXPOV) THEN
                  CALL FMST2M('OVERFLOW',MXY(16))
                  KFLAG = -5
                  GO TO 190
              ENDIF
          ENDIF
          IF (MWK(START(MXY(2))+2) == MEXPOV .AND. MWK(START(MXY(2))+3) /= 0 .AND.  &
              MWK(START(MXY(2))) > 0) THEN
              CALL FMBIG(MXY(17))
              MWK(START(MXY(17))+2) = MXSAVE + 1
              CALL FMLN(MXY(17),MXY(7))
              CALL FMDIV(MXY(17),MXY(7),MXY(18))
              IF (FMCOMP(MXY(1),'<=',MXY(18))) THEN
                  CALL FMST2M('UNDERFLOW',MXY(16))
                  KFLAG = -6
                  GO TO 190
              ELSE
                  CALL FMST2M('UNKNOWN',MXY(16))
                  KFLAG = -4
                  GO TO 210
              ENDIF
          ENDIF
          IF (MWK(START(MXY(2))+2) == MEXPOV .AND. MWK(START(MXY(2))) < 0 .AND.  &
              MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(1))+3) /= 0) THEN
              IF (MWK(START(MXY(1))+2) /= MEXPOV) THEN
                  CALL FMINT(MXY(1),MXY(15))
                  IF (FMCOMP(MXY(1),'==',MXY(15))) THEN
                      CALL FMI2M(2,MXY(12))
                      CALL FMMOD(MXY(15),MXY(12),MXY(7))
                      CALL FMEQ(MXY(7),MXY(12))
                      IF (MWK(START(MXY(12))+3) /= 0) THEN
                          CALL FMST2M('OVERFLOW',MXY(16))
                          KFLAG = -5
                          GO TO 190
                      ELSE
                          CALL FMST2M('-OVERFLOW',MXY(16))
                          KFLAG = -5
                          GO TO 190
                      ENDIF
                  ENDIF
              ENDIF
          ENDIF
          IF (MWK(START(MXY(1))+2) == MEXPOV .AND. MWK(START(MXY(1))) < 0 .AND.  &
              MWK(START(MXY(1))+3) /= 0) THEN
              IF (MWK(START(MXY(2))+2) /= MEXPOV .AND. MWK(START(MXY(2))) > 0 .AND.  &
                  MWK(START(MXY(2))+3) /= 0) THEN
                  CALL FMI2M(1,MXY(7))
                  IF (FMCOMP(MXY(2),'<',MXY(7))) THEN
                      CALL FMST2M('OVERFLOW',MXY(16))
                      KFLAG = -5
                      GO TO 190
                  ELSE
                      CALL FMST2M('UNDERFLOW',MXY(16))
                      KFLAG = -6
                      GO TO 190
                  ENDIF
              ENDIF
          ENDIF
          CALL FMST2M('UNKNOWN',MXY(16))
          KFLAG = -4
          GO TO 210
      ENDIF

      IF (MWK(START(MXY(1))+2) == MEXPUN .OR. MWK(START(MXY(2))+2) == MEXPUN) THEN
          IF (MWK(START(MXY(1))+2) == MEXPUN .AND. MWK(START(MXY(2))+2) == MEXPUN) THEN
              CALL FMST2M('UNKNOWN',MXY(16))
              KFLAG = -4
              GO TO 210
          ENDIF
          IF (MWK(START(MXY(2))+2) == MEXPUN .AND. MWK(START(MXY(2))) > 0 .AND.  &
              MWK(START(MXY(2))+3) /= 0) THEN
              IF (MWK(START(MXY(1))+2) >= 1 .AND. MWK(START(MXY(1))) > 0) THEN
                  CALL FMGAM(MXY(1),MXY(20))
                  CALL FMEQ(MXY(20),MXY(16))
                  GO TO 190
              ELSE IF (MWK(START(MXY(1))+2) >= 1 .AND. MWK(START(MXY(1))) < 0) THEN
                  CALL FMST2M('OVERFLOW',MXY(16))
                  KFLAG = -5
                  GO TO 210
              ELSE
                  CALL FMST2M('UNKNOWN',MXY(16))
                  KFLAG = -4
                  GO TO 210
              ENDIF
          ENDIF
      ENDIF

      IF (MWK(START(MXY(2))+3) == 0) THEN
          IF (MWK(START(MXY(1))) < 0 .OR. MWK(START(MXY(1))+3) == 0) THEN
              CALL FMST2M('UNKNOWN',MXY(16))
              KFLAG = -4
              GO TO 210
          ELSE
              CALL FMGAM(MXY(1),MXY(20))
              CALL FMEQ(MXY(20),MXY(16))
              GO TO 190
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))) < 0) THEN
          CALL FMINT(MXY(1),MXY(15))
          IF (FMCOMP(MXY(1),'==',MXY(15)) .AND. MWK(START(MXY(1)))*MWK(START(MXY(1))+3) > 0) THEN
              KXNEG = 1
              CALL FMI2M(2,MXY(12))
              CALL FMMOD(MXY(15),MXY(12),MXY(7))
              CALL FMEQ(MXY(7),MXY(12))
              IF (MWK(START(MXY(12))+3) /= 0) MODA2 = 1
          ELSE
              CALL FMST2M('UNKNOWN',MXY(16))
              KFLAG = -4
              GO TO 210
          ENDIF
      ENDIF
      IF (MWK(START(MXY(2))+2) == MEXPUN) THEN
          IF (MWK(START(MXY(1))) < 0 .AND. MWK(START(MXY(1))+2) >= 1) THEN
              CALL FMST2M('OVERFLOW',MXY(16))
              KFLAG = -5
          ELSE
              CALL FMGAM(MXY(1),MXY(20))
              CALL FMEQ(MXY(20),MXY(16))
          ENDIF
          GO TO 190
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMI2M(0,MXY(1))
          MAS = 1
      ENDIF
      CALL FMMAX(MXY(1),MXY(2),MXY(7))
      CALL FMMIN(MXY(1),MXY(2),MXY(8))
      CALL FMDPM(1.0D6,MXY(3))
      CALL FMDPM(1.0D2,MXY(4))
      IF (FMCOMP(MXY(7),'>=',MXY(3)) .AND. FMCOMP(MXY(8),'>=',MXY(4))) THEN
          CALL FMI2M(1,MXY(7))
          CALL FMSUB(MXY(1),MXY(7),MXY(9))
          CALL FMMAX(MXY(9),MXY(2),MXY(11))
          CALL FMADDI(MXY(11),1)
          CALL FMLN(MXY(11),MXY(7))
          CALL FMMPY(MXY(9),MXY(7),MXY(4))
          CALL FMSUB(MXY(4),MXY(11),MXY(7))
          CALL FMEXP(MXY(7),MXY(13))
          IF ((MWK(START(MXY(13))+2) == MEXPOV .AND. MWK(START(MXY(13))) > 0 .AND.  &
              MWK(START(MXY(13))+3) /= 0) .OR. MWK(START(MXY(13))+2) > MXSAVE+1) THEN
              CALL FMST2M('OVERFLOW',MXY(16))
              KFLAG = -5
              GO TO 190
          ENDIF
      ENDIF

!             If A is 1 the result is exp(-X).

      CALL FMI2M(1,MXY(7))
      IF (FMCOMP(MXY(1),'==',MXY(7))) THEN
          IF (ABS(MWK(START(MXY(2))+2)) < MEXPOV) THEN
              CALL FMEQ(MXY(2),MXY(8))
              IF (MWK(START(MXY(8))+2) /= MUNKNO .AND. MWK(START(MXY(8))+3) /= 0)  &
                  MWK(START(MXY(8))) = -MWK(START(MXY(8)))
              CALL FMEXP(MXY(8),MXY(16))
              IF (MWK(START(MXY(16))+2) /= MUNKNO) GO TO 210
          ENDIF
      ENDIF

!             If A is negative and X is small, the result is -X**A / A.

      IF (MWK(START(MXY(1))) == -1 .AND. MWK(START(MXY(2))+2) < -NDIG) THEN
          CALL FMPWR(MXY(2),MXY(1),MXY(8))
          CALL FMDIV(MXY(8),MXY(1),MXY(16))
          IF (MWK(START(MXY(16))+2) == MUNKNO) THEN
              CALL FMLN(MXY(2),MXY(8))
              CALL FMMPY(MXY(8),MXY(1),MXY(9))
              CALL FMABS(MXY(1),MXY(10))
              CALL FMLN(MXY(10),MXY(11))
              CALL FMSUB(MXY(9),MXY(11),MXY(10))
              CALL FMEXP(MXY(10),MXY(16))
              IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
                  MWK(START(MXY(16))) = -MWK(START(MXY(16)))
          ENDIF
          IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
              MWK(START(MXY(16))) = -MWK(START(MXY(16)))
          IF (MWK(START(MXY(16))+2) /= MUNKNO) GO TO 210
      ENDIF
      IF (MWK(START(MXY(1))) == -1 .AND. MWK(START(MXY(2))) == 1 .AND.  &
          MWK(START(MXY(1))+2) > NDIG .AND.                        &
          MWK(START(MXY(1))+2) - MWK(START(MXY(2))+2) > NDIG) THEN
          CALL FMI2M(1,MXY(3))
          CALL FMSUB(MXY(3),MXY(1),MXY(4))
          CALL FMADD(MXY(4),MXY(2),MXY(6))
          CALL FMDIV(MXY(3),MXY(6),MXY(5))
          CALL FMSQR(MXY(1),MXY(4))
          CALL FMMPYI(MXY(2),2,MXY(6))
          CALL FMADDI(MXY(6),3)
          CALL FMMPY(MXY(1),MXY(6),MXY(7))
          CALL FMSUB(MXY(4),MXY(7),MXY(8))
          CALL FMDIV(MXY(5),MXY(8),MXY(9))
          CALL FMSUB(MXY(1),MXY(3),MXY(10))
          CALL FMMPY(MXY(10),MXY(9),MXY(11))
          IF (MWK(START(MXY(11))+2) /= MUNKNO) THEN
              CALL FMADD(MXY(5),MXY(11),MXY(12))
          ELSE
              CALL FMEQ(MXY(5),MXY(12))
          ENDIF
          CALL FMPWR(MXY(2),MXY(1),MXY(13))
          IF (MWK(START(MXY(1))+2) == MEXPOV .OR. MWK(START(MXY(1))+2) == MEXPUN) THEN
              CALL FMEQ(MXY(13),MXY(16))
          ELSE
              CALL FMEXP(MXY(2),MXY(14))
              CALL FMMPY(MXY(12),MXY(13),MXY(15))
              CALL FMDIV(MXY(15),MXY(14),MXY(16))
          ENDIF
          IF (MWK(START(MXY(16))+2) /= MUNKNO) GO TO 210
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion,
!                    = 4 means use an O(A**2) formula.

      CALL FMI2M(-10000,MXY(11))
      CALL FMI2M(10000,MXY(12))
      CALL FMABS(MXY(1),MXY(14))
      CALL FMABS(MXY(2),MXY(15))
      CALL FMSUB(MXY(15),MXY(14),MXY(13))
      KABIGR = 1
      IF (MWK(START(MXY(13))+3) >= 0 .AND. MWK(START(MXY(13))) > 0) KABIGR = 0

!             Check whether the smallest term in the asymptotic series is small enough to give
!             the required accuracy.

      IF (KFLAGA /= 0 .OR. KFLAGX /= 0) THEN
          CALL FMDIV(MXY(14),MXY(15),MXY(10))
          CALL FMI2M(1,MXY(8))
          CALL FMSUB(MXY(8),MXY(10),MXY(9))
          IF (MWK(START(MXY(9))) < 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          T1 = FMDPLG(A)
          SMALL = T1 - FMDPLG(-ABS(X)) - (A+ABS(X))*LOG(ABS(X))
          TOL = -DBLE(NDIG+2)*DLOGMB - 12.0D0
          B = 1.0D0
          IF (A > ABS(X)) B = A - ABS(X)
          BIG = T1 - FMDPLG(A-B) - B*LOG(ABS(X))

          NMETHD = 0
          IF (FMCOMP(MXY(13),'<=',MXY(11))) THEN
              IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(1))+3) /= 0) THEN
                  NMETHD = 1
              ELSE
                  NMETHD = 3
              ENDIF
          ELSE IF (FMCOMP(MXY(13),'>=',MXY(12)) .AND. MWK(START(MXY(1))) > 0 .AND.     &
                   MWK(START(MXY(1))+3) > 0 .AND. MWK(START(MXY(2))) > 0 .AND.  &
                   MWK(START(MXY(2))+3) > 0) THEN
              NMETHD = 3
              IF (SMALL < TOL+BIG) NMETHD = 2
          ELSE IF (FMCOMP(MXY(13),'>=',MXY(12))) THEN
              NMETHD = 3
          ELSE IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(2))) > 0 .AND.  &
                   MWK(START(MXY(2))+3) > 0) THEN
              CALL FMDP2M(SQRT(DPMAX),MXY(11))
              IF (FMCOMP(MXY(2),'>=',MXY(11))) THEN
                  KFLAG = -5
                  CALL FMST2M('OVERFLOW',MXY(16))
                  GO TO 190
              ENDIF

              IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(1))+3) /= 0) THEN
                  C2 = DBLE(NDSAVE)*DLOGMB/6.0D0
                  C1 = MAX( 10.0D0 , C2 , A )
                  C2 = MAX( 10.0D0 , C2 , A - 6.5D0*A/(SQRT(A)+1.0D0) )
              ELSE
                  C1 = MAX( 15.0D0 , DBLE(NDSAVE)*DLOGMB/5.0D0 )
                  C2 = C1
              ENDIF
              IF (X < MIN(C1,C2)) THEN
                  IF (-2*MWK(START(MXY(1))+2) > NDIG .OR. MWK(START(MXY(1))+3) == 0) THEN
                      NMETHD = 4
                  ELSE
                      NMETHD = 1
                  ENDIF
              ELSE IF (X > C2) THEN
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
              IF (NMETHD == 0 .AND. X > C1) NMETHD = 3
              IF (NMETHD == 0) NMETHD = 1
          ELSE IF (MWK(START(MXY(1))) < 0 .AND. MWK(START(MXY(2))) > 0 .AND.  &
              MWK(START(MXY(2))+3) > 0) THEN
              CALL FMDP2M(SQRT(DPMAX),MXY(11))
              IF (FMCOMP(MXY(2),'>=',MXY(11))) THEN
                  KFLAG = -6
                  CALL FMST2M('UNDERFLOW',MXY(16))
                  GO TO 190
              ENDIF

              C1 = MAX( 10.0D0 , DBLE(NDSAVE)*DLOGMB/7.0D0 )
              C2 = -2.0D0*A
              IF (X < C1) THEN
                  IF (-2*MWK(START(MXY(1))+2) > NDIG) THEN
                      NMETHD = 4
                  ELSE
                      NMETHD = 1
                  ENDIF
              ELSE IF (X > C2) THEN
                  T1 = FMDPLG(A)
                  SMALL = T1 - FMDPLG(-ABS(X)) - (A+ABS(X))*LOG(ABS(X))
                  TOL = -DBLE(NDIG+2)*DLOGMB - 12.0D0
                  B = 1.0D0
                  IF (A > ABS(X)) B = A - ABS(X)
                  BIG = T1 - FMDPLG(A-B) - B*LOG(ABS(X))
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
              IF (NMETHD == 0 .AND. X > C1) NMETHD = 3
              IF (NMETHD == 0) NMETHD = 1
          ELSE IF (MWK(START(MXY(1))) > 0 .AND. MWK(START(MXY(1))+3) > 0 .AND.  &
              MWK(START(MXY(2))) < 0) THEN
              CALL FMEQ(MXY(2),MXY(11))
              IF (MWK(START(MXY(11))+2) /= MUNKNO .AND. MWK(START(MXY(11))+3) /= 0)  &
                  MWK(START(MXY(11))) = -MWK(START(MXY(11)))
              CALL FMMPYI(MXY(1),2,MXY(12))
              IF (FMCOMP(MXY(11),'<',MXY(1))) THEN
                  NMETHD = 1
              ELSE IF (FMCOMP(MXY(11),'<',MXY(12))) THEN
                  NMETHD = 3
              ELSE
                  NMETHD = 3
                  IF (SMALL < TOL+BIG) NMETHD = 2
              ENDIF
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150
      IF (NMETHD == 3) GO TO 170
      IF (NMETHD == 4) GO TO 180

!             Method 1.  Use the X**N/Pochhammer(A+1,N) series.

!             MXY(16) is the current sum.
!             MXY(12) is the current term.
!             MXY(11) is (A+N)/X.
!             MXY(19) is 1/X

!             Raise the precision if A is negative and near an integer, to compensate for
!             cancellation when (A+N)/X is near zero.
!             Raise the precision if A is positive and near zero, since there will be cancellation
!             in subtracting the sum from Gamma(A).
!             If A is a negative integer use method 3 or 4.

      IEXTRA = 0
      IF (MWK(START(MXY(1))) < 0) THEN
          IF (KFLAGA == 0) THEN
              IF (ABS(A) > 1.0D3) THEN
                  NMETHD = 3
                  GO TO 170
              ENDIF
          ELSE
              NMETHD = 3
              GO TO 170
          ENDIF
          CALL FMNINT(MXY(1),MXY(16))
          IF (FMCOMP(MXY(16),'==',MXY(1))) THEN
              IF (KFLAGI == 0) THEN
                  IF (KFLAGX /= 0) THEN
                      GO TO 170
                  ELSE
                      IF (ABS(X) <= 20.0D0) THEN
                          C1 = 0.7D0*(DBLE(NDSAVE)*DLOGMB*(20.0D0-X))**0.75D0
                          IF (ABS(A) > C1) THEN
                              GO TO 170
                          ELSE
                              GO TO 180
                          ENDIF
                      ELSE
                          GO TO 170
                      ENDIF
                  ENDIF
              ELSE
                  GO TO 170
              ENDIF
          ENDIF
          CALL FMSUB(MXY(1),MXY(16),MXY(19))
          IEXTRA = MAX(-2*INT(MWK(START(MXY(19))+2)),-INT(MWK(START(MXY(1))+2))+1,0)
      ELSE
          IEXTRA = MAX(-INT(MWK(START(MXY(1))+2))+1,0)
      ENDIF

!             Raise the precision further as X increases in magnitude.

      IF (KFLAGX == 0 .AND. KFLAGA == 0) THEN
          T1 = (0.92D0 + (X-A) + (A-0.5D0)*LOG(ABS(A)+1.0D-10) -  &
               (A-1.0D0)*LOG(ABS(X)+1.0D-10))/DLOGMB
          IF (T1 > 0 .AND. ABS(X) > 1.0D0) THEN
              IF (A < 0.0D0 .OR. X >= A) THEN
                  IEXTRA = IEXTRA + MAX(0,INT(T1)+1)
              ENDIF
          ENDIF
      ENDIF

      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

      JEXTRA = 0

  140 IF (KABIGR == 1) THEN
          CALL FMGAM(MXY(1),MXY(20))
          IF (KFLAG /= 0) THEN
              CALL FMEQ(MXY(20),MXY(16))
              GO TO 190
          ENDIF
          CALL FMEQ(MXY(20),MXY(16))
      ELSE
          CALL FMI2M(0,MXY(16))
      ENDIF

      MAXM09 = MWK(START(MXY(16))+2)

      CALL FMABS(MXY(2),MXY(19))
      CALL FMLN(MXY(19),MXY(6))
      CALL FMMPY_R2(MXY(1),MXY(6))
      CALL FMSUB_R1(MXY(6),MXY(2))
      CALL FMEXP(MXY(6),MXY(20))
      CALL FMDIV(MXY(20),MXY(1),MXY(12))
      IF (MWK(START(MXY(12))+2) == MUNKNO) THEN
          CALL FMLN(MXY(1),MXY(15))
          CALL FMSUB_R1(MXY(6),MXY(15))
          CALL FMEXP(MXY(6),MXY(12))
      ENDIF
      IF (KXNEG == 1 .AND. MODA2 == 1 .AND. MWK(START(MXY(12))+2) /= MUNKNO  &
          .AND. MWK(START(MXY(12))+3) /= 0) THEN
          MWK(START(MXY(12))) = -MWK(START(MXY(12)))
      ENDIF

      IF (MWK(START(MXY(12))+2) /= MUNKNO .AND. MWK(START(MXY(12))+3) /= 0) THEN
          MWK(START(MXY(12))) = -MWK(START(MXY(12)))
      ENDIF
      CALL FMADD_R1(MXY(16),MXY(12))
      MAXM09 = MAX(MAXM09,MWK(START(MXY(16))+2))

      CALL FMI2M(1,MXY(9))
      CALL FMADD(MXY(1),MXY(9),MXY(11))
      CALL FMDIV_R1(MXY(12),MXY(11))
      CALL FMMPY_R1(MXY(12),MXY(2))
      CALL FMDIV_R1(MXY(11),MXY(2))
      CALL FMDIV(MXY(9),MXY(2),MXY(19))
      NDSAV1 = NDIG

!             If A is negative and ABS(A) > ABS(X), the terms in the series first decrease,
!             then increase, then decrease. Try to predict the number of extra digits required to
!             keep the precision from prematurely becoming too small.

      KFLGOK = 1
      IF (MWK(START(MXY(1))) < 0) THEN
          KFLGOK = 0
          MWK(START(MXY(1))) = 1
          MWK(START(MXY(2))) = 1
          IF (FMCOMP(MXY(1),'>',MXY(2))) THEN
              IF (JEXTRA == 0) THEN
                  IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                      T1 = FMDPLG(A+AINT(-ABS(X)-A)) - FMDPLG(A+1.0D0+AINT(ABS(X)-A))
                      T1 = (T1 + 2.0D0*ABS(X)*LOG(ABS(X)+1.0D-10))/DLOGMB
                      T1 = MAX(0.0D0,T1+1.0D0)
                      JEXTRA = T1
                  ENDIF
              ENDIF

!             If A is negative and ABS(A) is much bigger than ABS(X), then the later increase
!             in the size of the terms can be ignored.

              IF (KFLAGA == 0 .AND. KFLAGX == 0) THEN
                  T1 = (AINT(X-A)*LOG(ABS(X)+1.0D-10) + FMDPLG(A+1.0D0)  &
                       - FMDPLG(A+1.0D0+AINT(X-A))) / DLOGMB
                  IF (T1 < -DBLE(NDIG)) KFLGOK = 1
              ELSE
                  KFLGOK = 1
              ENDIF
          ENDIF
          MWK(START(MXY(1))) = MAS
          MWK(START(MXY(2))) = MBS
      ENDIF

      NMNNDG = NDSAV1

!             Method 1 summation loop.

      DO J = 1, NTERMS
         NDIG = NDSAV1
         CALL FMADD_R1(MXY(16),MXY(12))
         MAXM09 = MAX(MAXM09,MWK(START(MXY(16))+2))
         IF (KFLAG /= 0) THEN
             IF (KFLGOK == 0 .AND. KFLAGA == 0 .AND. KFLAGX == 0) THEN
                 IF (DBLE(J) > X-A) EXIT
             ELSE
                 EXIT
             ENDIF
         ENDIF

         CALL FMADD_R1(MXY(11),MXY(19))

         NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(16))+2)-MWK(START(MXY(12))+2)))
         NDIG = MIN(NDSAV1,NDIG2+JEXTRA)
         NMNNDG = MIN(NMNNDG,NDIG)
         CALL FMDIV_R1(MXY(12),MXY(11))
      ENDDO

      NDIG = NDSAV1
      IF (KABIGR == 0) THEN
          CALL FMEQ(MXY(16),MXY(19))
          CALL FMGAM(MXY(1),MXY(20))
          IF (KFLAG /= 0) THEN
              CALL FMEQ(MXY(20),MXY(16))
              GO TO 190
          ENDIF
          CALL FMADD(MXY(20),MXY(19),MXY(16))
      ENDIF

!             If too much cancellation occurred, raise the precision and do the calculation again.

      IEXTRA = NDIG - NDSAVE
      IF (INT(MAXM09-MWK(START(MXY(16))+2)) >= IEXTRA-NGRD52/2) THEN
          IEXTRA = IEXTRA + NGRD52
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA
          GO TO 140
      ENDIF

      GO TO 190

!             Method 2.  Use the Pochhammer(A-N,N)/X**N series.

!             MXY(16) is the current sum.
!             MXY(12) is the current term.
!             MXY(11) is (A-N)/X.
!             MXY(19) is -1/X

  150 CALL FMABS(MXY(2),MXY(19))
      CALL FMLN(MXY(19),MXY(6))
      CALL FMMPY(MXY(1),MXY(6),MXY(16))
      CALL FMSUB_R2(MXY(16),MXY(6))
      CALL FMSUB_R1(MXY(6),MXY(2))
      CALL FMEXP(MXY(6),MXY(12))
      IF (KXNEG == 1 .AND. MODA2 == 0 .AND. MWK(START(MXY(12))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(12))+3) /= 0) MWK(START(MXY(12))) = -MWK(START(MXY(12)))
      IF (ABS(MWK(START(MXY(12))+2)) >= MXEXP2) THEN
          CALL FMEQ(MXY(12),MXY(16))
          GO TO 190
      ENDIF

!             Here MXY(12) is X**(A-1)/EXP(X).

      CALL FMI2M(0,MXY(16))
      CALL FMEQ(MXY(1),MXY(11))
      CALL FMDIV_R1(MXY(11),MXY(2))
      CALL FMI2M(1,MXY(9))
      CALL FMDIV(MXY(9),MXY(2),MXY(19))
      IF (MWK(START(MXY(19))+2) /= MUNKNO .AND. MWK(START(MXY(19))+3) /= 0)  &
          MWK(START(MXY(19))) = -MWK(START(MXY(19)))
      NDSAV1 = NDIG

!             Disable NDIG reduction until the terms in the sum begin to decrease in size.

      BIGJ = 0
      IF (KFLAGA == 0 .AND. KFLAGX == 0) BIGJ = ABS(A) - ABS(X)
      JTERMS = NTERMS
      IF (KFLAGI == 0 .AND. INTA > 0) THEN
          JTERMS = INTA
      ELSE IF (KFLAGX == 0) THEN
          IF (KFLAGA == 0) THEN
              T1 = A + ABS(X)
              IF (T1 > 0 .AND. T1 < DBLE(NTERMS)) JTERMS = INT(T1) + 2
          ELSE IF (MWK(START(MXY(1))+2) < 0) THEN
              T1 = ABS(X)
              IF (T1 > 0 .AND. T1 < DBLE(NTERMS)) JTERMS = INT(T1) + 2
          ENDIF
      ENDIF

!             Method 2 summation loop.

      DO J = 1, JTERMS
         NDIG = NDSAV1
         CALL FMADD_R1(MXY(16),MXY(12))
         IF (KFLAG /= 0 .AND. J > 1) GO TO 160
         CALL FMADD_R1(MXY(11),MXY(19))
         IF (REAL(J) >= BIGJ) THEN
             NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(16))+2)-MWK(START(MXY(12))+2)))
             NDIG = MIN(NDSAV1,NDIG2)
         ENDIF
         CALL FMMPY_R1(MXY(12),MXY(11))
      ENDDO

  160 NDIG = NDSAV1
      GO TO 190

!             Method 3.  Use the continued fraction expansion.

!             MXY(19) is the current approximation.
!             MXY(16) is the term in the sum, S(k).
!             MXY(14), MXY(15) are the latest denominators, Q(k-1) and Q(k).

!             Raise the precision so that convergence of the continued fraction expansion
!             is easier to detect.

  170 JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0))

!             Raise the precision further for small X if A is positive.

      IF (KFLAGX == 0 .AND. KFLAGA == 0) THEN
          T1 = (0.92D0 + (ABS(X)-A) + (A-0.5D0)*LOG(ABS(A)+1.0D-10) -  &
               (A-1.0D0)*LOG(ABS(X)+1.0D-10))/DLOGMB
          IF (T1 > 0.0D0 .AND. A > 0.0D0) THEN
              IF (ABS(X) < A) THEN
                  JEXTRA = JEXTRA + MAX(0,INT(1.5D0*T1)+1)
              ENDIF
          ENDIF
      ENDIF
      NDSAV1 = NDIG
      IF (NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA)
          CALL FMEQU_R1(MXY(2),NDSAV1,NDSAV1+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      CALL FMEQU(MXY(1),MXY(11),NDSAV1,NDIG)
      IF (MWK(START(MXY(11))+2) /= MUNKNO .AND. MWK(START(MXY(11))+3) /= 0)  &
          MWK(START(MXY(11))) = -MWK(START(MXY(11)))
      CALL FMI2M(1,MXY(14))
      CALL FMEQU(MXY(2),MXY(15),NDSAV1,NDIG)
      CALL FMI2M(1,MXY(7))
      CALL FMDIV(MXY(7),MXY(15),MXY(16))
      CALL FMEQ(MXY(16),MXY(19))

      JTERMS = NTERMS
      IF (INTA > 0) JTERMS = INTA - 1

!             Method 3 continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, JTERMS
         CALL FMADDI(MXY(11),1)
         CALL FMMPY(MXY(11),MXY(14),MXY(13))
         CALL FMADD(MXY(15),MXY(13),MXY(12))
         CALL FMMPY(MXY(13),MXY(16),MXY(8))
         CALL FMDIV(MXY(8),MXY(12),MXY(16))
         IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
             MWK(START(MXY(16))) = -MWK(START(MXY(16)))
         NDIG = NDSAV2
         CALL FMADD_R1(MXY(19),MXY(16))
         KFLAG1 = KFLAG
         CALL FMEQ(MXY(15),MXY(14))
         CALL FMEQ(MXY(12),MXY(15))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(19))+2)-MWK(START(MXY(16))+2))))
         CALL FMMPYI(MXY(14),J,MXY(13))
         CALL FMMPY(MXY(2),MXY(15),MXY(8))
         CALL FMADD(MXY(8),MXY(13),MXY(12))
         CALL FMMPY(MXY(13),MXY(16),MXY(8))
         CALL FMDIV(MXY(8),MXY(12),MXY(16))
         IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
             MWK(START(MXY(16))) = -MWK(START(MXY(16)))
         NDIG = NDSAV2
         CALL FMADD_R1(MXY(19),MXY(16))

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(15),MXY(14))
         CALL FMEQ(MXY(12),MXY(15))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(19))+2)-MWK(START(MXY(16))+2))))
      ENDDO

      NDIG = NDSAV2
      CALL FMEQU_R1(MXY(19),NDIG,NDSAV1)
      NDIG = NDSAV1
      CALL FMABS(MXY(2),MXY(15))
      CALL FMLN(MXY(15),MXY(6))
      CALL FMMPY_R2(MXY(1),MXY(6))
      CALL FMSUB_R1(MXY(6),MXY(2))
      CALL FMEXP(MXY(6),MXY(5))
      IF (KXNEG == 1 .AND. MODA2 == 1 .AND. MWK(START(MXY(5))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(5))+3) /= 0) MWK(START(MXY(5))) = -MWK(START(MXY(5)))
      IF (ABS(MWK(START(MXY(5))+2)) >= MXEXP2) THEN
          CALL FMEQ(MXY(5),MXY(16))
          IF (MWK(START(MXY(19))) < 0 .AND. MWK(START(MXY(16))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(16))+3) /= 0) MWK(START(MXY(16))) = -MWK(START(MXY(16)))
          GO TO 190
      ENDIF

      CALL FMMPY(MXY(5),MXY(19),MXY(16))
      GO TO 190

!             Method 4.  Use the O(A**2) formula when A is small.

!             MXY(16) is the current term.
!             MXY(19) is the current sum.

!             Raise the precision if X is larger than A in magnitude.
!             The terms initially increase in size, and the final sum is small.

  180 IEXTRA = 0

!             If A is a negative integer, replace it by zero and later use a recurrence to recover
!             the original function value.

      IF (KFLAGI == 0 .AND. INTA < 0) THEN
          CALL FMI2M(0,MXY(1))
          A = 0.0D0
          KMETH4 = 1
      ENDIF

      IF (KFLAGX == 0) THEN
          IF (KFLAGA == 0) THEN
              T1 = ABS(X) - ABS(A)
          ELSE
              T1 = ABS(X)
          ENDIF
          IF (T1 > 0) THEN
              T2 = (T1 + LOG(T1))/DLOGMB
              IF (T2 > DBLE(MXEXP2/10)) T2 = DBLE(MXEXP2/10)
              IEXTRA = INT(MAX(0.0D0,T2))
          ENDIF
          T1 = ABS(X)+1.0D-10
          T2 = (T1 - 0.5D0*LOG(6.2831853D0*T1))/DLOGMB
          IF (T2 > DBLE(MXEXP2/10)) T2 = DBLE(MXEXP2/10)
          IEXTRA = IEXTRA + INT(MAX(0.0D0,T2))
      ENDIF

      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          CALL FMEQU_R1(MXY(2),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

      CALL FMEULR(MXY(19))
      CALL FMEQ(MXY(19),MXY(20))
      MWK(START(MXY(19))) = -1
      CALL FMABS(MXY(2),MXY(16))
      CALL FMLN(MXY(16),MXY(15))
      CALL FMSUB_R1(MXY(19),MXY(15))
      IF (MWK(START(MXY(1))+3) /= 0 .AND. MWK(START(MXY(1))+2) >= -NDIG-1) THEN
          CALL FMSQR(MXY(15),MXY(7))
          CALL FMMPY(MXY(7),MXY(1),MXY(4))
          CALL FMDIVI(MXY(4),2,MXY(16))
          CALL FMSUB_R1(MXY(19),MXY(16))

          CALL FMSQR(MXY(20),MXY(14))
          CALL FMPI(MXY(13))
          CALL FMSQR(MXY(13),MXY(7))
          CALL FMDIVI(MXY(7),6,MXY(13))
          CALL FMADD(MXY(13),MXY(14),MXY(7))
          CALL FMMPY(MXY(7),MXY(1),MXY(4))
          CALL FMDIVI(MXY(4),2,MXY(14))
          CALL FMADD_R1(MXY(19),MXY(14))
      ENDIF

      NDSAV1 = NDIG
      CALL FMI2M(1,MXY(14))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(1),MXY(14),MXY(13))
      KROUND = JR
      IF (FMCOMP(MXY(14),'==',MXY(13))) THEN
          CALL FMI2M(-1,MXY(16))
          DO J = 1, NTERMS
             NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(19))+2)-MWK(START(MXY(16))+2)))
             NDIG = MIN(NDSAV1,NDIG2)
             CALL FMMPY_R1(MXY(16),MXY(2))
             IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
                 MWK(START(MXY(16))) = -MWK(START(MXY(16)))
             CALL FMDIVI_R1(MXY(16),J)
             CALL FMDIVI(MXY(16),J,MXY(15))
             NDIG = NDSAV1
             CALL FMADD_R1(MXY(19),MXY(15))
             IF (KFLAG /= 0) EXIT
          ENDDO
      ELSE
          CALL FMPWR(MXY(2),MXY(1),MXY(16))
          IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
              MWK(START(MXY(16))) = -MWK(START(MXY(16)))
          CALL FMEQ(MXY(1),MXY(20))
          DO J = 1, NTERMS
             NDIG2 = MAX(NGRD22,NDSAV1-INT(MWK(START(MXY(19))+2)-MWK(START(MXY(16))+2)))
             NDIG = MIN(NDSAV1,NDIG2)
             CALL FMMPY_R1(MXY(16),MXY(2))
             IF (MWK(START(MXY(16))+2) /= MUNKNO .AND. MWK(START(MXY(16))+3) /= 0)  &
                 MWK(START(MXY(16))) = -MWK(START(MXY(16)))
             CALL FMDIVI_R1(MXY(16),J)
             NDIG = NDSAV1
             CALL FMADD_R1(MXY(20),MXY(14))
             NDIG = MIN(NDSAV1,NDIG2)
             CALL FMDIV(MXY(16),MXY(20),MXY(15))
             NDIG = NDSAV1
             CALL FMADD_R1(MXY(19),MXY(15))
             IF (KFLAG /= 0) EXIT
          ENDDO
      ENDIF
      CALL FMEQ(MXY(19),MXY(16))

!             Use the recurrence relation if A was a negative integer.

      IF (KFLAGI == 0 .AND. INTA < 0) THEN
          N = -INTA
          CALL FMI2M(1,MXY(19))
          CALL FMDIV_R1(MXY(19),MXY(2))
          CALL FMEQ(MXY(19),MXY(15))
          CALL FMEQ(MXY(19),MXY(14))
          DO J = 1, N-1
             CALL FMMPYI_R1(MXY(15),J)
             CALL FMMPY_R1(MXY(15),MXY(14))
             IF (MWK(START(MXY(15))+2) /= MUNKNO .AND. MWK(START(MXY(15))+3) /= 0)  &
                 MWK(START(MXY(15))) = -MWK(START(MXY(15)))
             CALL FMADD_R1(MXY(19),MXY(15))
          ENDDO
          CALL FMEXP(MXY(2),MXY(14))
          CALL FMDIV_R1(MXY(19),MXY(14))
          CALL FMSUB_R1(MXY(16),MXY(19))
          CALL FMFCTI(N,MXY(14))
          CALL FMDIV_R1(MXY(16),MXY(14))
          IF (MOD(N,2) == 1 .AND. MWK(START(MXY(16))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(16))+3) /= 0) MWK(START(MXY(16))) = -MWK(START(MXY(16)))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  190 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(16))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 120
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(16))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(16))+J+1)) GO TO 200
              ENDDO
              GO TO 210
          ENDIF
  200     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(16))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          IF (KMETH4 == 1) THEN
              CALL FMI2M(INTA,MXY(1))
          ENDIF
          CALL FMEQU_R1(MXY(2),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(16),MRETRY,NDOLD,NDIG)
          GO TO 130
      ENDIF

  210 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(16))+1) = MIN(MWK(START(MXY(16))+1),MACCA,MACCB,MACMAX)
      CALL FMEXT2(MXY(16),MC,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMIGM2

      SUBROUTINE FMLNGM(MA,MB)

!  MB = LN(GAMMA(MA))

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MAS,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTA,J,J2,K,K0,K1,K2,KASAVE,KFL,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,KSIGN,  &
                 KWRNSV,LSHIFT,NDENOM,NDGOAL,NDIG2,NDMB,NDOLD,NDSAV1,NDSAVE,NDSV,NGOAL,NMXDIF,  &
                 NTERM,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      CHARACTER(155) :: STRING
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(15),MJSUMS(LJSUMS),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      MRETRY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMLNGM   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      MAS = MWK(START(MA))
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQ(MXY(1),MXY(13))
      NUMTRY = 0

!             Near zero Gamma(x) is about 1/x.

  120 IF (MWK(START(MXY(13))+2) < (-NDIG-3)) THEN
          CALL FMLN(MXY(13),MXY(10))
          IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
              MWK(START(MXY(10))) = -MWK(START(MXY(10)))
          GO TO 150
      ENDIF

!             Check for special cases.

      IF (MAS < 0) THEN
          KFL = 0
          IF (MWK(START(MXY(1))+2) <= NDSAVE) THEN
              CALL FMINT(MXY(13),MXY(9))
              IF (FMCOMP(MXY(13),'==',MXY(9))) KFL = -4
              CALL FMI2M(2,MXY(10))
              MWK(START(MXY(9))) = 1
              CALL FMMOD(MXY(9),MXY(10),MXY(5))
              CALL FMEQ(MXY(5),MXY(10))
              IF (MWK(START(MXY(10))+3) == 0) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(10))
              KFLAG = -4
              GO TO 170
          ELSE
              CALL FMI2M(1,MXY(5))
              CALL FMSUB_R2(MXY(5),MXY(13))
          ENDIF
      ENDIF

!             To speed the asymptotic series calculation, increase the argument by LSHIFT.

      IEXTRA = 0
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(13),INTA)
      KWARN = KWRNSV

      IF (KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(NDIG)*ALOGMB/4.46-REAL(INTA)))
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)
      IF (KFLAG == 0) THEN
          IF (LSHIFT > 0 .OR. INTA <= 10) THEN
              IF (INTA <= 2) THEN
                  CALL FMI2M(0,MXY(10))
                  GO TO 150
              ENDIF
              INTA = INTA - 1
              CALL FMFCTI(INTA,MXY(13))
              CALL FMLN(MXY(13),MXY(10))
              GO TO 150
          ENDIF
      ENDIF

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(5))
          CALL FMADD(MXY(13),MXY(5),MXY(12))
      ELSE
          CALL FMEQ(MXY(13),MXY(12))
      ENDIF

!             Sum the asymptotic series.

!       MXY(13) is Z
!       MXY(12) is Z + LSHIFT
!       MXY(9)  is X**J2 = (1/(Z+LSHIFT)**2)**J2
!       MXY(10) is the current power of X
!       MXY(11) is the current term in the sum
!       MJSUMS  is the partial sum

      J2 = INT(0.3*ALOGMB + 0.2*SQRT(REAL(NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG
      CALL FMI2M(1,MXY(10))
      J = -2*J2
      CALL FMIPWR(MXY(12),J,MXY(9))
      IF (ABS(MWK(START(MXY(9))+2)) >= MEXPAB) THEN
          J2 = 1
          CALL FMIPWR(MXY(12),-2,MXY(9))
      ENDIF
      DO J = 1, J2
         NTERM = 2*J
         CALL FMBERN(NTERM,MXY(10),MXY(11))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10))
             KFLAG = -4
             GO TO 170
         ENDIF
         NDENOM = NTERM*(NTERM-1)
         CALL FMDIVI(MXY(11),NDENOM,MJSUMS(J))
      ENDDO

      NDIG2 = NDIG
  130 CALL FMMPY_R1(MXY(10),MXY(9))

      NMXDIF = MIN(NDSAV1,NGRD22)
      DO J = 1, J2
         NTERM = NTERM + 2
         CALL FMBERN(NTERM,MXY(10),MXY(11))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10))
             KFLAG = -4
             GO TO 170
         ENDIF
         NDENOM = NTERM*(NTERM-1)
         IF (NDENOM <= MXBASE) THEN
             CALL FMDIVI_R1(MXY(11),NDENOM)
         ELSE
             CALL FMDIVI_R1(MXY(11),NTERM)
             NDENOM = NTERM - 1
             CALL FMDIVI_R1(MXY(11),NDENOM)
         ENDIF
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(11))
         NMXDIF = MAX(NMXDIF,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(11))+2)))
         NDIG = NDIG2
         IF (KFLAG /= 0) GO TO 140
      ENDDO
      NDIG2 = NMXDIF
      NDIG = NDIG2
      GO TO 130

!             Put the J2 concurrent sums back together.

  140 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMSQR(MXY(12),MXY(11))
          CALL FMI2M(1,MXY(5))
          CALL FMDIV_R2(MXY(5),MXY(11))
          CALL FMEQ(MJSUMS(J2),MXY(9))
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(9),MXY(11))
             CALL FMADD_R1(MXY(9),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(9),MJSUMS(1))
      ENDIF

!             Add the log terms to the asymptotic series.

!       MXY(10) is the current sum as the log terms are added
!       MXY(11) is now LN(Z+LSHIFT)

      CALL FMDIV(MJSUMS(1),MXY(12),MXY(10))
      CALL FMLN(MXY(12),MXY(11))
      IF (MBASE /= MBS2PI .OR. NDIG > NDG2PI) THEN
          NDMB = INT(150.0*2.302585/ALOGMB)
          IF (NDMB >= NDIG) THEN
              NDSV = NDIG
              NDIG = NDMB
              STRING = '1.837877066409345483560659472811235279722794'//  &
              '94727556682563430308096553139185452079538948659727190'//  &
              '8395244011293249268674892733725763681587144311751830445'
              CALL FMST2M(STRING,M_LN_2PI)
              MWK(START(M_LN_2PI)+1) = NINT(NDIG*ALOGM2)
              MBS2PI = MBASE
              NDG2PI = NDIG
              IF (ABS(MWK(START(M_LN_2PI)+2)) > 10) NDG2PI = 0
              NDIG = NDSV
          ELSE
              NDSV = NDIG
              NDIG = NDIG + 2
              CALL FMPI(MXY(9))
              CALL FMMPYI(MXY(9),2,MXY(5))
              CALL FMLN(MXY(5),M_LN_2PI)
              MBS2PI = MBASE
              NDG2PI = NDIG
              IF (ABS(MWK(START(M_LN_2PI)+2)) > 10) NDG2PI = 0
              NDIG = NDSV
          ENDIF
      ENDIF
      CALL FMSUB(M_LN_2PI,MXY(11),MXY(5))
      CALL FMDIVI(MXY(5),2,MXY(9))
      CALL FMADD_R1(MXY(10),MXY(9))
      CALL FMSUB_R1(MXY(10),MXY(12))
      CALL FMMPY(MXY(11),MXY(12),MXY(9))
      CALL FMADD_R1(MXY(10),MXY(9))

!             Now the log of gamma of the shifted argument has been computed.  Reverse the shifting.
!             The product MA*(MA+1)*...*(MA+LSHIFT-1) is computed four terms at a time to reduce
!             the number of FMMPY calls.

!             MXY(13) is Z
!             MXY(6) is Z**2
!             MXY(7) is Z**3
!             MXY(8) is (Z+K)*...*(Z+K+3)
!             MXY(11) is the current product

      IF (LSHIFT > 0) THEN
          CALL FMSQR(MXY(13),MXY(6))
          CALL FMMPY(MXY(13),MXY(6),MXY(7))
          CALL FMSQR(MXY(6),MXY(8))
          CALL FMMPYI(MXY(7),6,MXY(12))
          CALL FMADD_R1(MXY(8),MXY(12))
          CALL FMMPYI(MXY(6),11,MXY(12))
          CALL FMADD_R1(MXY(8),MXY(12))
          CALL FMMPYI(MXY(13),6,MXY(12))
          CALL FMADD_R1(MXY(8),MXY(12))
          CALL FMEQ(MXY(8),MXY(11))
          CALL FMMPYI_R1(MXY(7),16)
          DO K = 0, LSHIFT-8, 4
             CALL FMADD_R1(MXY(8),MXY(7))
             K2 = 24*(2*K + 7)
             CALL FMMPYI(MXY(6),K2,MXY(12))
             CALL FMADD_R1(MXY(8),MXY(12))
             IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                 K1 = 8*(6*K*K + 42*K + 79)
                 CALL FMMPYI(MXY(13),K1,MXY(12))
                 CALL FMADD_R1(MXY(8),MXY(12))
             ELSE
                 K1 = 48*K
                 CALL FMMPYI(MXY(13),K1,MXY(12))
                 CALL FMMPYI_R1(MXY(12),K)
                 CALL FMADD_R1(MXY(8),MXY(12))
                 K1 = 336*K + 632
                 CALL FMMPYI(MXY(13),K1,MXY(12))
                 CALL FMADD_R1(MXY(8),MXY(12))
             ENDIF
             IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                 K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                 CALL FMADDI(MXY(8),K0)
             ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12))
                 K0 = K*K + 7*K + 15
                 CALL FMMPYI_R1(MXY(12),K0)
                 CALL FMADD_R1(MXY(8),MXY(12))
             ELSE
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12))
                 CALL FMMPYI(MXY(12),K,MXY(9))
                 CALL FMMPYI_R1(MXY(9),K)
                 CALL FMADD_R1(MXY(8),MXY(9))
                 K0 = 7*K + 15
                 CALL FMMPYI_R1(MXY(12),K0)
                 CALL FMADD_R1(MXY(8),MXY(12))
             ENDIF
             CALL FMMPY_R1(MXY(11),MXY(8))
          ENDDO
          CALL FMLN(MXY(11),MXY(4))
          CALL FMSUB_R1(MXY(10),MXY(4))
      ENDIF

!             Use the reflection formula if MA was negative.

      IF (MAS < 0) THEN

!             Reduce the argument before multiplying by Pi.

          CALL FMNINT(MXY(13),MXY(6))
          CALL FMDIVI(MXY(6),2,MXY(7))
          CALL FMINT(MXY(7),MXY(2))
          CALL FMMPYI(MXY(2),2,MXY(8))
          KSIGN = -1
          IF (FMCOMP(MXY(6),'==',MXY(8))) KSIGN = 1
          CALL FMSUB(MXY(13),MXY(6),MXY(9))
          MWK(START(MXY(9))+1) = MWK(START(MXY(13))+1)
          CALL FMPI(MXY(11))
          CALL FMMPY_R1(MXY(11),MXY(9))
          KRSAVE = KRAD
          KRAD = 1
          CALL FMSIN(MXY(11),MXY(3))
          MWK(START(MXY(3))) = KSIGN*MWK(START(MXY(3)))
          KRAD = KRSAVE
          CALL FMDIV_R2(MPISAV,MXY(3))
          CALL FMLN(MXY(3),MXY(4))
          CALL FMSUB_R2(MXY(4),MXY(10))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  150 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(10))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(10))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(10))+J+1)) GO TO 160
              ENDDO
              GO TO 170
          ENDIF
  160     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(10))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(13))
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  170 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(10))+1) = MIN(MWK(START(MXY(10))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLNGM

      SUBROUTINE FMPGAM(N,MA,MB)

!  MB = POLYGAMMA(N,MA)      (Nth Derivative of PSI)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTA,J,J2,JN,JNC,JSTART,K,KASAVE,KFL,KL,KOVUN,KR_RETRY,KRESLT,     &
                 KRFLCT,KRSAVE,KWRNSV,K_RETURN_CODE,LSHIFT,N1,NBOT,NC,NDGOAL,NDIG2,NDOLD,  &
                 NDSAV1,NDSAVE,NDSV2,NGOAL,NMXDIF,NTERM,NTOP,NUMTRY

!             Set the coefficients used in computing various derivatives of COT(Pi*X)
!             for the reflection formula.

      INTEGER :: KGCD(14) =  &
              (/ 1, 2, 2, 8, 8, 16, 16, 128, 128, 256, 256, 1024, 1024, 2048 /)
      INTEGER :: KCOEFF(56) = (/  &
                    1,          1,              3, 1,     3, 2,                           &
                    15, 15, 2,                  45, 60, 17,                               &
                    315, 525, 231, 17,          315, 630, 378, 62,                        &
                    2835, 6615, 5040, 1320, 62,                                           &
                    14175, 37800, 34965, 12720, 1382,                                     &
                    155925, 467775, 509355, 238425, 42306, 1382,                          &
                    467775, 1559250, 1954260, 1121670, 280731, 21844,                     &
                    6081075, 22297275, 31621590, 21531510, 7012005,  907725, 21844,       &
                    42567525, 170270100, 269594325, 212612400, 85630545, 15839460, 929569 /)
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(13),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. N >= 0) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMI2M(0,MXY(2))
          CALL FMSUB(MXY(2),MXY(1),MXY(3))
          CALL FMIPWR(MXY(3),-N-1,MXY(4))
          IF (N >= 2) THEN
              CALL FMI2M(N,MXY(6))
              CALL FMFACT(MXY(6),MXY(7))
              CALL FMMPY_R1(MXY(4),MXY(7))
          ENDIF
          IF (N == 0) THEN
              CALL FMEULR(MXY(2))
              CALL FMMPYI(MXY(2),-1,MXY(5))
          ELSE IF (MOD(N,2) == 1) THEN
              CALL FMI2M(1,MXY(2))
              CALL FMBERN(N+1,MXY(2),MXY(3))
              CALL FMABS(MXY(3),MXY(6))
              CALL FMPI(MXY(7))
              CALL FMIPWR(MXY(7),N+1,MXY(8))
              CALL FMMPY(MXY(6),MXY(8),MXY(7))
              CALL FMI2M(2,MXY(2))
              CALL FMIPWR(MXY(2),N-1,MXY(6))
              CALL FMMPY(MXY(6),MXY(7),MXY(8))
              CALL FMDIVI(MXY(8),(N+1)/2,MXY(5))
          ELSE
              CALL FMI2M(1,MXY(2))
              CALL FMBERN(N,MXY(2),MXY(3))
              CALL FMABS(MXY(3),MXY(6))
              CALL FMPI(MXY(7))
              CALL FMIPWR(MXY(7),N,MXY(8))
              CALL FMMPY(MXY(6),MXY(8),MXY(7))
              CALL FMI2M(2,MXY(2))
              CALL FMIPWR(MXY(2),N-2,MXY(6))
              CALL FMMPY(MXY(6),MXY(7),MXY(8))
              CALL FMDIVI(MXY(8),N/2,MXY(10))
              CALL FMI2M(1,MXY(2))
              CALL FMBERN(N+2,MXY(2),MXY(3))
              CALL FMABS(MXY(3),MXY(6))
              CALL FMPI(MXY(7))
              CALL FMIPWR(MXY(7),N+2,MXY(8))
              CALL FMMPY(MXY(6),MXY(8),MXY(7))
              CALL FMI2M(2,MXY(2))
              CALL FMIPWR(MXY(2),N,MXY(6))
              CALL FMMPY(MXY(6),MXY(7),MXY(8))
              CALL FMDIVI(MXY(8),(N+2)/2,MXY(11))
              CALL FMMPY(MXY(10),MXY(11),MXY(9))
              CALL FMSQRT(MXY(9),MXY(10))
              CALL FMI2M(0,MXY(8))
              CALL FMSUB(MXY(8),MXY(10),MXY(5))
          ENDIF
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG+1 .AND.  &
              MWK(START(MXY(4))+2) < MEXPOV) THEN
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB)
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPGAM'
                  CALL FMNTRI(2,N,1)
                  CALL FMNTR(2,MA,MA,1,0)
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMPGAM'
          CALL FMNTRI(2,N,1)
          NCALL = NCALL - 1
      ENDIF
      CALL FMENT2('FMPGAM   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQ(MXY(1),MXY(13))
      NUMTRY = 0

  120 IF (N == 0) THEN
          CALL FMPSI(MXY(1),MXY(10))
          GO TO 160
      ENDIF
      IF (N < 0 .OR. MWK(START(MA)+3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(10))
          KFLAG = -4
          GO TO 180
      ENDIF

!             Near zero PGAM(x) is about n!/(-x)**(n+1).

      IF (MWK(START(MXY(13))+2) < (-NDIG-1)) THEN
          CALL FMFCTI(N,MXY(12))
          IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
              MWK(START(MXY(13))) = -MWK(START(MXY(13)))
          CALL FMIPWR(MXY(13),N+1,MXY(11))
          CALL FMDIV(MXY(12),MXY(11),MXY(10))
          GO TO 160
      ENDIF

!             Check for special cases.

      KRFLCT = 0
      CALL FMDP2M(-0.5D0,MXY(5))
      IF (FMCOMP(MXY(13),'<=',MXY(5))) THEN
          KRFLCT = 1
          KFL = 0
          IF (MWK(START(MA)+2) <= NDSAVE) THEN
              CALL FMINT(MXY(13),MXY(9))
              IF (FMCOMP(MXY(13),'==',MXY(9))) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(10))
              KFLAG = -4
              GO TO 180
          ELSE
              CALL FMI2M(1,MXY(4))
              CALL FMSUB_R2(MXY(4),MXY(13))
          ENDIF
      ENDIF
      IF (MWK(START(MA)+2) > NDIG+3) THEN
          CALL FMIPWR(MXY(13),-N,MXY(10))
          IF (MWK(START(MXY(10))+2) /= MEXPUN) THEN
              CALL FMFCTI(N-1,MXY(9))
              CALL FMMPY_R1(MXY(10),MXY(9))
          ENDIF
          IF (MOD(N-1,2) == 1 .AND. MWK(START(MXY(10))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(10))+3) /= 0) MWK(START(MXY(10))) = -MWK(START(MXY(10)))
          IF (KROUND /= 1) THEN
              IF (MWK(START(MXY(10))+2) /= MEXPUN) THEN
                  CALL FMMPYI(MXY(10),N,MXY(4))
                  CALL FMDIVI_R1(MXY(4),2)
                  CALL FMDIV_R1(MXY(4),MXY(13))
                  CALL FMADD_R1(MXY(10),MXY(4))
              ENDIF
          ENDIF
          GO TO 160
      ENDIF

!             To speed the asymptotic series calculation, increase the argument by LSHIFT.

      IEXTRA = 0
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(13),INTA)
      KWARN = KWRNSV

      IF (KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(NDIG)*ALOGMB/4.46-REAL(INTA)))
          LSHIFT = LSHIFT + (7*N)/20
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(4))
          CALL FMADD(MXY(13),MXY(4),MXY(12))
      ELSE
          CALL FMEQ(MXY(13),MXY(12))
      ENDIF

!             Sum the asymptotic series.

      J2 = INT(0.3*ALOGMB + 0.2*SQRT(REAL(NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))

!             MXY(13) is Z
!             MXY(12) is Z + LSHIFT
!             MXY(9) is X**J2 = (1/(Z+LSHIFT)**2)**J2
!             MXY(10) is the current power of X times the quotient of factorials in each term
!             MXY(11) is the current term in the sum
!             MXY(8) is (N+1)!
!             MJSUMS holds the partial sums

      NDSAV1 = NDIG
      CALL FMFCTI(N+1,MXY(8))
      CALL FMDIVI(MXY(8),2,MXY(10))
      J = -2*J2
      CALL FMIPWR(MXY(12),J,MXY(9))
      IF (ABS(MWK(START(MXY(9))+2)) >= MEXPAB) THEN
          J2 = 1
          CALL FMIPWR(MXY(12),-2,MXY(9))
      ENDIF
      DO J = 1, J2
         NTERM = 2*J
         CALL FMBERN(NTERM,MXY(10),MJSUMS(J))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10))
             KFLAG = -4
             GO TO 180
         ENDIF
         NTOP = (N+NTERM)*(N+NTERM+1)
         CALL FMMPYI_R1(MXY(10),NTOP)
         NBOT = (NTERM+1)*(NTERM+2)
         CALL FMDIVI_R1(MXY(10),NBOT)
      ENDDO

      NDIG2 = NDIG
  130 CALL FMMPY_R1(MXY(10),MXY(9))
      NMXDIF = MIN(NDSAV1,NGRD22)
      DO J = 1, J2
         NTERM = NTERM + 2
         CALL FMBERN(NTERM,MXY(10),MXY(11))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(10))
             KFLAG = -4
             GO TO 180
         ENDIF
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(11))
         IF (KFLAG /= 0) THEN
             GO TO 140
         ELSE
             NMXDIF = MAX(NMXDIF,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(11))+2)))
             NDIG = NDIG2
             NTOP = (N+NTERM)*(N+NTERM+1)
             CALL FMMPYI_R1(MXY(10),NTOP)
             NBOT = (NTERM+1)*(NTERM+2)
             CALL FMDIVI_R1(MXY(10),NBOT)
         ENDIF
      ENDDO
      NDIG2 = NMXDIF
      NDIG = NDIG2
      GO TO 130

!             Put the J2 concurrent sums back together.

  140 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMI2M(1,MXY(9))
          CALL FMSQR(MXY(12),MXY(11))
          CALL FMDIV_R2(MXY(9),MXY(11))
          CALL FMEQ(MJSUMS(J2),MXY(9))
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(9),MXY(11))
             CALL FMADD_R1(MXY(9),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(9),MJSUMS(1))
      ENDIF
      CALL FMIPWR(MXY(12),N+2,MXY(6))
      CALL FMDIV_R1(MJSUMS(1),MXY(6))

!             Add the initial terms to the asymptotic series.

      CALL FMDIVI(MXY(8),N+1,MXY(9))
      CALL FMDIVI(MXY(9),N,MXY(8))
      CALL FMMPYI(MXY(12),2,MXY(7))
      CALL FMI2M(N,MXY(10))
      CALL FMADD_R1(MXY(7),MXY(10))
      CALL FMMPY_R1(MXY(7),MXY(8))
      CALL FMMPYI_R1(MXY(6),2)
      CALL FMDIV_R1(MXY(6),MXY(12))
      CALL FMDIV(MXY(7),MXY(6),MXY(10))
      CALL FMADD_R2(MJSUMS(1),MXY(10))
      IF (MOD(N-1,2) == 1 .AND. MWK(START(MXY(10))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(10))+3) /= 0) MWK(START(MXY(10))) = -MWK(START(MXY(10)))

!             Now PGAM of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(MA)**(N+1) + ... + 1/(MA+LSHIFT-1)**(N+1) is computed.

!             MXY(13) is Z
!             MXY(9) is N!
!             MXY(10) is the sum of the asymptotic series
!             MXY(11) is the sum 1/(MA)**(N+1) + ... + 1/(MA+LSHIFT-1)**(N+1)

      IF (LSHIFT > 0) THEN
          CALL FMI2M(1,MXY(6))
          CALL FMEQ(MXY(13),MXY(7))
          N1 = -(N + 1)
          CALL FMIPWR(MXY(7),N1,MXY(11))
          DO K = 1, LSHIFT-1
             CALL FMADD_R1(MXY(7),MXY(6))
             CALL FMIPWR(MXY(7),N1,MXY(12))
             CALL FMADD_R1(MXY(11),MXY(12))
          ENDDO
          CALL FMMPY_R2(MXY(9),MXY(11))
          IF (MOD(N+1,2) == 1 .AND. MWK(START(MXY(11))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(11))+3) /= 0) MWK(START(MXY(11))) = -MWK(START(MXY(11)))
          CALL FMADD_R1(MXY(10),MXY(11))
      ENDIF

!             Use the reflection formula if MA was less than -1/2.

      IF (KRFLCT == 1) THEN

!             MXY(11) is COT(Pi*Z)
!             MXY(9) is MXY(11)**2

!             Reduce the argument before multiplying by Pi.

          CALL FMMPYI(MXY(13),2,MXY(5))
          CALL FMINT(MXY(5),MXY(9))
          IF (FMCOMP(MXY(5),'==',MXY(9))) THEN
              CALL FMI2M(0,MXY(11))
              CALL FMEQ(MXY(11),MXY(9))
              CALL FMI2M(1,MXY(5))
          ELSE
              CALL FMNINT(MXY(13),MXY(5))
              CALL FMSUB(MXY(13),MXY(5),MXY(9))
              NDSV2 = NDIG
  150         CALL FMPI(MXY(11))
              CALL FMMPY_R1(MXY(11),MXY(9))
              KRSAVE = KRAD
              KRAD = 1
              CALL FMTAN(MXY(11),MXY(2))
              CALL FMEQ(MXY(2),MXY(11))
              KRAD = KRSAVE
              IF ((MWK(START(MXY(11))+2) < 0 .OR. MWK(START(MXY(11))+2) > 1) .AND.  &
                  NDSV2 == NDIG) THEN
                  IEXTRA = INT(MAX(-MWK(START(MXY(11))+2),MWK(START(MXY(11))+2)))
                  IF (IEXTRA > 0) THEN
                      CALL FMEQU_R1(MXY(9),NDIG,NDIG+IEXTRA)
                  ENDIF
                  NDIG = NDIG + IEXTRA
                  GO TO 150
              ENDIF

              NDIG = NDSV2
              CALL FMI2M(1,MXY(5))
              CALL FMDIV_R2(MXY(5),MXY(11))
              CALL FMSQR(MXY(11),MXY(9))
          ENDIF
          NC = (N+1)/2

!             For N up to 14, use the stored coefficients to compute the Nth derivative
!             of Cot(Pi*Z).  For larger N, the coefficients are generated from a recurrence
!             relation and stored as FM numbers.

          IF (N <= 14) THEN
              JSTART = (N*N + 4 - MOD(N,2))/4
              IF (N <= 2) THEN
                  CALL FMI2M(1,MXY(6))
              ELSE
                  CALL FMMPYI(MXY(9),KCOEFF(JSTART),MXY(6))
              ENDIF
              DO J = 2, NC
                 CALL FMI2M(KCOEFF(JSTART+J-1),MXY(7))
                 CALL FMADD_R1(MXY(6),MXY(7))
                 IF (J < NC) CALL FMMPY_R1(MXY(6),MXY(9))
              ENDDO
              IF (MOD(N,2) == 0) CALL FMMPY_R1(MXY(6),MXY(11))
              IF (N > 1) CALL FMMPYI_R1(MXY(6),KGCD(N))
          ELSE
              IF (NC > LJSUMS) THEN
                  KFLAG = -12
                  CALL FMWRN2
                  WRITE (KW,  &
                         "(' For PGAM(',I5,',*) with NDIG =',I5,',',I7,"  //  &
                         "' words are needed'/' in array MJSUMS.',"       //  &
                         "'  The current dimension of MJSUMS IS',I7/)"        &
                        ) N,NDIG,NC*(NDIG+3),LJSUMS
                  MXEXP = MXSAVE
                  NDIG = NDSAVE
                  CALL FMST2M('UNKNOWN',MB)
                  IF (NTRACE /= 0) CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
                  KACCSW = KASAVE
                  NUMBER_USED = NUMBER_USED_SAVE
                  IF (TEMPV_CALL_STACK == 1) THEN
                      IF (TEMPV(MB) == -1) TEMPV(MB) = -2
                  ENDIF
                  TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
                  RETURN
              ENDIF

              DO J = 1, 7
                 CALL FMI2M(KCOEFF(J+49),MJSUMS(J))
                 CALL FMMPYI_R1(MJSUMS(J),KGCD(14))
              ENDDO
              DO JN = 15, N
                 JNC = (JN+1)/2
                 DO K = JNC, 2, -1
                    IF (K == JNC .AND. MOD(JN,2) == 1) THEN
                        CALL FMEQ(MJSUMS(K-1),MJSUMS(K))
                    ELSE
                        CALL FMADD_R2(MJSUMS(K-1),MJSUMS(K))
                        CALL FMMPYI_R1(MJSUMS(K),JN-2*(K-1))
                    ENDIF
                 ENDDO
                 CALL FMMPYI_R1(MJSUMS(1),JN)
              ENDDO

!             MJSUMS now has the coefficients needed for the polynomial in Cot**2 that defines
!             the Nth derivative of Cot.

              CALL FMEQ(MJSUMS(1),MXY(6))
              DO J = 2, NC
                 CALL FMMPY_R1(MXY(6),MXY(9))
                 CALL FMADD_R1(MXY(6),MJSUMS(J))
              ENDDO
              IF (MOD(N,2) == 0) CALL FMMPY_R1(MXY(6),MXY(11))
          ENDIF

!             To complete the calculation of the Nth derivative of Cot, multiply the polynomial
!             in Cot**2 by Csc**2.

          CALL FMADD(MXY(9),MXY(5),MXY(7))
          CALL FMMPY_R1(MXY(6),MXY(7))

          CALL FMPI(MXY(7))
          CALL FMIPWR(MPISAV,N+1,MXY(7))
          CALL FMMPY_R1(MXY(6),MXY(7))
          IF (MOD(N,2) == 1 .AND. MWK(START(MXY(10))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(10))+3) /= 0) MWK(START(MXY(10))) = -MWK(START(MXY(10)))
          CALL FMADD_R1(MXY(10),MXY(6))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(10))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(10))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(10))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(10))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(13))
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(10))+1) = MIN(MWK(START(MXY(10))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPGAM

      SUBROUTINE FMPOCH(MA,N,MB)

!  MB = MA*(MA+1)*(MA+2)*...*(MA+N-1)       (Pochhammer's symbol)

!  MB = Gamma(MA+N)/Gamma(MA)

!  For negative N, Pochhammer(MA,N) = 1/Pochhammer(MA+N,-N).

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: N
      REAL (KIND(1.0D0)) :: MA2,MAS,MACCA,MACMAX,MBSIGN,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,JR,K,K0,K1,K2,KASAVE,KL,KLAST,KM08,KMB,KOVUN,KR_RETRY,KRESLT,  &
                 KRSAVE,K_RETURN_CODE,LT,NDGOAL,NDOLD,NDSAVE,NGOAL,NT,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      REAL :: T
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(15),MRETRY,NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG .AND. N /= 0 .AND. N /= 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          NT = ABS(N) - 1
          IF (N < 0) NT = NT + 1
          CALL FMI2M(NT,MXY(2))
          CALL FMFACT(MXY(2),MXY(3))
          CALL FMMPY(MXY(1),MXY(3),MXY(4))
          IF (NT <= 20) THEN
              CALL FMI2M(1,MXY(2))
              CALL FMI2M(1,MXY(5))
              DO K1 = 2, NT
                 CALL FMDIVI(MXY(2),K1,MXY(6))
                 CALL FMADD_R1(MXY(5),MXY(6))
              ENDDO
          ELSE
              CALL FMI2M(NT,MXY(7))
              CALL FMLN(MXY(7),MXY(5))
              CALL FMEULR(MXY(6))
              CALL FMADD_R1(MXY(5),MXY(6))
              CALL FMI2M(1,MXY(2))
              CALL FMDIV(MXY(2),MXY(7),MXY(8))
              CALL FMDIVI(MXY(8),2,MXY(6))
              CALL FMADD_R1(MXY(5),MXY(6))
              CALL FMSQR(MXY(8),MXY(9))
              CALL FMDIVI(MXY(9),12,MXY(6))
              CALL FMSUB_R1(MXY(5),MXY(6))
              CALL FMSQR(MXY(9),MXY(8))
              CALL FMDIVI(MXY(8),120,MXY(6))
              CALL FMADD_R1(MXY(5),MXY(6))
          ENDIF
          IF (N > 0) THEN
              CALL FMEQ(MXY(4),MXY(6))
              CALL FMMPY(MXY(4),MXY(5),MXY(8))
              CALL FMMPY(MXY(1),MXY(8),MXY(7))
          ELSE
              IF (MOD(NT,2) == 0) THEN
                  CALL FMI2M(1,MXY(2))
              ELSE
                  CALL FMI2M(-1,MXY(2))
              ENDIF
              CALL FMDIV(MXY(2),MXY(3),MXY(6))
              CALL FMMPY(MXY(6),MXY(5),MXY(8))
              CALL FMMPY(MXY(1),MXY(8),MXY(7))
          ENDIF
          IF (MWK(START(MXY(6))+2) - MWK(START(MXY(7))+2) > NDIG+1 .AND.  &
              MWK(START(MXY(6))+2) < MEXPOV) THEN
              CALL FMEQU(MXY(6),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(9),NDIG,NDSAVE)
              CALL FMEQU(MXY(9),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(6),MXY(8),MXY(9))
              IF (MWK(START(MXY(9))+3) == 0) THEN
                  CALL FMEQU(MXY(6),MXY(8),NDIG,NDSAVE)
                  CALL FMEQU(MXY(7),MXY(9),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(8),MXY(9),MB)
                  IF (MWK(START(MB)+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(8))) > 0) THEN
                          IF (MWK(START(MXY(9))) < 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(8),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(8))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(9))) > 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(8),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(8))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(9))) < 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(8),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(8))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(9))) > 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(8),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(8))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(6),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPOCH'
                  CALL FMNTR(2,MA,MA,1,1)
                  CALL FMNTRI(2,N,0)
                  NCALL = NCALL - 1
              ENDIF
              IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPOCH'
                  KFLAG = -4
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPOCH'
                  IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ENDIF
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPOCH'
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMPOCH   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      CALL FMNTRI(2,N,0)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MA2 = MWK(START(MA)+3)
      MAS = MWK(START(MA))
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      NT = N
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQ(MXY(1),MXY(13))
      NUMTRY = 0

!             Check for special cases.

  120 IEXTRA = 0
      IF (N == 0) THEN
          CALL FMI2M(1,MXY(11))
          GO TO 160
      ENDIF
      IF (NT < 0) THEN
          CALL FMADDI(MXY(1),NT)
          CALL FMEQ(MXY(1),MXY(13))
          NT = -NT
          MA2 = MWK(START(MXY(1))+3)
          MAS = MWK(START(MXY(1)))
      ENDIF
      IF (MA2 == 0) THEN
          IF (NT > 0) THEN
              CALL FMI2M(0,MXY(11))
              GO TO 140
          ELSE
              CALL FMST2M('UNKNOWN',MXY(11))
              KFLAG = -4
              GO TO 160
          ENDIF
      ENDIF
      IF (NT == 0) THEN
          CALL FMI2M(1,MXY(11))
          GO TO 140
      ELSE IF (NT == 1) THEN
          CALL FMEQU(MXY(1),MXY(11),NDSAVE,NDIG)
          GO TO 140
      ENDIF
      CALL FMI2M(1,MXY(4))
      JR = KROUND
      KROUND = 1
      CALL FMADD(MXY(1),MXY(4),MXY(5))
      KROUND = JR
      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMST2M('OVERFLOW',MXY(11))
          IF (MAS < 0) MWK(START(MXY(11))) = (-1)**NT
          GO TO 140
      ELSE IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          IF (NT == 2) THEN
              CALL FMST2M('UNDERFLOW',MXY(11))
              IF (MAS < 0) MWK(START(MXY(11))) = -1
          ELSE
              CALL FMST2M('UNKNOWN',MXY(11))
              KFLAG = -4
          ENDIF
          GO TO 160
      ELSE IF (FMCOMP(MXY(5),'==',MXY(4))) THEN
          T = NDIG
          J = INT(15.21*SQRT(T)*ALOGMT + 42.87*SQRT(T) + 30.0)
          IF (NT <= J) THEN
              K1 = NT - 1
              CALL FMFCTI(K1,MXY(11))
              CALL FMMPY_R2(MXY(1),MXY(11))
              GO TO 140
          ENDIF
      ENDIF

!             Look for cases where overflow is easy to detect.

      CALL FMI2M(NT,MXY(9))
      CALL FMABS(MXY(13),MXY(7))
      IF (MWK(START(MXY(13))+2) > 0 .AND. FMCOMP(MXY(9),'<',MXY(7))) THEN
          CALL FMADD(MXY(13),MXY(9),MXY(8))
          MWK(START(MXY(8))) = 1
          CALL FMMIN(MXY(7),MXY(8),MXY(10))
          IF (INT(MWK(START(MXY(10))+2))-1 > INTMAX/NT) THEN
              CALL FMST2M('OVERFLOW',MXY(11))
              IF (MWK(START(MXY(13))) > 0) THEN
                  MWK(START(MXY(11))) = 1
              ELSE
                  MWK(START(MXY(11))) = (-1)**MOD(NT,2)
              ENDIF
              KFLAG = -5
              GO TO 140
          ENDIF
      ENDIF

!             For large values of MA, the result is MA**NT.

      LT = NDIG + 3 + INT(2.0D0*LOG(DBLE(NT))/DLOGMB)
      IF (MWK(START(MXY(1))+2) > LT) THEN
          CALL FMIPWR(MXY(13),NT,MXY(11))
          IF (KROUND /= 1 .AND. NT > 1) THEN
              IF (ABS(MWK(START(MXY(11))+2)) /= MEXPOV) THEN
                  CALL FMDIV(MXY(11),MXY(13),MXY(8))
                  IF (MOD(NT,2) == 0) THEN
                      CALL FMMPYI_R1(MXY(8),NT-1)
                      CALL FMMPYI_R1(MXY(8),NT/2)
                  ELSE
                      CALL FMMPYI_R1(MXY(8),(NT-1)/2)
                      CALL FMMPYI_R1(MXY(8),NT)
                  ENDIF
                  CALL FMADD_R1(MXY(11),MXY(8))
              ENDIF
          ENDIF
          GO TO 140
      ENDIF

      MBSIGN = 1
      IF (MAS < 0) THEN
          CALL FMINT(MXY(13),MXY(8))
          CALL FMI2M(NT,MXY(9))
          JR = KROUND
          KROUND = 1
          CALL FMADD(MXY(13),MXY(9),MXY(10))
          KROUND = JR
          IF (FMCOMP(MXY(13),'==',MXY(8))) THEN

!                  If MA is a negative integer and MA+NT is positive, then the result is zero.

              IF (MWK(START(MXY(10)))*MWK(START(MXY(10))+3) > 0) THEN
                  CALL FMI2M(0,MXY(11))
                  GO TO 140
              ENDIF
          ENDIF

!                  If MA is negative and MA+NT-1 is negative, then use the reflection formula
!                  Pochhammer(MA,NT) = (-1)**NT*Pochhammer(-MA-(NT-1),NT).

          CALL FMI2M(1,MXY(11))
          IF (FMCOMP(MXY(10),'<',MXY(11))) THEN

!                 Extra guard digits may be required to insure the reflection formula is accurate.

              IEXTRA = MAX(INT(MWK(START(MXY(13))+2)),IEXTRA)
              IF (IEXTRA > 0) THEN
                  CALL FMEQU_R1(MXY(13),NDIG,NDIG+IEXTRA)
              ENDIF
              NDIG = NDIG + IEXTRA
              CALL FMI2M(NT-1,MXY(11))
              IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
                  MWK(START(MXY(13))) = -MWK(START(MXY(13)))
              CALL FMSUB_R1(MXY(13),MXY(11))
              IF (MOD(NT,2) == 1) MBSIGN = -1
          ENDIF
      ENDIF

!             If NT is large enough, it is faster to use two calls to FMLNGM.
!             The formula below gives a rough approximation of where to change methods.

      T = NDIG
      J = INT(15.21*SQRT(T)*ALOGMT + 42.87*SQRT(T) + 25.03)
      IF (NT > J) THEN
          CALL FMI2M(NT,MXY(4))
          CALL FMADD(MXY(13),MXY(4),MXY(14))

!             Compute IEXTRA, the number of extra digits required to compensate for
!             cancellation error.

          IF (MAX(MWK(START(MXY(13))+2),MWK(START(MXY(14))+2)) > IEXTRA) THEN
              IEXTRA = INT(MAX(MWK(START(MXY(13))+2),MWK(START(MXY(14))+2)))
          ENDIF
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(13),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA

          CALL FMI2M(-1,MXY(15))
          IF (IEXTRA > 0) THEN
              CALL FMI2M(NT,MXY(4))
              CALL FMADD(MXY(13),MXY(4),MXY(14))
          ENDIF
          CALL FMI2M(2,MXY(9))
          KMB = 0
          IF (MWK(START(MXY(13))) < 0) THEN
              CALL FMMOD(MXY(13),MXY(9),MXY(8))
              IF (FMCOMP(MXY(8),'>',MXY(15))) KMB = 1
          ENDIF
          KM08 = 0
          IF (MWK(START(MXY(14))) < 0) THEN
              CALL FMMOD(MXY(14),MXY(9),MXY(8))
              IF (FMCOMP(MXY(8),'>',MXY(15))) KM08 = 1
          ENDIF
          CALL FMI2M(1,MXY(15))
          IF (MWK(START(MXY(13))) < 0 .AND. KMB == 1) THEN
              CALL FMEQ(MXY(13),MXY(15))
              CALL FMI2M(1,MXY(4))
              CALL FMADD(MXY(13),MXY(4),MXY(2))
              CALL FMLNGM(MXY(2),MXY(13))
          ELSE
              CALL FMLNGM(MXY(13),MXY(3))
              CALL FMEQ(MXY(3),MXY(13))
          ENDIF
          IF (MWK(START(MXY(14))) < 0 .AND. KM08 == 1) THEN
              CALL FMI2M(-1,MXY(7))
              CALL FMADD_R1(MXY(14),MXY(7))
              CALL FMMPY(MXY(15),MXY(14),MXY(2))
              CALL FMLNGM(MXY(2),MXY(14))
          ELSE
              CALL FMLNGM(MXY(14),MXY(3))
              CALL FMEQ(MXY(3),MXY(14))
          ENDIF

          CALL FMSUB(MXY(14),MXY(13),MXY(11))
          CALL FMEXP(MXY(11),MXY(2))
          CALL FMMPY(MXY(2),MXY(15),MXY(11))
          GO TO 130
      ENDIF

!             Compute the product Z*(Z+1)*...*(Z+NT-1) four terms at a time to reduce the number
!             of FMMPY calls.

!             MXY(13) is Z
!             MXY(6) is Z**2
!             MXY(7) is Z**3
!             MXY(8) is (Z+K)*...*(Z+K+3)
!             MXY(11) is the current product

!             If MXY(13) is negative and MXY(13)+NT is positive, extra digits are required when
!             MXY(13) is close to an integer.

      IF (MWK(START(MXY(13))) < 0) THEN
          CALL FMI2M(NT,MXY(8))
          CALL FMADD(MXY(13),MXY(8),MXY(9))
          IF (MWK(START(MXY(9)))*MWK(START(MXY(9))+3) > 0) THEN
              CALL FMNINT(MXY(13),MXY(10))
              IF (MWK(START(MXY(10))+3) /= 0) THEN
                  CALL FMSUB(MXY(13),MXY(10),MXY(9))
                  IEXTRA = MAX(IEXTRA,NDIG-NDSAVE)
                  IF (MAX(MWK(START(MXY(13))+2),MWK(START(MXY(9))+2)) > IEXTRA) THEN
                      IEXTRA = INT(MAX(MWK(START(MXY(13))+2),MWK(START(MXY(9))+2)))
                  ENDIF
                  IF (IEXTRA > 0) THEN
                      CALL FMEQU_R1(MXY(13),NDIG,NDIG+IEXTRA)
                  ENDIF
                  NDIG = NDIG + IEXTRA
              ENDIF
          ENDIF
      ENDIF

      CALL FMI2M(1,MXY(11))
      IF (NT >= 4) THEN
          CALL FMSQR(MXY(13),MXY(6))
          CALL FMMPY(MXY(13),MXY(6),MXY(7))
          CALL FMSQR(MXY(6),MXY(8))
          CALL FMMPYI(MXY(7),6,MXY(12))
          CALL FMADD_R1(MXY(8),MXY(12))
          CALL FMMPYI(MXY(6),11,MXY(12))
          CALL FMADD_R1(MXY(8),MXY(12))
          CALL FMMPYI(MXY(13),6,MXY(12))
          CALL FMADD_R1(MXY(8),MXY(12))
          CALL FMEQ(MXY(8),MXY(11))
          CALL FMMPYI_R1(MXY(7),16)
          DO K = 0, NT-8, 4
             CALL FMADD_R1(MXY(8),MXY(7))
             K2 = 24*(2*K + 7)
             CALL FMMPYI(MXY(6),K2,MXY(12))
             CALL FMADD_R1(MXY(8),MXY(12))
             IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                 K1 = 8*(6*K*K + 42*K + 79)
                 CALL FMMPYI(MXY(13),K1,MXY(12))
                 CALL FMADD_R1(MXY(8),MXY(12))
             ELSE
                 K1 = 48*K
                 CALL FMMPYI(MXY(13),K1,MXY(12))
                 CALL FMMPYI_R1(MXY(12),K)
                 CALL FMADD_R1(MXY(8),MXY(12))
                 K1 = 336*K + 632
                 CALL FMMPYI(MXY(13),K1,MXY(12))
                 CALL FMADD_R1(MXY(8),MXY(12))
             ENDIF
             IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                 K0 = 8*(2*K + 7)*(K*K + 7*K + 15)
                 CALL FMADDI(MXY(8),K0)
             ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12))
                 K0 = K*K + 7*K + 15
                 CALL FMMPYI_R1(MXY(12),K0)
                 CALL FMADD_R1(MXY(8),MXY(12))
             ELSE
                 K0 = 8*(2*K + 7)
                 CALL FMI2M(K0,MXY(12))
                 CALL FMMPYI(MXY(12),K,MXY(9))
                 CALL FMMPYI_R1(MXY(9),K)
                 CALL FMADD_R1(MXY(8),MXY(9))
                 K0 = 7*K + 15
                 CALL FMMPYI_R1(MXY(12),K0)
                 CALL FMADD_R1(MXY(8),MXY(12))
             ENDIF
             CALL FMMPY_R1(MXY(11),MXY(8))
          ENDDO
      ENDIF

      KLAST = (NT/4)*4
      DO J = KLAST, NT-1
         CALL FMI2M(J,MXY(9))
         CALL FMADD_R2(MXY(13),MXY(9))
         CALL FMMPY_R1(MXY(11),MXY(9))
      ENDDO

!             If the reflection formula was used, multiply by (-1)**NT.

  130 MWK(START(MXY(11))) = MBSIGN*MWK(START(MXY(11)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  140 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(11))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(11))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(11))+J+1)) GO TO 150
              ENDDO
              GO TO 160
          ENDIF
  150     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(11))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(13))
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(11),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  160 MACMAX = NINT(NDSAVE*ALOGM2)
      IF (N < 0) THEN
          CALL FMI2M(1,MXY(6))
          CALL FMDIV_R2(MXY(6),MXY(11))
      ENDIF
      MWK(START(MXY(11))+1) = MIN(MWK(START(MXY(11))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPOCH

      SUBROUTINE FMPSI(MA,MB)

!  MB = PSI(MA)      (Derivative of Ln(Gamma(MA))

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,INTA,J,J2,K,K0,K0B,K1,K1B,K2,KASAVE,KFL,KL,KOVUN,KR_RETRY,KRESLT,     &
                 KRFLCT,KRSAVE,KWRNSV,K_RETURN_CODE,LSHIFT,NDENOM,NDGOAL,NDIG2,NDOLD,NDSAV1,  &
                 NDSAVE,NGOAL,NMXDIF,NTERM,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(11),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMI2M(0,MXY(2))
          CALL FMSUB(MXY(2),MXY(1),MXY(3))
          CALL FMI2M(1,MXY(2))
          CALL FMDIV(MXY(2),MXY(3),MXY(4))
          CALL FMEULR(MXY(6))
          CALL FMMPYI(MXY(6),-1,MXY(5))
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG+1 .AND.  &
              MWK(START(MXY(4))+2) < MEXPOV) THEN
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB)
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMPSI'
                  CALL FMNTR(2,MA,MA,1,1)
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMPSI    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      CALL FMEQ(MXY(1),MXY(11))
      NUMTRY = 0

!             Near zero Psi(x) is about -1/x.

  120 IF (MWK(START(MXY(11))+2) < (-NDIG-1)) THEN
          CALL FMI2M(-1,MXY(3))
          CALL FMDIV(MXY(3),MXY(11),MXY(8))
          GO TO 150
      ENDIF

!             Check for special cases.

      KRFLCT = 0
      CALL FMDPM(DBLE(-0.5),MXY(4))
      IF (FMCOMP(MXY(11),'<=',MXY(4))) THEN
          KRFLCT = 1
          KFL = 0
          IF (MWK(START(MA)+2) <= NDSAVE) THEN
              CALL FMINT(MXY(11),MXY(7))
              IF (FMCOMP(MXY(11),'==',MXY(7))) KFL = -4
          ELSE
              KFL = -4
          ENDIF
          IF (KFL /= 0) THEN
              CALL FMST2M('UNKNOWN',MXY(8))
              KFLAG = -4
              GO TO 170
          ELSE
              CALL FMI2M(1,MXY(3))
              CALL FMSUB_R2(MXY(3),MXY(11))
          ENDIF
      ENDIF

!             To speed the asymptotic series calculation, increase the argument by LSHIFT.

      IEXTRA = 0
      KWRNSV = KWARN
      KWARN = 0
      CALL FMM2I(MXY(11),INTA)
      KWARN = KWRNSV

      IF (KFLAG == -4) THEN
          LSHIFT = 0
      ELSE
          LSHIFT = INT(MAX(0.0,REAL(NDIG)*ALOGMB/4.46-REAL(INTA)))
      ENDIF
      IF (LSHIFT > 0) LSHIFT = 4*(LSHIFT/4 + 1)

      IF (LSHIFT /= 0) THEN
          CALL FMI2M(LSHIFT,MXY(3))
          CALL FMADD(MXY(11),MXY(3),MXY(10))
      ELSE
          CALL FMEQ(MXY(11),MXY(10))
      ENDIF

!             Sum the asymptotic series.

      J2 = INT(0.3*ALOGMB + 0.2*SQRT(REAL(NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))

!             MXY(11) is Z
!             MXY(10) is Z + LSHIFT
!             MXY(7) is X**J2 = (1/(Z+LSHIFT)**2)**J2
!             MXY(8) is the current power of X
!             MXY(9) is the current term in the sum
!             MJSUMS is the partial sum

      NDSAV1 = NDIG
      CALL FMI2M(1,MXY(8))
      J = -2*J2
      CALL FMIPWR(MXY(10),J,MXY(7))
      IF (ABS(MWK(START(MXY(7))+2)) >= MEXPAB) THEN
          J2 = 1
          CALL FMIPWR(MXY(10),-2,MXY(7))
      ENDIF
      DO J = 1, J2
         NTERM = 2*J
         CALL FMBERN(NTERM,MXY(8),MXY(9))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(8))
             KFLAG = -4
             GO TO 170
         ENDIF
         NDENOM = NTERM
         CALL FMDIVI(MXY(9),NDENOM,MJSUMS(J))
      ENDDO

      NDIG2 = NDIG
  130 CALL FMMPY_R1(MXY(8),MXY(7))
      NMXDIF = MIN(NDSAV1,NGRD22)
      DO J = 1, J2
         NTERM = NTERM + 2
         CALL FMBERN(NTERM,MXY(8),MXY(9))
         IF (KFLAG == -11) THEN
             CALL FMST2M('UNKNOWN',MXY(8))
             KFLAG = -4
             GO TO 170
         ENDIF
         NDENOM = NTERM
         CALL FMDIVI_R1(MXY(9),NDENOM)
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(9))
         NMXDIF = MAX(NMXDIF,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(9))+2)))
         NDIG = NDIG2
         IF (KFLAG /= 0) GO TO 140
      ENDDO
      NDIG2 = NMXDIF
      NDIG = NDIG2
      GO TO 130

!             Put the J2 concurrent sums back together.

  140 NDIG = NDSAV1
      CALL FMI2M(1,MXY(7))
      CALL FMSQR(MXY(10),MXY(9))
      CALL FMDIV_R2(MXY(7),MXY(9))
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(7))
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(7),MXY(9))
             CALL FMADD_R1(MXY(7),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(7),MJSUMS(1))
      ENDIF

!             Add the log term to the asymptotic series.

!             MXY(8) is the current sum as the log terms are added
!             MXY(9) is now LN(Z+LSHIFT)

      CALL FMMPY(MJSUMS(1),MXY(9),MXY(8))
      CALL FMLN(MXY(10),MXY(9))
      CALL FMI2M(1,MXY(4))
      CALL FMDIV(MXY(4),MXY(10),MXY(5))
      CALL FMDIVI_R1(MXY(5),2)
      CALL FMSUB_R2(MXY(9),MXY(5))
      CALL FMSUB_R2(MXY(5),MXY(8))

!             Now Psi of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(MA) + ... + 1/(MA+LSHIFT-1) is computed.

!             MXY(11) is Z
!             MXY(4) is X**2
!             MXY(5) is 16*Z**3
!             MXY(6) is the current four-term numerator
!             MXY(7) is the current four-term denominator
!             MXY(9) is the current sum

      IF (LSHIFT > 0) THEN
          CALL FMSQR(MXY(11),MXY(4))
          CALL FMMPY(MXY(11),MXY(4),MXY(5))
          CALL FMSQR(MXY(4),MXY(6))
          CALL FMMPYI(MXY(5),6,MXY(10))
          CALL FMADD_R1(MXY(6),MXY(10))
          CALL FMMPYI(MXY(4),11,MXY(10))
          CALL FMADD_R1(MXY(6),MXY(10))
          CALL FMMPYI(MXY(11),6,MXY(10))
          CALL FMADD(MXY(6),MXY(10),MXY(7))
          CALL FMMPYI(MXY(5),4,MXY(6))
          CALL FMMPYI(MXY(4),18,MXY(10))
          CALL FMADD_R1(MXY(6),MXY(10))
          CALL FMMPYI(MXY(11),22,MXY(10))
          CALL FMADD_R1(MXY(6),MXY(10))
          CALL FMI2M(6,MXY(10))
          CALL FMADD_R1(MXY(6),MXY(10))
          CALL FMDIV(MXY(6),MXY(7),MXY(9))
          CALL FMMPYI_R1(MXY(5),16)
          DO K = 4, LSHIFT-4, 4
             CALL FMADD_R1(MXY(7),MXY(5))

             CALL FMMPYI(MXY(4),48,MXY(10))
             CALL FMADD_R1(MXY(6),MXY(10))

             K2 = 8*(6*K - 3)
             CALL FMMPYI(MXY(4),K2,MXY(10))
             CALL FMADD_R1(MXY(7),MXY(10))

             K1 = 16*(6*K - 3)
             CALL FMMPYI(MXY(11),K1,MXY(10))
             CALL FMADD_R1(MXY(6),MXY(10))

             IF (K <= SQRT(REAL(INTMAX)/49.0)) THEN
                 K1 = 8*(6*K*K - 6*K + 7)
                 CALL FMMPYI(MXY(11),K1,MXY(10))
                 CALL FMADD_R1(MXY(7),MXY(10))

                 CALL FMI2M(K1,MXY(10))
                 CALL FMADD_R1(MXY(6),MXY(10))
             ELSE
                 K1 = 48*K
                 CALL FMMPYI(MXY(11),K1,MXY(10))
                 CALL FMMPYI_R1(MXY(10),K)
                 CALL FMADD_R1(MXY(7),MXY(10))
                 K1B = 8*(-6*K + 7)
                 CALL FMMPYI(MXY(11),K1B,MXY(10))
                 CALL FMADD_R1(MXY(7),MXY(10))

                 CALL FMI2M(K1,MXY(10))
                 CALL FMMPYI_R1(MXY(10),K)
                 CALL FMADD_R1(MXY(6),MXY(10))
                 CALL FMI2M(K1B,MXY(10))
                 CALL FMADD_R1(MXY(6),MXY(10))
             ENDIF
             IF (K <= (REAL(INTMAX)/17.0)**0.3333) THEN
                 K0 = 8*(2*K - 1)*(K*K - K + 3)
                 CALL FMI2M(K0,MXY(10))
                 CALL FMADD_R1(MXY(7),MXY(10))
             ELSE IF (K <= SQRT(REAL(INTMAX)*0.9)) THEN
                 K0 = 8*(2*K - 1)
                 CALL FMI2M(K0,MXY(10))
                 K0B = K*K - K + 3
                 CALL FMMPYI_R1(MXY(10),K0B)
                 CALL FMADD_R1(MXY(7),MXY(10))
             ELSE
                 K0 = 8*(2*K - 1)
                 CALL FMI2M(K0,MXY(10))
                 CALL FMMPYI_R1(MXY(10),K)
                 CALL FMMPYI_R1(MXY(10),K)
                 CALL FMADD_R1(MXY(7),MXY(10))
                 K0B = -K + 3
                 CALL FMI2M(K0,MXY(10))
                 CALL FMMPYI_R1(MXY(10),K0B)
                 CALL FMADD_R1(MXY(7),MXY(10))
             ENDIF
             CALL FMDIV(MXY(6),MXY(7),MXY(10))
             CALL FMADD_R1(MXY(9),MXY(10))
          ENDDO
          CALL FMSUB_R1(MXY(8),MXY(9))
      ENDIF

!             Use the reflection formula if MA was less than -1/2.

      IF (KRFLCT == 1) THEN

!             Reduce the argument before multiplying by Pi.

          CALL FMNINT(MXY(11),MXY(4))
          CALL FMSUB(MXY(11),MXY(4),MXY(7))
          MWK(START(MXY(7))+1) = MWK(START(MXY(11))+1)
          CALL FMPI(MXY(9))
          CALL FMMPY_R1(MXY(9),MXY(7))
          KRSAVE = KRAD
          KRAD = 1
          CALL FMTAN(MXY(9),MXY(2))
          KRAD = KRSAVE
          CALL FMDIV_R2(MPISAV,MXY(2))
          CALL FMADD_R1(MXY(8),MXY(2))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  150 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(8))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(8))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(8))+J+1)) GO TO 160
              ENDDO
              GO TO 170
          ENDIF
  160     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(8))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = NDIG + IEXTRA
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(11))
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(8),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  170 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(8))+1) = MIN(MWK(START(MXY(8))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(8),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMPSI

      SUBROUTINE FMWRN2

!  Called by one of the FM routines to print a warning message if any error condition arises
!  in that routine.

      USE FMVALS
      IMPLICIT NONE

      CHARACTER(9) :: NAME

      INTEGER :: NCS

      IF (KFLAG >= 0 .OR. NCALL /= 1 .OR. KWARN <= 0) RETURN
      NCS = NCALL
      NAME = NAMEST(NCALL)
      WRITE (KW,  &
             "(/' Error of type KFLAG =',I3,"  //  &
             "' in FM package in routine ',A/)"    &
            ) KFLAG,TRIM(NAME)

  110 NCALL = NCALL - 1
      IF (NCALL > 0) THEN
          NAME = NAMEST(NCALL)
          WRITE (KW,"( ' called from ',A)") TRIM(NAME)
          GO TO 110
      ENDIF

      IF (KFLAG == -1) THEN
          WRITE (KW,"(' NDIG must be at least 2'/)")
      ELSE IF (KFLAG == -2) THEN
          WRITE (KW,"(' MBASE must be between 2 and',I10/)") INT(MXBASE)
      ELSE IF (KFLAG == -3) THEN
          WRITE (KW,  &
                 "(' An input argument is not a valid FM number.',"  //  &
                 "'  Its exponent is out of range.'/)"                   &
                )
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -4 .OR. KFLAG == -7) THEN
          WRITE (KW,"(' Invalid input argument for this routine.'/)")
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -5) THEN
          WRITE (KW,"(' The result has overflowed.'/)")
      ELSE IF (KFLAG == -6) THEN
          WRITE (KW,"(' The result has underflowed.'/)")
      ELSE IF (KFLAG == -8) THEN
          WRITE (KW,  &
                 "(' The result array is not big enough to hold the',"    //  &
                 "' output character string'/' in the current format.'/"  //  &
                 "' The result ''***...***'' has been returned.'/)"           &
                )
      ELSE IF (KFLAG == -9) THEN
          WRITE (KW,  &
                 "(' Precision could not be raised enough to'"  //  &
                 ",' provide all requested guard digits.'/)"        &
                )
          WRITE (KW,  &
                 "(I23,' digits were requested (NDIG).'/)"          &
                ) NDIG
          WRITE (KW,"(' UNKNOWN has been returned.'/)")
      ELSE IF (KFLAG == -10) THEN
          IF (NAMEST(NCS) == 'FMM2SP') THEN
              WRITE (KW,  &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to single precision.'/)"                      &
                    )
          ELSE
              WRITE (KW,  &
                     "(' An FM number was too small in magnitude to ',"  //  &
                     "'convert to double precision.'/)"                      &
                    )
          ENDIF
          WRITE (KW,"(' Zero has been returned.'/)")
      ELSE IF (KFLAG == -11) THEN
          WRITE (KW,"(' Array MBERN is not large enough.')")
      ELSE IF (KFLAG == -12) THEN
          WRITE (KW,"(' Array MJSUMS is not large enough.')")
      ENDIF

      NCALL = NCS
      IF (KWARN >= 2) THEN
          STOP
      ENDIF
      RETURN
      END SUBROUTINE FMWRN2

!  These are the longer and more readable routine names, equivalent to the older names.

      SUBROUTINE FMATAN2(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FMATN2(MA,MB,MC)
      RETURN
      END SUBROUTINE FMATAN2

      SUBROUTINE FMCOSH_SINH(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FMCHSH(MA,MB,MC)
      RETURN
      END SUBROUTINE FMCOSH_SINH

      FUNCTION FMCOMPARE(MA,LREL,MB)
      IMPLICIT NONE
      LOGICAL :: FMCOMPARE
      LOGICAL, EXTERNAL :: FMCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      FMCOMPARE = FMCOMP(MA,LREL,MB)
      RETURN
      END FUNCTION FMCOMPARE

      SUBROUTINE FMCOS_SIN(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FMCSSN(MA,MB,MC)
      RETURN
      END SUBROUTINE FMCOS_SIN

      SUBROUTINE FMEULER(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL FMEULR(MA)
      RETURN
      END SUBROUTINE FMEULER

      SUBROUTINE FMFPRINT(FORM,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      CALL FMFPRT(FORM,MA)
      RETURN
      END SUBROUTINE FMFPRINT

      SUBROUTINE FMIPOWER(MA,IVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      CALL FMIPWR(MA,IVAL,MB)
      RETURN
      END SUBROUTINE FMIPOWER

      SUBROUTINE FMLOG10(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      CALL FMLG10(MA,MB)
      RETURN
      END SUBROUTINE FMLOG10

      SUBROUTINE FMPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL FMPRNT(MA)
      RETURN
      END SUBROUTINE FMPRINT

      SUBROUTINE FMPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FMPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE FMPOWER

      SUBROUTINE FMRATIONAL_POWER(MA,IVAL,JVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL,JVAL
      CALL FMRPWR(MA,IVAL,JVAL,MB)
      RETURN
      END SUBROUTINE FMRATIONAL_POWER

      SUBROUTINE FMWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      CALL FMWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE FMWRITE

      FUNCTION IMCOMPARE(MA,LREL,MB)
      IMPLICIT NONE
      LOGICAL :: IMCOMPARE
      LOGICAL, EXTERNAL :: IMCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      IMCOMPARE = IMCOMP(MA,LREL,MB)
      RETURN
      END FUNCTION IMCOMPARE

      SUBROUTINE IMFPRINT(FORM,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      CALL IMFPRT(FORM,MA)
      RETURN
      END SUBROUTINE IMFPRINT

      SUBROUTINE IMMPY_MOD(MA,MB,MC,MD)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      CALL IMMPYM(MA,MB,MC,MD)
      RETURN
      END SUBROUTINE IMMPY_MOD

      SUBROUTINE IMPOWER_MOD(MA,MB,MC,MD)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      CALL IMPMOD(MA,MB,MC,MD)
      RETURN
      END SUBROUTINE IMPOWER_MOD

      SUBROUTINE IMPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL IMPRNT(MA)
      RETURN
      END SUBROUTINE IMPRINT

      SUBROUTINE IMPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL IMPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE IMPOWER

      SUBROUTINE IMWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      CALL IMWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE IMWRITE

      SUBROUTINE ZMCOSH_SINH(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZMCHSH(MA,MB,MC)
      RETURN
      END SUBROUTINE ZMCOSH_SINH

      SUBROUTINE ZMCOMPLEX(MAFM,MBFM,MC)
      IMPLICIT NONE
      INTEGER :: MAFM,MBFM,MC(2)
      CALL ZMCMPX(MAFM,MBFM,MC)
      RETURN
      END SUBROUTINE ZMCOMPLEX

      SUBROUTINE ZMCONJUGATE(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      CALL ZMCONJ(MA,MB)
      RETURN
      END SUBROUTINE ZMCONJUGATE

      SUBROUTINE ZMCOS_SIN(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZMCSSN(MA,MB,MC)
      RETURN
      END SUBROUTINE ZMCOS_SIN

      SUBROUTINE ZMFPRINT(FORM1,FORM2,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM1,FORM2
      INTEGER :: MA(2)
      CALL ZMFPRT(FORM1,FORM2,MA)
      RETURN
      END SUBROUTINE ZMFPRINT

      SUBROUTINE ZMIPOWER(MA,IVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL
      CALL ZMIPWR(MA,IVAL,MB)
      RETURN
      END SUBROUTINE ZMIPOWER

      SUBROUTINE ZMLOG10(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      CALL ZMLG10(MA,MB)
      RETURN
      END SUBROUTINE ZMLOG10

      SUBROUTINE ZMPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA(2)
      CALL ZMPRNT(MA)
      RETURN
      END SUBROUTINE ZMPRINT

      SUBROUTINE ZMPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZMPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE ZMPOWER

      SUBROUTINE ZMRATIONAL_POWER(MA,IVAL,JVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL,JVAL
      CALL ZMRPWR(MA,IVAL,JVAL,MB)
      RETURN
      END SUBROUTINE ZMRATIONAL_POWER

      SUBROUTINE ZMWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA(2)
      CALL ZMWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE ZMWRITE

      SUBROUTINE FPATAN2(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FPATN2(MA,MB,MC)
      RETURN
      END SUBROUTINE FPATAN2

      SUBROUTINE FPCOSH_SINH(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FPCHSH(MA,MB,MC)
      RETURN
      END SUBROUTINE FPCOSH_SINH

      FUNCTION FPCOMPARE(MA,LREL,MB)
      IMPLICIT NONE
      LOGICAL :: FPCOMPARE
      LOGICAL, EXTERNAL :: FPCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      FPCOMPARE = FPCOMP(MA,LREL,MB)
      RETURN
      END FUNCTION FPCOMPARE

      SUBROUTINE FPCOS_SIN(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FPCSSN(MA,MB,MC)
      RETURN
      END SUBROUTINE FPCOS_SIN

      SUBROUTINE FPEULER(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL FPEULR(MA)
      RETURN
      END SUBROUTINE FPEULER

      SUBROUTINE FPFPRINT(FORM,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      CALL FPFPRT(FORM,MA)
      RETURN
      END SUBROUTINE FPFPRINT

      SUBROUTINE FPIPOWER(MA,IVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      CALL FPIPWR(MA,IVAL,MB)
      RETURN
      END SUBROUTINE FPIPOWER

      SUBROUTINE FPLOG10(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      CALL FPLG10(MA,MB)
      RETURN
      END SUBROUTINE FPLOG10

      SUBROUTINE FPPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL FPPRNT(MA)
      RETURN
      END SUBROUTINE FPPRINT

      SUBROUTINE FPPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL FPPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE FPPOWER

      SUBROUTINE FPRATIONAL_POWER(MA,IVAL,JVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL,JVAL
      CALL FPRPWR(MA,IVAL,JVAL,MB)
      RETURN
      END SUBROUTINE FPRATIONAL_POWER

      SUBROUTINE FPWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      CALL FPWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE FPWRITE

      FUNCTION IPCOMPARE(MA,LREL,MB)
      IMPLICIT NONE
      LOGICAL :: IPCOMPARE
      LOGICAL, EXTERNAL :: IPCOMP
      CHARACTER(*) :: LREL
      INTEGER :: MA,MB
      IPCOMPARE = IPCOMP(MA,LREL,MB)
      RETURN
      END FUNCTION IPCOMPARE

      SUBROUTINE IPFPRINT(FORM,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM
      INTEGER :: MA
      CALL IPFPRT(FORM,MA)
      RETURN
      END SUBROUTINE IPFPRINT

      SUBROUTINE IPMPY_MOD(MA,MB,MC,MD)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      CALL IPMPYM(MA,MB,MC,MD)
      RETURN
      END SUBROUTINE IPMPY_MOD

      SUBROUTINE IPPOWER_MOD(MA,MB,MC,MD)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      CALL IPPMOD(MA,MB,MC,MD)
      RETURN
      END SUBROUTINE IPPOWER_MOD

      SUBROUTINE IPPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA
      CALL IPPRNT(MA)
      RETURN
      END SUBROUTINE IPPRINT

      SUBROUTINE IPPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      CALL IPPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE IPPOWER

      SUBROUTINE IPWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA
      CALL IPWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE IPWRITE

      SUBROUTINE ZPCOSH_SINH(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZPCHSH(MA,MB,MC)
      RETURN
      END SUBROUTINE ZPCOSH_SINH

      SUBROUTINE ZPCOMPLEX(MAFM,MBFM,MC)
      IMPLICIT NONE
      INTEGER :: MAFM,MBFM,MC(2)
      CALL ZPCMPX(MAFM,MBFM,MC)
      RETURN
      END SUBROUTINE ZPCOMPLEX

      SUBROUTINE ZPCONJUGATE(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      CALL ZPCONJ(MA,MB)
      RETURN
      END SUBROUTINE ZPCONJUGATE

      SUBROUTINE ZPCOS_SIN(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZPCSSN(MA,MB,MC)
      RETURN
      END SUBROUTINE ZPCOS_SIN

      SUBROUTINE ZPFPRINT(FORM1,FORM2,MA)
      IMPLICIT NONE
      CHARACTER(*) :: FORM1,FORM2
      INTEGER :: MA(2)
      CALL ZPFPRT(FORM1,FORM2,MA)
      RETURN
      END SUBROUTINE ZPFPRINT

      SUBROUTINE ZPIPOWER(MA,IVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL
      CALL ZPIPWR(MA,IVAL,MB)
      RETURN
      END SUBROUTINE ZPIPOWER

      SUBROUTINE ZPLOG10(MA,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      CALL ZPLG10(MA,MB)
      RETURN
      END SUBROUTINE ZPLOG10

      SUBROUTINE ZPPRINT(MA)
      IMPLICIT NONE
      INTEGER :: MA(2)
      CALL ZPPRNT(MA)
      RETURN
      END SUBROUTINE ZPPRINT

      SUBROUTINE ZPPOWER(MA,MB,MC)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2),MC(2)
      CALL ZPPWR(MA,MB,MC)
      RETURN
      END SUBROUTINE ZPPOWER

      SUBROUTINE ZPRATIONAL_POWER(MA,IVAL,JVAL,MB)
      IMPLICIT NONE
      INTEGER :: MA(2),MB(2)
      INTEGER :: IVAL,JVAL
      CALL ZPRPWR(MA,IVAL,JVAL,MB)
      RETURN
      END SUBROUTINE ZPRATIONAL_POWER

      SUBROUTINE ZPWRITE(KWRITE,MA)
      IMPLICIT NONE
      INTEGER :: KWRITE
      INTEGER :: MA(2)
      CALL ZPWRIT(KWRITE,MA)
      RETURN
      END SUBROUTINE ZPWRITE

!             Packed versions of routines for special functions.

      SUBROUTINE FPBERNOULLI(INT,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: INT
      INTENT (IN) :: INT
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMBERNOULLI(INT,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBERNOULLI

      SUBROUTINE FPBERN(INT,MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: INT
      INTENT (IN) :: MA,INT
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMBERN(INT,MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBERN

      SUBROUTINE FPBETA(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMBETA(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBETA

      SUBROUTINE FPCMBI(N,K,MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTEGER :: K,N
      INTENT (IN) :: N,K
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMCMBI(N,K,MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCMBI

      SUBROUTINE FPCOMB(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMCOMB(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCOMB

      SUBROUTINE FPEULR(MA)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA
      INTENT (INOUT) :: MA
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMEULR(MPA)
      CALL FMPACK(MPA,MA)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MA) == -1) TEMPV(MA) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEULR

      SUBROUTINE FPFACT(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMFACT(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPFACT

      SUBROUTINE FPGAM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMGAM(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPGAM

      SUBROUTINE FPIBTA(MA,MB,MC,MD)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC,MD
      INTENT (IN) :: MA,MB,MC
      INTENT (INOUT) :: MD
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMUNPK(MC,MPC)
      CALL FMIBTA(MPA,MPB,MPC,MPD)
      CALL FMPACK(MPD,MD)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MD) == -1) TEMPV(MD) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPIBTA

      SUBROUTINE FPIGM1(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMIGM1(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPIGM1

      SUBROUTINE FPIGM2(MA,MB,MC)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB,MC
      INTENT (IN) :: MA,MB
      INTENT (INOUT) :: MC
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMUNPK(MB,MPB)
      CALL FMIGM2(MPA,MPB,MPC)
      CALL FMPACK(MPC,MC)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPIGM2

      SUBROUTINE FPLNGM(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMLNGM(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLNGM

      SUBROUTINE FPPGAM(N,MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: N
      INTENT (IN) :: MA,N
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMPGAM(N,MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPGAM

      SUBROUTINE FPPOCH(MA,N,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: N
      INTENT (IN) :: MA,N
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMPOCH(MPA,N,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPOCH

      SUBROUTINE FPPSI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMPSI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPPSI


!     FM exponential integral and related functions

!  Here is a list of the routines that are designed to be called by the user:


!  FMBESJ(N,MA,MB)      MB = J(N,MA)   Bessel function of the first kind.

!  FMBESY(N,MA,MB)      MB = Y(N,MA)   Bessel function of the second kind.

!  FMC(MA,MB)           MB = C(MA)     Fresnel Cosine Integral

!  FMCHI(MA,MB)         MB = Chi(MA)   Hyperbolic Cosine Integral

!  FMCI(MA,MB)          MB = Ci(MA)    Cosine Integral

!  FMEI(MA,MB)          MB = Ei(MA)    Exponential Integral

!  FMEN(N,MA,MB)        MB = E(N,MA)   Exponential Integral E_n

!  FMERF(MA,MB)         MB = Erf(MA)   Error function

!  FMERFC(MA,MB)        MB = Erfc(MA)  Complimentary Error function

!  FMLERC(MA,MB)        MB = Ln(Erfc(MA))  Log Erfc

!  FMLI(MA,MB)          MB = Li(MA)    Logarithmic Integral

!  FMS(MA,MB)           MB = S(MA)     Fresnel Sine Integral

!  FMSHI(MA,MB)         MB = Shi(MA)   Hyperbolic Sine Integral

!  FMSI(MA,MB)          MB = Si(MA)    Sine Integral

!  For each of these routines there is also a version available for which the argument list is the
!  same but all FM numbers are in packed format.  The packed versions have the same names except
!  'FM' is replaced by 'FP' at the start of each name.

! --------------------------------------------------------------------------------------------------

      SUBROUTINE FMBESJ(N,MA,MB)

!  MB = Bessel J(N,MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA,MB
      DOUBLE PRECISION :: CBIG,CKLOG,CRHS,DBIG,DKLOG,DRHS,ERR,FMDPLG,XLOG
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KASAVE,KD,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE,  &
                 NDGOAL,NDIG2,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NTERMS,NUMTRY
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(15),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. N >= 0 .AND. MWK(START(MA)+2) < -NDIG) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMDIVI(MXY(1),2,MXY(3))
          CALL FMIPWR(MXY(3),N,MXY(2))
          CALL FMI2M(N,MXY(4))
          CALL FMFACT(MXY(4),MXY(5))
          CALL FMDIV(MXY(2),MXY(5),MXY(4))
          CALL FMMPY(MXY(4),MXY(3),MXY(5))
          CALL FMMPY(MXY(5),MXY(3),MXY(6))
          CALL FMDIVI(MXY(6),N+1,MXY(5))
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG+1 .AND.  &
              MWK(START(MXY(4))+2) < MEXPOV) THEN
              CALL FMEQU(MXY(4),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMSUB(MXY(6),MXY(7),MB)
                  IF (MWK(START(MB)+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(6))) > 0) THEN
                          IF (MWK(START(MXY(7))) > 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) < 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(7))) > 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMBESJ'
                  CALL FMNTRI(2,N,1)
                  CALL FMNTR(2,MA,MA,1,0)
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMBESJ'
          CALL FMNTRI(2,N,1)
          NCALL = NCALL - 1
      ENDIF
      CALL FMENT2('FMBESJ   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             Check for special cases.

  120 IF (N < 0) THEN
          CALL FMST2M('UNKNOWN',MXY(12))
          KFLAG = -4
          GO TO 200
      ENDIF
      IF (MWK(START(MA)+3) == 0) THEN
          IF (N == 0) THEN
              CALL FMI2M(1,MXY(12))
          ELSE
              CALL FMI2M(0,MXY(12))
          ENDIF
          GO TO 200
      ENDIF
      IF (2*MWK(START(MXY(1))+2) < -NDIG-1) THEN
          CALL FMDIVI(MXY(1),2,MXY(12))
          CALL FMIPWR(MXY(12),N,MXY(15))
          CALL FMFCTI(N,MXY(14))
          CALL FMDIV(MXY(15),MXY(14),MXY(12))
          GO TO 180
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series
!                    = 2 means use the asymptotic series

      NMETHD = 1
      CALL FMABS(MXY(1),MXY(15))
      CALL FMLN(MXY(15),MXY(14))

!             XLOG is Log(|x|)

      CALL FMM2DP(MXY(14),XLOG)

!             c(k) is the absolute value of the kth term of the convergent series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |c(k)/c(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|c(k)|) < Log(|c(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      CRHS = N*(XLOG-DLOGTW) - FMDPLG(DBLE(N+1)) - NDIG*DLOGMB - 20*DLOGTN

!             d(k) is the absolute value of the kth term of the asymptotic series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |d(k)/d(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|d(k)|) < Log(|d(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      DRHS = N
      DRHS = MIN(0.0D0,LOG(ABS(4*DRHS*DRHS-1))-XLOG-3*DLOGTW) - NDIG*DLOGMB - 20*DLOGTN - 50

      CBIG = N*(XLOG-DLOGTW) - FMDPLG(DBLE(N+1))
      DBIG = 1
      K = 1
      DO J = 0, 50
         K = 2*K
         CKLOG = (2*K+N)*XLOG - (2*K+N)*DLOGTW - FMDPLG(DBLE(K+1)) - FMDPLG(DBLE(N+K+1))
         CBIG = MAX(CBIG,CKLOG)
         IF (CKLOG < CRHS) THEN
             NMETHD = 1
             IF (NUMTRY == 0) THEN
                 CKLOG = MIN(0.0D0,N*XLOG - N*DLOGTW - FMDPLG(DBLE(N+1)))
                 IEXTRA = ((CBIG-CKLOG)/DLOGMB + 3)*1.2 - 14/ALOGMT
                 NDIG = NDIG+MAX(0,IEXTRA)
                 CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
             ENDIF
             EXIT
         ENDIF
         KD = K/2
         IF (N-2*KD < 0) THEN
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5)) + FMDPLG(DBLE(2*KD-N+0.5)) -  &
                     2*KD*DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1))
         ELSE
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5)) - FMDPLG(DBLE(N-2*KD+0.5)) -  &
                     2*KD*DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1))
         ENDIF
         DBIG = MAX(DBIG,DKLOG)
         IF (DKLOG < DRHS) THEN
             NMETHD = 2
             IF (NUMTRY == 0) THEN
                 IEXTRA = (DBIG/DLOGMB + 3)*1.2 - 14/ALOGMT
                 NDIG = NDIG+MAX(0,IEXTRA)
                 CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
             ENDIF
             EXIT
         ENDIF
      ENDDO
      IF (KR_RETRY <= 0 .AND. NCALL <= 1 .AND. N <= 100) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
      ENDIF
      IF (NMETHD == 2) GO TO 150

!             Method 1.  Sum the convergent series.
!                        J(n,x) = Sum( (-1)^k (x/2)^(2k+n) / ( k! (n+k)! )

      J2 = INT(0.3*ALOGMB + 0.2*SQRT(REAL(NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))

!             MXY(1) is X
!             MXY(14) is -X**2/4
!             MXY(15) is MXY(14)**J2
!             MXY(13) is the current term in the sum
!             MJSUMS holds the partial sums

      NDSAV1 = NDIG
      CALL FMSQR(MXY(1),MXY(14))
      CALL FMDIVI_R1(MXY(14),4)
      MWK(START(MXY(14))) = -1
      CALL FMIPWR(MXY(14),J2,MXY(15))
      CALL FMI2M(1,MXY(10))
      CALL FMFCTI(N,MXY(11))
      CALL FMDIV(MXY(10),MXY(11),MXY(13))
      DO J = 1, J2
         NTERM = J
         CALL FMEQ(MXY(13),MJSUMS(J))
         CALL FMDIVI_R1(MXY(13),J)
         CALL FMDIVI_R1(MXY(13),N+J)
      ENDDO

      NTERM = J2
      NDIG2 = NDIG
  130 CALL FMMPY_R1(MXY(13),MXY(15))
      NDIG = NDIG2
      DO J = 1, J2
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(13))
         IF (KFLAG /= 0) THEN
             GO TO 140
         ELSE
             NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(13))+2)))
             NDIG = MIN(NDSAV1,NDIG)
             NTERM = NTERM + 1
             CALL FMDIVI_R1(MXY(13),NTERM)
             CALL FMDIVI_R1(MXY(13),N+NTERM)
         ENDIF
      ENDDO
      GO TO 130

!             Put the J2 concurrent sums back together.

  140 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(11))
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(11),MXY(14))
             CALL FMADD_R1(MXY(11),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(11),MJSUMS(1))
      ENDIF
      CALL FMDIVI(MXY(1),2,MXY(11))
      CALL FMIPWR(MXY(11),N,MXY(12))
      CALL FMMPY_R1(MXY(12),MJSUMS(1))
      GO TO 180

!             Method 2.  Sum the asymptotic series.
!                        J(n,x) = Sqrt(2/(Pi*x)) * (Cos(c)*Sum(a(k)) - Sin(c)*Sum(b(k)))
!                        c = x - n*Pi/2 - Pi/4
!                        a(k) = (-1)^k * Gamma(2k+n+0.5) / ( (2x)^(2k) * (2k)! * Gamma(-2k+n+0.5) )
!                        b(k) = (-1)^k * Gamma(2k+n+1.5) /
!                               ( (2x)^(2k+1) * (2k+1)! * Gamma(-2k+n-0.5) )

!             MXY(1) is x
!             MXY(15) is the current term for the series
!             MXY(14) is 1/x^2
!             MXY(13) is MXY(14)^J2
!             MXY(12) is the sum of the a(k) series
!             MXY(11) is the sum of the b(k) series

  150 NDSAV1 = NDIG
      J2 = INT(0.3*ALOGMB + 0.2*SQRT(REAL(NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))

!             Sum the A(k) series.

      CALL FMI2M(1,MXY(15))
      CALL FMSQR(MXY(1),MXY(14))
      CALL FMDIV_R2(MXY(15),MXY(14))
      CALL FMIPWR(MXY(14),J2,MXY(13))
      LARGE = SQRT(MXBASE+1.0D-3)
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(15),MJSUMS(J))
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMMPYI_R1(MXY(15),1+4*NTERM-2*N)
             CALL FMMPYI_R1(MXY(15),3+4*NTERM-2*N)
             CALL FMMPYI_R1(MXY(15),1+4*NTERM+2*N)
             CALL FMMPYI_R1(MXY(15),3+4*NTERM+2*N)
             CALL FMDIVI_R1(MXY(15),-128)
             CALL FMDIVI_R1(MXY(15),1+NTERM)
             CALL FMDIVI_R1(MXY(15),1+2*NTERM)
         ELSE
             CALL FMMPYI_R1(MXY(15),(1+4*NTERM-2*N)*(3+4*NTERM-2*N))
             CALL FMMPYI_R1(MXY(15),(1+4*NTERM+2*N)*(3+4*NTERM+2*N))
             CALL FMDIVI_R1(MXY(15),-128)
             CALL FMDIVI_R1(MXY(15),(1+NTERM)*(1+2*NTERM))
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMMPY_R2(MXY(13),MXY(15))
         DO J = 1, J2
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(15))
            IF (KFLAG /= 0) GO TO 160
            NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(15))+2)))
            NDIG = MIN(NDSAV1,NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMMPYI_R1(MXY(15),1+4*NTERM-2*N)
                CALL FMMPYI_R1(MXY(15),3+4*NTERM-2*N)
                CALL FMMPYI_R1(MXY(15),1+4*NTERM+2*N)
                CALL FMMPYI_R1(MXY(15),3+4*NTERM+2*N)
                CALL FMDIVI_R1(MXY(15),-128)
                CALL FMDIVI_R1(MXY(15),1+NTERM)
                CALL FMDIVI_R1(MXY(15),1+2*NTERM)
            ELSE
                CALL FMMPYI_R1(MXY(15),(1+4*NTERM-2*N)*(3+4*NTERM-2*N))
                CALL FMMPYI_R1(MXY(15),(1+4*NTERM+2*N)*(3+4*NTERM+2*N))
                CALL FMDIVI_R1(MXY(15),-128)
                CALL FMDIVI_R1(MXY(15),(1+NTERM)*(1+2*NTERM))
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  160 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(11))
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(11),MXY(14))
             CALL FMADD_R1(MXY(11),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(11),MXY(12))
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(12))
      ENDIF

!             Sum the B(k) series.

      NDIG = NDSAV1
      IF (N < LARGE) THEN
          CALL FMI2M(4*N*N-1,MXY(15))
      ELSE
          CALL FMI2M(N,MXY(15))
          CALL FMSQR_R1(MXY(15))
          CALL FMMPYI_R1(MXY(15),4)
          CALL FMADDI(MXY(15),-1)
      ENDIF
      CALL FMDIVI_R1(MXY(15),8)
      CALL FMDIV_R1(MXY(15),MXY(1))
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(15),MJSUMS(J))
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMMPYI_R1(MXY(15),3+4*NTERM-2*N)
             CALL FMMPYI_R1(MXY(15),5+4*NTERM-2*N)
             CALL FMMPYI_R1(MXY(15),3+4*NTERM+2*N)
             CALL FMMPYI_R1(MXY(15),5+4*NTERM+2*N)
             CALL FMDIVI_R1(MXY(15),-128)
             CALL FMDIVI_R1(MXY(15),1+NTERM)
             CALL FMDIVI_R1(MXY(15),3+2*NTERM)
         ELSE
             CALL FMMPYI_R1(MXY(15),(3+4*NTERM-2*N)*(5+4*NTERM-2*N))
             CALL FMMPYI_R1(MXY(15),(3+4*NTERM+2*N)*(5+4*NTERM+2*N))
             CALL FMDIVI_R1(MXY(15),-128)
             CALL FMDIVI_R1(MXY(15),(1+NTERM)*(3+2*NTERM))
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMMPY_R2(MXY(13),MXY(15))
         DO J = 1, J2
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(15))
            IF (KFLAG /= 0) GO TO 170
            NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(15))+2)))
            NDIG = MIN(NDSAV1,NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMMPYI_R1(MXY(15),3+4*NTERM-2*N)
                CALL FMMPYI_R1(MXY(15),5+4*NTERM-2*N)
                CALL FMMPYI_R1(MXY(15),3+4*NTERM+2*N)
                CALL FMMPYI_R1(MXY(15),5+4*NTERM+2*N)
                CALL FMDIVI_R1(MXY(15),-128)
                CALL FMDIVI_R1(MXY(15),1+NTERM)
                CALL FMDIVI_R1(MXY(15),3+2*NTERM)
            ELSE
                CALL FMMPYI_R1(MXY(15),(3+4*NTERM-2*N)*(5+4*NTERM-2*N))
                CALL FMMPYI_R1(MXY(15),(3+4*NTERM+2*N)*(5+4*NTERM+2*N))
                CALL FMDIVI_R1(MXY(15),-128)
                CALL FMDIVI_R1(MXY(15),(1+NTERM)*(3+2*NTERM))
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  170 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(11))
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(11),MXY(14))
             CALL FMADD_R1(MXY(11),MJSUMS(J))
          ENDDO
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(11))
      ENDIF

!             To minimize cancellation error for very large x, with c = x - n*Pi/2 - Pi/4,
!             then we have
!             cos(c) = (k1*sin(x) + k2*cos(x)) / sqrt(2)
!             sin(c) = (k2*sin(x) - k1*cos(x)) / sqrt(2),  where
!             k1 = cos(n*Pi/2) + sin(n*Pi/2)
!             k2 = cos(n*Pi/2) - sin(n*Pi/2)
!             This is equivalent to
!             Mod( n, 4 ) =   0   1   2   3
!                      k1 =   1   1  -1  -1
!                      k2 =   1  -1  -1   1

      KRSAVE = KRAD
      KRAD = 1
      CALL FMCSSN(MXY(1),MXY(7),MXY(8))
      KRAD = KRSAVE
      K = MOD(N,4)
      IF (K == 0) THEN
          CALL FMADD(MXY(8),MXY(7),MXY(9))
          CALL FMSUB(MXY(8),MXY(7),MXY(10))
      ELSE IF (K == 1) THEN
          CALL FMSUB(MXY(8),MXY(7),MXY(9))
          CALL FMADD(MXY(8),MXY(7),MXY(10))
          CALL FMMPYI_R1(MXY(10),-1)
      ELSE IF (K == 2) THEN
          CALL FMADD(MXY(8),MXY(7),MXY(9))
          CALL FMMPYI_R1(MXY(9),-1)
          CALL FMSUB(MXY(7),MXY(8),MXY(10))
      ELSE
          CALL FMSUB(MXY(7),MXY(8),MXY(9))
          CALL FMADD(MXY(8),MXY(7),MXY(10))
      ENDIF
      CALL FMI2M(2,MXY(5))
      CALL FMSQRT(MXY(5),MXY(6))
      CALL FMDIV(MXY(9),MXY(6),MXY(7))
      CALL FMDIV(MXY(10),MXY(6),MXY(8))

      CALL FMMPY_R2(MXY(7),MXY(12))
      CALL FMMPY_R2(MXY(8),MXY(11))
      CALL FMSUB(MXY(12),MXY(11),MXY(9))
      CALL FMPI(MXY(10))
      CALL FMMPY(MXY(10),MXY(1),MXY(8))
      CALL FMI2M(2,MXY(7))
      CALL FMDIV(MXY(7),MXY(8),MXY(6))
      CALL FMSQRT(MXY(6),MXY(7))
      CALL FMMPY(MXY(7),MXY(9),MXY(12))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  180 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(12))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(12))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(12))+J+1)) GO TO 190
              ENDDO
              GO TO 200
          ENDIF
  190     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(12))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          IF (N >= 1000) IEXTRA = MAX(NDIG/2,IEXTRA)
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(15))
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(12),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  200 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(12))+1) = MIN(MWK(START(MXY(12))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) == -1) THEN
          IF (MOD(N,2) == 1 .AND. MWK(START(MXY(12))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(12))+3) /= 0) THEN
              MWK(START(MXY(12))) = -MWK(START(MXY(12)))
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(12),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBESJ

      SUBROUTINE FMBESY(N,MA,MB)

!  MB = Bessel Y(N,MA)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: N
      INTEGER :: MA,MB
      DOUBLE PRECISION :: CBIG,CKLOG,CRHS,DBIG,DKLOG,DRHS,ERR,FMDPLG,XLOG
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KASAVE,KD,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,LARGE,NDGOAL,  &
                 NDIG2,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NTERMS,NUMTRY
      INTENT (IN) :: N,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(15),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMBESY'
          CALL FMNTRI(2,N,1)
          NCALL = NCALL - 1
      ENDIF
      CALL FMENT2('FMBESY   ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF
      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             Check for special cases.

  120 IF (N < 0 .OR. MWK(START(MA)+3) == 0 .OR. MWK(START(MA)) == -1) THEN
          CALL FMST2M('UNKNOWN',MXY(9))
          KFLAG = -4
          GO TO 230
      ENDIF
      IF (N < 2 .AND. MWK(START(MA)+2) == MEXPUN) THEN
          CALL FMST2M('UNKNOWN',MXY(9))
          KFLAG = -4
          GO TO 230
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series
!                    = 2 means use the asymptotic series

      NMETHD = 1
      CALL FMABS(MXY(1),MXY(12))
      CALL FMLN(MXY(12),MXY(11))

!             XLOG is Log(|x|)

      CALL FMM2DP(MXY(11),XLOG)

!             c(k) is the absolute value of the kth term of the convergent series.  The psi terms
!                  grow logarithmically, so they are ignored for this estimate.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |c(k)/c(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|c(k)|) < Log(|c(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      CRHS = N*(XLOG-DLOGTW) - FMDPLG(DBLE(N+1)) - NDIG*DLOGMB - 20*DLOGTN

!             d(k) is the absolute value of the kth term of the asymptotic series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |d(k)/d(0)| < MBASE**(-NDIG) * 10**(-20).
!             Check Log(|d(k)|) < Log(|d(0)|) - NDIG*Log(MBASE) - 20*Log(10)

      DRHS = N
      DRHS = MIN(0.0D0,LOG(ABS(4*DRHS*DRHS-1))-XLOG-3*DLOGTW) - NDIG*DLOGMB - 20*DLOGTN - 50

      CBIG = N*(XLOG-DLOGTW) - FMDPLG(DBLE(N+1))
      DBIG = 1
      K = 1
      DO J = 0, 50
         K = 2*K
         CKLOG = (2*K+N)*XLOG - (2*K+N)*DLOGTW - FMDPLG(DBLE(K+1)) - FMDPLG(DBLE(N+K+1))
         CBIG = MAX(CBIG,CKLOG)
         IF (CKLOG < CRHS) THEN
             NMETHD = 1
             IF (NUMTRY == 0) THEN
                 CKLOG = MIN(0.0D0,N*XLOG - N*DLOGTW - FMDPLG(DBLE(N+1)))
                 IEXTRA = ((CBIG-CKLOG)/DLOGMB + 3)*1.2 - 14/ALOGMT
                 NDIG = NDIG+MAX(0,IEXTRA)
                 CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
             ENDIF
             EXIT
         ENDIF
         KD = K
         IF (N-2*KD < 0) THEN
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5)) + FMDPLG(DBLE(2*KD-N+0.5)) -  &
                     2*KD*DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1))
         ELSE
             DKLOG = FMDPLG(DBLE(2*KD+N+0.5)) - FMDPLG(DBLE(N-2*KD+0.5)) -  &
                     2*KD*DLOGTW - 2*KD*XLOG - FMDPLG(DBLE(2*KD+1))
         ENDIF
         DBIG = MAX(DBIG,DKLOG)
         IF (DKLOG < DRHS) THEN
             NMETHD = 2
             IF (NUMTRY == 0) THEN
                 IEXTRA = (DBIG/DLOGMB + 3)*1.2 - 14/ALOGMT
                 NDIG = NDIG+MAX(0,IEXTRA)
                 CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
             ENDIF
             EXIT
         ENDIF
      ENDDO
      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
      ENDIF
      IF (NMETHD == 2) GO TO 180

!             Method 1.  Sum the convergent series.
!                        Y(n,x) = (-1/pi)*
!                        Sum( (-1)^k (psi(k+1) + psi(n+k+1)) (x/2)^(2k+n) / ( k! (n+k)! )
!                        - (1/pi)*Sum( (n-k-1)! (x/2)^(2k-n) / k! ) + (2/pi)*ln(x/2)*J(n,x)

!                        The first sum above (involving psi) runs from k=0 to infinity, but the
!                        second sum is finite, for k=0 to k=n-1.

      J2 = INT(0.3*ALOGMB + 0.2*SQRT(REAL(NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))

!             Sum( (-1)^k (psi(k+1) + psi(n+k+1)) (x/2)^(2k+n) / ( k! (n+k)! )

!             MXY(1) is X
!             MXY(11) is -X**2/4
!             MXY(12) is MXY(11)**J2
!             MXY(13) is psi(k+1)
!             MXY(14) is psi(n+k+1)
!             MXY(10) is the current term in the sum
!             MJSUMS holds the partial sums

      NDSAV1 = NDIG
      CALL FMEULR(MXY(13))
      MWK(START(MXY(13))) = -1
      IF (N < 5000) THEN
          CALL FMEQ(MXY(13),MXY(14))
          IF (N > 0) THEN
              CALL FMI2M(1,MXY(7))
              DO J = 1, N
                 CALL FMDIVI(MXY(7),J,MXY(8))
                 CALL FMADD_R1(MXY(14),MXY(8))
              ENDDO
          ENDIF
      ELSE
          CALL FMI2M(N+1,MXY(12))
          CALL FMPSI(MXY(12),MXY(14))
      ENDIF
      CALL FMDIVI(MXY(1),2,MXY(8))
      CALL FMIPWR(MXY(8),N,MXY(9))
      CALL FMSQR(MXY(1),MXY(11))
      CALL FMDIVI_R1(MXY(11),4)
      MWK(START(MXY(11))) = -1
      CALL FMIPWR(MXY(11),J2,MXY(12))
      CALL FMI2M(1,MXY(7))
      CALL FMFCTI(N,MXY(8))
      CALL FMADD(MXY(13),MXY(14),MXY(6))
      CALL FMDIV(MXY(6),MXY(8),MXY(2))
      CALL FMMPY(MXY(2),MXY(9),MXY(3))
      IF (MWK(START(MXY(3))+2) <= MEXPUN) THEN
          CALL FMEQ(MXY(3),MXY(9))
          IF (MWK(START(MXY(9))+2) /= MUNKNO) MWK(START(MXY(9))) = -MWK(START(MXY(9)))
          GO TO 150
      ENDIF
      IF (MWK(START(MXY(1))+2) < -NDIG) THEN
          CALL FMPI(MXY(6))
          MWK(START(MXY(6))) = -1
          CALL FMDIV(MXY(3),MXY(6),MXY(9))
          GO TO 150
      ENDIF
      CALL FMDIV(MXY(7),MXY(8),MXY(10))
      DO J = 1, J2
         NTERM = J
         CALL FMADD(MXY(13),MXY(14),MXY(6))
         CALL FMMPY(MXY(10),MXY(6),MJSUMS(J))
         CALL FMDIVI_R1(MXY(10),J)
         CALL FMDIVI_R1(MXY(10),N+J)
         CALL FMDIVI(MXY(7),NTERM,MXY(6))
         CALL FMADD_R1(MXY(13),MXY(6))
         IF (N > 0) CALL FMDIVI(MXY(7),N+NTERM,MXY(6))
         CALL FMADD_R1(MXY(14),MXY(6))
      ENDDO
      CALL FMI2M(0,MXY(5))

      NTERM = J2
      NDIG2 = NDIG
      CALL FMADD_R2(MXY(13),MXY(14))
      CALL FMEQ(MXY(10),MXY(13))
      CALL FMMPY_R1(MXY(10),MXY(14))

!             Start the main summation loop.
!             The psi terms are updated without doing a full multiply inside the J loop.
!             MXY(13) now holds (x/2)^L / [ (k-1)! (n+k-1)! ].

  130 CALL FMMPYD(MXY(12),MXY(10),MXY(13),MXY(2),MXY(3))
      CALL FMEQ(MXY(2),MXY(10))
      CALL FMEQ(MXY(3),MXY(13))
      NDIG = NDIG2
      DO J = 1, J2
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(10))
         IF (KFLAG /= 0) THEN
             GO TO 140
         ELSE
             NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(10))+2)))
             NDIG = MIN(NDSAV1,NDIG)
             NTERM = NTERM + 1
             CALL FMDIVI_R1(MXY(13),NTERM*(N+NTERM))
             CALL FMDIVI(MXY(13),NTERM*(N+NTERM),MXY(2))
             CALL FMMPYI_R1(MXY(2),N+2*NTERM)
             CALL FMDIVI(MXY(10),NTERM*(N+NTERM),MXY(4))
             CALL FMADD(MXY(4),MXY(2),MXY(10))
         ENDIF
      ENDDO
      GO TO 130

!             Put the J2 concurrent sums back together.

  140 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(8))
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(8),MXY(11))
             CALL FMADD_R1(MXY(8),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(8),MJSUMS(1))
      ENDIF
      CALL FMMPY_R1(MXY(9),MJSUMS(1))
      CALL FMPI(MXY(6))
      MWK(START(MXY(6))) = -1
      CALL FMDIV_R1(MXY(9),MXY(6))

!             Sum( (n-k-1)! (x/2)^(2k-n) / k! )

  150 IF (N > 0) THEN
          MWK(START(MXY(11))) = 1
          CALL FMDIVI(MXY(1),2,MXY(6))
          CALL FMIPWR(MXY(6),-N,MXY(7))
          CALL FMFCTI(N-1,MXY(6))
          CALL FMMPY_R1(MXY(7),MXY(6))
          CALL FMEQ(MXY(7),MXY(8))
          IF (MWK(START(MXY(8))+2) == MEXPOV) THEN
              MWK(START(MXY(8))) = -1
              GO TO 160
          ENDIF
          DO J = 1, N-1
             CALL FMMPY_R1(MXY(7),MXY(11))
             CALL FMDIVI_R1(MXY(7),N-J)
             CALL FMDIVI_R1(MXY(7),J)
             CALL FMADD_R1(MXY(8),MXY(7))
          ENDDO
          CALL FMPI(MXY(6))
          MWK(START(MXY(6))) = -1
          CALL FMDIV_R1(MXY(8),MXY(6))

  160     CALL FMADD(MXY(9),MXY(8),MXY(14))
          IF (NCALL <= 1 .AND. MWK(START(MXY(14))+1) <= INT(REAL(NDSAVE)*ALOGM2)+17) THEN
              CALL FMEQ(MXY(14),MXY(9))
              CALL FMI2M(0,MRETRY)
              GO TO 210
          ENDIF
      ELSE
          CALL FMEQ(MXY(9),MXY(14))
      ENDIF

!             Add the J(n,x) term.

      CALL FMBESJ(N,MXY(1),MXY(15))
      IF (MWK(START(MXY(15))+2) == MEXPUN) THEN
          MWK(START(MXY(15))) = -1
          GO TO 170
      ENDIF
      CALL FMDIVI(MXY(1),2,MXY(6))
      CALL FMLN(MXY(6),MXY(7))
      CALL FMMPY(MXY(15),MXY(7),MXY(8))
      CALL FMPI(MXY(6))
      CALL FMDIV_R1(MXY(8),MXY(6))
      CALL FMMPYI(MXY(8),2,MXY(15))

  170 CALL FMADD(MXY(14),MXY(15),MXY(9))

      GO TO 210

!             Method 2.  Sum the asymptotic series.
!                        Y(n,x) = Sqrt(2/(Pi*x))*(Sin(c)*Sum(a(k)) + Cos(c)*Sum(b(k)))
!                        c = x - n*Pi/2 - Pi/4
!                        a(k) = (-1)^k * Gamma(2k+n+0.5) / ( (2x)^(2k) * (2k)! * Gamma(-2k+n+0.5) )
!                        b(k) = (-1)^k * Gamma(2k+n+1.5) /
!                               ( (2x)^(2k+1) * (2k+1)! * Gamma(-2k+n-0.5) )

!             MXY(1) is x
!             MXY(12) is the current term for the series
!             MXY(11) is 1/x^2
!             MXY(10) is MXY(11)^J2
!             MXY(9) is the sum of the a(k) series
!             MXY(8) is the sum of the b(k) series

  180 NDSAV1 = NDIG
      J2 = INT(0.3*ALOGMB + 0.2*SQRT(REAL(NDIG)))
      J2 = MAX(1,MIN(LJSUMS,J2))

!             Sum the A(k) series.

      CALL FMI2M(1,MXY(12))
      CALL FMSQR(MXY(1),MXY(11))
      CALL FMDIV_R2(MXY(12),MXY(11))
      CALL FMIPWR(MXY(11),J2,MXY(10))
      LARGE = SQRT(MXBASE+1.0D-3)
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(12),MJSUMS(J))
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMMPYI_R1(MXY(12),1+4*NTERM-2*N)
             CALL FMMPYI_R1(MXY(12),3+4*NTERM-2*N)
             CALL FMMPYI_R1(MXY(12),1+4*NTERM+2*N)
             CALL FMMPYI_R1(MXY(12),3+4*NTERM+2*N)
             CALL FMDIVI_R1(MXY(12),-128)
             CALL FMDIVI_R1(MXY(12),1+NTERM)
             CALL FMDIVI_R1(MXY(12),1+2*NTERM)
         ELSE
             CALL FMMPYI_R1(MXY(12),(1+4*NTERM-2*N)*(3+4*NTERM-2*N))
             CALL FMMPYI_R1(MXY(12),(1+4*NTERM+2*N)*(3+4*NTERM+2*N))
             CALL FMDIVI_R1(MXY(12),-128)
             CALL FMDIVI_R1(MXY(12),(1+NTERM)*(1+2*NTERM))
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMMPY_R2(MXY(10),MXY(12))
         DO J = 1, J2
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(12))
            IF (KFLAG /= 0) GO TO 190
            NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(12))+2)))
            NDIG = MIN(NDSAV1,NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMMPYI_R1(MXY(12),1+4*NTERM-2*N)
                CALL FMMPYI_R1(MXY(12),3+4*NTERM-2*N)
                CALL FMMPYI_R1(MXY(12),1+4*NTERM+2*N)
                CALL FMMPYI_R1(MXY(12),3+4*NTERM+2*N)
                CALL FMDIVI_R1(MXY(12),-128)
                CALL FMDIVI_R1(MXY(12),1+NTERM)
                CALL FMDIVI_R1(MXY(12),1+2*NTERM)
            ELSE
                CALL FMMPYI_R1(MXY(12),(1+4*NTERM-2*N)*(3+4*NTERM-2*N))
                CALL FMMPYI_R1(MXY(12),(1+4*NTERM+2*N)*(3+4*NTERM+2*N))
                CALL FMDIVI_R1(MXY(12),-128)
                CALL FMDIVI_R1(MXY(12),(1+NTERM)*(1+2*NTERM))
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  190 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(8))
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(8),MXY(11))
             CALL FMADD_R1(MXY(8),MJSUMS(J))
          ENDDO
          CALL FMEQ(MXY(8),MXY(9))
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(9))
      ENDIF

!             Sum the B(k) series.

      NDIG = NDSAV1
      IF (N < LARGE) THEN
          CALL FMI2M(4*N*N-1,MXY(12))
      ELSE
          CALL FMI2M(N,MXY(12))
          CALL FMSQR_R1(MXY(12))
          CALL FMMPYI_R1(MXY(12),4)
          CALL FMADDI(MXY(12),-1)
      ENDIF
      CALL FMDIVI_R1(MXY(12),8)
      CALL FMDIV_R1(MXY(12),MXY(1))
      DO J = 1, J2
         NTERM = J - 1
         CALL FMEQ(MXY(12),MJSUMS(J))
         IF (3+4*NTERM+2*N > LARGE) THEN
             CALL FMMPYI_R1(MXY(12),3+4*NTERM-2*N)
             CALL FMMPYI_R1(MXY(12),5+4*NTERM-2*N)
             CALL FMMPYI_R1(MXY(12),3+4*NTERM+2*N)
             CALL FMMPYI_R1(MXY(12),5+4*NTERM+2*N)
             CALL FMDIVI_R1(MXY(12),-128)
             CALL FMDIVI_R1(MXY(12),1+NTERM)
             CALL FMDIVI_R1(MXY(12),3+2*NTERM)
         ELSE
             CALL FMMPYI_R1(MXY(12),(3+4*NTERM-2*N)*(5+4*NTERM-2*N))
             CALL FMMPYI_R1(MXY(12),(3+4*NTERM+2*N)*(5+4*NTERM+2*N))
             CALL FMDIVI_R1(MXY(12),-128)
             CALL FMDIVI_R1(MXY(12),(1+NTERM)*(3+2*NTERM))
         ENDIF
      ENDDO
      NTERMS = INT(INTMAX/10)

      DO K = 1, NTERMS
         CALL FMMPY_R2(MXY(10),MXY(12))
         DO J = 1, J2
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(12))
            IF (KFLAG /= 0) GO TO 200
            NDIG = MAX(NGRD22,NDSAV1-INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(12))+2)))
            NDIG = MIN(NDSAV1,NDIG)
            NTERM = NTERM + 1
            IF (3+4*NTERM+2*N > LARGE) THEN
                CALL FMMPYI_R1(MXY(12),3+4*NTERM-2*N)
                CALL FMMPYI_R1(MXY(12),5+4*NTERM-2*N)
                CALL FMMPYI_R1(MXY(12),3+4*NTERM+2*N)
                CALL FMMPYI_R1(MXY(12),5+4*NTERM+2*N)
                CALL FMDIVI_R1(MXY(12),-128)
                CALL FMDIVI_R1(MXY(12),1+NTERM)
                CALL FMDIVI_R1(MXY(12),3+2*NTERM)
            ELSE
                CALL FMMPYI_R1(MXY(12),(3+4*NTERM-2*N)*(5+4*NTERM-2*N))
                CALL FMMPYI_R1(MXY(12),(3+4*NTERM+2*N)*(5+4*NTERM+2*N))
                CALL FMDIVI_R1(MXY(12),-128)
                CALL FMDIVI_R1(MXY(12),(1+NTERM)*(3+2*NTERM))
            ENDIF
         ENDDO
      ENDDO

!             Put the J2 concurrent sums back together.

  200 NDIG = NDSAV1
      IF (J2 > 1) THEN
          CALL FMEQ(MJSUMS(J2),MXY(8))
          DO J = J2-1, 1, -1
             CALL FMMPY_R1(MXY(8),MXY(11))
             CALL FMADD_R1(MXY(8),MJSUMS(J))
          ENDDO
      ELSE
          CALL FMEQ(MJSUMS(1),MXY(8))
      ENDIF

!             To minimize cancellation error for very large x, with c = x - n*Pi/2 - Pi/4,
!             then we have
!             cos(c) = (k1*sin(x) + k2*cos(x)) / sqrt(2)
!             sin(c) = (k2*sin(x) - k1*cos(x)) / sqrt(2),  where
!             k1 = cos(n*Pi/2) + sin(n*Pi/2)
!             k2 = cos(n*Pi/2) - sin(n*Pi/2)
!             This is equivalent to
!             Mod( n, 4 ) =   0   1   2   3
!                      k1 =   1   1  -1  -1
!                      k2 =   1  -1  -1   1

      KRSAVE = KRAD
      KRAD = 1
      CALL FMCSSN(MXY(1),MXY(4),MXY(5))
      KRAD = KRSAVE
      K = MOD(N,4)
      IF (K == 0) THEN
          CALL FMADD(MXY(5),MXY(4),MXY(6))
          CALL FMSUB(MXY(5),MXY(4),MXY(7))
      ELSE IF (K == 1) THEN
          CALL FMSUB(MXY(5),MXY(4),MXY(6))
          CALL FMADD(MXY(5),MXY(4),MXY(7))
          CALL FMMPYI_R1(MXY(7),-1)
      ELSE IF (K == 2) THEN
          CALL FMADD(MXY(5),MXY(4),MXY(6))
          CALL FMMPYI_R1(MXY(6),-1)
          CALL FMSUB(MXY(4),MXY(5),MXY(7))
      ELSE
          CALL FMSUB(MXY(4),MXY(5),MXY(6))
          CALL FMADD(MXY(5),MXY(4),MXY(7))
      ENDIF
      CALL FMI2M(2,MXY(2))
      CALL FMSQRT(MXY(2),MXY(3))
      CALL FMDIV(MXY(6),MXY(3),MXY(4))
      CALL FMDIV(MXY(7),MXY(3),MXY(5))

      CALL FMMPY_R2(MXY(5),MXY(9))
      CALL FMMPY_R2(MXY(4),MXY(8))
      CALL FMADD(MXY(9),MXY(8),MXY(6))
      CALL FMPI(MXY(7))
      CALL FMMPY(MXY(7),MXY(1),MXY(5))
      CALL FMI2M(2,MXY(4))
      CALL FMDIV(MXY(4),MXY(5),MXY(3))
      CALL FMSQRT(MXY(3),MXY(4))
      CALL FMMPY(MXY(4),MXY(6),MXY(9))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  210 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(9))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(9))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              IF (MWK(START(MRETRY)+3) == 0) GO TO 220
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(9))+J+1)) GO TO 220
              ENDDO
              GO TO 230
          ENDIF
  220     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(9))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          CALL FMEQ(MXY(1),MXY(12))
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(9),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  230 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(9))+1) = MIN(MWK(START(MXY(9))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) == -1) THEN
          IF (MOD(N,2) == 1 .AND. MWK(START(MXY(9))+2) /= MUNKNO .AND.  &
              MWK(START(MXY(9))+3) /= 0) THEN
              MWK(START(MXY(9))) = -MWK(START(MXY(9)))
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(9),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMBESY

      SUBROUTINE FMC(MA,MB)

!  MB = C(MA)    Fresnel Cosine Integral.

!  Integral from 0 to MA of Cos(pi*t**2/2) dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE,  &
                 NBOT,NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(14),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0
      K = 0
      NCALL = NCALL + 1

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1) THEN
          J = NTRACE
          NTRACE = 0
          KL = KWARN
          KWARN = 0
          CALL FMDP2M(1.0D-10,MXY(1))
          CALL FMULP(MXY(1),MXY(2))
          CALL FMSQRT(MXY(2),MXY(3))
          CALL FMSQRT(MXY(3),MXY(2))
          CALL FMABS(MA,MXY(3))
          CALL FMSUB(MXY(3),MXY(2),MXY(4))
          IF (MWK(START(MXY(4))) < 0) K = 1
          NTRACE = J
          KWARN = KL
      ENDIF
      IF (KROUND /= 1 .AND. K == 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMIPWR(MXY(1),5,MXY(2))
          CALL FMPI(MXY(3))
          CALL FMSQR(MXY(3),MXY(4))
          CALL FMDIVI(MXY(4),40,MXY(3))
          CALL FMMPY(MXY(2),MXY(3),MXY(5))
          CALL FMEQ(MXY(1),MXY(4))
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG .AND.  &
              MWK(START(MXY(4))+2) > MEXPUN) THEN
              CALL FMEQU(MXY(4),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMSUB(MXY(6),MXY(7),MB)
                  IF (MWK(START(MB)+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(6))) > 0) THEN
                          IF (MWK(START(MXY(7))) > 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) < 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(7))) > 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) < 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NAMEST(NCALL) = 'FMC'
                  CALL FMNTR(2,MA,MA,1,1)
              ENDIF
              IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
                  NAMEST(NCALL) = 'FMC'
                  KFLAG = -4
                  CALL FMWRN2
              ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
                  NAMEST(NCALL) = 'FMC'
                  IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
                  CALL FMWRN2
              ENDIF
              IF (NTRACE /= 0) THEN
                  NAMEST(NCALL) = 'FMC'
                  CALL FMNTR(1,MB,MB,1,1)
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMC      ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMEQ(MXY(1),MXY(10))
          GO TO 180
      ENDIF
      IF (4*MWK(START(MXY(1))+2) < -NDIG) THEN
          CALL FMEQ(MXY(1),MXY(10))
          GO TO 180
      ENDIF
      CALL FMINT(MXY(1),MXY(8))
      IF (3*MWK(START(MXY(1))+2) > NDIG .AND. FMCOMP(MXY(1),'==',MXY(8)) .AND.  &
          MWK(START(MXY(1))+2) < MEXPOV) THEN
          MWK(START(MXY(1))) = MWK(START(MA))
          IF (MOD(INT(MBASE),2) == 0 .AND. MWK(START(MXY(1))+2) > NDSAVE) THEN
              K = 0
          ELSE
              CALL FMI2M(2,MXY(8))
              CALL FMMOD(MXY(1),MXY(8),MXY(7))
              CALL FMM2I(MXY(7),K)
          ENDIF
          CALL FMI2M(1,MXY(8))
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(10))
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(10))
          ENDIF
          IF (K == 0) THEN
              CALL FMIPWR(MXY(1),3,MXY(7))
              CALL FMPI(MXY(6))
              CALL FMSQR_R1(MXY(6))
              CALL FMMPY_R1(MXY(6),MXY(7))
              CALL FMDIV_R2(MXY(8),MXY(6))
              CALL FMSUB_R1(MXY(10),MXY(6))
          ELSE
              CALL FMPI(MXY(6))
              CALL FMMPY_R1(MXY(6),MXY(1))
              CALL FMDIV_R2(MXY(8),MXY(6))
              CALL FMADD_R1(MXY(10),MXY(6))
          ENDIF
          IF (MWK(START(MA)) < 0) MWK(START(MXY(10))) = -MWK(START(MXY(10)))
          GO TO 180
      ENDIF
      IF (MWK(START(MXY(1))+2) > NDIG) THEN
          CALL FMI2M(1,MXY(8))
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(10))
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(10))
          ENDIF
          GO TO 180
      ENDIF

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) , INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      IF (KFLAGX == 0) THEN
          IF (ABS(X) < SQRT(HUGE(X)/(4*LOG(HUGE(X))))) THEN
              Y = (DPPI*X*X-1)/2
              Y = (2*Y+1.5)*LOG(2*Y+2) - (2*Y+1) - Y*DLOGTW - (Y+0.5)*LOG(Y+1) + Y - Y*LOG(DPPI*X*X)
              IF (Y <= -(NDIG+1)*DLOGMB) THEN
                  NMETHD = 2
              ELSE
                  NMETHD = 1
              ENDIF
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use x times the series (-1)**n*(pi*x*x/2)**(2*n)/((4*n+1)*(2*n)!).

!             MXY(6) is the current term
!             MXY(9) is pi*x*x/2

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          IEXTRA = MAX(0.0D0,(0.096*X*X + 0.033*ABS(X) - 0.5)*LOG(1.0E7)/ALOGMB)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          ENDIF
      ENDIF
      NDIG = NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF

      J2 = INT(5.0D0 + 0.001D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(4))
      CALL FMDIVI(MXY(4),2,MXY(9))
      CALL FMPI(MXY(3))
      CALL FMMPY_R1(MXY(9),MXY(3))
      CALL FMI2M(1,MXY(6))
      CALL FMI2M(1,MJSUMS(1))
      NTERM = 0
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL FMDIVI_R1(MXY(6),NTERM)
         NTERM = NTERM + 1
         NBOT = -NTERM
         CALL FMDIVI_R1(MXY(6),NBOT)
         CALL FMDIVI(MXY(6),2*NTERM+1,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(9),2*J2,MXY(7))

  130 CALL FMMPY_R1(MXY(6),MXY(7))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMDIVI_R1(MXY(6),NTERM)
             NBOT = -(NTERM - 1)
             CALL FMDIVI_R1(MXY(6),NBOT)
         ELSE
             CALL FMDIVI_R1(MXY(6),-NBOT)
         ENDIF
         CALL FMDIVI(MXY(6),2*NTERM+1,MXY(2))
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(6))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(10))
      IF (J2 >= 2) THEN
          CALL FMSQR(MXY(9),MXY(8))
          DO J = 2, J2
             CALL FMMPY_R2(MXY(8),MXY(10))
             CALL FMADD_R1(MXY(10),MJSUMS(J2-J+1))
          ENDDO
      ENDIF
      CALL FMMPY_R1(MXY(10),MXY(1))

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then C(x) = 0.5 + f(x)*sin(pi*x*x/2) - g(x)*cos(pi*x*x/2).

  150 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      CALL FMFGFI(MXY(1),MXY(11),MXY(12))
      CALL FMSQR(MXY(1),MXY(4))
      KRSAVE = KRAD
      KRAD = 0
      CALL FMMPYI(MXY(4),90,MXY(7))
      CALL FMCSSN(MXY(7),MXY(13),MXY(14))
      KRAD = KRSAVE
      CALL FMMPY(MXY(11),MXY(14),MXY(10))
      CALL FMMPY(MXY(12),MXY(13),MXY(7))
      CALL FMI2M(1,MXY(4))
      CALL FMDIVI(MXY(4),2,MXY(5))
      CALL FMADD(MXY(5),MXY(10),MXY(6))
      CALL FMSUB(MXY(6),MXY(7),MXY(10))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(10))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(10))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(10))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(10))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(10))+1) = MIN(MWK(START(MXY(10))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) == -1) THEN
          IF (MWK(START(MXY(10))+3) /= 0 .AND. MWK(START(MXY(10))+2) /= MUNKNO)  &
              MWK(START(MXY(10))) =-1
      ENDIF
      CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMC

      SUBROUTINE FMCHI(MA,MB)

!  MB = Hyperbolic Cosine Integral(MA)

!  EulerGamma + Ln(MA) + Integral from 0 to MA of ( Cosh(t) - 1 ) / t  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: X,Y
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: IEXTRA,J,J2,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,LARGE,NBOT,NDGOAL,  &
                 NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(11),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMCHI    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) ,INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Check for special cases.

      IF (MWK(START(MXY(1))) == -1 .OR. MWK(START(MXY(1))+2) == MEXPUN .OR.  &
          MWK(START(MXY(1))+3) ==0) THEN
          CALL FMST2M('UNKNOWN',MXY(7))
          KFLAG = -4
          GO TO 180
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMST2M('OVERFLOW',MXY(7))
          KFLAG = -5
          GO TO 180
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (NDIG+5)*DLOGMB
          IF (ABS(X) > Y+(DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the gamma + ln(X) + X**(2*N)/((2*N)*(2*N)!) series.

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          Y = NINT(ABS(X)/2)
          Y = 2*Y*LOG(ABS(X)+1.0E-9) - LOG(2*Y+1.0E-9) - (2*Y+0.5)*LOG(2*Y+1) + 2*Y
          Y = Y/DLOGMB
          IEXTRA = MAX(0,INT(Y+1))
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
      ENDIF

      J2 = INT(5.0D0 + 0.001D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(2))
      CALL FMDIVI(MXY(2),2,MXY(6))
      CALL FMDIVI(MXY(6),2,MJSUMS(1))
      NTERM = 2
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL FMDIVI_R1(MXY(6),NTERM)
         NTERM = NTERM + 1
         NBOT = NTERM
         CALL FMDIVI_R1(MXY(6),NBOT)
         CALL FMDIVI(MXY(6),NTERM,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(1),2*J2,MXY(4))

  130 CALL FMMPY_R1(MXY(6),MXY(4))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMDIVI_R1(MXY(6),NTERM)
             NBOT = (NTERM - 1)
             CALL FMDIVI_R1(MXY(6),NBOT)
         ELSE
             CALL FMDIVI_R1(MXY(6),NBOT)
         ENDIF
         CALL FMDIVI(MXY(6),NTERM,MXY(3))
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(3))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(3))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(7))
      IF (J2 >= 2) THEN
          CALL FMSQR(MXY(1),MXY(5))
          DO J = 2, J2
             CALL FMMPY_R2(MXY(5),MXY(7))
             CALL FMADD_R1(MXY(7),MJSUMS(J2-J+1))
          ENDDO
      ENDIF
      CALL FMEQ(MXY(7),MXY(11))
      CALL FMEULR(MXY(9))
      CALL FMLN(MXY(1),MXY(2))
      CALL FMADD(MXY(9),MXY(2),MXY(10))
      CALL FMADD(MXY(10),MXY(11),MXY(7))

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then CHI(x) = f(x)*sinh(x) + g(x)*cosh(x).

  150 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
      ENDIF
      CALL FMFHGH(MXY(1),MXY(8),MXY(9))
      CALL FMCHSH(MXY(1),MXY(10),MXY(11))
      IF (MWK(START(MXY(10))+2) < MEXPOV) THEN
          CALL FMMPY(MXY(8),MXY(11),MXY(7))
          CALL FMMPY(MXY(9),MXY(10),MXY(4))
          CALL FMADD_R1(MXY(7),MXY(4))
      ELSE
          CALL FMADD(MXY(8),MXY(9),MXY(4))
          CALL FMDIVI_R1(MXY(4),2)
          CALL FMLN(MXY(4),MXY(7))
          CALL FMADD(MXY(1),MXY(7),MXY(4))
          CALL FMEXP(MXY(4),MXY(7))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(7))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(7))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(7))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(7))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(7),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(7))+1) = MIN(MWK(START(MXY(7))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(7),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCHI

      SUBROUTINE FMCI(MA,MB)

!  MB = Cosine Integral(MA)

!  Integral from MA to Infinity of -Cos(t) / t  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,LARGE,NBOT,  &
                 NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(11),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMCI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) ,INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Check for special cases.

      IF (MWK(START(MXY(1))) == -1) THEN
          CALL FMST2M('UNKNOWN',MXY(7))
          KFLAG = -4
          GO TO 180
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMST2M('UNKNOWN',MXY(7))
          KFLAG = -4
          GO TO 180
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (NDIG+5)*DLOGMB
          IF (ABS(X) > Y+(DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the  gamma + ln(X) + (-1)**N*X**(2*N)/((2*N)*(2*N)!) series.

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          Y = NINT(ABS(X)/2)
          Y = 2*Y*LOG(ABS(X)+1.0E-9) - LOG(2*Y+1.0E-9) - (2*Y+0.5)*LOG(2*Y+1) + 2*Y
          Y = Y/DLOGMB
          IEXTRA = MAX(0,INT(Y+1))
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      IF (ABS(X) < 5 .AND. KR_RETRY <= 0) THEN
          NDIG = NDIG - 2
          IEXTRA = 0
      ENDIF
      NDIG = NDIG + IEXTRA

      J2 = INT(5.0D0 + 0.001D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(2))
      CALL FMDIVI(MXY(2),-2,MXY(6))
      CALL FMDIVI(MXY(6),2,MJSUMS(1))
      NTERM = 2
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL FMDIVI_R1(MXY(6),NTERM)
         NTERM = NTERM + 1
         NBOT = -NTERM
         CALL FMDIVI_R1(MXY(6),NBOT)
         CALL FMDIVI(MXY(6),NTERM,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(1),2*J2,MXY(4))

  130 CALL FMMPY_R1(MXY(6),MXY(4))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMDIVI_R1(MXY(6),NTERM)
             NBOT = -(NTERM - 1)
             CALL FMDIVI_R1(MXY(6),NBOT)
         ELSE
             CALL FMDIVI_R1(MXY(6),-NBOT)
         ENDIF
         CALL FMDIVI(MXY(6),NTERM,MXY(3))
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(3))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(3))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(7))
      IF (J2 >= 2) THEN
          CALL FMSQR(MXY(1),MXY(5))
          DO J = 2, J2
             CALL FMMPY_R2(MXY(5),MXY(7))
             CALL FMADD_R1(MXY(7),MJSUMS(J2-J+1))
          ENDDO
      ENDIF
      CALL FMEQ(MXY(7),MXY(11))
      CALL FMEULR(MXY(9))
      CALL FMLN(MXY(1),MXY(2))
      CALL FMADD(MXY(9),MXY(2),MXY(10))
      CALL FMADD(MXY(10),MXY(11),MXY(7))

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then CI(x) = f(x)*sin(x) - g(x)*cos(x).

  150 CALL FMFXGX(MXY(1),MXY(8),MXY(9))
      KRSAVE = KRAD
      KRAD = 1
      CALL FMCSSN(MXY(1),MXY(10),MXY(11))
      KRAD = KRSAVE
      CALL FMMPY(MXY(8),MXY(11),MXY(7))
      CALL FMMPY(MXY(9),MXY(10),MXY(4))
      CALL FMSUB_R1(MXY(7),MXY(4))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(7))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(7))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(7))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(7))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(7),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(7))+1) = MIN(MWK(START(MXY(7))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(7),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMCI

      SUBROUTINE FMEI(MA,MB)

!  MB = Exponential Integral(MA)

!  Integral from -Infinity to MA of e**t / t  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,JEXTRA,JTERMS,KASAVE,KFLAG1,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,  &
                 NDGOAL,NDOLD,NDSAV1,NDSAV2,NDSAVE,NGOAL,NMETHD,NTERM,NTERMS,NUMTRY
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(15),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMEI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

  120 NTERMS = INT(INTMAX/10)

!             X is a double precision approximation to the input argument to this function.

      CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0),INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0 .OR. MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMST2M('UNKNOWN',MXY(10))
          KFLAG = -4
          GO TO 200
      ELSE IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMI2M(0,MXY(10))
          IF (MWK(START(MXY(1))) > 0) THEN
              CALL FMST2M('OVERFLOW',MXY(10))
              KFLAG = -5
          ELSE
              CALL FMST2M('-UNDERFLOW',MXY(10))
              KFLAG = -6
          ENDIF
          GO TO 200
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (NDIG+3)*DLOGMB
          IF (ABS(X) > Y+(DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
          IF (X < 0.0D0 .AND. NMETHD == 1) THEN
              IF (X <= -14.3D0-0.275D0*Y) NMETHD = 3
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150
      IF (NMETHD == 3) GO TO 170

!             Method 1.  Use the X**N/(N*N!) series.

      IF (KFLAGX == 0) THEN
          IF (X < 0) THEN
              IEXTRA = INT(2.0D0*ABS(X)/DLOGMB)
          ELSE IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
              NDIG = NDIG - IEXTRA - 1
              IEXTRA = 0
          ELSE IF (KR_RETRY <= 0 .AND. NCALL > 1) THEN
              NDIG = NDIG - IEXTRA
              IEXTRA = 0
          ENDIF
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

      J2 = INT(5.0D0 + 0.001D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMI2M(1,MXY(6))
      NTERM = 1
      DO J = 1, J2
         CALL FMDIVI_R1(MXY(6),NTERM)
         CALL FMDIVI(MXY(6),NTERM,MJSUMS(J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(1),J2,MXY(5))

  130 CALL FMMPY_R1(MXY(6),MXY(5))
      DO J = 1, J2
         CALL FMDIVI_R1(MXY(6),NTERM)
         CALL FMDIVI(MXY(6),NTERM,MXY(4))
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(5))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(1),MXY(5))
             CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
          ENDDO
      ENDIF
      CALL FMMPY(MXY(1),MXY(5),MXY(13))

      CALL FMEULR(MXY(12))
      CALL FMABS(MXY(1),MXY(2))
      CALL FMLN(MXY(2),MXY(11))
      CALL FMADD(MXY(13),MXY(11),MXY(2))
      CALL FMADD(MXY(2),MXY(12),MXY(10))

      GO TO 180

!             Method 2.  Use the N!/X**N series.

  150 J2 = INT(4.5D0 + 0.0025D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS,J2))
      IF (KFLAGX == 0) THEN
          IF (X > 0 .AND. KR_RETRY <= 0 .AND. NCALL <= 1) THEN
              NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
          ENDIF
      ENDIF
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMI2M(1,MXY(6))
      CALL FMDIV(MXY(6),MXY(1),MXY(15))
      NTERM = 0
      DO J = 1, J2
         IF (NTERM >= 2) CALL FMMPYI_R1(MXY(6),NTERM)
         CALL FMEQ(MXY(6),MJSUMS(J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(15))+2)+MWK(START(MXY(6))+2) < -NDIG-3) GO TO 160
      CALL FMIPWR(MXY(15),J2,MXY(5))

      DO JTERMS = 1, NTERMS
         CALL FMMPY_R1(MXY(6),MXY(5))
         DO J = 1, J2
            CALL FMMPYI_R1(MXY(6),NTERM)
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(6))
            IF (KFLAG /= 0) GO TO 160
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(6))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  160 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(5))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(15),MXY(5))
             CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
          ENDDO
      ENDIF
      CALL FMMPY(MXY(15),MXY(5),MXY(13))
      CALL FMEXP(MXY(1),MXY(11))
      IF (MWK(START(MXY(11))+2) == MEXPOV .AND. MWK(START(MXY(1))) > 0) THEN
          CALL FMEQ(MXY(11),MXY(10))
          GO TO 180
      ELSE
          CALL FMMPY(MXY(11),MXY(13),MXY(10))
      ENDIF

      NDIG = NDSAV1
      GO TO 180

!             Method 3.  Use the continued fraction expansion.

!             MXY(14) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

  170 NDSAV1 = NDIG
      JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0))
      IF (NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      CALL FMEQ(MXY(1),MXY(13))
      IF (MWK(START(MXY(13))+2) /= MUNKNO .AND. MWK(START(MXY(13))+3) /= 0)  &
          MWK(START(MXY(13))) = -MWK(START(MXY(13)))
      CALL FMI2M(1,MXY(8))
      CALL FMEQU(MXY(13),MXY(9),NDSAV1,NDIG)
      CALL FMI2M(1,MXY(2))
      CALL FMDIV(MXY(2),MXY(13),MXY(10))
      CALL FMEQ(MXY(10),MXY(14))

!             Method 3 continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, NTERMS
         CALL FMMPYI(MXY(8),J,MXY(6))
         CALL FMADD(MXY(9),MXY(6),MXY(7))
         CALL FMMPY_R2(MXY(6),MXY(10))
         CALL FMDIV_R1(MXY(10),MXY(7))
         IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
             MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         NDIG = NDSAV2
         CALL FMADD_R1(MXY(14),MXY(10))
         KFLAG1 = KFLAG
         CALL FMEQ(MXY(9),MXY(8))
         CALL FMEQ(MXY(7),MXY(9))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(10))+2))))
         CALL FMMPYI(MXY(8),J,MXY(6))
         CALL FMMPY(MXY(13),MXY(9),MXY(3))
         CALL FMADD(MXY(3),MXY(6),MXY(7))
         CALL FMMPY_R2(MXY(6),MXY(10))
         CALL FMDIV_R1(MXY(10),MXY(7))
         IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
             MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         NDIG = NDSAV2
         CALL FMADD_R1(MXY(14),MXY(10))

!             Check for convergence.

         IF (KFLAG1 == 1 .AND. KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(9),MXY(8))
         CALL FMEQ(MXY(7),MXY(9))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(10))+2))))
      ENDDO

      CALL FMEQU_R1(MXY(14),NDIG,NDSAV1)
      NDIG = NDSAV1
      CALL FMEXP(MXY(1),MXY(15))
      CALL FMMPY(MXY(14),MXY(15),MXY(10))
      IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
          MWK(START(MXY(10))) = -MWK(START(MXY(10)))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  180 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(10))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(10))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(10))+J+1)) GO TO 190
              ENDDO
              GO TO 200
          ENDIF
  190     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(10))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(10),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  200 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(10))+1) = MIN(MWK(START(MXY(10))+1),MACCA,MACMAX)
      CALL FMEXT2(MXY(10),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEI

      SUBROUTINE FMEN(IVAL,MA,MB)

!  MB = Exponential Integral(IVAL,MA)

!  Integral from 1 to Infinity of e**(-MA*t) / t**IVAL  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      INTEGER :: IVAL,N
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR,X
      INTEGER :: IEXTRA,J,J2,JS,JTERM,K,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,  &
                 K_RETURN_CODE,NDSAVE,NDSAV1,NDSAV2,NGOAL,NMETHD,NTERM,NTERMS
      INTEGER, SAVE :: M_EULER_HARMONIC = -3
      INTEGER, SAVE :: IVAL_E_H = 0, NDIG_E_H = 0
      REAL (KIND(1.0D0)), SAVE :: MBS_E_H = 0
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: IVAL,MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(14),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0
      K = 0
      N = IVAL

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1) THEN
          IF (N > 1 .AND. MWK(START(MA)+2) < -NDIG) K = 1
          IF (N <= 0) THEN
              J = NTRACE
              NTRACE = 0
              KL = KWARN
              KWARN = 0
              KRSAVE = KROUND
              KROUND = 1
              NDSAVE = NDIG
              NDIG = NDIG + NGRD52
              CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
              CALL FMI2M(-N,MXY(2))
              CALL FMFACT(MXY(2),MXY(3))
              CALL FMIPWR(MXY(1),-N+1,MXY(5))
              CALL FMDIV(MXY(3),MXY(5),MXY(4))
              CALL FMI2M(-1,MXY(6))
              CALL FMDIVI(MXY(6),-N+1,MXY(5))
              IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG) K = 1
              NTRACE = J
              KWARN = KL
              NDIG = NDSAVE
              KROUND = KRSAVE
          ENDIF
          IF (MWK(START(MA)) < 0 .AND. N > 0) K = 0
      ENDIF
      IF (KROUND /= 1 .AND. K == 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          IF (MWK(START(MA)+2) == MEXPUN) CALL FMTINY(MXY(1))
          IF (N == 2) THEN
              CALL FMI2M(1,MXY(4))
              CALL FMLN(MXY(1),MXY(2))
              CALL FMEULR(MXY(3))
              CALL FMADD(MXY(2),MXY(3),MXY(5))
              CALL FMMPY(MXY(5),MXY(1),MXY(6))
              CALL FMSUB(MXY(6),MXY(1),MXY(5))
          ELSE IF (N >= 3) THEN
              CALL FMI2M(1,MXY(2))
              CALL FMDIVI(MXY(2),N-1,MXY(4))
              CALL FMDIVI(MXY(1),-(N-2),MXY(5))
          ENDIF
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG+1 .AND.  &
              MWK(START(MXY(4))+2) < MUNKNO) THEN
              CALL FMEQU(MXY(4),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB)
                  IF (MWK(START(MB)+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(6))) > 0) THEN
                          IF (MWK(START(MXY(7))) < 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(7))) < 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMEN'
                  CALL FMNTRI(2,N,1)
                  CALL FMNTR(2,MA,MA,1,0)
                  NCALL = NCALL - 1
              ENDIF
              IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMEN'
                  KFLAG = -4
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMEN'
                  IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
                  CALL FMWRN2
                  NCALL = NCALL - 1
              ENDIF
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMEN'
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      IF (NTRACE /= 0) THEN
          NCALL = NCALL + 1
          NAMEST(NCALL) = 'FMEN'
          CALL FMNTRI(2,IVAL,1)
          NCALL = NCALL - 1
      ENDIF
      CALL FMENT2('FMEN     ',MA,MA,1,0,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

!             Special cases.

      IF (IVAL > 0 .AND. (MWK(START(MXY(1))) < 0 .OR. MWK(START(MXY(1))+3) == 0)) THEN
          IF (IVAL > 1 .AND. MWK(START(MXY(1))+3) == 0) THEN
              CALL FMI2M(1,MXY(2))
              CALL FMDIVI(MXY(2),IVAL-1,MXY(12))
          ELSE
              CALL FMST2M('UNKNOWN',MXY(12))
              KFLAG = -4
          ENDIF
          GO TO 180
      ENDIF
      IF (IVAL <= 0 .AND. MWK(START(MXY(1))+3) == 0) THEN
          CALL FMST2M('UNKNOWN',MXY(12))
          KFLAG = -4
          GO TO 180
      ENDIF
      IF (IVAL == 0) THEN
          CALL FMI2M(-1000,MXY(3))
          IF (FMCOMP(MXY(1),'>=',MXY(3))) THEN
              CALL FMEQ(MXY(1),MXY(3))
              IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
                  MWK(START(MXY(3))) = -MWK(START(MXY(3)))
              CALL FMEXP(MXY(3),MXY(4))
              CALL FMDIV(MXY(4),MXY(1),MXY(12))
          ELSE
              CALL FMEQ(MXY(1),MXY(3))
              IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
                  MWK(START(MXY(3))) = -MWK(START(MXY(3)))
              CALL FMLN(MXY(3),MXY(4))
              CALL FMSUB(MXY(3),MXY(4),MXY(5))
              CALL FMEXP(MXY(5),MXY(12))
              IF (MWK(START(MXY(12))+2) /= MUNKNO .AND. MWK(START(MXY(12))+3) /= 0)  &
                  MWK(START(MXY(12))) = -MWK(START(MXY(12)))
          ENDIF
          GO TO 180
      ELSE IF (IVAL == 1 .AND. MWK(START(MXY(1))+2) < -NDIG) THEN
          CALL FMEULR(MXY(11))
          CALL FMLN(MXY(1),MXY(10))
          CALL FMADD(MXY(10),MXY(11),MXY(4))
          CALL FMSUB(MXY(1),MXY(4),MXY(12))
          GO TO 180
      ELSE IF (IVAL == 2 .AND. (MWK(START(MXY(1))+2) < -NDIG .OR. MWK(START(MXY(1))+3) == 0)) THEN
          IF (MWK(START(MXY(1))+2) < -NDIG*2 .OR. MWK(START(MXY(1))+3) == 0) THEN
              CALL FMI2M(1,MXY(12))
          ELSE
              CALL FMEULR(MXY(11))
              CALL FMLN(MXY(1),MXY(10))
              CALL FMADD(MXY(10),MXY(11),MXY(4))
              CALL FMI2M(1,MXY(3))
              CALL FMSUB(MXY(4),MXY(3),MXY(2))
              CALL FMMPY(MXY(2),MXY(1),MXY(5))
              CALL FMADD(MXY(3),MXY(5),MXY(12))
          ENDIF
          GO TO 180
      ELSE IF (IVAL > 2 .AND. (MWK(START(MXY(1))+2) < -NDIG .OR. MWK(START(MXY(1))+3) == 0)) THEN
          CALL FMI2M(1,MXY(3))
          CALL FMDIVI(MXY(3),IVAL-1,MXY(4))
          CALL FMDIVI(MXY(1),IVAL-2,MXY(5))
          CALL FMSUB(MXY(4),MXY(5),MXY(12))
          GO TO 180
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 use the convergent series,
!                    = 2 use the continued fraction expansion,
!                    = 3 for small positive IVAL use a recurrence involving ExponentialEi,
!                    = 4 for small negative IVAL use a recurrence involving exp,
!                    = 5 use incomplete gamma.

      CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) > 0) THEN
          X = DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      NMETHD = 5
      IF (IVAL > 0) THEN
          IF (ABS(X) < (NDIG*ALOGMB)/(5.5 + 0.00095*IVAL) +   &
              (NDIG*ALOGMB)**2 * 1.0E-4 * (4.22 + LOG(REAL(IVAL)))/(24 + LOG(REAL(IVAL))) .AND.  &
              ABS(MWK(START(MXY(1))+2)) < MEXPOV .AND. MWK(START(MXY(1))+3) /= 0) THEN
              NMETHD = 1
          ELSE IF (IVAL < MAX(2,INT((NDIG+3)*ALOGMB/32)) .AND.  &
                   ABS(X) > (NDIG+5)*ALOGMB + LOG(6.2832*(NDIG+5)*ALOGMB)/2) THEN
              NMETHD = 3
          ELSE
              NMETHD = 2
          ENDIF
      ELSE IF (IVAL < 0 .AND. IVAL >= -10 .AND. ABS(X) > 1 .AND.  &
               ABS(MWK(START(MXY(1))+2)) < MEXPOV .AND. MWK(START(MXY(1))+3) /= 0) THEN
          NMETHD = 2
      ELSE IF (IVAL < 0 .AND. IVAL >= -10 .AND. ABS(X) <= 1 .AND.  &
               ABS(MWK(START(MXY(1))+2)) < MEXPOV .AND. MWK(START(MXY(1))+3) /= 0) THEN
          NMETHD = 4
      ELSE IF (IVAL < 0 .AND. IVAL > -500 .AND.  &
               ABS(MWK(START(MXY(1))+2)) < MEXPOV .AND. MWK(START(MXY(1))+3) /= 0) THEN
          NMETHD = 4
      ENDIF
      IF (NMETHD == 2) GO TO 140
      IF (NMETHD == 3) GO TO 150
      IF (NMETHD == 4) GO TO 160
      IF (NMETHD == 5) GO TO 170

!             Method 1.  Use the (-X)**N/((N-IVAL+1)*N!) series.

      IF (KFLAGX == 0) THEN
          IF (X > 0) THEN
              IEXTRA = INT(2.0D0*ABS(X)/DLOGMB)
          ELSE IF (KR_RETRY <= 0) THEN
              NDIG = NDIG - IEXTRA - 1
              IEXTRA = 0
          ENDIF
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

      J2 = INT(5.0D0 + 0.001D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMI2M(1,MXY(6))
      JTERM = 0
      NTERM = IVAL - 1
      DO J = 1, J2
         IF (J > 2) CALL FMDIVI_R1(MXY(6),JTERM)
         IF (NTERM /= 0) THEN
             CALL FMDIVI(MXY(6),NTERM,MJSUMS(J))
         ELSE
             IF (IVAL == IVAL_E_H .AND. NDIG <= NDIG_E_H .AND. MBS_E_H == MBASE) THEN
                 CALL FMEQ(M_EULER_HARMONIC,MXY(2))
                 CALL FMLN(MXY(1),MXY(3))
                 CALL FMSUB_R1(MXY(2),MXY(3))
                 CALL FMMPY(MXY(6),MXY(2),MJSUMS(J))
             ELSE
                 CALL FMEULER(MXY(2))
                 MWK(START(MXY(2))) = -MWK(START(MXY(2)))
                 CALL FMI2M(1,MXY(3))
                 DO K = 1, IVAL-1
                    CALL FMDIVI(MXY(3),K,MXY(4))
                    CALL FMADD_R1(MXY(2),MXY(4))
                 ENDDO
                 IVAL_E_H = IVAL
                 NDIG_E_H = NDIG
                 MBS_E_H = MBASE
                 CALL FMEQ(MXY(2),M_EULER_HARMONIC)
                 CALL FMLN(MXY(1),MXY(3))
                 CALL FMSUB_R1(MXY(2),MXY(3))
                 CALL FMMPY(MXY(6),MXY(2),MJSUMS(J))
             ENDIF
         ENDIF
         JTERM = JTERM + 1
         NTERM = NTERM - 1
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 130
      CALL FMEQ(MXY(1),MXY(2))
      IF (MWK(START(MXY(2))+2) /= MUNKNO .AND. MWK(START(MXY(2))+3) /= 0)  &
          MWK(START(MXY(2))) = -MWK(START(MXY(2)))
      CALL FMIPWR(MXY(2),J2,MXY(5))

  120 CALL FMMPY_R1(MXY(6),MXY(5))
      DO J = 1, J2
         CALL FMDIVI_R1(MXY(6),JTERM)
         IF (NTERM /= 0) THEN
             CALL FMDIVI(MXY(6),NTERM,MXY(4))
         ELSE
             IF (IVAL == IVAL_E_H .AND. NDIG <= NDIG_E_H .AND. MBS_E_H == MBASE) THEN
                 CALL FMEQ(M_EULER_HARMONIC,MXY(7))
                 CALL FMLN(MXY(1),MXY(3))
                 CALL FMSUB_R1(MXY(7),MXY(3))
                 CALL FMMPY(MXY(6),MXY(7),MXY(4))
             ELSE
                 CALL FMEULER(MXY(7))
                 MWK(START(MXY(7))) = -MWK(START(MXY(7)))
                 CALL FMI2M(1,MXY(3))
                 DO K = 1, IVAL-1
                    CALL FMDIVI(MXY(3),K,MXY(4))
                    CALL FMADD_R1(MXY(7),MXY(4))
                 ENDDO
                 IVAL_E_H = IVAL
                 NDIG_E_H = NDIG
                 MBS_E_H = MBASE
                 CALL FMEQ(MXY(7),M_EULER_HARMONIC)
                 CALL FMLN(MXY(1),MXY(3))
                 CALL FMSUB_R1(MXY(7),MXY(3))
                 CALL FMMPY(MXY(6),MXY(7),MXY(4))
             ENDIF
         ENDIF
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0) GO TO 130
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
         JTERM = JTERM + 1
         NTERM = NTERM - 1
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(5))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(2),MXY(5))
             CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
          ENDDO
      ENDIF
      CALL FMEQ(MXY(5),MXY(12))
      GO TO 180

!             Method 2.  use the continued fraction expansion.

!             MXY(14) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

  140 IF (KFLAGX == 0) THEN
          IF (X > 0 .AND. IVAL > 0 .AND. KR_RETRY <= 0 .AND. NCALL <= 1) THEN
              NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
          ENDIF
      ENDIF
      CALL FMI2M(-IVAL,MXY(2))
      CALL FMSUB(MXY(2),MXY(1),MXY(3))
      CALL FMNINT(MXY(3),MXY(2))
      CALL FMSUB(MXY(3),MXY(2),MXY(4))
      IF (MWK(START(MXY(4))+3) == 0) THEN
          IF (IVAL <= 0) THEN
              IF (ABS(IVAL) <= 100) THEN
                  GO TO 160
              ELSE
                  GO TO 170
              ENDIF
          ELSE
              GO TO 170
          ENDIF
      ENDIF
      IEXTRA = 0
      IF (MWK(START(MXY(2))) >= 0) THEN
          IF (MWK(START(MXY(4))+2) < 0) IEXTRA = -MWK(START(MXY(4))+2)
      ENDIF
      IF (IVAL < 0) THEN
          IF (ABS(X) > 1/SQRT(DPMAX) .AND. ABS(X) < SQRT(DPMAX)) THEN
              J = (LOG(6.2831853D0) + LOG(DBLE(-IVAL)) - IVAL*(LOG(DBLE(-IVAL))-1) -  &
                  (1-IVAL)*LOG(ABS(X))) / DLOGMB + NGRD21
          ELSE
              J = (LOG(6.2831853D0) + LOG(DBLE(-IVAL)) - IVAL*(LOG(DBLE(-IVAL))-1)) / DLOGMB  &
                  - DBLE(1-IVAL)*(MWK(START(MXY(1))+2)-1)
          ENDIF
          IEXTRA = MAX(IEXTRA,J)
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA
      NDSAV1 = NDIG
      CALL FMI2M(0,MXY(8))
      CALL FMI2M(1,MXY(9))
      CALL FMI2M(0,MXY(10))
      CALL FMI2M(0,MXY(14))
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 1) THEN
             CALL FMMPY(MXY(1),MXY(9),MXY(11))
             CALL FMMPYI(MXY(8),(J-1)/2,MXY(12))
         ELSE
             CALL FMEQ(MXY(9),MXY(11))
             CALL FMMPYI(MXY(8),IVAL+(J-2)/2,MXY(12))
         ENDIF
         IF (J == 1) THEN
             CALL FMEQ(MXY(11),MXY(7))
             CALL FMEXP(MXY(1),MXY(5))
             IF (MWK(START(MXY(5))+2) >= MEXPOV) GO TO 170
             CALL FMMPY(MXY(1),MXY(5),MXY(6))
             CALL FMI2M(1,MXY(2))
             CALL FMDIV(MXY(2),MXY(6),MXY(10))
         ELSE
             CALL FMADD(MXY(11),MXY(12),MXY(7))
             CALL FMMPY_R1(MXY(10),MXY(12))
             CALL FMDIV_R1(MXY(10),MXY(7))
             IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
                 MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         ENDIF
         CALL FMEQ(MXY(9),MXY(8))
         CALL FMEQ(MXY(7),MXY(9))
         NDIG = NDSAV2
         CALL FMADD_R1(MXY(14),MXY(10))

!             Check for convergence.

         IF (KFLAG == 1 .AND. J > 1) THEN
             EXIT
         ENDIF
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(10))+2))))
      ENDDO

      CALL FMEQ(MXY(14),MXY(12))
      NDIG = NDSAV1
      IF (MWK(START(MXY(12))+2) == MUNKNO) GO TO 170
      GO TO 180

!             Method 3.  For small positive IVAL use a recurrence involving ExponentialEi.

  150 KACCSW = 1
      NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 27
      IF (MWK(START(MXY(1))) < 0) THEN
          CALL FMST2M('UNKNOWN',MXY(12))
          KFLAG = -4
      ELSE IF (IVAL == 1) THEN
          CALL FMEQ(MXY(1),MXY(3))
          IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
              MWK(START(MXY(3))) = -MWK(START(MXY(3)))
          CALL FMEI(MXY(3),MXY(12))
          IF (MWK(START(MXY((12)))+2) /= MUNKNO .AND. MWK(START(MXY((12)))+3) /= 0)  &
              MWK(START(MXY((12)))) = -MWK(START(MXY((12))))
          IF (MWK(START(MXY(12))+1) <= NGOAL) THEN
              NDIG = 2*NDIG
              GO TO 110
          ENDIF
      ELSE
          IEXTRA = 0
          IF (KFLAGX == 0) THEN
              IEXTRA = INT(IVAL/2.25D0*(LOG(ABS(X))-1.1D0*(LOG(DBLE(IVAL))-1.4D0))*DLOGTN/DLOGMB)
              IEXTRA = MAX(0,IEXTRA)
          ENDIF
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          ENDIF
          NDIG = NDIG + IEXTRA
          CALL FMEQ(MXY(1),MXY(3))
          IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
              MWK(START(MXY(3))) = -MWK(START(MXY(3)))
          CALL FMEI(MXY(3),MXY(4))
          IF (MWK(START(MXY((4)))+2) /= MUNKNO .AND. MWK(START(MXY((4)))+3) /= 0)  &
              MWK(START(MXY((4)))) = -MWK(START(MXY((4))))
          IF (MWK(START(MXY(4))+2) == MEXPUN) THEN
              CALL FMEQ(MXY(4),MXY(12))
          ELSE
              CALL FMEXP(MXY(3),MXY(5))
              DO J = 1, IVAL-1
                 CALL FMMPY(MXY(4),MXY(3),MXY(6))
                 IF (J > 2) CALL FMDIVI_R1(MXY(6),J-1)
                 CALL FMADD(MXY(6),MXY(5),MXY(4))
              ENDDO
              CALL FMDIVI(MXY(4),IVAL-1,MXY(12))
          ENDIF
          IF (MWK(START(MXY(12))+1) <= NGOAL) THEN
              NDIG = 2*NDIG
              GO TO 110
          ENDIF
      ENDIF
      IF (MWK(START(MXY(12))+2) == MUNKNO) GO TO 170
      GO TO 180

!             Method 4.  For small negative IVAL use a recurrence involving exp.

  160 CALL FMEQ(MXY(1),MXY(3))
      IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
          MWK(START(MXY(3))) = -MWK(START(MXY(3)))
      CALL FMI2M(1,MXY(4))
      CALL FMI2M(1,MXY(5))
      DO J = 1, -IVAL
         CALL FMMPY_R1(MXY(5),MXY(1))
         IF (J > 1) CALL FMDIVI_R1(MXY(5),J)
         CALL FMADD_R1(MXY(4),MXY(5))
      ENDDO
      CALL FMMPY_R1(MXY(5),MXY(1))
      CALL FMDIV(MXY(4),MXY(5),MXY(6))
      CALL FMABS(MXY(6),MXY(7))
      CALL FMLN(MXY(7),MXY(8))
      CALL FMSUB(MXY(8),MXY(1),MXY(5))
      CALL FMEXP(MXY(5),MXY(12))
      IF (MWK(START(MXY(12))+2) /= MUNKNO .AND. MWK(START(MXY(6))) < 0)  &
          MWK(START(MXY(12))) = -MWK(START(MXY(12)))
      IF (MWK(START(MXY(12))+2) == MUNKNO) GO TO 170
      GO TO 180

!             Method 5.  use incomplete gamma.

  170 IF (MWK(START(MXY(1))) < 0) THEN
          IF (IVAL > 0) THEN
              CALL FMST2M('UNKNOWN',MXY(12))
              KFLAG = -4
          ELSE
              CALL FMI2M(-1,MXY(12))
              IF (IVAL == -1 .AND. FMCOMP(MXY(1),'==',MXY(12))) THEN
                  CALL FMI2M(0,MXY(12))
              ELSE
                  N = 1 - IVAL
                  CALL FMI2M(N,MXY(12))
                  RAISE_NDIG = 1
                  CALL FMIGM2(MXY(12),MXY(1),MXY(13))
                  RAISE_NDIG = 0
                  IF (MWK(START(MXY(13))+2) == MEXPOV) THEN
                      N = IVAL
                      CALL FMI2M(1,MXY(7))
                      CALL FMI2M(1,MXY(8))
                      CALL FMDIV(MXY(8),MXY(1),MXY(9))
                      IF (MWK(START(MXY(9))+2) /= MUNKNO .AND. MWK(START(MXY(9))+3) /= 0)  &
                          MWK(START(MXY(9))) = -MWK(START(MXY(9)))
                      JS = 0
                      DO J = 0, 10000
                         CALL FMMPYI_R1(MXY(7),N+J)
                         CALL FMMPY_R1(MXY(7),MXY(9))
                         CALL FMADD_R1(MXY(8),MXY(7))
                         IF (KFLAG == 1) THEN
                             JS = 1
                             EXIT
                         ENDIF
                      ENDDO
                      IF (JS == 1) THEN
                          CALL FMLN(MXY(8),MXY(9))
                          CALL FMSUB(MXY(9),MXY(1),MXY(7))
                          CALL FMI2M(0,MXY(6))
                          CALL FMSUB(MXY(6),MXY(1),MXY(2))
                          CALL FMLN(MXY(2),MXY(3))
                          CALL FMSUB(MXY(7),MXY(3),MXY(2))
                          CALL FMEXP(MXY(2),MXY(3))
                          CALL FMSUB(MXY(6),MXY(3),MXY(12))
                      ELSE
                          CALL FMST2M('UNKNOWN',MXY(12))
                          KFLAG = -4
                      ENDIF
                  ELSE
                      CALL FMEQ(MXY(13),MXY(12))
                      N = IVAL - 1
                      CALL FMIPWR(MXY(1),N,MXY(3))
                      CALL FMMPY_R2(MXY(3),MXY(12))
                  ENDIF
              ENDIF
          ENDIF
      ELSE
          N = 1 - IVAL
          CALL FMI2M(N,MXY(12))
          RAISE_NDIG = 1
          CALL FMIGM2(MXY(12),MXY(1),MXY(13))
          RAISE_NDIG = 0
          IF (MWK(START(MXY(13))+2) == MEXPUN .AND. IVAL > 0) THEN
              CALL FMEQ(MXY(1),MXY(4))
              IF (MWK(START(MXY(4))+2) /= MUNKNO .AND. MWK(START(MXY(4))+3) /= 0)  &
                  MWK(START(MXY(4))) = -MWK(START(MXY(4)))
              CALL FMEXP(MXY(4),MXY(5))
              CALL FMDIV(MXY(5),MXY(1),MXY(6))
              IF (MWK(START(MXY(6))+2) == MEXPUN) THEN
                  CALL FMST2M('UNDERFLOW',MXY(12))
                  KFLAG = -6
              ELSE
                  CALL FMI2M(1,MXY(7))
                  CALL FMI2M(1,MXY(8))
                  CALL FMDIV(MXY(8),MXY(1),MXY(9))
                  IF (MWK(START(MXY(9))+2) /= MUNKNO .AND. MWK(START(MXY(9))+3) /= 0)  &
                      MWK(START(MXY(9))) = -MWK(START(MXY(9)))
                  JS = 0
                  DO J = 0, 10000
                     CALL FMMPYI_R1(MXY(7),N+J)
                     CALL FMMPY_R1(MXY(7),MXY(9))
                     CALL FMADD_R1(MXY(8),MXY(7))
                     IF (KFLAG == 1) THEN
                         JS = 1
                         EXIT
                     ENDIF
                  ENDDO
                  IF (JS == 1) THEN
                      CALL FMMPY(MXY(6),MXY(8),MXY(12))
                  ELSE
                      CALL FMST2M('UNKNOWN',MXY(12))
                      KFLAG = -4
                  ENDIF
              ENDIF
          ELSE
              CALL FMEQ(MXY(13),MXY(12))
              N = IVAL - 1
              CALL FMIPWR(MXY(1),N,MXY(3))
              CALL FMMPY_R2(MXY(3),MXY(12))
          ENDIF
      ENDIF

  180 NAMEST(NCALL) = 'FMEN'
      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(12))+1) = MIN(MWK(START(MXY(12))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(12))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(12),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMEN

      SUBROUTINE FMERF(MA,MB)

!  MB = Erf(MA)    Error function.

!  2/Sqrt(pi) * Integral from 0 to MA of e**(-t**2) dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: C1,C2,ERR,X
      INTEGER :: IEXTRA,J,J2,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,NDSAVE,NDSAV1,NDSAV2,  &
                 NMETHD,NTERM,NTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(14),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMERF    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)

!             X is a double precision approximation to the input argument to this function.

      MWK(START(MXY(1))) = 1
      CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) > 0) THEN
          X = DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      C1 = SQRT(DLOGMB*(NDIG+21))/5
      C2 = (DLOGMB*(NDIG+6))**0.6D0/4.1D0
      IF (MWK(START(MXY(1))+2) < 1) THEN
          NMETHD = 1
      ELSE IF (ABS(X) <= C1) THEN
          NMETHD = 1
      ELSE IF (ABS(X) <= C2) THEN
          NMETHD = 2
      ELSE
          NMETHD = 3
      ENDIF
      IF (NMETHD /= 1) GO TO 140

!             Method 1.  Use the (-1)**n x**(2n+1) / n! / (2n+1) series.

!             If MA is large in magnitude, use more guard digits.

      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      IF (KFLAGX == 0) THEN
          IF (ABS(X) > 2 .AND. ABS(X) < SQRT(HUGE(X))) THEN
              IEXTRA = MAX(INT((X*X-1.83-LOG(2*X*X+1))/ALOGMB+1),0)
              IF (IEXTRA > 0) THEN
                  CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
              ENDIF
              NDIG = NDIG + IEXTRA
          ENDIF
      ENDIF

      J2 = INT(5.0D0 + 0.001D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL FMEQ(MXY(1),MXY(6))
      CALL FMEQ(MXY(1),MJSUMS(1))
      DO J = 2, J2
         CALL FMDIVI_R1(MXY(6),-NTERM)
         CALL FMDIVI(MXY(6),2*NTERM+1,MJSUMS(J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 130
      CALL FMIPWR(MXY(1),2*J2,MXY(5))

  120 CALL FMMPY_R1(MXY(6),MXY(5))
      DO J = 1, J2
         CALL FMDIVI_R1(MXY(6),-NTERM)
         CALL FMDIVI(MXY(6),2*NTERM+1,MXY(4))
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0) GO TO 130
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 120

!             Put the J2 separate sums back together.

  130 KFLAG = 0
      CALL FMSQR(MXY(1),MXY(4))
      CALL FMEQ(MJSUMS(J2),MXY(5))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(4),MXY(5))
             CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
          ENDDO
      ENDIF

      CALL FMPI(MXY(4))
      CALL FMSQRT(MXY(4),MXY(3))
      CALL FMMPYI(MXY(5),2,MXY(4))
      CALL FMDIV_R2(MXY(4),MXY(3))
      GO TO 180

  140 IF (NMETHD /= 2) GO TO 170

!             Method 2.  Use the x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF

      MWK(START(MXY(1))) = 1
      J2 = INT(5.0D0 + 0.001D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      NTERM = 1
      CALL FMMPYI(MXY(1),2,MXY(6))
      CALL FMEQ(MXY(6),MJSUMS(1))
      DO J = 2, J2
         CALL FMMPYI_R1(MXY(6),2)
         CALL FMDIVI_R1(MXY(6),2*NTERM+1)
         CALL FMEQ(MXY(6),MJSUMS(J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 160
      CALL FMIPWR(MXY(1),2*J2,MXY(5))

  150 CALL FMMPY_R1(MXY(6),MXY(5))
      DO J = 1, J2
         CALL FMMPYI_R1(MXY(6),2)
         CALL FMDIVI_R1(MXY(6),2*NTERM+1)
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(6))
         IF (KFLAG /= 0) GO TO 160
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(6))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
         NTERM = NTERM + 1
      ENDDO
      GO TO 150

!             Put the J2 separate sums back together.

  160 KFLAG = 0
      CALL FMSQR(MXY(1),MXY(6))
      CALL FMEQ(MJSUMS(J2),MXY(5))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(6),MXY(5))
             CALL FMADD_R1(MXY(5),MJSUMS(J2-J+1))
          ENDDO
      ENDIF

      CALL FMPI(MXY(4))
      CALL FMSQRT(MXY(4),MXY(3))
      CALL FMDIV_R2(MXY(5),MXY(3))
      CALL FMEXP(MXY(6),MXY(4))
      CALL FMDIV_R1(MXY(3),MXY(4))

      GO TO 180

!             Method 3.  Use the continued fraction expansion.

!             MXY(2) is abs(x).
!             MXY(3) is abs(2x).
!             MXY(4) is -x*x.
!             MXY(14) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

  170 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      NDSAV1 = NDIG
      CALL FMABS(MXY(1),MXY(2))
      CALL FMMPYI(MXY(2),2,MXY(3))
      CALL FMSQR(MXY(2),MXY(4))
      IF (MWK(START(MXY(4))+2) /= MUNKNO .AND. MWK(START(MXY(4))+3) /= 0)  &
          MWK(START(MXY(4))) = -MWK(START(MXY(4)))
      CALL FMI2M(0,MXY(8))
      CALL FMI2M(1,MXY(9))
      CALL FMI2M(1,MXY(10))
      CALL FMI2M(1,MXY(14))
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 1) THEN
             CALL FMMPY(MXY(2),MXY(9),MXY(11))
         ELSE
             CALL FMMPY(MXY(3),MXY(9),MXY(11))
         ENDIF
         IF (J == 1) THEN
             CALL FMEQ(MXY(11),MXY(7))
             CALL FMEXP(MXY(4),MXY(5))
             CALL FMPI(MXY(12))
             CALL FMSQRT(MXY(12),MXY(6))
             CALL FMDIV(MXY(5),MXY(6),MXY(10))
             CALL FMDIV_R1(MXY(10),MXY(2))
             IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
                 MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         ELSE
             CALL FMMPYI(MXY(8),J-1,MXY(12))
             CALL FMADD(MXY(11),MXY(12),MXY(7))
             CALL FMMPY_R1(MXY(10),MXY(12))
             CALL FMDIV_R1(MXY(10),MXY(7))
             IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
                 MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         ENDIF
         CALL FMEQ(MXY(9),MXY(8))
         CALL FMEQ(MXY(7),MXY(9))
         NDIG = NDSAV2
         CALL FMADD_R1(MXY(14),MXY(10))

!             Check for convergence.

         IF (KFLAG == 1) THEN
             EXIT
         ENDIF
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(10))+2))))
      ENDDO

      CALL FMEQ(MXY(14),MXY(3))
      NDIG = NDSAV1
  180 IF (KROUND /= 1) THEN
          IF (MWK(START(MXY(3))+2) == 1 .AND. MWK(START(MA)) > 0 .AND.  &
              (KROUND == -1 .OR. KROUND == 0)) THEN
              CALL FMTINY(MXY(1))
              CALL FMSUB_R1(MXY(3),MXY(1))
          ENDIF
          IF (MWK(START(MXY(3))+2) == 1 .AND. MWK(START(MA)) < 0 .AND.  &
              (KROUND == 2 .OR. KROUND == 0)) THEN
              KRSAVE = KROUND
              KROUND = 0
              CALL FMTINY(MXY(1))
              CALL FMSUB_R1(MXY(3),MXY(1))
              KROUND = KRSAVE
          ENDIF
          IF (KFLAG == 1) KFLAG = 0
      ENDIF

      IF (MWK(START(MA)) < 0) THEN
          IF (MWK(START(MXY(3))+2) /= MUNKNO .AND. MWK(START(MXY(3))+3) /= 0)  &
              MWK(START(MXY(3))) = -MWK(START(MXY(3)))
      ENDIF
      NAMEST(NCALL) = 'FMERF'

      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(3))+1) = MIN(MWK(START(MXY(3))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(3),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMERF

      SUBROUTINE FMERFC(MA,MB)

!  MB = ERFC(MA)    Complimentary Error function.

!  2/Sqrt(pi) * Integral from MA to infinity of e**(-t**2) dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: C1,ERR,X
      INTEGER :: IEXTRA,J,K,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,  &
                 NDSAVE,NDSAV1,NDSAV2,NMETHD,NTERMS
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(14),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1 .AND. MWK(START(MA)+2) < -NDIG) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMI2M(1,MXY(4))
          IF (MWK(START(MA)+2) == MEXPUN) THEN
              CALL FMI2M(0,MXY(2))
              CALL FMSUB(MXY(2),MXY(1),MXY(5))
          ELSE
              CALL FMPI(MXY(2))
              CALL FMSQRT(MXY(2),MXY(3))
              CALL FMDIV(MXY(4),MXY(3),MXY(5))
              CALL FMMPYI(MXY(5),-2,MXY(6))
              CALL FMMPY(MXY(1),MXY(6),MXY(5))
          ENDIF
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG) THEN
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
              NDIG = NDSAVE
              KROUND = KRSAVE
              CALL FMADD(MXY(6),MXY(7),MB)
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NCALL = NCALL + 1
                  NAMEST(NCALL) = 'FMERFC'
                  CALL FMNTR(2,MA,MA,1,1)
                  CALL FMNTR(1,MB,MB,1,1)
                  NCALL = NCALL - 1
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMERFC   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMI2M(1,MXY(3))
      CALL FMDIVI_R1(MXY(3),2)
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

!             Check for special cases.

      IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMI2M(1,MXY(3))
          GO TO 130
      ENDIF

!             X is a double precision approximation to the input argument to this function.

      CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) > 0) THEN
          X = DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF
      C1 = (DLOGMB*(NDIG+6))**0.7D0/9
      IF (MWK(START(MXY(1))+2) < 1) THEN
          NMETHD = 1
      ELSE IF (X <= C1) THEN
          NMETHD = 1
      ELSE
          NMETHD = 2
      ENDIF
      IF (NMETHD /= 1) GO TO 120

!             Method 1.  Use ERF.

      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      IF (X < 2) THEN
          RAISE_NDIG = 1
          CALL FMERF(MXY(1),MXY(4))
          RAISE_NDIG = 0
          CALL FMI2M(1,MXY(2))
          CALL FMSUB(MXY(2),MXY(4),MXY(3))
          GO TO 130
      ENDIF

!             Raise precision to compensate for cancellation if x is large.

      IEXTRA = MAX(INT((X*X+LOG(2*X))/ALOGMB+1),0)
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA
      RAISE_NDIG = 1
      CALL FMERF(MXY(1),MXY(4))
      RAISE_NDIG = 0
      CALL FMI2M(1,MXY(2))
      CALL FMSUB(MXY(2),MXY(4),MXY(3))
      GO TO 130

  120 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      NDSAV1 = NDIG

!             Method 2.  Use the continued fraction expansion.

!             MXY(2) is abs(x).
!             MXY(3) is abs(2x).
!             MXY(4) is -x*x.
!             MXY(14) is the current approximation.
!             MXY(10) is the term in the sum, S(k).
!             MXY(8), MXY(9) are the latest denominators, Q(k-1) and Q(k).

      CALL FMABS(MXY(1),MXY(2))
      CALL FMMPYI(MXY(2),2,MXY(3))
      CALL FMSQR(MXY(2),MXY(4))
      IF (MWK(START(MXY(4))+2) /= MUNKNO .AND. MWK(START(MXY(4))+3) /= 0)  &
          MWK(START(MXY(4))) = -MWK(START(MXY(4)))
      CALL FMI2M(0,MXY(8))
      CALL FMI2M(1,MXY(9))
      CALL FMI2M(1,MXY(10))
      CALL FMI2M(0,MXY(14))
      NTERMS = INT(INTMAX/10)

!             Continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 1) THEN
             CALL FMMPY(MXY(2),MXY(9),MXY(11))
         ELSE
             CALL FMMPY(MXY(3),MXY(9),MXY(11))
         ENDIF
         IF (J == 1) THEN
             CALL FMEQ(MXY(11),MXY(7))
             CALL FMEXP(MXY(4),MXY(5))
             CALL FMPI(MXY(12))
             CALL FMSQRT(MXY(12),MXY(6))
             CALL FMDIV(MXY(5),MXY(6),MXY(10))
             CALL FMDIV_R1(MXY(10),MXY(2))
             IF (MWK(START(MXY(10))+2) == MEXPUN) THEN
                 CALL FMEQ(MXY(10),MXY(3))
                 GO TO 130
             ENDIF
         ELSE
             CALL FMMPYI(MXY(8),J-1,MXY(12))
             CALL FMADD(MXY(11),MXY(12),MXY(7))
             CALL FMMPY_R1(MXY(10),MXY(12))
             CALL FMDIV_R1(MXY(10),MXY(7))
             IF (MWK(START(MXY(10))+2) /= MUNKNO .AND. MWK(START(MXY(10))+3) /= 0)  &
                 MWK(START(MXY(10))) = -MWK(START(MXY(10)))
         ENDIF
         CALL FMEQ(MXY(9),MXY(8))
         CALL FMEQ(MXY(7),MXY(9))
         NDIG = NDSAV2
         CALL FMADD_R1(MXY(14),MXY(10))

!             Check for convergence.

         IF (J > 1 .AND. KFLAG == 1) THEN
             EXIT
         ENDIF
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(10))+2))))
      ENDDO

      CALL FMEQ(MXY(14),MXY(3))
      NDIG = NDSAV1

  130 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(3))+1) = MIN(MWK(START(MXY(3))+1),MACCA,MACMAX)
      NAMEST(NCALL) = 'FMERFC'

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(3))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      IF (KROUND == -1 .OR. KROUND == 0) THEN
          CALL FMI2M(2,MXY(1))
          IF (FMCOMP(MXY(3),'==',MXY(1))) THEN
              CALL FMDP2M(1.9999D0,MXY(2))
              CALL FMULP(MXY(2),MXY(4))
              CALL FMSUB(MXY(1),MXY(4),MXY(3))
          ENDIF
      ENDIF
      CALL FMEXT2(MXY(3),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMERFC

      SUBROUTINE FMFGFI(MA,MB,MC)

!  Internal routine for the two auxiliary asymptotic series used in the sine and cosine
!  Fresnel integral functions.

!  For x = MA the two values returned are MB and MC, where

!  MB = f(x) = (1 - 1*3/(pi*x*x)**2 + 1*3*5*7/(pi*x*x)**4 - ...) / (pi*x)
!  MC = g(x) = (1 - 1*3*5/(pi*x*x)**2 + 1*3*5*7*9/(pi*x*x)**4 - ...) / (pi**2*x**3)

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: J,J2,JTERMS,NBOT,NDSAV1,NTERM,NTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MXY(6),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NTERMS = INT(INTMAX/10)
      J2 = INT(4.5D0 + 0.0025D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS/2,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums for f(x) and another J2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

!             MXY(6) is 1/(pi*x*x)**2
!             MXY(4) is the current term

      CALL FMI2M(1,MXY(4))
      CALL FMDIV(MXY(4),MA,MXY(2))
      CALL FMSQR(MXY(2),MXY(6))
      CALL FMPI(MXY(1))
      CALL FMDIV(MXY(6),MXY(1),MXY(2))
      CALL FMSQR(MXY(2),MXY(6))
      NTERM = 0
      DO J = 1, J2
         NBOT = -(2*NTERM-1)
         IF (NTERM >= 2) CALL FMMPYI_R1(MXY(4),NBOT)
         CALL FMEQ(MXY(4),MJSUMS(J))
         NTERM = NTERM + 1

         NBOT = 2*NTERM - 1
         IF (NTERM >= 2) CALL FMMPYI_R1(MXY(4),NBOT)
         CALL FMEQ(MXY(4),MJSUMS(J2+J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(6))+2)+MWK(START(MXY(4))+2) < -NDIG-3) GO TO 110
      CALL FMIPWR(MXY(6),J2,MXY(3))

      DO JTERMS = 1, NTERMS
         CALL FMMPY_R1(MXY(4),MXY(3))
         DO J = 1, J2
            NBOT = -(2*NTERM-1)
            CALL FMMPYI_R1(MXY(4),NBOT)
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(4))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1

            NBOT = 2*NTERM - 1
            CALL FMMPYI_R1(MXY(4),NBOT)
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J2+J),MXY(4))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J2+J))+2)-MWK(START(MXY(4))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  110 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(3))
      CALL FMEQ(MJSUMS(J2+J2),MXY(5))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(6),MXY(3))
             CALL FMADD_R1(MXY(3),MJSUMS(J2-J+1))

             CALL FMMPY_R2(MXY(6),MXY(5))
             CALL FMADD_R1(MXY(5),MJSUMS(J2+J2-J+1))
          ENDDO
      ENDIF
      CALL FMMPY(MA,MXY(1),MXY(2))
      CALL FMDIV(MXY(3),MXY(2),MB)

      CALL FMSQR(MXY(2),MXY(3))
      CALL FMMPY(MXY(3),MA,MXY(2))
      CALL FMDIV(MXY(5),MXY(2),MC)

      NDIG = NDSAV1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFGFI

      SUBROUTINE FMFHGH(MA,MB,MC)

!  Internal routine for the two auxiliary asymptotic series used in the hyperbolic sine and
!  cosine integral functions.

!  For x = MA the two values returned are MB and MC, where

!  MB = f(x) = (1 + 2!/x**2 + 4!/x**4 + ...) / x
!  MC = g(x) = (1 + 3!/x**2 + 5!/x**4 + ...) / x**2

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: J,J2,JTERMS,NBOT,NDSAV1,NTERM,NTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MXY(5),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NTERMS = INT(INTMAX/10)
      J2 = INT(4.5D0 + 0.0025D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS/2,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums for f(x) and another J2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      CALL FMI2M(1,MXY(3))
      CALL FMDIV(MXY(3),MA,MXY(1))
      CALL FMSQR(MXY(1),MXY(5))
      NTERM = 0
      DO J = 1, J2
         NBOT = NTERM
         IF (NTERM >= 2) CALL FMMPYI_R1(MXY(3),NBOT)
         CALL FMEQ(MXY(3),MJSUMS(J))
         NTERM = NTERM + 1

         IF (NTERM >= 2) CALL FMMPYI_R1(MXY(3),NTERM)
         CALL FMEQ(MXY(3),MJSUMS(J2+J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(5))+2)+MWK(START(MXY(3))+2) < -NDIG-3) GO TO 110
      CALL FMIPWR(MXY(5),J2,MXY(2))

      DO JTERMS = 1, NTERMS
         CALL FMMPY_R1(MXY(3),MXY(2))
         DO J = 1, J2
            NBOT = NTERM
            CALL FMMPYI_R1(MXY(3),NBOT)
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(3))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(3))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1

            CALL FMMPYI_R1(MXY(3),NTERM)
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J2+J),MXY(3))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J2+J))+2)-MWK(START(MXY(3))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  110 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(2))
      CALL FMEQ(MJSUMS(J2+J2),MXY(4))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(5),MXY(2))
             CALL FMADD_R1(MXY(2),MJSUMS(J2-J+1))

             CALL FMMPY_R2(MXY(5),MXY(4))
             CALL FMADD_R1(MXY(4),MJSUMS(J2+J2-J+1))
          ENDDO
      ENDIF
      CALL FMDIV(MXY(2),MA,MB)
      CALL FMMPY(MXY(4),MXY(5),MC)

      NDIG = NDSAV1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFHGH

      SUBROUTINE FMFXGX(MA,MB,MC)

!  Internal routine for the two auxiliary asymptotic series used in the sine and
!  cosine integral functions.

!  For x = MA the two values returned are MB and MC, where

!  MB = f(x) = (1 - 2!/x**2 + 4!/x**4 - ...) / x
!  MC = g(x) = (1 - 3!/x**2 + 5!/x**4 - ...) / x**2

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB,MC
      INTEGER :: J,J2,JTERMS,NBOT,NDSAV1,NTERM,NTERMS
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB,MC
      INTEGER :: MXY(5),MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      IF (MC <= 0) THEN
          CALL FMDEFINE(MC)
      ELSE IF (SIZE_OF(MC) < NDIG+3) THEN
          CALL FMDEFINE(MC)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      NTERMS = INT(INTMAX/10)
      J2 = INT(4.5D0 + 0.0025D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS/2,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums for f(x) and another J2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      CALL FMI2M(1,MXY(3))
      CALL FMDIV(MXY(3),MA,MXY(1))
      CALL FMSQR(MXY(1),MXY(5))
      NTERM = 0
      DO J = 1, J2
         NBOT = -NTERM
         IF (NTERM >= 2) CALL FMMPYI_R1(MXY(3),NBOT)
         CALL FMEQ(MXY(3),MJSUMS(J))
         NTERM = NTERM + 1

         IF (NTERM >= 2) CALL FMMPYI_R1(MXY(3),NTERM)
         CALL FMEQ(MXY(3),MJSUMS(J2+J))
         NTERM = NTERM + 1
      ENDDO
      IF (MWK(START(MXY(5))+2)+MWK(START(MXY(3))+2) < -NDIG-3) GO TO 110
      CALL FMIPWR(MXY(5),J2,MXY(2))

      DO JTERMS = 1, NTERMS
         CALL FMMPY_R1(MXY(3),MXY(2))
         DO J = 1, J2
            NBOT = -NTERM
            CALL FMMPYI_R1(MXY(3),NBOT)
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J),MXY(3))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(3))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1

            CALL FMMPYI_R1(MXY(3),NTERM)
            NDIG = NDSAV1
            CALL FMADD_R1(MJSUMS(J2+J),MXY(3))
            IF (KFLAG /= 0) GO TO 110
            NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J2+J))+2)-MWK(START(MXY(3))+2))
            NDIG = MIN(NDSAV1,NDIG)
            IF (NDIG < NGRD22) NDIG = NGRD22
            NTERM = NTERM + 1
         ENDDO
      ENDDO

!             Put the J2 separate sums back together.

  110 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(2))
      CALL FMEQ(MJSUMS(J2+J2),MXY(4))
      IF (J2 >= 2) THEN
          DO J = 2, J2
             CALL FMMPY_R2(MXY(5),MXY(2))
             CALL FMADD_R1(MXY(2),MJSUMS(J2-J+1))

             CALL FMMPY_R2(MXY(5),MXY(4))
             CALL FMADD_R1(MXY(4),MJSUMS(J2+J2-J+1))
          ENDDO
      ENDIF
      CALL FMDIV(MXY(2),MA,MB)
      CALL FMMPY(MXY(4),MXY(5),MC)

      NDIG = NDSAV1
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          IF (TEMPV(MC) == -1) TEMPV(MC) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMFXGX

      SUBROUTINE FMLERC(MA,MB)

!  MB = Ln(erfc(MA))

!  MA must be positive, and is assumed to be large enough that erfc(MA) might underflow.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR
      INTEGER :: J,JEXTRA,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAV1,NDSAV2,NDSAVE,NMETHD,NTERMS
      LOGICAL, EXTERNAL :: FMCOMP
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(17),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMLERC   ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

      NTERMS = INT(INTMAX/10)

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMI2M(0,MXY(11))
          GO TO 140
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          KFLAG = -4
          CALL FMST2M('UNKNOWN',MXY(11))
          GO TO 140
      ENDIF
      IF (MWK(START(MXY(1))+2) == MEXPOV .AND. MWK(START(MXY(1))) > 0) THEN
              CALL FMST2M('-OVERFLOW',MXY(11))
              KFLAG = -5
          GO TO 140
      ENDIF

!            Close to zero use the series for Ln(1-erf(x)).

      IF (LOG(MWK(START(MXY(1))+3)+1.0D0)+(MWK(START(MXY(1))+2)-1)*DLOGMB < -10.0D0*DLOGTN) THEN
          CALL FMERF(MXY(1),MXY(10))
          CALL FMEQ(MXY(10),MXY(11))
          CALL FMEQ(MXY(10),MXY(6))
          IF (MWK(START(MXY(11))+2) /= MUNKNO .AND. MWK(START(MXY(11))+3) /= 0)  &
              MWK(START(MXY(11))) = -MWK(START(MXY(11)))
          DO J = 2, NTERMS
             CALL FMMPY_R1(MXY(6),MXY(10))
             CALL FMDIVI(MXY(6),J,MXY(3))
             CALL FMSUB_R1(MXY(11),MXY(3))
             IF (KFLAG == 1) EXIT
          ENDDO
          GO TO 140
      ENDIF

!             Determine which method to use.

!             NMETHD = 1 means use FMERFC,
!                    = 2 means use the asymptotic value,
!                    = 3 means use the continued fraction expansion.

      NMETHD = 1
      CALL FMI2M(1000,MXY(3))
      IF (MWK(START(MXY(1))+2) >= NDIG) THEN
          NMETHD = 2
      ELSE IF(FMCOMP(MXY(1),'>',MXY(3))) THEN
          NMETHD = 3
      ENDIF

      IF (NMETHD == 2) GO TO 120
      IF (NMETHD == 3) GO TO 130

!             Method 1.  Use FMERFC.

      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      CALL FMERFC(MXY(1),MXY(15))
      CALL FMLN(MXY(15),MXY(11))

      NAMEST(NCALL) = 'FMLERC'

      GO TO 140

!             Method 2.  Use the asymptotic value.

  120 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      IF (MWK(START(MXY(1))) == 1) THEN
          CALL FMPI(MXY(16))
          CALL FMSQRT(MXY(16),MXY(3))
          CALL FMMPY_R1(MXY(3),MXY(1))
          CALL FMI2M(1,MXY(2))
          CALL FMDIV(MXY(2),MXY(3),MXY(11))
          CALL FMLN(MXY(11),MXY(4))
          CALL FMSQR(MXY(1),MXY(5))
          CALL FMSUB(MXY(4),MXY(5),MXY(11))
      ELSE
          CALL FMI2M(2,MXY(3))
          CALL FMLN(MXY(3),MXY(11))
      ENDIF

      GO TO 140

!             Method 3.  Use the continued fraction expansion.

!             MXY(14) is the current approximation.
!             MXY(11) is the term in the sum, S(k).
!             MXY(9), MXY(10) are the latest denominators, Q(k-1) and Q(k).

  130 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      NDSAV1 = NDIG
      JEXTRA = INT(MAX(1.0,5.76/ALOGMB + 1.0))
      IF (NDIG+JEXTRA > NDSAV1) THEN
          CALL FMEQU_R1(MXY(1),NDSAV1,NDSAV1+JEXTRA)
      ENDIF
      NDIG = NDIG + JEXTRA
      CALL FMI2M(1,MXY(9))
      CALL FMEQ(MXY(1),MXY(10))
      CALL FMI2M(1,MXY(11))
      CALL FMI2M(1,MXY(14))

!             Method 3 continued fraction loop.

      NDSAV2 = NDIG
      DO J = 1, NTERMS
         IF (MOD(J,2) == 0) THEN
             CALL FMMPYI(MXY(9),J/2,MXY(7))
             CALL FMMPY(MXY(1),MXY(10),MXY(3))
             CALL FMADD(MXY(3),MXY(7),MXY(8))
         ELSE
             CALL FMMPYI(MXY(9),J,MXY(3))
             CALL FMDIVI(MXY(3),2,MXY(7))
             CALL FMMPY(MXY(1),MXY(10),MXY(3))
             CALL FMADD(MXY(3),MXY(7),MXY(8))
         ENDIF
         CALL FMMPY(MXY(7),MXY(11),MXY(3))
         CALL FMDIV(MXY(3),MXY(8),MXY(11))
         IF (MWK(START(MXY(11))+2) /= MUNKNO .AND. MWK(START(MXY(11))+3) /= 0)  &
             MWK(START(MXY(11))) = -MWK(START(MXY(11)))
         NDIG = NDSAV2
         CALL FMADD_R1(MXY(14),MXY(11))

!             Check for convergence.

         IF (KFLAG == 1) THEN
             EXIT
         ENDIF
         CALL FMEQ(MXY(10),MXY(9))
         CALL FMEQ(MXY(8),MXY(10))
         NDIG = MIN(NDSAV2,MAX(NGRD22,NDSAV2-INT(MWK(START(MXY(14))+2)-MWK(START(MXY(11))+2))))
      ENDDO

      CALL FMEQU_R1(MXY(14),NDIG,NDSAV1)
      NDIG = NDSAV1
      CALL FMPI(MXY(16))
      CALL FMSQRT(MXY(16),MXY(3))
      CALL FMDIV(MXY(14),MXY(3),MXY(11))
      CALL FMDIV(MXY(11),MXY(1),MXY(12))
      CALL FMLN(MXY(12),MXY(13))
      CALL FMSQR(MXY(1),MXY(12))
      IF (MWK(START(MXY(12))+2) < MEXPOV) THEN
          CALL FMSUB(MXY(13),MXY(12),MXY(11))
      ELSE
          CALL FMEQ(MXY(12),MXY(11))
          IF (MWK(START(MXY(11))+2) /= MUNKNO .AND. MWK(START(MXY(11))+3) /= 0)  &
              MWK(START(MXY(11))) = -MWK(START(MXY(11)))
      ENDIF

  140 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(11))+1) = MIN(MWK(START(MXY(11))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(11))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF
      CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLERC

      SUBROUTINE FMLI(MA,MB)

!  MB = Logarithmic Integral(MA)

!  Integral from 0 to MA of 1 / Ln(t)  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      DOUBLE PRECISION :: ERR,X
      INTEGER :: J,KASAVE,KL,KOVUN,KR_RETRY,KRESLT,NDSAVE
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(3),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMLI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMI2M(0,MXY(2))
      ELSE IF (MWK(START(MXY(1))+2) == MEXPUN .AND. MWK(START(MXY(1))) == 1) THEN
          CALL FMST2M('-UNDERFLOW',MXY(2))
          KFLAG = -6
      ELSE
          CALL FMLN(MXY(1),MXY(3))
          CALL FMEI(MXY(3),MXY(2))
      ENDIF

      NAMEST(NCALL) = 'FMLI'

      MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(2))+1) = MIN(MWK(START(MXY(2))+1),MACCA,MACMAX)

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(2))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      KL = KFLAG
      CALL FMM2DP(MXY(1),X)
      IF (KFLAG == 0 .AND. KL == 0) THEN
          IF (X > 1.44 .AND. X < 1.46) THEN
              IF (MWK(START(MXY(2))+2) < 0) THEN
                  IF (KR_RETRY <= 1 .AND. NDIG < 2*NDSAVE+10) THEN
                      KR_RETRY = 2
                      GO TO 110
                  ENDIF
              ENDIF
          ENDIF
      ENDIF
      KFLAG = KL
      CALL FMEXT2(MXY(2),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMLI

      SUBROUTINE FMS(MA,MB)

!  MB = S(MA)    Fresnel Sine Integral.

!  Integral from 0 to MA of Sin(pi*t**2/2) dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,JR,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,LARGE,NBOT,NDGOAL,  &
                 NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY

      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(14),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE
      LOGICAL, EXTERNAL :: FMCOMP

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED

      CALL FMENT2('FMS      ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMEQ(MXY(1),MXY(11))
          GO TO 180
      ENDIF
      IF (4*MWK(START(MXY(1))+2) < -NDIG) THEN
          CALL FMSQR(MXY(1),MXY(11))
          CALL FMMPY_R2(MXY(1),MXY(11))
          CALL FMPI(MXY(3))
          CALL FMDIVI(MXY(3),6,MXY(4))
          CALL FMMPY_R1(MXY(11),MXY(4))
          GO TO 160
      ENDIF
      CALL FMINT(MXY(1),MXY(8))
      IF (MWK(START(MXY(1))+2) > NDIG .AND. FMCOMP(MXY(1),'==',MXY(8)) .AND.  &
          MWK(START(MXY(1))+2) < MEXPOV) THEN
          CALL FMI2M(1,MXY(8))
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(11))
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(11))
          ENDIF
          CALL FMPI(MXY(6))
          CALL FMMPY_R1(MXY(6),MXY(1))
          CALL FMDIV_R2(MXY(8),MXY(6))
          JR = KROUND
          IF (KROUND == -1 .AND. MWK(START(MA)) < 0) KROUND =  2
          IF (KROUND ==  2 .AND. MWK(START(MA)) < 0) KROUND = -1
          CALL FMSUB_R1(MXY(11),MXY(6))
          KROUND = JR
          GO TO 180
      ENDIF
      IF (MWK(START(MXY(1))+2) > NDIG) THEN
          CALL FMI2M(1,MXY(8))
          IF (MWK(START(MXY(1))) < 0) THEN
              CALL FMDIVI(MXY(8),-2,MXY(11))
          ELSE
              CALL FMDIVI(MXY(8),2,MXY(11))
          ENDIF
          GO TO 160
      ENDIF

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) ,INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      IF (KFLAGX == 0) THEN
          IF (ABS(X) < SQRT(HUGE(X)/(4*LOG(HUGE(X))))) THEN
              Y = (DPPI*X*X-1)/2
              Y = (2*Y+1.5)*LOG(2*Y+2) - (2*Y+1) - Y*DLOGTW - (Y+0.5)*LOG(Y+1) + Y - Y*LOG(DPPI*X*X)
              IF (Y <= -(NDIG+1)*DLOGMB) THEN
                  NMETHD = 2
              ELSE
                  NMETHD = 1
              ENDIF
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use x times the series (-1)**n*(pi*x*x/2)**(2*n+1)/((4*n+3)*(2*n+1)!).

!             MXY(6) is the current term
!             MXY(9) is pi*x*x/2

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          IEXTRA = MAX(0.0D0,(0.096*X*X + 0.033*ABS(X) - 0.5)*LOG(1.0E7)/ALOGMB)
          IF (IEXTRA > 0) THEN
              CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
          ENDIF
      ENDIF
      NDIG = NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF

      J2 = INT(5.0D0 + 0.001D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMSQR(MXY(1),MXY(4))
      CALL FMDIVI(MXY(4),2,MXY(9))
      CALL FMPI(MXY(3))
      CALL FMMPY_R1(MXY(9),MXY(3))
      CALL FMI2M(1,MXY(6))
      CALL FMDIVI(MXY(6),3,MJSUMS(1))
      NTERM = 0
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL FMDIVI_R1(MXY(6),NTERM+1)
         NTERM = NTERM + 1
         NBOT = -(NTERM+1)
         CALL FMDIVI_R1(MXY(6),NBOT)
         CALL FMDIVI(MXY(6),2*NTERM+3,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(9),2*J2,MXY(7))

  130 CALL FMMPY_R1(MXY(6),MXY(7))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         NBOT = NTERM*(NTERM+1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMDIVI_R1(MXY(6),NTERM)
             NBOT = -(NTERM + 1)
             CALL FMDIVI_R1(MXY(6),NBOT)
         ELSE
             CALL FMDIVI_R1(MXY(6),-NBOT)
         ENDIF
         CALL FMDIVI(MXY(6),2*NTERM+3,MXY(2))
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(2))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(6))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(11))
      IF (J2 >= 2) THEN
          CALL FMSQR(MXY(9),MXY(8))
          DO J = 2, J2
             CALL FMMPY_R2(MXY(8),MXY(11))
             CALL FMADD_R1(MXY(11),MJSUMS(J2-J+1))
          ENDDO
      ENDIF
      CALL FMMPY_R1(MXY(11),MXY(1))
      CALL FMMPY_R1(MXY(11),MXY(9))

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then S(x) = 0.5 - f(x)*cos(pi*x*x/2) - g(x)*sin(pi*x*x/2).

  150 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-1)
      ENDIF
      CALL FMFGFI(MXY(1),MXY(12),MXY(13))
      CALL FMSQR(MXY(1),MXY(4))
      KRSAVE = KRAD
      KRAD = 0
      CALL FMMPYI(MXY(4),90,MXY(7))
      CALL FMCSSN(MXY(7),MXY(14),MXY(10))
      KRAD = KRSAVE
      CALL FMMPY(MXY(12),MXY(14),MXY(11))
      CALL FMMPY(MXY(13),MXY(10),MXY(7))
      CALL FMI2M(1,MXY(4))
      CALL FMDIVI(MXY(4),2,MXY(5))
      CALL FMSUB(MXY(5),MXY(11),MXY(6))
      CALL FMSUB(MXY(6),MXY(7),MXY(11))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(11))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(11))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(11))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(11))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(11),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(11))+1) = MIN(MWK(START(MXY(11))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) == -1) THEN
          IF(MWK(START(MXY(11))+3) /= 0 .AND. MWK(START(MXY(11))+2) /= MUNKNO)  &
             MWK(START(MXY(11))) =-1
      ENDIF
      CALL FMEXT2(MXY(11),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMS

      SUBROUTINE FMSHI(MA,MB)

!  MB = Hyperbolic Sine Integral(MA)

!  Integral from 0 to MA of sinh(t) / t  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,k,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE,  &
                 NBOT,NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(12),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0
      K = 0
      NCALL = NCALL + 1

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1) THEN
          J = NTRACE
          NTRACE = 0
          KL = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMDIVI(MXY(1),18,MXY(2))
          IF (MWK(START(MXY(2))+2) < -NDIG) K = 1
          NTRACE = J
          KWARN = KL
      ENDIF
      IF (KROUND /= 1 .AND. K == 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMSQR(MXY(1),MXY(2))
          CALL FMMPY(MXY(1),MXY(2),MXY(3))
          CALL FMDIVI(MXY(3),18,MXY(5))
          CALL FMEQ(MXY(1),MXY(4))
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG .AND.  &
              MWK(START(MXY(4))+2) > MEXPUN) THEN
              CALL FMEQU(MXY(4),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MXY(9))
                  IF (MWK(START(MXY(9))+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(6))) > 0) THEN
                          IF (MWK(START(MXY(7))) < 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MXY(9))
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(7))) < 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MXY(9))
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MXY(9))
                          ENDIF
                      ENDIF
                  ENDIF
                  CALL FMEQU(MXY(9),MB,NDIG,NDSAVE)
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ELSE IF (MWK(START(MXY(4))+2) == MEXPUN) THEN
              IF (KRSAVE == 2 .AND. MWK(START(MA)) == 1) THEN
                  CALL FMTINY(MXY(9))
                  CALL FMEQU(MXY(9),MB,NDIG,NDSAVE)
                  K_RETURN_CODE = 1
              ENDIF
              IF (KRSAVE == -1 .AND. MWK(START(MA)) == -1) THEN
                  CALL FMTINY(MXY(9))
                  MWK(START(MXY(9))) = -1
                  CALL FMEQU(MXY(9),MB,NDIG,NDSAVE)
                  K_RETURN_CODE = 1
              ENDIF
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NAMEST(NCALL) = 'FMSHI'
                  CALL FMNTR(2,MA,MA,1,1)
                  CALL FMNTR(1,MB,MB,1,1)
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMSHI    ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMI2M(0,MXY(8))
          GO TO 180
      ELSE IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMEQ(MXY(1),MXY(8))
          GO TO 180
      ELSE IF (MWK(START(MXY(1))+2) == MEXPOV) THEN
          CALL FMST2M('OVERFLOW',MXY(8))
          KFLAG = -5
          GO TO 180
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) ,INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (NDIG+5)*DLOGMB
          IF (ABS(X) > Y+(DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the X**(2*N+1)/((2*N+1)*(2*N+1)!) series.

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          Y = NINT(ABS(X)/2)
          Y = 2*Y*LOG(ABS(X)+1.0E-9) - LOG(2*Y+1.0E-9) - (2*Y+0.5)*LOG(2*Y+1) + 2*Y
          Y = Y/DLOGMB - 7/ALOGMT
          IEXTRA = MAX(0,INT(Y+1))
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA
      IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
      ENDIF

      J2 = INT(5.0D0 + 0.001D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMEQ(MXY(1),MXY(7))
      CALL FMEQ(MXY(1),MJSUMS(1))
      NTERM = 1
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL FMDIVI_R1(MXY(7),NTERM)
         NTERM = NTERM + 1
         NBOT = NTERM
         CALL FMDIVI_R1(MXY(7),NBOT)
         CALL FMDIVI(MXY(7),NTERM,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(1),2*J2,MXY(5))

  130 CALL FMMPY_R1(MXY(7),MXY(5))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMDIVI_R1(MXY(7),NTERM)
             NBOT = (NTERM - 1)
             CALL FMDIVI_R1(MXY(7),NBOT)
         ELSE
             NBOT = NBOT
             CALL FMDIVI_R1(MXY(7),NBOT)
             NBOT = NBOT
         ENDIF
         CALL FMDIVI(MXY(7),NTERM,MXY(4))
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(8))
      IF (J2 >= 2) THEN
          CALL FMSQR(MXY(1),MXY(6))
          DO J = 2, J2
             CALL FMMPY_R2(MXY(6),MXY(8))
             CALL FMADD_R1(MXY(8),MJSUMS(J2-J+1))
          ENDDO
      ENDIF

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then Shi(x) = f(x)*cosh(x) + g(x)*sinh(x).

  150 IF (KR_RETRY <= 0 .AND. NCALL <= 1) THEN
          NDIG = MAX(NDSAVE+NGRD52,NDIG-2)
      ENDIF
      CALL FMFHGH(MXY(1),MXY(9),MXY(10))
      CALL FMCHSH(MXY(1),MXY(11),MXY(12))
      IF (MWK(START(MXY(11))+2) < MEXPOV) THEN
          CALL FMMPY(MXY(9),MXY(11),MXY(2))
          CALL FMMPY(MXY(10),MXY(12),MXY(3))
          CALL FMADD(MXY(2),MXY(3),MXY(8))
      ELSE
          CALL FMADD(MXY(9),MXY(10),MXY(5))
          CALL FMDIVI_R1(MXY(5),2)
          CALL FMLN(MXY(5),MXY(8))
          CALL FMADD(MXY(1),MXY(8),MXY(5))
          CALL FMEXP(MXY(5),MXY(8))
      ENDIF

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(8))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(8))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(8))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(8))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(8),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(8))+1) = MIN(MWK(START(MXY(8))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) < 0 .AND. MWK(START(MXY(8))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(8))+3) /= 0) THEN
          MWK(START(MXY(8))) = -MWK(START(MXY(8)))
      ENDIF
      CALL FMEXT2(MXY(8),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSHI

      SUBROUTINE FMSI(MA,MB)

!  MB = Sine Integral(MA)

!  Integral from 0 to MA of sin(t) / t  dt.

      USE FMVALS
      IMPLICIT NONE

      INTEGER :: MA,MB
      DOUBLE PRECISION :: ERR,X,Y
      REAL (KIND(1.0D0)) :: MACCA,MACMAX,MXSAVE
      INTEGER :: IEXTRA,J,J2,K,KASAVE,KFLAGX,KL,KOVUN,KR_RETRY,KRESLT,KRSAVE,K_RETURN_CODE,LARGE,  &
                 NBOT,NDGOAL,NDOLD,NDSAV1,NDSAVE,NGOAL,NMETHD,NTERM,NUMTRY
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      INTEGER :: MXY(13),MRETRY,MJSUMS(LJSUMS),NUMBER_USED_SAVE

      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      MXY = -2
      MRETRY = -2
      MJSUMS = -2
      IF (MB <= 0) THEN
          CALL FMDEFINE(MB)
      ELSE IF (SIZE_OF(MB) < NDIG+3) THEN
          CALL FMDEFINE(MB)
      ENDIF
      NUMBER_USED_SAVE = NUMBER_USED
      K_RETURN_CODE = 0
      K = 0
      NCALL = NCALL + 1

!             Rounding for special cases in non-standard rounding modes (KROUND = -1, 0, or 2).

      IF (KROUND /= 1) THEN
          J = NTRACE
          NTRACE = 0
          KL = KWARN
          KWARN = 0
          CALL FMSQR(MA,MXY(1))
          CALL FMDIVI(MXY(1),18,MXY(2))
          IF (MWK(START(MXY(2))+2) < -NDIG) K = 1
          NTRACE = J
          KWARN = KL
      ENDIF
      IF (KROUND /= 1 .AND. K == 1) THEN
          J = NTRACE
          NTRACE = 0
          K = KWARN
          KWARN = 0
          KRSAVE = KROUND
          KROUND = 1
          NDSAVE = NDIG
          NDIG = NDIG + NGRD52
          CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
          CALL FMSQR(MXY(1),MXY(2))
          CALL FMMPY(MXY(1),MXY(2),MXY(3))
          CALL FMDIVI(MXY(3),-18,MXY(5))
          CALL FMEQ(MXY(1),MXY(4))
          IF (MWK(START(MXY(4))+2) - MWK(START(MXY(5))+2) > NDIG .AND.  &
              MWK(START(MXY(4))+2) > MEXPUN) THEN
              CALL FMEQU(MXY(4),MXY(10),NDIG,NDSAVE)
              CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
              CALL FMEQU(MXY(6),MXY(8),NDSAVE,NDIG)
              CALL FMSUB(MXY(4),MXY(8),MXY(6))
              IF (MWK(START(MXY(6))+3) == 0) THEN
                  CALL FMEQU(MXY(4),MXY(6),NDIG,NDSAVE)
                  CALL FMEQU(MXY(5),MXY(7),NDIG,NDSAVE)
                  NDIG = NDSAVE
                  KROUND = KRSAVE
                  CALL FMADD(MXY(6),MXY(7),MB)
                  IF (MWK(START(MB)+2) >= MEXPOV) THEN
                      IF (MWK(START(MXY(6))) > 0) THEN
                          IF (MWK(START(MXY(7))) < 0 .AND. (KROUND == -1 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. KROUND == 2) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ELSE
                          IF (MWK(START(MXY(7))) < 0 .AND. KROUND == -1) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMADD(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE IF (MWK(START(MXY(7))) > 0 .AND. (KROUND == 2 .OR. KROUND == 0)) THEN
                              CALL FMEQ(MXY(6),MXY(1))
                              MWK(START(MXY(1))+2) = 0
                              CALL FMULP(MXY(1),MXY(2))
                              CALL FMSUB(MXY(1),MXY(2),MXY(3))
                              MWK(START(MXY(3))+2) = MWK(START(MXY(6))+2) + MWK(START(MXY(3))+2)
                              CALL FMEQ(MXY(3),MB)
                          ELSE
                              KROUND = KRSAVE
                              CALL FMEQ(MXY(10),MB)
                          ENDIF
                      ENDIF
                  ENDIF
              ELSE
                  KROUND = KRSAVE
                  CALL FMEQU(MXY(4),MB,NDIG,NDSAVE)
              ENDIF
              K_RETURN_CODE = 1
          ENDIF
          KFLAG = 0
          NTRACE = J
          KWARN = K
          NDIG = NDSAVE
          KROUND = KRSAVE
          IF (K_RETURN_CODE == 1) THEN
              IF (NTRACE /= 0) THEN
                  NAMEST(NCALL) = 'FMSI'
                  CALL FMNTR(2,MA,MA,1,1)
              ENDIF
              IF (MWK(START(MB)+2) == MUNKNO .AND. MWK(START(MA)+2) /= MUNKNO) THEN
                  NAMEST(NCALL) = 'FMSI'
                  KFLAG = -4
                  CALL FMWRN2
              ELSE IF (ABS(MWK(START(MB)+2)) == MEXPOV .AND. ABS(MWK(START(MA)+2)) < MEXPOV) THEN
                  NAMEST(NCALL) = 'FMSI'
                  IF (MWK(START(MB)+2) == MEXPOV) KFLAG = -5
                  IF (MWK(START(MB)+2) == MEXPUN) KFLAG = -6
                  CALL FMWRN2
              ENDIF
              IF (NTRACE /= 0) THEN
                  NAMEST(NCALL) = 'FMSI'
                  CALL FMNTR(1,MB,MB,1,1)
              ENDIF
              NUMBER_USED = NUMBER_USED_SAVE
              IF (TEMPV_CALL_STACK == 1) THEN
                  IF (TEMPV(MB) == -1) TEMPV(MB) = -2
              ENDIF
              TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          ENDIF
      ENDIF
      NCALL = NCALL - 1
      IF (K_RETURN_CODE == 1) RETURN

      CALL FMENT2('FMSI     ',MA,MA,1,1,MB,KRESLT,NDSAVE,MXSAVE,KASAVE,KOVUN)
      IF (KRESLT /= 0) THEN
          NUMBER_USED = NUMBER_USED_SAVE
          IF (TEMPV_CALL_STACK == 1) THEN
              IF (TEMPV(MB) == -1) TEMPV(MB) = -2
          ENDIF
          TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
          RETURN
      ENDIF

      KACCSW = 1
      MACCA = MWK(START(MA)+1)
      KR_RETRY = 0

  110 IF (KR_RETRY >= 1) THEN
          IF (NCALL == 1) NDIG = MAX(NDIG,2*NDSAVE+10)
      ENDIF
      CALL FMEQU(MA,MXY(1),NDSAVE,NDIG)
      MWK(START(MXY(1))) = 1
      MWK(START(MXY(1))+1) = NINT(NDIG*ALOGM2)
      NUMTRY = 0

!             X is a double precision approximation to the input argument to this function.

  120 CALL FMM2DP(MXY(1),X)
      KFLAGX = KFLAG
      IF (KFLAG /= 0 .AND. MWK(START(MXY(1))+2) < 0) THEN
          X = 1.0D0/DPMAX
          IF (MWK(START(MXY(1))) < 0) X = -X
          KFLAGX = 0
      ENDIF

!             Check for special cases.

      IF (MWK(START(MXY(1))+3) == 0) THEN
          CALL FMI2M(0,MXY(8))
          GO TO 180
      ELSE IF (MWK(START(MXY(1))+2) == MEXPUN) THEN
          CALL FMEQ(MXY(1),MXY(8))
          GO TO 180
      ELSE IF (MWK(START(MXY(1))+2) > NDIG) THEN
          CALL FMPI(MXY(8))
          CALL FMDIVI_R1(MXY(8),2)
          GO TO 160
      ENDIF

!             If MA is large in magnitude, use more guard digits.

      IEXTRA = MIN(MAX(INT(MWK(START(MXY(1))+2)),0) ,INT(2.0+ALOGMX/ALOGMB))
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

!             Determine which method to use.

!             NMETHD = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      NMETHD = 1
      IF (KFLAGX /= 0) THEN
          IF (MWK(START(MXY(1))+2) <= 0) THEN
              NMETHD = 1
          ELSE
              NMETHD = 2
          ENDIF
      ELSE
          Y = (NDIG+5)*DLOGMB
          IF (ABS(X) > Y+(DLOGTP+LOG(Y))/2.0D0) NMETHD = 2
      ENDIF

      IF (NMETHD == 2) GO TO 150

!             Method 1.  Use the (-1)**N*X**(2*N+1)/((2*N+1)*(2*N+1)!) series.

      IEXTRA = 0
      IF (KFLAGX == 0) THEN
          Y = NINT(ABS(X)/2)
          Y = 2*Y*LOG(ABS(X)+1.0E-9) - LOG(2*Y+1.0E-9) - (2*Y+0.5)*LOG(2*Y+1) + 2*Y
          Y = Y/DLOGMB - 7/ALOGMT
          IEXTRA = MAX(0,INT(Y+1))
          IF (ABS(X) < 5 .AND. KR_RETRY <= 0) THEN
              NDIG = NDIG - 2
              IEXTRA = 0
          ENDIF
      ENDIF
      IF (IEXTRA > 0) THEN
          CALL FMEQU_R1(MXY(1),NDIG,NDIG+IEXTRA)
      ENDIF
      NDIG = NDIG + IEXTRA

      J2 = INT(5.0D0 + 0.001D0*NDIG*DLOGMB)
      J2 = MAX(1,MIN(LJSUMS,J2))
      NDSAV1 = NDIG

!             Split into J2 concurrent sums.

      CALL FMEQ(MXY(1),MXY(7))
      CALL FMEQ(MXY(1),MJSUMS(1))
      NTERM = 1
      DO J = 2, J2
         NTERM = NTERM + 1
         CALL FMDIVI_R1(MXY(7),NTERM)
         NTERM = NTERM + 1
         NBOT = -NTERM
         CALL FMDIVI_R1(MXY(7),NBOT)
         CALL FMDIVI(MXY(7),NTERM,MJSUMS(J))
      ENDDO
      IF (MWK(START(MXY(1))+2) < -NDIG) GO TO 140
      CALL FMIPWR(MXY(1),2*J2,MXY(5))

  130 CALL FMMPY_R1(MXY(7),MXY(5))
      DO J = 1, J2
         NTERM = NTERM + 2
         LARGE = INT(INTMAX/NTERM)
         NBOT = NTERM*(NTERM-1)
         IF (NTERM > LARGE .OR. NBOT > MXBASE) THEN
             CALL FMDIVI_R1(MXY(7),NTERM)
             NBOT = -(NTERM - 1)
             CALL FMDIVI_R1(MXY(7),NBOT)
         ELSE
             NBOT = -NBOT
             CALL FMDIVI_R1(MXY(7),NBOT)
             NBOT = -NBOT
         ENDIF
         CALL FMDIVI(MXY(7),NTERM,MXY(4))
         NDIG = NDSAV1
         CALL FMADD_R1(MJSUMS(J),MXY(4))
         IF (KFLAG /= 0) GO TO 140
         NDIG = NDSAV1 - INT(MWK(START(MJSUMS(J))+2)-MWK(START(MXY(4))+2))
         NDIG = MIN(NDSAV1,NDIG)
         IF (NDIG < NGRD22) NDIG = NGRD22
      ENDDO
      GO TO 130

!             Put the J2 separate sums back together.

  140 KFLAG = 0
      CALL FMEQ(MJSUMS(J2),MXY(8))
      IF (J2 >= 2) THEN
          CALL FMSQR(MXY(1),MXY(6))
          DO J = 2, J2
             CALL FMMPY_R2(MXY(6),MXY(8))
             CALL FMADD_R1(MXY(8),MJSUMS(J2-J+1))
          ENDDO
      ENDIF

      GO TO 160

!             Method 2.  Use the two N!/X**N asymptotic series for f(x) and g(x).
!                        Then Si(x) = pi/2 - f(x)*cos(x) - g(x)*sin(x).

  150 CALL FMFXGX(MXY(1),MXY(10),MXY(11))
      KRSAVE = KRAD
      KRAD = 1
      CALL FMCSSN(MXY(1),MXY(12),MXY(13))
      KRAD = KRSAVE
      CALL FMPI(MXY(9))
      IF (MWK(START(MXY(12))+2) == MUNKNO .OR. MWK(START(MXY(13))+2) == MUNKNO) THEN
          CALL FMMPYI(MXY(9),2,MXY(8))
          CALL FMDIV(MXY(1),MXY(8),MXY(3))
          CALL FMINT(MXY(3),MXY(2))
          CALL FMMPY(MXY(2),MXY(8),MXY(3))
          CALL FMSUB(MXY(1),MXY(3),MXY(8))
          KRSAVE = KRAD
          KRAD = 1
          CALL FMCSSN(MXY(8),MXY(12),MXY(13))
          KRAD = KRSAVE
      ENDIF
      CALL FMDIVI(MXY(9),2,MXY(2))
      CALL FMMPY(MXY(10),MXY(12),MXY(3))
      CALL FMSUB_R1(MXY(2),MXY(3))
      CALL FMMPY(MXY(11),MXY(13),MXY(3))
      CALL FMSUB(MXY(2),MXY(3),MXY(8))

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

  160 IF (NCALL == 1) THEN
          KL = MIN(NDIG-NDSAVE,INT(3*DLOGTN/DLOGMB + 1.5))
          ERR = 0
          DO J = KL, 1, -1
             ERR = (ERR + MWK(START(MXY(8))+J+NDSAVE+2)) / MBASE
          ENDDO
          IF ( (KROUND == 1 .AND. ERR > 0.498 .AND. ERR < 0.502) .OR.  &
               (KROUND /= 1 .AND. (ERR > 0.998 .OR. ERR < 0.002)) ) KR_RETRY = KR_RETRY + 1
      ENDIF
      IF (KR_RETRY == 1 .AND. NDIG < 2*NDSAVE+10) THEN
          KR_RETRY = 2
          GO TO 110
      ENDIF

!             Check for too much cancellation.

      IF (NCALL <= 1) THEN
          NGOAL = INT(REAL(NDSAVE)*ALOGM2) + 17
      ELSE
          NGOAL = INT(-MXEXP2)
      ENDIF
      IF (MWK(START(MXY(8))+1) <= NGOAL) THEN
          IF (NUMTRY > 0) THEN
              NDGOAL = INT(REAL(NGOAL)/ALOGM2 + 1.0)
              DO J = 1, NDGOAL+1
                 IF (MWK(START(MRETRY)+J+1) /= MWK(START(MXY(8))+J+1)) GO TO 170
              ENDDO
              GO TO 180
          ENDIF
  170     IEXTRA = INT(REAL(NGOAL-MWK(START(MXY(8))+1))/ALOGM2 + 23.03/ALOGMB) + 1
          NDOLD = NDIG
          NDIG = MAX(NDIG+IEXTRA,NDIG+NGRD52+2)
          CALL FMEQU_R1(MXY(1),NDSAVE,NDIG)
          NUMTRY = NUMTRY + 1
          CALL FMEQU(MXY(8),MRETRY,NDOLD,NDIG)
          GO TO 120
      ENDIF

  180 MACMAX = NINT(NDSAVE*ALOGM2)
      MWK(START(MXY(8))+1) = MIN(MWK(START(MXY(8))+1),MACCA,MACMAX)
      IF (MWK(START(MA)) < 0 .AND. MWK(START(MXY(8))+2) /= MUNKNO .AND.  &
          MWK(START(MXY(8))+3) /= 0) THEN
          MWK(START(MXY(8))) = -MWK(START(MXY(8)))
      ENDIF
      CALL FMEXT2(MXY(8),MB,NDSAVE,MXSAVE,KASAVE,KOVUN)
      NUMBER_USED = NUMBER_USED_SAVE
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FMSI


!  Here are the routines which work with packed FM numbers.
!  All names are the same as unpacked versions with 'FM' replaced by 'FP'.

!  This packed format is not available when using the FM, IM, or ZM derived types.

      SUBROUTINE FPBESJ(IVAL,MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMBESJ(IVAL,MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBESJ

      SUBROUTINE FPBESY(IVAL,MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMBESY(IVAL,MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPBESY

      SUBROUTINE FPC(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMC(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPC

      SUBROUTINE FPCHI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCHI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCHI

      SUBROUTINE FPCI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMCI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPCI

      SUBROUTINE FPEI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMEI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEI

      SUBROUTINE FPEN(IVAL,MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTEGER :: IVAL
      INTENT (IN) :: MA,IVAL
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMEN(IVAL,MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPEN

      SUBROUTINE FPERF(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMERF(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPERF

      SUBROUTINE FPERFC(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMERFC(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPERFC

      SUBROUTINE FPLERC(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMLERC(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLERC

      SUBROUTINE FPLI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMLI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPLI

      SUBROUTINE FPS(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMS(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPS

      SUBROUTINE FPSHI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSHI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSHI

      SUBROUTINE FPSI(MA,MB)
      USE FMVALS
      IMPLICIT NONE
      INTEGER :: MA,MB
      INTENT (IN) :: MA
      INTENT (INOUT) :: MB
      TEMPV_CALL_STACK = TEMPV_CALL_STACK + 1
      CALL FMUNPK(MA,MPA)
      CALL FMSI(MPA,MPB)
      CALL FMPACK(MPB,MB)
      IF (TEMPV_CALL_STACK == 1) THEN
          IF (TEMPV(MB) == -1) TEMPV(MB) = -2
      ENDIF
      TEMPV_CALL_STACK = TEMPV_CALL_STACK - 1
      RETURN
      END SUBROUTINE FPSI
