C      ALGORITHM 737, COLLECTED ALGORITHMS FROM ACM.
C      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE,
C      VOL. 20, NO. 4, DECEMBER, 1994, P. 447-459.

This package consists of 5 files

1) D1I1MACH.F which contains the routines D1MACH and I1MACH from the 
   SLATEC package.

2) BASICOPS.F which contains the routines for interval inclusions for
   the elementary arithmetic operations.  These are ADD, CANCEL, IDIV,
   MULT, RNDOUT, SCLADD, SCLMLT and SUB.  Documentation for these 
   routines appears in their prologues.

3) UTILFUNS.F which contains basic utility functions for operations
   such as intersection of intervals, checking inclusion of one interval
   in another, and so on.  The routines are ICAP, IDISJ, IHULL, IILEI,
   IILTI, IINF, IMID, IMIG, INEG, INTABS, IRLEI, IRLTI, ISUP, IVL1, IVL2
   and IWID.
   
4) ELEMFUNS.F which contains routines for the elementary functions.
   The routines are IACOS, IACOT, IASIN, IATAN, ICOS, IEXP, IIPOWR, 
   ILOG, ISIN, ISINH, ISQRT, AND POWER.

5) MISCMACH.F which contains the routine ERRTST, used to print
   information about error conditions.  It also contains the routine
   SIMINI, in which global variables specifying interval inclusions for
   mathematical constants are set.  Some assumptions on the arithmetic 
   are given in the prologue to SIMINI.

C*** d1i1mach.f
Caveat receptor.  (Jack) dongarra@anl-mcs, (Eric Grosse) research!ehg
Compliments of netlib   Wed Mar 11 09:10:56 CST 1987
      DOUBLE PRECISION FUNCTION D1MACH(I)
C
C  DOUBLE-PRECISION MACHINE CONSTANTS
C
C  D1MACH( 1) = B**(EMIN-1), THE SMALLEST POSITIVE MAGNITUDE.
C
C  D1MACH( 2) = B**EMAX*(1 - B**(-T)), THE LARGEST MAGNITUDE.
C
C  D1MACH( 3) = B**(-T), THE SMALLEST RELATIVE SPACING.
C
C  D1MACH( 4) = B**(1-T), THE LARGEST RELATIVE SPACING.
C
C  D1MACH( 5) = LOG10(B)
C
C  TO ALTER THIS FUNCTION FOR A PARTICULAR ENVIRONMENT,
C  THE DESIRED SET OF DATA STATEMENTS SHOULD BE ACTIVATED BY
C  REMOVING THE C FROM COLUMN 1.
C  ON RARE MACHINES A STATIC STATEMENT MAY NEED TO BE ADDED.
C  (BUT PROBABLY MORE SYSTEMS PROHIBIT IT THAN REQUIRE IT.)
C
C  FOR IEEE-ARITHMETIC MACHINES (BINARY STANDARD), ONE OF THE FIRST
C  TWO SETS OF CONSTANTS BELOW SHOULD BE APPROPRIATE.
C
C  WHERE POSSIBLE, OCTAL OR HEXADECIMAL CONSTANTS HAVE BEEN USED
C  TO SPECIFY THE CONSTANTS EXACTLY, WHICH HAS IN SOME CASES
C  REQUIRED THE USE OF EQUIVALENT INTEGER ARRAYS.
C
      INTEGER SMALL(4)
      INTEGER LARGE(4)
      INTEGER RIGHT(4)
      INTEGER DIVER(4)
      INTEGER LOG10(4)
C
      DOUBLE PRECISION DMACH(5)
C
      EQUIVALENCE (DMACH(1),SMALL(1))
      EQUIVALENCE (DMACH(2),LARGE(1))
      EQUIVALENCE (DMACH(3),RIGHT(1))
      EQUIVALENCE (DMACH(4),DIVER(1))
      EQUIVALENCE (DMACH(5),LOG10(1))
C
C     MACHINE CONSTANTS FOR IEEE ARITHMETIC MACHINES, SUCH AS THE AT&T
C     3B SERIES AND MOTOROLA 68000 BASED MACHINES (E.G. SUN 3 AND AT&T
C     PC 7300), IN WHICH THE MOST SIGNIFICANT BYTE IS STORED FIRST.
C
C      DATA SMALL(1),SMALL(2) /    1048576,          0 /
C      DATA LARGE(1),LARGE(2) / 2146435071,         -1 /
C      DATA RIGHT(1),RIGHT(2) / 1017118720,          0 /
C      DATA DIVER(1),DIVER(2) / 1018167296,          0 /
C      DATA LOG10(1),LOG10(2) / 1070810131, 1352628735 /
C
C     MACHINE CONSTANTS FOR IEEE ARITHMETIC MACHINES AND 8087-BASED
C     MICROS, SUCH AS THE IBM PC AND AT&T 6300, IN WHICH THE LEAST
C     SIGNIFICANT BYTE IS STORED FIRST.
C
       DATA SMALL(1),SMALL(2) /          0,    1048576 /
       DATA LARGE(1),LARGE(2) /         -1, 2146435071 /
       DATA RIGHT(1),RIGHT(2) /          0, 1017118720 /
       DATA DIVER(1),DIVER(2) /          0, 1018167296 /
       DATA LOG10(1),LOG10(2) / 1352628735, 1070810131 /
C
C     MACHINE CONSTANTS FOR AMDAHL MACHINES.
C
C      DATA SMALL(1),SMALL(2) /    1048576,          0 /
C      DATA LARGE(1),LARGE(2) / 2147483647,         -1 /
C      DATA RIGHT(1),RIGHT(2) /  856686592,          0 /
C      DATA DIVER(1),DIVER(2) /  873463808,          0 /
C      DATA LOG10(1),LOG10(2) / 1091781651, 1352628735 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM.
C
C      DATA SMALL(1) / ZC00800000 /
C      DATA SMALL(2) / Z000000000 /
C
C      DATA LARGE(1) / ZDFFFFFFFF /
C      DATA LARGE(2) / ZFFFFFFFFF /
C
C      DATA RIGHT(1) / ZCC5800000 /
C      DATA RIGHT(2) / Z000000000 /
C
C      DATA DIVER(1) / ZCC6800000 /
C      DATA DIVER(2) / Z000000000 /
C
C      DATA LOG10(1) / ZD00E730E7 /
C      DATA LOG10(2) / ZC77800DC0 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 5700 SYSTEM.
C
C      DATA SMALL(1) / O1771000000000000 /
C      DATA SMALL(2) / O0000000000000000 /
C
C      DATA LARGE(1) / O0777777777777777 /
C      DATA LARGE(2) / O0007777777777777 /
C
C      DATA RIGHT(1) / O1461000000000000 /
C      DATA RIGHT(2) / O0000000000000000 /
C
C      DATA DIVER(1) / O1451000000000000 /
C      DATA DIVER(2) / O0000000000000000 /
C
C      DATA LOG10(1) / O1157163034761674 /
C      DATA LOG10(2) / O0006677466732724 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 6700/7700 SYSTEMS.
C
C      DATA SMALL(1) / O1771000000000000 /
C      DATA SMALL(2) / O7770000000000000 /
C
C      DATA LARGE(1) / O0777777777777777 /
C      DATA LARGE(2) / O7777777777777777 /
C
C      DATA RIGHT(1) / O1461000000000000 /
C      DATA RIGHT(2) / O0000000000000000 /
C
C      DATA DIVER(1) / O1451000000000000 /
C      DATA DIVER(2) / O0000000000000000 /
C
C      DATA LOG10(1) / O1157163034761674 /
C      DATA LOG10(2) / O0006677466732724 /
C
C     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES.
C
C      DATA SMALL(1) / 00604000000000000000B /
C      DATA SMALL(2) / 00000000000000000000B /
C
C      DATA LARGE(1) / 37767777777777777777B /
C      DATA LARGE(2) / 37167777777777777777B /
C
C      DATA RIGHT(1) / 15604000000000000000B /
C      DATA RIGHT(2) / 15000000000000000000B /
C
C      DATA DIVER(1) / 15614000000000000000B /
C      DATA DIVER(2) / 15010000000000000000B /
C
C      DATA LOG10(1) / 17164642023241175717B /
C      DATA LOG10(2) / 16367571421742254654B /
C
C     MACHINE CONSTANTS FOR CONVEX C-1
C
C      DATA SMALL(1),SMALL(2) / '00100000'X, '00000000'X /
C      DATA LARGE(1),LARGE(2) / '7FFFFFFF'X, 'FFFFFFFF'X /
C      DATA RIGHT(1),RIGHT(2) / '3CC00000'X, '00000000'X /
C      DATA DIVER(1),DIVER(2) / '3CD00000'X, '00000000'X /
C      DATA LOG10(1),LOG10(2) / '3FF34413'X, '509F79FF'X /
C
C     MACHINE CONSTANTS FOR THE CRAY 1, XMP, 2, AND 3.
C
C      DATA SMALL(1) / 201354000000000000000B /
C      DATA SMALL(2) / 000000000000000000000B /
C
C      DATA LARGE(1) / 577767777777777777777B /
C      DATA LARGE(2) / 000007777777777777776B /
C
C      DATA RIGHT(1) / 376434000000000000000B /
C      DATA RIGHT(2) / 000000000000000000000B /
C
C      DATA DIVER(1) / 376444000000000000000B /
C      DATA DIVER(2) / 000000000000000000000B /
C
C      DATA LOG10(1) / 377774642023241175717B /
C      DATA LOG10(2) / 000007571421742254654B /
C
C     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200
C
C     NOTE - IT MAY BE APPROPRIATE TO INCLUDE THE FOLLOWING LINE -
C     STATIC DMACH(5)
C
C      DATA SMALL/20K,3*0/,LARGE/77777K,3*177777K/
C      DATA RIGHT/31420K,3*0/,DIVER/32020K,3*0/
C      DATA LOG10/40423K,42023K,50237K,74776K/
C
C     MACHINE CONSTANTS FOR THE HARRIS SLASH 6 AND SLASH 7
C
C      DATA SMALL(1),SMALL(2) / '20000000, '00000201 /
C      DATA LARGE(1),LARGE(2) / '37777777, '37777577 /
C      DATA RIGHT(1),RIGHT(2) / '20000000, '00000333 /
C      DATA DIVER(1),DIVER(2) / '20000000, '00000334 /
C      DATA LOG10(1),LOG10(2) / '23210115, '10237777 /
C
C     MACHINE CONSTANTS FOR THE HONEYWELL DPS 8/70 SERIES.
C
C      DATA SMALL(1),SMALL(2) / O402400000000, O000000000000 /
C      DATA LARGE(1),LARGE(2) / O376777777777, O777777777777 /
C      DATA RIGHT(1),RIGHT(2) / O604400000000, O000000000000 /
C      DATA DIVER(1),DIVER(2) / O606400000000, O000000000000 /
C      DATA LOG10(1),LOG10(2) / O776464202324, O117571775714 /
C
C     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES,
C     THE XEROX SIGMA 5/7/9 AND THE SEL SYSTEMS 85/86.
C
C      DATA SMALL(1),SMALL(2) / Z00100000, Z00000000 /
C      DATA LARGE(1),LARGE(2) / Z7FFFFFFF, ZFFFFFFFF /
C      DATA RIGHT(1),RIGHT(2) / Z33100000, Z00000000 /
C      DATA DIVER(1),DIVER(2) / Z34100000, Z00000000 /
C      DATA LOG10(1),LOG10(2) / Z41134413, Z509F79FF /
C
C     MACHINE CONSTANTS FOR THE INTERDATA 8/32
C     WITH THE UNIX SYSTEM FORTRAN 77 COMPILER.
C
C     FOR THE INTERDATA FORTRAN VII COMPILER REPLACE
C     THE Z'S SPECIFYING HEX CONSTANTS WITH Y'S.
C
C      DATA SMALL(1),SMALL(2) / Z'00100000', Z'00000000' /
C      DATA LARGE(1),LARGE(2) / Z'7EFFFFFF', Z'FFFFFFFF' /
C      DATA RIGHT(1),RIGHT(2) / Z'33100000', Z'00000000' /
C      DATA DIVER(1),DIVER(2) / Z'34100000', Z'00000000' /
C      DATA LOG10(1),LOG10(2) / Z'41134413', Z'509F79FF' /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KA PROCESSOR).
C
C      DATA SMALL(1),SMALL(2) / "033400000000, "000000000000 /
C      DATA LARGE(1),LARGE(2) / "377777777777, "344777777777 /
C      DATA RIGHT(1),RIGHT(2) / "113400000000, "000000000000 /
C      DATA DIVER(1),DIVER(2) / "114400000000, "000000000000 /
C      DATA LOG10(1),LOG10(2) / "177464202324, "144117571776 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR).
C
C      DATA SMALL(1),SMALL(2) / "000400000000, "000000000000 /
C      DATA LARGE(1),LARGE(2) / "377777777777, "377777777777 /
C      DATA RIGHT(1),RIGHT(2) / "103400000000, "000000000000 /
C      DATA DIVER(1),DIVER(2) / "104400000000, "000000000000 /
C      DATA LOG10(1),LOG10(2) / "177464202324, "047674776746 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRANS SUPPORTING
C     32-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL).
C
C      DATA SMALL(1),SMALL(2) /    8388608,           0 /
C      DATA LARGE(1),LARGE(2) / 2147483647,          -1 /
C      DATA RIGHT(1),RIGHT(2) /  612368384,           0 /
C      DATA DIVER(1),DIVER(2) /  620756992,           0 /
C      DATA LOG10(1),LOG10(2) / 1067065498, -2063872008 /
C
C      DATA SMALL(1),SMALL(2) / O00040000000, O00000000000 /
C      DATA LARGE(1),LARGE(2) / O17777777777, O37777777777 /
C      DATA RIGHT(1),RIGHT(2) / O04440000000, O00000000000 /
C      DATA DIVER(1),DIVER(2) / O04500000000, O00000000000 /
C      DATA LOG10(1),LOG10(2) / O07746420232, O20476747770 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRANS SUPPORTING
C     16-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL).
C
C      DATA SMALL(1),SMALL(2) /    128,      0 /
C      DATA SMALL(3),SMALL(4) /      0,      0 /
C
C      DATA LARGE(1),LARGE(2) /  32767,     -1 /
C      DATA LARGE(3),LARGE(4) /     -1,     -1 /
C
C      DATA RIGHT(1),RIGHT(2) /   9344,      0 /
C      DATA RIGHT(3),RIGHT(4) /      0,      0 /
C
C      DATA DIVER(1),DIVER(2) /   9472,      0 /
C      DATA DIVER(3),DIVER(4) /      0,      0 /
C
C      DATA LOG10(1),LOG10(2) /  16282,   8346 /
C      DATA LOG10(3),LOG10(4) / -31493, -12296 /
C
C      DATA SMALL(1),SMALL(2) / O000200, O000000 /
C      DATA SMALL(3),SMALL(4) / O000000, O000000 /
C
C      DATA LARGE(1),LARGE(2) / O077777, O177777 /
C      DATA LARGE(3),LARGE(4) / O177777, O177777 /
C
C      DATA RIGHT(1),RIGHT(2) / O022200, O000000 /
C      DATA RIGHT(3),RIGHT(4) / O000000, O000000 /
C
C      DATA DIVER(1),DIVER(2) / O022400, O000000 /
C      DATA DIVER(3),DIVER(4) / O000000, O000000 /
C
C      DATA LOG10(1),LOG10(2) / O037632, O020232 /
C      DATA LOG10(3),LOG10(4) / O102373, O147770 /
C
C     MACHINE CONSTANTS FOR THE PRIME 50 SERIES SYSTEMS
C     WTIH 32-BIT INTEGERS AND 64V MODE INSTRUCTIONS,
C     SUPPLIED BY IGOR BRAY.
C
C      DATA SMALL(1),SMALL(2) / :10000000000, :00000100001 /
C      DATA LARGE(1),LARGE(2) / :17777777777, :37777677775 /
C      DATA RIGHT(1),RIGHT(2) / :10000000000, :00000000122 /
C      DATA DIVER(1),DIVER(2) / :10000000000, :00000000123 /
C      DATA LOG10(1),LOG10(2) / :11504046501, :07674600177 /
C
C     MACHINE CONSTANTS FOR THE SEQUENT BALANCE 8000
C
C      DATA SMALL(1),SMALL(2) / $00000000,  $00100000 /
C      DATA LARGE(1),LARGE(2) / $FFFFFFFF,  $7FEFFFFF /
C      DATA RIGHT(1),RIGHT(2) / $00000000,  $3CA00000 /
C      DATA DIVER(1),DIVER(2) / $00000000,  $3CB00000 /
C      DATA LOG10(1),LOG10(2) / $509F79FF,  $3FD34413 /
C
C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES.
C
C      DATA SMALL(1),SMALL(2) / O000040000000, O000000000000 /
C      DATA LARGE(1),LARGE(2) / O377777777777, O777777777777 /
C      DATA RIGHT(1),RIGHT(2) / O170540000000, O000000000000 /
C      DATA DIVER(1),DIVER(2) / O170640000000, O000000000000 /
C      DATA LOG10(1),LOG10(2) / O177746420232, O411757177572 /
C
C     MACHINE CONSTANTS FOR THE VAX UNIX F77 COMPILER
C
C      DATA SMALL(1),SMALL(2) /        128,           0 /
C      DATA LARGE(1),LARGE(2) /     -32769,          -1 /
C      DATA RIGHT(1),RIGHT(2) /       9344,           0 /
C      DATA DIVER(1),DIVER(2) /       9472,           0 /
C      DATA LOG10(1),LOG10(2) /  546979738,  -805796613 /
C
C     MACHINE CONSTANTS FOR THE VAX-11 WITH
C     FORTRAN IV-PLUS COMPILER
C
C      DATA SMALL(1),SMALL(2) / Z00000080, Z00000000 /
C      DATA LARGE(1),LARGE(2) / ZFFFF7FFF, ZFFFFFFFF /
C      DATA RIGHT(1),RIGHT(2) / Z00002480, Z00000000 /
C      DATA DIVER(1),DIVER(2) / Z00002500, Z00000000 /
C      DATA LOG10(1),LOG10(2) / Z209A3F9A, ZCFF884FB /
C
C     MACHINE CONSTANTS FOR VAX/VMS VERSION 2.2
C
C      DATA SMALL(1),SMALL(2) /       '80'X,        '0'X /
C      DATA LARGE(1),LARGE(2) / 'FFFF7FFF'X, 'FFFFFFFF'X /
C      DATA RIGHT(1),RIGHT(2) /     '2480'X,        '0'X /
C      DATA DIVER(1),DIVER(2) /     '2500'X,        '0'X /
C      DATA LOG10(1),LOG10(2) / '209A3F9A'X, 'CFF884FB'X /
C
      IF (I .LT. 1  .OR.  I .GT. 5) GOTO 999
      D1MACH = DMACH(I)
      RETURN
  999 WRITE(I1MACH(2),1999) I
 1999 FORMAT(' D1MACH - I OUT OF BOUNDS',I10)
      STOP
      END
C***********************************************************************
C***********************************************************************
      INTEGER FUNCTION I1MACH(I)
C
C  I/O UNIT NUMBERS.
C
C    I1MACH( 1) = THE STANDARD INPUT UNIT.
C
C    I1MACH( 2) = THE STANDARD OUTPUT UNIT.
C
C    I1MACH( 3) = THE STANDARD PUNCH UNIT.
C
C    I1MACH( 4) = THE STANDARD ERROR MESSAGE UNIT.
C
C  WORDS.
C
C    I1MACH( 5) = THE NUMBER OF BITS PER INTEGER STORAGE UNIT.
C
C    I1MACH( 6) = THE NUMBER OF CHARACTERS PER INTEGER STORAGE UNIT.
C
C  INTEGERS.
C
C    ASSUME INTEGERS ARE REPRESENTED IN THE S-DIGIT, BASE-A FORM
C
C               SIGN ( X(S-1)*A**(S-1) + ... + X(1)*A + X(0) )
C
C               WHERE 0 .LE. X(I) .LT. A FOR I=0,...,S-1.
C
C    I1MACH( 7) = A, THE BASE.
C
C    I1MACH( 8) = S, THE NUMBER OF BASE-A DIGITS.
C
C    I1MACH( 9) = A**S - 1, THE LARGEST MAGNITUDE.
C
C  FLOATING-POINT NUMBERS.
C
C    ASSUME FLOATING-POINT NUMBERS ARE REPRESENTED IN THE T-DIGIT,
C    BASE-B FORM
C
C               SIGN (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
C
C               WHERE 0 .LE. X(I) .LT. B FOR I=1,...,T,
C               0 .LT. X(1), AND EMIN .LE. E .LE. EMAX.
C
C    I1MACH(10) = B, THE BASE.
C
C  SINGLE-PRECISION
C
C    I1MACH(11) = T, THE NUMBER OF BASE-B DIGITS.
C
C    I1MACH(12) = EMIN, THE SMALLEST EXPONENT E.
C
C    I1MACH(13) = EMAX, THE LARGEST EXPONENT E.
C
C  DOUBLE-PRECISION
C
C    I1MACH(14) = T, THE NUMBER OF BASE-B DIGITS.
C
C    I1MACH(15) = EMIN, THE SMALLEST EXPONENT E.
C
C    I1MACH(16) = EMAX, THE LARGEST EXPONENT E.
C
C  TO ALTER THIS FUNCTION FOR A PARTICULAR ENVIRONMENT,
C  THE DESIRED SET OF DATA STATEMENTS SHOULD BE ACTIVATED BY
C  REMOVING THE C FROM COLUMN 1.  ALSO, THE VALUES OF
C  I1MACH(1) - I1MACH(4) SHOULD BE CHECKED FOR CONSISTENCY
C  WITH THE LOCAL OPERATING SYSTEM.  FOR FORTRAN 77, YOU MAY WISH
C  TO ADJUST THE DATA STATEMENT SO IMACH(6) IS SET TO 1, AND
C  THEN TO COMMENT OUT THE EXECUTABLE TEST ON I .EQ. 6 BELOW.
C  ON RARE MACHINES A STATIC STATEMENT MAY NEED TO BE ADDED.
C  (BUT PROBABLY MORE SYSTEMS PROHIBIT IT THAN REQUIRE IT.)
C
C  FOR IEEE-ARITHMETIC MACHINES (BINARY STANDARD), THE FIRST
C  SET OF CONSTANTS BELOW SHOULD BE APPROPRIATE, EXCEPT PERHAPS
C  FOR IMACH(1) - IMACH(4).
C
      INTEGER IMACH(16),OUTPUT
C
      EQUIVALENCE (IMACH(4),OUTPUT)
C
C     MACHINE CONSTANTS FOR IEEE ARITHMETIC MACHINES, SUCH AS THE AT&T
C     3B SERIES, MOTOROLA 68000 BASED MACHINES (E.G. SUN 3 AND AT&T
C     PC 7300), AND 8087 BASED MICROS (E.G. IBM PC AND AT&T 6300).
C
       DATA IMACH( 1) /    5 /
       DATA IMACH( 2) /    6 /
       DATA IMACH( 3) /    7 /
       DATA IMACH( 4) /    6 /
       DATA IMACH( 5) /   32 /
       DATA IMACH( 6) /    4 /
       DATA IMACH( 7) /    2 /
       DATA IMACH( 8) /   31 /
       DATA IMACH( 9) / 2147483647 /
       DATA IMACH(10) /    2 /
       DATA IMACH(11) /   24 /
       DATA IMACH(12) / -125 /
       DATA IMACH(13) /  128 /
       DATA IMACH(14) /   53 /
       DATA IMACH(15) / -1021 /
       DATA IMACH(16) /  1024 /
C
C     MACHINE CONSTANTS FOR AMDAHL MACHINES.
C
C      DATA IMACH( 1) /   5 /
C      DATA IMACH( 2) /   6 /
C      DATA IMACH( 3) /   7 /
C      DATA IMACH( 4) /   6 /
C      DATA IMACH( 5) /  32 /
C      DATA IMACH( 6) /   4 /
C      DATA IMACH( 7) /   2 /
C      DATA IMACH( 8) /  31 /
C      DATA IMACH( 9) / 2147483647 /
C      DATA IMACH(10) /  16 /
C      DATA IMACH(11) /   6 /
C      DATA IMACH(12) / -64 /
C      DATA IMACH(13) /  63 /
C      DATA IMACH(14) /  14 /
C      DATA IMACH(15) / -64 /
C      DATA IMACH(16) /  63 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM.
C
C      DATA IMACH( 1) /    7 /
C      DATA IMACH( 2) /    2 /
C      DATA IMACH( 3) /    2 /
C      DATA IMACH( 4) /    2 /
C      DATA IMACH( 5) /   36 /
C      DATA IMACH( 6) /    4 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   33 /
C      DATA IMACH( 9) / Z1FFFFFFFF /
C      DATA IMACH(10) /    2 /
C      DATA IMACH(11) /   24 /
C      DATA IMACH(12) / -256 /
C      DATA IMACH(13) /  255 /
C      DATA IMACH(14) /   60 /
C      DATA IMACH(15) / -256 /
C      DATA IMACH(16) /  255 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 5700 SYSTEM.
C
C      DATA IMACH( 1) /   5 /
C      DATA IMACH( 2) /   6 /
C      DATA IMACH( 3) /   7 /
C      DATA IMACH( 4) /   6 /
C      DATA IMACH( 5) /  48 /
C      DATA IMACH( 6) /   6 /
C      DATA IMACH( 7) /   2 /
C      DATA IMACH( 8) /  39 /
C      DATA IMACH( 9) / O0007777777777777 /
C      DATA IMACH(10) /   8 /
C      DATA IMACH(11) /  13 /
C      DATA IMACH(12) / -50 /
C      DATA IMACH(13) /  76 /
C      DATA IMACH(14) /  26 /
C      DATA IMACH(15) / -50 /
C      DATA IMACH(16) /  76 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 6700/7700 SYSTEMS.
C
C      DATA IMACH( 1) /   5 /
C      DATA IMACH( 2) /   6 /
C      DATA IMACH( 3) /   7 /
C      DATA IMACH( 4) /   6 /
C      DATA IMACH( 5) /  48 /
C      DATA IMACH( 6) /   6 /
C      DATA IMACH( 7) /   2 /
C      DATA IMACH( 8) /  39 /
C      DATA IMACH( 9) / O0007777777777777 /
C      DATA IMACH(10) /   8 /
C      DATA IMACH(11) /  13 /
C      DATA IMACH(12) / -50 /
C      DATA IMACH(13) /  76 /
C      DATA IMACH(14) /  26 /
C      DATA IMACH(15) / -32754 /
C      DATA IMACH(16) /  32780 /
C
C     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES.
C
C      DATA IMACH( 1) /    5 /
C      DATA IMACH( 2) /    6 /
C      DATA IMACH( 3) /    7 /
C      DATA IMACH( 4) /    6 /
C      DATA IMACH( 5) /   60 /
C      DATA IMACH( 6) /   10 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   48 /
C      DATA IMACH( 9) / 00007777777777777777B /
C      DATA IMACH(10) /    2 /
C      DATA IMACH(11) /   48 /
C      DATA IMACH(12) / -974 /
C      DATA IMACH(13) / 1070 /
C      DATA IMACH(14) /   96 /
C      DATA IMACH(15) / -927 /
C      DATA IMACH(16) / 1070 /
C
C     MACHINE CONSTANTS FOR CONVEX C-1.
C
C      DATA IMACH( 1) /    5 /
C      DATA IMACH( 2) /    6 /
C      DATA IMACH( 3) /    7 /
C      DATA IMACH( 4) /    6 /
C      DATA IMACH( 5) /   32 /
C      DATA IMACH( 6) /    4 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   31 /
C      DATA IMACH( 9) / 2147483647 /
C      DATA IMACH(10) /    2 /
C      DATA IMACH(11) /   24 /
C      DATA IMACH(12) / -128 /
C      DATA IMACH(13) /  127 /
C      DATA IMACH(14) /   53 /
C      DATA IMACH(15) /-1024 /
C      DATA IMACH(16) / 1023 /
C
C     MACHINE CONSTANTS FOR THE CRAY 1, XMP, 2, AND 3.
C
C      DATA IMACH( 1) /     5 /
C      DATA IMACH( 2) /     6 /
C      DATA IMACH( 3) /   102 /
C      DATA IMACH( 4) /     6 /
C      DATA IMACH( 5) /    64 /
C      DATA IMACH( 6) /     8 /
C      DATA IMACH( 7) /     2 /
C      DATA IMACH( 8) /    63 /
C      DATA IMACH( 9) /  777777777777777777777B /
C      DATA IMACH(10) /     2 /
C      DATA IMACH(11) /    47 /
C      DATA IMACH(12) / -8189 /
C      DATA IMACH(13) /  8190 /
C      DATA IMACH(14) /    94 /
C      DATA IMACH(15) / -8099 /
C      DATA IMACH(16) /  8190 /
C
C     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200.
C
C      DATA IMACH( 1) /   11 /
C      DATA IMACH( 2) /   12 /
C      DATA IMACH( 3) /    8 /
C      DATA IMACH( 4) /   10 /
C      DATA IMACH( 5) /   16 /
C      DATA IMACH( 6) /    2 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   15 /
C      DATA IMACH( 9) /32767 /
C      DATA IMACH(10) /   16 /
C      DATA IMACH(11) /    6 /
C      DATA IMACH(12) /  -64 /
C      DATA IMACH(13) /   63 /
C      DATA IMACH(14) /   14 /
C      DATA IMACH(15) /  -64 /
C      DATA IMACH(16) /   63 /
C
C     MACHINE CONSTANTS FOR THE HARRIS SLASH 6 AND SLASH 7.
C
C      DATA IMACH( 1) /       5 /
C      DATA IMACH( 2) /       6 /
C      DATA IMACH( 3) /       0 /
C      DATA IMACH( 4) /       6 /
C      DATA IMACH( 5) /      24 /
C      DATA IMACH( 6) /       3 /
C      DATA IMACH( 7) /       2 /
C      DATA IMACH( 8) /      23 /
C      DATA IMACH( 9) / 8388607 /
C      DATA IMACH(10) /       2 /
C      DATA IMACH(11) /      23 /
C      DATA IMACH(12) /    -127 /
C      DATA IMACH(13) /     127 /
C      DATA IMACH(14) /      38 /
C      DATA IMACH(15) /    -127 /
C      DATA IMACH(16) /     127 /
C
C     MACHINE CONSTANTS FOR THE HONEYWELL DPS 8/70 SERIES.
C
C      DATA IMACH( 1) /    5 /
C      DATA IMACH( 2) /    6 /
C      DATA IMACH( 3) /   43 /
C      DATA IMACH( 4) /    6 /
C      DATA IMACH( 5) /   36 /
C      DATA IMACH( 6) /    4 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   35 /
C      DATA IMACH( 9) / O377777777777 /
C      DATA IMACH(10) /    2 /
C      DATA IMACH(11) /   27 /
C      DATA IMACH(12) / -127 /
C      DATA IMACH(13) /  127 /
C      DATA IMACH(14) /   63 /
C      DATA IMACH(15) / -127 /
C      DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES,
C     THE XEROX SIGMA 5/7/9 AND THE SEL SYSTEMS 85/86.
C
C      DATA IMACH( 1) /   5 /
C      DATA IMACH( 2) /   6 /
C      DATA IMACH( 3) /   7 /
C      DATA IMACH( 4) /   6 /
C      DATA IMACH( 5) /  32 /
C      DATA IMACH( 6) /   4 /
C      DATA IMACH( 7) /   2 /
C      DATA IMACH( 8) /  31 /
C      DATA IMACH( 9) / Z7FFFFFFF /
C      DATA IMACH(10) /  16 /
C      DATA IMACH(11) /   6 /
C      DATA IMACH(12) / -64 /
C      DATA IMACH(13) /  63 /
C      DATA IMACH(14) /  14 /
C      DATA IMACH(15) / -64 /
C      DATA IMACH(16) /  63 /
C
C     MACHINE CONSTANTS FOR THE INTERDATA 8/32
C     WITH THE UNIX SYSTEM FORTRAN 77 COMPILER.
C
C     FOR THE INTERDATA FORTRAN VII COMPILER REPLACE
C     THE Z'S SPECIFYING HEX CONSTANTS WITH Y'S.
C
C      DATA IMACH( 1) /   5 /
C      DATA IMACH( 2) /   6 /
C      DATA IMACH( 3) /   6 /
C      DATA IMACH( 4) /   6 /
C      DATA IMACH( 5) /  32 /
C      DATA IMACH( 6) /   4 /
C      DATA IMACH( 7) /   2 /
C      DATA IMACH( 8) /  31 /
C      DATA IMACH( 9) / Z'7FFFFFFF' /
C      DATA IMACH(10) /  16 /
C      DATA IMACH(11) /   6 /
C      DATA IMACH(12) / -64 /
C      DATA IMACH(13) /  62 /
C      DATA IMACH(14) /  14 /
C      DATA IMACH(15) / -64 /
C      DATA IMACH(16) /  62 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KA PROCESSOR).
C
C      DATA IMACH( 1) /    5 /
C      DATA IMACH( 2) /    6 /
C      DATA IMACH( 3) /    7 /
C      DATA IMACH( 4) /    6 /
C      DATA IMACH( 5) /   36 /
C      DATA IMACH( 6) /    5 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   35 /
C      DATA IMACH( 9) / "377777777777 /
C      DATA IMACH(10) /    2 /
C      DATA IMACH(11) /   27 /
C      DATA IMACH(12) / -128 /
C      DATA IMACH(13) /  127 /
C      DATA IMACH(14) /   54 /
C      DATA IMACH(15) / -101 /
C      DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR).
C
C      DATA IMACH( 1) /    5 /
C      DATA IMACH( 2) /    6 /
C      DATA IMACH( 3) /    7 /
C      DATA IMACH( 4) /    6 /
C      DATA IMACH( 5) /   36 /
C      DATA IMACH( 6) /    5 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   35 /
C      DATA IMACH( 9) / "377777777777 /
C      DATA IMACH(10) /    2 /
C      DATA IMACH(11) /   27 /
C      DATA IMACH(12) / -128 /
C      DATA IMACH(13) /  127 /
C      DATA IMACH(14) /   62 /
C      DATA IMACH(15) / -128 /
C      DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRANS SUPPORTING
C     32-BIT INTEGER ARITHMETIC.
C
C      DATA IMACH( 1) /    5 /
C      DATA IMACH( 2) /    6 /
C      DATA IMACH( 3) /    7 /
C      DATA IMACH( 4) /    6 /
C      DATA IMACH( 5) /   32 /
C      DATA IMACH( 6) /    4 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   31 /
C      DATA IMACH( 9) / 2147483647 /
C      DATA IMACH(10) /    2 /
C      DATA IMACH(11) /   24 /
C      DATA IMACH(12) / -127 /
C      DATA IMACH(13) /  127 /
C      DATA IMACH(14) /   56 /
C      DATA IMACH(15) / -127 /
C      DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRANS SUPPORTING
C     16-BIT INTEGER ARITHMETIC.
C
C      DATA IMACH( 1) /    5 /
C      DATA IMACH( 2) /    6 /
C      DATA IMACH( 3) /    7 /
C      DATA IMACH( 4) /    6 /
C      DATA IMACH( 5) /   16 /
C      DATA IMACH( 6) /    2 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   15 /
C      DATA IMACH( 9) / 32767 /
C      DATA IMACH(10) /    2 /
C      DATA IMACH(11) /   24 /
C      DATA IMACH(12) / -127 /
C      DATA IMACH(13) /  127 /
C      DATA IMACH(14) /   56 /
C      DATA IMACH(15) / -127 /
C      DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR THE PRIME 50 SERIES SYSTEMS
C     WTIH 32-BIT INTEGERS AND 64V MODE INSTRUCTIONS,
C     SUPPLIED BY IGOR BRAY.
C
C      DATA IMACH( 1) /            1 /
C      DATA IMACH( 2) /            1 /
C      DATA IMACH( 3) /            2 /
C      DATA IMACH( 4) /            1 /
C      DATA IMACH( 5) /           32 /
C      DATA IMACH( 6) /            4 /
C      DATA IMACH( 7) /            2 /
C      DATA IMACH( 8) /           31 /
C      DATA IMACH( 9) / :17777777777 /
C      DATA IMACH(10) /            2 /
C      DATA IMACH(11) /           23 /
C      DATA IMACH(12) /         -127 /
C      DATA IMACH(13) /         +127 /
C      DATA IMACH(14) /           47 /
C      DATA IMACH(15) /       -32895 /
C      DATA IMACH(16) /       +32637 /
C
C     MACHINE CONSTANTS FOR THE SEQUENT BALANCE 8000.
C
C      DATA IMACH( 1) /     0 /
C      DATA IMACH( 2) /     0 /
C      DATA IMACH( 3) /     7 /
C      DATA IMACH( 4) /     0 /
C      DATA IMACH( 5) /    32 /
C      DATA IMACH( 6) /     1 /
C      DATA IMACH( 7) /     2 /
C      DATA IMACH( 8) /    31 /
C      DATA IMACH( 9) /  2147483647 /
C      DATA IMACH(10) /     2 /
C      DATA IMACH(11) /    24 /
C      DATA IMACH(12) /  -125 /
C      DATA IMACH(13) /   128 /
C      DATA IMACH(14) /    53 /
C      DATA IMACH(15) / -1021 /
C      DATA IMACH(16) /  1024 /
C
C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES.
C
C     NOTE THAT THE PUNCH UNIT, I1MACH(3), HAS BEEN SET TO 7
C     WHICH IS APPROPRIATE FOR THE UNIVAC-FOR SYSTEM.
C     IF YOU HAVE THE UNIVAC-FTN SYSTEM, SET IT TO 1.
C
C      DATA IMACH( 1) /    5 /
C      DATA IMACH( 2) /    6 /
C      DATA IMACH( 3) /    7 /
C      DATA IMACH( 4) /    6 /
C      DATA IMACH( 5) /   36 /
C      DATA IMACH( 6) /    6 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   35 /
C      DATA IMACH( 9) / O377777777777 /
C      DATA IMACH(10) /    2 /
C      DATA IMACH(11) /   27 /
C      DATA IMACH(12) / -128 /
C      DATA IMACH(13) /  127 /
C      DATA IMACH(14) /   60 /
C      DATA IMACH(15) /-1024 /
C      DATA IMACH(16) / 1023 /
C
C     MACHINE CONSTANTS FOR VAX.
C
C      DATA IMACH( 1) /    5 /
C      DATA IMACH( 2) /    6 /
C      DATA IMACH( 3) /    7 /
C      DATA IMACH( 4) /    6 /
C      DATA IMACH( 5) /   32 /
C      DATA IMACH( 6) /    4 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   31 /
C      DATA IMACH( 9) / 2147483647 /
C      DATA IMACH(10) /    2 /
C      DATA IMACH(11) /   24 /
C      DATA IMACH(12) / -127 /
C      DATA IMACH(13) /  127 /
C      DATA IMACH(14) /   56 /
C      DATA IMACH(15) / -127 /
C      DATA IMACH(16) /  127 /
      IF (I .LT. 1  .OR.  I .GT. 16) GO TO 999
      I1MACH=IMACH(I)
C/6S
C/7S
      IF(I.EQ.6) I1MACH=1
C/
      RETURN
  999 WRITE(OUTPUT,1999) I
 1999 FORMAT(' I1MACH - I OUT OF BOUNDS',I10)
      STOP
      END

C*** basicops.f
      SUBROUTINE ADD (A,B,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Manuel Novoa III
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   September 29, 1987
C
C Part of the generalized bisection package
C (interval arithmetic subpackage).
C
C***********************************************************************
C
C Called by --
C
C  any routine requiring interval addition.
C
C***********************************************************************
C
C Function --
C
C  This routine adds the interval A and the interval B.  It
C  simulates directed roundings with the routine RNDOUT;  the interval
C  result should contain the interval which would have been obtained
C  with exact interval arithmetic.  However, in general it will not
C  be the smallest possible machine-representable such containing
C  interval.  See the documentation in subroutine RNDOUT for more
C  detailed information.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), B(2), RESULT(2)
C
C***********************************************************************
C
C Argument descriptions -- (INPUT  = set on entry and not alterable)
C                          (OUTPUT = to be set by the routine)
C                          (I/O    = set on entry but alterable)
C
C  A        is the first operand to the addition.
C           (INPUT)
C
C  B        is the second operand to the addition.
C           (INPUT)
C
C  RESULT   is the interval-arithmetic sum of A and B.
C           (OUTPUT)
C
C***********************************************************************
C
C Internal variable declarations --
C
      LOGICAL RNDDWN, RNDUP
C
C***********************************************************************
C
C Internal variable descriptions --
C
C RNDDWN    is set to .TRUE. if RNDOUT has to round down, and is set
C           to .FALSE. otherwise.
C
C RNDUP     is set to .TRUE. if RNDOUT has to round up, and is set
C           to .FALSE. otherwise.
C
C***********************************************************************
C
C Common block declarations -- none
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines -- none
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C RNDOUT
C
C***********************************************************************
C
C User-supplied functions and subroutines -- none
C
C***********************************************************************
C
C I/O functions --  none
C
C***********************************************************************
C
C Internal constant declarations -- none
C
C***********************************************************************
C
C Beginning of executable statements --
C
      RNDDWN = (A(1).NE.0D0).AND.(B(1).NE.0D0)
      RNDUP = (A(2).NE.0D0).AND.(B(2).NE.0D0)
C
      RESULT(1) = A(1) + B(1)
      RESULT(2) = A(2) + B(2)
C
      CALL RNDOUT(RESULT,RNDDWN,RNDUP)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE CANCEL (A,B,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   Manuel Novoa III
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   March 13, 1990
C
C Part of the generalized bisection package
C (interval arithmetic subpackage).
C
C***********************************************************************
C
C Called by --
C
C  Any routine requiring an interval addend to be canceled (removed)
C  from a previously accumulated interval sum.
C
C***********************************************************************
C
C Function --
C
C  Given an interval B, and a previously accumulated interval sum A
C  for which B was an addend, this routine returns an interval which
C  contains, and is hopefully close to, the sum of the other addends
C  for A.  Directed roundings are simulated with the routine RNDOUT;
C  the interval result should contain the interval which would have
C  been obtained with exact interval arithmetic.  However, in general
C  it will not be the smallest possible machine-representable such
C  containing interval.  See the documentation in subroutine RNDOUT for
C  more detailed information.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), B(2), RESULT(2)
C
C***********************************************************************
C
C Argument descriptions -- (INPUT  = set on entry and not alterable)
C                          (OUTPUT = to be set by the routine)
C                          (I/O    = set on entry but alterable)
C
C  A        is the first operand to the subtraction.
C           (INPUT)
C
C  B        is the second operand to the subtraction
C           (INPUT)
C
C  RESULT   is the interval-arithmetic value of A - B.
C           (OUTPUT)
C
C***********************************************************************
C
C Internal variable declarations --
C
      LOGICAL RNDDWN, RNDUP
C
C***********************************************************************
C
C Internal variable descriptions --
C
C
C RNDDWN    is set to .TRUE. if RNDOUT has to round down, and is set
C           to .FALSE. otherwise.
C
C RNDUP     is set to .TRUE. if RNDOUT has to round up, and is set
C           to .FALSE. otherwise.
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C RNDOUT
C
C***********************************************************************
C
C Beginning of executable statements --
C
      RNDDWN = (B(1).NE.0D0)
      RNDUP = (B(2).NE.0D0)
C
      RESULT(1) = A(1) - B(1)
      RESULT(2) = A(2) - B(2)
C
      CALL RNDOUT(RESULT,RNDDWN,RNDUP)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE IDIV (AA,BB,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   May 21, 1992
C
C Part of the interval arithmetic elementary function package.
C
C***********************************************************************
C
C Function --
C
C  This routine performs interval division.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION AA(2), BB(2), RESULT(2)
C
C***********************************************************************
C
C Internal variable declarations --

      DOUBLE PRECISION C(2)
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  ERRTST, MULT, RNDOUT
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 3
      IERR = 0
C
C  Do usual interval division if zero is not in the denominator --
C
      IF (BB(1).GT.ZERO(2)) THEN
         C(1) = ONE(1)/BB(2)
         C(2) = ONE(2)/BB(1)
         CALL RNDOUT(C,.TRUE.,.TRUE.)
         CALL MULT(AA,C,RESULT)
      ELSE IF (BB(2).LT.ZERO(1)) THEN
         C(1) = ONE(2)/BB(2)
         C(2) = ONE(1)/BB(1)
         CALL RNDOUT(C,.TRUE.,.TRUE.)
         CALL MULT(AA,C,RESULT)
      ELSE
         IERR = 6
         CALL ERRTST(BB)
         RESULT(1) = NEGINF
         RESULT(2) = POSINF
      END IF
C
      RETURN
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE MULT (A, B, RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C         and
C
C   Manuel Novoa III
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   November 17, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  MULT multiplies the interval A and the interval B.  It
C  puts the result into output parameter RESULT.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), B(2), RESULT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TEMP, A1, B1
      DOUBLE PRECISION AA(2), BB(2)
C
C***********************************************************************
C
C Internal Constant Declarations --
C
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO = 0.0D0)
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Pictures for cases.
C
      IF ((ZERO .LE. A(1)) .AND. (ZERO .LE. B(1))) THEN
C  Case 1   ---------------- 0 -----------------
C        A:                    [==========]
C        B:                         [===========]
          RESULT(1) = A(1) * B(1)
          RESULT(2) = A(2) * B(2)
      ELSE IF ((A(1) .LT. ZERO) .AND. (ZERO .LT. A(2))
     1                          .AND. (ZERO .LE. B(1))) THEN
C  Case 2   ---------------- 0 -----------------
C        A:            [==================]
C        B:                         [===========]
          RESULT(1) = A(1) * B(2)
          RESULT(2) = A(2) * B(2)
      ELSE IF ((A(2) .LE. ZERO) .AND. (ZERO .LE. B(1))) THEN
C  Case 3   ---------------- 0 -----------------
C        A:    [==========]
C        B:                         [===========]
          B1 = B(1)
          RESULT(1) = A(1) * B(2)
          RESULT(2) = A(2) * B1
      ELSE IF ((ZERO .LE. A(1)) .AND. (B(1) .LT. ZERO)
     1                          .AND. (ZERO .LT. B(2))) THEN
C  Case 4   ---------------- 0 -----------------
C        A:                     [==========]
C        B:               [===========]
          RESULT(1) = A(2) * B(1)
          RESULT(2) = A(2) * B(2)
      ELSE IF ((A(2) .LE. ZERO) .AND. (B(1) .LT. ZERO)
     1                          .AND. (ZERO .LT. B(2))) THEN
C  Case 5   ---------------- 0 -----------------
C        A:    [==========]
C        B           [===========]
          A1 = A(1)
          B1 = B(1)
          RESULT(1) = A(1) * B(2)
          RESULT(2) = A1 * B1
      ELSE IF ((ZERO .LE. A(1)) .AND. (B(2) .LE. ZERO)) THEN
C  Case 6   ---------------- 0 -----------------
C        A:                    [==========]
C        B:  [===========]
          A1 = A(1)
          RESULT(1) = A(2) * B(1)
          RESULT(2) = A1 * B(2)
      ELSE IF ((A(1) .LT. ZERO) .AND. (ZERO .LT. A(2))
     1                          .AND. (B(2) .LE. ZERO)) THEN
C  Case 7   ---------------- 0 -----------------
C        A:              [==========]
C        B:  [===========]
          A1 = A(1)
          B1 = B(1)
          RESULT(1) = A(2) * B(1)
          RESULT(2) = A1 * B1
      ELSE IF ((A(2) .LE. ZERO) .AND. (B(2) .LE. ZERO)) THEN
C  Case 8   ---------------- 0 -----------------
C        A:    [==========]
C        B:   [===========]
          A1 = A(1)
          B1 = B(1)
          RESULT(1) = A(2) * B(2)
          RESULT(2) = A1 * B1
      ELSE
C  Case 9   ---------------- 0 -----------------
C        A:              [==========]
C        B:              [===========]
C  Must check two cases.
          AA(1) = A(1)
          AA(2) = A(2)
          BB(1) = B(1)
          BB(2) = B(2)
          RESULT(1) = AA(1) * BB(2)
          TEMP = AA(2) * BB(1)
          IF (TEMP .LT. RESULT(1)) THEN
              RESULT(1) = TEMP
          ELSE
          END IF
              RESULT(2) = AA(1) * BB(1)
          TEMP = AA(2) * BB(2)
          IF (TEMP .GT. RESULT(2)) THEN
              RESULT(2) = TEMP
          ELSE
          END IF
      END IF
C
      CALL RNDOUT(RESULT,.TRUE.,.TRUE.)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE RNDOUT (X,RNDDWN,RNDUP)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Manuel Novoa III
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   September 29, 1987
C
C   Modified August, 1991 and April, 1992 by Kaisheng Du and
C   R. Baker Kearfott to be more accurate near the underflow
C   threshold.
C
C Part of the generalized bisection package
C (interval arithmetic subpackage)
C
C***********************************************************************
C
C Function --
C
C  This routine is intended to simulate directed roundings in a
C  reasonably transportable way.  It is called for each elementary
C  operation involving intervals.  The endpoints of the result interval
C  are first computed with the machine's usual floating point
C  arithmetic.
C
C  If RNDDWN = .TRUE., then this routine decreases the left
C  endpoint of that approximate result by the absolute value of
C  that endpoint times a rigorous estimate for the maximum relative
C  error in an elementary operation.
C
C  If RNDUP = .TRUE., then this routine increases the right
C  endpoint of that approximate result by the absolute value of
C  that endpoint times a rigorous estimate for the maximum relative
C  error in an elementary operation.
C
C  For this routine to work properly, a machine-dependent parameter
C  must be installed in the routine SIMINI.  See the documentation in
C  that routine for details.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2)
      LOGICAL RNDDWN, RNDUP
C
C***********************************************************************
C
C Argument descriptions -- (INPUT  = set on entry and not alterable)
C                          (OUTPUT = to be set by the routine)
C                          (I/O    = set on entry but alterable)
C
C X         is the interval to be adjusted.
C           (I/O)
C
C RNDDWN    is set to .TRUE. if the left endpoint is to be adjusted, and
C           is set to .FALSE. otherwise.
C           (INPUT)
C
C RNDUP     is set to .TRUE. if the right endpoint is to be adjusted,
C           and is set to .FALSE. otherwise.
C           (INPUT)
C
C***********************************************************************
C
C Common block declarations --
C
      DOUBLE PRECISION MXULP, TTINY2, TOL0
      COMMON /MACH1/ MXULP, TTINY2, TOL0
C
C  This common block holds machine parameters which are set in
C  SIMINI and used here.
C
C  Variable descriptions
C
C  MXULP       (machine epsilon)
C                * (maximum error in ULP's of the floating pt. op's)
C
C  TTINY2      2 * (smallest representable positive machine number)
C                * (maximum error in ULP's of the floating pt. op's)
C
C  TOL0        TTINY2 / MXULP
C
      DOUBLE PRECISION TINY, TEST
      COMMON /MACH2/ TINY, TEST
C
C  See SIMINI for an explanation of the common block MACH2.
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IF (RNDDWN) THEN
         IF (X(1).GE.TEST) THEN
            X(1) = (1.D0 - MXULP ) * X(1)
         ELSE IF (X(1).LE.-TEST) THEN
            X(1) = (1D0 + MXULP ) * X(1)
         ELSE IF (X(1).LE.0.D0) THEN
            X(1) = -TEST
         ELSE
            X(1) = 0.D0
         END IF
      END IF
C
      IF (RNDUP) THEN
         IF (X(2).GE.TEST) THEN
            X(2) = (1.D0 + MXULP )* X(2)
         ELSE IF (X(2).LE.-TEST) THEN
            X(2) = (1.D0 - MXULP ) * X(2)
         ELSE IF(X(2).GE.0D0) THEN
            X(2) = TEST
         ELSE
            X(2) = 0.D0
         ENDIF
      END IF
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE SCLADD (R,A,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Manuel Novoa III
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   September 29, 1987
C
C Part of the generalized bisection package
C (interval arithmetic subpackage).
C
C***********************************************************************
C
C Called by --
C
C  Any routine requiring addition of a point value to an interval.
C
C***********************************************************************
C
C FUNCTION --
C
C  This routine adds the interval A to the point R.  It simulates
C  directed roundings with the routine RNDOUT;  the interval
C  result should contain the interval which would have been obtained
C  with exact interval arithmetic.  However, in general it will not
C  be the smallest possible machine-representable such containing
C  interval.  See the documentation in subroutine RNDOUT for more
C  detailed information.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION R, A(2), RESULT(2)
C
C***********************************************************************
C
C Argument descriptions -- (INPUT  = set on entry and not alterable)
C                          (OUTPUT = to be set by the routine)
C                          (I/O    = set on entry but alterable)
C
C  R        is the point to be added to the interval.
C           (INPUT)
C
C  A        is the interval to be added to the point.
C           (INPUT)
C
C  RESULT   is the interval-arithmetic sum of R and B.
C           (OUTPUT)
C
C***********************************************************************
C
C Internal variable declarations --
C
      LOGICAL RNDDWN, RNDUP
C
C***********************************************************************
C
C Internal variable descriptions --
C
C RNDDWN    is set to .TRUE. if RNDOUT has to round down, and is set
C           to .FALSE. otherwise.
C
C RNDUP     is set to .TRUE. if RNDOUT has to round up, and is set
C           to .FALSE. otherwise.
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  RNDOUT
C
C***********************************************************************
C
C Beginning of executable statements --
C
      RNDDWN = (R.NE.0D0).AND.(A(1).NE.0D0)
      RNDUP = (R.NE.0D0).AND.(A(2).NE.0D0)
C
      RESULT(1) = R + A(1)
      RESULT(2) = R + A(2)
C
      CALL RNDOUT(RESULT,RNDDWN,RNDUP)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE SCLMLT (R,A,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Manuel Novoa III
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   September 29, 1987
C
C Part of the generalized bisection package
C (interval arithmetic subpackage).
C
C Modified by Manuel Novoa III on March 13, 1990 to clean the code
C   slightly, and to remove the need for MAX and MIN.
C
C***********************************************************************
C
C Called by --
C
C  Any routine requiring multiplication of an interval and a point
C  value.
C
C***********************************************************************
C
C Function --
C
C  This routine multiplies the interval A and the point R.  It
C  simulates directed roundings with the routine RNDOUT;  the interval
C  result should contain the interval which would have been obtained
C  with exact interval arithmetic.  However, in general it will not
C  be the smallest possible machine-representable such containing
C  interval.  See the documentation in subroutine RNDOUT for more
C  detailed information.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION R, A(2), RESULT(2)
C
C***********************************************************************
C
C Argument descriptions -- (INPUT  = set on entry and not alterable)
C                          (OUTPUT = to be set by the routine)
C                          (I/O    = set on entry but alterable)
C
C  R        is the point to be multiplied to the interval.
C           (INPUT)
C
C  A        is the interval to be multiplied to the point.
C           (INPUT)
C
C  RESULT   is the interval-arithmetic product R * B.
C           (OUTPUT)
C
C***********************************************************************
C
C Internal variable declarations --
C
      LOGICAL RNDDWN, RNDUP
      DOUBLE PRECISION T1, T2
C
C***********************************************************************
C
C Internal variable descriptions --
C
C RNDDWN    is set to .TRUE. if RNDOUT is to round down, and is set
C           to .FALSE. otherwise.
C
C RNDUP     is set to .TRUE. if RNDOUT is to round up, and is set
C           to .FALSE. otherwise.
C
C T1 and T2 are temporary variables.
C
C***********************************************************************
C
C Common block declarations -- none
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --  none
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  RNDOUT
C
C***********************************************************************
C
C User-supplied functions and subroutines -- none
C
C***********************************************************************
C
C I/O functions --  none
C
C***********************************************************************
C
C Internal constant declarations -- none
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IF ((R.EQ.0D0).OR.((A(1).EQ.0D0).AND.(A(2).EQ.0D0))) THEN
         RESULT(1) = 0D0
         RESULT(2) = 0D0
         RETURN
      END IF
C
      T1 = A(1)
      T2 = A(2)
      RNDDWN = .TRUE.
      RNDUP = .TRUE.
C
      IF (T1.EQ.0D0) THEN
         IF (R.LT.0D0) THEN
            RESULT(1) = R * T2
            RESULT(2) = 0D0
            RNDUP = .FALSE.
         ELSE
            RESULT(1) = 0D0
            RESULT(2) = R * T2
            RNDDWN = .FALSE.
         END IF
      ELSE IF (T2.EQ.0D0) THEN
         IF (R.LT.0D0) THEN
            RESULT(1) = 0D0
            RESULT(2) = R * T1
            RNDDWN = .FALSE.
         ELSE
            RESULT(1) = R * T1
            RESULT(2) = 0D0
            RNDUP = .FALSE.
         END IF
      ELSE IF (R.GT.0D0) THEN
         RESULT(1) = R * T1
         RESULT(2) = R * T2
      ELSE
         RESULT(1) = R * T2
         RESULT(2) = R * T1
      END IF
C
      CALL RNDOUT(RESULT,RNDDWN,RNDUP)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE SUB (A,B,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Manuel Novoa III
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   September 29, 1987
C
C Part of the generalized bisection package
C (interval arithmetic subpackage).
C
C***********************************************************************
C
C Called by --
C
C  Any routine requiring interval subtraction.
C
C***********************************************************************
C
C Function --
C
C  This routine subtracts the interval B from the interval A.  It
C  simulates directed roundings with the routine RNDOUT;  the interval
C  result should contain the interval which would have been obtained
C  with exact interval arithmetic.  However, in general it will not
C  be the smallest possible machine-representable such containing
C  interval.  See the documentation in subroutine RNDOUT for more
C  detailed information.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), B(2), RESULT(2)
C
C***********************************************************************
C
C Argument descriptions -- (INPUT  = set on entry and not alterable)
C                          (OUTPUT = to be set by the routine)
C                          (I/O    = set on entry but alterable)
C
C  A        is the first operand to the subtraction.
C           (INPUT)
C
C  B        is the second operand to the subtraction
C           (INPUT)
C
C  RESULT   is the interval-arithmetic value of A - B.
C           (OUTPUT)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TA1, TA2, TB1, TB2
      LOGICAL RNDDWN, RNDUP
C
C***********************************************************************
C
C Internal variable descriptions --
C
C TA1, TA2, TB1, and TB2 are temporaries.
C
C RNDDWN    is set to .TRUE. if RNDOUT has to round down, and is set
C           to .FALSE. otherwise.
C
C RNDUP     is set to .TRUE. if RNDOUT has to round up, and is set
C           to .FALSE. otherwise.
C
C***********************************************************************
C
C Common block declarations -- none
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines -- none
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C RNDOUT
C
C***********************************************************************
C
C User-supplied functions and subroutines -- none
C
C***********************************************************************
C
C I/O functions --  none
C
C***********************************************************************
C
C Internal constant declarations -- none
C
C***********************************************************************
C
C Beginning of executable statements --
C
      TA1 = A(1)
      TA2 = A(2)
      TB1 = B(1)
      TB2 = B(2)
C
      RNDDWN = (TB2.NE.0D0)
      RNDUP = (TB1.NE.0D0)
C
      RESULT(1) = TA1 - TB2
      RESULT(2) = TA2 - TB1
C
      CALL RNDOUT(RESULT,RNDDWN,RNDUP)
C
      RETURN
      END

c*** utilfuns.f
      SUBROUTINE ICAP (A, B, RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  DICAP computes the intersection of the two intervals A and B, and
C  places  the result in RESULT.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), B(2), RESULT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
C
C***********************************************************************
C
C Common block declarations --
C
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C   MIN, MAX
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C   ERRTST
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION T(2)
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 13
      IERR = 0
C
      T(1) = MAX (A(1), B(1))
      T(2) = MIN (A(2), B(2))
      RESULT(1) = T(1)
      RESULT(2) = T(2)
      IF (RESULT(1).GT.RESULT(2)) THEN
         IERR=13
         CALL ERRTST(RESULT)
      END IF
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      LOGICAL FUNCTION IDISJ (A, B)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  This function returns .TRUE. if the intervals A and B are disjoint,
C  and .FALSE. otherwise.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), B(2)
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IDISJ = (A(2) .LT. B(1)) .OR. (B(2) .LT. A(1))
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE IHULL (A, B, RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IHULL returns the convex-hull of the interval A and the interval B
C  in RESULT.  If one of the intervals is empty (lower bound is greater
C  than upper bound), then just the upper interval is returned.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), B(2), RESULT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION T(2)
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IF ( A(1).GT.A(2) ) THEN
         IF (B(1).GT.B(2)) THEN
            T(1) = MAX(A(2),B(2))
            T(2) = MIN(A(1),B(2))
         ELSE
            T(1) = B(1)
            T(2) = B(2)
         END IF
      ELSE IF ( B(1).GT.B(2) ) THEN
         T(1) = A(1)
         T(2) = A(2)
      ELSE
         T(1) = MIN (A(1), B(1))
         T(2) = MAX (A(2), B(2))
         RESULT(1) = T(1)
         RESULT(2) = T(2)
      END IF
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      LOGICAL FUNCTION IILEI (A, B)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IILEI sets its value to .TRUE. if interval A is in the closure of
C  interval B.  The value of IILEI is .FALSE. otherwise.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), B(2)
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IILEI = (A(1) .GE. B(1)) .AND. (A(2) .LE. B(2))
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      LOGICAL FUNCTION IILTI (A, B)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IILE sets its value to .TRUE. if interval A is in the interior of
C  interval B.  The value of IILE is .FALSE. otherwise.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), B(2)
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IILTI = (A(1) .GT. B(1)) .AND. (A(2) .LT. B(2))
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      DOUBLE PRECISION FUNCTION IINF (A)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IINF returns the lower endpoint of the interval A.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2)
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IINF = A(1)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      DOUBLE PRECISION FUNCTION IMID (X)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IMID returns a floating point approximation to the midpoint
C  of the interval A, using available floating point arithmetic.  The
C  value returned by this routine can be considered to DEFINE the
C  midpoint.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2)
C
C***********************************************************************
C
C Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IMID = X(1) + (X(2) - X(1)) / TWO(1)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      DOUBLE PRECISION FUNCTION IMIG (A)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IMIG returns the mignitude of the interval A. Since ABS is not
C  assumed to give an exact result, the result is rounded down.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TMP(2)
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C  ABS, MIN
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  RNDOUT
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IF ( ((A(1).GT.0D0) .AND. (A(2).GT.0D0))
     * .OR.((A(1).LT.0D0) .AND. (A(2).LT.0D0)) ) THEN
         TMP(1) = ABS(A(2))
         CALL RNDOUT(TMP,.TRUE.,.FALSE.)
         TMP(2)=TMP(1)
         TMP(1) = ABS(A(1))
         CALL RNDOUT(TMP,.TRUE.,.FALSE.)
         IMIG = MIN (TMP(1), TMP(2))
      ELSE
         IMIG = 0D0
      END IF
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE INEG (A, RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  INEG performs interval unary negation.  The result is rounded out in
C  case the negatives of the endpoints are not representable.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), RESULT(2)
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  RNDOUT
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION T(2)
C
C***********************************************************************
C
C Beginning of executable statements --
C
      T(1) = A(1)
      T(2) = A(2)
      RESULT(1) = -T(2)
      RESULT(2) = -T(1)
      CALL RNDOUT (RESULT, .TRUE.,.TRUE.)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      DOUBLE PRECISION FUNCTION INTABS (A)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  INTABS returns the maximum absolute value of the interval A.
C  Since ABS is not assumed to give an exact result, the result is
C  rounded up.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TMP(2)
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C  ABS, MAX
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  RNDOUT
C
C***********************************************************************
C
C Beginning of executable statements --
C
      TMP(2) = ABS(A(1))
      CALL RNDOUT(TMP,.FALSE.,.TRUE.)
      TMP(1)=TMP(2)
      TMP(2) = ABS(A(2))
      CALL RNDOUT(TMP,.FALSE.,.TRUE.)
C
      INTABS = MAX (TMP(1), TMP(2))
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      LOGICAL FUNCTION IRLEI (A, B)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IRLEI sets its value to .TRUE. if double precision value A is in the
C  closure of the interval B. The value of IRLEI is set to .FALSE.
C  otherwise.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A, B(2)
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IRLEI = (A .GE. B(1)) .AND. (A .LE. B(2))
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      LOGICAL FUNCTION IRLTI (A, B)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IRLEI sets its value to .TRUE. if double precision value A is in the
C  interior of the interval B. The value of IRLEI is set to .FALSE.
C  otherwise.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A, B(2)
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IRLTI = (A .GT. B(1)) .AND. (A .LT. B(2))
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      DOUBLE PRECISION FUNCTION ISUP (A)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IINF returns the upper endpoint of the interval A.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2)
C
C***********************************************************************
C
C Beginning of executable statements --
C
      ISUP = A(2)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE IVL1 (R, RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IVL1 constructs an interval RESULT from the double precision variable
C  R.  This is done by using simulated directed roundings with RNDOUT.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION R, RESULT(2)
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  RNDOUT
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION T
C
C***********************************************************************
C
C Beginning of executable statements --
C
      T = R
      RESULT(1) = T
      RESULT(2) = T
      IF (T.NE.0D0) CALL RNDOUT (RESULT, .TRUE.,.TRUE.)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE IVL2 (R1, R2, RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C
c   Hong Jiang
c   Dept. of Math., Stat. and Computer Science
c   Marquette University
C   Milwaukee, WI 53233
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IVL2 constructs an interval RESULT, roughly equal to [R1,R2], from
C  the double precision variables R1 and R2.  This is done by using
C  simulated directed roundings with RNDOUT.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION R1, R2, RESULT(2)
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  RNDOUT
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION T(2)
      LOGICAL RNDUP, RNDDWN
C
C***********************************************************************
C
C Common block declarations --
C
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 15
      IERR = 0
C
      T(1) = R1
      T(2) = R2
      RESULT(1) = T(1)
      RESULT(2) = T(2)
C
      IF (RESULT(2).LT.RESULT(1)) THEN
         IERR = 1
         CALL ERRTST(RESULT)
      END IF
C
      RNDDWN = T(1).NE.0D0
      RNDUP = T(2).NE.0D0
      CALL RNDOUT (RESULT, RNDDWN, RNDUP)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE IVLABS (A, RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IVLABS returns a rigorous bound on the range of the absolute value
C  of the interval A.  The intrinsic function ABS is assumed to be
C  accurate to the same accuracy as the elementary operations.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), RESULT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TMP(2), TA(2)
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C  ABS
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  RNDOUT
C
C***********************************************************************
C
C Beginning of executable statements --
C
      TA(1) = A(1)
      TA(2) = A(2)

      TMP(1) = ABS(TA(1))
      TMP(2) = ABS(TA(2))

      IF (TMP(1).LE.TMP(2)) THEN
         RESULT(1) = TMP(1)
         RESULT(2) = TMP(2)
      ELSE
         RESULT(1) = TMP(2)
         RESULT(2) = TMP(1)
      END IF

      CALL RNDOUT(RESULT,.TRUE.,.TRUE.)

      IF ( ( TA(1).LE.0 .AND. TA(2).GE.0 ) .OR. RESULT(1).LT. 0)
     1   RESULT(1) = 0D0

      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE IVLI (A, RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   January 8, 1993
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IVLI places the contents of interval A in RESULT.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2), RESULT(2)
C
C***********************************************************************
C
C Beginning of executable statements --
C
      RESULT(1) = A(1)
      RESULT(2) = A(2)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      DOUBLE PRECISION FUNCTION IWID (A)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C (Utility function)
C
C***********************************************************************
C
C Function --
C
C  IWID returns the width of the interval A, rounded up.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION A(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TMP(2)
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  RNDOUT
C
C***********************************************************************
C
C Beginning of executable statements --
C
      TMP(2) = A(2)-A(1)
      CALL RNDOUT(TMP,.FALSE.,.TRUE.)
C
      IWID = TMP(2)
C
      RETURN
      END

c*** elemfuns.f
      SUBROUTINE IACOS (X,IRCCOS)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C   By Chenyi Hu
C       and
C   Abdulhamid Awad
C
C   Computer and Mathematical Sciences Department
C   University of Houston-Downtown
C   Houston, TX 77002
C
C       and
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   July 12, 1992
C
C Part of the interval elementary function library
C
C
C***********************************************************************
C
C Function --
C
C  This routine computes an interval enclosure for the arccos over
C  the interval X and returns the result in the interval IRCCOS.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2), IRCCOS(2)
C
C***********************************************************************
C
C Common blocks --
C
        DOUBLE PRECISION MXULP, TTINY2, TOL0
        COMMON /MACH1/MXULP, TTINY2, TOL0
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  ERRTST, IASIN, SUB
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 8
      IERR = 0
C
      IF (X(2).LT.X(1)) THEN
         IERR = 1
         CALL ERRTST(X)
      END IF
C
      IF (X(2).GT.ONE(1)) THEN
         IERR = 9
         CALL ERRTST(X)
         IRCCOS(1) = NEGINF
         IRCCOS(2) = POSINF
         RETURN
      ELSE IF (X(1).LT.-ONE(1)+MXULP) THEN
         IERR = 10
         CALL ERRTST(X)
         IRCCOS(1) = NEGINF
         IRCCOS(2) = POSINF
         RETURN
      END IF
C
      CALL IASIN(X, IRCCOS)
C
      CALL SUB(PI2,IRCCOS,IRCCOS)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE IACOT(X,IRCCOT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   By Chenyi Hu
C       and
C   Abdulhamid Awad
C
C   Computer and Mathematical Sciences Department
C   University of Houston-Downtown
C   Houston, TX 77002
C
C       and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   June 16, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C   This program finds bounds on the value of ARCCOT(X) as X
C   ranges of the interval XX, and places the resulting interval
C   in IRCCOT.
C
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2), IRCCOT(2)
C
C***********************************************************************
C
C Common blocks--
C
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  IATAN, SUB
C
C***********************************************************************
C
C Beginning of executable statements --
C

      CALL IATAN(X, IRCCOT)
      CALL SUB(PI2,IRCCOT,IRCCOT)

      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE IASIN(XX,IRCSIN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C   By Chenyi Hu
C       and
C   Abdulhamid Awad
C
C   Computer and Mathematical Sciences Department
C   University of Houston-Downtown
C   Houston, TX 77002
C
C       and
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   July 7, 1992
C
C Part of the interval elementary function library
C
C
C***********************************************************************
C
C Function --
C
C  This routine computes an interval enclosure for the arcsin over
C  the interval XX and returns the result in the interval IRCSIN.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION XX(2), IRCSIN(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION LB, UB
      DOUBLE PRECISION X(2), RSLT(2), TMP(2)
      LOGICAL OVER, NEGATV, FLIP
C
C***********************************************************************
C
C Common blocks --
C
        DOUBLE PRECISION MXULP, TTINY2, TOL0
        COMMON /MACH1/MXULP, TTINY2, TOL0
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --  none
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  ASNSER, ERRTST, ISQRT, MULT, RNDOUT, SUB
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 9
      IERR = 0
C
      IF (XX(2).LT.XX(1)) THEN
         IERR = 1
         CALL ERRTST(XX)
      END IF
C
      IF (XX(2).GT.ONE(1)) THEN
         IERR = 9
         CALL ERRTST(XX)
         RETURN
      ELSE IF (XX(1).LT.-ONE(1)+MXULP) THEN
         IERR = 10
         CALL ERRTST(XX)
         RETURN
      END IF
C
      LB = XX(1)
      UB = XX(2)
C
C For the lower end point ---
C----------------------------------------------------------------------
C
C  If LB < 0, convert it to positive --

      IF (LB .LT. ZERO(1)) THEN
         OVER = .TRUE.
         NEGATV = .TRUE.
         TMP(2) = -LB
         CALL RNDOUT(TMP,.FALSE.,.TRUE.)
         LB = TMP(2)
      ELSE
         OVER = .FALSE.
         NEGATV =.FALSE.
      ENDIF
C
C  Transform LB to a small interval X such that 0 <= X <= 0.5 --
C
      X(1) = LB
      X(2) = LB
      IF (NEGATV) CALL RNDOUT(X,.TRUE.,.TRUE.)
C
      IF (LB .LE. OD2F(2) ) THEN
         FLIP = .FALSE.
      ELSE
         FLIP = .TRUE.
C
C   X <-- SQRT( (1 - X)/2 )
C
         CALL SUB(ONE,X,X)
         CALL MULT(OD2F,X,X)
         IF(X(1).LT.0D0) THEN
            X(1)=0D0
         END IF
         CALL ISQRT(X,X)
      ENDIF
C
C  Find a bound on the arcsin at the lower end point --
C
        CALL ASNSER (X, OVER, RSLT)
C
C  Undo the argument transformation, if it was applied --
C
      IF (FLIP) THEN
         CALL MULT(TWO,RSLT,RSLT)
         CALL SUB(PI2,RSLT,RSLT)
      END IF

      IF (NEGATV) THEN
         IRCSIN(1) = -RSLT(2)
         CALL RNDOUT(IRCSIN,.TRUE.,.FALSE.)
      ELSE
         IRCSIN(1) = RSLT(1)
      ENDIF
C
C For the upper end point ---
C----------------------------------------------------------------------
C
      IF (UB .LT. 0D0) THEN
         OVER =.FALSE.
         NEGATV = .TRUE.
         TMP(2) = -UB
         CALL RNDOUT(TMP,.FALSE.,.TRUE.)
         UB = TMP(2)
      ELSE
         OVER = .TRUE.
         NEGATV = .FALSE.
      ENDIF
C
      X(1) = UB
      X(2) = UB
      IF (NEGATV) CALL RNDOUT(X,.TRUE.,.TRUE.)
C
      IF (UB .LE. OD2F(2) ) THEN
         FLIP = .FALSE.
      ELSE
         FLIP = .TRUE.
C
C   X <-- SQRT( (1 - X)/2 )
C
         CALL SUB(ONE,X,X)
         CALL MULT(OD2F,X,X)
         IF(X(1).LT.0D0) THEN
            X(1)=0D0
         END IF
         CALL ISQRT(X,X)
      ENDIF
C
      CALL ASNSER(X, OVER, RSLT)
C
      IF (FLIP) THEN
         CALL MULT(TWO,RSLT,RSLT)
         CALL SUB(PI2,RSLT,RSLT)
      END IF

      IF (NEGATV) THEN
         IRCSIN(2) = -RSLT(1)
         CALL RNDOUT(IRCSIN,.FALSE.,.TRUE.)
      ELSE
         IRCSIN(2) = RSLT(2)
      ENDIF
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
C
      SUBROUTINE ASNSER (X, OVER, RSLT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C   By Chenyi Hu
C       and
C   Abdulhamid Awad
C
C   Computer and Mathematical Sciences Department
C   University of Houston-Downtown
C   Houston, TX 77002
C
C       and
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   July 7, 1992
C
C Part of the interval elementary function library
C
C
C***********************************************************************
C
C Function --
C
C  This routine computes an interval enclosure for the arcsin over
C  the interval X and returns the result in the interval RSLT.  It is
C  assumed that X is nearly a point, between 0 and .5.  This routine is
C  normally called from IASIN.  The argument OVER indicates whether
C  the upper end point or lower end point is important.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2)
      LOGICAL OVER
      DOUBLE PRECISION RSLT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TEMP1(2), TEMP2(2), TEMP3(2), SUM(2)
      DOUBLE PRECISION T
      INTEGER I
      DOUBLE PRECISION D2IM1(2), D2I(2), D2IP1(2)
C
C***********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MXULP, TTINY2, TOL0
      COMMON /MACH1/MXULP, TTINY2, TOL0
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C  ABS, DBLE, MAX
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  ADD, ERRTST, IDIV, MULT, RNDOUT
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 10
      IERR = 0
C
      SUM(1) = X(1)
      SUM(2) = X(2)
C
      TEMP1(1) = X(1) * X(1)
      TEMP1(2) = X(2) * X(2)
      CALL RNDOUT(TEMP1, .TRUE., .TRUE.)
C
      TEMP2(1) = X(1)
      TEMP2(2) = X(2)
C
      DO 10 I = 1,100
C
         D2IM1(1) = DBLE(2*I-1)
         D2IM1(2) = D2IM1(1)
         CALL RNDOUT(D2IM1,.TRUE.,.TRUE.)
         D2I(1) = DBLE(2*I)
         D2I(2) = D2I(1)
         CALL RNDOUT(D2I,.TRUE.,.TRUE.)
         D2IP1(1) = DBLE(2*I+1)
         D2IP1(2) = D2IP1(1)
         CALL RNDOUT(D2IP1,.TRUE.,.TRUE.)
C
C  TEMP2 <-- (2i-1)TEMP1 TEMP2 / (2i)
C
         CALL MULT(D2IM1,TEMP2,TEMP2)
         CALL MULT(TEMP2,TEMP1,TEMP2)
         CALL IDIV(TEMP2,D2I,TEMP2)
C
         CALL IDIV(TEMP2,D2IP1,TEMP3)
C
         SUM(1) = SUM(1) + TEMP3(1)
         SUM(2) = SUM(2) + TEMP3(2)
         CALL RNDOUT(SUM,.TRUE.,.TRUE.)
         T = MAX( ABS(SUM(1)), TOL0 )
         IF (TEMP3(2)/T .LT. MXULP) GOTO 20
   10 CONTINUE
         IERR=11
         CALL ERRTST(TEMP3)
         RETURN
   20 CONTINUE
C
      IF (OVER) THEN
         CALL MULT(TWO,TEMP3,TEMP3)
         CALL ADD(SUM,TEMP3,RSLT)
      ELSE
         RSLT(1) = SUM(1)
         RSLT(2) = SUM(2)
      ENDIF
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE IATAN(XX,IRCTAN)

C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   By Chenyi Hu
C       and
C   Abdulhamid Awad
C
C   Computer and Mathematical Sciences Department
C   University of Houston-Downtown
C   Houston, TX 77002
C
C       and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   June 16, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C   This program finds bounds on the value of ARCTAN(X) as X
C   ranges over the interval XX, and places the resulting interval
C   in IRCTAN.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION XX(2), IRCTAN(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION LB, UB, X(2), RSLT(2), TMP(2)
      INTEGER CODE
      LOGICAL EVEN, NEGATV, RLB, RUB
C
C***********************************************************************
C
C Common blocks--
C
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
      DOUBLE PRECISION MXULP, TTINY2, TOL0
      COMMON /MACH1/MXULP, TTINY2, TOL0
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  ADD, ATNRED, ATNSER, RNDOUT, SUB
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 11
      IERR = 0
C
      IF (XX(2).LT.XX(1)) THEN
         IERR = 1
         CALL ERRTST(XX)
      END IF
C
      LB = XX(1)
      UB = XX(2)
C
C  Find the logical value EVEN, used in subroutine ATNSER to determine
C  the number of terms to be computed in the series --
C
      IF (LB .GT. 1.0D0) THEN
         EVEN = .TRUE.
      ELSE IF (LB .GE. 0D0) THEN
         EVEN = .FALSE.
      ELSE IF (LB .GT. -1D0) THEN
         EVEN = .FALSE.
      ELSE
         EVEN = .TRUE.
      ENDIF
C
C  If LB < 0, convert it to positive and update even --

      IF (LB .LT. 0D0) THEN
         EVEN = .NOT. EVEN
         NEGATV = .TRUE.
         TMP(2) = -LB
         CALL RNDOUT(TMP,.FALSE.,.TRUE.)
         LB = TMP(2)
      ELSE
         NEGATV =.FALSE.
      ENDIF
C
C  Transform LB to an interval X such that 0 <= X < 1/sqrt(3).  Here, X
C  is a small interval containing the lower bound of the the interval
C  [LB,UB] after transformation --
C
      CALL ATNRED(LB, CODE, X)
C
C  Find the value of the arctangent for the interval X --
C
      CALL ATNSER(X, EVEN, RSLT)
C
C  Undo the transformation and store the result --
C
      IF (CODE .EQ. 11) THEN
      ELSE IF (CODE .EQ. 12 ) THEN
         CALL ADD(PI6,RSLT,RSLT)
      ELSE IF (CODE .EQ. 21 ) THEN
         CALL SUB(PI2,RSLT,RSLT)
      ELSE IF (CODE .EQ. 22 ) THEN
         CALL SUB(PI3,RSLT,RSLT)
      END IF
C
      IF (NEGATV) THEN
         IRCTAN(1) = -RSLT(2)
         RLB = .TRUE.
      ELSE
         IRCTAN(1) = RSLT(1)
         RLB = .FALSE.
      ENDIF
C
C  Similarly obtain an enclosure for the arctangent at the upper
C  end point --
C
      IF (UB .GT. 1.0D0) THEN
         EVEN = .FALSE.
      ELSE IF (UB .GE. 0D0) THEN
         EVEN = .TRUE.
      ELSE IF (UB .GT. -1D0) THEN
         EVEN = .TRUE.
      ELSE
         EVEN = .FALSE.
      ENDIF
C
      IF (UB .LT. 0D0) THEN
         EVEN = .NOT. EVEN
         NEGATV = .TRUE.
         TMP(2) = -UB
         CALL RNDOUT(TMP,.FALSE.,.TRUE.)
         UB = TMP(2)
      ELSE
         NEGATV = .FALSE.
      ENDIF
C
      CALL ATNRED(UB, CODE, X)
      CALL ATNSER(X, EVEN, RSLT)
C
      IF (CODE .EQ. 11) THEN
      ELSE IF (CODE .EQ. 12 ) THEN
         CALL ADD(PI6,RSLT,RSLT)
      ELSE IF (CODE .EQ. 21 ) THEN
         CALL SUB(PI2,RSLT,RSLT)
      ELSE IF (CODE .EQ. 22 ) THEN
         CALL SUB(PI3,RSLT,RSLT)
      END IF
C
      IF (NEGATV) THEN
         IRCTAN(2) = -RSLT(1)
         RUB = .TRUE.
      ELSE
         IRCTAN(2) = RSLT(2)
         RUB = .FALSE.
      ENDIF
C
      CALL RNDOUT(IRCTAN,RLB,RUB)
C
      RETURN
      END
C**********************************************************************
C**********************************************************************
      SUBROUTINE ATNRED(PP,CODE,X)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   By Chenyi Hu
C       and
C   Abdulhamid Awad
C
C   Computer and Mathematical Sciences Department
C   University of Houston-Downtown
C   Houston, TX 77002
C
C       and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   June 16, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C  This is an auxiliary routine for IATAN.  It performs an argument
C  reduction in preparation for computing a series approximation to the
C  arctangent function.
C
C  The subroutine transforms a given nonnegative number P to a
C  nonnegative number less than the reciprocal of the square root of 3,
C  then converts it to an interval.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION PP, X(2)
      INTEGER CODE
C
C***********************************************************************
C
C Argument descriptions -- (INPUT  = set on entry and not alterable)
C                          (OUTPUT = to be set by the routine)
C                          (I/O    = set on entry but alterable)
C
C PP     A floating point representation of an endpoint, to be reduced.
C        (INPUT)
C
C X      A small interval enclosure for the reduced quantity
C        corresponding to PP.
C        (OUTPUT)
C
C CODE   A flag indicating how the argument was reduced, as follows:
C
C          CODE = 11      no transformation
C          CODE = 12      1 / sqrt(3) < P < = 1
C          CODE = 21      P > 1 and 0 < 1/P < 1 / sqrt(3)
C          CODE = 22      P > 1 and 1/P >= 1 / sqrt(3)
C
C        (OUTPUT)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION P(2), TMP(2)
C
C***********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  ADD, IDIV, MULT, SUB
C
C***********************************************************************
C
C Beginning of executable statements --
C
      P(1) = PP
      P(2) = PP
C
      IF (P(1) .LE. ODSQT3(1)) THEN
         CODE = 11
      ELSE IF (P(1) .LE. ONE(2)) THEN
C
C  P <-- (sqrt(3)P - 1)/(sqrt(3)+P):
C
         CALL MULT(P,SQT3,TMP)
         CALL SUB(TMP,ONE,TMP)
         CALL ADD(SQT3,P,P)
         CALL IDIV(TMP,P,P)
         CODE = 12
      ELSE
C
C  P <-- 1/P:
C
         CALL IDIV(ONE,P,P)
         IF (P(1) .LE. ODSQT3(1)) THEN
            CODE = 21
         ELSE
            CALL MULT(P,SQT3,TMP)
            CALL SUB(TMP,ONE,TMP)
            CALL ADD(SQT3,P,P)
            CALL IDIV(TMP,P,P)
            CODE = 22
         ENDIF
      ENDIF
C
      X(1) = P(1)
      X(2) = P(2)
C
      RETURN
      END
C**********************************************************************
C**********************************************************************
      SUBROUTINE ATNSER (X,EVEN,RSLT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   By Chenyi Hu
C       and
C   Abdulhamid Awad
C
C   Computer and Mathematical Sciences Department
C   University of Houston-Downtown
C   Houston, TX 77002
C
C       and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   June 16, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C  This subroutine computes an enclosure for arctan X and puts the
C  result in RSLT.  It is assumed that X is an interval of small width
C  between 0 and 1 / sqrt(3).  The argument EVEN is used to determine
C  whether an even or odd number of terms should be taken.  This routine
C  is normally called from IATAN.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2), RSLT(2)
      LOGICAL EVEN
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TEMP1(2), TEMP2(2), TEMP3(2), SUM(2), XS(2)
      DOUBLE PRECISION DI(2), T
      INTEGER I, SIGN
C
C***********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MXULP, TTINY2, TOL0
      COMMON /MACH1/ MXULP, TTINY2, TOL0
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C  DBLE
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  ADD, IDIV, MULT, POWER, RNDOUT
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 12
      IERR = 0
C
      IF (X(1).LT.0D0) THEN
         IERR=12
         CALL ERRTST(X)
         RETURN
      END IF
C
      CALL POWER(X,2,XS)
C
      IF ((X(1) .EQ. 0D0) .AND. (X(2) .EQ. 0D0)) THEN
         RSLT(1) = ZERO(1)
         RSLT(2) = ZERO(2)
         RETURN
      ENDIF
C
      SUM(1) = X(1)
      SUM(2) = X(2)
C
      SIGN = -1
      CALL POWER(X,3,TEMP1)
C
      DO 10 I = 1,10000
         SIGN = -SIGN
         CALL MULT(TWO,TEMP1,TEMP2)
         DI(1) = DBLE (4*I*I - 1)
         DI(2) = DI(1)
         CALL RNDOUT(DI,.TRUE.,.TRUE.)
         CALL IDIV(TEMP2,DI,TEMP2)
C
         IF (SIGN .GT. 0) THEN
            SUM(1) = SUM(1) + TEMP2(1)
            SUM(2) = SUM(2) + TEMP2(2)
         ELSE
            SUM(1) = SUM(1) - TEMP2(2)
            SUM(2) = SUM(2) - TEMP2(1)
         ENDIF
         CALL RNDOUT(SUM,.TRUE.,.TRUE.)
C
         TEMP1(1) = TEMP1(1) * XS(1)
         TEMP1(2) = TEMP1(2) * XS(2)
         CALL RNDOUT(TEMP1, .TRUE., .TRUE.)
C
         T = MAX( ABS(SUM(1)),2D0*TOL0 )
         IF (TEMP1(2)/T .GT. MXULP) GOTO 10
         IF (EVEN .AND. (SIGN .LT. 0)) GOTO 10
         IF (EVEN .OR. (SIGN .LE. 0)) GOTO 20
   10 CONTINUE
         IERR=11
         CALL ERRTST(TEMP2)
         RETURN
   20 CONTINUE
C
      CALL ADD(XS,ONE,TEMP3)
      CALL IDIV(SUM,TEMP3,RSLT)
C
        RETURN
        END
C***********************************************************************
C***********************************************************************
      SUBROUTINE ICOS(X,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Kaisheng Du
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C
C***********************************************************************
C
C Function --
C
C  This routine returns the interval value of the cosine function
C  (evaluated over the interval X) in the interval variable
C  RESULT.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2), RESULT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION V1(2), V2(2)
      DOUBLE PRECISION VAL1(2),VAL2(2)
      DOUBLE PRECISION TMP(2), T1, T2
C
      INTEGER N1, N2
C
      LOGICAL EVEN
C
C***********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C     ABS, ERRTST, IDINT, MAX, MIN, MOD
C
C***********************************************************************
C
C Package-supplied functions and subroutines -- none
C
C     EXTERNAL ERRTST, MULT, RCOS, RNDOUT
C
C***********************************************************************
C
C User-supplied functions and subroutines -- none
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 2
      IERR = 0
C
      IF (X(2).LT.X(1)) THEN
         IERR = 1
         CALL ERRTST(X)
      END IF
C
C  Compute the value at the left endpoint using interval arithmetic --
C
      V1(1) = X(1)
      V1(2) = X(1)
C
C  If X1/PI is out of range, return the interval [-1,1] --
C
      CALL MULT(V1,A,TMP)
      T1 =ABS(TMP(1))
      IF(T1.GE.MAXX) THEN
         IERR = 5
         CALL ERRTST(X)
         RESULT(1) = -1D0
         RESULT(2) =  1D0
         RETURN
      ENDIF
C
C  Compute the value at the right endpoint using interval arithmetic --
C
      V2(1) = X(2)
      V2(2) = X(2)
      CALL RNDOUT(V2,.TRUE.,.TRUE.)
C
C  If X2/pi is out of range, return the interval [-1,1] --
C
      CALL MULT(V2,A,TMP)
      T2 = ABS(TMP(2))
      IF(T2.GE.MAXX) THEN
         IERR = 5
         CALL ERRTST(X)
         RESULT(1) = -1D0
         RESULT(2) =  1D0
         RETURN
      ENDIF
C
C  If both X1/pi and X2/pi are within range, calculate the function
C  values at the left and right endpoints using interval arithmetic --
C
      CALL RCOS(V1,VAL1)
C
      CALL RCOS(V2,VAL2)
C
C  Calculate the number of half-periods from zero for the left
C  and right endpoints in order to normalize to [-pi/2,pi/2] --
C
      N1 = IDINT(T1)
      N2 = IDINT(T2)
      IF(V1(1).LT.0D0) N1 = -N1-1
      IF(V2(2).LT.0D0) N2 = -N2-1
C
C   In even half periods, the function is decreasing --
C
      EVEN = MOD(N1,2).EQ.0
C
C   If X1 and X2 are in the same half period, then the lower bound
C   and upper bound on the range occur at the endpoints --
C
      IF(N1.EQ.N2) THEN
         RESULT(1) = MIN(VAL1(1),VAL2(1))
         RESULT(2) = MAX(VAL1(2),VAL2(2))
         RETURN
      ENDIF
C
C   Consider the case X2 is in the half period adjacent to X1 --
C
      IF(N2.EQ.N1+1) THEN
C
C    If X1 is in the increasing half period, then the upper bound should
C    equal 1;  otherwise, the lower bound should be -1 --
C
         IF(EVEN) THEN
            RESULT(1) = -1.D0
            RESULT(2) = MAX(VAL1(2),VAL2(2))
         ELSE
           RESULT(1) = MIN(VAL1(1),VAL2(1))
           RESULT(2) = 1.D0
         ENDIF
C
C   If X1 and X2 are not in adjecent half periods, then the lower
C   bound should be -1 and the upper bound should be 1 --
C
      ELSE
         RESULT(1) = -1.D0
         RESULT(2) =  1.D0
      ENDIF
C
      CALL RNDOUT(RESULT,.TRUE.,.TRUE.)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE IEXP(X,RESULT)
C
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Kaisheng Du
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C  This routine returns the interval exp(X) in RESULT.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2), RESULT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TEMP(2), TVAL(2), T
C
C***********************************************************************
C
C Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Fortran-supplied functions --
C
C     ABS
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
      EXTERNAL ERRTST, REXP
      DOUBLE PRECISION D1MACH
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 1
      IERR = 0
C
      IF (X(2).LT.X(1)) THEN
         IERR = 1
         CALL ERRTST(X)
      END IF
C
      IF (X(1).EQ.ZERO(1)) THEN
         RESULT(1) =ONE(1)
      ELSE
         T = ABS(X(1))
         IF (T.GT.MXLGM1) THEN
            IF(X(1).GT.ZERO(1))THEN
               IERR = 3
            ELSE
               IERR = 2
            END IF
            CALL ERRTST(X)
         END IF
         IF (IERR.EQ.2) THEN
            RESULT(1) = ZERO(1)
         ELSE IF (IERR.EQ.3) THEN
            RESULT(1) = POSINF
            RESULT(2) = POSINF
            RETURN
         ELSE
            TEMP(1) = X(1)
            TEMP(2) = X(1)
            CALL REXP(TEMP,TVAL)
            RESULT(1) = TVAL(1)
         END IF
      END IF
C
      IF (X(2).EQ.ZERO(2)) THEN
         RESULT(2) =ONE(2)
      ELSE
         IF (X(2).GT.MXLGM1) THEN
            IERR = 4
            CALL ERRTST(X)
         END IF
         IF (IERR.EQ.4) THEN
            RESULT(2) = D1MACH(2)
            RETURN
         ELSE
            TEMP(1) = X(2)
            TEMP(2) = X(2)
            CALL REXP(TEMP,TVAL)
            RESULT(2) = TVAL(2)
         END IF
      END IF
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE IIPOWR(XX, YY, RESULT)
C
C  Kaisheng Du and R. B. Kearfott, Summer, 1991
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Kaisheng Du
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C**********************************************************************
C
C Function --
C
C  This routine returns the interval X**Y, provided that X is a
C  positive interval.
C  RESULT.
C
C**********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION XX(2), YY(2), RESULT(2)
C
C**********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION X(2), Y(2)
      LOGICAL LBZERO

C**********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C   ABS, MAX
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C   ERRTST, IEXP, ILOG, MULT
C
C**********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 14
      IERR = 0
C
      X(1) = XX(1)
      X(2) = XX(2)
      Y(1) = YY(1)
      Y(2) = YY(2)
C
      IF (X(2).LT.X(1)) THEN
         IERR = 1
         CALL ERRTST(X)
      END IF
C
      LBZERO = .FALSE.
      IF (X(1).EQ.0D0) THEN
         IF (Y(1).LT.0D0) THEN
            IF(Y(2).GE.0D0) THEN
               IERR = 14
               RESULT(1) = NEGINF
               RESULT(2) = POSINF
               RETURN
            END IF
         END IF
         LBZERO = .TRUE.
         X(1) = X(2)
      END IF

      IF (X(1).LE.ZERO(2)) THEN
         IERR = 7
         CALL ERRTST(X)
         RETURN
      END IF
C
      CALL ILOG(X,RESULT)
C
      CALL MULT(RESULT,Y,RESULT)
C
      IF (ABS(RESULT(1)).GT.MXLGM1) THEN
         IF(RESULT(1).GT.ZERO(1)) THEN
            IERR = 3
         ELSE
            IERR = 2
         END IF
         CALL ERRTST(RESULT)
      END IF
      IF (RESULT(2).GT.MXLGM1) THEN
         IERR = 4
         CALL ERRTST(RESULT)
      END IF
C
      CALL IEXP(RESULT,RESULT)
      IF(LBZERO) THEN
         IF (Y(1).LT.0D0) THEN
            RESULT(2) = POSINF
            IERR = 15
         ELSE
            RESULT(1) = 0D0
         END IF
      END IF
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE ILOG(X,RESULT)
C
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Kaisheng Du
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C  This routine returns the interval log(X) in RESULT.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2), RESULT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TEMP(2), TVAL(2)
C
C***********************************************************************
C
C Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C     ERRTST, RLOG
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 4
      IERR = 0
C
      IF (X(2).LT.X(1)) THEN
         IERR = 1
         CALL ERRTST(X)
      END IF
C
      IF (X(1).LE.ZERO(2)) THEN
         IERR = 7
         CALL ERRTST(X)
         RETURN
      END IF
C
      TEMP(1) = X(1)
      TEMP(2) = X(1)
      CALL RLOG(TEMP,TVAL)
      RESULT(1) = TVAL(1)
C
      TEMP(1) = X(2)
      TEMP(2) = X(2)
      CALL RLOG(TEMP,TVAL)
      RESULT(2) = TVAL(2)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE ISIN(X,RESULT)
C
C  Kaisheng Du and R. B. Kearfott, Summer, 1991
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Kaisheng Du
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C**********************************************************************
C
C Function --
C
C  This routine returns the interval value of the sine function
C  (evaluated over the interval X) in the interval variable
C  RESULT.
C
C**********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2), RESULT(2)
C
C**********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C***********************************************************************
C
C Fortran supplied functions and subroutines --
C
C      ABS, MAX
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C      ICOS, MULT, POWER, SUB
C
C**********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TMP1(2), TMP2(2), TMP3(2)
      LOGICAL SMALL1, SMALL2
C
C**********************************************************************
C
C
C Beginning of executable statements --
C
C  Assure good relative accuracy near zero by the case separately;
C  otherwise, shift the argument and use the interval cosine function --
C
      SMALL1=.FALSE.
      SMALL2=.FALSE.
      IF ( MAX( ABS(X(1)), ABS(X(2)) ) .LT. PI2(1) ) THEN
         IF(ABS(X(1)).LT.CBTEP) THEN
            SMALL1 = .TRUE.
            TMP1(1) = X(1)
            TMP1(2) = X(1)
            IF (X(1).GT.ZERO(2)) THEN
               CALL POWER(TMP1,3,TMP2)
               CALL MULT(TMP2,OD3F,TMP2)
               CALL SUB(TMP1,TMP2,TMP1)
            END IF
         END IF
         IF(ABS(X(2)).LT.CBTEP) THEN
            SMALL2 = .TRUE.
            TMP3(1) = X(2)
            TMP3(2) = X(2)
            IF (X(2).LT.ZERO(1)) THEN
               CALL POWER(TMP3,3,TMP2)
               CALL MULT(TMP2,OD3F,TMP2)
               CALL SUB(TMP3,TMP2,TMP3)
            END IF
         END IF
      END IF
C
      IF (SMALL1 .AND. SMALL2) THEN
         RESULT(1) = TMP1(1)
         RESULT(2) = TMP3(2)
         RETURN
      ELSE
         CALL SUB(X,PI2,RESULT)
         CALL ICOS(RESULT,RESULT)
      END IF
C
      IF (SMALL1) RESULT(1) = MAX(TMP1(1),RESULT(1))
      IF (SMALL2) RESULT(2) = MIN(TMP3(2),RESULT(2))
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE ISINH(XX,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   Chenyi Hu
C
C   Computer and Mathematical Sciences Department
C   University of Houston-Downtown
C   Houston, TX 77002
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   October 20, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C  This routine returns an interval inclusion for the hyperbolic sine
C  over the interval XX in RESULT.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION XX(2), RESULT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION AA, BB, X(2), RSLT(2)
      DOUBLE PRECISION TMP(2), TMP2(2)
      INTEGER CODE
      LOGICAL OVER, NEGATV
C
C***********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
      DOUBLE PRECISION MXULP, TTINY2, TOL0
      COMMON /MACH1/MXULP, TTINY2, TOL0
C
C***********************************************************************
C
C Package-supplied functions and subroutines --

C  ERRTST, IDIV, IEXP, ISHSER, ISNRED, ISNVAL, MULT, RNDOUT, SUB
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 6
      IERR = 0
C
      IF (XX(2).LT.XX(1)) THEN
         IERR = 1
         CALL ERRTST(XX)
      END IF
C
      AA = XX(1)
      BB = XX(2)
C
C-------------------------------------------------------------------
C  Compute the value of the hyperbolic sine at the lower endpoint A.
C-------------------------------------------------------------------
C
      IF (AA .LT. ZERO(1)) THEN
         OVER = .TRUE.
         NEGATV = .TRUE.
         TMP(2) = -AA
         CALL RNDOUT(TMP,.FALSE.,.TRUE.)
         AA = TMP(2)
      ELSE
         OVER = .FALSE.
         NEGATV =.FALSE.
      ENDIF
C
C  Transform AA to an interval X such that 0 <= X <= 1 --
C
      CALL ISNRED(AA, CODE, X)
C
      IF (CODE .EQ. 20) THEN
C
C  Use the exponential function for arguments larger than 27 --
C
         CALL IEXP(X, TMP)
         CALL IDIV(ONE,TMP,TMP2)
         CALL SUB(TMP,TMP2,TMP)
         CALL MULT(OD2F,TMP,RSLT)
      ELSE
C
C  Evaluate the series X + X^3/3! + X^5/5! + ... for 0 <= X <= 1 --
C
         CALL ISHSER(X, OVER, RSLT)
         CALL ISNVAL(CODE, RSLT)
       END IF
C
C  Undo the possible argument reduction from ISNRED --
C
      IF (NEGATV) THEN
         RESULT(1) = - RSLT(2)
         CALL RNDOUT(RESULT,.TRUE.,.FALSE.)
      ELSE
         RESULT(1) = RSLT(1)
      ENDIF
C
C-------------------------------------------------------------------
C  Compute the value of the hyperbolic sine at the upper endpoint B
C  (completely analogous to computation for the lower endpoint A).
C-------------------------------------------------------------------
C
      IF (BB .LT. ZERO(1)) THEN
         OVER =.FALSE.
         NEGATV = .TRUE.
         TMP(2) = -BB
         CALL RNDOUT(TMP,.FALSE.,.TRUE.)
         BB = TMP(2)
      ELSE
         OVER = .TRUE.
         NEGATV = .FALSE.
      ENDIF
C
      CALL ISNRED(BB, CODE, X)
C
      IF (CODE .EQ. 20) THEN
         CALL IEXP(X, TMP)
         CALL IDIV(ONE,TMP,TMP2)
         CALL SUB(TMP,TMP2,TMP)
         CALL MULT(OD2F,TMP,RSLT)
      ELSE
         CALL ISHSER(X, OVER, RSLT)
         CALL ISNVAL(CODE, RSLT)
      END IF
C
      IF (NEGATV) THEN
         RESULT(2) = - RSLT(1)
         CALL RNDOUT(RESULT,.FALSE.,.TRUE.)
      ELSE
         RESULT(2) = RSLT(2)
      ENDIF
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE ISNRED(P,CODE,X)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   Chenyi Hu
C
C   Computer and Mathematical Sciences Department
C   University of Houston-Downtown
C   Houston, TX 77002
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   October 20, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C  This subroutine transforms the nonnegative number P to a nonnegative
C  number which less than 1, and then converts the result to an
C  interval.  The following code numbers are set to record how the
C  transformation was done:
C
C     CODE = 11      0 < P < =  1
C     CODE = 12      1 < P < =  3
C     CODE = 13      3 < P < =  9
C     CODE = 14      9 < P < = 27
C     CODE = 20          P >   27
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION P
      INTEGER CODE
      DOUBLE PRECISION X(2)
C
C***********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C***********************************************************************
C
C Beginning of executable statements --
C
      X(1) = P
      X(2) = P
C
      IF (P .LE. ONE(1) ) THEN
         CODE = 11
         GO TO 10
      ELSE IF (P .LE. THREE(1)) THEN
         CALL MULT(X,THIRD,X)
         CODE = 12
         GO TO 10
      ELSE IF (P .LE. NINE(1)) THEN
         CALL MULT(X,NINTH,X)
         CODE = 13
         GO TO 10
      ELSE IF (P .LE. TWOT7(1)) THEN
         CALL MULT(X,TT7TH,X)
         CODE = 14
         GO TO 10
      ELSE
         CODE = 20
         GO TO 10
      ENDIF
C
   10 CALL RNDOUT(X, .TRUE., .TRUE.)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
        SUBROUTINE ISHSER (X, OVER, RSLT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   Chenyi Hu
C
C   Computer and Mathematical Sciences Department
C   University of Houston-Downtown
C   Houston, TX 77002
C
C         and
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   October 20, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C   This subroutine uses a series to bound the value of the hyperbolic
C   sine function over the nonnegative interval X of small width.  The
C   result is returned in RSLT.  The logical variable OVER indicates
C   whether negation was applied during the argument reduction.  This
C   routine is not meant to be called by the user.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2)
      LOGICAL OVER
      DOUBLE PRECISION RSLT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TEMP1(2), TEMP2(2), SUM(2), ERR(2), T
      INTEGER I
C
C***********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION MXULP, TTINY2, TOL0
      COMMON /MACH1/ MXULP, TTINY2, TOL0
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C  ABS, DBLE, FLOAT, MAX
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  MULT, POWER, RNDOUT
C
C***********************************************************************
C
C Beginning of executable statements --
C
      SUM(1) = X(1)
      SUM(2) = X(2)

      I = 1
C
C  Use temp1 to hold X^2 --
C
      CALL POWER(X,2,TEMP1)

      TEMP2(1) = X(1)
      TEMP2(2) = X(2)
C
10    CONTINUE
      I = I + 2
         TEMP2(1) = TEMP1(1) * TEMP2(1)
         TEMP2(2) = TEMP1(2) * TEMP2(2)
         CALL RNDOUT(TEMP2, .TRUE., .TRUE.)
C
         TEMP2(1) = TEMP2(1)/DBLE(FLOAT(I))
         TEMP2(2) = TEMP2(2)/DBLE(FLOAT(I))
         CALL RNDOUT(TEMP2, .TRUE., .TRUE.)
C
         TEMP2(1) = TEMP2(1)/DBLE(FLOAT(I-1))
         TEMP2(2) = TEMP2(2)/DBLE(FLOAT(I-1))
         CALL RNDOUT(TEMP2, .TRUE., .TRUE.)
C
         SUM(1) = SUM(1) + TEMP2(1)
         SUM(2) = SUM(2) + TEMP2(2)
         CALL RNDOUT(SUM,.TRUE.,.TRUE.)
C
         CALL MULT(TWO,TEMP2,ERR)
         T = MAX(ABS(SUM(1)),ABS(SUM(2)),2D0*TOL0)
         IF ((ERR(1)/T) .GT. MXULP) GOTO 10
C
      IF (OVER) THEN
         RSLT(1) = SUM(1) + ERR(1)
         RSLT(2) = SUM(2) + ERR(2)
         CALL RNDOUT(RSLT, .TRUE., .TRUE.)
      ELSE
         RSLT(1) = SUM(1)
         RSLT(2) = SUM(2)
      ENDIF
C
      RETURN
      END

C **********************************************************
      SUBROUTINE ISNVAL (CODE,RSLT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Chenyi Hu
C
C   Computer and Mathematical Sciences Department
C   University of Houston-Downtown
C   Houston, TX 77002
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   October 20, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C   This routine transforms the result from the reduced argument
C   computation for the arcsine function back to the value corresponding
C   to the original argument.  The type of argument reduction which was
C   applied is given in the integer variable CODE.  Both the reduced
C   value input to this routine and the final value output from this
C   routine are stored in RSLT.
C
C***********************************************************************
C
C Argument declarations --
C
      INTEGER CODE
      DOUBLE PRECISION RSLT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TEMP(2)
C
C***********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  ADD, MULT, RNDOUT
C
C
C***********************************************************************
C
C Beginning of executable statements --
C
      IF (CODE .EQ. 11) RETURN
C
   20 CONTINUE
      TEMP(1) = RSLT(1) * RSLT(1)
      TEMP(2) = RSLT(2) * RSLT(2)
      CALL RNDOUT(TEMP, .TRUE., .TRUE.)
C
C  rslt <-- rslt * (3 + 4 rslt^2)
C
      CALL MULT(FOUR,TEMP,TEMP)
      CALL ADD(THREE,TEMP,TEMP)
      CALL MULT(RSLT,TEMP,RSLT)
C
      IF (CODE .EQ. 12) THEN
         RETURN
      ELSE IF (CODE .EQ. 13) THEN
         CODE = 12
         GO TO 20
      ELSE IF (CODE .EQ. 14) THEN
         CODE = 13
         GO TO 20
      ENDIF
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE ISQRT(X,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Kaisheng Du
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C  This subroutine returns the interval value of the square root of X
C  in RESULT.  It uses the routine RSQRT to get rigorous values at the
C  endpoints.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2), RESULT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION V(2), RL(2), RR(2)
C
C***********************************************************************
C
C  Common block declarations --
C
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Package-supplied functions and subroutines --

C     ERRTST, RSQRT
C
C***********************************************************************
C
C Beginning of executable statements --
C
C  Identifying code for this routine --
C
      IROUT = 5
      IERR = 0
C
      IF (X(2).LT.X(1)) THEN
         IERR = 1
         CALL ERRTST(X)
      END IF
C
      IF (X(1).LT.0D0) THEN
         IERR = 7
         CALL ERRTST(X)
         RETURN
      ELSE IF (X(1).EQ.0D0) THEN
         RL(1) = 0D0
         RL(2) = 0D0
      ELSE
         V(1) = X(1)
         V(2) = X(1)
         CALL RSQRT(V,RL)
      END IF
C
      IF (X(2).EQ.0D0) THEN
         RR(1) = 0D0
         RR(2) = 0D0
      ELSE
         V(1) = X(2)
         V(2) = X(2)
         CALL RSQRT(V,RR)
      END IF
C
      RESULT(1) = RL(1)
      RESULT(2) = RR(2)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE POWER(AA,NDUM,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Manuel Novoa III
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   September 29, 1987
C
C Part of the generalized bisection package
C (interval arithmetic subpackage).
C
C   Modified by Manuel Novoa III on March 13, 1990 to fix a bug which
C   caused overestimation for N odd and zero in the interval's interior.
C
C   Modified August, 1991 and April, 1992 by Kaisheng Du and
C   R. Baker Kearfott to allow computation of negative integer powers.
C
C***********************************************************************
C
C Called by --
C
C  Any routine requiring computation of a positive integer power of
C  an interval.
C
C***********************************************************************
C
C Function --
C
C  This routine computes the NDUM-th power, of the interval A, where
C  NDUM is an integer.  It simulates directed roundings with the routine
C  RNDOUT; the interval result should contain the interval which would
C  have been obtained with exact interval arithmetic.  However, in
C  general it will not be the smallest possible machine-representable
C  such containing interval.  See the documentation in subroutine RNDOUT
C  for more detailed information.
C
C  This routine can clearly be made more efficient and more readable on
C  Fortran systems for which the intrinsic represented by A**N is
C  optimally accurate.  See the documentation in the subsidiary routine
C  RRPOWR for more information.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION AA(2), RESULT(2)
      INTEGER NDUM
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION B(2), TMP(2)
      LOGICAL EVEN ,L
      DOUBLE PRECISION TEMP
      INTEGER N
C
C***********************************************************************
C
C Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C    MAX, MOD
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C    ERRTST, MULT, RNDOUT, RRPOWR
C
C***********************************************************************
C
C Beginning of executable statements --
C
C
C  Identifying code for this routine --
C
      IROUT = 7
      IERR = 0
C
      IF (AA(2).LT.AA(1)) THEN
         IERR = 1
         CALL ERRTST(AA)
      END IF
C
C  If N is equal to 0 then return the point interval [1,1] --
C
      N = NDUM
C
      IF (N.EQ.0) THEN
         RESULT(1) = ONE(1)
         RESULT(2) = ONE(2)
         RETURN
      END IF
C
C     If N = 1 then return AA.
C
      IF (N.EQ.1) THEN
         RESULT(1) = AA(1)
         RESULT(2) = AA(2)
         RETURN
      END IF
C
C  If N < 0, let N = -N.
C
      L = (N.LT.0)
      IF(L) THEN
         IF (AA(1).LT.ZERO(1) .AND. AA(2).GT.ZERO(2)) THEN
            IERR=8
            CALL ERRTST(AA)
            RESULT(1) = NEGINF
            RESULT(2) = POSINF
            RETURN
         END IF
         N = -N
      END IF
C
C  If N > 1, check cases for 0 in or not in the interval --
C
      EVEN = (MOD(N,2).EQ.0)
C
      IF (AA(1).GT.ZERO(2)) THEN
         CALL RRPOWR(AA(1),N,TMP)
         B(1) = TMP(1)
         CALL RRPOWR(AA(2),N,TMP)
         B(2) = TMP(2)
      ELSE IF (AA(2).LT.ZERO(1)) THEN
         IF (EVEN) THEN
            CALL RRPOWR(AA(2),N,TMP)
            B(1) = TMP(1)
            CALL RRPOWR(AA(1),N,TMP)
            B(2) = TMP(2)
         ELSE
            CALL RRPOWR(AA(1),N,TMP)
            B(1) = TMP(1)
            CALL RRPOWR(AA(2),N,TMP)
            B(2) = TMP(2)
         END IF
      ELSE IF (EVEN) THEN
         B(1) = ZERO(1)
         TMP(2) = -AA(1)
         CALL RNDOUT(TMP,.FALSE.,.TRUE.)
         TEMP = MAX(TMP(2),AA(2))
         CALL RRPOWR(TEMP,N,TMP)
         B(2) = TMP(2)
      ELSE
         CALL RRPOWR(AA(1),N,TMP)
         B(1) = TMP(1)
         CALL RRPOWR(AA(2),N,TMP)
         B(2) = TMP(2)
      END IF
C
      IF (L) THEN
         IF(B(1).GT.0D0)  THEN
            TEMP = B(1)
            B(1) = ONE(1)/B(2)
            B(2) = ONE(2)/TEMP
            CALL RNDOUT(B,.TRUE.,.TRUE.)
         ELSE
            TEMP = B(1)
            B(1) = ONE(2)/B(2)
            B(2) = ONE(1)/TEMP
            CALL RNDOUT(B,.TRUE.,.TRUE.)
         END IF
      END IF
C
      RESULT(1) = B(1)
      RESULT(2) = B(2)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE RRPOWR(AA,NDUM,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   November 14, 1992
C
C Part of the generalized bisection package
C (interval arithmetic subpackage).
C
C***********************************************************************
C
C Called by --
C
C  POWER
C
C***********************************************************************
C
C Function --
C
C  This routine computes the NDUM-th power, of the interval point AA,
C  using simulated directed roundings to rigorously bound the roundoff
C  error.  The results is placed in RESULT.  The reason for this routine
C  is to allow rigor on machines on which exponentiation by an integer
C  is not accurate to within one digit in the last place.  The POWER
C  routine can certainly be made more efficient without this routine
C  if the Fortran intrinsic A**NDUM is optimally accurate.  This routine
C  can also be made more efficient by rewriting it in Fortran 90, and
C  making good use of recursion.  (See ``Programmer's Guide to Fortran
C  90, W. S. Brainerd, C. H. Goldberg, J. C. Adams, McGraw Hill, 1990
C  p. 222 ff.)
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION AA, RESULT(2)
      INTEGER NDUM
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION X(2)
      INTEGER I
C
C***********************************************************************
C
C Beginning of executable statements --
C
      X(1) = AA
      X(2) = AA
C
      RESULT(1) = X(1)
      RESULT(2) = X(2)
      IF (NDUM.EQ.1) RETURN
C
      DO 10 I = 2,NDUM,1
         CALL MULT(RESULT,X,RESULT)
   10 CONTINUE
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE RCOS(XA,VAL)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Kaisheng Du
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C  This routine is used to compute one of the endpoints of the
C  cosine of the interval X.  It is assumed that X is an interval of
C  very small width.  In particular, it is assumed that the length of
C  the interval is at most pi/16.  It is also assumed that the
C  absolute value of the argument is no greater than MAXX / pi,
C  where MAXX is the largest representable integer in the machine.
C  Since this routine doesn't check these conditions, it is assumed
C  that the calling routine has done so.
C
C  This routine is usually called by ISIN, which returns interval
C  values of the sin for general interval arguments.
C
C  This routine translates the interval to [0,pi/8], and possibly
C  uses a double angle formula twice.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION XA(2), VAL(2)
C
C***********************************************************************
C
C Argument descriptions -- (INPUT  = set on entry and not alterable)
C                          (OUTPUT = to be set by the routine)
C                          (I/O    = set on entry but alterable)
C
C  XA    is the interval argument
C       (INPUT)
C
C  VAL   is the resulting interval cosine value
C        (OUTPUT)
C
C***********************************************************************
C
C Internal variable declarations --
C
      LOGICAL L2
      INTEGER N
      DOUBLE PRECISION  DN, ERTRM(2), TEM(2), TMP, V(2), VALT(2),
     *                  VSQ(2), X(2)
C
C***********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MXULP, TOL0, TTINY2
      COMMON /MACH1/ MXULP, TTINY2, TOL0
C
C  The above common block holds machine parameters which are set in
C  SIMINI and used here.
C
C  Variable descriptions
C
C  MXULP       (machine epsilon)
C                * (maximum error in ULP's of the floating pt. op's)
C
C  TTINY2      2 * (smallest representable positive machine number)
C                * (maximum error in ULP's of the floating pt. op's)
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines
C
C     DBLE, MOD, NINT
C
C***********************************************************************
C
C Package-supplied functions and subroutines
C
C     ADD, MULT, POWER, RNDOUT, SCLMLT, SUB
C
C***********************************************************************
C
C Beginning of executable statements --
C
      X(1) = XA(1)
      X(2) = XA(2)
      IF (X(2).LT.0D0) THEN
         TMP = X(2)
         X(2) = -X(1)
         X(1) = -TMP
      END IF
C
C  Reduce the angle to between 0 and pi using translation by a
C  multiple of pi/2, making sure that the resulting interval is either
C  entirely positive or entirely negative.
C
      CALL MULT (X,A,TEM)
      N = NINT((TEM(1)+TEM(2))/2D0)
      DN = DBLE(N)
C
      CALL SCLMLT (DN,PI,V)
      CALL SUB (X,V,V)
C
      IF (V(2).LT.0D0) THEN
         TMP = V(2)
         V(2) = -V(1)
         V(1) = -TMP
         CALL RNDOUT(V,.TRUE.,.TRUE.)
      END IF
C
C  Further reduce the angle to between 0 and pi/8, using angle halving.
C
      L2 = V(2) .GE. PI8(1)
      IF (L2) THEN
         V(1) = V(1)/4D0
         V(2) = V(2)/4D0
         CALL RNDOUT(V,.TRUE.,.TRUE.)
      END IF
C
C  Compute value of the cosine of the reduced angle.
C
      CALL POWER(V,2,VSQ)
C
C  val  = one + vsq * (-od2f + vsq * (od4f + vsq * (-od6f
C        + vsq * (od8f + vsq * (-od10f + vsq * od12f)))))
C
      CALL MULT (VSQ, OD12F, VAL)
      CALL SUB (VAL, OD10F, VAL)
      CALL MULT (VSQ, VAL, VAL)
      CALL ADD (OD8F, VAL, VAL)
      CALL MULT (VSQ, VAL, VAL)
      CALL SUB (VAL, OD6F, VAL)
      CALL MULT (VSQ,VAL, VAL)
      CALL ADD (OD4F, VAL, VAL)
      CALL MULT (VSQ, VAL, VAL)
      CALL SUB (VAL, OD2F, VAL)
      CALL MULT (VSQ, VAL, VAL)
      CALL ADD (ONE, VAL, VAL)
C
C  valt = - v **14 * od14f
C
      CALL POWER (V, 14, VALT)
      CALL MULT (VALT, OD14F, VALT)
      TMP = VALT(2)
      VALT(2) = -VALT(1)
      VALT(1) = -TMP
      CALL RNDOUT(VALT,.TRUE.,.FALSE.)

      ERTRM(1) = VALT(1)
      ERTRM(2) = 0D0
C
      CALL ADD (VAL,ERTRM,VAL)
C
C  Use double angle formulas to get back to original angle in
C  [0, pi/2]. ( val <-- 8val^4 - 8val^2 + 1 )
C
      IF (L2) THEN
         CALL POWER(VAL, 2, TEM)
         CALL SUB  (TEM, ONE, VAL)
         CALL MULT (VAL, TEM, VAL)
         CALL MULT (VAL, EIGHT, VAL)
         CALL ADD  (ONE, VAL, VAL)
      END IF
C
C  Change the sign of the result if the shift was by an odd multiple of
C  pi --
C
      IF (MOD(N,2).NE.0) THEN
         TMP = VAL(1)
         VAL(1) = -VAL(2)
         VAL(2) = -TMP
      END IF
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE REXP(X,VAL)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Kaisheng Du
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C  This routine is used to compute the interval value exp(X).
C  It is assumed that the width of the interval X is small.
C
C  This routine is usually called by the routine IEXP,
C  to compute interval values of endpoints.
C
C  This routine translates the midpoint to [0,1/16], by first making
C  it positive,  then subtracting the integer part,  and finally
C  possibly dividing by 2 a number of times (To translate
C  back to the original interval, it then squares the result a number of
C  times, multiplies by e**N for some N, and possibly takes a
C  reciprocal.)
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2), VAL(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TMP(2)
      INTEGER N
      DOUBLE PRECISION ERTRM(2), G(2), VALT(2)
C
C***********************************************************************
C
C Common block declarations --
C
C
C  This common block holds machine parameters which are set in
C  SIMINI and used here.
C
C  Variable descriptions
C
C  MXULP       (machine epsilon)
C                * (maximum error in ULP's of the floating pt. op's)
C
C  TTINY2      2 * (smallest representable positive machine number)
C                * (maximum error in ULP's of the floating pt. op's)
C
C  TOL0        TTINY2 / MXULP
C
      DOUBLE PRECISION MXULP, TOL0, TTINY2
      COMMON /MACH1/ MXULP, TTINY2, TOL0
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C     DBLE, DMAX1, DMIN1, NINT
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C     ADD, MULT, POWER, RNDOUT, SCLMLT
C
C***********************************************************************
C
C Beginning of executable statements --
C
C   Reduce the arguments with the formula X = G + N /4, where G is
C   between -.25 and .25 --
C
      CALL MULT (FOUR,X,TMP(1))
      N=NINT(TMP(1))
      TMP(1) = DBLE(N)
      TMP(2) = DBLE(N)
      CALL RNDOUT(TMP,.TRUE.,.TRUE.)
      CALL IDIV(TMP,FOUR,TMP)
      CALL SUB(X, TMP, G)
C
C  Compute Taylor series approximation --
C
c     val = one + g*(one + g*(od2f + g*(od3f + g*(od4f + g*(od5f +
c    *     g*(od6f + g*(od7f + g*(od8f +g*(od9f +g*(od10f +g*od11f
c    *     )))))))))) --
C
      CALL MULT (G,OD11F,TMP)
      CALL ADD (OD10F,TMP,TMP)
      CALL MULT (G,TMP,TMP)
      CALL ADD (OD9F,TMP,TMP)
      CALL MULT (G,TMP,TMP)
      CALL ADD (OD8F,TMP,TMP)
      CALL MULT (G,TMP,TMP)
      CALL ADD (OD7F,TMP,TMP)
      CALL MULT (G,TMP,TMP)
      CALL ADD (OD6F,TMP,TMP)
      CALL MULT (G,TMP,TMP)
      CALL ADD (OD5F,TMP,TMP)
      CALL MULT (G,TMP,TMP)
      CALL ADD (OD4F,TMP,TMP)
      CALL MULT (G,TMP,TMP)
      CALL ADD (OD3F,TMP,TMP)
      CALL MULT (G,TMP,TMP)
      CALL ADD (OD2F,TMP,TMP)
      CALL MULT (G,TMP,TMP)
      CALL ADD (ONE,TMP,TMP)
      CALL MULT (G,TMP,TMP)
      CALL ADD (ONE,TMP,VAL)
C
C  Compute the error term and add to the approximation --
C
C     VALT = G**12 * OD12F * A3
C
      CALL POWER (G,12,TMP)
      CALL MULT (TMP,OD12F,TMP)
      CALL MULT (TMP,A3,VALT)
C
      ERTRM(1) = DMIN1(0D0,VALT(1))
      ERTRM(2) = DMAX1(0D0,VALT(2))
C
      CALL ADD (VAL,ERTRM,VAL)
C
C  Translate back to original interval -- val=val*e14**n --
C
      CALL POWER (E14,N,TMP)
      CALL MULT (VAL,TMP,VAL)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE RLOG(XX,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Rebecca Yun
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C
C***********************************************************************
C
C Function --
C
C  This subroutine returns the interval value of the logarithm over the
C  interval XX in RESULT.  It is assumed that XX is relatively small,
C  and that it is possible.  The usual use of this routine is from the
C  routine ILOG, which checks the argument values and calls this routine
C  to get rigorous bounds on values at the end points.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION XX(2), RESULT(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      INTEGER K
      DOUBLE PRECISION ERRTRM(2), VAL(2), X(2), XI(2), Y(2)
C
C
C***********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C     DBLE, INT, LOG
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C   ADD, IDIV, MULT, POWER, RNDOUT, SUB
C
C***********************************************************************
C
C Beginning of executable statements --
C
      X(1) = XX(1)
      X(2) = XX(2)
C
C  Argument reduction: rewrite X <-- R^K * X
C               where  1/R <= X <= R = EXP(1/16)  ---
C
C   It is O.K. to use the Fortran LOG function here, since it it not
C   critical that X be exactly between 1/R and R ---
C
      IF (X(1).GE.ONE(1)) THEN
         K=INT(LOG((X(1)+X(2))/TWO(1))*SXTEEN(1))
      ELSE
         K = INT(LOG((X(1)+X(2))/TWO(1))*SXTEEN(1))-1
      END IF
C
      IF (K.LT.JTINY2) K=JTINY2
C
C    X <-- X/(R^K) ---
C
      CALL POWER(ESXTNT,K,VAL)
      CALL IDIV(X,VAL,X)
C
C  Initialize the values ---
C
      CALL SUB (X,ONE,Y)
C
      RESULT(1) = ZERO(1)
      RESULT(2) = ZERO(2)
C
C  Use Horner's scheme to evaluate the thirteenth degree Taylor
C  polynomial centered at one --
C
      CALL MULT(Y,THRTTH,RESULT)
      CALL SUB(RESULT,TWLVTH,RESULT)
      CALL MULT(Y,RESULT,RESULT)
      CALL ADD(ELEVTH,RESULT,RESULT)
      CALL MULT(Y,RESULT,RESULT)
      CALL SUB(RESULT,TENTH,RESULT)
      CALL MULT(Y,RESULT,RESULT)
      CALL ADD(NINTH,RESULT,RESULT)
      CALL MULT(Y,RESULT,RESULT)
      CALL SUB(RESULT,EIGHTH,RESULT)
      CALL MULT(Y,RESULT,RESULT)
      CALL ADD(SEVNTH,RESULT,RESULT)
      CALL MULT(Y,RESULT,RESULT)
      CALL SUB(RESULT,SIXTH,RESULT)
      CALL MULT(Y,RESULT,RESULT)
      CALL ADD(FIFTH,RESULT,RESULT)
      CALL MULT(Y,RESULT,RESULT)
      CALL SUB(RESULT,FOURTH,RESULT)
      CALL MULT(Y,RESULT,RESULT)
      CALL ADD(THIRD,RESULT,RESULT)
      CALL MULT(Y,RESULT,RESULT)
      CALL SUB(RESULT,OD2F,RESULT)
      CALL MULT(Y,RESULT,RESULT)
      CALL ADD(ONE,RESULT,RESULT)
      CALL MULT(Y,RESULT,RESULT)
C
C  Compute the error term ---
C
      IF (X(1).LT.ONE(1)) THEN
         XI(1) = X(1)
      ELSE
         XI(1) = ONE(1)
      END IF
C
C
      IF(X(2).GT.ONE(2)) THEN
         XI(2) = X(2)
      ELSE
         XI(2) = ONE(2)
      END IF
C
C    ERRTRM <-- Y^14 / [14*XI^14]
C
      CALL IDIV(Y,XI,ERRTRM)
      CALL POWER(ERRTRM,14,ERRTRM)
      CALL MULT(ERRTRM,FORTTH,ERRTRM)
C
C    RESULT <-- RESULT - ERRTRM
C
      CALL SUB (RESULT,ERRTRM,RESULT)
C
C  Undo the argument reduction: RESULT <-- RESULT+ K/16 --
C
      Y(1) = DBLE(K)
      Y(2) = Y(1)
      CALL RNDOUT(Y,.TRUE.,.TRUE.)
      CALL MULT(Y,SXTNTH,Y)
      CALL ADD (RESULT,Y,RESULT)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE RSQRT(X,VAL)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Kaisheng Du
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C
C***********************************************************************
C
C Function --
C
C  This routine returns the square root of the interval X in VAL.  It is
C  assumed that the interval X has relatively small width, and that its
C  lower bound is positive.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2), VAL(2)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION AM1(2), TMP1(2), TMP2(2), ERRTRM(2)
      DOUBLE PRECISION XTMP(2), XMID(2), XOLD(2)
      DOUBLE PRECISION CMIN, CMAX, T
      LOGICAL L, LSMALL
      INTEGER ITER, N
C
C***********************************************************************
C
C Common blocks --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines --
C
C   LOG10, MAX, MIN, NINT
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C   ADD, IDIV, MULT, POWER, RNDOUT, SUB
C
C***********************************************************************
C
C Beginning of executable statements --
C
      XTMP(1) = X(1)
      XTMP(2) = X(2)
C
C  Reduce to between 1/5 and 5 by dividing by the appropriate power
C  of 10.  Use the Fortran logarithm function to get the power.  This is
C  O.K., provided the argument to this function is within range,
C  since it is not crucial that the argument be exactly in [1/5,5] --
C
      N = NINT( LOG10( (XTMP(1)+XTMP(2))/2D0 ) )
C
C  Treat values between the smallest number which can be reciprocated
C  and the smallest representable number (if these two values are
C  different) as a special case --
C
      IF (N.LT.ITINY2) THEN
         N=ITINY2
         XTMP(1) = TINY2
         XTMP(2) = TINY2
         LSMALL = .TRUE.
      ELSE
         LSMALL = .FALSE.
      END IF
      CALL POWER(TEN,-N,TMP1)
      CALL MULT(XTMP,TMP1,XTMP)
C
      L = .FALSE.
C
      IF (XTMP(2).LT.ONE(1)) L = .TRUE.
C
C  Take the reciprocal if initial value is greater than one, in
C  order to have stable behavior in the interval Newton method --
C
      IF (L .AND. .NOT.LSMALL) THEN
         T = ONE(1)/XTMP(2)
         XTMP(2) = ONE(2)/XTMP(1)
         XTMP(1) = T
         CALL RNDOUT(XTMP,.TRUE.,.TRUE.)
      END IF
C
C  The reduced argument can be less than zero, depending on the
C  rounding properties and size of the original argument --
C
      IF (XTMP(1).LE.ZERO(2)) THEN
         WRITE(6,*) 'IN RSQRT, ARGUMENT WAS DETERMINED TO BE TOO'
         WRITE(6,*) 'LARGE OR TOO SMALL.'
         STOP
      END IF
C
C  Make an initial estimate for the result using a degree two
C  Taylor series with remainder term, provided the interval is
C  sufficiently bounded away from zero
C  (i.e. V <-- 1 + 1/2 (c-1) - 1/8 (c-1)^2 + 1/32 I (c-1)^3 )
C
         VAL(1) = ONE(1)
         VAL(2) = ONE(2)
         CALL SUB(XTMP,ONE,AM1)
         CALL MULT(AM1,OD2F,TMP1)
         CALL ADD(VAL,TMP1,VAL)
         CALL POWER(AM1,2,TMP1)
         CALL MULT(TMP1,EIGHTH,TMP1)
         CALL SUB(VAL,TMP1,VAL)
C
         CMIN = MIN(XTMP(1),ONE(1))
         CMAX = MAX(XTMP(2),ONE(2))
         TMP1(1) = ONE(1)/CMAX
         TMP1(2) = ONE(2)/CMIN
         CALL RNDOUT(TMP1,.TRUE.,.TRUE.)
         CALL POWER(TMP1,2,TMP2)
         CALL POWER(TMP1,3,TMP1)
         ERRTRM(1) = MIN(TMP1(1),TMP2(1))
         ERRTRM(2) = MAX(TMP1(2),TMP2(2))
         CALL MULT(ERRTRM,SXTNTH,ERRTRM)
         CALL POWER(AM1,3,TMP1)
         CALL MULT(ERRTRM,TMP1,ERRTRM)
C
         CALL ADD(ERRTRM,VAL,VAL)
         VAL(1) = MAX(VAL(1),TINY2)
C
C  Do an interval Newton iteration until it becomes stationary --
C
      DO 10    ITER = 1,100
C
         XOLD(1) = VAL(1)
         XOLD(2) = VAL(2)
         XMID(1) = (VAL(1)+VAL(2))/2D0
         XMID(2) = XMID(1)
C
C       VAL <-- MID(VAL) - (MID(VAL)^2-A) / (TWO*VAL) --
C
         CALL POWER (XMID,2,TMP1)
         CALL SUB (TMP1,XTMP,TMP1)
         CALL MULT (TWO,VAL,TMP2)
         CALL IDIV(TMP1,TMP2,TMP2)
         CALL SUB (XMID,TMP2,VAL)
C
         VAL(1) = MAX(VAL(1),XOLD(1))
         VAL(2) = MIN(VAL(2),XOLD(2))
C
         IF (VAL(1).EQ.XOLD(1) .AND. VAL(2).EQ.XOLD(2)) GO TO 20
C
   10 CONTINUE
   20 CONTINUE
C
C  Take the reciprocal of the result, if the argument was
C  reciprocated --
C
      IF (L.AND. .NOT. LSMALL) THEN
         T = VAL(1)
         VAL(1) = ONE(1)/VAL(2)
         VAL(2) = ONE(2)/T
         CALL RNDOUT(VAL,.TRUE.,.TRUE.)
      END IF
C
C  Transform back to the original position by multiplying by the
C  appropriate power of the square root of 10 --
C
      CALL POWER(SQT10,N,TMP1)
      CALL MULT(TMP1,VAL,VAL)
C
      IF (LSMALL) VAL(1)=ZERO(1)
C
      RETURN
      END

c*** miscmach.f
      SUBROUTINE ERRTST(X)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Kaisheng Du
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C
C***********************************************************************
C
C Function --
C
C  This routine prints error conditions which have been signalled
C  in other routines.  It halts execution, changes X, or returns,
C  depending on the particular error and on the way the error handling
C  control flags are set.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION X(2)
C
C***********************************************************************
C
C Argument descriptions -- (INPUT  = set on entry and not alterable)
C                          (OUTPUT = to be set by the routine)
C                          (I/O    = set on entry but alterable)
C
C  X  is an interval which depends on the error set (I/O)
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION T
C
C***********************************************************************
C
C Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Beginning of executable statements --
C
      ISIG = 0
C
      IF (IERR.EQ.1) THEN
         ISIG = 2
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *    'SEVERITY 2 ERROR:  LOWER BOUND ON INTERVAL IS GREATER',
     *    ' THAN UPPER BOUND'
            WRITE(IERPUN,100) 'X:',X
         END IF
         T = X(1)
         X(1) = X(2)
         X(2) = T
      ELSE IF (IERR.EQ.2) THEN
         ISIG = 1
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *    'SEVERITY 1 ERROR: LOWER BOUND ON X FOR IEXP WOULD UNDERFLOW'
         END IF
      ELSE IF (IERR.EQ.3) THEN
         ISIG = 2
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *    'SEVERITY 2 ERROR: LOWER BOUND ON X FOR IEXP WOULD OVERFLOW'
         END IF
      ELSE IF (IERR.EQ.4) THEN
         ISIG = 2
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *    'SEVERITY 2 ERROR: UPPER BOUND ON X FOR IEXP WOULD OVERFLOW'
         END IF
      ELSE IF (IERR.EQ.5) THEN
         ISIG = 0
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *    'WARNING: Loss of accuracy in trig function due to the',
     *    ' argument range.'
            WRITE(IERPUN,*) 'X:',X
         END IF
      ELSE IF (IERR.EQ.6) THEN
         ISIG = 2
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *    'SEVERITY 2 ERROR: ZERO IN DENOMINATOR IN ORDINARY INTERVAL',
     *    ' DIVISION.'
            WRITE(IERPUN,*) 'DENOMINATOR:',X
         END IF
      ELSE IF (IERR.EQ.7) THEN
         ISIG = 3
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *    'SEVERITY 3 ERROR: ARGUMENT CONTAINS ZERO IN ELEMENTARY',
     *    ' FUNCTION.'
            WRITE(IERPUN,*) 'ARGUMENT:',X
         END IF
      ELSE IF (IERR.EQ.8) THEN
         ISIG = 2
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *    'SEVERITY 2 ERROR: NEGATIVE POWER OF A ZERO-CONTAINING'
            WRITE(IERPUN,*)
     *    'INTERVAL IS UNDEFINED IN ORDINARY INTERVAL ARITHMETIC.'
            WRITE(IERPUN,*) 'ARGUMENT:',X
         END IF
      ELSE IF (IERR.EQ.9) THEN
         ISIG = 3
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *    'SEVERITY 3 ERROR: ARGUMENT TO INVERSE TRIG FUNCTION'
            WRITE(IERPUN,*)
     *    'MAY CONTAIN NUMBERS WHICH ARE GREATER THAN 1.'
            WRITE(IERPUN,*) 'ARGUMENT:',X
         END IF
      ELSE IF (IERR.EQ.10) THEN
         ISIG = 3
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *    'SEVERITY 3 ERROR: ARGUMENT TO INVERSE TRIG FUNCTION'
            WRITE(IERPUN,*)
     *    'MAY CONTAIN NUMBERS WHICH ARE LESS THAN -1.'
            WRITE(IERPUN,*) 'ARGUMENT:',X
         END IF
      ELSE IF (IERR.EQ.11) THEN
         ISIG = 3
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *    'SEVERITY 3 ERROR: APPROXIMATING SERIES FOR REDUCED ARGUMENT',
     *    ' DID NOT CONVERGE.'
            WRITE(IERPUN,*) 'CURRENT TERM IN SERIES:',X
         END IF
      ELSE IF (IERR.EQ.12) THEN
         ISIG = 3
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*) 'INTERNAL ERROR;  NEGATIVE ARGUMENT:'
            WRITE(IERPUN,*) X
            WRITE(IERPUN,*) 'POSSIBLY, AN ARRAY WAS DIMENSIONED',
     *                   ' INCORRECTLY OR MEMORY WAS NOT PROPERLY'
            WRITE(IERPUN,*) 'ALLOCATED.  IF THE ERROR PERSISTS, THEN:'
            WRITE(IERPUN,*) 'Contact R. Baker Kearfott, Dept. Math.,'
            WRITE(IERPUN,*) 'USL Box 4-1010, Lafayette, LA 70504-1010.'
            WRITE(IERPUN,*) 'email: rbk@usl.edu'
         END IF
      ELSE IF (IERR.EQ.13) THEN
         ISIG = 0
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *        'Warning:  Disjoint intervals in intersection.'
            X(1) = POSINF
            X(2) = NEGINF
         END IF
      ELSE IF (IERR.EQ.14) THEN
         ISIG = 1
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *        'Power function with operands containing 0^0 occured.'
            WRITE(IERPUN,*)
     *        'Result is sent to [NEGINF,POSINF].'
         END IF
      ELSE IF (IERR.EQ.15) THEN
         ISIG = 1
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*)
     *        'Power function with operands of the form'
            WRITE(IERPUN,*)
     *        '[0,pos]^[pos,pos] occurred. Result is set to'
            WRITE(IERPUN,*)
     *        '[pos,POSINF].'
         END IF
      ELSE
         ISIG=3
         IF (IPRTCL.LE.ISIG) THEN
            WRITE(IERPUN,*) 'INTERNAL ERROR;  UNKNOWN ERROR TYPE,',IERR,
     *                      ' IN ERRTST.'
            WRITE(IERPUN,*) 'POSSIBLY, AN ARRAY WAS DIMENSIONED',
     *                   ' INCORRECTLY OR MEMORY WAS NOT PROPERLY'
            WRITE(IERPUN,*) 'ALLOCATED.  IF THE ERROR PERSISTS, THEN:'
            WRITE(IERPUN,*) 'Contact R. Baker Kearfott, Dept. Math.,'
            WRITE(IERPUN,*) 'USL Box 4-1010, Lafayette, LA 70504-1010.'
            WRITE(IERPUN,*) 'email: rbk@usl.edu'
         END IF
      END IF

C
      IF (IPRTCL.LE.ISIG) THEN
         IF (IROUT.EQ.1) THEN
            WRITE(IERPUN,*) 'Error occurred in routine IEXP.'
         ELSE IF (IROUT.EQ.2) THEN
            WRITE(IERPUN,*) 'Error occurred in routine ICOS.'
         ELSE IF (IROUT.EQ.3) THEN
            WRITE(IERPUN,*) 'Error occurred in routine IDIV.'
         ELSE IF (IROUT.EQ.4) THEN
            WRITE(IERPUN,*) 'Error occurred in routine ILOG.'
         ELSE IF (IROUT.EQ.5) THEN
            WRITE(IERPUN,*) 'Error occurred in routine ISQRT.'
         ELSE IF (IROUT.EQ.6) THEN
            WRITE(IERPUN,*) 'Error occurred in routine ISINH.'
         ELSE IF (IROUT.EQ.7) THEN
            WRITE(IERPUN,*) 'Error occurred in routine POWER.'
         ELSE IF (IROUT.EQ.8) THEN
            WRITE(IERPUN,*) 'Error occurred in routine IACOS.'
         ELSE IF (IROUT.EQ.9) THEN
            WRITE(IERPUN,*) 'Error occurred in routine IASIN.'
         ELSE IF (IROUT.EQ.10) THEN
            WRITE(IERPUN,*) 'Error occurred in routine ASNSER, ',
     *                      'an auxiliary routine called by IASIN.'
         ELSE IF (IROUT.EQ.11) THEN
            WRITE(IERPUN,*) 'Error occurred in routine IATAN.'
         ELSE IF (IROUT.EQ.12) THEN
            WRITE(IERPUN,*) 'Error occurred in routine ATNSER, ',
     *                      'an auxiliary routine called by IATAN.'
         ELSE IF (IROUT.EQ.13) THEN
            WRITE(IERPUN,*) 'Error occurred in routine ICAP, ',
     *                      'a utility function routine.'
         ELSE IF (IROUT.EQ.14) THEN
            WRITE(IERPUN,*) 'Error occurred in routine IIPOWR.'
         ELSE IF (IROUT.EQ.15) THEN
            WRITE(IERPUN,*) 'Error occurred in routine IVL2, ',
     *                      'a utility function routine.'
         ELSE
            ISIG = 3
            WRITE(IERPUN,*) 'INTERNAL ERROR;  UNKNOWN ROUTINE NUMBER,',
     *                      IROUT, ' IN ERRTST.'
            WRITE(IERPUN,*) 'POSSIBLY, AN ARRAY WAS DIMENSIONED',
     *                   ' INCORRECTLY OR MEMORY WAS NOT PROPERLY'
            WRITE(IERPUN,*) 'ALLOCATED.  IF THE ERROR PERSISTS, THEN:'
            WRITE(IERPUN,*) 'Contact R. Baker Kearfott, Dept. Math.,'
            WRITE(IERPUN,*) 'USL Box 4-1010, Lafayette, LA 70504-1010.'
            WRITE(IERPUN,*) 'email: rbk@usl.edu'
         END IF
      END IF
C
      IF (ISIG.GE.ISEVER) STOP
C
      RETURN
C
  100 FORMAT(1X,A,3X,D23.15,2X,D23.15)
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE SIMINI
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C
C         and
C
C   Kaisheng Du
C
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C Part of the interval elementary function library
C
C
C***********************************************************************
C
C Called by -- GENBIS
C
C***********************************************************************
C
C Function --
C
C  This routine sets certain machine parameters used to simulate
C  directed roundings in a reasonably transportable way.  In
C  particular, it sets the amount by which to decrease the left endpoint
C  and increase the right endpoint of an interval computed using usual
C  floating point arithmetic to guarantee that the resulting interval
C  will contain the result which would have been obtained with true
C  interval arithmetic.
C
C
C  In addition to setting certain parameters, certain constants, such as
C  pi and the natural logarithm base e, are set here.  The data
C  for the representation for these constants which appears here
C  should be accurate at least to the number of significant figures
C  present in the machine.  If it is possible to input a binary form
C  for the double precision representation of this data, then that
C  form should be given to be correct to all representable digits.
C
C  This routine assumes that the four elementary floating point
C  operations, and unary negation, will give results with a maximum
C  error of one ULP (unit in the last place).  If this is not so, change
C  the value of MAXERR in the data statement below to the maximum number
C  of ULP's by which a floating point result can differ from the true
C  result (for '+', '-', '*', '/' and conversion from integer
C  to double precision).
C
C  An additional assumption is that the standard routines MIN and MAX
C  return exact values corresponding to one of their arguments.
C
C  When determining the maximum error of the result A op B, where
C  A and B are floating point numbers, we assume that A and B are
C  represented exactly.  For example, if A and B are almost equal,
C  then it is not unreasonable to assume that A - B, where the
C  subtraction is a floating point subtraction, is within a few
C  units of the last place of the true result.
C
C  Throughout the elementary function routines, it is assumed that
C  storing the double precision expressions 0D0 leads to an exact
C  floating point representation of 0. It is also assumed that a
C  floating point assignment statement (such as A=B) causes exactly the
C  same value to be in A as in B.
C
C  Note:  On some machines, an underflow naturally occurs when this
C         routine is executed.  (It would happen in the computation of
C         TINY2.)  This is not a problem.
C
C  If SIMINI is installed correctly, then the conclusions this
C  package prints out will have mathematical rigor.
C
C***********************************************************************
C
C Common block declarations --
C
      DOUBLE PRECISION MXULP, TTINY2, TOL0
      COMMON /MACH1/ MXULP, TTINY2, TOL0
C
C  This common block holds machine parameters which are set here
C  and used in RNDOUT.
C
C  Variable descriptions
C
C  MXULP       (machine epsilon)
C                * (maximum error in ULP's of the floating pt. op's)
C
C  TTINY2      2 * (smallest representable positive machine number)
C                * (maximum error in ULP's of the floating pt. op's)
C
C  TOL0        TTINY2 / MXULP
C
      DOUBLE PRECISION TINY, TEST
      COMMON /MACH2/ TINY, TEST
C
C  Common block MACH2 stores machine constants used in RNDOUT.  TINY
C  is the smallest representable machine number, while TEST is the
C  smallest number which can be safely rounded to something other than
C  zero.
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      INTEGER ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
      COMMON /ERFLGS/ ISIG, IERR, IROUT, IPRTCL, ISEVER, IERPUN
C
C The above common block stores signalling information for error
C conditions.  In particular,
C
C ISIG   is set to 0 at the beginning of SIMINI, and is reset
C        to the severity level of the error (1, 2, or 3) when an error
C        condition occurs.  The user may reset the flag to zero after an
C        error condition, depending on the error, if ISEVER is set to
C        allow execution after an error of its severity.
C
C IERR   is the number of the error condition, if an error occurred in
C        the last routine in INTLIB with error checking.  If no errors
C        occurred in the last such routine called, then IERR is zero.
C        The specific error conditions associated with particular error
C        numbers is defined in the routine ERRTST.
C
C IROUT  is the code number of the package routine in which the error
C        occurred
C
C IPRTCL controls the level of error which is printed.  IPRCTL=0 prints
C        all levels, while IPRCTL=1 prints only errors of level 1 or
C        greater.  If IPRTCL=4, then no error information is printed.
C
C ISEVER gives the error level which will stop execution.  ISEVER=0
C        causes any error to stop execution, while ISEVER>=3 causes only
C        errors of severity 3 to stop execution.  Generally, severity 3
C        errors correspond to when it is impossible to assign a result
C        with any meaningful interpretation.
C
C IERPUN is the Fortran unit number to which errors should be printed.
C
C***********************************************************************
C
C Fortran-supplied functions and subroutines -- DBLE, INT, MAX
C
C***********************************************************************
C
C Package-supplied functions and subroutines --
C
C  D1MACH, I1MACH (the SLATEC routines for machine constants)
C
C  RNDOUT
C
      DOUBLE PRECISION D1MACH
      INTEGER I1MACH
C
C***********************************************************************
C
C User-supplied functions and subroutines -- none
C
C***********************************************************************
C
C I/O functions -- none
C
C***********************************************************************
C
C Internal variable declarations --
C
      DOUBLE PRECISION TMP(2)
C
C***********************************************************************
C
C Internal constant declarations --
C
      INTEGER MAXERR
      DATA MAXERR/1/
C
C***********************************************************************
C
C Internal constant descriptions --
C
C  MAXERR      is the maximum number of ULP's (units in the last
C              place) by which a result of one of the floating point
C              operations (+, -, *, /, ** N) can differ from the
C              true result.  (See explanation above.)
C
C********** WARNING: The value of MAXERR is machine dependent and
C                    must be manually set.
C
C***********************************************************************
C
C Beginning of executable statements --
C
      TINY = D1MACH(1)
      MXULP = DBLE(MAXERR) * D1MACH(4)
      TEST = TINY/(1D0-3D0*MXULP)
      TTINY2 = 2D0 * DBLE(MAXERR) * TINY
      TOL0 = TTINY2 / MXULP
C
      TMP(1) = 1D0/D1MACH(2)
      TMP(2) = TMP(1)
      CALL RNDOUT (TMP,.TRUE.,.TRUE.)
      TINY2 = MAX(TINY,TMP(2))
      CBTEP = (6D0*D1MACH(4))**(1D0/3D0)
      ITINY2 = INT(LOG10(TINY2))
      JTINY2 = 16*INT(LOG(TINY2))
C
      MAXX = DBLE(I1MACH(9))
C
      MXLGM1 = LOG(D1MACH(2)) -LOG(4D0) - 1D0
      NEGINF = -D1MACH(2)
      POSINF =  D1MACH(2)
C
      A(1) = 0.31830988618379067153776752674502864D+00
      A(2) = 0.31830988618379067153776752674502864D+00
      CALL RNDOUT(A,.TRUE.,.TRUE.)
C
      PI(1) = 0.31415926535897932384626433832795028D+01
      PI(2) = 0.31415926535897932384626433832795028D+01
      CALL RNDOUT(PI,.TRUE.,.TRUE.)

      E(1) =  0.27182818284590452353602874713526625D+01
      E(2) =  0.27182818284590452353602874713526625D+01
      CALL RNDOUT(E,.TRUE.,.TRUE.)
C
      PI2(1) = 0.15707963267948966192313216916397499D+01
      PI2(2) = 0.15707963267948966192313216916397499D+01
      CALL RNDOUT(PI2,.TRUE.,.TRUE.)
C
      PI3(1) = 1.0471975511965977461542144610931676D0
      PI3(2) = 1.0471975511965977461542144610931676D0
      CALL RNDOUT(PI3,.TRUE.,.TRUE.)
C
      PI4(1) = 0.7853981633974483096156608458198757D0
      PI4(2) = 0.7853981633974483096156608458198757D0
      CALL RNDOUT(PI4,.TRUE.,.TRUE.)
C
      PI6(1) = 0.5235987755982988730771072305465838D0
      PI6(2) = 0.5235987755982988730771072305465838D0
      CALL RNDOUT(PI6,.TRUE.,.TRUE.)
C
      PI8(1) = 0.39269908169872415480783042290993785D+00
      PI8(2) = 0.39269908169872415480783042290993785D+00
      CALL RNDOUT(PI8,.TRUE.,.TRUE.)
C
      E14(1) = 0.12840254166877414840734205680624368D+01
      E14(2) = 0.12840254166877414840734205680624368D+01
      CALL RNDOUT(E14,.TRUE.,.TRUE.)
C
      A3(1) = 0.11331484530668263168290072278117947D+01
      A3(2) = 0.11331484530668263168290072278117947D+01
      CALL RNDOUT(A3,.TRUE.,.TRUE.)
C
      ONE  (1) = 1D0
      OD2F (1) = 1D0 /           2D0
      OD3F (1) = 1D0 /           6D0
      OD4F (1) = 1D0 /          24D0
      OD5F (1) = 1D0 /         120D0
      OD6F (1) = 1D0 /         720D0
      OD7F (1) = 1D0 /        5040D0
      OD8F (1) = 1D0 /       40320D0
      OD9F (1) = 1D0 /      362880D0
      OD10F(1) = 1D0 /     3628800D0
      OD11F(1) = 1D0 /    39916800D0
      OD12F(1) = 1D0 /   479001600D0
      OD14F(1) = 1D0 / 87178291200D0
C
      ONE  (2) = ONE  (1)
      OD2F (2) = OD2F (1)
      OD3F (2) = OD3F (1)
      OD4F (2) = OD4F (1)
      OD5F (2) = OD5F (1)
      OD6F (2) = OD6F (1)
      OD7F (2) = OD7F (1)
      OD8F (2) = OD8F (1)
      OD9F (2) = OD9F (1)
      OD10F(2) = OD10F(1)
      OD11F(2) = OD11F(1)
      OD12F(2) = OD12F(1)
      OD14F(2) = OD14F(1)
C
      CALL RNDOUT(  ONE,.TRUE.,.TRUE.)
      CALL RNDOUT( OD2F,.TRUE.,.TRUE.)
      CALL RNDOUT( OD4F,.TRUE.,.TRUE.)
      CALL RNDOUT( OD6F,.TRUE.,.TRUE.)
      CALL RNDOUT( OD8F,.TRUE.,.TRUE.)
      CALL RNDOUT(OD10F,.TRUE.,.TRUE.)
      CALL RNDOUT(OD12F,.TRUE.,.TRUE.)
      CALL RNDOUT(OD14F,.TRUE.,.TRUE.)
C
      EIGHT(1) = 8D0
      EIGHT(2) = 8D0
      CALL RNDOUT(EIGHT,.TRUE.,.TRUE.)
C
      ZERO(1) = 0D0
      ZERO(2) = 0D0
C
      TWO(1) = 2D0
      TWO(2) = 2D0
      CALL RNDOUT(TWO,.TRUE.,.TRUE.)
C
      THREE(1) = 3D0
      THREE(2) = 3D0
      CALL RNDOUT(THREE,.TRUE.,.TRUE.)
C
      FOUR(1) = 4D0
      FOUR(2) = 4D0
      CALL RNDOUT(FOUR,.TRUE.,.TRUE.)
C
      NINE(1) = 9D0
      NINE(2) = 9D0
      CALL RNDOUT(NINE,.TRUE.,.TRUE.)
C
      SXTNTH(1) = 1D0/16D0
      SXTNTH(2) = SXTNTH(1)
      CALL RNDOUT(SXTNTH,.TRUE.,.TRUE.)
C
      TEN(1) = 10D0
      TEN(2) = 10D0
      CALL RNDOUT(TEN,.TRUE.,.TRUE.)
C
      TWOT7(1) = 27D0
      TWOT7(2) = 27D0
      CALL RNDOUT(TWOT7,.TRUE.,.TRUE.)
C
      SQT10(1) = 3.1622776601683793319988935444327185D0
      SQT10(2) = 3.1622776601683793319988935444327185D0
      CALL RNDOUT(SQT10,.TRUE.,.TRUE.)
C
      ESXTNT(1) = 1.0644944589178594295633905946428909D0
      ESXTNT(2) = 1.0644944589178594295633905946428909D0
      CALL RNDOUT(ESXTNT,.TRUE.,.TRUE.)
C
      SXTEEN(1) = 16D0
      SXTEEN(2) = 16D0
      CALL RNDOUT(SXTEEN, .TRUE.,.TRUE.)
C
      THIRD(1) = 1D0/3D0
      THIRD(2) = 1D0/3D0
      CALL RNDOUT(THIRD,.TRUE.,.TRUE.)
C
      FOURTH(1) = .25D0
      FOURTH(2) = .25D0
      CALL RNDOUT(FOURTH,.TRUE.,.TRUE.)
C
      FIFTH(1) = .2D0
      FIFTH(2) = .2D0
      CALL RNDOUT(FIFTH,.TRUE.,.TRUE.)
C
      SIXTH(1) = 1D0/6D0
      SIXTH(2) = 1D0/6D0
      CALL RNDOUT(SIXTH,.TRUE.,.TRUE.)
C
      SEVNTH(1) = 1D0/7D0
      SEVNTH(2) = 1D0/7D0
      CALL RNDOUT(SEVNTH,.TRUE.,.TRUE.)
C
      EIGHTH(1) = .125D0
      EIGHTH(2) = .125D0
      CALL RNDOUT(EIGHTH,.TRUE.,.TRUE.)
C
      NINTH(1) = 1D0/9D0
      NINTH(2) = 1D0/9D0
      CALL RNDOUT(NINTH,.TRUE.,.TRUE.)
C
      TENTH(1) = .1D0
      TENTH(2) = .1D0
      CALL RNDOUT(TENTH,.TRUE.,.TRUE.)
C
      ELEVTH(1) = 1D0/11D0
      ELEVTH(2) = 1D0/11D0
      CALL RNDOUT(ELEVTH,.TRUE.,.TRUE.)
C
      TWLVTH(1) = 1D0/12D0
      TWLVTH(2) = 1D0/12D0
      CALL RNDOUT(TWLVTH,.TRUE.,.TRUE.)
C
      THRTTH(1) = 1D0/13D0
      THRTTH(2) = 1D0/13D0
      CALL RNDOUT(THRTTH,.TRUE.,.TRUE.)
C
      FORTTH(1) = 1D0/14D0
      FORTTH(2) = 1D0/14D0
      CALL RNDOUT(FORTTH,.TRUE.,.TRUE.)
C
      TT7TH(1) = 1D0/27D0
      TT7TH(2) = 1D0/27D0
      CALL RNDOUT(TT7TH,.TRUE.,.TRUE.)
C
      SQT3(1) = 1.7320508075688772935274463415058724D0
      SQT3(2) = 1.7320508075688772935274463415058724D0
      CALL RNDOUT(SQT3,.TRUE.,.TRUE.)
C
      ODSQT3(1) = 0.57735026918962576450914878050195746D0
      ODSQT3(2) = 0.57735026918962576450914878050195746D0
      CALL RNDOUT(ODSQT3,.TRUE.,.TRUE.)
      CALL SCLMLT(1D0+100D0*MXULP,ODSQT3,ODSQT3)
C
C  Set default values for the error checking routine --
C
      ISIG = 0
      IERR = 0
      IPRTCL = 0
      ISEVER = 3
      IERPUN = 6
C
      RETURN
      END
c*** tstprogs.f

      PROGRAM TSTDRV
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
      PARAMETER(IOUTUN=6)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   December 22, 1992
C
C The main test routine driver for INTLIB
C
C***********************************************************************
C
C  Package routines directly called --
C
C     TIACOS, TIACOT, TIASIN, TIATAN, TICOS,  TIEXP, TIIPWR, TILOG,
C     TINPWR, TISIN,  TISINH, TISQRT, TIUTIL
C
C***********************************************************************
C
C  Beginning of executable statements --
C
C  Change the following statement as appropriate for different systems-
C
      OPEN(IOUTUN,FILE='INTLIBTS.OUT')
C
      WRITE(6,*) 'TEST OF ROUTINE IACOS FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TIACOS(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TEST OF ROUTINE IACOT FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TIACOT(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TEST OF ROUTINE IASIN FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TIASIN(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TEST OF ROUTINE IATAN FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TIATAN(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TEST OF ROUTINE ICOS FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TICOS(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TEST OF ROUTINE IEXP FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TIEXP(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TEST OF ROUTINE IIPOWR FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TIIPWR(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TEST OF ROUTINE ILOG FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TILOG(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TEST OF ROUTINE POWER FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TINPWR(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TEST OF ROUTINE ISIN FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TISIN(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TEST OF ROUTINE ISINH FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TISINH(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TEST OF ROUTINE ISQRT FOLLOWS'
      WRITE(6,*)
      WRITE(6,*)
      CALL TISQRT(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
C
      WRITE(6,*) 'TESTS OF THE UTILITY ROUTINES FOLLOW'
      WRITE(6,*)
      WRITE(6,*)
      CALL TIUTIL(IOUTUN)
      WRITE(6,*)
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
     * '***************************************************************'
      WRITE(6,*)
      WRITE(6,*)
      WRITE(6,*) 'END OF TESTS.'
C
      STOP
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TIACOS(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   July 6, 1992
C
C A test routine for the interval elementary function library
C
C***********************************************************************
C
C  Routine tested --  IACOS
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DACOS, MAX, MIN
C
C***********************************************************************
C
C  Package routines called --
C
C     D1MACH, EVAL, IACOS, IDIV, RNDOUT, SIMINI
C
      DOUBLE PRECISION D1MACH
C
C***********************************************************************
C
C  Variables --
C
      DOUBLE PRECISION X(2), RMAX, RELMAX, ABSMAX
C
C***********************************************************************
C
C  Functions tested --
C
      EXTERNAL IACOS
      INTRINSIC DACOS
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR, ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      INTEGER I
      DOUBLE PRECISION XR(2,20), R1(20), R2(20)
C
      DATA R1/
     *  0.02705383300781D0,  0.38760375976563D0,
     *  0.41886901855469D0,  0.96777343750000D0,
     *  0.92518615722656D0,  0.02670288085938D0,
     *  0.35655212402344D0,  0.36712646484375D0,
     *  0.47663879394531D0,  0.55740356445313D0,
     *  0.87724304199219D0,  0.30651855468750D0,
     *  0.85328674316406D0,  0.83908081054688D0,
     *  0.27781677246094D0,  0.27032470703125D0,
     *  0.47700500488281D0,  0.98110961914063D0,
     *  0.10514831542969D0,  0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,  0.34286499023438D0,
     *  0.15611267089844D0,  0.45867919921875D0,
     *  0.40315246582031D0,  0.53372192382813D0,
     *  0.47758483886719D0,  0.90197753906250D0,
     *  0.79933166503906D0,  0.41305541992188D0,
     *  0.36643981933594D0,  0.80718994140625D0,
     *  0.63008117675781D0,  0.09024047851563D0,
     *  0.36955261230469D0,  0.90869140625000D0,
     *  0.56727600097656D0,  0.92465209960938D0,
     *  0.28379821777344D0,  0.19085693359375D0/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK = .TRUE.
C
      CALL SIMINI
C
      RMAX = ONE(2)
C
      DO 10 I = 1,20
         XR(1,I) = -1D0 + 2D0*MIN(R1(I),R2(I))
         XR(2,I) = -1D0 + 2D0*MAX(R1(I),R2(I))
   10 CONTINUE
C
C [0, 0]
C
      X(1) = 0D0
      X(2) = 0D0
      CALL EVAL(RMAX,IOUTUN,IACOS,DACOS,X)
C
C [.5,.5]
C
      X(1) = .5D0
      X(2) = .5D0
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,IACOS,DACOS,X)
C
C [-.5,-.5]
C
      X(1) = -.5D0
      X(2) = -.5D0
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,IACOS,DACOS,X)
C
C [sqrt(3)/2, sqrt(3)/2]
C
      CALL IDIV(SQT3,TWO,X)
      CALL EVAL(RMAX,IOUTUN,IACOS,DACOS,X)
C
C [-sqrt(3)/2, -sqrt(3)/2]
C
      X(1) = -SQT3(2)
      X(2) = -SQT3(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL IDIV(X,TWO,X)
      CALL EVAL(RMAX,IOUTUN,IACOS,DACOS,X)
C
C [1,1]
C
      X(1) = ONE(1)
      X(2) = ONE(1)
      CALL EVAL(RMAX,IOUTUN,IACOS,DACOS,X)
C
C [-1,-1]
C
      X(1) = -ONE(1)
      X(2) = -ONE(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      X(1) =  X(2)
      CALL EVAL(RMAX,IOUTUN,IACOS,DACOS,X)
C
C [TINY, TINY]
C
      X(1) = D1MACH(1)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,IACOS,DACOS,X)
C
C [-TINY, -TINY]
C
      X(1) = -D1MACH(1)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,IACOS,DACOS,X)
C
      RELMAX = RELERR
      ABSMAX = ABSERR
C
C Twenty randomly generated intervals --
C
      DO 20 I = 1,20
         CALL EVAL(RMAX,IOUTUN,IACOS,DACOS,XR(1,I))
   20 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE',
     *                   'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE ',
     *                   'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TIACOT(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   July 6, 1992
C
C A test routine for the interval elementary function library
C
C
C***********************************************************************
C
C  Routine tested --  IACOT
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DABS, DEXP, DLOG, MAX, MIN
C
C***********************************************************************
C
C  Package routines called --
C
C     D1MACH, EVAL, IACOT, SIMINI
C
      DOUBLE PRECISION D1MACH
C
C***********************************************************************
C
C  Variables --
C
      DOUBLE PRECISION X(2), RELMAX, ABSMAX
C
      DOUBLE PRECISION T, MAXX2(2)
C
C***********************************************************************
C
C  Functions tested --
C
      EXTERNAL IACOT
      EXTERNAL DACOT1
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR, ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      INTEGER I
      DOUBLE PRECISION BHIGH, BLOW, RMAX, SIZE
      DOUBLE PRECISION XR(2,20), R1(20), R2(20), R3(20)
C
      DATA R1/
     *  0.02705383300781D0,  0.38760375976563D0,
     *  0.41886901855469D0,  0.96777343750000D0,
     *  0.92518615722656D0,  0.02670288085938D0,
     *  0.35655212402344D0,  0.36712646484375D0,
     *  0.47663879394531D0,  0.55740356445313D0,
     *  0.87724304199219D0,  0.30651855468750D0,
     *  0.85328674316406D0,  0.83908081054688D0,
     *  0.27781677246094D0,  0.27032470703125D0,
     *  0.47700500488281D0,  0.98110961914063D0,
     *  0.10514831542969D0,  0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,  0.34286499023438D0,
     *  0.15611267089844D0,  0.45867919921875D0,
     *  0.40315246582031D0,  0.53372192382813D0,
     *  0.47758483886719D0,  0.90197753906250D0,
     *  0.79933166503906D0,  0.41305541992188D0,
     *  0.36643981933594D0,  0.80718994140625D0,
     *  0.63008117675781D0,  0.09024047851563D0,
     *  0.36955261230469D0,  0.90869140625000D0,
     *  0.56727600097656D0,  0.92465209960938D0,
     *  0.28379821777344D0,  0.19085693359375D0/
C
      DATA R3/
     *  0.53279113769531D0,  0.52566528320313D0,
     *  0.15605163574219D0,  0.88806152343750D0,
     *  0.69850158691406D0,  0.75265502929688D0,
     *  0.28318786621094D0,  0.48468017578125D0,
     *  0.48628234863281D0,  0.71499633789063D0,
     *  0.21208190917969D0,  0.71508789062500D0,
     *  0.56800842285156D0,  0.77206420898438D0,
     *  0.73960876464844D0,  0.56365966796875D0,
     *  0.86555480957031D0,  0.53323364257813D0,
     *  0.91264343261719D0,  0.26477050781250D0/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK=.TRUE.
C
      CALL SIMINI
C
      MAXX2(1) = D1MACH(2)
      MAXX2(2) = MAXX2(1)
      RMAX = MAXX2(1)/TEN(2)
C
      T = DLOG(MAXX2(1))
      DO 10 I = 1,20
         SIZE = -1D0 + 2D0*R1(I)
         SIZE = SIZE*DABS(SIZE**2)*T
         BLOW = -1D0 + 2D0*R2(I)
         BHIGH = BLOW + (1D0-BLOW)*R3(I)
         XR(1,I) = DEXP(SIZE)*BLOW
         XR(2,I) = DEXP(SIZE)*BHIGH
   10 CONTINUE
C
C [0, 0]
C
      X(1) = 0D0
      X(2) = 0D0
      CALL EVAL(RMAX,IOUTUN,IACOT,DACOT1,X)
C
C [.25,.25]
C
      X(1) = .25D0
      X(2) = .25D0
      CALL EVAL(RMAX,IOUTUN,IACOT,DACOT1,X)
C
C [-.25,-.25]
C
      X(1) = -.25D0
      X(2) = -.25D0
      CALL EVAL(RMAX,IOUTUN,IACOT,DACOT1,X)
C
C [sqrt(3), sqrt(3)]
C
      CALL EVAL(RMAX,IOUTUN,IACOT,DACOT1,SQT3)
C
C [-sqrt(3), -sqrt(3)]
C
      X(1) = -SQT3(2)
      X(2) = -SQT3(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,IACOT,DACOT1,X)
C
C [1/sqrt(3),1/sqrt(3)]
C
      X(1) = 1D0/SQT3(2)
      X(2) = 1D0/SQT3(1)
      CALL EVAL(RMAX,IOUTUN,IACOT,DACOT1,X)
C
C [-1/sqrt(3),-1/sqrt3)]
C
      X(1) = -1D0/SQT3(1)
      X(2) = -1D0/SQT3(2)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,IACOT,DACOT1,X)
C
C [M,M]
C
      X(1) = MAXX2(1)/TEN(2)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,IACOT,DACOT1,X)
C
C [TINY, TINY]
C
      X(1) = D1MACH(1)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,IACOT,DACOT1,X)
C
C [-TINY, -TINY]
C
      X(1) = -D1MACH(1)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,IACOT,DACOT1,X)
C
      RELMAX = RELERR
      ABSMAX = ABSERR
C
C Twenty randomly generated intervals --
C
      DO 20 I = 1,20
         CALL EVAL(RMAX,IOUTUN,IACOT,DACOT1,XR(1,I))
   20 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE',
     *                   'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE ',
     *                   'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      DOUBLE PRECISION FUNCTION DACOT1(X)
C
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   July 6, 1992
C
C A test routine for the interval elementary function library
C
C***********************************************************************
C
C Function --
C
C  This routine computes a floating point approximation to the cotangent
C  of x by using the Fortran intrinsic function DATAN.
C
C***********************************************************************
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C***********************************************************************

C
      DOUBLE PRECISION X
C
      DACOT1 = (PI2(1)+PI2(2))/2D0 - DATAN(X)
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TIASIN(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   July 6, 1992
C
C A test routine for the interval elementary function library
C
C***********************************************************************
C
C  Routine tested --  IASIN
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DASIN, MAX, MIN
C
C***********************************************************************
C
C  Package routines called --
C
C     D1MACH, EVAL, IASIN, IDIV, RNDOUT, SIMINI
C
      DOUBLE PRECISION D1MACH
C
C***********************************************************************
C
C  Variables --
C
      DOUBLE PRECISION X(2), RELMAX, ABSMAX
C
C***********************************************************************
C
C  Routines tested --
C
      EXTERNAL IASIN
      INTRINSIC DASIN
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR,  ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      INTEGER I
      DOUBLE PRECISION XR(2,20), RMAX, R1(20), R2(20)
C
      DATA R1/
     *  0.02705383300781D0,  0.38760375976563D0,
     *  0.41886901855469D0,  0.96777343750000D0,
     *  0.92518615722656D0,  0.02670288085938D0,
     *  0.35655212402344D0,  0.36712646484375D0,
     *  0.47663879394531D0,  0.55740356445313D0,
     *  0.87724304199219D0,  0.30651855468750D0,
     *  0.85328674316406D0,  0.83908081054688D0,
     *  0.27781677246094D0,  0.27032470703125D0,
     *  0.47700500488281D0,  0.98110961914063D0,
     *  0.10514831542969D0,  0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,  0.34286499023438D0,
     *  0.15611267089844D0,  0.45867919921875D0,
     *  0.40315246582031D0,  0.53372192382813D0,
     *  0.47758483886719D0,  0.90197753906250D0,
     *  0.79933166503906D0,  0.41305541992188D0,
     *  0.36643981933594D0,  0.80718994140625D0,
     *  0.63008117675781D0,  0.09024047851563D0,
     *  0.36955261230469D0,  0.90869140625000D0,
     *  0.56727600097656D0,  0.92465209960938D0,
     *  0.28379821777344D0,  0.19085693359375D0/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK = .TRUE.
C
      CALL SIMINI
C
      RMAX = ONE(2)
C
      DO 10 I = 1,20
         XR(1,I) = -1D0 + 2D0*MIN(R1(I),R2(I))
         XR(2,I) = -1D0 + 2D0*MAX(R1(I),R2(I))
   10 CONTINUE
C
C [0, 0]
C
      X(1) = 0D0
      X(2) = 0D0
      CALL EVAL(RMAX,IOUTUN,IASIN,DASIN,X)
C
C [.5,.5]
C
      X(1) = .5D0
      X(2) = .5D0
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,IASIN,DASIN,X)
C
C [-.5,-.5]
C
      X(1) = -.5D0
      X(2) = -.5D0
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,IASIN,DASIN,X)
C
C [sqrt(3)/2, sqrt(3)/2]
C
      CALL IDIV(SQT3,TWO,X)
      CALL EVAL(RMAX,IOUTUN,IASIN,DASIN,X)
C
C [-sqrt(3)/2, -sqrt(3)/2]
C
      X(1) = -SQT3(2)
      X(2) = -SQT3(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL IDIV(X,TWO,X)
      CALL EVAL(RMAX,IOUTUN,IASIN,DASIN,X)
C
C [1,1]
C
      X(1) = ONE(1)
      X(2) = ONE(1)
      CALL EVAL(RMAX,IOUTUN,IASIN,DASIN,X)
C
C [-1,-1]
C
      X(1) = -ONE(1)
      X(2) = -ONE(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      X(1) =  X(2)
      CALL EVAL(RMAX,IOUTUN,IASIN,DASIN,X)
C
C [TINY, TINY]
C
      X(1) = D1MACH(1)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,IASIN,DASIN,X)
C
C [-TINY, -TINY]
C
      X(1) = -D1MACH(1)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,IASIN,DASIN,X)
C
      RELMAX = RELERR
      ABSMAX = RELERR
C
C Twenty randomly generated intervals --
C
      DO 20 I = 1,20
         CALL EVAL(RMAX,IOUTUN,IASIN,DASIN,XR(1,I))
   20 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE'
         WRITE(IOUTUN,*) 'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE '
         WRITE(IOUTUN,*) 'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TIATAN(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C A test routine for the interval elementary function library
C
C
C***********************************************************************
C
C  Routine tested --  IATAN
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DABS, DATAN, DEXP, DLOG
C
C***********************************************************************
C
C  Package routines called --
C
C     D1MACH, EVAL, IATAN, SIMINI
C
C***********************************************************************
C
C  Variables --
C
      DOUBLE PRECISION X(2)
C
      DOUBLE PRECISION T, MAXX2(2), RELMAX, ABSMAX
C
C***********************************************************************
C
C  Routines tested --
C
      EXTERNAL IATAN
      INTRINSIC DATAN
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR,  ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      INTEGER I
      DOUBLE PRECISION BHIGH, BLOW, D1MACH, RMAX, SIZE
      DOUBLE PRECISION XR(2,20), R1(20), R2(20), R3(20)
C
      DATA R1/
     *  0.02705383300781D0,  0.38760375976563D0,
     *  0.41886901855469D0,  0.96777343750000D0,
     *  0.92518615722656D0,  0.02670288085938D0,
     *  0.35655212402344D0,  0.36712646484375D0,
     *  0.47663879394531D0,  0.55740356445313D0,
     *  0.87724304199219D0,  0.30651855468750D0,
     *  0.85328674316406D0,  0.83908081054688D0,
     *  0.27781677246094D0,  0.27032470703125D0,
     *  0.47700500488281D0,  0.98110961914063D0,
     *  0.10514831542969D0,  0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,  0.34286499023438D0,
     *  0.15611267089844D0,  0.45867919921875D0,
     *  0.40315246582031D0,  0.53372192382813D0,
     *  0.47758483886719D0,  0.90197753906250D0,
     *  0.79933166503906D0,  0.41305541992188D0,
     *  0.36643981933594D0,  0.80718994140625D0,
     *  0.63008117675781D0,  0.09024047851563D0,
     *  0.36955261230469D0,  0.90869140625000D0,
     *  0.56727600097656D0,  0.92465209960938D0,
     *  0.28379821777344D0,  0.19085693359375D0/
C
      DATA R3/
     *  0.53279113769531D0,  0.52566528320313D0,
     *  0.15605163574219D0,  0.88806152343750D0,
     *  0.69850158691406D0,  0.75265502929688D0,
     *  0.28318786621094D0,  0.48468017578125D0,
     *  0.48628234863281D0,  0.71499633789063D0,
     *  0.21208190917969D0,  0.71508789062500D0,
     *  0.56800842285156D0,  0.77206420898438D0,
     *  0.73960876464844D0,  0.56365966796875D0,
     *  0.86555480957031D0,  0.53323364257813D0,
     *  0.91264343261719D0,  0.26477050781250D0/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK = .TRUE.
C
      CALL SIMINI
C
      MAXX2(1) = D1MACH(2)
      MAXX2(2) = MAXX2(1)
      RMAX = MAXX2(1)/TEN(2)
C
      T = DLOG(MAXX2(1))
      DO 10 I = 1,20
         SIZE = -1D0 + 2D0*R1(I)
         SIZE = SIZE*DABS(SIZE**2)*T
         BLOW = -1D0 + 2D0*R2(I)
         BHIGH = BLOW + (1D0-BLOW)*R3(I)
         XR(1,I) = DEXP(SIZE)*BLOW
         XR(2,I) = DEXP(SIZE)*BHIGH
   10 CONTINUE
C
C [0, 0]
C
      X(1) = 0D0
      X(2) = 0D0
      CALL EVAL(RMAX,IOUTUN,IATAN,DATAN,X)
C
C [.25,.25]
C
      X(1) = .25D0
      X(2) = .25D0
      CALL EVAL(RMAX,IOUTUN,IATAN,DATAN,X)
C
C [-.25,-.25]
C
      X(1) = -.25D0
      X(2) = -.25D0
      CALL EVAL(RMAX,IOUTUN,IATAN,DATAN,X)
C
C [sqrt(3), sqrt(3)]
C
      CALL EVAL(RMAX,IOUTUN,IATAN,DATAN,SQT3)
C
C [-sqrt(3), -sqrt(3)]
C
      X(1) = -SQT3(2)
      X(2) = -SQT3(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,IATAN,DATAN,X)
C
C [1/sqrt(3),1/sqrt(3)]
C
      X(1) = 1D0/SQT3(2)
      X(2) = 1D0/SQT3(1)
      CALL EVAL(RMAX,IOUTUN,IATAN,DATAN,X)
C
C [-1/sqrt(3),-1/sqrt3)]
C
      X(1) = -1D0/SQT3(1)
      X(2) = -1D0/SQT3(2)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,IATAN,DATAN,X)
C
C [M,M]
C
      X(1) = MAXX2(1)/TEN(2)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,IATAN,DATAN,X)
C
C [TINY, TINY]
C
      X(1) = D1MACH(1)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,IATAN,DATAN,X)
C
C [-TINY, -TINY]
C
      X(1) = -D1MACH(1)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,IATAN,DATAN,X)
C
      RELMAX = RELERR
      ABSMAX = ABSERR
C
C Twenty randomly generated intervals --
C
      DO 20 I = 1,20
         CALL EVAL(RMAX,IOUTUN,IATAN,DATAN,XR(1,I))
   20 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE'
         WRITE(IOUTUN,*) 'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE '
         WRITE(IOUTUN,*) 'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TICOS(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C A test routine for the interval elementary function library
C
C
C***********************************************************************
C
C  Routine tested -- ICOS
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DCOS, DSQRT
C
C***********************************************************************
C
C  Package routines called --
C
C     EVAL, ICOS, MULT, RNDOUT, SIMINI, SUB
C
C***********************************************************************
C
C  Variables --
C
      INTEGER I
      DOUBLE PRECISION BHIGH, BLOW, SIZE
      DOUBLE PRECISION X(2), RELMAX, ABSMAX
C
      DOUBLE PRECISION TMP(2), T, MAXX2(2), RMAX
C
      EXTERNAL ICOS
      INTRINSIC DCOS
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR,  ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      DOUBLE PRECISION XR(2,20), R1(20), R2(20), R3(20)
C
      DATA R1/
     *  0.02705383300781D0,  0.38760375976563D0,
     *  0.41886901855469D0,  0.96777343750000D0,
     *  0.92518615722656D0,  0.02670288085938D0,
     *  0.35655212402344D0,  0.36712646484375D0,
     *  0.47663879394531D0,  0.55740356445313D0,
     *  0.87724304199219D0,  0.30651855468750D0,
     *  0.85328674316406D0,  0.83908081054688D0,
     *  0.27781677246094D0,  0.27032470703125D0,
     *  0.47700500488281D0,  0.98110961914063D0,
     *  0.10514831542969D0,  0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,  0.34286499023438D0,
     *  0.15611267089844D0,  0.45867919921875D0,
     *  0.40315246582031D0,  0.53372192382813D0,
     *  0.47758483886719D0,  0.90197753906250D0,
     *  0.79933166503906D0,  0.41305541992188D0,
     *  0.36643981933594D0,  0.80718994140625D0,
     *  0.63008117675781D0,  0.09024047851563D0,
     *  0.36955261230469D0,  0.90869140625000D0,
     *  0.56727600097656D0,  0.92465209960938D0,
     *  0.28379821777344D0,  0.19085693359375D0/
C
      DATA R3/
     *  0.53279113769531D0,  0.52566528320313D0,
     *  0.15605163574219D0,  0.88806152343750D0,
     *  0.69850158691406D0,  0.75265502929688D0,
     *  0.28318786621094D0,  0.48468017578125D0,
     *  0.48628234863281D0,  0.71499633789063D0,
     *  0.21208190917969D0,  0.71508789062500D0,
     *  0.56800842285156D0,  0.77206420898438D0,
     *  0.73960876464844D0,  0.56365966796875D0,
     *  0.86555480957031D0,  0.53323364257813D0,
     *  0.91264343261719D0,  0.26477050781250D0/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK = .TRUE.
C
      CALL SIMINI
C
      DO 10 I = 1,20
         SIZE = MAXX*R1(I)**20
         BLOW = (-2D0+4D0*R2(I))*(PI(1)+PI(2))/2D0
         BHIGH =(2D0*R3(I)**3)*(PI(1)+PI(2))/2D0
         XR(1,I) = SIZE*BLOW
         XR(2,I) = XR(1,I)+BHIGH
   10 CONTINUE
C
      MAXX2(1) = MAXX
      MAXX2(2) = MAXX
      RMAX = MAXX/2D0
C
C [0, 0]
C
      X(1) = ZERO(1)
      X(2) = ZERO(2)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [pi, pi]
C
      X(1) = PI(1)
      X(2) = PI(2)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [pi/2, pi/2]
C
      X(1) = PI2(1)
      X(2) = PI2(2)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [(M-1)pi, (M-1)pi]
C
      CALL SUB(MAXX2,ONE,TMP)
      CALL MULT(TMP,PI,X)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [-pi, -pi]
C
      X(1) = -PI(2)
      X(2) = -PI(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [-pi/2, -pi/2]
C
      X(1) = -PI2(2)
      X(2) = -PI2(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [(1-M)pi, (1-M)pi]
C
      CALL SUB(ONE,MAXX2,TMP)
      CALL MULT(TMP,PI,X)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [sqrt(M)pi, sqrt(M)pi]
C
      TMP(1) = DSQRT(MAXX)
      TMP(2) = TMP(1)
      CALL MULT(TMP,PI,X)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [-sqrt(M)pi, -sqrt(M)pi]
C
      T = X(2)
      X(2) = -X(1)
      X(1) = -T
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
      RELMAX = RELERR
      ABSMAX = ABSERR
C
C [pi/2, 3pi/2]
C
      X(1) = PI2(1)
      CALL MULT(THREE,PI2,TMP)
      X(2) = TMP(2)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [-3pi/2, -pi/2]
C
      T = X(2)
      X(2) = -X(1)
      X(1) = -T
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [pi, 2pi]
C
      X(1) = PI(1)
      CALL MULT(TWO,PI,TMP)
      X(2) = TMP(2)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [-2pi, -pi]
C
      T = X(2)
      X(2) = -X(1)
      X(1) = -T
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [8M, 8M]
C
      CALL MULT(EIGHT,MAXX2,X)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C [-8M, -8M]
C
      T = X(2)
      X(2) = -X(1)
      X(1) = -T
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,X)
C
C Twenty randomly generated intervals --
C
      DO 20 I = 1,20
         CALL EVAL(RMAX,IOUTUN,ICOS,DCOS,XR(1,I))
   20 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE'
         WRITE(IOUTUN,*) 'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE '
         WRITE(IOUTUN,*) 'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TIEXP(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C A test routine for the interval elementary function library
C
C
C***********************************************************************
C
C  Routine tested --  IEXP
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DABS, DEXP, DLOG
C
C***********************************************************************
C
C  Package routines called --
C
C     D1MACH, EVAL, IEXP, RNDOUT, SIMINI
C
C***********************************************************************
C
C  Variables --
C
      DOUBLE PRECISION X(2), RELMAX, ABSMAX
C
      DOUBLE PRECISION T, MAXX2(2), RMAX
C
      EXTERNAL IEXP
      INTRINSIC DEXP
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR,  ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      INTEGER I
      DOUBLE PRECISION BHIGH, BLOW, D1MACH, SIZE
      DOUBLE PRECISION XR(2,20), R1(20), R2(20), R3(20)
C
      DATA R1/
     *  0.02705383300781D0,  0.38760375976563D0,
     *  0.41886901855469D0,  0.96777343750000D0,
     *  0.92518615722656D0,  0.02670288085938D0,
     *  0.35655212402344D0,  0.36712646484375D0,
     *  0.47663879394531D0,  0.55740356445313D0,
     *  0.87724304199219D0,  0.30651855468750D0,
     *  0.85328674316406D0,  0.83908081054688D0,
     *  0.27781677246094D0,  0.27032470703125D0,
     *  0.47700500488281D0,  0.98110961914063D0,
     *  0.10514831542969D0,  0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,  0.34286499023438D0,
     *  0.15611267089844D0,  0.45867919921875D0,
     *  0.40315246582031D0,  0.53372192382813D0,
     *  0.47758483886719D0,  0.90197753906250D0,
     *  0.79933166503906D0,  0.41305541992188D0,
     *  0.36643981933594D0,  0.80718994140625D0,
     *  0.63008117675781D0,  0.09024047851563D0,
     *  0.36955261230469D0,  0.90869140625000D0,
     *  0.56727600097656D0,  0.92465209960938D0,
     *  0.28379821777344D0,  0.19085693359375D0/
C
      DATA R3/
     *  0.53279113769531D0,  0.52566528320313D0,
     *  0.15605163574219D0,  0.88806152343750D0,
     *  0.69850158691406D0,  0.75265502929688D0,
     *  0.28318786621094D0,  0.48468017578125D0,
     *  0.48628234863281D0,  0.71499633789063D0,
     *  0.21208190917969D0,  0.71508789062500D0,
     *  0.56800842285156D0,  0.77206420898438D0,
     *  0.73960876464844D0,  0.56365966796875D0,
     *  0.86555480957031D0,  0.53323364257813D0,
     *  0.91264343261719D0,  0.26477050781250D0/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK = .TRUE.
C
      CALL SIMINI
C
      T = MXLGM1
      RMAX = T/2D0
      DO 10 I = 1,20
         SIZE = -1D0 + 2D0*R1(I)
         SIZE = SIZE*DABS(SIZE**2)*T
         BLOW = R2(I)
         BHIGH = BLOW + (1D0-BLOW)*R3(I)
         XR(1,I) = DEXP(SIZE)*BLOW
         XR(2,I) = DEXP(SIZE)*BHIGH
         XR(1,I) = DLOG(XR(1,I))
         XR(2,I) = DLOG(XR(2,I))
   10 CONTINUE
C
      MAXX2(1) = DLOG(D1MACH(2))-1D0
      MAXX2(2) = MAXX2(1)
      CALL RNDOUT(MAXX2,.TRUE.,.TRUE.)
C
C [0, 0]
C
      X(1) = ZERO(1)
      X(2) = ZERO(2)
      CALL EVAL(RMAX,IOUTUN,IEXP,DEXP,X)
C
C [.25,.25]
C
      X(1) = .25D0
      X(2) = .25D0
      CALL EVAL(RMAX,IOUTUN,IEXP,DEXP,X)
C
C [-.25,-.25]
C
      X(1) = -.25D0
      X(2) = -.25D0
      CALL EVAL(RMAX,IOUTUN,IEXP,DEXP,X)
C
C [log(M), log(M)]
C
      X(1) = MAXX2(1)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,IEXP,DEXP,X)
C
C [-log(M), -log(M)]
C
      T = X(1)
      X(1) = -X(2)
      X(2) = -T
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,IEXP,DEXP,X)
C
C [.125, .125]
C
      X(1) = .125D0
      X(2) = .125D0
      CALL EVAL(RMAX,IOUTUN,IEXP,DEXP,X)
C
C [-.125, -.125]
C
      X(1) = -.125D0
      X(2) = -.125D0
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,IEXP,DEXP,X)
C
      RELMAX = RELERR
      ABSMAX = ABSERR
C
C Twenty randomly generated intervals --
C
      DO 20 I = 1,20
         CALL EVAL(RMAX,IOUTUN,IEXP,DEXP,XR(1,I))
   20 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE'
         WRITE(IOUTUN,*) 'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE '
         WRITE(IOUTUN,*) 'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TIIPWR(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C A test routine for the interval elementary function library
C
C
C***********************************************************************
C
C  Routine tested --  IIPOWER
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DABS, DEXP, DLOG
C
C***********************************************************************
C
C  Package routines called --
C
C     D1MACH, EVAL2, IIPOWR, RNDOUT, RPOWR, SIMINI
C
C***********************************************************************
C
C  Variables --
C
      DOUBLE PRECISION X(2), Y(2), RELMAX, ABSMAX
C
      DOUBLE PRECISION T, MAXX2(2), RMAX
C
      EXTERNAL IIPOWR, RPOWR
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR,  ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      INTEGER I
      DOUBLE PRECISION BHIGH, BLOW, D1MACH, SIZE
      DOUBLE PRECISION XR(2,20), YR(20,20)
      DOUBLE PRECISION R1(20), R2(20), R3(20), R4(20), R5(20)
      DOUBLE PRECISION YMIN, YMAX
C
      DATA R1/
     *  0.02705383300781D0,   0.38760375976563D0,
     *  0.41886901855469D0,   0.96777343750000D0,
     *  0.92518615722656D0,   0.02670288085938D0,
     *  0.35655212402344D0,   0.36712646484375D0,
     *  0.47663879394531D0,   0.55740356445313D0,
     *  0.87724304199219D0,   0.30651855468750D0,
     *  0.85328674316406D0,   0.83908081054688D0,
     *  0.27781677246094D0,   0.27032470703125D0,
     *  0.47700500488281D0,   0.98110961914063D0,
     *  0.10514831542969D0,   0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,   0.34286499023438D0,
     *  0.15611267089844D0,   0.45867919921875D0,
     *  0.40315246582031D0,   0.53372192382813D0,
     *  0.47758483886719D0,   0.90197753906250D0,
     *  0.79933166503906D0,   0.41305541992188D0,
     *  0.36643981933594D0,   0.80718994140625D0,
     *  0.63008117675781D0,   0.09024047851563D0,
     *  0.36955261230469D0,   0.90869140625000D0,
     *  0.56727600097656D0,   0.92465209960938D0,
     *  0.28379821777344D0,   0.19085693359375D0/
C
      DATA R3/
     *  0.53279113769531D0,   0.52566528320313D0,
     *  0.15605163574219D0,   0.88806152343750D0,
     *  0.69850158691406D0,   0.75265502929688D0,
     *  0.28318786621094D0,   0.48468017578125D0,
     *  0.48628234863281D0,   0.71499633789063D0,
     *  0.21208190917969D0,   0.71508789062500D0,
     *  0.56800842285156D0,   0.77206420898438D0,
     *  0.73960876464844D0,   0.56365966796875D0,
     *  0.86555480957031D0,   0.53323364257813D0,
     *  0.91264343261719D0,   0.26477050781250D0/
C
      DATA R4/
     *  4.4316742319792D-01,  8.6999237745448D-01,
     *  8.2621532353974D-02,  2.1461421839815D-01,
     *  7.7130012307484D-01,  6.5717599887886D-01,
     *  5.0064431505671D-01,  3.1219144111883D-01,
     *  5.6980325067631D-01,  1.7625776736111D-02,
     *  8.6766593138850D-01,  2.1347226643210D-01,
     *  6.1645451274884D-01,  3.1272386061651D-01,
     *  3.7172458364622D-02,  6.9623463878241D-01,
     *  2.2364976630285D-01,  9.1956028981867D-01,
     *  7.9059801627431D-01,  8.7158953594753D-01/

      DATA R5/
     *  6.4293594285880D-01,  4.1698302659799D-01,
     *  8.8709495740548D-02,  9.5604945365278D-01,
     *  3.5995765561767D-01,  6.6826398691127D-01,
     *  2.8374625447801D-01,  4.4251544859568D-01,
     *  2.1401624287539D-01,  5.0102629426157D-02,
     *  3.9656644303202D-01,  3.9935191279784D-01,
     *  9.8288971050347D-01,  2.6381172642670D-01,
     *  5.9927083417863D-02,  6.0433649070370D-01,
     *  7.7768903627971D-01,  6.8877329451775D-01,
     *  7.4036657236227D-01,  1.6858026009105D-01/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK = .TRUE.
C
      CALL SIMINI
C
      T = MXLGM1
      RMAX = (T/2D0)/3D0
      YMIN = -3D0
      YMAX =  3D0
      DO 10 I = 1,20
         SIZE = -1D0 + 2D0*R1(I)
         SIZE = SIZE*DABS(SIZE**2)*T
         BLOW = R2(I)
         BHIGH = BLOW + (1D0-BLOW)*R3(I)
         XR(1,I) = DEXP(SIZE)*BLOW
         XR(2,I) = DEXP(SIZE)*BHIGH
         XR(1,I) = ABS(DLOG(XR(1,I)))
         XR(2,I) = ABS(DLOG(XR(2,I)))
         IF (XR(2,I).LT.XR(1,I)) THEN
            T = XR(1,I)
            XR(1,I)=XR(2,I)
            XR(2,I)=T
         END IF
         YR(1,I) = YMIN + R4(I)*(YMAX-YMIN)
         YR(2,I) = YR(1,I) + R5(I)*(YMAX-YR(1,I))
   10 CONTINUE
C
      MAXX2(1) = DLOG(D1MACH(2))-1D0
      MAXX2(2) = MAXX2(1)
      CALL RNDOUT(MAXX2,.TRUE.,.TRUE.)
C
C X = [.25,.25], Y = [1,1]
C
      X(1) = FOURTH(1)
      X(2) = FOURTH(2)
      Y(1) = ONE(1)
      Y(2) = ONE(2)
      CALL EVAL2(RMAX,IOUTUN,IIPOWR,RPOWR,X,Y)
C
C X = [.25,.25], Y = [.5,.5]
C
      Y(1) = OD2F(1)
      Y(2) = OD2F(2)
      CALL EVAL2(RMAX,IOUTUN,IIPOWR,RPOWR,X,Y)
C
C X = [.25,.25], Y = [2.,2.]
C
      Y(1) = TWO(1)
      Y(2) = TWO(2)
      CALL EVAL2(RMAX,IOUTUN,IIPOWR,RPOWR,X,Y)
C
C X = [log(M), log(M)], Y = [1,1]
C
      X(1) = MAXX2(1)
      X(2) = X(1)
      Y(1) = ONE(1)
      Y(2) = ONE(2)
      CALL EVAL2(RMAX,IOUTUN,IIPOWR,RPOWR,X,Y)
C
C X = [log(M), log(M)], Y = [2,2]
C
      Y(1) = TWO(1)
      Y(2) = TWO(2)
      CALL EVAL2(RMAX,IOUTUN,IIPOWR,RPOWR,X,Y)
C
C X = [log(M), log(M)], Y = [.5,.5]
C
      Y(1) = OD2F(1)
      Y(2) = OD2F(2)
      CALL EVAL2(RMAX,IOUTUN,IIPOWR,RPOWR,X,Y)
C
      RELMAX = RELERR
      ABSMAX = ABSERR
C
C Twenty randomly generated intervals --
C
      DO 20 I = 1,20
         CALL EVAL2(RMAX,IOUTUN,IIPOWR,RPOWR,XR(1,I),YR(1,I))
   20 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE'
         WRITE(IOUTUN,*) 'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE '
         WRITE(IOUTUN,*) 'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE EVAL2(RMAX,IOUTUN,FCN,LFCN,X,Y)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C An auxiliary routine for testing the interval elementary function
C library
C
C***********************************************************************
C
C  Function --
C
C    This routine provides a generic interface between the routines
C    in the package and the test drivers.  It also provides output of
C    the results for all of the test drivers.  As an additional check,
C    the Fortran intrinsic functions are called at the endpoints of the
C    input interval, as long as those endpoints are within the
C    proper range.
C
C***********************************************************************
C
C  Argument declarations --
C
      DOUBLE PRECISION RMAX
      INTEGER IOUTUN
      EXTERNAL FCN
      DOUBLE PRECISION LFCN
      DOUBLE PRECISION X(2), Y(2)
C
C***********************************************************************
C
C  Argument descriptions --
C
C RMAX   defines a bound on the set of allowable values of the
C        corresponding Fortran 77 intrinsic function.  The fortran
C        intrinsic function is not evaluated if
C        MAX(ABS(X(1)),ABS(X(2)) > RMAX.
C
C IOUTUN is the unit number for output.
C
C FCN    is the name of the interval elementary function routine being
C        tested.
C
C LFCN   is the name of the Fortran intrinsic function corresponding to
C        FCN.
C
C X      [X(1),X(2)] is the interval over which the function defined in
C        FCN is to be evaluated.
C
C***********************************************************************
C
C  Fortran-supplied routines --
C
C     ABS, MAX
C
C***********************************************************************
C
C  Package routines --
C
      DOUBLE PRECISION D1MACH
C
C
C***********************************************************************
C
C  Internal variable declarations --
C
      DOUBLE PRECISION RESULT(2), LF1, LF2, LF3, LF4, RMID, REL, ABSE
      LOGICAL BAD
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR, ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
      BAD = .FALSE.
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) '[X1,X2] is:'
      WRITE(IOUTUN,*) '[',X(1),',',X(2),']'
      WRITE(IOUTUN,*) '[Y1,Y2] is:'
      WRITE(IOUTUN,*) '[',Y(1),',',Y(2),']'
C
      CALL FCN(X,Y,RESULT)
C
      WRITE(IOUTUN,*)'The function bounds are:'
      WRITE(IOUTUN,5)
     *'      12345678901234567890123456789',
     *'      12345678901234567890123456789'
    5 FORMAT(2(1X,A35))
      WRITE(IOUTUN,10) RESULT(1), RESULT(2)
   10 FORMAT(2(1X,D35.25))
C
      RMID   = MAX( ABS(.5D0*(RESULT(1)+RESULT(2) )), DSQRT(D1MACH(1)) )
      ABSE = RESULT(2)-RESULT(1)
      REL = ABSE/RMID
      RELERR = MAX(REL,RELERR)
      ABSERR = MAX(ABSE,ABSERR)
      WRITE(IOUTUN,20) 'Relative range width:', REL
      WRITE(IOUTUN,20) 'Absolute range width:', ABSE
   20 FORMAT(1X,A,1X,D35.25)
C
      IF(ABS(X(1)).LT.RMAX .AND. ABS(X(2)).LT.RMAX) THEN
         WRITE(IOUTUN,*)
     *    'The Fortran library function values at (lower, lower),'
         WRITE(IOUTUN,*)
     *    '(upper, lower), (lower,upper), and (upper,upper)'
         WRITE(IOUTUN,*)
     *    'points of the rectangle are:'
         WRITE(IOUTUN,5)
     *'      12345678901234567890123456789',
     *'      12345678901234567890123456789'
         LF1 = LFCN(X(1),Y(1))
         LF2 = LFCN(X(2),Y(1))
         LF3 = LFCN(X(1),Y(2))
         LF4 = LFCN(X(2),Y(2))
         WRITE(IOUTUN,10) LF1, LF2
         WRITE(IOUTUN,10) LF3, LF4
C
         BAD = (LF1.LT.RESULT(1)) .OR. (LF1.GT.RESULT(2))
     *    .OR. (LF2.LT.RESULT(1)) .OR. (LF2.GT.RESULT(2))
     *    .OR. (LF3.LT.RESULT(1)) .OR. (LF3.GT.RESULT(2))
     *    .OR. (LF4.LT.RESULT(1)) .OR. (LF4.GT.RESULT(2))
         OK = OK .AND. .NOT.BAD
         IF (BAD) THEN
            WRITE(IOUTUN,*) 'POINT FUNCTION VALUES ARE NOT WITHIN',
     *                      ' THE INTERVAL FUNCTION VALUE.'
            WRITE(IOUTUN,*) 'EITHER THE INTERVAL BOUNDS ARE WRONG',
     *                      ' OR THE CORRESPONDING FORTRAN-SUPPLIED'
            WRITE(IOUTUN,*) 'FUNCTION IS INNACURATE.'
         END IF
C
      END IF
      WRITE(IOUTUN,*)
     * '---------------------------------------------------'
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      DOUBLE PRECISION FUNCTION RPOWR(X,Y)
C
      DOUBLE PRECISION X, Y
C
      RPOWR = X**Y
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TILOG(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C A test routine for the interval elementary function library
C
C
C***********************************************************************
C
C  Routine tested --  ILOG
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DABS, DLOG, DEXP
C
C***********************************************************************
C
C  Package routines called --
C
C     D1MACH, EVAL, ILOG, SIMINI
C
C***********************************************************************
C
C  Variables --
C
      DOUBLE PRECISION X(2), RELMAX, ABSMAX
C
      DOUBLE PRECISION D1MACH, MAXX2(2), T
C
      EXTERNAL ILOG
      INTRINSIC DLOG
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR,  ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      INTEGER I
      DOUBLE PRECISION BHIGH, BLOW, RMAX, SIZE
      DOUBLE PRECISION XR(2,20), R1(20), R2(20), R3(20)
C
      DATA R1/
     *  0.02705383300781D0,  0.38760375976563D0,
     *  0.41886901855469D0,  0.96777343750000D0,
     *  0.92518615722656D0,  0.02670288085938D0,
     *  0.35655212402344D0,  0.36712646484375D0,
     *  0.47663879394531D0,  0.55740356445313D0,
     *  0.87724304199219D0,  0.30651855468750D0,
     *  0.85328674316406D0,  0.83908081054688D0,
     *  0.27781677246094D0,  0.27032470703125D0,
     *  0.47700500488281D0,  0.98110961914063D0,
     *  0.10514831542969D0,  0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,  0.34286499023438D0,
     *  0.15611267089844D0,  0.45867919921875D0,
     *  0.40315246582031D0,  0.53372192382813D0,
     *  0.47758483886719D0,  0.90197753906250D0,
     *  0.79933166503906D0,  0.41305541992188D0,
     *  0.36643981933594D0,  0.80718994140625D0,
     *  0.63008117675781D0,  0.09024047851563D0,
     *  0.36955261230469D0,  0.90869140625000D0,
     *  0.56727600097656D0,  0.92465209960938D0,
     *  0.28379821777344D0,  0.19085693359375D0/
C
      DATA R3/
     *  0.53279113769531D0,  0.52566528320313D0,
     *  0.15605163574219D0,  0.88806152343750D0,
     *  0.69850158691406D0,  0.75265502929688D0,
     *  0.28318786621094D0,  0.48468017578125D0,
     *  0.48628234863281D0,  0.71499633789063D0,
     *  0.21208190917969D0,  0.71508789062500D0,
     *  0.56800842285156D0,  0.77206420898438D0,
     *  0.73960876464844D0,  0.56365966796875D0,
     *  0.86555480957031D0,  0.53323364257813D0,
     *  0.91264343261719D0,  0.26477050781250D0/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK = .TRUE.
C
      CALL SIMINI
C
      MAXX2(1) = D1MACH(2)
      MAXX2(2) = MAXX2(1)
      RMAX = MAXX2(1)/TEN(2)
C
      T = DLOG(MAXX2(1))
      DO 10 I = 1,20
         SIZE = -1D0 + 2D0*R1(I)
         SIZE = SIZE*DABS(SIZE**2)*T
         BLOW = R2(I)
         BHIGH = BLOW + (1D0-BLOW)*R3(I)
         XR(1,I) = DEXP(SIZE)*BLOW
         XR(2,I) = DEXP(SIZE)*BHIGH
   10 CONTINUE
C
C [.25,.25]
C
      X(1) = .25D0
      X(2) = .25D0
      CALL EVAL(RMAX,IOUTUN,ILOG,DLOG,X)
C
C [.125, .125]
C
      X(1) = .125D0
      X(2) = .125D0
      CALL EVAL(RMAX,IOUTUN,ILOG,DLOG,X)
C
C [1,1]
C
      CALL EVAL(RMAX,IOUTUN,ILOG,DLOG,ONE)
C
C [2,2]
C
      CALL EVAL(RMAX,IOUTUN,ILOG,DLOG,TWO)
C
C [M,M]
C
      X(1) = MAXX2(1)/TEN(2)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,ILOG,DLOG,X)
C
C [TINY, TINY]
C
      X(1) = D1MACH(1)*TEN(2)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,ILOG,DLOG,X)
C
      RELMAX = RELERR
      ABSMAX = ABSERR
C
C Twenty randomly generated intervals --
C
      DO 20 I = 1,20
         CALL EVAL(RMAX,IOUTUN,ILOG,DLOG,XR(1,I))
   20 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE'
         WRITE(IOUTUN,*) 'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE '
         WRITE(IOUTUN,*) 'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TINPWR(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C A test routine for the interval elementary function library
C
C
C***********************************************************************
C
C  Routine tested --  POWER
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DABS, DEXP, DLOG
C
C***********************************************************************
C
C  Package routines called --
C
C     D1MACH, EVAL3, POWER, RNDOUT, RPOWR, SIMINI
C
C***********************************************************************
C
C  Variables --
C
      DOUBLE PRECISION X(2), RELMAX, ABSMAX
C
      DOUBLE PRECISION T, MAXX2(2), RMAX
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR,  ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      INTEGER I
      DOUBLE PRECISION BHIGH, BLOW, D1MACH, SIZE
      DOUBLE PRECISION XR(2,20)
      INTEGER NR(20)
      DOUBLE PRECISION R1(20), R2(20), R3(20), R4(20)
      INTEGER NMIN, NMAX
C
      DATA R1/
     *  0.02705383300781D0,  0.38760375976563D0,
     *  0.41886901855469D0,  0.96777343750000D0,
     *  0.92518615722656D0,  0.02670288085938D0,
     *  0.35655212402344D0,  0.36712646484375D0,
     *  0.47663879394531D0,  0.55740356445313D0,
     *  0.87724304199219D0,  0.30651855468750D0,
     *  0.85328674316406D0,  0.83908081054688D0,
     *  0.27781677246094D0,  0.27032470703125D0,
     *  0.47700500488281D0,  0.98110961914063D0,
     *  0.10514831542969D0,  0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,  0.34286499023438D0,
     *  0.15611267089844D0,  0.45867919921875D0,
     *  0.40315246582031D0,  0.53372192382813D0,
     *  0.47758483886719D0,  0.90197753906250D0,
     *  0.79933166503906D0,  0.41305541992188D0,
     *  0.36643981933594D0,  0.80718994140625D0,
     *  0.63008117675781D0,  0.09024047851563D0,
     *  0.36955261230469D0,  0.90869140625000D0,
     *  0.56727600097656D0,  0.92465209960938D0,
     *  0.28379821777344D0,  0.19085693359375D0/
C
      DATA R3/
     *  0.53279113769531D0,  0.52566528320313D0,
     *  0.15605163574219D0,  0.88806152343750D0,
     *  0.69850158691406D0,  0.75265502929688D0,
     *  0.28318786621094D0,  0.48468017578125D0,
     *  0.48628234863281D0,  0.71499633789063D0,
     *  0.21208190917969D0,  0.71508789062500D0,
     *  0.56800842285156D0,  0.77206420898438D0,
     *  0.73960876464844D0,  0.56365966796875D0,
     *  0.86555480957031D0,  0.53323364257813D0,
     *  0.91264343261719D0,  0.26477050781250D0/
C
      DATA R4/
     *  4.4316742319792D-01,  8.6999237745448D-01,
     *  8.2621532353974D-02,  2.1461421839815D-01,
     *  7.7130012307484D-01,  6.5717599887886D-01,
     *  5.0064431505671D-01,  3.1219144111883D-01,
     *  5.6980325067631D-01,  1.7625776736111D-02,
     *  8.6766593138850D-01,  2.1347226643210D-01,
     *  6.1645451274884D-01,  3.1272386061651D-01,
     *  3.7172458364622D-02,  6.9623463878241D-01,
     *  2.2364976630285D-01,  9.1956028981867D-01,
     *  7.9059801627431D-01,  8.7158953594753D-01/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK = .TRUE.
C
      CALL SIMINI
C
      T = MXLGM1
      RMAX = (T/2D0)/3D0
      NMIN = -15
      NMAX =  15
      DO 10 I = 1,20
         SIZE = -1D0 + 2D0*R1(I)
         SIZE = SIZE*DABS(SIZE**2)*T
         BLOW = R2(I)
         BHIGH = BLOW + (1D0-BLOW)*R3(I)
         XR(1,I) = DEXP(SIZE)*BLOW
         XR(2,I) = DEXP(SIZE)*BHIGH
         XR(1,I) = ABS(DLOG(XR(1,I)))
         XR(2,I) = ABS(DLOG(XR(2,I)))
         IF (XR(2,I).LT.XR(1,I)) THEN
            T = XR(1,I)
            XR(1,I)=XR(2,I)
            XR(2,I)=T
         END IF
         NR(I) = NMIN + R4(I)*(NMAX-NMIN)
   10 CONTINUE
C
      MAXX2(1) = DLOG(D1MACH(2))-1D0
      MAXX2(2) = MAXX2(1)
      CALL RNDOUT(MAXX2,.TRUE.,.TRUE.)
C
C X = [.25,.25], N = 1
C
      X(1) = FOURTH(1)
      X(2) = FOURTH(2)
      N = 1
      CALL EVAL3(RMAX,IOUTUN,X,N)
C
C X = [.25,.25], N = -1
C
      N = -1
      CALL EVAL3(RMAX,IOUTUN,X,N)
C
C X = [.25,.25], N = 2
C
      N = 2
      CALL EVAL3(RMAX,IOUTUN,X,N)
C
C X = [log(M), log(M)], N = 2
C
      X(1) = MAXX2(1)
      X(2) = X(1)
      N = 2
      CALL EVAL3(RMAX,IOUTUN,X,N)
C
C X = [log(M), log(M)], N = 10
C
      N = 10
      CALL EVAL3(RMAX,IOUTUN,X,N)
C
C X = [log(M), log(M)], N = -10
C
      N = -10
      CALL EVAL3(RMAX,IOUTUN,X,N)
C
      RELMAX = RELERR
      ABSMAX = ABSERR
C
C Twenty randomly generated intervals --
C
      DO 20 I = 1,20
         CALL EVAL3(RMAX,IOUTUN,XR(1,I),NR(I))
   20 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE'
         WRITE(IOUTUN,*) 'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE '
         WRITE(IOUTUN,*) 'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE EVAL3(RMAX,IOUTUN,X,N)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C An auxiliary routine for testing the interval elementary function
C library
C
C***********************************************************************
C
C Function --
C
C  This routine provides a generic interface between POWER and the test
C  driver TINPWR.  It also provides output of the results for this the
C  test driver.  As an additional check, the Fortran intrinsic functions
C  are called at the endpoints of the input interval, as long as those
C  endpoints are within the proper range.
C
C***********************************************************************
C
C Argument declarations --
C
      DOUBLE PRECISION RMAX
      INTEGER IOUTUN
      DOUBLE PRECISION X(2)
      INTEGER N
C
C***********************************************************************
C
C  Argument descriptions --
C
C RMAX   defines a bound on the set of allowable values of the
C        corresponding Fortran 77 intrinsic function.  The fortran
C        intrinsic function is not evaluated if
C        MAX(ABS(X(1)),ABS(X(2)) > RMAX.
C
C IOUTUN is the unit number for output.
C
C X      [X(1),X(2)] is the interval over which POWER
C        is to be evaluated.
C
C N      is the integer power to be taken
C
C***********************************************************************
C
C  Fortran-supplied routines --
C
C     ABS, MAX
C
C***********************************************************************
C
C  Package routines --
C
      DOUBLE PRECISION D1MACH
C
C
C***********************************************************************
C
C  Internal variable declarations --
C
      DOUBLE PRECISION RESULT(2), LF1, LF2, RMID, REL, ABSE
      LOGICAL BAD
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR, ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
      BAD = .FALSE.
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) '[X1,X2] is:'
      WRITE(IOUTUN,*) '[',X(1),',',X(2),']'
      WRITE(IOUTUN,*) 'N is:', N
C
      CALL POWER(X,N,RESULT)
C
      WRITE(IOUTUN,*)'The function bounds are:'
      WRITE(IOUTUN,5)
     *'      12345678901234567890123456789',
     *'      12345678901234567890123456789'
    5 FORMAT(2(1X,A35))
      WRITE(IOUTUN,10) RESULT(1), RESULT(2)
   10 FORMAT(2(1X,D35.25))
C
      RMID   = MAX( ABS(.5D0*(RESULT(1)+RESULT(2) )), DSQRT(D1MACH(1)) )
      ABSE = RESULT(2)-RESULT(1)
      REL = ABSE/RMID
      RELERR = MAX(REL,RELERR)
      ABSERR = MAX(ABSE,ABSERR)
      WRITE(IOUTUN,20) 'Relative range width:', REL
      WRITE(IOUTUN,20) 'Absolute range width:', ABSE
   20 FORMAT(1X,A,1X,D35.25)
C
      IF(ABS(X(1)).LT.RMAX .AND. ABS(X(2)).LT.RMAX) THEN
         WRITE(IOUTUN,*)
     *    'The Fortran library function values at the endpoints are:'
         WRITE(IOUTUN,5)
     *'      12345678901234567890123456789',
     *'      12345678901234567890123456789'
         LF1 = X(1)**N
         LF2 = X(2)**N
         WRITE(IOUTUN,10) LF1, LF2
C
         BAD = (LF1.LT.RESULT(1)) .OR. (LF1.GT.RESULT(2))
     *    .OR. (LF2.LT.RESULT(1)) .OR. (LF2.GT.RESULT(2))
         OK = OK .AND. .NOT.BAD
         IF (BAD) THEN
            WRITE(IOUTUN,*) 'POINT FUNCTION VALUES ARE NOT WITHIN',
     *                      ' THE INTERVAL FUNCTION VALUE.'
            WRITE(IOUTUN,*) 'EITHER THE INTERVAL BOUNDS ARE WRONG',
     *                      ' OR THE CORRESPONDING FORTRAN-SUPPLIED'
            WRITE(IOUTUN,*) 'FUNCTION IS INNACURATE.'
         END IF
C
      END IF
      WRITE(IOUTUN,*)
     * '---------------------------------------------------'
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TISIN(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C A test routine for the interval elementary function library
C
C
C***********************************************************************
C
C  Routine tested -- ISIN
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DSIN, DSQRT
C
C***********************************************************************
C
C  Package routines called --
C
C     EVAL, ISIN, MULT, RNDOUT, SIMINI, SUB
C
C***********************************************************************
C
C  Variables --
C
      DOUBLE PRECISION X(2), RELMAX, ABSMAX
C
      INTEGER I
      DOUBLE PRECISION BHIGH, BLOW, SIZE
      DOUBLE PRECISION TMP(2), T, MAXX2(2), RMAX
C
      EXTERNAL ISIN
      INTRINSIC DSIN
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR,  ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      DOUBLE PRECISION XR(2,20), R1(20), R2(20), R3(20)
C
      DATA R1/
     *  0.02705383300781D0,  0.38760375976563D0,
     *  0.41886901855469D0,  0.96777343750000D0,
     *  0.92518615722656D0,  0.02670288085938D0,
     *  0.35655212402344D0,  0.36712646484375D0,
     *  0.47663879394531D0,  0.55740356445313D0,
     *  0.87724304199219D0,  0.30651855468750D0,
     *  0.85328674316406D0,  0.83908081054688D0,
     *  0.27781677246094D0,  0.27032470703125D0,
     *  0.47700500488281D0,  0.98110961914063D0,
     *  0.10514831542969D0,  0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,  0.34286499023438D0,
     *  0.15611267089844D0,  0.45867919921875D0,
     *  0.40315246582031D0,  0.53372192382813D0,
     *  0.47758483886719D0,  0.90197753906250D0,
     *  0.79933166503906D0,  0.41305541992188D0,
     *  0.36643981933594D0,  0.80718994140625D0,
     *  0.63008117675781D0,  0.09024047851563D0,
     *  0.36955261230469D0,  0.90869140625000D0,
     *  0.56727600097656D0,  0.92465209960938D0,
     *  0.28379821777344D0,  0.19085693359375D0/
C
      DATA R3/
     *  0.53279113769531D0,  0.52566528320313D0,
     *  0.15605163574219D0,  0.88806152343750D0,
     *  0.69850158691406D0,  0.75265502929688D0,
     *  0.28318786621094D0,  0.48468017578125D0,
     *  0.48628234863281D0,  0.71499633789063D0,
     *  0.21208190917969D0,  0.71508789062500D0,
     *  0.56800842285156D0,  0.77206420898438D0,
     *  0.73960876464844D0,  0.56365966796875D0,
     *  0.86555480957031D0,  0.53323364257813D0,
     *  0.91264343261719D0,  0.26477050781250D0/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK = .TRUE.
C
      CALL SIMINI
C
      DO 10 I = 1,20
         SIZE = MAXX*R1(I)**20
         BLOW = (-2D0+4D0*R2(I))*(PI(1)+PI(2))/2D0
         BHIGH =(2D0*R3(I)**3)*(PI(1)+PI(2))/2D0
         XR(1,I) = SIZE*BLOW
         XR(2,I) = XR(1,I)+BHIGH
   10 CONTINUE
C
      MAXX2(1) = MAXX
      MAXX2(2) = MAXX
      RMAX = MAXX/2D0
C
C [0, 0]
C
      X(1) = ZERO(1)
      X(2) = ZERO(2)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [pi, pi]
C
      X(1) = PI(1)
      X(2) = PI(2)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [pi/2, pi/2]
C
      X(1) = PI2(1)
      X(2) = PI2(2)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [(M-1)pi, (M-1)pi]
C
      CALL SUB(MAXX2,ONE,TMP)
      CALL MULT(TMP,PI,X)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [-pi, -pi]
C
      X(1) = -PI(2)
      X(2) = -PI(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [-pi/2, -pi/2]
C
      X(1) = -PI2(2)
      X(2) = -PI2(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [(1-M)pi, (1-M)pi]
C
      CALL SUB(ONE,MAXX2,TMP)
      CALL MULT(TMP,PI,X)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [sqrt(M)pi, sqrt(M)pi]
C
      TMP(1) = DSQRT(MAXX)
      TMP(2) = TMP(1)
      CALL MULT(TMP,PI,X)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [-sqrt(M)pi, -sqrt(M)pi]
C
      T = X(2)
      X(2) = -X(1)
      X(1) = -T
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C Check accuracy near X=0 --
C
      DO 20 I = 1,20
         X(1) = 10D0**(-I)
         X(2) = X(1)
         CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
   20 CONTINUE
C
      RELMAX = RELERR
      ABSMAX = ABSERR
C
C [8M, 8M]
C
      CALL MULT(EIGHT,MAXX2,X)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [-8M, -8M]
C
      T = X(2)
      X(2) = -X(1)
      X(1) = -T
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [pi/2, 3pi/2]
C
      X(1) = PI2(1)
      CALL MULT(THREE,PI2,TMP)
      X(2) = TMP(2)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [-3pi/2, -pi/2]
C
      T = X(2)
      X(2) = -X(1)
      X(1) = -T
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [pi, 2pi]
C
      X(1) = PI(1)
      CALL MULT(TWO,PI,TMP)
      X(2) = TMP(2)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C [-2pi, -pi]
C
      T = X(2)
      X(2) = -X(1)
      X(1) = -T
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,X)
C
C Twenty randomly generated intervals --
C
      DO 30 I = 1,20
         CALL EVAL(RMAX,IOUTUN,ISIN,DSIN,XR(1,I))
   30 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE'
         WRITE(IOUTUN,*) 'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE '
         WRITE(IOUTUN,*) 'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TISINH(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C A test routine for the interval elementary function library
C
C
C***********************************************************************
C
C  Routine tested --  ISINH
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DABS, DSINH, DLOG
C
C***********************************************************************
C
C  Package routines called --
C
C     D1MACH, EVAL, ISINH, RNDOUT, SIMINI
C
C***********************************************************************
C
C  Variables --
C
      DOUBLE PRECISION X(2), RELMAX, ABSMAX
C
      DOUBLE PRECISION T, MAXX2(2), RMAX
C
      EXTERNAL ISINH
      INTRINSIC DSINH
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR,  ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      INTEGER I
      DOUBLE PRECISION BHIGH, BLOW, D1MACH, SIZE
      DOUBLE PRECISION XR(2,20), R1(20), R2(20), R3(20)
C
      DATA R1/
     *  0.02705383300781D0,  0.38760375976563D0,
     *  0.41886901855469D0,  0.96777343750000D0,
     *  0.92518615722656D0,  0.02670288085938D0,
     *  0.35655212402344D0,  0.36712646484375D0,
     *  0.47663879394531D0,  0.55740356445313D0,
     *  0.87724304199219D0,  0.30651855468750D0,
     *  0.85328674316406D0,  0.83908081054688D0,
     *  0.27781677246094D0,  0.27032470703125D0,
     *  0.47700500488281D0,  0.98110961914063D0,
     *  0.10514831542969D0,  0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,  0.34286499023438D0,
     *  0.15611267089844D0,  0.45867919921875D0,
     *  0.40315246582031D0,  0.53372192382813D0,
     *  0.47758483886719D0,  0.90197753906250D0,
     *  0.79933166503906D0,  0.41305541992188D0,
     *  0.36643981933594D0,  0.80718994140625D0,
     *  0.63008117675781D0,  0.09024047851563D0,
     *  0.36955261230469D0,  0.90869140625000D0,
     *  0.56727600097656D0,  0.92465209960938D0,
     *  0.28379821777344D0,  0.19085693359375D0/
C
      DATA R3/
     *  0.53279113769531D0,  0.52566528320313D0,
     *  0.15605163574219D0,  0.88806152343750D0,
     *  0.69850158691406D0,  0.75265502929688D0,
     *  0.28318786621094D0,  0.48468017578125D0,
     *  0.48628234863281D0,  0.71499633789063D0,
     *  0.21208190917969D0,  0.71508789062500D0,
     *  0.56800842285156D0,  0.77206420898438D0,
     *  0.73960876464844D0,  0.56365966796875D0,
     *  0.86555480957031D0,  0.53323364257813D0,
     *  0.91264343261719D0,  0.26477050781250D0/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK = .TRUE.
C
      CALL SIMINI
C
      T = MXLGM1
      RMAX = T/2D0
      DO 10 I = 1,20
         SIZE = -1D0 + 2D0*R1(I)
         SIZE = SIZE*DABS(SIZE**2)*T
         BLOW = R2(I)
         BHIGH = BLOW + (1D0-BLOW)*R3(I)
         XR(1,I) = DEXP(SIZE)*BLOW
         XR(2,I) = DEXP(SIZE)*BHIGH
         XR(1,I) = DLOG(XR(1,I))
         XR(2,I) = DLOG(XR(2,I))
   10 CONTINUE
C
      MAXX2(1) = DLOG(D1MACH(2))-4D0
      MAXX2(2) = MAXX2(1)
      CALL RNDOUT(MAXX2,.TRUE.,.TRUE.)
C
C [0, 0]
C
      X(1) = ZERO(1)
      X(2) = ZERO(2)
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,X)
C
C [.25,.25]
C
      X(1) = .25D0
      X(2) = .25D0
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,X)
C
C [-.25,-.25]
C
      X(1) = -.25D0
      X(2) = -.25D0
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,X)
C
C [3,3]
C
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,THREE)
C
C [-3,-3]
C
      X(1) = -THREE(2)
      X(2) = -THREE(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,X)
C
C [9,9]
C
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,NINE)
C
C [-9,-9]
C
      X(1) = -NINE(2)
      X(2) = -NINE(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,X)
C
C [27,27]
C
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,TWOT7)
C
C [-27,-27]
C
      X(1) = -TWOT7(2)
      X(2) = -TWOT7(1)
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,X)
C
C [log(M), log(M)]
C
      X(1) = MAXX2(1)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,X)
C
C [-log(M), -log(M)]
C
      T = X(1)
      X(1) = -X(2)
      X(2) = -T
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,X)
C
C [.125, .125]
C
      X(1) = .125D0
      X(2) = .125D0
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,X)
C
C [-.125, -.125]
C
      X(1) = -.125D0
      X(2) = -.125D0
      CALL RNDOUT(X,.TRUE.,.TRUE.)
      CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,X)
C
      RELMAX = RELERR
      ABSMAX = ABSERR
C
C Twenty randomly generated intervals --
C
      DO 20 I = 1,20
         CALL EVAL(RMAX,IOUTUN,ISINH,DSINH,XR(1,I))
   20 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE'
         WRITE(IOUTUN,*) 'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE '
         WRITE(IOUTUN,*) 'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TISQRT(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C A test routine for the interval elementary function library
C
C
C***********************************************************************
C
C  Routine tested --  ISQRT
C
C***********************************************************************
C
C  Fortran intrinsic functions called --
C
C     DABS, DSQRT, DEXP, DLOG
C
C***********************************************************************
C
C  Package routines called --
C
C     D1MACH, EVAL, ISQRT, SIMINI
C
C***********************************************************************
C
C  Variables --
C
      DOUBLE PRECISION X(2), RELMAX, ABSMAX
C
      DOUBLE PRECISION T, MAXX2(2)
C
      EXTERNAL ISQRT
      INTRINSIC DSQRT
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR,  ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
C  Pseudorandom data and variables for scaling it --
C
      INTEGER I
      DOUBLE PRECISION BHIGH, BLOW, D1MACH, RMAX, SIZE
      DOUBLE PRECISION XR(2,20), R1(20), R2(20), R3(20)
C
      DATA R1/
     *  0.02705383300781D0,  0.38760375976563D0,
     *  0.41886901855469D0,  0.96777343750000D0,
     *  0.92518615722656D0,  0.02670288085938D0,
     *  0.35655212402344D0,  0.36712646484375D0,
     *  0.47663879394531D0,  0.55740356445313D0,
     *  0.87724304199219D0,  0.30651855468750D0,
     *  0.85328674316406D0,  0.83908081054688D0,
     *  0.27781677246094D0,  0.27032470703125D0,
     *  0.47700500488281D0,  0.98110961914063D0,
     *  0.10514831542969D0,  0.99291992187500D0/
C
      DATA R2/
     *  0.01966857910156D0,  0.34286499023438D0,
     *  0.15611267089844D0,  0.45867919921875D0,
     *  0.40315246582031D0,  0.53372192382813D0,
     *  0.47758483886719D0,  0.90197753906250D0,
     *  0.79933166503906D0,  0.41305541992188D0,
     *  0.36643981933594D0,  0.80718994140625D0,
     *  0.63008117675781D0,  0.09024047851563D0,
     *  0.36955261230469D0,  0.90869140625000D0,
     *  0.56727600097656D0,  0.92465209960938D0,
     *  0.28379821777344D0,  0.19085693359375D0/
C
      DATA R3/
     *  0.53279113769531D0,  0.52566528320313D0,
     *  0.15605163574219D0,  0.88806152343750D0,
     *  0.69850158691406D0,  0.75265502929688D0,
     *  0.28318786621094D0,  0.48468017578125D0,
     *  0.48628234863281D0,  0.71499633789063D0,
     *  0.21208190917969D0,  0.71508789062500D0,
     *  0.56800842285156D0,  0.77206420898438D0,
     *  0.73960876464844D0,  0.56365966796875D0,
     *  0.86555480957031D0,  0.53323364257813D0,
     *  0.91264343261719D0,  0.26477050781250D0/
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      RELERR=ZERO(1)
      ABSERR=ZERO(1)
      OK = .TRUE.
C
      CALL SIMINI
C
      MAXX2(1) = D1MACH(2)
      MAXX2(2) = MAXX2(1)
      RMAX = MAXX2(1)/TEN(2)
C
      T = DLOG(MAXX2(1))
      DO 10 I = 1,20
         SIZE = -1D0 + 2D0*R1(I)
         SIZE = SIZE*DABS(SIZE**2)*T
         BLOW = R2(I)
         BHIGH = BLOW + (1D0-BLOW)*R3(I)
         XR(1,I) = DEXP(SIZE)*BLOW
         XR(2,I) = DEXP(SIZE)*BHIGH
   10 CONTINUE
C
C [0, 0]
C
      X(1) = 0D0
      X(2) = 0D0
      CALL EVAL(RMAX,IOUTUN,ISQRT,DSQRT,X)
C
C [.25,.25]
C
      X(1) = .25D0
      X(2) = .25D0
      CALL EVAL(RMAX,IOUTUN,ISQRT,DSQRT,X)
C
C [.125, .125]
C
      X(1) = .125D0
      X(2) = .125D0
      CALL EVAL(RMAX,IOUTUN,ISQRT,DSQRT,X)
C
C [M,M]
C
      X(1) = MAXX2(1)/TEN(2)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,ISQRT,DSQRT,X)
C
C [TINY, TINY]
C
      X(1) = D1MACH(1)
      X(2) = X(1)
      CALL EVAL(RMAX,IOUTUN,ISQRT,DSQRT,X)
C
      RELMAX = RELERR
      ABSMAX = ABSERR
C
C Twenty randomly generated intervals --
C
      DO 20 I = 1,20
         CALL EVAL(RMAX,IOUTUN,ISQRT,DSQRT,XR(1,I))
   20 CONTINUE
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*)
     *'==============================================================='
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'SUMMARY SECTION'
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum relative width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', RELMAX
      WRITE(IOUTUN,*)
C
      WRITE(IOUTUN,*) 'Maximum absolute width of an output interval'
      WRITE(IOUTUN,*) 'with point input:', ABSMAX
      WRITE(IOUTUN,*)
C
      IF (OK) THEN
         WRITE(IOUTUN,*) 'Fortran-supplied function values at the ',
     *                   'endpoints were within'
         WRITE(IOUTUN,*) 'the interval bounds in each case tested.'
      ELSE
         WRITE(IOUTUN,*) 'FORTRAN-SUPPLIED FUNCTION VALUES AT THE ',
     *                   'ENDPOINTS WERE NOT WITHIN THE INTERVAL'
         WRITE(IOUTUN,*) 'BOUNDS FOR AT LEAST ONE CASE TESTED.  SEE'
         WRITE(IOUTUN,*) 'THE DETAILED PRINTOUT ABOVE FOR WHICH CASE.'
         WRITE(IOUTUN,*)
         WRITE(IOUTUN,*) 'EITHER THE FORTRAN-SUPPLIED FUNCTIONS ARE '
         WRITE(IOUTUN,*) 'INACCURATE OR THE INTERVAL BOUNDS ARE WRONG.'
      END IF
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE TIUTIL(IOUTUN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER IOUTUN
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C A test routine for the interval elementary function library
C
C
C***********************************************************************
C
C  Routines tested --
C
C   The utility routines ICAP, IDISJ, IHULL, IILEI, IILTI, IINF, IMID,
C   IMIG, INTABS, IRLEI, IRLTI, ISUP, IVL1, IVL2, and IWID.
C
C   The tests are not exhaustive tries of all possible arguments, but
C   are meant mainly to verify that these routines have been compiled
C   and linked properly.  This paradigm is appropriate to the extent
C   that each of the routines involves only several statements.
C
C***********************************************************************
C
C  Package routines called --
C
C     UOUT1, UOUT1B, UOUT1C, UOUT2, UOUTL, and SIMINI, as well as the
C     routines listed above.
C
      LOGICAL IDISJ, IILEI, IILTI, IRLEI, IRLTI
      DOUBLE PRECISION IINF, IMID, IMIG, INTABS, ISUP, IWID
C
C***********************************************************************
C
C  Variables --
C
      INTEGER NTRIES
      PARAMETER (NTRIES=7)
C
      DOUBLE PRECISION X(2,NTRIES), Y(2,NTRIES), RESULT(2)
      INTEGER I
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION MAXX, MXLGM1, NEGINF, POSINF, A(2), PI(2), E(2),
     *   PI2(2), PI3(2), PI4(2), PI6(2), PI8(2), E14(2), A3(2), ONE(2),
     *   OD2F(2), OD3F(2), OD4F(2), OD5F(2), OD6F(2), OD7F(2), OD8F(2),
     *   OD9F(2), OD10F(2), OD11F(2), OD12F(2), OD14F(2), EIGHT(2),
     *   ZERO(2), TWO(2), THREE(2), FOUR(2), SXTNTH(2), NINE(2), TEN(2),
     *   TWOT7(2), SQT10(2), ESXTNT(2), SXTEEN(2), THIRD(2), FOURTH(2),
     *   FIFTH(2), SIXTH(2), SEVNTH(2), EIGHTH(2), NINTH(2), TENTH(2),
     *   ELEVTH(2), TWLVTH(2), THRTTH(2), FORTTH(2), TT7TH(2), TINY2,
     *   CBTEP, SQT3(2), ODSQT3(2)
C
      COMMON /MTHCNS/  MAXX, MXLGM1, NEGINF, POSINF, A, PI, E, PI2, PI3,
     *   PI4, PI6, PI8, ONE, OD2F, OD3F, E14, A3, OD4F, OD5F, OD6F,
     *   OD7F, OD8F, OD9F, OD10F, OD11F, OD12F, OD14F, EIGHT, ZERO, TWO,
     *   THREE, FOUR, SXTNTH, NINE, TEN, TWOT7, SQT10, ESXTNT, SXTEEN,
     *   THIRD, FOURTH, FIFTH, SIXTH, SEVNTH, EIGHTH, NINTH, TENTH,
     *   ELEVTH, TWLVTH, THRTTH, FORTTH, TT7TH, TINY2, CBTEP, SQT3,
     *   ODSQT3
C
      INTEGER ITINY2, JTINY2
C
      COMMON /IMATH/   ITINY2, JTINY2
C
C
C  The above common blocks hold mathematical constants which are used in
C  the elementary function routines.
C
C  Variable descriptions
C
C  MAXX        a double precision representation of the largest
C              representable integer
C
C  MXLGM1      an approximation to the logarithm of .25 times the
C              largest representable machine number, minus 1. This
C              should be a rigorous lower bound on the logarithm of the
C              largest representable machine number.  Its default
C              computation in SIMINI is to use the Fortran LOG function.
C              This should be changed if the Fortran LOG function is not
C              sufficiently accurate.
C
C
C  A           an interval enclosure for 1/pi
C
C  PI          an interval enclosure for pi
C
C  PI2         an interval enclosure for pi/2
C
C  PI3         an interval enclosure for pi/3
C
C  PI4         an interval enclosure for pi/4
C
C  PI6         an interval enclosure for pi/6
C
C  PI8         an interval enclosure for pi/8
C
C  E           an interval enclosure for E
C
C  E14         an interval enclosure for e^{1/4}
C
C  ESXTNT      an interval enclosure for e^{1/16}
C
C  SQT10       an interval enclosure for SQRT(10)
C
C  TINY2       the maximum of the smallest machine number and the
C              reciprocal of the largest machine number.  This quantity
C              is checked to avoid overflow in certain places.
C
C  CBTEP       an approximation to the cube root of six times the
C              largest distance between numbers.
C
C  SQT3        an interval enclosure for the square root of 3.
C
C  ODSQT3      the reciprocal of the square root of 3 times
C              1+ 100*MXULP, used in argument reduction in the
C              arctangent routine.
C
C  ITINY2      the logarithm base 10 of TINY2 truncated to an integer.
C
C  JTINY2      sixteen times the logarithm base e of TINY2 truncated to
C              an integer.
C
C  See the statements in the routine SIMINI for the definitions of
C  the other constants.
C
C***********************************************************************
C
C  Beginning of executable statements --
C
      CALL SIMINI
C
C X = [0,1], Y = [-1,1]
C
      X(1,1) = ZERO(1)
      X(2,1) = ONE(2)
      Y(1,1) = -ONE(2)
      Y(2,1) = ONE(2)
C
C X = [0,1], Y = [2,3]
C
      X(1,2) = ZERO(1)
      X(2,2) = ONE(2)
      Y(1,2) = TWO(1)
      Y(2,2) = THREE(2)
C
C X = [-2,1], Y = [2,3]
C
      X(1,3) = -TWO(2)
      X(2,3) = ONE(2)
      Y(1,3) = TWO(1)
      Y(2,3) = THREE(2)
C
C X = [1,1], Y = [1,1]
C
      X(1,4) = ONE(1)
      X(2,4) = ONE(1)
      Y(1,4) = ONE(1)
      Y(2,4) = ONE(1)
C
C X = [-1,-1], Y = [-1,-1]
C
      X(1,5) = -ONE(2)
      X(2,5) = -ONE(2)
      Y(1,5) = -ONE(2)
      Y(2,5) = -ONE(2)
C
C X = [-1,1], Y = [-1,1]
C
      X(1,6) = -ONE(2)
      X(2,6) = ONE(2)
      Y(1,6) = -ONE(2)
      Y(2,6) = ONE(2)
C
C X = [-1,2], Y = [-2,1]
C
      X(1,7) = -ONE(2)
      X(2,7) = TWO(2)
      Y(1,7) = -TWO(2)
      Y(2,7) = ONE(2)
C
      WRITE(IOUTUN,*) 'TEST OF ICAP FOLLOWS:'
      DO 10 I = 1,NTRIES
         CALL ICAP(X(1,I),Y(1,I),RESULT)
         CALL UOUT2(IOUTUN,X(1,I),Y(1,I),RESULT)
   10 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IDISJ FOLLOWS:'
      DO 20 I = 1,NTRIES
         CALL UOUTL(IOUTUN,X(1,I),Y(1,I),IDISJ(X(1,I),Y(1,I)))
   20 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IHULL FOLLOWS:'
      DO 30 I = 1,NTRIES
         CALL IHULL(X(1,I),Y(1,I),RESULT)
         CALL UOUT2(IOUTUN,X(1,I),Y(1,I),RESULT)
   30 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IILEI FOLLOWS:'
      DO 40 I = 1,NTRIES
         CALL UOUTL(IOUTUN,X(1,I),Y(1,I),IILEI(X(1,I),Y(1,I)))
   40 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IILTI FOLLOWS:'
      DO 50 I = 1,NTRIES
         CALL UOUTL(IOUTUN,X(1,I),Y(1,I),IILTI(X(1,I),Y(1,I)))
   50 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IINF FOLLOWS:'
      DO 60 I = 1,NTRIES
         CALL UOUT1B(IOUTUN,X(1,I),IINF(X(1,I)))
   60 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IMID FOLLOWS:'
      DO 70 I = 1,NTRIES
         CALL UOUT1B(IOUTUN,X(1,I),IMID(X(1,I)))
   70 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IMIG FOLLOWS:'
      DO 80 I = 1,NTRIES
         CALL UOUT1B(IOUTUN,X(1,I),IMIG(X(1,I)))
   80 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF INTABS FOLLOWS:'
      DO 90 I = 1,NTRIES
         CALL UOUT1B(IOUTUN,X(1,I),INTABS(X(1,I)))
   90 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IRLEI FOLLOWS:'
      DO 100 I = 1,NTRIES
         CALL UOUTLB(IOUTUN,X(1,I),Y(1,I),IRLEI(X(1,I),Y(1,I)))
  100 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IRLTI FOLLOWS:'
      DO 110 I = 1,NTRIES
         CALL UOUTLB(IOUTUN,X(1,I),Y(1,I),IRLTI(X(1,I),Y(1,I)))
  110 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF ISUP FOLLOWS:'
      DO 120 I = 1,NTRIES
         CALL UOUT1B(IOUTUN,X(1,I),ISUP(X(1,I)))
  120 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IVL1 FOLLOWS:'
      DO 130 I = 1,NTRIES
         CALL IVL1(X(1,I),RESULT)
         CALL UOUT1C(IOUTUN,X(1,I),RESULT)
  130 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IVL2 FOLLOWS:'
      DO 140 I = 1,NTRIES
         CALL IVL2(X(1,I),Y(1,I),RESULT)
         CALL UOUT2B(IOUTUN,X(1,I),Y(1,I),RESULT)
  140 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IVLABS FOLLOWS:'
      DO 150 I = 1,NTRIES
         CALL IVLABS(X(1,I),RESULT)
         CALL UOUT1(IOUTUN,X(1,I),RESULT)
  150 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      WRITE(IOUTUN,*) 'TEST OF IWID FOLLOWS:'
      DO 160 I = 1,NTRIES
         CALL UOUT1B(IOUTUN,X(1,I),IWID(X(1,I)))
  160 CONTINUE
      WRITE(IOUTUN,*)
     *'***************************************************************'
      WRITE(IOUTUN,*)
     *'***************************************************************'
C
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE UOUT1(IOUTUN,X,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C An auxiliary routine for testing the interval elementary function
C library
C
C***********************************************************************
C
C Function --
C
C  This routine provides output of results for one-argument
C  utility function routines in the package for the test driver.
C
C***********************************************************************
C
C Argument declarations --
C
      INTEGER IOUTUN
      DOUBLE PRECISION X(2), RESULT(2)
C
C***********************************************************************
C
C  Argument descriptions --
C
C IOUTUN is the unit number for output.
C
C X      [X(1),X(2)] is the interval over which the function
C        was evaluated.
C
C RESULT is the interval result of the evaluation.
C
C***********************************************************************
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) '[X1,X2] is:'
      WRITE(IOUTUN,*) '[',X(1),',',X(2),']'
C
      WRITE(IOUTUN,*)'The function bounds on [X1,X2] are:'
      WRITE(IOUTUN,10) RESULT(1), RESULT(2)
   10 FORMAT(2(1X,D35.25))
      WRITE(IOUTUN,*)
     * '---------------------------------------------------'
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE UOUT1B(IOUTUN,X,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C An auxiliary routine for testing the interval elementary function
C library
C
C***********************************************************************
C
C Function --
C
C  This routine provides output of results for one-argument
C  utility function routines with non-interval results.
C
C***********************************************************************
C
C Argument declarations --
C
      INTEGER IOUTUN
      DOUBLE PRECISION X(2), RESULT
C
C***********************************************************************
C
C  Argument descriptions --
C
C IOUTUN is the unit number for output.
C
C X      [X(1),X(2)] is the interval over which the function
C        was evaluated.
C
C RESULT is the double precision result of the evaluation.
C
C***********************************************************************
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) '[X1,X2] is:'
      WRITE(IOUTUN,*) '[',X(1),',',X(2),']'
C
      WRITE(IOUTUN,10)'The result on [X1,X2] is:', RESULT
   10 FORMAT(1X,A,1X,D35.25)
      WRITE(IOUTUN,*)
     * '---------------------------------------------------'
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE UOUT1C(IOUTUN,X,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C An auxiliary routine for testing the interval elementary function
C library
C
C***********************************************************************
C
C Function --
C
C  This routine provides output of results for one real argument
C  utility function routines in the package for the test driver.
C
C***********************************************************************
C
C Argument declarations --
C
      INTEGER IOUTUN
      DOUBLE PRECISION X, RESULT(2)
C
C***********************************************************************
C
C  Argument descriptions --
C
C IOUTUN is the unit number for output.
C
C X      is the real variable over which the function was evaluated.
C
C RESULT is the interval result of the evaluation.
C
C***********************************************************************
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,5) 'Input point X is:',X
    5 FORMAT(1X,A,1X,D35.25)
C
      WRITE(IOUTUN,*)'The function bounds on X are:'
      WRITE(IOUTUN,10) RESULT(1), RESULT(2)
   10 FORMAT(2(1X,D35.25))
      WRITE(IOUTUN,*)
     * '---------------------------------------------------'
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE UOUT2(IOUTUN,X,Y,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C An auxiliary routine for testing the interval elementary function
C library
C
C***********************************************************************
C
C Function --
C
C  This routine provides output of results for two-argument
C  utility function routines in the package for the test driver.
C
C***********************************************************************
C
C Argument declarations --
C
      INTEGER IOUTUN
      DOUBLE PRECISION X(2), Y(2), RESULT(2)
C
C***********************************************************************
C
C  Argument descriptions --
C
C IOUTUN is the unit number for output.
C
C X      [X(1),X(2)] is the first argement over which the function
C        was evaluated.
C
C Y      [Y(1),Y(2)] is the second argement over which the function
C        was evaluated.
C
C RESULT is the interval result of the evaluation.
C
C***********************************************************************
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) '[X1,X2] is:'
      WRITE(IOUTUN,*) '[',X(1),',',X(2),']'
      WRITE(IOUTUN,*) '[Y1,Y2] is:'
      WRITE(IOUTUN,*) '[',Y(1),',',Y(2),']'
C
      WRITE(IOUTUN,*)'The function bounds are:'
      WRITE(IOUTUN,10) RESULT(1), RESULT(2)
   10 FORMAT(2(1X,D35.25))
      WRITE(IOUTUN,*)
     * '---------------------------------------------------'
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE UOUT2B(IOUTUN,X,Y,RESULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C An auxiliary routine for testing the interval elementary function
C library
C
C***********************************************************************
C
C Function --
C
C  This routine provides output of results for two-real-argument
C  utility function routines in the package for the test driver.
C
C***********************************************************************
C
C Argument declarations --
C
      INTEGER IOUTUN
      DOUBLE PRECISION X, Y, RESULT(2)
C
C***********************************************************************
C
C  Argument descriptions --
C
C IOUTUN is the unit number for output.
C
C X      X is the first argement at which the function was evaluated.
C
C Y      Y is the second argement at which the function was evaluated.
C
C RESULT is the interval result of the evaluation.
C
C***********************************************************************
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'X is:', X
      WRITE(IOUTUN,*) 'Y is:', Y
C
      WRITE(IOUTUN,*)'The function bounds are:'
      WRITE(IOUTUN,10) RESULT(1), RESULT(2)
   10 FORMAT(2(1X,D35.25))
      WRITE(IOUTUN,*)
     * '---------------------------------------------------'
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE UOUTL(IOUTUN,X,Y,LRSULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C An auxiliary routine for testing the interval elementary function
C library
C
C***********************************************************************
C
C Function --
C
C  This routine provides output of results for logical
C  utility function routines in the package for the test driver.
C
C***********************************************************************
C
C Argument declarations --
C
      INTEGER IOUTUN
      DOUBLE PRECISION X(2), Y(2)
      LOGICAL LRSULT
C
C***********************************************************************
C
C  Argument descriptions --
C
C IOUTUN is the unit number for output.
C
C X      [X(1),X(2)] is the first argement over which the function
C        was evaluated.
C
C Y      [Y(1),Y(2)] is the second argement over which the function
C        was evaluated.
C
C LRSULT is the logical result of the evaluation.
C
C***********************************************************************
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) '[X1,X2] is:'
      WRITE(IOUTUN,*) '[',X(1),',',X(2),']'
      WRITE(IOUTUN,*) '[Y1,Y2] is:'
      WRITE(IOUTUN,*) '[',Y(1),',',Y(2),']'
C
      WRITE(IOUTUN,*)'The result of the test is:', LRSULT
      WRITE(IOUTUN,*)
     * '---------------------------------------------------'
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE UOUTLB(IOUTUN,X,Y,LRSULT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C An auxiliary routine for testing the interval elementary function
C library
C
C***********************************************************************
C
C Function --
C
C  This routine provides output of results for logical
C  utility function routines with a real and an interval argument in the
C  package for the test driver.
C
C***********************************************************************
C
C Argument declarations --
C
      INTEGER IOUTUN
      DOUBLE PRECISION X, Y(2)
      LOGICAL LRSULT
C
C***********************************************************************
C
C  Argument descriptions --
C
C IOUTUN is the unit number for output.
C
C X      [X(1),X(2)] is the first argement over which the function
C        was evaluated.
C
C Y      [Y(1),Y(2)] is the second argement over which the function
C        was evaluated.
C
C LRSULT is the logical result of the evaluation.
C
C***********************************************************************
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) 'X is:', X
      WRITE(IOUTUN,*) '[Y1,Y2] is:'
      WRITE(IOUTUN,*) '[',Y(1),',',Y(2),']'
C
      WRITE(IOUTUN,*)'The result of the test is:', LRSULT
      WRITE(IOUTUN,*)
     * '---------------------------------------------------'
C
      RETURN
      END
C***********************************************************************
C***********************************************************************
      SUBROUTINE EVAL(RMAX,IOUTUN,FCN,LFCN,X)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C Written by:
C
C   R. Baker Kearfott
C   Department of Mathematics
C   U.S.L. Box 4-1010
C   Lafayette, LA 70504
C
C   April 11, 1992
C
C An auxiliary routine for testing the interval elementary function
C library
C
C***********************************************************************
C
C  Function --
C
C    This routine provides a generic interface between the routines
C    in the package and the test drivers.  It also provides output of
C    the results for all of the test drivers.  As an additional check,
C    the Fortran intrinsic functions are called at the endpoints of the
C    input interval, as long as those endpoints are within the
C    proper range.
C
C***********************************************************************
C
C  Argument declarations --
C
      DOUBLE PRECISION RMAX
      INTEGER IOUTUN
      EXTERNAL FCN
      DOUBLE PRECISION LFCN
      DOUBLE PRECISION X(2)
C
C***********************************************************************
C
C  Argument descriptions --
C
C RMAX   defines a bound on the set of allowable values of the
C        corresponding Fortran 77 intrinsic function.  The fortran
C        intrinsic function is not evaluated if
C        MAX(ABS(X(1)),ABS(X(2)) > RMAX.
C
C IOUTUN is the unit number for output.
C
C FCN    is the name of the interval elementary function routine being
C        tested.
C
C LFCN   is the name of the Fortran intrinsic function corresponding to
C        FCN.
C
C X      [X(1),X(2)] is the interval over which the function defined in
C        FCN is to be evaluated.
C
C***********************************************************************
C
C  Fortran-supplied routines --
C
C     ABS, MAX
C
C***********************************************************************
C
C  Package routines --
C
      DOUBLE PRECISION D1MACH
C
C
C***********************************************************************
C
C  Internal variable declarations --
C
      DOUBLE PRECISION RESULT(2), LF1, LF2, RMID, REL, ABSE
      LOGICAL BAD
C
C***********************************************************************
C
C  Common block declarations --
C
      DOUBLE PRECISION RELERR, ABSERR
      LOGICAL OK
      COMMON /ACCURA/ RELERR, ABSERR, OK
C
C   The above common block is to keep track of the maximum
C   relative width, to judge error when the input intervals are
C   points.
C
C***********************************************************************
C
      BAD = .FALSE.
C
      WRITE(IOUTUN,*)
      WRITE(IOUTUN,*) '[X1,X2] is:'
      WRITE(IOUTUN,*) '[',X(1),',',X(2),']'
C
      CALL FCN(X,RESULT)
C
      WRITE(IOUTUN,*)'The function bounds on [X1,X2] are:'
      WRITE(IOUTUN,5)
     *'      12345678901234567890123456789',
     *'      12345678901234567890123456789'
    5 FORMAT(2(1X,A35))
      WRITE(IOUTUN,10) RESULT(1), RESULT(2)
   10 FORMAT(2(1X,D35.25))
C
      RMID   = MAX( ABS( .5D0*RESULT(1)+.5D0*RESULT(2) ),
     *                   DSQRT(D1MACH(1)) )
      ABSE = RESULT(2)-RESULT(1)
      REL = ABSE/RMID
      RELERR = MAX(REL,RELERR)
      ABSERR = MAX(ABSE,ABSERR)
      WRITE(IOUTUN,20) 'Relative range width:', REL
      WRITE(IOUTUN,20) 'Absolute range width:', ABSE
   20 FORMAT(1X,A,1X,D35.25)
C
      IF(ABS(X(1)).LT.RMAX .AND. ABS(X(2)).LT.RMAX) THEN
         WRITE(IOUTUN,*)
     *    'The Fortran library function values at the endpoints are:'
         WRITE(IOUTUN,5)
     *'      12345678901234567890123456789',
     *'      12345678901234567890123456789'
         LF1 = LFCN(X(1))
         LF2 = LFCN(X(2))
         WRITE(IOUTUN,10) LF1, LF2
C
         BAD =  (LF1.LT.RESULT(1)) .OR. (LF1.GT.RESULT(2))
     *    .OR. (LF2.LT.RESULT(1)) .OR. (LF2.GT.RESULT(2))
         OK = OK .AND. .NOT.BAD
         IF (BAD) THEN
            WRITE(IOUTUN,*) 'POINT FUNCTION VALUES ARE NOT WITHIN',
     *                      ' THE INTERVAL FUNCTION VALUE.'
            WRITE(IOUTUN,*) 'EITHER THE INTERVAL BOUNDS ARE WRONG',
     *                      ' OR THE CORRESPONDING FORTRAN-SUPPLIED'
            WRITE(IOUTUN,*) 'FUNCTION IS INNACURATE.'
         END IF
C
      END IF
      WRITE(IOUTUN,*)
     * '---------------------------------------------------'
C
      RETURN
      END

c*** intlibts.out
 TEST OF ROUTINE IACOS FOLLOWS
 
 
 
 [X1,X2] is:
 [  0.000000000000000E+000,  0.000000000000000E+000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  4.999999999999999E-001,  5.000000000000001E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1047197551196594000000000D+01      .1047197551196601000000000D+01
 Relative range width:      .6361109362927035000000000D-14
 Absolute range width:      .6661338147750939000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1047197551196598000000000D+01      .1047197551196598000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -5.000000000000001E-001, -4.999999999999999E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2094395102393192000000000D+01      .2094395102393205000000000D+01
 Relative range width:      .6361109362927025000000000D-14
 Absolute range width:      .1332267629550188000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2094395102393196000000000D+01      .2094395102393195000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  8.660254037844376E-001,  8.660254037844396E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5235987755982926000000000D+00      .5235987755983053000000000D+00
 Relative range width:      .2417221557912272000000000D-13
 Absolute range width:      .1265654248072678000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5235987755983009000000000D+00      .5235987755982969000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -8.660254037844398E-001, -8.660254037844374E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2617993877991487000000000D+01      .2617993877991502000000000D+01
 Relative range width:      .5937035405398563000000000D-14
 Absolute range width:      .1554312234475219000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2617993877991497000000000D+01      .2617993877991492000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1332267629550188000000000D-14      .2980232371996295000000000D-07
 Relative range width:      .2000000178813934000000000D+01
 Absolute range width:      .2980232505223058000000000D-07
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2107342425544702000000000D-07      .2107342425544702000000000D-07
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -9.999999999999996E-001, -9.999999999999996E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3141592617089549000000000D+01      .3141592653589796000000000D+01
 Relative range width:      .1161838948003941000000000D-07
 Absolute range width:      .3650024682499975000000000D-07
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3141592623787471000000000D+01      .3141592623787471000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.225073858507201E-308,  2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.225073858507201E-308, -2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -9.606628417968800E-001, -9.458923339843800E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2811130035041763000000000D+01      .2860175524520529000000000D+01
 Relative range width:      .1729601375333115000000000D-01
 Absolute range width:      .4904548947876641000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2860175524520523000000000D+01      .2811130035041767000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -3.142700195312400E-001, -2.247924804687400E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1797526387591276000000000D+01      .1890483943021833000000000D+01
 Relative range width:      .5041068060951079000000000D-01
 Absolute range width:      .9295755543055684000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1890483943021831000000000D+01      .1797526387591277000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.877746582031200E-001, -1.622619628906200E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1733778891513089000000000D+01      .2329215380999674000000000D+01
 Relative range width:      .2931023031535492000000000D+00
 Absolute range width:      .5954364894865849000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2329215380999665000000000D+01      .1733778891513090000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -8.264160156250000E-002,  9.355468750000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3609920911791111000000000D+00      .1653532287295592000000000D+01
 Relative range width:      .1283221200922004000000000D+01
 Absolute range width:      .1292540196116480000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1653532287295591000000000D+01      .3609920911791145000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.936950683593800E-001,  8.503723144531199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5541038589720603000000000D+00      .1765723480091116000000000D+01
 Relative range width:      .1044577413772827000000000D+01
 Absolute range width:      .1211619621119056000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1765723480091114000000000D+01      .5541038589720647000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -9.465942382812400E-001,  6.744384765625999E-002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1503301244199433000000000D+01      .2813300062624256000000000D+01
 Relative range width:      .6069584496274766000000000D+00
 Absolute range width:      .1309998818424823000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2813300062624251000000000D+01      .1503301244199434000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.868957519531200E-001, -4.483032226562000E-002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1615641679005701000000000D+01      .1861781113323459000000000D+01
 Relative range width:      .1415642842513805000000000D+00
 Absolute range width:      .2461394343177572000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1861781113323457000000000D+01      .1615641679005702000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.657470703125000E-001,  8.039550781250000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .6368800379291712000000000D+00      .1839775101248654000000000D+01
 Relative range width:      .9713868065772029000000000D+00
 Absolute range width:      .1202895063319483000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1839775101248653000000000D+01      .6368800379291762000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.672241210938000E-002,  5.986633300781199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9289650106024032000000000D+00      .1617535754669633000000000D+01
 Relative range width:      .5407975944540281000000000D+00
 Absolute range width:      .6885707440672293000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1617535754669632000000000D+01      .9289650106024112000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.738891601562400E-001,  1.148071289062600E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1455735484191357000000000D+01      .1745573957308707000000000D+01
 Relative range width:      .1810749497440261000000000D+00
 Absolute range width:      .2898384731173502000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1745573957308706000000000D+01      .1455735484191358000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.671203613281200E-001,  7.544860839843801E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .7159255914300560000000000D+00      .1841199894045294000000000D+01
 Relative range width:      .8801087854365177000000000D+00
 Absolute range width:      .1125274302615238000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1841199894045292000000000D+01      .7159255914300605000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -3.869628906250000E-001,  6.143798828125000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9091965440323886000000000D+00      .1968131929582135000000000D+01
 Relative range width:      .7360545695497206000000000D+00
 Absolute range width:      .1058935385549747000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1968131929582132000000000D+01      .9091965440323967000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.601623535156199E-001,  7.065734863281199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .7861520721012375000000000D+00      .1307605984136162000000000D+01
 Relative range width:      .4981033128268949000000000D+00
 Absolute range width:      .5214539120349243000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1307605984136160000000000D+01      .7861520721012447000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -8.195190429687400E-001,  6.781616210937600E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .8255380811527215000000000D+00      .2531367550716110000000000D+01
 Relative range width:      .1016310648335820000000000D+01
 Absolute range width:      .1705829469563388000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2531367550716104000000000D+01      .8255380811527289000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.443664550781200E-001, -2.608947753906200E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1834745289426104000000000D+01      .2031263259843107000000000D+01
 Relative range width:      .1016645296628485000000000D+00
 Absolute range width:      .1965179704170028000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2031263259843103000000000D+01      .1834745289426105000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.593505859375000E-001,  8.173828125000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .6139430402289663000000000D+00      .2048060274833687000000000D+01
 Relative range width:      .1077472162780509000000000D+01
 Absolute range width:      .1434117234604721000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2048060274833684000000000D+01      .6139430402289709000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.598999023438000E-002,  1.345520019531199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1435834987509589000000000D+01      .1616802544557795000000000D+01
 Relative range width:      .1185647199493391000000000D+00
 Absolute range width:      .1809675570482054000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1616802544557794000000000D+01      .1435834987509590000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  8.493041992187600E-001,  9.622192382812600E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2757574501943416000000000D+00      .5561304785527289000000000D+00
 Relative range width:      .6740644230303112000000000D+00
 Absolute range width:      .2803730283583873000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5561304785527246000000000D+00      .2757574501943448000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -7.897033691406200E-001, -4.324035644531200E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2017953056012622000000000D+01      .2481121658962657000000000D+01
 Relative range width:      .2058950483344350000000000D+00
 Absolute range width:      .4631686029500348000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2481121658962652000000000D+01      .2017953056012626000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.182861328125000E-001,  9.858398437500000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1684856157290133000000000D+00      .2237356531940624000000000D+01
 Relative range width:      .1719872534626242000000000D+01
 Absolute range width:      .2068870916211611000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2237356531940615000000000D+01      .1684856157290165000000000D+00
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:       2.000000178813934
 
 Maximum absolute width of an output interval
 with point input:  3.650024682499975E-008
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TEST OF ROUTINE IACOT FOLLOWS
 
 
 
 [X1,X2] is:
 [  0.000000000000000E+000,  0.000000000000000E+000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .5654319433712919000000000D-15
 Absolute range width:      .8881784197001252000000000D-15
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.500000000000000E-001,  2.500000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1325817663668031000000000D+01      .1325817663668034000000000D+01
 Relative range width:      .2344684758800135000000000D-14
 Absolute range width:      .3108624468950438000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1325817663668032000000000D+01      .1325817663668032000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.500000000000000E-001, -2.500000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1815774989921759000000000D+01      .1815774989921763000000000D+01
 Relative range width:      .2078868970371809000000000D-14
 Absolute range width:      .3774758283725532000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1815774989921761000000000D+01      .1815774989921761000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [       1.732050807568877,       1.732050807568878]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5235987755982935000000000D+00      .5235987755983044000000000D+00
 Relative range width:      .2077962391889497000000000D-13
 Absolute range width:      .1088018564132653000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5235987755982989000000000D+00      .5235987755982987000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.732050807568878,      -1.732050807568876]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2617993877991488000000000D+01      .2617993877991501000000000D+01
 Relative range width:      .4749628324318851000000000D-14
 Absolute range width:      .1243449787580175000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2617993877991494000000000D+01      .2617993877991494000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  5.773502691896256E-001,  5.773502691896260E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1047197551196593000000000D+01      .1047197551196602000000000D+01
 Relative range width:      .7845368214276677000000000D-14
 Absolute range width:      .8215650382226158000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1047197551196598000000000D+01      .1047197551196598000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -5.773502691896261E-001, -5.773502691896255E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2094395102393191000000000D+01      .2094395102393201000000000D+01
 Relative range width:      .4664813532813157000000000D-14
 Absolute range width:      .9769962616701378000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2094395102393196000000000D+01      .2094395102393195000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.797693134862316E+307,  1.797693134862316E+307]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1332267629550188000000000D-14      .1332267629550188000000000D-14
 Relative range width:      .1786278848828884000000000+140
 Absolute range width:      .2664535259100376000000000D-14
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.225073858507201E-308,  2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.225073858507201E-308, -2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.276847097890946E-261,  1.115951231047181E-262]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -9.903652608056447E-005,  1.186774665360168E-004]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570677649328917000000000D+01      .1570895363320654000000000D+01
 Relative range width:      .1386018983870790000000000D-03
 Absolute range width:      .2177139917374227000000000D-03
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570895363320653000000000D+01      .1570677649328918000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -3.315313621677351E-002, -2.045730221667231E-002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1591250775926008000000000D+01      .1603937324475357000000000D+01
 Relative range width:      .7941033923952824000000000D-02
 Absolute range width:      .1268654854934881000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1603937324475356000000000D+01      .1591250775926009000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.123731537608978E+251,  2.258376007728173E+252]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1332267629550188000000000D-14      .3141592653589796000000000D+01
 Relative range width:      .2000000000000002000000000D+01
 Absolute range width:      .3141592653589797000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3141592653589793000000000D+01     -.6125742274543100000000000D-16
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.964880865780309E+188,  2.301679644601745E+189]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1332267629550188000000000D-14      .3141592653589796000000000D+01
 Relative range width:      .2000000000000002000000000D+01
 Absolute range width:      .3141592653589797000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3141592653589793000000000D+01     -.6125742274543100000000000D-16
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.351392160813672E-263,  2.682250315279288E-262]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.357209448835715E-009,  1.320053815155970E-008]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796313594357000000000D+01      .1570796329152107000000000D+01
 Relative range width:      .9904371000500325000000000D-08
 Absolute range width:      .1555774953310163000000000D-07
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796329152106000000000D+01      .1570796313594358000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.318482309723622E-006,  1.474313137791030E-006]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570794852481758000000000D+01      .1570795008312588000000000D+01
 Relative range width:      .9920507558305652000000000D-07
 Absolute range width:      .1558308297955335000000000D-06
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570795008312587000000000D+01      .1570794852481759000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  5.568554095093109E-001,  7.383890571322996E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9347677293175244000000000D+00      .1062705085920429000000000D+01
 Relative range width:      .1280992218035907000000000D+00
 Absolute range width:      .1279373566029046000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1062705085920425000000000D+01      .9347677293175263000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -5.090196402955172E-001,       1.947911243674908]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .4742866366932866000000000D+00      .2041633584484440000000000D+01
 Relative range width:      .1245943281188354000000000D+01
 Absolute range width:      .1567346947791153000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2041633584484436000000000D+01      .4742866366932915000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.595101589308905E+131,  3.982298428764696E+129]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1332267629550188000000000D-14      .3141592653589796000000000D+01
 Relative range width:      .2000000000000002000000000D+01
 Absolute range width:      .3141592653589797000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3141592653589793000000000D+01     -.6125742274543100000000000D-16
 ---------------------------------------------------
 
 [X1,X2] is:
 [  8.451756729797211E-019,  1.224516081280632E-018]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.423456662773590E+108,  3.722732096481154E+108]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1332267629550188000000000D-14      .1332267629550188000000000D-14
 Relative range width:      .1786278848828884000000000+140
 Absolute range width:      .2664535259100376000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6125742274543100000000000D-16     -.6125742274543100000000000D-16
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.134274509232382E+096,  8.100517782607545E+095]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1332267629550188000000000D-14      .3141592653589796000000000D+01
 Relative range width:      .2000000000000002000000000D+01
 Absolute range width:      .3141592653589797000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3141592653589793000000000D+01     -.6125742274543100000000000D-16
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.336505333864183E-028,  6.015337034903970E-028]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.084033222890656E-030,  1.220546754326818E-030]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.255756589385469E-001,  8.246942537772992E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .8811782334870180000000000D+00      .1445874569816947000000000D+01
 Relative range width:      .4853317771974655000000000D+00
 Absolute range width:      .5646963363299287000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1445874569816946000000000D+01      .8811782334870200000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.538806680956895E+274,  3.873627349881290E+274]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1332267629550188000000000D-14      .1332267629550188000000000D-14
 Relative range width:      .1786278848828884000000000+140
 Absolute range width:      .2664535259100376000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6125742274543100000000000D-16     -.6125742274543100000000000D-16
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.690019655351553E-153,  1.353573125590249E-152]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.366625511237862E+295, -4.195492772075063E+294]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3141592653589790000000000D+01      .3141592653589796000000000D+01
 Relative range width:      .1696295830113876000000000D-14
 Absolute range width:      .5329070518200751000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3141592653589793000000000D+01      .3141592653589793000000000D+01
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:  1.786278848828884E+139
 
 Maximum absolute width of an output interval
 with point input:  1.243449787580175E-014
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TEST OF ROUTINE IASIN FOLLOWS
 
 
 
 [X1,X2] is:
 [  0.000000000000000E+000,  0.000000000000000E+000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2225073858507203000000000-307      .6675221575521612000000000-307
 Relative range width:      .5966672584960172000000000-153
 Absolute range width:      .8900295434028815000000000-307
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .0000000000000000000000000D+00      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  4.999999999999999E-001,  5.000000000000001E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5235987755982964000000000D+00      .5235987755983018000000000D+00
 Relative range width:      .1038981195944748000000000D-13
 Absolute range width:      .5440092820663267000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5235987755982987000000000D+00      .5235987755982990000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -5.000000000000001E-001, -4.999999999999999E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.5235987755983074000000000D+00     -.5235987755982963000000000D+00
 Relative range width:      .2120369787642332000000000D-13
 Absolute range width:      .1110223024625157000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.5235987755982990000000000D+00     -.5235987755982987000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  8.660254037844376E-001,  8.660254037844396E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1047197551196592000000000D+01      .1047197551196603000000000D+01
 Relative range width:      .1102592289574019000000000D-13
 Absolute range width:      .1154631945610163000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1047197551196596000000000D+01      .1047197551196600000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -8.660254037844398E-001, -8.660254037844374E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1047197551196605000000000D+01     -.1047197551196591000000000D+01
 Relative range width:      .1335832966214676000000000D-13
 Absolute range width:      .1398881011027697000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1047197551196600000000000D+01     -.1047197551196595000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796296992573000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1897274900532634000000000D-07
 Absolute range width:      .2980232416405215000000000D-07
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796305721472000000000D+01      .1570796305721472000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -9.999999999999996E-001, -9.999999999999996E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796326794898000000000D+01     -.1570796290294654000000000D+01
 Relative range width:      .2323677739876993000000000D-07
 Absolute range width:      .3650024416046449000000000D-07
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796296992574000000000D+01     -.1570796296992574000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.225073858507201E-308,  2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2225073858507203000000000-307      .8900295434028815000000000-307
 Relative range width:      .7458340731200215000000000-153
 Absolute range width:      .1112536929253602000000000-306
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2225073858507201000000000-307      .2225073858507201000000000-307
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.225073858507201E-308, -2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.8900295434028819000000000-307      .2225073858507203000000000-307
 Relative range width:      .7458340731200217000000000-153
 Absolute range width:      .1112536929253602000000000-306
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2225073858507201000000000-307     -.2225073858507201000000000-307
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -9.606628417968800E-001, -9.458923339843800E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1289379197725632000000000D+01     -.1240333708246867000000000D+01
 Relative range width:      .3877553801695932000000000D-01
 Absolute range width:      .4904548947876464000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1289379197725627000000000D+01     -.1240333708246870000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -3.142700195312400E-001, -2.247924804687400E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3196876162269350000000000D+00     -.2267300607963801000000000D+00
 Relative range width:      .3402435877878399000000000D+00
 Absolute range width:      .9295755543055492000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3196876162269340000000000D+00     -.2267300607963808000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.877746582031200E-001, -1.622619628906200E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.7584190542047760000000000D+00     -.1629825647181930000000000D+00
 Relative range width:      .1292458092666674000000000D+01
 Absolute range width:      .5954364894865829000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.7584190542047685000000000D+00     -.1629825647181933000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -8.264160156250000E-002,  9.355468750000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.8273596050069415000000000D-01      .1209804235615785000000000D+01
 Relative range width:      .2293632470463231000000000D+01
 Absolute range width:      .1292540196116479000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.8273596050069398000000000D-01      .1209804235615782000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.936950683593800E-001,  8.503723144531199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1949271532962182000000000D+00      .1016692467822836000000000D+01
 Relative range width:      .2948821518019446000000000D+01
 Absolute range width:      .1211619621119054000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1949271532962174000000000D+00      .1016692467822832000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -9.465942382812400E-001,  6.744384765625999E-002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1242503735829359000000000D+01      .6749508259546243000000000D-01
 Relative range width:      .2229768801820140000000000D+01
 Absolute range width:      .1309998818424821000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1242503735829354000000000D+01      .6749508259546230000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.868957519531200E-001, -4.483032226562000E-002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2909847865285611000000000D+00     -.4484535221080563000000000D-01
 Relative range width:      .1465856728891036000000000D+01
 Absolute range width:      .2461394343177555000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2909847865285601000000000D+00     -.4484535221080568000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.657470703125000E-001,  8.039550781250000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2689787744537570000000000D+00      .9339162888657248000000000D+00
 Relative range width:      .3618069479455531000000000D+01
 Absolute range width:      .1202895063319482000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2689787744537560000000000D+00      .9339162888657203000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.672241210938000E-002,  5.986633300781199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4673942787473501000000000D-01      .6418313161924927000000000D+00
 Relative range width:      .2314166123197283000000000D+01
 Absolute range width:      .6885707440672277000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4673942787473495000000000D-01      .6418313161924853000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.738891601562400E-001,  1.148071289062600E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1747776305138098000000000D+00      .1150608426035389000000000D+00
 Relative range width:      .9707101914217278000000000D+01
 Absolute range width:      .2898384731173487000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1747776305138093000000000D+00      .1150608426035387000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.671203613281200E-001,  7.544860839843801E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2704035672503964000000000D+00      .8548707353648400000000000D+00
 Relative range width:      .3850598849702703000000000D+01
 Absolute range width:      .1125274302615237000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2704035672503954000000000D+00      .8548707353648362000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -3.869628906250000E-001,  6.143798828125000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3973356027872376000000000D+00      .6615997827625073000000000D+00
 Relative range width:      .8014218087739639000000000D+01
 Absolute range width:      .1058935385549745000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3973356027872353000000000D+00      .6615997827625000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.601623535156199E-001,  7.065734863281199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2631903426587355000000000D+00      .7846442546936584000000000D+00
 Relative range width:      .9952981383750862000000000D+00
 Absolute range width:      .5214539120349229000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2631903426587362000000000D+00      .7846442546936520000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -8.195190429687400E-001,  6.781616210937600E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.9605712239212122000000000D+00      .7452582456421744000000000D+00
 Relative range width:      .1584511517324973000000000D+02
 Absolute range width:      .1705829469563386000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.9605712239212072000000000D+00      .7452582456421678000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.443664550781200E-001, -2.608947753906200E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4604669330482092000000000D+00     -.2639489626312080000000000D+00
 Relative range width:      .5425556550845432000000000D+00
 Absolute range width:      .1965179704170012000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4604669330482065000000000D+00     -.2639489626312089000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.593505859375000E-001,  8.173828125000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4772639480387901000000000D+00      .9568532865659297000000000D+00
 Relative range width:      .5980605152770985000000000D+01
 Absolute range width:      .1434117234604720000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4772639480387871000000000D+00      .9568532865659257000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.598999023438000E-002,  1.345520019531199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4600621776289722000000000D-01      .1349613392853067000000000D+00
 Relative range width:      .4068738346956556000000000D+01
 Absolute range width:      .1809675570482039000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4600621776289716000000000D-01      .1349613392853064000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  8.493041992187600E-001,  9.622192382812600E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1014665848242168000000000D+01      .1295038876600555000000000D+01
 Relative range width:      .2427782437666166000000000D+00
 Absolute range width:      .2803730283583863000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1014665848242172000000000D+01      .1295038876600552000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -7.897033691406200E-001, -4.324035644531200E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.9103253321677600000000000D+00     -.4471567292177268000000000D+00
 Relative range width:      .6823936995194021000000000D+00
 Absolute range width:      .4631686029500332000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.9103253321677552000000000D+00     -.4471567292177291000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.182861328125000E-001,  9.858398437500000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6665602051457263000000000D+00      .1402310711065883000000000D+01
 Relative range width:      .5623838242895133000000000D+01
 Absolute range width:      .2068870916211609000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6665602051457183000000000D+00      .1402310711065880000000000D+01
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:  2.323677739876993E-008
 
 Maximum absolute width of an output interval
 with point input:  2.323677739876993E-008
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TEST OF ROUTINE IATAN FOLLOWS
 
 
 
 [X1,X2] is:
 [  0.000000000000000E+000,  0.000000000000000E+000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .0000000000000000000000000D+00      .0000000000000000000000000D+00
 Relative range width:      .0000000000000000000000000D+00
 Absolute range width:      .0000000000000000000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .0000000000000000000000000D+00      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.500000000000000E-001,  2.500000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2449786631268632000000000D+00      .2449786631268651000000000D+00
 Relative range width:      .7817557223286124000000000D-14
 Absolute range width:      .1915134717478395000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2449786631268641000000000D+00      .2449786631268641000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.500000000000000E-001, -2.500000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2449786631268653000000000D+00     -.2449786631268632000000000D+00
 Relative range width:      .8270748946375173000000000D-14
 Absolute range width:      .2026157019940911000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2449786631268641000000000D+00     -.2449786631268641000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [       1.732050807568877,       1.732050807568878]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1047197551196593000000000D+01      .1047197551196603000000000D+01
 Relative range width:      .9329627065626316000000000D-14
 Absolute range width:      .9769962616701378000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1047197551196598000000000D+01      .1047197551196598000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.732050807568878,      -1.732050807568876]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1047197551196603000000000D+01     -.1047197551196593000000000D+01
 Relative range width:      .1017777498068325000000000D-13
 Absolute range width:      .1065814103640150000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1047197551196598000000000D+01     -.1047197551196597000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  5.773502691896256E-001,  5.773502691896260E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5235987755982955000000000D+00      .5235987755983025000000000D+00
 Relative range width:      .1335832966214677000000000D-13
 Absolute range width:      .6994405055138486000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5235987755982988000000000D+00      .5235987755982990000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -5.773502691896261E-001, -5.773502691896255E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.5235987755983029000000000D+00     -.5235987755982954000000000D+00
 Relative range width:      .1441851455596794000000000D-13
 Absolute range width:      .7549516567451064000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.5235987755982991000000000D+00     -.5235987755982987000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.797693134862316E+307,  1.797693134862316E+307]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.225073858507201E-308,  2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4450147717014412000000000-307      .4450147717014411000000000-307
 Relative range width:      .5966672584960176000000000-153
 Absolute range width:      .8900295434028821000000000-307
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2225073858507201000000000-307      .2225073858507201000000000-307
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.225073858507201E-308, -2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4450147717014413000000000-307      .4450147717014413000000000-307
 Relative range width:      .5966672584960179000000000-153
 Absolute range width:      .8900295434028825000000000-307
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2225073858507201000000000-307     -.2225073858507201000000000-307
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.276847097890946E-261,  1.115951231047181E-262]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1276847097890948000000000-260      .1115951231047182000000000-261
 Relative range width:      .9307983310466402000000000-107
 Absolute range width:      .1388442220995666000000000-260
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1276847097890946000000000-260      .1115951231047181000000000-261
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -9.903652608056447E-005,  1.186774665360168E-004]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.9903652575677353000000000D-04      .1186774659788523000000000D-03
 Relative range width:      .2216940627830935000000000D+02
 Absolute range width:      .2177139917356258000000000D-03
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.9903652575677334000000000D-04      .1186774659788521000000000D-03
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -3.315313621677351E-002, -2.045730221667231E-002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3314099768045922000000000D-01     -.2045444913111237000000000D-01
 Relative range width:      .4734188929872956000000000D+00
 Absolute range width:      .1268654854934685000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3314099768045913000000000D-01     -.2045444913111241000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.123731537608978E+251,  2.258376007728173E+252]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796326794898000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1414847550405689000000000D+17
 Absolute range width:      .3141592653589795000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.964880865780309E+188,  2.301679644601745E+189]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796326794898000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1414847550405689000000000D+17
 Absolute range width:      .3141592653589795000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.351392160813672E-263,  2.682250315279288E-262]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2351392160813668000000000-262      .2682250315279291000000000-261
 Relative range width:      .1640519780063824000000000-107
 Absolute range width:      .2447111099197925000000000-261
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2351392160813672000000000-262      .2682250315279288000000000-261
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.357209448835715E-009,  1.320053815155970E-008]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2357209448835719000000000D-08      .1320053815155971000000000D-07
 Relative range width:      .2869551966360129000000000D+01
 Absolute range width:      .1555774760039543000000000D-07
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2357209448835715000000000D-08      .1320053815155970000000000D-07
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.318482309723622E-006,  1.474313137791030E-006]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1318482309722856000000000D-05      .1474313137789964000000000D-05
 Relative range width:      .1115948740219310000000000D+00
 Absolute range width:      .1558308280671077000000000D-06
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1318482309722858000000000D-05      .1474313137789962000000000D-05
 ---------------------------------------------------
 
 [X1,X2] is:
 [  5.568554095093109E-001,  7.383890571322996E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5080912408744682000000000D+00      .6360285974773715000000000D+00
 Relative range width:      .2236432798634158000000000D+00
 Absolute range width:      .1279373566029033000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5080912408744714000000000D+00      .6360285974773703000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -5.090196402955172E-001,       1.947911243674908]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4708372576895422000000000D+00      .1096509690101609000000000D+01
 Relative range width:      .5010119885732471000000000D+01
 Absolute range width:      .1567346947791151000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4708372576895388000000000D+00      .1096509690101605000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.595101589308905E+131,  3.982298428764696E+129]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796326794898000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1414847550405689000000000D+17
 Absolute range width:      .3141592653589795000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  8.451756729797211E-019,  1.224516081280632E-018]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .8451756729797197000000000D-18      .1224516081280633000000000D-17
 Relative range width:      .3665670576500689000000000D+00
 Absolute range width:      .3793404083009136000000000D-18
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .8451756729797211000000000D-18      .1224516081280632000000000D-17
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.423456662773590E+108,  3.722732096481154E+108]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.134274509232382E+096,  8.100517782607545E+095]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796326794898000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1414847550405689000000000D+17
 Absolute range width:      .3141592653589795000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.336505333864183E-028,  6.015337034903970E-028]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2336505333864188000000000D-27      .6015337034903977000000000D-27
 Relative range width:      .4540486245352072000000000D+01
 Absolute range width:      .8351842368768165000000000D-27
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2336505333864183000000000D-27      .6015337034903970000000000D-27
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.084033222890656E-030,  1.220546754326818E-030]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1084033222890655000000000D-29      .1220546754326819000000000D-29
 Relative range width:      .1184715069866998000000000D+00
 Absolute range width:      .1365135314361643000000000D-30
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1084033222890656000000000D-29      .1220546754326818000000000D-29
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.255756589385469E-001,  8.246942537772992E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1249217569779505000000000D+00      .6896180933078779000000000D+00
 Relative range width:      .1386540722671263000000000D+01
 Absolute range width:      .5646963363299274000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1249217569779509000000000D+00      .6896180933078766000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.538806680956895E+274,  3.873627349881290E+274]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.690019655351553E-153,  1.353573125590249E-152]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6690019655351564000000000-152      .1353573125590251000000000-151
 Relative range width:      .5909028043082123000000000D+01
 Absolute range width:      .2022575091125407000000000-151
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6690019655351553000000000-152      .1353573125590249000000000-151
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.366625511237862E+295, -4.195492772075063E+294]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796326794898000000000D+01     -.1570796326794895000000000D+01
 Relative range width:      .1696295830113876000000000D-14
 Absolute range width:      .2664535259100376000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1570796326794897000000000D+01     -.1570796326794897000000000D+01
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:  1.441851455596794E-014
 
 Maximum absolute width of an output interval
 with point input:  1.065814103640150E-014
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TEST OF ROUTINE IACOS FOLLOWS
 
 
 
 [X1,X2] is:
 [  0.000000000000000E+000,  0.000000000000000E+000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  4.999999999999999E-001,  5.000000000000001E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1047197551196594000000000D+01      .1047197551196601000000000D+01
 Relative range width:      .6361109362927035000000000D-14
 Absolute range width:      .6661338147750939000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1047197551196598000000000D+01      .1047197551196598000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -5.000000000000001E-001, -4.999999999999999E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2094395102393192000000000D+01      .2094395102393205000000000D+01
 Relative range width:      .6361109362927025000000000D-14
 Absolute range width:      .1332267629550188000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2094395102393196000000000D+01      .2094395102393195000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  8.660254037844376E-001,  8.660254037844396E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5235987755982926000000000D+00      .5235987755983053000000000D+00
 Relative range width:      .2417221557912272000000000D-13
 Absolute range width:      .1265654248072678000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5235987755983009000000000D+00      .5235987755982969000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -8.660254037844398E-001, -8.660254037844374E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2617993877991487000000000D+01      .2617993877991502000000000D+01
 Relative range width:      .5937035405398563000000000D-14
 Absolute range width:      .1554312234475219000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2617993877991497000000000D+01      .2617993877991492000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1332267629550188000000000D-14      .2980232371996295000000000D-07
 Relative range width:      .2000000178813934000000000D+01
 Absolute range width:      .2980232505223058000000000D-07
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2107342425544702000000000D-07      .2107342425544702000000000D-07
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -9.999999999999996E-001, -9.999999999999996E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3141592617089549000000000D+01      .3141592653589796000000000D+01
 Relative range width:      .1161838948003941000000000D-07
 Absolute range width:      .3650024682499975000000000D-07
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3141592623787471000000000D+01      .3141592623787471000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.225073858507201E-308,  2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.225073858507201E-308, -2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794896000000000D+01      .1570796326794897000000000D+01
 Relative range width:      .1130863886742584000000000D-14
 Absolute range width:      .1776356839400250000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1570796326794897000000000D+01      .1570796326794897000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -9.606628417968800E-001, -9.458923339843800E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2811130035041763000000000D+01      .2860175524520529000000000D+01
 Relative range width:      .1729601375333115000000000D-01
 Absolute range width:      .4904548947876641000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2860175524520523000000000D+01      .2811130035041767000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -3.142700195312400E-001, -2.247924804687400E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1797526387591276000000000D+01      .1890483943021833000000000D+01
 Relative range width:      .5041068060951079000000000D-01
 Absolute range width:      .9295755543055684000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1890483943021831000000000D+01      .1797526387591277000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.877746582031200E-001, -1.622619628906200E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1733778891513089000000000D+01      .2329215380999674000000000D+01
 Relative range width:      .2931023031535492000000000D+00
 Absolute range width:      .5954364894865849000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2329215380999665000000000D+01      .1733778891513090000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -8.264160156250000E-002,  9.355468750000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3609920911791111000000000D+00      .1653532287295592000000000D+01
 Relative range width:      .1283221200922004000000000D+01
 Absolute range width:      .1292540196116480000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1653532287295591000000000D+01      .3609920911791145000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.936950683593800E-001,  8.503723144531199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5541038589720603000000000D+00      .1765723480091116000000000D+01
 Relative range width:      .1044577413772827000000000D+01
 Absolute range width:      .1211619621119056000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1765723480091114000000000D+01      .5541038589720647000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -9.465942382812400E-001,  6.744384765625999E-002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1503301244199433000000000D+01      .2813300062624256000000000D+01
 Relative range width:      .6069584496274766000000000D+00
 Absolute range width:      .1309998818424823000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2813300062624251000000000D+01      .1503301244199434000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.868957519531200E-001, -4.483032226562000E-002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1615641679005701000000000D+01      .1861781113323459000000000D+01
 Relative range width:      .1415642842513805000000000D+00
 Absolute range width:      .2461394343177572000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1861781113323457000000000D+01      .1615641679005702000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.657470703125000E-001,  8.039550781250000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .6368800379291712000000000D+00      .1839775101248654000000000D+01
 Relative range width:      .9713868065772029000000000D+00
 Absolute range width:      .1202895063319483000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1839775101248653000000000D+01      .6368800379291762000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.672241210938000E-002,  5.986633300781199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9289650106024032000000000D+00      .1617535754669633000000000D+01
 Relative range width:      .5407975944540281000000000D+00
 Absolute range width:      .6885707440672293000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1617535754669632000000000D+01      .9289650106024112000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.738891601562400E-001,  1.148071289062600E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1455735484191357000000000D+01      .1745573957308707000000000D+01
 Relative range width:      .1810749497440261000000000D+00
 Absolute range width:      .2898384731173502000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1745573957308706000000000D+01      .1455735484191358000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.671203613281200E-001,  7.544860839843801E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .7159255914300560000000000D+00      .1841199894045294000000000D+01
 Relative range width:      .8801087854365177000000000D+00
 Absolute range width:      .1125274302615238000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1841199894045292000000000D+01      .7159255914300605000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -3.869628906250000E-001,  6.143798828125000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9091965440323886000000000D+00      .1968131929582135000000000D+01
 Relative range width:      .7360545695497206000000000D+00
 Absolute range width:      .1058935385549747000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1968131929582132000000000D+01      .9091965440323967000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.601623535156199E-001,  7.065734863281199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .7861520721012375000000000D+00      .1307605984136162000000000D+01
 Relative range width:      .4981033128268949000000000D+00
 Absolute range width:      .5214539120349243000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1307605984136160000000000D+01      .7861520721012447000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -8.195190429687400E-001,  6.781616210937600E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .8255380811527215000000000D+00      .2531367550716110000000000D+01
 Relative range width:      .1016310648335820000000000D+01
 Absolute range width:      .1705829469563388000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2531367550716104000000000D+01      .8255380811527289000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.443664550781200E-001, -2.608947753906200E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1834745289426104000000000D+01      .2031263259843107000000000D+01
 Relative range width:      .1016645296628485000000000D+00
 Absolute range width:      .1965179704170028000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2031263259843103000000000D+01      .1834745289426105000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.593505859375000E-001,  8.173828125000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .6139430402289663000000000D+00      .2048060274833687000000000D+01
 Relative range width:      .1077472162780509000000000D+01
 Absolute range width:      .1434117234604721000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2048060274833684000000000D+01      .6139430402289709000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -4.598999023438000E-002,  1.345520019531199E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1435834987509589000000000D+01      .1616802544557795000000000D+01
 Relative range width:      .1185647199493391000000000D+00
 Absolute range width:      .1809675570482054000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1616802544557794000000000D+01      .1435834987509590000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  8.493041992187600E-001,  9.622192382812600E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2757574501943416000000000D+00      .5561304785527289000000000D+00
 Relative range width:      .6740644230303112000000000D+00
 Absolute range width:      .2803730283583873000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5561304785527246000000000D+00      .2757574501943448000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -7.897033691406200E-001, -4.324035644531200E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2017953056012622000000000D+01      .2481121658962657000000000D+01
 Relative range width:      .2058950483344350000000000D+00
 Absolute range width:      .4631686029500348000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2481121658962652000000000D+01      .2017953056012626000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.182861328125000E-001,  9.858398437500000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1684856157290133000000000D+00      .2237356531940624000000000D+01
 Relative range width:      .1719872534626242000000000D+01
 Absolute range width:      .2068870916211611000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2237356531940615000000000D+01      .1684856157290165000000000D+00
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:       2.000000178813934
 
 Maximum absolute width of an output interval
 with point input:  3.650024682499975E-008
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TEST OF ROUTINE IEXP FOLLOWS
 
 
 
 [X1,X2] is:
 [  0.000000000000000E+000,  0.000000000000000E+000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999998000000000D+00      .1000000000000000000000000D+01
 Relative range width:      .4440892098500626000000000D-15
 Absolute range width:      .4440892098500626000000000D-15
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D+01      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.500000000000000E-001,  2.500000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1284025416687740000000000D+01      .1284025416687743000000000D+01
 Relative range width:      .2420999170693532000000000D-14
 Absolute range width:      .3108624468950438000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1284025416687741000000000D+01      .1284025416687741000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.500000000000000E-001, -2.500000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .7788007830714035000000000D+00      .7788007830714063000000000D+00
 Relative range width:      .3563886454526602000000000D-14
 Absolute range width:      .2775557561562891000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .7788007830714049000000000D+00      .7788007830714049000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [     708.782712893383900,     708.782712893383900]
 SEVERITY 2 ERROR: LOWER BOUND ON X FOR IEXP WOULD OVERFLOW
 Error occurred in routine IEXP.
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1797693134862316000000000+309      .1797693134862316000000000+309
 Relative range width:      .0000000000000000000000000D+00
 Absolute range width:      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [    -708.782712893384000,    -708.782712893383700]
 SEVERITY 1 ERROR: LOWER BOUND ON X FOR IEXP WOULD UNDERFLOW
 Error occurred in routine IEXP.
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .0000000000000000000000000D+00      .2225073858507203000000000-307
 Relative range width:      .1491668146240042000000000-153
 Absolute range width:      .2225073858507203000000000-307
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.250000000000000E-001,  1.250000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1133148453066825000000000D+01      .1133148453066827000000000D+01
 Relative range width:      .1763583084737643000000000D-14
 Absolute range width:      .1998401444325282000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1133148453066826000000000D+01      .1133148453066826000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.250000000000000E-001, -1.250000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .8824969025845940000000000D+00      .8824969025845971000000000D+00
 Relative range width:      .3522533008156873000000000D-14
 Absolute range width:      .3108624468950438000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .8824969025845953000000000D+00      .8824969025845955000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [    -602.599392022667600,    -599.283184444063300]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1969741551025935000000000-261      .5427750781336701000000000-260
 Relative range width:      .3506662416449002000000000-106
 Absolute range width:      .5230776626234107000000000-260
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -9.105831376909460,      -8.408946173968973]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1110165379832945000000000D-03      .2228645937215523000000000D-03
 Relative range width:      .6699872806057955000000000D+00
 Absolute range width:      .1118480557382579000000000D-03
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1110165379832969000000000D-03      .2228645937215466000000000D-03
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -4.879306522769393,      -4.267609450505548]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .7602284210991092000000000D-02      .1401524728087730000000000D-01
 Relative range width:      .5933113197775147000000000D+00
 Absolute range width:      .6412963069886212000000000D-02
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .7602284210991187000000000D-02      .1401524728087711000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [     578.461888379725000,     579.178784420888000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1670344743266312000000000+252      .3420976646241309000000000+252
 Relative range width:      .6876925532859751000000000D+00
 Absolute range width:      .1750631902974997000000000+252
 ---------------------------------------------------
 
 [X1,X2] is:
 [     434.092498105281700,     434.802550328017400]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3341770052332380000000000+189      .6797486048916251000000000+189
 Relative range width:      .6816507960891341000000000D+00
 Absolute range width:      .3455715996583870000000000+189
 ---------------------------------------------------
 
 [X1,X2] is:
 [    -600.632268638937500,    -600.126930643729700]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1408380739146570000000000-260      .2334455393475226000000000-260
 Relative range width:      .6208315547013295000000000-107
 Absolute range width:      .9260746543286550000000000-261
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -17.443579966468410,     -17.173728130675900]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2656742577617425000000000D-07      .3479722722872583000000000D-07
 Relative range width:      .2682261220280807000000000D+00
 Absolute range width:      .8229801452551580000000000D-08
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2656742577617533000000000D-07      .3479722722872410000000000D-07
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -13.379198344792310,     -13.327866037483980]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1546991710548022000000000D-05      .1628475857253118000000000D-05
 Relative range width:      .5132103853387488000000000D-01
 Absolute range width:      .8148414670509613000000000D-07
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1546991710548075000000000D-05      .1628475857253049000000000D-05
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.961296993628609E-001, -1.809466420932045E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .7436909655203580000000000D+00      .8344798836077548000000000D+00
 Relative range width:      .1150558802141793000000000D+00
 Absolute range width:      .9078891808739686000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .7436909655203591000000000D+00      .8344798836077532000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.862839841202110E-001,  8.873980357642959E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1204764345744711000000000D+01      .2428801767062243000000000D+01
 Relative range width:      .6737389018481105000000000D+00
 Absolute range width:      .1224037421317532000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1204764345744713000000000D+01      .2428801767062235000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [     302.816218240113800,     303.128603679079600]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3246479108601015000000000+132      .4436902495616250000000000+132
 Relative range width:      .3098696507178126000000000D+00
 Absolute range width:      .1190423387015235000000000+132
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3246479108603915000000000+132      .4436902495612819000000000+132
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -41.203525604680310,     -41.045829762106630]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1275076362804270000000000D-17      .1492872194561872000000000D-17
 Relative range width:      .1573698551427178000000000D+00
 Absolute range width:      .2177958317576022000000000D-18
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1275076362804393000000000D-17      .1492872194561691000000000D-17
 ---------------------------------------------------
 
 [X1,X2] is:
 [     249.075046012968600,     249.362835147385600]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1485655322626790000000000+109      .1981085851096037000000000+109
 Relative range width:      .2858191619406178000000000D+00
 Absolute range width:      .4954305284692462000000000+108
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1485655322627887000000000+109      .1981085851094841000000000+109
 ---------------------------------------------------
 
 [X1,X2] is:
 [     218.223664410368900,     220.396546942576300]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5933805053851999000000000D+95      .5211997127562943000000000D+96
 Relative range width:      .1591151140957655000000000D+01
 Absolute range width:      .4618616622177743000000000D+96
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5933805053855922000000000D+95      .5211997127559988000000000D+96
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -63.066164201849450,     -62.250023670958210]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .4080495397429206000000000D-27      .9229075978902649000000000D-27
 Relative range width:      .7736658733622422000000000D+00
 Absolute range width:      .5148580581473443000000000D-27
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .4080495397429848000000000D-27      .9229075978900929000000000D-27
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -68.659676242345230,     -68.604583543991140]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1518733171385302000000000D-29      .1604752029401329000000000D-29
 Relative range width:      .5507876777797021000000000D-01
 Absolute range width:      .8601885801602676000000000D-31
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1518733171385545000000000D-29      .1604752029400999000000000D-29
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.357195176784329E-001, -1.287488195960174E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5295543275077081000000000D+00      .8791947743115973000000000D+00
 Relative range width:      .4963842693526503000000000D+00
 Absolute range width:      .3496404468038892000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5295543275077096000000000D+00      .8791947743115957000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [     630.131189081127900,     630.173723582825300]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .4597251816432141000000000+274      .4797011862671808000000000+274
 Relative range width:      .4252809013313128000000000D-01
 Absolute range width:      .1997600462396671000000000+273
 ---------------------------------------------------
 
 [X1,X2] is:
 [    -349.640786881999100,    -348.445902869256500]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1422117919566331000000000-151      .4697503821577295000000000-151
 Relative range width:      .1070453711212178000000000D+01
 Absolute range width:      .3275385902010963000000000-151
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1422117919567450000000000-151      .4697503821572704000000000-151
 ---------------------------------------------------
 
 [X1,X2] is:
 [     676.113167653702800,     676.865763064643900]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .4287635461215313000000000+294      .9100513289668025000000000+294
 Relative range width:      .7189758521521002000000000D+00
 Absolute range width:      .4812877828452712000000000+294
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:  3.563886454526602E-015
 
 Maximum absolute width of an output interval
 with point input:  3.108624468950438E-015
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TEST OF ROUTINE IIPOWR FOLLOWS
 
 
 
 [X1,X2] is:
 [  2.499999999999999E-001,  2.500000000000001E-001]
 [Y1,Y2] is:
 [  9.999999999999998E-001,       1.000000000000000]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .2499999999999950000000000D+00      .2500000000000041000000000D+00
 Relative range width:      .3641531520770520000000000D-13
 Absolute range width:      .9103828801926284000000000D-14
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .2500000000000000000000000D+00      .2500000000000001000000000D+00
      .2499999999999999000000000D+00      .2500000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.499999999999999E-001,  2.500000000000001E-001]
 [Y1,Y2] is:
 [  4.999999999999999E-001,  5.000000000000001E-001]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .4999999999999947000000000D+00      .5000000000000044000000000D+00
 Relative range width:      .1942890293094026000000000D-13
 Absolute range width:      .9714451465470120000000000D-14
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .5000000000000000000000000D+00      .5000000000000001000000000D+00
      .4999999999999999000000000D+00      .5000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.499999999999999E-001,  2.500000000000001E-001]
 [Y1,Y2] is:
 [       2.000000000000000,       2.000000000000000]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .6249999999999763000000000D-01      .6250000000000190000000000D-01
 Relative range width:      .6838973831690990000000000D-13
 Absolute range width:      .4274358644806853000000000D-14
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .6250000000000001000000000D-01      .6250000000000007000000000D-01
      .6249999999999993000000000D-01      .6249999999999999000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [     708.782712893383900,     708.782712893383900]
 [Y1,Y2] is:
 [  9.999999999999998E-001,       1.000000000000000]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .7087827128933371000000000D+03      .7087827128934431000000000D+03
 Relative range width:      .1494902892368980000000000D-12
 Absolute range width:      .1059561327565461000000000D-09
 ---------------------------------------------------
 
 [X1,X2] is:
 [     708.782712893383900,     708.782712893383900]
 [Y1,Y2] is:
 [       2.000000000000000,       2.000000000000000]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .5023729340964376000000000D+06      .5023729340965903000000000D+06
 Relative range width:      .3040309138302328000000000D-12
 Absolute range width:      .1527369022369385000000000D-06
 ---------------------------------------------------
 
 [X1,X2] is:
 [     708.782712893383900,     708.782712893383900]
 [Y1,Y2] is:
 [  4.999999999999999E-001,  5.000000000000001E-001]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .2662297340443656000000000D+02      .2662297340443858000000000D+02
 Relative range width:      .7553010370606889000000000D-13
 Absolute range width:      .2010835942201084000000000D-11
 ---------------------------------------------------
 
 [X1,X2] is:
 [     599.283184444063300,     602.599392022667600]
 [Y1,Y2] is:
 [ -3.409954608124799E-001,       1.807050605871963]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1127256728012444000000000D+00      .1055972302571421000000000D+06
 Relative range width:      .1999995729980713000000000D+01
 Absolute range width:      .1055971175314693000000000D+06
 ---------------------------------------------------
 
 [X1,X2] is:
 [       7.218542389437259,       7.915427592377745]
 [Y1,Y2] is:
 [       2.219954264726880,       2.545220096305920]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .8048568660525086000000000D+02      .1935597485254642000000000D+03
 Relative range width:      .8252212766563974000000000D+00
 Absolute range width:      .1130740619202133000000000D+03
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .8048568660525436000000000D+02      .9875794234457604000000000D+02
      .1530886338205626000000000D+03      .1935597485254517000000000D+03
 ---------------------------------------------------
 
 [X1,X2] is:
 [       1.279296391595414,       1.890993463859259]
 [Y1,Y2] is:
 [      -2.504270805876156,      -2.015989718267463]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .2028118101620747000000000D+00      .6086213895224520000000000D+00
 Relative range width:      .1000229173561422000000000D+01
 Absolute range width:      .4058095793603773000000000D+00
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .5396537628311111000000000D+00      .2028118101620792000000000D+00
      .6086213895224480000000000D+00      .2768189066325115000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  7.690083328773525E-001,       1.485904374040399]
 [Y1,Y2] is:
 [      -1.712314689611100,       2.792891194831562]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .4801952084166044000000000D+00      .3511663898964901000000000D+01
 Relative range width:      .1518825494087548000000000D+01
 Absolute range width:      .3031468690548297000000000D+01
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .1567912945642813000000000D+01      .5075718429200684000000000D+00
      .4801952084166111000000000D+00      .3022398754759979000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.543925838232221E-001,  9.644448065589772E-001]
 [Y1,Y2] is:
 [       1.627800738449040,       2.121734367677222]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .5478205914826118000000000D-01      .9427720650159904000000000D+00
 Relative range width:      .1780334488841265000000000D+01
 Absolute range width:      .8879900058677292000000000D+00
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .1077158713220988000000000D+00      .9427720650159870000000000D+00
      .5478205914826323000000000D-01      .9260635150425597000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [       1.726458241165669,       2.231796236373460]
 [Y1,Y2] is:
 [  9.430559932731601E-001,       2.317637596061680]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1673599205305161000000000D+01      .6427689243272050000000000D+01
 Relative range width:      .1173662700234263000000000D+01
 Absolute range width:      .4754090037966888000000000D+01
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .1673599205305171000000000D+01      .2132066539093731000000000D+01
      .3545209000111404000000000D+01      .6427689243271892000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  5.218636014415414E-001,  7.917154372340419E-001]
 [Y1,Y2] is:
 [  3.865890340260192E-003,  8.540077218700186E-001]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .5738409053840421000000000D+00      .9990975162376887000000000D+00
 Relative range width:      .5407161590155559000000000D+00
 Absolute range width:      .4252566108536466000000000D+00
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .9974889798843010000000000D+00      .9990975162376875000000000D+00
      .5738409053840472000000000D+00      .8191760365447478000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  6.669183952183501E-002,  1.180241468301591E-001]
 [Y1,Y2] is:
 [      -1.126851353287020,  6.993441246004747E-001]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1505296837862871000000000D+00      .2113952737325993000000000D+02
 Relative range width:      .1971718312753611000000000D+01
 Absolute range width:      .2098899768947364000000000D+02
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .2113952737325910000000000D+02      .1111094202103175000000000D+02
      .1505296837862909000000000D+00      .2243821371905868000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.088082996889184E-001,  2.239913569585746E-001]
 [Y1,Y2] is:
 [  4.188195040578599E-001,  9.712340559826326E-001]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1159773950953473000000000D+00      .5343972060427645000000000D+00
 Relative range width:      .1286704032461325000000000D+01
 Absolute range width:      .4184198109474173000000000D+00
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .3949437691601843000000000D+00      .5343972060427603000000000D+00
      .1159773950953505000000000D+00      .2338419758460258000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.827205029964723E-001,  8.838345546405572E-001]
 [Y1,Y2] is:
 [      -2.894245339583334,      -2.598928149587338]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1378408612184641000000000D+01      .1369521070513442000000000D+03
 Relative range width:      .1960141589711487000000000D+01
 Absolute range width:      .1355736984391596000000000D+03
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .1369521070513352000000000D+03      .1429603327345941000000000D+01
      .8290139010360095000000000D+02      .1378408612184649000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.119368690096085E-001,  6.243223079754370E-001]
 [Y1,Y2] is:
 [       2.205995588331000,       2.520871093618307]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .5304047328919877000000000D-01      .3537307645409406000000000D+00
 Relative range width:      .1478424545726140000000000D+01
 Absolute range width:      .3006902912517418000000000D+00
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .7654439441064935000000000D-01      .3537307645409357000000000D+00
      .5304047328920088000000000D-01      .3049664694549060000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.267611733458649E-002,  2.503719599082678E-001]
 [Y1,Y2] is:
 [      -1.719166401407400,  1.654417278059443E-001]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .6746730663861505000000000D+00      .5969723233608760000000000D+02
 Relative range width:      .1955298872090361000000000D+01
 Absolute range width:      .5902255926970145000000000D+02
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .5969723233608444000000000D+02      .1081262837624971000000000D+02
      .6746730663861548000000000D+00      .7952450550126331000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  8.579775825296736E-002,  3.735868926699434E-001]
 [Y1,Y2] is:
 [  6.987270764930400E-001,       2.960624554068270]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .6957010876591758000000000D-03      .5025953360513480000000000D+00
 Relative range width:      .1994470785002539000000000D+01
 Absolute range width:      .5018996349636888000000000D+00
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .1798004448867881000000000D+00      .5025953360513438000000000D+00
      .6957010876592406000000000D-03      .5420160687322613000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.158771301464439E-001,       2.288759662353888]
 [Y1,Y2] is:
 [      -1.123656836300940, -3.578780712512532E-002]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .3943962594396470000000000D+00      .1126536710353880000000000D+02
 Relative range width:      .1864698365768926000000000D+01
 Absolute range width:      .1087097084409915000000000D+02
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .1126536710353844000000000D+02      .3943962594396522000000000D+00
      .1080183324928138000000000D+01      .9708020790365184000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.801495043387501E-001,       1.196290035229996]
 [Y1,Y2] is:
 [      -2.776965249812268,      -2.430768571384673]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .6079260946253441000000000D+00      .1467073779653768000000000D+02
 Relative range width:      .1840843126347727000000000D+01
 Absolute range width:      .1406281170191233000000000D+02
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .1467073779653713000000000D+02      .6079260946253485000000000D+00
      .1049623567777255000000000D+02      .6468409675737666000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.566066457140129E-001,  2.116993440680969E-001]
 [Y1,Y2] is:
 [       1.177407832694460,       2.278866787067941]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1462445462934794000000000D-01      .1607299732635756000000000D+00
 Relative range width:      .1666402387323163000000000D+01
 Absolute range width:      .1461055186342276000000000D+00
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .1127101968280067000000000D+00      .1607299732635723000000000D+00
      .1462445462934874000000000D-01      .2906729321916815000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  5.995921391748456E-002,  5.669299119999001E-001]
 [Y1,Y2] is:
 [      -1.658101402182900,       1.964452988173885]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .3973337267231477000000000D-02      .1062768797812086000000000D+03
 Relative range width:      .1999850458962244000000000D+01
 Absolute range width:      .1062729064439413000000000D+03
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .1062768797812021000000000D+03      .2562555585291224000000000D+01
      .3973337267231760000000000D-02      .3279593654731173000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  4.267321696446306E-001,  4.692666713421426E-001]
 [Y1,Y2] is:
 [       2.517361738912020,       2.849790084061906]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .8831215451498046000000000D-01      .1488828079277899000000000D+00
 Relative range width:      .5107246190139789000000000D+00
 Absolute range width:      .6057065341280947000000000D-01
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .1172107146518116000000000D+00      .1488828079277864000000000D+00
      .8831215451498349000000000D-01      .1157750958165724000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.438115938497790E-001,       1.538695606592413]
 [Y1,Y2] is:
 [       1.743588097645860,       2.673793471266954]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .5757273052219070000000000D-01      .3165247716640274000000000D+01
 Relative range width:      .1928543669787275000000000D+01
 Absolute range width:      .3107674986118083000000000D+01
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .1554296873745107000000000D+00      .2119909124481215000000000D+01
      .5757273052219299000000000D-01      .3165247716640225000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.819788714833971E-001,  5.706165394577959E-001]
 [Y1,Y2] is:
 [       2.229537215685180,       2.359422032255447]
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1795052551022739000000000D-01      .2862600040410820000000000D+00
 Relative range width:      .1763972331441607000000000D+01
 Absolute range width:      .2683094785308546000000000D+00
 The Fortran library function values at (lower, lower),
 (upper, lower), (lower,upper), and (upper,upper)
 points of the rectangle are:
       12345678901234567890123456789       12345678901234567890123456789
      .2239696690092868000000000D-01      .2862600040410777000000000D+00
      .1795052551022835000000000D-01      .2661420540581192000000000D+00
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:  3.040309138302328E-013
 
 Maximum absolute width of an output interval
 with point input:  1.527369022369385E-007
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TEST OF ROUTINE ILOG FOLLOWS
 
 
 
 [X1,X2] is:
 [  2.500000000000000E-001,  2.500000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1386294361119905000000000D+01     -.1386294361119881000000000D+01
 Relative range width:      .1793918842136351000000000D-13
 Absolute range width:      .2486899575160351000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1386294361119891000000000D+01     -.1386294361119891000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.250000000000000E-001,  1.250000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2079441541679858000000000D+01     -.2079441541679821000000000D+01
 Relative range width:      .1751206488752152000000000D-13
 Absolute range width:      .3641531520770513000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2079441541679836000000000D+01     -.2079441541679836000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,       1.000000000000000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1332267629550191000000000D-14      .1332267629550191000000000D-14
 Relative range width:      .1351079888211152000000000D+17
 Absolute range width:      .2664535259100382000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2220446049250313000000000D-15      .2220446049250313000000000D-15
 ---------------------------------------------------
 
 [X1,X2] is:
 [       2.000000000000000,       2.000000000000000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .6931471805599405000000000D+00      .6931471805599525000000000D+00
 Relative range width:      .1729850312060053000000000D-13
 Absolute range width:      .1199040866595169000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .6931471805599451000000000D+00      .6931471805599455000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.797693134862316E+307,  1.797693134862316E+307]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .7074801278003856000000000D+03      .7074801278003965000000000D+03
 Relative range width:      .1542649184395806000000000D-13
 Absolute range width:      .1091393642127514000000000D-10
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.225073858507201E-308,  2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.7083964214867668000000000D+03     -.7083964185219742000000000D+03
 Relative range width:      .4185216882792749000000000D-08
 Absolute range width:      .2964792656712234000000000D-05
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.7083964185322641000000000D+03     -.7083964185322641000000000D+03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.614212505450001E-263,  7.203632355523320E-262]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6046189165504194000000000D+03     -.6013027089718059000000000D+03
 Relative range width:      .5499872476666727000000000D-02
 Absolute range width:      .3316207578613444000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6046189165504138000000000D+03     -.6013027089718095000000000D+03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.080477151403373E-004,  2.169047114486279E-004]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.9132937621553081000000000D+01     -.8436052418612453000000000D+01
 Relative range width:      .7933127645327777000000000D-01
 Absolute range width:      .6968852029406278000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.9132937621552992000000000D+01     -.8436052418612505000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  7.525174970799521E-003,  1.387309197085012E-002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4889501216684077000000000D+01     -.4277804144420155000000000D+01
 Relative range width:      .1334518810422262000000000D+00
 Absolute range width:      .6116970722639223000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4889501216684028000000000D+01     -.4277804144420184000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.178718057986076E+252,  2.414092638730612E+252]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5804158708908852000000000D+03      .5811327669320573000000000D+03
 Relative range width:      .1234379720018796000000000D-02
 Absolute range width:      .7168960411720491000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5804158708908889000000000D+03      .5811327669320518000000000D+03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.449654304039512E+189,  2.948738169629400E+189]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .4355599076928726000000000D+03      .4362699599156154000000000D+03
 Relative range width:      .1628877947690808000000000D-02
 Absolute range width:      .7100522227428314000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .4355599076928755000000000D+03      .4362699599156112000000000D+03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.860791742102470E-262,  3.084347291701431E-262]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6026562922994943000000000D+03     -.6021509543042772000000000D+03
 Relative range width:      .8388694484393728000000000D-03
 Absolute range width:      .5053379952171326000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6026562922994887000000000D+03     -.6021509543042808000000000D+03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.511174218485965E-008,  3.289061598505736E-008]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1749993028407082000000000D+02     -.1723007844827805000000000D+02
 Relative range width:      .1553998087777140000000000D-01
 Absolute range width:      .2698518357927675000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1749993028407066000000000D+02     -.1723007844827816000000000D+02
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.479238655716344E-006,  1.557154069750048E-006]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1342398302436196000000000D+02     -.1337265071705342000000000D+02
 Relative range width:      .3831250432713866000000000D-02
 Absolute range width:      .5133230730853633000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1342398302436183000000000D+02     -.1337265071705350000000000D+02
 ---------------------------------------------------
 
 [X1,X2] is:
 [  7.435099818306929E-001,  8.342768056421874E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2963730877104608000000000D+00     -.1811900304407985000000000D+00
 Relative range width:      .4823783616940881000000000D+00
 Absolute range width:      .1151830572696623000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2963730877104570000000000D+00     -.1811900304408006000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [       1.209122645033399,       2.437588087018611]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1898950098568526000000000D+00      .8910090615009485000000000D+00
 Relative range width:      .1297273403297253000000000D+01
 Absolute range width:      .7011140516440959000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1898950098568545000000000D+00      .8910090615009393000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.047261776948326E+131,  1.236472406374660E+132]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3038411093280646000000000D+03      .3041534947670351000000000D+03
 Relative range width:      .1027592800549277000000000D-02
 Absolute range width:      .3123854389704661000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3038411093280664000000000D+03      .3041534947670322000000000D+03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.110416081378582E-018,  1.300086285529038E-018]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4134179688071814000000000D+02     -.4118410103814384000000000D+02
 Relative range width:      .3821729821815441000000000D-02
 Absolute range width:      .1576958425743058000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4134179688071776000000000D+02     -.4118410103814408000000000D+02
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.447436714129662E+108,  4.597074430983445E+108]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2499168210168395000000000D+03      .2502046101512604000000000D+03
 Relative range width:      .1150877032998706000000000D-02
 Absolute range width:      .2877891344209047000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2499168210168410000000000D+03      .2502046101512580000000000D+03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.248994460341245E+095,  1.097062589780692E+096]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2189679226302913000000000D+03      .2211408051625023000000000D+03
 Relative range width:      .9874298758437452000000000D-02
 Absolute range width:      .2172882532210934000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2189679226302927000000000D+03      .2211408051625002000000000D+03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.309616486188918E-028,  7.485537670572995E-028]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6327555028635752000000000D+02     -.6245940975546528000000000D+02
 Relative range width:      .1298191896065774000000000D-01
 Absolute range width:      .8161405308922411000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6327555028635692000000000D+02     -.6245940975546568000000000D+02
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.205128929390389E-030,  1.273385695108470E-030]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6889096623325828000000000D+02     -.6883587353490312000000000D+02
 Relative range width:      .8000284976828969000000000D-03
 Absolute range width:      .5509269835516761000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6889096623325763000000000D+02     -.6883587353490354000000000D+02
 ---------------------------------------------------
 
 [X1,X2] is:
 [  5.294314212245990E-001,  8.789907186439752E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6359516384294700000000000D+00     -.1289809403470442000000000D+00
 Relative range width:      .1325530411826124000000000D+01
 Absolute range width:      .5069706980824258000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6359516384294621000000000D+00     -.1289809403470466000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.852759742231847E+274,  4.020170076694044E+274]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .6322571051880386000000000D+03      .6322996396897458000000000D+03
 Relative range width:      .6727179603369084000000000D-04
 Absolute range width:      .4253450170722317000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .6322571051880424000000000D+03      .6322996396897398000000000D+03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  4.390841822636957E-153,  1.450371727826398E-152]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3508159982602459000000000D+03     -.3496211142474979000000000D+03
 Relative range width:      .3411823820899499000000000D-02
 Absolute range width:      .1194884012747991000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3508159982602425000000000D+03     -.3496211142474999000000000D+03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  4.218596222745108E+294,  8.953977392896885E+294]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .6783995197643148000000000D+03      .6791521151752664000000000D+03
 Relative range width:      .1108754012122832000000000D-02
 Absolute range width:      .7525954109515851000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .6783995197643189000000000D+03      .6791521151752601000000000D+03
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:  1.351079888211152E+016
 
 Maximum absolute width of an output interval
 with point input:  2.964792656712234E-006
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TEST OF ROUTINE POWER FOLLOWS
 
 
 
 [X1,X2] is:
 [  2.499999999999999E-001,  2.500000000000001E-001]
 N is:          1
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .2499999999999999000000000D+00      .2500000000000001000000000D+00
 Relative range width:      .4440892098500626000000000D-15
 Absolute range width:      .1110223024625157000000000D-15
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2499999999999999000000000D+00      .2500000000000001000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.499999999999999E-001,  2.500000000000001E-001]
 N is:         -1
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .3999999999999997000000000D+01      .4000000000000003000000000D+01
 Relative range width:      .1332267629550188000000000D-14
 Absolute range width:      .5329070518200751000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .4000000000000001000000000D+01      .3999999999999999000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.499999999999999E-001,  2.500000000000001E-001]
 N is:          2
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .6249999999999996000000000D-01      .6250000000000004000000000D-01
 Relative range width:      .1332267629550188000000000D-14
 Absolute range width:      .8326672684688674000000000D-16
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .6249999999999997000000000D-01      .6250000000000003000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [     708.782712893383900,     708.782712893383900]
 N is:          2
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .5023729340965049000000000D+06      .5023729340965051000000000D+06
 Relative range width:      .4634617588875583000000000D-15
 Absolute range width:      .2328306436538696000000000D-09
 ---------------------------------------------------
 
 [X1,X2] is:
 [     708.782712893383900,     708.782712893383900]
 N is:         10
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .3199861390867070000000000D+29      .3199861390867083000000000D+29
 Relative range width:      .4123347208404156000000000D-14
 Absolute range width:      .1319413953331200000000000D+15
 ---------------------------------------------------
 
 [X1,X2] is:
 [     708.782712893383900,     708.782712893383900]
 N is:        -10
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .3125135366344804000000000D-28      .3125135366344820000000000D-28
 Relative range width:      .5022036155443224000000000D-14
 Absolute range width:      .1569454280043795000000000D-42
 ---------------------------------------------------
 
 [X1,X2] is:
 [     599.283184444063300,     602.599392022667600]
 N is:         -1
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1659477279994307000000000D-02      .1668660202651389000000000D-02
 Relative range width:      .5518355359395936000000000D-02
 Absolute range width:      .9182922657082187000000000D-05
 ---------------------------------------------------
 
 [X1,X2] is:
 [       7.218542389437259,       7.915427592377745]
 N is:         11
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .2772966496429898000000000D+10      .7642196234582117000000000D+10
 Relative range width:      .9350271069032233000000000D+00
 Absolute range width:      .4869229738152220000000000D+10
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2772966496429903000000000D+10      .7642196234582101000000000D+10
 ---------------------------------------------------
 
 [X1,X2] is:
 [       1.279296391595414,       1.890993463859259]
 N is:        -12
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .4783212411023692000000000D-03      .5204103209866481000000000D-01
 Relative range width:      .1963569906277563000000000D+01
 Absolute range width:      .5156271085756244000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5204103209866466000000000D-01      .4783212411023707000000000D-03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  7.690083328773525E-001,       1.485904374040399]
 N is:         -8
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .4207974612221590000000000D-01      .8176202398481099000000000D+01
 Relative range width:      .1979518957669348000000000D+01
 Absolute range width:      .8134122652358883000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .8176202398481083000000000D+01      .4207974612221597000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.543925838232221E-001,  9.644448065589772E-001]
 N is:          8
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1754024160438236000000000D-04      .7485469245804560000000000D+00
 Relative range width:      .1999906272646225000000000D+01
 Absolute range width:      .7485293843388516000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1754024160438239000000000D-04      .7485469245804547000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [       1.726458241165669,       2.231796236373460]
 N is:          4
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .8884322461634552000000000D+01      .2480950866548158000000000D+02
 Relative range width:      .9452879456637836000000000D+00
 Absolute range width:      .1592518620384702000000000D+02
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .8884322461634557000000000D+01      .2480950866548156000000000D+02
 ---------------------------------------------------
 
 [X1,X2] is:
 [  5.218636014415414E-001,  7.917154372340419E-001]
 N is:          0
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999998000000000D+00      .1000000000000000000000000D+01
 Relative range width:      .4440892098500626000000000D-15
 Absolute range width:      .4440892098500626000000000D-15
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D+01      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  6.669183952183501E-002,  1.180241468301591E-001]
 N is:         -5
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .4366622532864341000000000D+05      .7579429498368780000000000D+06
 Relative range width:      .1782107158044308000000000D+01
 Absolute range width:      .7142767245082345000000000D+06
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .7579429498368772000000000D+06      .4366622532864346000000000D+05
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.088082996889184E-001,  2.239913569585746E-001]
 N is:          2
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1183924608119347000000000D-01      .5017212799214361000000000D-01
 Relative range width:      .1236317771820898000000000D+01
 Absolute range width:      .3833288191095014000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1183924608119348000000000D-01      .5017212799214360000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.827205029964723E-001,  8.838345546405572E-001]
 N is:        -14
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .5633863545975724000000000D+01      .2162609221809045000000000D+11
 Relative range width:      .1999999998957950000000000D+01
 Absolute range width:      .2162609221245659000000000D+11
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2162609221809039000000000D+11      .5633863545975742000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.119368690096085E-001,  6.243223079754370E-001]
 N is:         11
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .2721032918726067000000000D-05      .5616908965716336000000000D-02
 Relative range width:      .1998063194253439000000000D+01
 Absolute range width:      .5614187932797611000000000D-02
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2721032918726073000000000D-05      .5616908965716323000000000D-02
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.267611733458649E-002,  2.503719599082678E-001]
 N is:         -8
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .6476114043344613000000000D+05      .1837626961341744000000000D+09
 Relative range width:      .1998590827694761000000000D+01
 Absolute range width:      .1836979349937409000000000D+09
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1837626961341740000000000D+09      .6476114043344628000000000D+05
 ---------------------------------------------------
 
 [X1,X2] is:
 [  8.579775825296736E-002,  3.735868926699434E-001]
 N is:          3
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .6315792044896579000000000D-03      .5214046400470453000000000D-01
 Relative range width:      .1952127742942527000000000D+01
 Absolute range width:      .5150888480021488000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .6315792044896582000000000D-03      .5214046400470451000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.158771301464439E-001,       2.288759662353888]
 N is:         -5
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1592205230326370000000000D-01      .4786425968929678000000000D+05
 Relative range width:      .1999998669399915000000000D+01
 Absolute range width:      .4786424376724448000000000D+05
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .4786425968929673000000000D+05      .1592205230326373000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.801495043387501E-001,       1.196290035229996]
 N is:        -13
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .9730287946731930000000000D-01      .2887968345243369000000000D+06
 Relative range width:      .1999998652300371000000000D+01
 Absolute range width:      .2887967372214574000000000D+06
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2887968345243360000000000D+06      .9730287946731961000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.566066457140129E-001,  2.116993440680969E-001]
 N is:          5
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .9420000775274128000000000D-04      .4252042159857018000000000D-03
 Relative range width:      .1274553394466213000000000D+01
 Absolute range width:      .3310042082329605000000000D-03
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9420000775274137000000000D-04      .4252042159857015000000000D-03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  5.995921391748456E-002,  5.669299119999001E-001]
 N is:         -8
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .9370548815663921000000000D+02      .5986218380537460000000000D+10
 Relative range width:      .1999999937385855000000000D+01
 Absolute range width:      .5986218286831972000000000D+10
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5986218380537450000000000D+10      .9370548815663938000000000D+02
 ---------------------------------------------------
 
 [X1,X2] is:
 [  4.267321696446306E-001,  4.692666713421426E-001]
 N is:         12
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .3646402503168778000000000D-04      .1140345690616344000000000D-03
 Relative range width:      .1030847424153958000000000D+01
 Absolute range width:      .7757054402994663000000000D-04
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3646402503168787000000000D-04      .1140345690616341000000000D-03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.438115938497790E-001,       1.538695606592413]
 N is:          8
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .1952379061388574000000000D-03      .3142112352421110000000000D+02
 Relative range width:      .1999975145803699000000000D+01
 Absolute range width:      .3142092828630497000000000D+02
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1952379061388577000000000D-03      .3142112352421106000000000D+02
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.819788714833971E-001,  5.706165394577959E-001]
 N is:         11
 The function bounds are:
       12345678901234567890123456789       12345678901234567890123456789
      .7248207910855706000000000D-08      .2088276070643669000000000D-02
 Relative range width:      .1999986116428081000000000D+01
 Absolute range width:      .2088268822435758000000000D-02
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .7248207910855721000000000D-08      .2088276070643665000000000D-02
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:  5.022036155443224E-015
 
 Maximum absolute width of an output interval
 with point input:  1.319413953331200E+014
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TEST OF ROUTINE ISIN FOLLOWS
 
 
 
 [X1,X2] is:
 [  0.000000000000000E+000,  0.000000000000000E+000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .0000000000000000000000000D+00      .0000000000000000000000000D+00
 Relative range width:      .0000000000000000000000000D+00
 Absolute range width:      .0000000000000000000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .0000000000000000000000000D+00      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [       3.141592653589792,       3.141592653589794]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1976196983832779000000000D-13      .1820765760385257000000000D-13
 Relative range width:      .4885714285714287000000000D+02
 Absolute range width:      .3796962744218036000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1010693265190987000000000D-14     -.7656635742092632000000000D-15
 ---------------------------------------------------
 
 [X1,X2] is:
 [       1.570796326794896,       1.570796326794897]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999991000000000D+00      .1000000000000000000000000D+01
 Relative range width:      .1110223024625157000000000D-14
 Absolute range width:      .1110223024625157000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D+01      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  6.746518845977818E+009,  6.746518845977829E+009]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1252596391865258000000000D-04      .1529412159151367000000000D-04
 Relative range width:      .2010007289896327000000000D+02
 Absolute range width:      .2782008551016624000000000D-04
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -3.141592653589795,      -3.141592653589791]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1953992523340276000000000D-13      .2287059430727823000000000D-13
 Relative range width:      .2546666666666665000000000D+02
 Absolute range width:      .4241051954068099000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1653841993909388000000000D-14     -.1898871684891112000000000D-14
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.570796326794897,      -1.570796326794896]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01     -.9999999999999991000000000D+00
 Relative range width:      .1110223024625157000000000D-14
 Absolute range width:      .1110223024625157000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.746518845977829E+009, -6.746518845977818E+009]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1252596391887462000000000D-04      .1624779168296620000000000D-04
 Relative range width:      .1546216398268172000000000D+02
 Absolute range width:      .2877375560184082000000000D-04
 ---------------------------------------------------
 
 [X1,X2] is:
 [  145584.388083676700000,  145584.388083676900000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1564312005860787000000000D+00      .1564312010189465000000000D+00
 Relative range width:      .2767144885044984000000000D-08
 Absolute range width:      .4328677971621175000000000D-09
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1564312009068013000000000D+00      .1564312007630736000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -145584.388083676900000, -145584.388083676700000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1564312010862946000000000D+00     -.1564312005959365000000000D+00
 Relative range width:      .3134656899280744000000000D-08
 Absolute range width:      .4903581429793746000000000D-09
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1564312007343281000000000D+00     -.1564312009355468000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-001,  1.000000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9983341664681308000000000D-01      .9983341664684112000000000D-01
 Relative range width:      .2807990782380596000000000D-12
 Absolute range width:      .2803313137178520000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9983341664682815000000000D-01      .9983341664682815000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-002,  1.000000000000000E-002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999833334150996000000000D-02      .9999833334182086000000000D-02
 Relative range width:      .3109023230440428000000000D-11
 Absolute range width:      .3108971413645634000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999833334166664000000000D-02      .9999833334166664000000000D-02
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-003,  1.000000000000000E-003]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999998333171110000000000D-03      .9999998333481976000000000D-03
 Relative range width:      .3108668355150841000000000D-10
 Absolute range width:      .3108667837037338000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999998333333417000000000D-03      .9999998333333417000000000D-03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-004,  1.000000000000000E-004]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999981746829000000000D-04      .9999999984844357000000000D-04
 Relative range width:      .3097527664889285000000000D-09
 Absolute range width:      .3097527659715049000000000D-13
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999983333334000000000D-04      .9999999983333334000000000D-04
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-005,  1.000000000000000E-005]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999833332000000000D-05      .1000000000000000000000000D-04
 Relative range width:      .1666689789667231000000000D-10
 Absolute range width:      .1666689789653342000000000D-15
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999833334000000000D-05      .9999999999833334000000000D-05
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-006,  1.000000000000000E-006]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999998331000000000D-06      .1000000000000000000000000D-05
 Relative range width:      .1668654906091111000000000D-12
 Absolute range width:      .1668654906090972000000000D-18
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999998333000000000D-06      .9999999999998333000000000D-06
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-007,  1.000000000000000E-007]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999980000000000D-07      .1000000000000000000000000D-06
 Relative range width:      .1985233470127269000000000D-14
 Absolute range width:      .1985233470127266000000000D-21
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999982000000000D-07      .9999999999999982000000000D-07
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-008,  1.000000000000000E-008]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999999000000000D-08      .1000000000000000000000000D-07
 Relative range width:      .1654361225106055000000000D-15
 Absolute range width:      .1654361225106055000000000D-23
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D-07      .1000000000000000000000000D-07
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-009,  1.000000000000000E-009]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999999000000000D-09      .1000000000000000000000000D-08
 Relative range width:      .2067951531382569000000000D-15
 Absolute range width:      .2067951531382569000000000D-24
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D-08      .1000000000000000000000000D-08
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-010,  1.000000000000000E-010]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999998000000000D-10      .1000000000000000000000000D-09
 Relative range width:      .2584939414228211000000000D-15
 Absolute range width:      .2584939414228211000000000D-25
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D-09      .1000000000000000000000000D-09
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999999E-012,  9.999999999999999E-012]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999998000000000D-11      .9999999999999999000000000D-11
 Relative range width:      .1615587133892632000000000D-15
 Absolute range width:      .1615587133892632000000000D-26
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999999000000000D-11      .9999999999999999000000000D-11
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-012,  1.000000000000000E-012]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999998000000000D-12      .1000000000000000000000000D-11
 Relative range width:      .2019483917365791000000000D-15
 Absolute range width:      .2019483917365790000000000D-27
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D-11      .1000000000000000000000000D-11
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-013,  1.000000000000000E-013]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999998000000000D-13      .1000000000000000000000000D-12
 Relative range width:      .2524354896707238000000000D-15
 Absolute range width:      .2524354896707238000000000D-28
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D-12      .1000000000000000000000000D-12
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-014,  1.000000000000000E-014]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999998000000000D-14      .1000000000000000000000000D-13
 Relative range width:      .1577721810442024000000000D-15
 Absolute range width:      .1577721810442024000000000D-29
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D-13      .1000000000000000000000000D-13
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-015,  1.000000000000000E-015]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999999000000000D-15      .1000000000000000000000000D-14
 Relative range width:      .1972152263052529000000000D-15
 Absolute range width:      .1972152263052530000000000D-30
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D-14      .1000000000000000000000000D-14
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-016,  1.000000000000000E-016]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999997000000000D-16      .1000000000000000000000000D-15
 Relative range width:      .2465190328815662000000000D-15
 Absolute range width:      .2465190328815662000000000D-31
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D-15      .1000000000000000000000000D-15
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-017,  1.000000000000000E-017]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999999000000000D-17      .1000000000000000000000000D-16
 Relative range width:      .1540743955509789000000000D-15
 Absolute range width:      .1540743955509789000000000D-32
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D-16      .1000000000000000000000000D-16
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-018,  1.000000000000000E-018]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999999000000000D-18      .1000000000000000000000000D-17
 Relative range width:      .1925929944387236000000000D-15
 Absolute range width:      .1925929944387236000000000D-33
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D-17      .1000000000000000000000000D-17
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.000000000000000E-019,  1.000000000000000E-019]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999997000000000D-19      .1000000000000000000000000D-18
 Relative range width:      .2407412430484045000000000D-15
 Absolute range width:      .2407412430484045000000000D-34
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D-18      .1000000000000000000000000D-18
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999999E-021,  9.999999999999999E-021]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999998000000000D-20      .9999999999999999000000000D-20
 Relative range width:      .1504632769052528000000000D-15
 Absolute range width:      .1504632769052528000000000D-35
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9999999999999999000000000D-20      .9999999999999999000000000D-20
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.717986917599999E+010,  1.717986917600001E+010]
 WARNING: Loss of accuracy in trig function due to the argument range.
 X:  1.717986917442919E+010   1.717986917442921E+010
 Error occurred in routine ICOS.
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01      .1000000000000000000000000D+01
 Relative range width:      .1340780792994260000000000+155
 Absolute range width:      .2000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.717986917600001E+010, -1.717986917599999E+010]
 WARNING: Loss of accuracy in trig function due to the argument range.
 X: -1.717986917757081E+010  -1.717986917757078E+010
 Error occurred in routine ICOS.
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01      .1000000000000000000000000D+01
 Relative range width:      .1340780792994260000000000+155
 Absolute range width:      .2000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [       1.570796326794896,       4.712388980384693]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01      .1000000000000000000000000D+01
 Relative range width:      .1340780792994260000000000+155
 Absolute range width:      .2000000000000000000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D+01     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -4.712388980384694,      -1.570796326794896]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01      .1000000000000000000000000D+01
 Relative range width:      .1340780792994260000000000+155
 Absolute range width:      .2000000000000000000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1000000000000000000000000D+01     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [       3.141592653589792,       6.283185307179592]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01      .2686739719592880000000000D-13
 Relative range width:      .2000000000000107000000000D+01
 Absolute range width:      .1000000000000027000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1010693265190987000000000D-14      .5084040827219027000000000D-14
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -6.283185307179593,      -3.141592653589791]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3008704396734175000000000D-13      .1000000000000000000000000D+01
 Relative range width:      .2000000000000120000000000D+01
 Absolute range width:      .1000000000000030000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6860397666619278000000000D-14     -.1898871684891112000000000D-14
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -5.718166882251091E-022,  9.502783724891757E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.5718166882251091000000000D-21      .8135773978405307000000000D+00
 Relative range width:      .2000000000000000000000000D+01
 Absolute range width:      .8135773978405307000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.5718166882251091000000000D-21      .8135773978405190000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -24.841184909838750,     -23.928527560849500]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2874432112310391000000000D+00      .9335576625127875000000000D+00
 Relative range width:      .1058335772194226000000000D+01
 Absolute range width:      .6461144512817485000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2874432112310806000000000D+00      .9335576625127763000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [    -256.519678424378400,    -256.495801144814300]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .8870516425133360000000000D+00      .8978211708635618000000000D+00
 Relative range width:      .1206755828147818000000000D-01
 Absolute range width:      .1076952835022582000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .8870516425134430000000000D+00      .8978211708634342000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -5.791384716724333E+008, -5.791384672718623E+008]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01      .9491344066450549000000000D+00
 Relative range width:      .7663861868449249000000000D+02
 Absolute range width:      .1949134406645055000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .8503271587177456000000000D-02      .9491342781355264000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -5.518370056202790E+008, -5.518370034789566E+008]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.9881725040748023000000000D+00      .6627466889710943000000000D+00
 Relative range width:      .1014620915995724000000000D+02
 Absolute range width:      .1650919193045897000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.9881724368317042000000000D+00      .6627463398364882000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.091821648457920E-023,       2.678969518806321]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1754152378907748000000000D-13      .1000000000000000000000000D+01
 Relative range width:      .2000000000000070000000000D+01
 Absolute range width:      .1000000000000018000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3091821648457920000000000D-22      .4462970433778647000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.670250641444144E-001, -5.243316951499994E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6186514233613637000000000D+00     -.5006345926010980000000000D+00
 Relative range width:      .2108787728555410000000000D+00
 Absolute range width:      .1180168307602657000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6186514233613494000000000D+00     -.5006345926011155000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      21.461267317961430,      22.176661886475310]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1844510616026066000000000D+00      .5054308854853576000000000D+00
 Relative range width:      .4298600072383163000000000D+01
 Absolute range width:      .6898819470879642000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5054308854853312000000000D+00     -.1844510616025689000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [    2958.558289188813000,    2959.280801722037000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.7325023367914312000000000D+00     -.9931397063953515000000000D-01
 Relative range width:      .1522423545908771000000000D+01
 Absolute range width:      .6331883661518960000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.7325023367901676000000000D+00     -.9931397064258875000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  -19668.764274642430000,  -19666.467643124480000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01     -.9747662309032995000000000D-01
 Relative range width:      .1644724557992496000000000D+01
 Absolute range width:      .9025233769096703000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6796823443694460000000000D+00     -.9747662310827931000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.625520246134957E+008, -2.625520245535593E+008]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1656344442381610000000000D+00      .2244106939947483000000000D+00
 Relative range width:      .3013817837744207000000000D+00
 Absolute range width:      .5877624975658732000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2244104445608332000000000D+00      .1656347371059503000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  4.443059222942245E-001,       2.741819779676960]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3892091352865066000000000D+00      .1000000000000000000000000D+01
 Relative range width:      .8793360901525108000000000D+00
 Absolute range width:      .6107908647134936000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .4298312947261462000000000D+00      .3892091352865216000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.469786162712476E+008,  1.469786174226952E+008]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5253750406373391000000000D-01      .9334845139101307000000000D+00
 Relative range width:      .1786870868576785000000000D+01
 Absolute range width:      .8809470098463967000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9334844719403077000000000D+00      .5253766991870637000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -3.309364200303450E+008, -3.309364171387323E+008]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.5722526004511825000000000D+00      .1000000000000000000000000D+01
 Relative range width:      .7351313425211113000000000D+01
 Absolute range width:      .1572252600451183000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.5722524353707386000000000D+00      .7573398238790887000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.640853730942747E-002,       2.515652742405221]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2640546781643895000000000D-01      .1000000000000000000000000D+01
 Relative range width:      .2108486508268354000000000D+01
 Absolute range width:      .1026405467816439000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2640546781642053000000000D-01      .5858592476874196000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  4.789057537780910E-002,       1.173093234406444]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .4787227124696568000000000D-01      .9219530215123024000000000D+00
 Relative range width:      .1802553009890004000000000D+01
 Absolute range width:      .8740807502653367000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .4787227124698118000000000D-01      .9219530215122909000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [     675.240703861462900,     679.315103176506700]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01      .6676814796152689000000000D+00
 Relative range width:      .1003664482909086000000000D+02
 Absolute range width:      .1667681479615269000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2003514786645827000000000D+00      .6676814796148848000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  7.825708724546880E+009,  7.825708725499528E+009]
 WARNING: Loss of accuracy in trig function due to the argument range.
 X:  7.825708722976082E+009   7.825708723928734E+009
 Error occurred in routine ICOS.
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01      .1000000000000000000000000D+01
 Relative range width:      .1340780792994260000000000+155
 Absolute range width:      .2000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.592375125673110E-010,       4.776208390697135]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01      .1000000000000000000000000D+01
 Relative range width:      .1340780792994260000000000+155
 Absolute range width:      .2000000000000000000000000D+01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1592375125673110000000000D-09     -.9979642325337690000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -7.237419205470671E+009, -7.237419205354047E+009]
 WARNING: Loss of accuracy in trig function due to the argument range.
 X: -7.237419207041469E+009  -7.237419206924841E+009
 Error occurred in routine ICOS.
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1000000000000000000000000D+01      .1000000000000000000000000D+01
 Relative range width:      .1340780792994260000000000+155
 Absolute range width:      .2000000000000000000000000D+01
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:      48.857142857142870
 
 Maximum absolute width of an output interval
 with point input:  2.877375560184082E-005
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TEST OF ROUTINE ISINH FOLLOWS
 
 
 
 [X1,X2] is:
 [  0.000000000000000E+000,  0.000000000000000E+000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4450147717014407000000000-307      .8900295434028815000000000-307
 Relative range width:      .8950008877440257000000000-153
 Absolute range width:      .1335044315104322000000000-306
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .0000000000000000000000000D+00      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.500000000000000E-001,  2.500000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2526123168081679000000000D+00      .2526123168081688000000000D+00
 Relative range width:      .3296225928291485000000000D-14
 Absolute range width:      .8326672684688674000000000D-15
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2526123168081683000000000D+00      .2526123168081683000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.500000000000000E-001, -2.500000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2526123168081689000000000D+00     -.2526123168081679000000000D+00
 Relative range width:      .3735722718730348000000000D-14
 Absolute range width:      .9436895709313831000000000D-15
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2526123168081683000000000D+00     -.2526123168081683000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [       2.999999999999999,       3.000000000000001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1001787492740982000000000D+02      .1001787492740999000000000D+02
 Relative range width:      .1684527916008377000000000D-13
 Absolute range width:      .1687538997430238000000000D-12
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1001787492740989000000000D+02      .1001787492740991000000000D+02
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -3.000000000000002,      -2.999999999999998]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1001787492741001000000000D+02     -.1001787492740982000000000D+02
 Relative range width:      .1932774135209609000000000D-13
 Absolute range width:      .1936228954946273000000000D-12
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1001787492740992000000000D+02     -.1001787492740988000000000D+02
 ---------------------------------------------------
 
 [X1,X2] is:
 [       8.999999999999998,       9.000000000000002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .4051541902082688000000000D+04      .4051541902082903000000000D+04
 Relative range width:      .5297754652569918000000000D-13
 Absolute range width:      .2146407496184111000000000D-09
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .4051541902082783000000000D+04      .4051541902082797000000000D+04
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -9.000000000000004,      -8.999999999999996]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4051541902082921000000000D+04     -.4051541902082688000000000D+04
 Relative range width:      .5769165024196889000000000D-13
 Absolute range width:      .2337401383556426000000000D-09
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4051541902082804000000000D+04     -.4051541902082776000000000D+04
 ---------------------------------------------------
 
 [X1,X2] is:
 [      26.999999999999990,      27.000000000000010]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2660241203008790000000000D+12      .2660241203009211000000000D+12
 Relative range width:      .1579657702865180000000000D-12
 Absolute range width:      .4202270507812500000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2660241203008974000000000D+12      .2660241203009012000000000D+12
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -27.000000000000010,     -26.999999999999990]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2660241203009249000000000D+12     -.2660241203008790000000000D+12
 Relative range width:      .1726495891657283000000000D-12
 Absolute range width:      .4592895507812500000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2660241203009031000000000D+12     -.2660241203008955000000000D+12
 ---------------------------------------------------
 
 [X1,X2] is:
 [     705.782712893383900,     705.782712893383900]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1646294914541076000000000+307      .1646294914547298000000000+307
 Relative range width:      .3779036435036484000000000D-11
 Absolute range width:      .6221408464877759000000000+295
 ---------------------------------------------------
 
 [X1,X2] is:
 [    -705.782712893384000,    -705.782712893383700]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1646294914547672000000000+307     -.1646294914541076000000000+307
 Relative range width:      .4006725748064293000000000D-11
 Absolute range width:      .6596252223012249000000000+295
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.250000000000000E-001,  1.250000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1253257752411153000000000D+00      .1253257752411157000000000D+00
 Relative range width:      .2879076409533362000000000D-14
 Absolute range width:      .3608224830031759000000000D-15
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1253257752411155000000000D+00      .1253257752411155000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -1.250000000000000E-001, -1.250000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1253257752411157000000000D+00     -.1253257752411153000000000D+00
 Relative range width:      .3764946074005166000000000D-14
 Absolute range width:      .4718447854656915000000000D-15
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1253257752411155000000000D+00     -.1253257752411154000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [    -602.599392022667600,    -599.283184444063300]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.2538404085244858000000000+262     -.9211918898694825000000000+260
 Relative range width:      .1859922639895517000000000D+01
 Absolute range width:      .2446284896257909000000000+262
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -9.105831376909460,      -8.408946173968973]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4503833419061449000000000D+04     -.2243514623908317000000000D+04
 Relative range width:      .6699873137589857000000000D+00
 Absolute range width:      .2260318795153131000000000D+04
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.4503833419061330000000000D+04     -.2243514623908366000000000D+04
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -4.879306522769393,      -4.267609450505548]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6576590518867339000000000D+02     -.3566842428131145000000000D+02
 Relative range width:      .5934377653921988000000000D+00
 Absolute range width:      .3009748090736193000000000D+02
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6576590518867241000000000D+02     -.3566842428131191000000000D+02
 ---------------------------------------------------
 
 [X1,X2] is:
 [     578.461888379725000,     579.178784420888000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .8351723716330605000000000+251      .1710488323120850000000000+252
 Relative range width:      .6876925532861764000000000D+00
 Absolute range width:      .8753159514877892000000000+251
 ---------------------------------------------------
 
 [X1,X2] is:
 [     434.092498105281700,     434.802550328017400]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1670885026166000000000000+189      .3398743024458514000000000+189
 Relative range width:      .6816507960893359000000000D+00
 Absolute range width:      .1727857998292514000000000+189
 ---------------------------------------------------
 
 [X1,X2] is:
 [    -600.632268638937500,    -600.126930643729700]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3550176355742696000000000+261     -.2141827174755398000000000+261
 Relative range width:      .4948518297437026000000000D+00
 Absolute range width:      .1408349180987298000000000+261
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -17.443579966468410,     -17.173728130675900]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1882003940511259000000000D+08     -.1436896097247790000000000D+08
 Relative range width:      .2682261220280743000000000D+00
 Absolute range width:      .4451078432634696000000000D+07
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1882003940511169000000000D+08     -.1436896097247840000000000D+08
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -13.379198344792310,     -13.327866037483980]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3232079374372882000000000D+06     -.3070355619776076000000000D+06
 Relative range width:      .5132103853413687000000000D-01
 Absolute range width:      .1617237545968057000000000D+05
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3232079374372739000000000D+06     -.3070355619776186000000000D+06
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -2.961296993628609E-001, -1.809466420932045E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3004767897715992000000000D+00     -.1819356762329802000000000D+00
 Relative range width:      .4914512865738992000000000D+00
 Absolute range width:      .1185411135386190000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3004767897715985000000000D+00     -.1819356762329804000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.862839841202110E-001,  8.873980357642959E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1873632509014123000000000D+00      .1008538055703563000000000D+01
 Relative range width:      .1373315340098374000000000D+01
 Absolute range width:      .8211748048021508000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1873632509014125000000000D+00      .1008538055703560000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [     302.816218240113800,     303.128603679079600]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1623239554300414000000000+132      .2218451247808252000000000+132
 Relative range width:      .3098696507179247000000000D+00
 Absolute range width:      .5952116935078382000000000+131
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1623239554301957000000000+132      .2218451247806410000000000+132
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -41.203525604680310,     -41.045829762106630]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3921333769378020000000000D+18     -.3349248527913944000000000D+18
 Relative range width:      .1573698551427324000000000D+00
 Absolute range width:      .5720852414640755000000000D+17
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3921333769377576000000000D+18     -.3349248527914344000000000D+18
 ---------------------------------------------------
 
 [X1,X2] is:
 [     249.075046012968600,     249.362835147385600]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .7428276613133526000000000+108      .9905429255480753000000000+108
 Relative range width:      .2858191619407305000000000D+00
 Absolute range width:      .2477152642347227000000000+108
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .7428276613139436000000000+108      .9905429255474205000000000+108
 ---------------------------------------------------
 
 [X1,X2] is:
 [     218.223664410368900,     220.396546942576300]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2966902526925829000000000D+95      .2605998563781621000000000D+96
 Relative range width:      .1591151140957697000000000D+01
 Absolute range width:      .2309308311089039000000000D+96
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2966902526927961000000000D+95      .2605998563779994000000000D+96
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -63.066164201849450,     -62.250023670958210]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1225341413973955000000000D+28     -.5417660458565760000000000D+27
 Relative range width:      .7736658733622633000000000D+00
 Absolute range width:      .6835753681173794000000000D+27
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.1225341413973733000000000D+28     -.5417660458566774000000000D+27
 ---------------------------------------------------
 
 [X1,X2] is:
 [     -68.659676242345230,     -68.604583543991140]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3292217549603835000000000D+30     -.3115746176601096000000000D+30
 Relative range width:      .5507876777799829000000000D-01
 Absolute range width:      .1764713730027390000000000D+29
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3292217549603190000000000D+30     -.3115746176601712000000000D+30
 ---------------------------------------------------
 
 [X1,X2] is:
 [ -6.357195176784329E-001, -1.287488195960174E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6794130241598137000000000D+00     -.1291048101377392000000000D+00
 Relative range width:      .1361276624158048000000000D+01
 Absolute range width:      .5503082140220745000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.6794130241598124000000000D+00     -.1291048101377394000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [     630.131189081127900,     630.173723582825300]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2298625908215808000000000+274      .2398505931336178000000000+274
 Relative range width:      .4252809013335990000000000D-01
 Absolute range width:      .9988002312037074000000000+272
 ---------------------------------------------------
 
 [X1,X2] is:
 [    -349.640786881999100,    -348.445902869256500]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3515882847130920000000000+152     -.1064395089373453000000000+152
 Relative range width:      .1070453711212303000000000D+01
 Absolute range width:      .2451487757757467000000000+152
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
     -.3515882847127610000000000+152     -.1064395089374514000000000+152
 ---------------------------------------------------
 
 [X1,X2] is:
 [     676.113167653702800,     676.865763064643900]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2143817730607412000000000+294      .4550256644834532000000000+294
 Relative range width:      .7189758521522991000000000D+00
 Absolute range width:      .2406438914227120000000000+294
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:  4.006725748064293E-012
 
 Maximum absolute width of an output interval
 with point input:  6.596252223012249E+294
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TEST OF ROUTINE ISQRT FOLLOWS
 
 
 
 [X1,X2] is:
 [  0.000000000000000E+000,  0.000000000000000E+000]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .0000000000000000000000000D+00      .0000000000000000000000000D+00
 Relative range width:      .0000000000000000000000000D+00
 Absolute range width:      .0000000000000000000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .0000000000000000000000000D+00      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.500000000000000E-001,  2.500000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .4999999999999993000000000D+00      .5000000000000007000000000D+00
 Relative range width:      .2775557561562891000000000D-14
 Absolute range width:      .1387778780781446000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5000000000000000000000000D+00      .5000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.250000000000000E-001,  1.250000000000000E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3535533905932733000000000D+00      .3535533905932742000000000D+00
 Relative range width:      .2512147933894040000000000D-14
 Absolute range width:      .8881784197001252000000000D-15
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3535533905932738000000000D+00      .3535533905932738000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.797693134862316E+307,  1.797693134862316E+307]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .4239921148867765000000000+154      .4239921148869569000000000+154
 Relative range width:      .4255130163914886000000000D-12
 Absolute range width:      .1804141637317172000000000+142
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.225073858507201E-308,  2.225073858507201E-308]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .0000000000000000000000000D+00      .1491668146240333000000000-153
 Relative range width:      .1000000000000196000000000D+01
 Absolute range width:      .1491668146240333000000000-153
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1491668146240041000000000-153      .1491668146240041000000000-153
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.614212505450001E-263,  7.203632355523320E-262]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .5112937028214771000000000-131      .2683958337144174000000000-130
 Relative range width:      .1359933180323423000000000D+01
 Absolute range width:      .2172664634322696000000000-130
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .5112937028215779000000000-131      .2683958337143727000000000-130
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.080477151403373E-004,  2.169047114486279E-004]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1039460028766554000000000D-01      .1472768520333828000000000D-01
 Relative range width:      .3449594518161496000000000D+00
 Absolute range width:      .4333084915672742000000000D-02
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1039460028766558000000000D-01      .1472768520333823000000000D-01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  7.525174970799521E-003,  1.387309197085012E-002]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .8674776637354692000000000D-01      .1177840904827565000000000D+00
 Relative range width:      .3034864552275059000000000D+00
 Absolute range width:      .3103632410920959000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .8674776637354717000000000D-01      .1177840904827563000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.178718057986076E+252,  2.414092638730612E+252]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1085687827133425000000000+127      .1553735060662379000000000+127
 Relative range width:      .3546587670305628000000000D+00
 Absolute range width:      .4680472335289536000000000+126
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1085687827133599000000000+127      .1553735060662085000000000+127
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.449654304039512E+189,  2.948738169629400E+189]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3807432604839070000000000D+95      .5430228512346641000000000D+95
 Relative range width:      .3513434595448685000000000D+00
 Absolute range width:      .1622795907507571000000000D+95
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3807432604839529000000000D+95      .5430228512345866000000000D+95
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.860791742102470E-262,  3.084347291701431E-262]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1364108405553510000000000-130      .1756230990417393000000000-130
 Relative range width:      .2513332910966072000000000D+00
 Absolute range width:      .3921225848638834000000000-131
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1364108405553778000000000-130      .1756230990417101000000000-130
 ---------------------------------------------------
 
 [X1,X2] is:
 [  2.511174218485965E-008,  3.289061598505736E-008]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1584668488512954000000000D-03      .1813577017528005000000000D-03
 Relative range width:      .1347215959577537000000000D+00
 Absolute range width:      .2289085290150511000000000D-04
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1584668488512965000000000D-03      .1813577017527995000000000D-03
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.479238655716344E-006,  1.557154069750048E-006]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1216239555234218000000000D-02      .1247859795710264000000000D-02
 Relative range width:      .2566474477900127000000000D-01
 Absolute range width:      .3162024047604641000000000D-04
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1216239555234225000000000D-02      .1247859795710259000000000D-02
 ---------------------------------------------------
 
 [X1,X2] is:
 [  7.435099818306929E-001,  8.342768056421874E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .8622702487217626000000000D+00      .9133875440590321000000000D+00
 Relative range width:      .5757561569024684000000000D-01
 Absolute range width:      .5111729533726950000000000D-01
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .8622702487217642000000000D+00      .9133875440590306000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [       1.209122645033399,       2.437588087018611]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1099601129970953000000000D+01      .1561277709768066000000000D+01
 Relative range width:      .3470105988308693000000000D+00
 Absolute range width:      .4616765797971127000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1099601129970954000000000D+01      .1561277709768064000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.047261776948326E+131,  1.236472406374660E+132]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .9511709508257069000000000D+66      .1111967808155842000000000D+67
 Relative range width:      .1558759503015794000000000D+00
 Absolute range width:      .1607968573301350000000000D+66
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .9511709508257875000000000D+66      .1111967808155731000000000D+67
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.110416081378582E-018,  1.300086285529038E-018]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1053762820267707000000000D-08      .1140213263178897000000000D-08
 Relative range width:      .7880709690816896000000000D-01
 Absolute range width:      .8645044291119076000000000D-10
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1053762820267722000000000D-08      .1140213263178883000000000D-08
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.447436714129662E+108,  4.597074430983445E+108]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1856727420524936000000000D+55      .2144078923683596000000000D+55
 Relative range width:      .1436467943891474000000000D+00
 Absolute range width:      .2873515031586597000000000D+54
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1856727420525065000000000D+55      .2144078923683418000000000D+55
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.248994460341245E+095,  1.097062589780692E+096]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .3534111572009426000000000D+48      .1047407556675457000000000D+49
 Relative range width:      .9908439865913284000000000D+00
 Absolute range width:      .6939963994745149000000000D+48
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .3534111572009640000000000D+48      .1047407556675382000000000D+49
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.309616486188918E-028,  7.485537670572995E-028]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1819235137685279000000000D-13      .2735971065375742000000000D-13
 Relative range width:      .4025002982628678000000000D+00
 Absolute range width:      .9167359276904632000000000D-14
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1819235137685318000000000D-13      .2735971065375691000000000D-13
 ---------------------------------------------------
 
 [X1,X2] is:
 [  1.205128929390389E-030,  1.273385695108470E-030]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1097783644162334000000000D-14      .1128443926435213000000000D-14
 Relative range width:      .2754460745866120000000000D-01
 Absolute range width:      .3066028227287919000000000D-16
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1097783644162359000000000D-14      .1128443926435191000000000D-14
 ---------------------------------------------------
 
 [X1,X2] is:
 [  5.294314212245990E-001,  8.789907186439752E-001]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .7276203826341023000000000D+00      .9375450488611083000000000D+00
 Relative range width:      .2521367093700801000000000D+00
 Absolute range width:      .2099246662270060000000000D+00
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .7276203826341033000000000D+00      .9375450488611068000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  3.852759742231847E+274,  4.020170076694044E+274]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .1962844808493656000000000+138      .2005036178400707000000000+138
 Relative range width:      .2126644929442478000000000D-01
 Absolute range width:      .4219136990705055000000000+136
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .1962844808494000000000000+138      .2005036178400291000000000+138
 ---------------------------------------------------
 
 [X1,X2] is:
 [  4.390841822636957E-153,  1.450371727826398E-152]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .6626342748934695000000000D-76      .1204313799566657000000000D-75
 Relative range width:      .5802834391415276000000000D+00
 Absolute range width:      .5416795246731874000000000D-76
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .6626342748935462000000000D-76      .1204313799566541000000000D-75
 ---------------------------------------------------
 
 [X1,X2] is:
 [  4.218596222745108E+294,  8.953977392896885E+294]
 The function bounds on [X1,X2] are:
       12345678901234567890123456789       12345678901234567890123456789
      .2053922155960036000000000+148      .2992319734403539000000000+148
 Relative range width:      .3719193803354887000000000D+00
 Absolute range width:      .9383975784435030000000000+147
 The Fortran library function values at the endpoints are:
       12345678901234567890123456789       12345678901234567890123456789
      .2053922155960422000000000+148      .2992319734402874000000000+148
 ---------------------------------------------------
 
 ===============================================================
 
 SUMMARY SECTION
 
 Maximum relative width of an output interval
 with point input:       1.000000000000196
 
 Maximum absolute width of an output interval
 with point input:  1.804141637317172E+141
 
 Fortran-supplied function values at the endpoints were within
 the interval bounds in each case tested.
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 TESTS OF THE UTILITY ROUTINES FOLLOW
 
 
 TEST OF ICAP FOLLOWS:
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The function bounds are:
      .0000000000000000000000000D+00      .1000000000000000000000000D+01
 ---------------------------------------------------
 Warning:  Disjoint intervals in intersection.
 Error occurred in routine ICAP, a utility function routine.
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The function bounds are:
      .1797693134862316000000000+309     -.1797693134862316000000000+309
 ---------------------------------------------------
 Warning:  Disjoint intervals in intersection.
 Error occurred in routine ICAP, a utility function routine.
 
 [X1,X2] is:
 [      -2.000000000000000,       1.000000000000000]
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The function bounds are:
      .1797693134862316000000000+309     -.1797693134862316000000000+309
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 [Y1,Y2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The function bounds are:
      .9999999999999998000000000D+00      .9999999999999998000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,      -1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The function bounds are:
     -.1000000000000000000000000D+01     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The function bounds are:
     -.1000000000000000000000000D+01      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       2.000000000000000]
 [Y1,Y2] is:
 [      -2.000000000000000,       1.000000000000000]
 The function bounds are:
     -.1000000000000000000000000D+01      .1000000000000000000000000D+01
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IDISJ FOLLOWS:
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The result of the test is:T
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -2.000000000000000,       1.000000000000000]
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The result of the test is:T
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 [Y1,Y2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,      -1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       2.000000000000000]
 [Y1,Y2] is:
 [      -2.000000000000000,       1.000000000000000]
 The result of the test is:F
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IHULL FOLLOWS:
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The function bounds are:
     -.1000000000000000000000000D+01      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The function bounds are:
      .0000000000000000000000000D+00      .3000000000000001000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -2.000000000000000,       1.000000000000000]
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The function bounds are:
     -.2000000000000000000000000D+01      .3000000000000001000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 [Y1,Y2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The function bounds are:
      .9999999999999998000000000D+00      .9999999999999998000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,      -1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The function bounds are:
     -.1000000000000000000000000D+01     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The function bounds are:
     -.1000000000000000000000000D+01      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       2.000000000000000]
 [Y1,Y2] is:
 [      -2.000000000000000,       1.000000000000000]
 The function bounds are:
     -.2000000000000000000000000D+01      .2000000000000000000000000D+01
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IILEI FOLLOWS:
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result of the test is:T
 ---------------------------------------------------
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -2.000000000000000,       1.000000000000000]
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 [Y1,Y2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The result of the test is:T
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,      -1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The result of the test is:T
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result of the test is:T
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       2.000000000000000]
 [Y1,Y2] is:
 [      -2.000000000000000,       1.000000000000000]
 The result of the test is:F
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IILTI FOLLOWS:
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -2.000000000000000,       1.000000000000000]
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 [Y1,Y2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,      -1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       1.000000000000000]
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result of the test is:F
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       2.000000000000000]
 [Y1,Y2] is:
 [      -2.000000000000000,       1.000000000000000]
 The result of the test is:F
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IINF FOLLOWS:
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -2.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:     -.2000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The result on [X1,X2] is:      .9999999999999998000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The result on [X1,X2] is:     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       2.000000000000000]
 The result on [X1,X2] is:     -.1000000000000000000000000D+01
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IMID FOLLOWS:
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .5000000000000002000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .5000000000000002000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -2.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:     -.4999999999999998000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The result on [X1,X2] is:      .9999999999999998000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The result on [X1,X2] is:     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:      .2220446049250313000000000D-15
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       2.000000000000000]
 The result on [X1,X2] is:      .5000000000000004000000000D+00
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IMIG FOLLOWS:
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -2.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The result on [X1,X2] is:      .9999999999999996000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:      .0000000000000000000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       2.000000000000000]
 The result on [X1,X2] is:      .0000000000000000000000000D+00
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF INTABS FOLLOWS:
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -2.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:      .2000000000000001000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       2.000000000000000]
 The result on [X1,X2] is:      .2000000000000001000000000D+01
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IRLEI FOLLOWS:
 
 X is:  0.000000000000000E+000
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result of the test is:T
 ---------------------------------------------------
 
 X is:  0.000000000000000E+000
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The result of the test is:F
 ---------------------------------------------------
 
 X is:      -2.000000000000000
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The result of the test is:F
 ---------------------------------------------------
 
 X is:  9.999999999999998E-001
 [Y1,Y2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The result of the test is:T
 ---------------------------------------------------
 
 X is:      -1.000000000000000
 [Y1,Y2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The result of the test is:T
 ---------------------------------------------------
 
 X is:      -1.000000000000000
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result of the test is:T
 ---------------------------------------------------
 
 X is:      -1.000000000000000
 [Y1,Y2] is:
 [      -2.000000000000000,       1.000000000000000]
 The result of the test is:T
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IRLTI FOLLOWS:
 
 X is:  0.000000000000000E+000
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result of the test is:T
 ---------------------------------------------------
 
 X is:  0.000000000000000E+000
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The result of the test is:F
 ---------------------------------------------------
 
 X is:      -2.000000000000000
 [Y1,Y2] is:
 [       2.000000000000000,       3.000000000000001]
 The result of the test is:F
 ---------------------------------------------------
 
 X is:  9.999999999999998E-001
 [Y1,Y2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The result of the test is:F
 ---------------------------------------------------
 
 X is:      -1.000000000000000
 [Y1,Y2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The result of the test is:F
 ---------------------------------------------------
 
 X is:      -1.000000000000000
 [Y1,Y2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result of the test is:F
 ---------------------------------------------------
 
 X is:      -1.000000000000000
 [Y1,Y2] is:
 [      -2.000000000000000,       1.000000000000000]
 The result of the test is:T
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF ISUP FOLLOWS:
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -2.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The result on [X1,X2] is:      .9999999999999998000000000D+00
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The result on [X1,X2] is:     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       2.000000000000000]
 The result on [X1,X2] is:      .2000000000000000000000000D+01
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IVL1 FOLLOWS:
 
 Input point X is:      .0000000000000000000000000D+00
 The function bounds on X are:
     -.2225073858507203000000000-307      .2225073858507203000000000-307
 ---------------------------------------------------
 
 Input point X is:      .0000000000000000000000000D+00
 The function bounds on X are:
     -.2225073858507203000000000-307      .2225073858507203000000000-307
 ---------------------------------------------------
 
 Input point X is:     -.2000000000000000000000000D+01
 The function bounds on X are:
     -.2000000000000001000000000D+01     -.2000000000000000000000000D+01
 ---------------------------------------------------
 
 Input point X is:      .9999999999999998000000000D+00
 The function bounds on X are:
      .9999999999999996000000000D+00      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 Input point X is:     -.1000000000000000000000000D+01
 The function bounds on X are:
     -.1000000000000000000000000D+01     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 Input point X is:     -.1000000000000000000000000D+01
 The function bounds on X are:
     -.1000000000000000000000000D+01     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 Input point X is:     -.1000000000000000000000000D+01
 The function bounds on X are:
     -.1000000000000000000000000D+01     -.1000000000000000000000000D+01
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IVL2 FOLLOWS:
 SEVERITY 2 ERROR:  LOWER BOUND ON INTERVAL IS GREATER THAN UPPER BOUND
 X:      .000000000000000D+00    -.100000000000000D+01
 Error occurred in routine IVL2, a utility function routine.
 
 X is:  0.000000000000000E+000
 Y is:      -1.000000000000000
 The function bounds are:
     -.1000000000000000000000000D+01      .2225073858507203000000000-307
 ---------------------------------------------------
 
 X is:  0.000000000000000E+000
 Y is:       2.000000000000000
 The function bounds are:
     -.2225073858507203000000000-307      .2000000000000000000000000D+01
 ---------------------------------------------------
 
 X is:      -2.000000000000000
 Y is:       2.000000000000000
 The function bounds are:
     -.2000000000000001000000000D+01      .2000000000000000000000000D+01
 ---------------------------------------------------
 
 X is:  9.999999999999998E-001
 Y is:  9.999999999999998E-001
 The function bounds are:
      .9999999999999996000000000D+00      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 X is:      -1.000000000000000
 Y is:      -1.000000000000000
 The function bounds are:
     -.1000000000000000000000000D+01     -.1000000000000000000000000D+01
 ---------------------------------------------------
 
 X is:      -1.000000000000000
 Y is:      -1.000000000000000
 The function bounds are:
     -.1000000000000000000000000D+01     -.1000000000000000000000000D+01
 ---------------------------------------------------
 SEVERITY 2 ERROR:  LOWER BOUND ON INTERVAL IS GREATER THAN UPPER BOUND
 X:     -.100000000000000D+01    -.200000000000000D+01
 Error occurred in routine IVL2, a utility function routine.
 
 X is:      -1.000000000000000
 Y is:      -2.000000000000000
 The function bounds are:
     -.2000000000000001000000000D+01     -.1000000000000000000000000D+01
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 TEST OF IWID FOLLOWS:
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  0.000000000000000E+000,       1.000000000000000]
 The result on [X1,X2] is:      .1000000000000000000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -2.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:      .3000000000000002000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [  9.999999999999998E-001,  9.999999999999998E-001]
 The result on [X1,X2] is:      .2225073858507203000000000-307
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,      -1.000000000000000]
 The result on [X1,X2] is:      .2225073858507203000000000-307
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       1.000000000000000]
 The result on [X1,X2] is:      .2000000000000001000000000D+01
 ---------------------------------------------------
 
 [X1,X2] is:
 [      -1.000000000000000,       2.000000000000000]
 The result on [X1,X2] is:      .3000000000000002000000000D+01
 ---------------------------------------------------
 ***************************************************************
 ***************************************************************
 
 ***************************************************************
 ***************************************************************
 ***************************************************************
 ***************************************************************
 
 
 END OF TESTS.
