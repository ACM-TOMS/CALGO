\section{Sample executions of SparsePOP}
\label{sample}

% Skim 5/15/07
Execution of  SparsePOP is illustrated with  examples.  
While SparsePOP can read a POP described in either the GAMS scalar format or 
the SparsePOP format shown in Section \ref{Representation},  there are three ways to
solve a POP  with SparsePOP. 

\subsection{The GAMS scalar format}

% Skim 5/15/07
Consider the POP 
(\ref{Bex314})  in Section \ref{Representation}, and assume that the POP is described in 
the GAMS scalar format in the file example1.gms. %To solve the POP by SparsePOP, 
Execution of SparsePOP
can be done by the following commands in Command window of MATLAB:
\begin{verbatim}
>> param.relaxOrder = 3;
>> sparsePOP('example1.gms',param);
\end{verbatim}
Then,  the following output appears in Command window: 
\begin{verbatim}
SparsePOP 2.00 by H.Waki, S.Kim, M.Kojima, M.Muramatsu and H.Sugimoto
                                                         June 1, 2007

## Computational Results by sparsePOP.m with SeDuMi ##
## Printed by printSolution.m ##
# Problem File Name   = example1.gms
# parameters:
  relaxOrder          = 3   % = param.relaxOrder. 
  sparseSW            = 1   % = param.sparseSW.  
  SeDuMiOutFile       = 0   % = param.SeDuMiOutFile. 
# SDP solved by SeDuMi:
  size of A           = [83,1085]   % = [SDPinfo.rowSize, SDPinfo.colSize]; 
  no of nonzeros in A = 2349  % = SDPinfo.nonzeroInA. 
  no of LP variables  = 50  % = SDPinfo.noOfLPvariables.
  no of FR variables  = 35  % = SDPinfo.noOfFRvariables.
  no of SDP blocks    = 7  % <--- SDPinfo.SDPblock.
  max size SDP block  = 20  % <--- SDPinfo.SDPblock.
  ave.size SDP block  = 1.14e+01  % <--- SDPinfo.SDPblock.
# SeDuMi information:
  SeDuMi.pars.eps     = 1.00e-09  % = param.SeDuMiEpsilon. 
  SeDuMiInfo.numerr   = 0  % = SeDuMiInfo.numerr. 
  SeDuMiInfo.pinf     = 0  % = SeDuMiInfo.pinf. 
  SeDuMiInfo.dinf     = 0  % = SeDuMiInfo.dinf. 
# Approximate optimal value information:
  SDPobjValue         = -7.9550950e+00   % a lower bound for the unknown 
                                         % optimal value obtained by 
                                         % the sparse SDP relaxation. 
  POP.objValue        = -7.9550951e+00  % an approximated optimal value.
  relative obj error  = +1.086e-09  % the relative error in the objective 
                                    % value. 
  POP.absError        = -1.295e-06  % the absolute error in the equality and 
                                    % inequality constraints. 
  POP.scaledError     = -2.642e-08  % the scaled error in equality and 
                                    % inequality constraints. 
# cpu time:
  cpuTime.conversion  =     0.05  % the cpu time for conversion from the POP 
                                  % into an SDP relaxation problem.
  cpuTime.SeDuMi      =     0.27  % the cpu time to solve the SDP relaxation 
                                  % problem by SeDuMi. 
  cpuTime.total       =     0.32  % the total cpu time. 
# Approximate optimal solution information:
  POP.xVect = 
     1:+4.7754773e-01    2:+5.1726097e-08    3:+3.4999999e+00 
\end{verbatim}
% Skim 5/15/07
Here {\sf param} is a structure with optional fields for 
% selecting  certain algorithmic procedures
% Kojima 5/18/07 
various parameters 
  that affect  the performance  of sparsePOP.m. 
% Skim 5/15/07
The fields of {\sf param} are explained in Section \ref{PARAM}, and 
the meaning of other 
% Kojima 5/18/07 
% output data is included 
outputs in Section \ref{mainFunctions}. 

The second input argument {\sf param} in the function  sparsePOP.m  can be omitted as 
\begin{verbatim}
>> sparsePOP('example1.gms');
\end{verbatim}
% Skim 5/15/07
In this case, the default parameters given in the function  defaultParameter.m are 
used. %  when executing sparsePOP.m. 
One of the default parameters is  {\sf param.relaxOrder} $=\omega_{\max} = 1$,
which will 
% Kojima 5/18/07 
% eventually 
provide us with 
an inaccurate approximate solution for example1.gms. 
%as above use the default value for
%{\sf param.relaxOrder} $=\omega_{\max} = 1$, but this results in 
%an inaccurate approximate solution. 

\subsection{The SparsePOP format}

% Skim 5/15/07
Since example1.m contains the description of the SparsePOP format  of the POP (\ref{Bex314}), 
%which is written in the file example1.m. 
the POP (\ref{Bex314}) can be solved by SparsePOP as follows:
\begin{verbatim}
>> [objPoly,ineqPolySys,lbd,ubd] = example1; 
>> param.relaxOrder = 3; 
>> sparsePOP(objPoly,ineqPolySys,lbd,ubd,param);
\end{verbatim}
This gives  the same output as  issuing commands 
\begin{verbatim}
>> param.relaxOrder = 3; 
>> sparsePOP('example1.gms',param)
\end{verbatim}
as previously discussed in Section 4.1.
When the last input argument  {\sf param} 
is omitted, the default values in 
defaultParameter.m are used for the parameters. 
% Skim 5/15/07
If a given POP doesn't have lower and upper bounds on some variable  $x_i$ of the POP,  
assigning -1.0e+10 and 1.0e+10 to {\sf lbd(}$i${\sf )} and {\sf ubd(}$i${\sf )}, respectively,
is necessary. In particular, 
when a 
given POP is unconstrained problem, it is necessary to set {\sf ineqPolySys = []} (the empty set), 
{\sf lbd(}$i${\sf ) = -1.0e+10} and 
{\sf ubd(}$i${\sf )= 1.0e+10} for all $i$.
% Kojima 5/18/07
% to solve with sparsePOP.m. 

% Skim 5/15/07
A simpler way to solve  the POP (\ref{Bex314}) using the 
 file  example1.m in the SparsePOP format  of  the POP (\ref{Bex314}) is: 
\begin{verbatim}
>> param.relaxOrder = 3; 
>> sparsePOP('example1',param);
\end{verbatim}
or
\begin{verbatim}
>> sparsePOP('example1');
\end{verbatim}

% Skim 5/15/07
Executing sparsePOP.m as the last command is especially convenient when we handle a POP 
with varying 
parameters. As an example, consider a minimization of the generalized Rosenbrock 
function 
\begin{eqnarray*}
& & 1+ \sum_{i=1}^n \left(100(x_i-x_{i-1}^2)^2 + (1-x_i)^2 \right). 
\end{eqnarray*}
This function has the minimum $0$ at $\x^1 = (-1,1,1,\ldots,1)^T \in \Real^n$  and 
$\x^2 = (1,1,1,\ldots,1)^T$ $ \in \Real^n$. 
The description in the SparsePOP format  of this problem 
is written in the file Rosenbrock.m whose function declaration line is 
\begin{verbatim}
function [objPoly,ineqPolySys,lbd,ubd] = Rosenbrock(nDim,s);
\end{verbatim}
% Skim 5/15/07 variables
Here {\sf nDim} stands for the variable dimension $n$ of the generalized Rosenbrock function. 
We specify $s=-1$ for the constraint $x_1 \leq 0$, $s=0$ for no constraint, and 
$s=1$ for the constraint $x_1 \geq 0$. The commands to solve
the problem of $n=60$ subject to $x_1 \leq 0$ are
\begin{verbatim}
>> param.relaxOrder = 2;
>> sparsePOP('Rosenbrock(60,-1)',param);
\end{verbatim}
And, for the problem of $n=120$ subject to $x_1 \geq 0$,  
\begin{verbatim}
>> param.relaxOrder = 2;
>> sparsePOP('Rosenbrock(120,1)',param);
\end{verbatim}

