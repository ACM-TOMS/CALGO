
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- Page automatically generated from latex_to_html converter. -->
<!-- by cc_extract_html, $Id: Chapter_main.html 254 2007-12-19 20:35:19Z mpouget $ -->
<!-- LaTeX source file: './Jet_fitting_3/main.tex' -->
<html lang="en-US"> <head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<link href="../latex_to_html.css" rel="STYLESHEET">
<title>Estimation of Local Differential Properties</title>
</head>
<body bgcolor="white">
<!-- =================================================================== -->

<div class="NavTop"><hr>
  
  <strong>Navigation:</strong>
<a href="Chapter_main.html">Up</a>,
  <a href="../contents.html">Table of Contents</A>,&nbsp;
  <a href="../packages.html">Package Overview</a>,&nbsp;
  <a href="../biblio.html">Bibliography</a>,&nbsp;
  <a href="../manual_index.html">Index</a>,&nbsp;
  <a href="../title.html">Title Page</a>
  <hr></div>
<a name="Chapter_1"></a>
  
    

  <A NAME="chap:Jet_fitting_3"></A><h1>Chapter 1<BR>Estimation of Local Differential Properties</h1>

  
    

<EM>Marc Pouget  and Fr&eacute;d&eacute;ric Cazals</EM><BR>


<P>

<CENTER> <img border=0 src="./david-dirmaxkmin-white-back.jpg" width=400>
</CENTER>

<B>Figure 1.1:&nbsp;&nbsp;</B>Principal directions associated with <MATH><I>k<SUB>max</SUB></I></MATH> scaled by <MATH><I>k<SUB>min</SUB></I></MATH>.
<A NAME="fig:jet3:fig-david"></A>
<P>

This package allows the estimation of local differential quantities of
  a surface from a point sample, given either as a mesh or as point
  cloud.
<P>

Note that this package needs the third party libraries
Lapack and Blas to be installed to compile
the example code.
<P>

<a name="Section_1.1"></a>
        
<A NAME="sec:intro"></A><h2>1.1&nbsp;&nbsp;&nbsp;Introduction</h2>
<P>

<h3>1.1.1&nbsp;&nbsp;&nbsp;Overview</h3>
<P>

Consider a sampled smooth surface, and assume we are given a
collection of points <MATH><I>P</I></MATH> about a given sample <MATH><I>p</I></MATH>. We aim at
estimating the differential properties up to any fixed order of the
surface at point <MATH><I>p</I></MATH> from the point set <MATH><I>P<SUP>+</SUP> = P <IMG BORDER=0 WIDTH=9 HEIGHT=11 ALIGN=BOTTOM SRC="cc_cup.gif"> { p}</I></MATH>  -  we
denote <MATH><I>N= <IMG BORDER=0 WIDTH=2 HEIGHT=29 ALIGN=MIDDLE SRC="cc_mid.gif"> P<SUP>+</SUP> <IMG BORDER=0 WIDTH=2 HEIGHT=29 ALIGN=MIDDLE SRC="cc_mid.gif"> </I></MATH>. More precisely, first order properties
correspond to the normal or the tangent plane; second order properties
provide the principal curvatures and directions, third order
properties provide the directional derivatives of the principal
curvatures along the curvature lines, etc.  Most of the time,
estimating first and second order differential quantities is
sufficient.  However, some applications involving shape analysis
require estimating third and fourth order differential quantities.
Many different estimators have been proposed in the vast literature of
applied geometry [<A HREF="../biblio.html#Biblio_cgal:p-smrqt-01">cgal:p-smrqt-01</A>] (section 3, page 7), and all
of them need to define a neighborhood around the point at which the
estimation is computed.  Our method relies on smooth differential
geometry calculations, carried out on smooth objects <I>fitted</I> from
the sample points. 
Datasets amenable to such a processing are naturally unstructured
point clouds, as well as meshes  - whose topological information may
be discarded.
<P>

Estimating differential properties from discrete date always raises a
philosophical issue.
On one hand, estimating differential quantities subsumes a smooth
surface does exist.
In this spirit one wishes to recover its differential
properties, so that any estimation method must come with an
asymptotic convergence analysis of the results returned. For the
method developed in this C<SMALL>GAL</SMALL> package, the
interested will find such an analysis in
[<A HREF="../biblio.html#Biblio_cgal:cp-edqpf-05">cgal:cp-edqpf-05</A>], (Theorem 3) -  it should be stressed 
the error bounds proved therein are optimal.
<P>

On the other hand, any estimation method may be applied to arbitrarily
data  - surface unknown, surface piecewise smooth etc. In such a case,
no analysis can be carried out, and it is up to the users to check the
results match their needs.
<P>

Unlike most of the C<SMALL>GAL</SMALL> packages, this package uses approximation
methods and is not intended to provide an exact canonical result in
any sense. This is why internal computations are performed with a
number type possibly different from that of the input data, even if
for convenience the results are returned with this original number
type. A reasonable choice for this internal number type is for example
the <I>double</I> type.
<P>

<h3>1.1.2&nbsp;&nbsp;&nbsp;Smooth Surfaces, <MATH><I>d</I></MATH>-Jets and the Monge Form</h3>
<P>

To present the method, we shall need the following notions. Consider a
smooth surface.  About one of its points, consider a coordinate system
whose <MATH><I>z</I></MATH>-axis does not belong to the tangent space. In such a frame,
the surface can locally be written as the graph of a bivariate
function. Letting <MATH><I>h.o.t.</I></MATH> stand for <I>higher order terms</I>, one
has&nbsp;:
<P ALIGN=CENTER>
<MATH><I>
z(x,y)=J<SUB>B,d</SUB>(x,y) + h.o.t.  ; &nbsp;&nbsp;J<SUB>B,d</SUB>(x,y)= <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC="cc_big_sum.gif"> <SUB>k=0</SUB><SUP>k=d</SUP>( <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC="cc_big_sum.gif"> <SUB>i=0</SUB><SUP>i=k</SUP>
(B<SUB>k-i,i</SUB>x<SUP>k-i</SUP>y<SUP>i</SUP>)/(i!(k-i)!)).
</I></MATH>
<P>

The degree <MATH><I>d</I></MATH> polynomial <MATH><I>J<SUB>B,d</SUB></I></MATH> is the Taylor expansion of the
function <MATH><I>z</I></MATH>, and is called its <I><MATH><I>d</I></MATH>-jet</I>. Notice that a <MATH><I>d</I></MATH>-jet contains
<MATH><I>N<SUB>d</SUB>=(d+1)(d+2)/2</I></MATH> coefficients.
<P>

Recall that an umbilical point of a surface  -  or umbilic for short,
is a point where both principal curvatures are identical.  At any
point of the surface which is not an umbilic, principal directions
<MATH><I>d<SUB>1</SUB>, d<SUB>2</SUB></I></MATH> are well defined, and these (non oriented) directions
together with the normal vector <MATH><I>n</I></MATH> define two direct orthonormal
frames. If <MATH><I>v<SUB>1</SUB></I></MATH> is a unit vector of direction <MATH><I>d<SUB>1</SUB></I></MATH>, there exists a
unique unit vector <MATH><I>v<SUB>2</SUB></I></MATH> so that <MATH><I>(v<SUB>1</SUB>,v<SUB>2</SUB>,n)</I></MATH> is direct; and the
other possible frame is <MATH><I>(-v<SUB>1</SUB>,-v<SUB>2</SUB>,n)</I></MATH>.  Both these coordinate
systems are known as the <I>Monge coordinate systems</I>. In both these
systems, the surface is said to be given in the Monge form and its jet
has the following canonical form&nbsp;:
<P>

<P ALIGN=CENTER>
<MATH><I>
  <TABLE>
  <TR>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
<A NAME="eq:monge"></A>
z(x,y) =  
    </TD>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
(1)/(2)(k<SUB>1</SUB>x<SUP>2</SUP> + k<SUB>2</SUB>y<SUP>2</SUP>)+
	(1)/(6)(b<SUB>0</SUB>x<SUP>3</SUP>+3b<SUB>1</SUB>x<SUP>2</SUP>y+3b<SUB>2</SUB>xy<SUP>2</SUP>+b<SUB>3</SUB>y<SUP>3</SUP>) 
    </TD>
  </TR>
  <TR>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>

    </TD>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
+(1)/(24)(c<SUB>0</SUB>x<SUP>4</SUP>+4c<SUB>1</SUB>x<SUP>3</SUP>y+6c<SUB>2</SUB>x<SUP>2</SUP>y<SUP>2</SUP>+4c<SUB>3</SUB>xy<SUP>3</SUP>+c<SUB>4</SUB>y<SUP>4</SUP>) + h.o.t.

    </TD>
  </TR>
</TABLE>
</I></MATH>
<P>

The coefficients <MATH><I>k<SUB>1</SUB>, k<SUB>2</SUB></I></MATH> are the principal curvatures,
<MATH><I>b<SUB>0</SUB>,b<SUB>3</SUB></I></MATH> are the directional derivatives of <MATH><I>k<SUB>1</SUB>,k<SUB>2</SUB></I></MATH> along their
respective curvature line, while <MATH><I>b<SUB>1</SUB>,b<SUB>2</SUB></I></MATH> are the directional
derivatives of <MATH><I>k<SUB>1</SUB>,k<SUB>2</SUB></I></MATH> along the other curvature lines.
<P>

The Monge coordinate system can be computed from any <MATH><I>d</I></MATH>-jet (<MATH><I>d <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif" ALT="greater or equal"> 2</I></MATH>), and so are the Monge coefficients. These informations
characterize the local geometry of the surface in a canonical way, and
are the quantities returned by our algorithm.
<P>

<h3>1.1.3&nbsp;&nbsp;&nbsp;Algorithm</h3>

Based on the above concepts, the algorithm consists of 4 steps.
<OL>
<LI>We perform a Principal Component Analysis (PCA) on <MATH><I>P<SUP>+</SUP></I></MATH>. This
analysis outputs three orthonormal eigenvectors and the associated
eigenvalues.  The fitting basis consists of these three vectors so
that the vector associated to the smallest eigenvalue is the last
vector of the basis. (Indeed, if the surface is well sampled, one
expects the PCA to provide one small and two large eigenvalues, the
eigenvector associated to the small one approximating the normal
vector.)
<LI>We perform a change of coordinates to move the samples into the
coordinate system of the fitting basis and with origin the point <MATH><I>p</I></MATH>
at which the estimation is sought. We then resort to polynomial
fitting, so as to either interpolate or approximate the <MATH><I>d</I></MATH>-jet of the
surface in this coordinate system. This bivariate polynomial
approximation reduces to linear algebra operations.
<LI>From the fitted <MATH><I>d</I></MATH>-jet, we compute the Monge basis <MATH><I>(d<SUB>1</SUB>,d<SUB>2</SUB>,n)</I></MATH>.
<LI>Finally, we compute the Monge coefficients : <MATH><I>k<SUB>i</SUB>, b<SUB>i</SUB>, c<SUB>i</SUB></I></MATH>.
</OL>
<P>

Further details can be found in section <A HREF="Chapter_main.html#sec:details">1.4</A> and in
[<A HREF="../biblio.html#Biblio_cgal:cp-edqpf-05">cgal:cp-edqpf-05</A>] (section 6).
<P>

<A NAME="sec:deg-cases"></A>
<h3>1.1.4&nbsp;&nbsp;&nbsp;Degenerate Cases</h3>
<P>

As usual, the  fitting procedure may run into (almost) degenerate
cases:
<UL>
<LI>Due to poor sampling, the PCA used to determine a rough normal
  vector may not be good. The nearer this direction to the tangent
  plane the worse the estimation.
<P>

<LI>As observed in [<A HREF="../biblio.html#Biblio_cgal:cp-edqpf-05">cgal:cp-edqpf-05</A>] (section 3.1), the
  interpolating problem is not <I>poised</I> if the points project,
  into the fitting frame, onto an algebraic curve of degree <MATH><I>d</I></MATH>. More
  generally, the problem is ill poised if the condition number is too
  large.
</UL>
In these cases, even if a result is provided, the estimation may not
be relevant. To inform the user of these issues, we provide the PCA
results and the condition number of the fitting. In any case, it is up
to the user to judge if the result meets its need.
<P>

<a name="Section_1.2"></a>
        
<h2>1.2&nbsp;&nbsp;&nbsp;Software Design</h2>
<P>

<h3>1.2.1&nbsp;&nbsp;&nbsp;Options and Interface Specifications</h3>
<P>

The fitting strategy performed by the class
<I><A HREF="../Jet_fitting_3_ref/Class_Monge_via_jet_fitting.html#Cross_link_anchor_4">Monge_via_jet_fitting</A></I> requires the following parameters:
<UL>
<LI>the degree <MATH><I>d</I></MATH> of the fitted polynomial (<MATH><I>d  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif" ALT="greater or equal"> 1</I></MATH>),
<LI>the degree <MATH><I>d'</I></MATH> of the Monge coefficients sought, with <MATH><I>1  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> d'  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> </I></MATH>min<MATH><I>(d,4) </I></MATH>,
<LI>a range of <MATH><I>N</I></MATH> input points on the surface, with the precondition that
<MATH><I>N  <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_geq.gif" ALT="greater or equal"> N<SUB>d</SUB> = (d+1)(d+2)/2</I></MATH>. Note that if <MATH><I>N=N<SUB>d</SUB></I></MATH>, interpolation
is performed; and if <MATH><I>N &gt;N<SUB>d</SUB></I></MATH>, approximation is used.
</UL>
<P>

<h3>1.2.2&nbsp;&nbsp;&nbsp;Output</h3>
<P>

As explained in Section <A HREF="Chapter_main.html#sec:intro">1.1</A>, the output consists of a
coordinate system, the Monge basis, together with the Monge
coefficients which are stored in the <I>Monge_form</I> class. In
addition, more information on the computational issues are stored in
the <I><A HREF="../Jet_fitting_3_ref/Class_Monge_via_jet_fitting.html#Cross_link_anchor_4">Monge_via_jet_fitting</A></I> class.
<P>

The <I>Monge_form</I> class provides the following information.
<P>

<UL>
<LI>Origin. This is the point on the fitted polynomial surface
where the differential quantities have been computed. In the
approximation case, it differs from the input point <MATH><I>p</I></MATH>&nbsp;: it is the
projection of <MATH><I>p</I></MATH> onto the fitted surface following the <MATH><I>z</I></MATH>-direction
of the fitting basis.
<P>

<LI>Monge Basis. The Monge basis <MATH><I>(d<SUB>1</SUB>,d<SUB>2</SUB>,n)</I></MATH> is orthonormal
direct, and the maximal, minimal curvatures are defined wrt this
basis. If the user has a predefined normal <MATH><I>n<SUB>0</SUB></I></MATH> (e.g. the sample
points come from an oriented mesh) then if <MATH><I>n<SUB>0</SUB> . n &gt;0</I></MATH> then max-min
is correct; if not, i.e. <MATH><I>n<SUB>0</SUB> . n &lt;0</I></MATH>, the user should switch to the
orthonormal direct basis <MATH><I>(d<SUB>1</SUB>',d<SUB>2</SUB>',n')=(d<SUB>2</SUB>,d<SUB>1</SUB>,-n)</I></MATH> with the
maximal curvature <MATH><I>k<SUB>1</SUB>'=-k<SUB>2</SUB></I></MATH> and the minimal curvature
<MATH><I>k<SUB>2</SUB>'=-k<SUB>1</SUB></I></MATH>. If <MATH><I>n<SUB>0</SUB> . n =0</I></MATH> or is small, the orientation of the
surface is clearly ill-defined, and the user may proof-check the
samples used to comply with its predefined normal.
<P>

<LI>Monge Coefficients.
The coefficient of the Monge form is <MATH><I>(k<SUB>1</SUB>, k<SUB>2</SUB> ( <IMG BORDER=0 WIDTH=11 HEIGHT=25 ALIGN=MIDDLE SRC="cc_leq.gif"> k<SUB>1</SUB>),
b<SUB>0</SUB>, b<SUB>1</SUB>, b<SUB>2</SUB>, b<SUB>3</SUB>, c<SUB>0</SUB>, c<SUB>1</SUB>, c<SUB>2</SUB>, c<SUB>3</SUB>, c<SUB>4</SUB>)</I></MATH> for <MATH><I>d' = 4</I></MATH>.
<P>

</UL>
<P>

In addition, the class <I><A HREF="../Jet_fitting_3_ref/Class_Monge_via_jet_fitting.html#Cross_link_anchor_4">Monge_via_jet_fitting</A></I> stores 
<UL>
<LI>the condition number of the fitting system,
<LI>the coordinate system of the PCA (in which the fitting is performed).
</UL>
<P>

<h3>1.2.3&nbsp;&nbsp;&nbsp;Template Parameters</h3>
<P>

<h4>Template parameter <TT>DataKernel</TT></h4>
<P>

This concept provides the types for the input sample points, together
with <MATH><I>3d</I></MATH> vectors and a number type. It is used as template for the
classe <I><A HREF="../Jet_fitting_3_ref/Class_Monge_via_jet_fitting.html#Cross_link_anchor_4">Monge_via_jet_fitting</A>&lt;<A HREF="../Jet_fitting_3_ref/Concept_DataKernel.html#Cross_link_anchor_0">DataKernel</A>, <A HREF="../Jet_fitting_3_ref/Concept_LocalKernel.html#Cross_link_anchor_2">LocalKernel</A> =   Cartesian&lt;double&gt;, <A HREF="../Jet_fitting_3_ref/Concept_SvdTraits.html#Cross_link_anchor_5">SvdTraits</A> = lapack_svd&gt;</I> . Typically, one can use
<I>CGAL::Cartesian&lt;double&gt;</I>.
<P>

<h4>Template parameter <TT>LocalKernel</TT></h4>

This is a parameter of the class 
<I><A HREF="../Jet_fitting_3_ref/Class_Monge_via_jet_fitting.html#Cross_link_anchor_4">Monge_via_jet_fitting</A>&lt;<A HREF="../Jet_fitting_3_ref/Concept_DataKernel.html#Cross_link_anchor_0">DataKernel</A>, <A HREF="../Jet_fitting_3_ref/Concept_LocalKernel.html#Cross_link_anchor_2">LocalKernel</A> = Cartesian&lt;double&gt;, <A HREF="../Jet_fitting_3_ref/Concept_SvdTraits.html#Cross_link_anchor_5">SvdTraits</A> = lapack_svd&gt;</I>. 
This concept defines the vector and number types used for local
computations and to store the PCA basis data.
<P>

Input points of type
<I><A HREF="../Jet_fitting_3_ref/Concept_DataKernel.html#Cross_link_anchor_0">DataKernel</A>::Point_3</I> are converted to
<I><A HREF="../Jet_fitting_3_ref/Concept_LocalKernel.html#Cross_link_anchor_2">LocalKernel</A>::Point_3</I>. For output of the <I>Monge_form</I> class,
these types are converted back to <I>Data_Kernel</I> ones.  Typically,
one can use
<I>CGAL::Cartesian&lt;double&gt;</I> which is the default.
<P>

<h4>Template parameter <TT>SvdTraits</TT></h4>
<P>

This concept provides the number, vector and matrix types for algebra
operations required by the fitting method in
<I><A HREF="../Jet_fitting_3_ref/Class_Monge_via_jet_fitting.html#Cross_link_anchor_4">Monge_via_jet_fitting</A>&lt;<A HREF="../Jet_fitting_3_ref/Concept_DataKernel.html#Cross_link_anchor_0">DataKernel</A>, <A HREF="../Jet_fitting_3_ref/Concept_LocalKernel.html#Cross_link_anchor_2">LocalKernel</A> = Cartesian&lt;double&gt;, <A HREF="../Jet_fitting_3_ref/Concept_SvdTraits.html#Cross_link_anchor_5">SvdTraits</A> = lapack_svd&gt;</I> 
. The main method is a linear solver using a singular value decomposition.
<P>

<h4>Compatibility requirements</h4>
<P>

To solve the fitting problem, the sample points are first converted
from the <I><A HREF="../Jet_fitting_3_ref/Concept_DataKernel.html#Cross_link_anchor_0">DataKernel</A></I> to the <I><A HREF="../Jet_fitting_3_ref/Concept_LocalKernel.html#Cross_link_anchor_2">LocalKernel</A></I> (this is done using
the <I>CGAL::Cartesian_converter</I>). Then change of coordinate
systems and linear algebra operations are performed with this
kernel. This implies that the number types <I><A HREF="../Jet_fitting_3_ref/Concept_LocalKernel.html#Cross_link_anchor_2">LocalKernel</A>::FT</I> and
<I><A HREF="../Jet_fitting_3_ref/Concept_SvdTraits.html#Cross_link_anchor_5">SvdTraits</A>::FT</I> must be identical.
Second the Monge basis and coefficients, computed with the
<I><A HREF="../Jet_fitting_3_ref/Concept_LocalKernel.html#Cross_link_anchor_2">LocalKernel</A></I>, are converted back to the <I><A HREF="../Jet_fitting_3_ref/Concept_DataKernel.html#Cross_link_anchor_0">DataKernel</A></I> 
(this is done using the <I>CGAL::Cartesian_converter</I> and the
<I>CGAL::NT_converter</I>).
<P>

<a name="Section_1.3"></a>
        
<h2>1.3&nbsp;&nbsp;&nbsp;Examples</h2>
<P>

<h3>1.3.1&nbsp;&nbsp;&nbsp;Single Estimation about a Point of a Point Cloud</h3>
<P>

The first example illustrates the computation of the local
differential quantities from a set of points given in a text file as
input. The first point of the list is the one at which the computation
is performed. The user has to specify a file for the input points and
the degrees <MATH><I>d</I></MATH> and <MATH><I>d'</I></MATH>.
<P>

<h3>1.3.2&nbsp;&nbsp;&nbsp;On a Mesh</h3>

The second example (cf Mesh_estimation.cpp in the example directory)
illustrates the computation of local differential quantities for all
vertices of a given mesh. The neighborhood of a given vertex is
computed using rings on the triangulation. Results are twofold:
<UL>
<LI>a human readable text file featuring the <I>Monge_form</I> and
  numerical informations on the computation&nbsp;: condition number and the
  PCA basis;
<LI>another text file which may be visualised with the demo program
  introspect-qt (experimental C<SMALL>GAL</SMALL> package) displaying the Monge
  basis at each vertex of the mesh.
</UL>
<P>

Figs.
<A HREF="Chapter_main.html#fig:jet3:fig-david">1.1</A> and
<A HREF="Chapter_main.html#fig:jet3:fig-elliptic-paraboloid">1.2</A>
provide illustrations of principal directions of curvature.
<P>

<CENTER> <img border=0 src="./ppal_curv_poly2x2+y2.jpg" width=600>
</CENTER>

<B>Figure 1.2:&nbsp;&nbsp;</B>Principal directions of curvature and normals at vertices of a mesh of the
 graph of the function <MATH><I>f(x,y)=2x<SUP>2</SUP>+y<SUP>2</SUP></I></MATH>.
<A NAME="fig:jet3:fig-elliptic-paraboloid"></A>
<P>

<BR>

<div class="AdvancedBlock">
  <table><tr><td valign="top">
  <img border="0" src="cc_advanced_begin1.gif" alt="begin of advanced section">
  </td><td valign="top">
  <em class="AdvancedBlockLabel">&nbsp;advanced&nbsp;</em>
  </td><td valign="top">
  <img border="0" src="cc_advanced_begin2.gif" alt="begin of advanced section">
  </td></tr></table>
 

  


<a name="Section_1.4"></a>
        
<h2>1.4&nbsp;&nbsp;&nbsp;Mathematical and Algorithmic Details</h2>


<A NAME="sec:details"></A>
In this Section, we detail the mathematics involved, in order to
justify the design choices made.
To begin with, observe the fitting problem involves three relevant
direct orthonormal basis: the world-basis <MATH><I>(w<SUB>x</SUB>,w<SUB>y</SUB>,w<SUB>z</SUB>)</I></MATH>, the
fitting-basis <MATH><I>(f<SUB>x</SUB>,f<SUB>y</SUB>,f<SUB>z</SUB>)</I></MATH>, the Monge basis <MATH><I>(d<SUB>1</SUB>,d<SUB>2</SUB>,n)</I></MATH>.
<P>

<A NAME="fig:jet_fitting_basis"></A>
<P>

<CENTER>
<img border=0 src="./jet_fitting_basis.gif" width=600>
</CENTER>

<B>Figure 1.3:&nbsp;&nbsp;</B>The three bases involved in the estimation.
<P>

<h3>1.4.1&nbsp;&nbsp;&nbsp;Computing a Basis for the Fitting</h3>
<P>

<B>Input : samples<BR>

Output : fitting-basis</B>
<P>

Performing a PCA requires diagonalizing a symmetric matrix.  This
analysis gives an orthonormal basis whose <MATH><I>z</I></MATH>-axis is provided by the
eigenvector associated to the smallest eigenvalue.<A HREF="#Footnote_1"><SUP>1</SUP></A> Note one may have
to swap the orientation of a vector to get a direct basis.
<P>

Let us denote <MATH><I>P<SUB>W <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> F</SUB></I></MATH> the matrix that changes coordinates from the
world-basis <MATH><I>(w<SUB>x</SUB>,w<SUB>y</SUB>,w<SUB>z</SUB>)</I></MATH> to the fitting-basis <MATH><I>(f<SUB>x</SUB>,f<SUB>y</SUB>,f<SUB>z</SUB>)</I></MATH>. The
rows of <MATH><I>P<SUB>W <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> F</SUB></I></MATH> are the coordinates of the vectors
<MATH><I>(f<SUB>x</SUB>,f<SUB>y</SUB>,f<SUB>z</SUB>)</I></MATH> in the world-basis. This matrix represents a
orthogonal transformation hence its inverse is its transpose. To obtain
the coordinates of a point in the fitting-basis from the coordinates
in the world-basis, one has to multiply by <MATH><I> P<SUB>W <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> F</SUB></I></MATH>.
<P>

As mentioned above, the eigenvalues are returned, from which the
sampling quality can be assessed. For a good sampling, the eigenvector
associated to the smallest eigenvalue should roughly give the normal
direction.
<P>

<A NAME="sec:solving"></A>
<h3>1.4.2&nbsp;&nbsp;&nbsp;Solving the Interpolation / Approximation Problem</h3>
<P>

<B>Input : samples, fitting-basis<BR>

Output : coefficients <MATH><I>A<SUB>i,j</SUB></I></MATH>
of the bivariate fitted polynomial in the fitting-basis </B>
<P>

Computations are done in the fitting-basis and the origin is the point
<MATH><I>p</I></MATH>. First, one has to transform coordinates of sample points with a
translation (<MATH><I>-p</I></MATH>) and multiplication by <MATH><I> P<SUB>W <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> F</SUB></I></MATH>.
<P>

The fitting process consists of finding the coefficients
<MATH><I>A<SUB>i,j</SUB></I></MATH> of the degree <MATH><I>d</I></MATH> polynomial 
<P ALIGN=CENTER>
<MATH><I>
<A NAME="eq-answer"></A>
J<SUB>A,d</SUB>=  <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC="cc_big_sum.gif"> <SUB>k=0</SUB><SUP>k=d</SUP>( <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC="cc_big_sum.gif"> <SUB>i=0</SUB><SUP>i=k</SUP>
(A<SUB>k-i,i</SUB>x<SUP>k-i</SUP>y<SUP>i</SUP>)/(i!(k-i)!)).
</I></MATH>
<P>

Denote <MATH><I>p<SUB>i</SUB>=(x<SUB>i</SUB>,y<SUB>i</SUB>,z<SUB>i</SUB>),  i=1,..., N</I></MATH> the coordinates of the
sample points of <MATH><I>P<SUP>+</SUP></I></MATH>.
For interpolation the linear equations to solve are <MATH><I>A(x<SUB>i</SUB>,y<SUB>i</SUB>)=z<SUB>i</SUB>  i=1,...,N</I></MATH>, and for approximation one has to minimize <MATH><I> <IMG BORDER=0 WIDTH=13 HEIGHT=24 ALIGN=MIDDLE SRC="cc_sum.gif"> <SUB>i=1</SUB><SUP>N</SUP>
(A(x<SUB>i</SUB>,y<SUB>i</SUB>)-z<SUB>i</SUB>)<SUP>2</SUP></I></MATH>. The linear algebra formulation of the problem is
given by
<P ALIGN=CENTER>
<MATH><I>
  <TABLE>
  <TR>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
<A NAME="eq:fit-linalg"></A>
 A =  
    </TD>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
(A<SUB>0,0</SUB>, A<SUB>1,0</SUB>,A<SUB>0,1</SUB>, ..., A<SUB>0,d</SUB>)<SUP>T</SUP> 
    </TD>
  </TR>
  <TR>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
Z=  
    </TD>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
(z<SUB>1</SUB>, z<SUB>2</SUB>,..., z<SUB>N</SUB>)<SUP>T</SUP> 
    </TD>
  </TR>
  <TR>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
M=  
    </TD>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
(1,x<SUB>i</SUB>, y<SUB>i</SUB>, (x<SUB>i</SUB><SUP>2</SUP>)/(2),...,
 (x<SUB>i</SUB>y<SUB>i</SUB><SUP>d-1</SUP>)/((d-1)!), (y<SUB>i</SUB><SUP>d</SUP>)/(d!))<SUB>i=1,...,N</SUB>
    </TD>
  </TR>
</TABLE>
</I></MATH>
<P>

The equations for interpolation become <MATH><I>MA=Z</I></MATH>. For approximation, the
system <MATH><I>MA=Z</I></MATH> is solved in the least square sense, i.e. one seeks the
vector <MATH><I>A</I></MATH> such that <MATH><I>A = </I></MATH>arg<MATH><I></I></MATH>min<MATH><I><SUB>A</SUB> ||MA-Z||<SUB>2</SUB></I></MATH>.
<P>

In any case, there is a preconditioning of the matrix <MATH><I>M</I></MATH> so as to
improve the condition number. Assuming the <MATH><I>{x<SUB>i</SUB>}</I></MATH>, <MATH><I>{y<SUB>i</SUB>}</I></MATH> are of
order <MATH><I>h</I></MATH>, the pre-conditioning consists of performing a column
scaling by dividing each monomial <MATH><I>x<SUB>i</SUB><SUP>k</SUP>y<SUB>i</SUB><SUP>l</SUP></I></MATH> by <MATH><I>h<SUP>k+l</SUP></I></MATH>  -  refer
to Eq. (<A HREF="Chapter_main.html#eq:fit-linalg">1.4.2</A>). Practically, the parameter <MATH><I>h</I></MATH> is chosen
as the mean value of the <MATH><I>{x<SUB>i</SUB>}</I></MATH> and <MATH><I>{y<SUB>i</SUB>}</I></MATH>. In other words, the
new system is <MATH><I>M'Y=(MD<SUP>-1</SUP>)(DA)=Z</I></MATH> with <MATH><I>D</I></MATH> the diagonal matrix
<MATH><I>D=(1,h,h,h<SUP>2</SUP>,...,h<SUP>d</SUP>,h<SUP>d</SUP>)</I></MATH>, so that the solution <MATH><I>A</I></MATH> of the
original system is <MATH><I>A=D<SUP>-1</SUP>Y</I></MATH>.
<P>

There is always a single solution since for under constrained systems
we also minimize <MATH><I>||A||<SUB>2</SUB></I></MATH>.  The method uses a singular value
decomposition of the <MATH><I>N &times; N<SUB>d</SUB></I></MATH> matrix <MATH><I>M= U S V<SUP>T</SUP></I></MATH>, where <MATH><I>U</I></MATH> is a
<MATH><I>N  &times; N</I></MATH> orthogonal matrix, <MATH><I>V</I></MATH> is a <MATH><I>N<SUB>d</SUB>  &times; N<SUB>d</SUB></I></MATH> orthogonal
matrix and <MATH><I>S</I></MATH> is a <MATH><I>N &times; N<SUB>d</SUB></I></MATH> matrix with the singular values on
its diagonal. Denote <MATH><I>r</I></MATH> the rank of <MATH><I>M</I></MATH>, we can decompose
<MATH><I>S= ( 
  <TABLE>
  <TR>
    <TD VALIGN=TOP ALIGN=CENTER NOWRAP>
D<SUB>r</SUB> 
    </TD>
    <TD VALIGN=TOP ALIGN=CENTER NOWRAP>
0<SUB>r, N<SUB>d</SUB>-r</SUB>
    </TD>
  </TR>
  <TR>
    <TD VALIGN=TOP ALIGN=CENTER NOWRAP>
0<SUB>N-r, r</SUB> 
    </TD>
    <TD VALIGN=TOP ALIGN=CENTER NOWRAP>
0<SUB>N-r, N<SUB>d</SUB>-r</SUB>

    </TD>
  </TR>
</TABLE>
 
).
</I></MATH>
The number <MATH><I>r</I></MATH>, which is the number of non zero singular values, is
strictly lower than <MATH><I>N<SUB>d</SUB></I></MATH> if the system is under constrained. In any
case, the unique solution which minimize <MATH><I>||A||<SUB>2</SUB></I></MATH> is given by&nbsp;:
<P ALIGN=CENTER>
<MATH><I>
A= V
( 
  <TABLE>
  <TR>
    <TD VALIGN=TOP ALIGN=CENTER NOWRAP>
D<SUB>r</SUB><SUP>-1</SUP> 
    </TD>
    <TD VALIGN=TOP ALIGN=CENTER NOWRAP>
0<SUB>N<SUB>d</SUB>-r, r</SUB>
    </TD>
  </TR>
  <TR>
    <TD VALIGN=TOP ALIGN=CENTER NOWRAP>
0<SUB>r, N-r</SUB> 
    </TD>
    <TD VALIGN=TOP ALIGN=CENTER NOWRAP>
0<SUB>N<SUB>d</SUB>-r, N-r</SUB>

    </TD>
  </TR>
</TABLE>
 
)
 U<SUP>T</SUP>Z.
</I></MATH>
<P>

One can provide the condition number of the matrix <MATH><I>M</I></MATH> (after
preconditioning) which is the ratio of the maximal and the minimal
singular values. It is infinite if the system is under constrained,
that is the smallest singular value is zero.
<P>

<b>Implementation details.</b>

We assume a <I>solve</I> function is provided by the traits
<I><A HREF="../Jet_fitting_3_ref/Concept_SvdTraits.html#Cross_link_anchor_5">SvdTraits</A></I>. This function solves the system MX=B (in the least square sense
if M is not square) using a Singular Value Decomposition and gives the
condition number of M.
<P>

<BR>

<BR>

Remark: as an alternative, other methods may be used to solve the
system. A <MATH><I>QR</I></MATH> decomposition can be substituted to the <MATH><I>SVD</I></MATH>. One can
also use the normal equation <MATH><I>M<SUP>T</SUP>MX=MTB</I></MATH> and apply methods for square
systems such as <MATH><I>LU</I></MATH>, <MATH><I>QR</I></MATH> or Cholesky since <MATH><I>M<SUP>T</SUP>M</I></MATH> is symmetric
definite positive when <MATH><I>M</I></MATH> has full rank. 
The advantages of the <MATH><I>SVD</I></MATH>
is that it works directly on the rectangular system and gives the
condition number of the system. For more on these alternatives, see
[<A HREF="../biblio.html#Biblio_gl-mc-83">gl-mc-83</A>] (Chap. 5).
<P>

<h3>1.4.3&nbsp;&nbsp;&nbsp;Principal  Curvature / Directions</h3>
<P>

<B>Input : coefficients of the fit <MATH><I>A<SUB>i,j</SUB></I></MATH>, 
fitting-basis<BR>

Output : Monge basis wrt fitting-basis and world-basis
</B>
<P>

In the fitting basis, we have determined a height function expressed
by Eq. (<A HREF="Chapter_main.html#eq-answer">1.4.2</A>). Computations are done in the fitting-basis.
The partial derivatives, evaluated at <MATH><I>(x,y)=(0,0)</I></MATH>, of the fitted
polynomial <MATH><I>J<SUB>A,d</SUB>(x,y)</I></MATH> are
<MATH><I>A<SUB>i,j</SUB>=( <IMG BORDER=0 WIDTH=8 HEIGHT=13 ALIGN=BOTTOM SRC="cc_partial.gif"> <SUP>i+j</SUP>J<SUB>A,d</SUB>)/( <IMG BORDER=0 WIDTH=8 HEIGHT=13 ALIGN=BOTTOM SRC="cc_partial.gif"> <SUP>i</SUP>x  <IMG BORDER=0 WIDTH=8 HEIGHT=13 ALIGN=BOTTOM SRC="cc_partial.gif"> <SUP>j</SUP>y)</I></MATH>
Expanding Eq. (<A HREF="Chapter_main.html#eq-answer">1.4.2</A>) yields:
<P ALIGN=CENTER>
<MATH><I>
  <TABLE>
  <TR>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
J<SUB>A,d</SUB>(x,y)
    </TD>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
=
A<SUB>0,0</SUB>+A<SUB>1,0</SUB>x+A<SUB>0,1</SUB>y+(1)/(2)(A<SUB>2,0</SUB>x<SUP>2</SUP>+2A<SUB>1,1</SUB>xy+A<SUB>0,2</SUB>y<SUP>2</SUP>) 
+ (1)/(6)(A<SUB>3,0</SUB>x<SUP>3</SUP>+3A<SUB>2,1</SUB>x<SUP>2</SUP>y+...)+ ...
    </TD>
  </TR>
</TABLE>
</I></MATH>
<P>

<UL>
<LI>The origin, that is the point of the fitted surface where the
  estimation is performed, is <MATH><I>(0,0,A<SUB>0,0</SUB>)</I></MATH>. 
<LI>The normal is
  <MATH><I>n=(-A<SUB>1,0</SUB>,-A<SUB>0,1</SUB>,1)/sqrt(A<SUB>1,0</SUB><SUP>2</SUP>+A<SUB>0,1</SUB><SUP>2</SUP>+1)</I></MATH>.
<LI>Curvature related properties are retrieved resorting to
  standard differential calculus [<A HREF="../biblio.html#Biblio_c-dgcs-76">c-dgcs-76</A>] (Chap. 3). More precisely, the
  Weingarten operator <MATH><I>W=-I<SUP>-1</SUP>II</I></MATH> is first computed in the basis of
  the tangent plane <MATH><I>{ (1,0,A<SUB>1,0</SUB>), (0,1,A<SUB>0,1</SUB>) }</I></MATH>. We compute
  an orthonormal basis of the tangent plane using the Gram-Schmidt
  algorithm, and then we compute Weingarten in this basis (applying a
  change of basis with the matrix <MATH><I>W'=P<SUP>-1</SUP>WP</I></MATH>). In this orthonormal
  basis, the matrix of the Weingarten map is symmetric and we
  diagonalize it.  One finally gets the principal curvatures which are
  the eigenvalues of <MATH><I>W</I></MATH>, and the associated principal
  directions. This gives an orthonormal direct basis
  <MATH><I>(d<SUB>1</SUB>,d<SUB>2</SUB>,n)</I></MATH>. Let us denote <MATH><I>P<SUB>F  <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> M</SUB></I></MATH> the matrix to
  change coordinates from the fitting-basis to the Monge basis. Its
  rows are the coordinates of the vectors <MATH><I>(d<SUB>1</SUB>,d<SUB>2</SUB>,n)</I></MATH> in the
  fitting-basis. It is an orthogonal matrix <MATH><I>P<SUB>F  <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> M</SUB><SUP>-1</SUP>=P<SUB>F  <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> M</SUB><SUP>T</SUP></I></MATH>. The Monge basis expressed in the
  world-basis is obtained by multiplying the coordinates of
  <MATH><I>(d<SUB>1</SUB>,d<SUB>2</SUB>,n)</I></MATH> in the fitting-basis by <MATH><I>P<SUB>W <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> F</SUB><SUP>-1</SUP></I></MATH>,
  (the same holds for the origin point which has in addition to be
  translated by <MATH><I>p</I></MATH>, i.e. the coordinates of the origin point are
  <MATH><I>P<SUB>W <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> F</SUB><SUP>-1</SUP> (0,0,A<SUB>0,0</SUB>) +p</I></MATH>.
</UL>
<P>

<h3>1.4.4&nbsp;&nbsp;&nbsp;Computing  Higher Order Monge Coefficients</h3>
<P>

<B>Input : coefficients of the fit, Monge basis wrt fitting-basis (<MATH><I>P<SUB>F
 <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> M</SUB></I></MATH>)<BR>

Output : third and fourth order coefficients of Monge</B>
<P>

We use explicit formula. The implicit equation of the fitted
polynomial surface in the fitting-basis with origin the point
<MATH><I>(0,0,A<SUB>0,0</SUB>)</I></MATH> is <MATH><I>Q=0</I></MATH> with
<P ALIGN=CENTER>
<MATH><I>
Q=-w-A<SUB>0,0</SUB>  + <IMG BORDER=0 WIDTH=19 HEIGHT=29 ALIGN=MIDDLE SRC="cc_big_sum.gif"> <SUB>i,j</SUB>(A<SUB>i,j</SUB>u<SUP>i</SUP>v<SUP>j</SUP>)/(i!j!).
</I></MATH>
<P>

The equation in the Monge basis is obtained by substituting <MATH><I>(u,v,w)</I></MATH>
by <MATH><I>P<SUP>T</SUP><SUB>F <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> M</SUB>(x,y,z)</I></MATH>. Denote <MATH><I>f(x,y,z)=0</I></MATH> this implicit
equation. By definition of the Monge basis, we have locally (at
<MATH><I>(0,0,0)</I></MATH>)
<P ALIGN=CENTER>
<MATH><I>
f(x,y,z)=0  <IMG BORDER=0 WIDTH=13 HEIGHT=11 ALIGN=BOTTOM SRC="cc_uppercase_Leftrightarrow.gif"> z=g(x,y)
</I></MATH>
<P>

and the Taylor expansion of <MATH><I>g</I></MATH> at <MATH><I>(0,0)</I></MATH> are the Monge coefficients
sought.
Let us denote the partial derivatives evaluated at the origin of <MATH><I>f</I></MATH>
and <MATH><I>g</I></MATH> by <MATH><I>f<SUB>i,j,k</SUB>=( <IMG BORDER=0 WIDTH=8 HEIGHT=13 ALIGN=BOTTOM SRC="cc_partial.gif"> <SUP>i+j+k</SUP>f)/( <IMG BORDER=0 WIDTH=8 HEIGHT=13 ALIGN=BOTTOM SRC="cc_partial.gif"> <SUP>i</SUP>x
 <IMG BORDER=0 WIDTH=8 HEIGHT=13 ALIGN=BOTTOM SRC="cc_partial.gif"> <SUP>j</SUP>y  <IMG BORDER=0 WIDTH=8 HEIGHT=13 ALIGN=BOTTOM SRC="cc_partial.gif"> <SUP>k</SUP>z)</I></MATH> and <MATH><I>g<SUB>i,j</SUB>=( <IMG BORDER=0 WIDTH=8 HEIGHT=13 ALIGN=BOTTOM SRC="cc_partial.gif"> <SUP>i+j</SUP>g)/( <IMG BORDER=0 WIDTH=8 HEIGHT=13 ALIGN=BOTTOM SRC="cc_partial.gif"> <SUP>i</SUP>x
 <IMG BORDER=0 WIDTH=8 HEIGHT=13 ALIGN=BOTTOM SRC="cc_partial.gif"> <SUP>j</SUP>y)</I></MATH>. One has <MATH><I>f<SUB>1,0,0</SUB>=f<SUB>0,1,0</SUB>=f<SUB>1,1,0</SUB>=0</I></MATH>,
<MATH><I>g<SUB>0,0</SUB>=g<SUB>1,0</SUB>=g<SUB>0,1</SUB>=g<SUB>1,1</SUB>=0</I></MATH> and <MATH><I>g<SUB>2,0</SUB>=k<SUB>1</SUB></I></MATH>,
<MATH><I>g<SUB>0,2</SUB>=k<SUB>2</SUB></I></MATH>. The partial derivative of order <MATH><I>n</I></MATH> of <MATH><I>f</I></MATH> depends on
the matrix <MATH><I>P<SUB>F <IMG BORDER=0 WIDTH=15 HEIGHT=9 ALIGN=BOTTOM SRC="cc_lowercase_rightarrow.gif"> M</SUB></I></MATH> and the partial derivatives of order
at most <MATH><I>n</I></MATH> of <MATH><I>J<SUB>A,d</SUB></I></MATH>. The third and fourth order coefficients of are
computed with the implicit function theorem. For instance&nbsp;:
<P ALIGN=CENTER>
<MATH><I>
  <TABLE>
  <TR>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>

    </TD>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
b<SUB>0</SUB>=g<SUB>3,0</SUB>=-( f<SUB>3,0,0</SUB> f<SUB>0,0,1</SUB> -3 f<SUB>1,0,1</SUB> f<SUB>2,0,0</SUB> )/(
f<SUB>0,0,1</SUB> <SUP>2</SUP>)

    </TD>
  </TR>
  <TR>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>

    </TD>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
b<SUB>1</SUB>=g<SUB>2,1</SUB>=-(-  f<SUB>0,1,1</SUB>      f<SUB>2,0,0</SUB>    +  f<SUB>2,1,0</SUB>    f<SUB>0,0,1</SUB>  )/(  f<SUB>0,0,1</SUB>    <SUP>2</SUP>)

    </TD>
  </TR>
  <TR>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>

    </TD>
    <TD VALIGN=TOP ALIGN=LEFT NOWRAP>
.... 
    </TD>
  </TR>
</TABLE>
</I></MATH>
<P>

<table><tr><td valign="bottom">
  <img border="0" src="cc_advanced_end1.gif" alt="end of advanced section">
  </td><td valign="bottom">
  <em class="AdvancedBlockLabel">&nbsp;advanced&nbsp;</em>
  </td><td valign="bottom">
  <img border="0" src="cc_advanced_end2.gif" alt="end of advanced section">
  </td></tr></table></div>
<P>

<HR><H3>Footnotes</H3>
<P>

<TABLE><TR><TD VALIGN=TOP>
</TD></TR><TR><TD VALIGN=TOP>
        <A NAME="Footnote_1">&nbsp;<SUP>1</SUP>&nbsp;</A></TD><TD VALIGN=TOP>
Another
  possibility is to choose as z-axis the axis of the world-basis with
  the least angle with the axis determined with the PCA. Then the
  change of basis reduces to a permutation of axis.

</TD></TR></TABLE>
<div class="NavNext"><hr> Next: <a href="../Jet_fitting_3_ref/Chapter_intro.html">Reference Manual</a><hr></div>
    
  <div class="NavBottom"><hr>
  
  <strong>Navigation:</strong>
<a href="../Jet_fitting_3_ref/Chapter_intro.html">Up</a>,
  <a href="../contents.html">Table of Contents</A>,&nbsp;
  <a href="../packages.html">Package Overview</a>,&nbsp;
  <a href="../biblio.html">Bibliography</a>,&nbsp;
  <a href="../manual_index.html">Index</a>,&nbsp;
  <a href="../title.html">Title Page</a>
  <hr></div>

<div class="NavAddress"><hr>
<SMALL><a href=http://www.cgal.org target=_top>CGAL Open Source Project</a>.
Separate Build.
19 December 2007.</SMALL>
<hr></div>
</body>  </html>
