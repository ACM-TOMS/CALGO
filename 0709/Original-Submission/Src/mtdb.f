      PROGRAM ZZMT

C## S T A T U S:
C               SINGLE/DOUBLE CONVERSION: NEEDED (SEE CONVRT).
C
C               IGNORE LINES BEGINNING WITH  "C!!!!" .
C
C               THIS VERSION IS IN   D O U B L E   PRECISION.
C!!!!           THIS VERSION IS IN   S I N G L E   PRECISION.
C
C               SYSTEM  DEPENDENCE:
C               THE CURRENT VERSION INCLUDES CODE FOR:
C
C             THIS VERSION IS FOR  SUN4
C
C>RCS $HEADER: MT.GL,V 2.8 92/01/06 13:49:01 BUCKLEY EXP $
C>RCS $LOG:     MT.GL,V $
C>RCS REVISION 2.8  92/01/06  13:49:01  BUCKLEY
C>RCS MINOR FIX FOR TOMS
C>RCS
C>RCS REVISION 2.7  91/12/16  12:22:49  BUCKLEY
C>RCS MINOR FIX FOR TOMS.
C>RCS
C>RCS REVISION 2.6  91/12/16  12:20:11  BUCKLEY
C>RCS MINOR FIX FOR TOMS.
C>RCS
C>RCS REVISION 2.5  90/10/12  13:40:08  BUCKLEY
C>RCS FIXED GROUPS
C>RCS
C>RCS REVISION 2.4  90/10/10  20:38:31  BUCKLEY
C>RCS FIXED CASE WHERE NO GROUPS AND NO PROLOG PRESENT.
C>RCS
C>RCS REVISION 2.3  90/10/04  13:08:09  BUCKLEY
C>RCS FIXED BRANCH TO 2060 INSIDE IF
C>RCS
C>RCS REVISION 2.2  90/08/29  16:45:33  BUCKLEY
C>RCS FIXED FILE NAME LENGTH FOR INPUT FILE.
C>RCS
C>RCS REVISION 2.1  90/08/05  16:07:41  BUCKLEY
C>RCS FIXED INITIAL FILE READING WHEN FILES NOT PRESENT.
C>RCS
C>RCS REVISION 2.0  90/07/31  11:42:40  BUCKLEY
C>RCS PRETTY WELL READY TO SEND TO TOMS AGAIN.
C>RCS
C>RCS REVISION 1.9.1.4  89/07/01  07:25:33  BUCKLEY
C>RCS PREPARING SUBMITTED VERSION OF MT
C>RCS
C>RCS REVISION 1.9.1.3  89/06/30  21:23:00  BUCKLEY
C>RCS PREPARING SUBMITTED VERSION OF MT
C>RCS
C>RCS REVISION 1.9.1.2  89/06/30  17:14:47  BUCKLEY
C>RCS PREPARING SUBMITTED VERSION OF MT
C>RCS
C>RCS REVISION 1.9.1.1  89/06/30  14:58:25  BUCKLEY
C>RCS PREPARING SUBMITTED VERSION OF MT
C>RCS
C>RCS REVISION 1.9  89/06/30  13:10:09  BUCKLEY
C>RCS PREPARING SUBMITTED VERSION OF MT
C>RCS
C>RCS REVISION 1.6  89/05/21  12:52:59  BUCKLEY
C>RCS MINOR FIXES IN PRNT AND DCOD
C>RCS
C>RCS REVISION 1.5  89/05/20  21:26:29  BUCKLEY
C>RCS TMP
C>RCS
C>RCS REVISION 1.4  89/05/20  21:04:11  BUCKLEY
C>RCS TEMP
C>RCS
C>RCS REVISION 1.3  89/05/18  12:17:16  BUCKLEY
C>RCS FINAL TEST OF MT BEFORE SUBMITTING
C>RCS
C>RCS REVISION 1.2  89/05/15  11:17:38  BUCKLEY
C>RCS INITIAL MT REVISION INTO RCS FORM.
C>RCS
C>RCS REVISION 1.1  89/01/17  16:38:11  BUCKLEY
C>RCS INITIAL REVISION
C>RCS
C
C## D E S C R I P T I O N:   SEE EXTERNAL DESCRIPTION FOR TP.
C## E N T R Y   P O I N T S: THE NATURAL ENTRY ZZMT.
C## S U B R O U T I N E S:
C
C ==> REVISE
C     GENERIC:             ABS   LEN  SQRT  INDEX
C
C     ZZADDP (ZZASET)                      ZZNRM2
C     ZZAFTR                               ZZOPEN (ZZCLSE,ZZOSET)
C    [ZZBASE]                              ZZPRNT (ZZPSET,ZZPGET)
C     ZZBFOR                               ZZPUTG (ZZDEFP)
C    [ZZBSTR]                              ZZPUTP (ZZPDEF)
C    [ZZCNTR]                              ZZRDCH
C    [ZZDATE]                              ZZRDIN
C     ZZDCOD (ZZDSET)                      ZZRDLG
C     ZZDEXP                               ZZRDRL
C     ZZDSRT                               ZZRECL
C    [ZZDTTM]                             [ZZSCAL]
C     ZZERRM (ZZETRM)                      ZZSECS
C     ZZEVAL (ZZEGET,ZZESRT,ZZESET,ZZECHK) ZZSHFT
C     ZZFNS  (ZZFPAR,ZZFSET)               ZZSMRY
C    [ZZGETG](ZZDEFG)                      ZZSORT
C     ZZGETP (ZZGDEF)                      ZZSRCH
C     ZZLADV                               ZZSTX0
C     ZZLENG                               ZZWRCH
C     ZZLINK                               ZZWRIN
C     ZZLMOD                               ZZWRLG
C     ZZLPCK                               ZZWRRL
C    [ZZMPAR]
C
C## P A R A M E T E R S:

C+++++ REAL CONSTANT DEFINITIONS, TRUE FALSE STUFF AND++++++++++++++++++
C+++++ PREDEFINED SPECIAL CHARACTERS AND STRINGS +++++++++++++++++++++++

      DOUBLE PRECISION  ZERO,       ONE,       TWO,       THREE
C!!!! REAL              ZERO,       ONE,       TWO,       THREE
      PARAMETER (       ZERO = 0D0, ONE = 1D0, TWO = 2D0, THREE = 3D0)

      DOUBLE PRECISION  FOUR,       FIVE,      SIX,       SEVEN
C!!!! REAL              FOUR,       FIVE,      SIX,       SEVEN
      PARAMETER (       FOUR = 4D0, FIVE = 5D0,SIX = 6D0, SEVEN = 7D0)

      DOUBLE PRECISION  EIGHT,         NINE,          TEN
C!!!! REAL              EIGHT,         NINE,          TEN
      PARAMETER (       EIGHT = 8D0,   NINE = 9D0,    TEN = 10D0     )

      LOGICAL     T,          F
      PARAMETER ( T = .TRUE., F = .FALSE. )

      CHARACTER*(*) TRUE,          QT,       FALSE,           QF
      PARAMETER (   TRUE = 'TRUE', QT = 'T', FALSE = 'FALSE', QF = 'F' )

      INTEGER     ITRUE,     IFALSE
      PARAMETER ( ITRUE = 1, IFALSE = 0 )

      DOUBLE PRECISION  RTRUE,        RFALSE
C!!!! REAL              RTRUE,        RFALSE
      PARAMETER      (  RTRUE = 1.D0, RFALSE = 0.D0 )

      CHARACTER*(*) BLANK,        QUOTE,        HASH
      PARAMETER (   BLANK  = ' ', QUOTE  = '"', HASH   = '#' )

      CHARACTER*(*) PERIOD,       COMMA,        SEMICN
      PARAMETER (   PERIOD = '.', COMMA  = ',', SEMICN = ';' )

      CHARACTER*(*) COLON,        DASH,         EQUALS
      PARAMETER (   COLON  = ':', DASH   = '-', EQUALS = '=' )

      CHARACTER*(*) OBRACE,       CBRACE,       UNDERS
      PARAMETER (   OBRACE = '{', CBRACE = '}', UNDERS = '_' )

      CHARACTER*(*) PLUS,         MINUS,        EXCLAM
      PARAMETER (   PLUS   = '+', MINUS  = '-', EXCLAM = '!' )

      CHARACTER*(*) GTHAN,        LTHAN,        QUESMK
      PARAMETER (   GTHAN  = '>', LTHAN  = '<', QUESMK = '?' )

      CHARACTER*(*) SLASH,        BSLASH,       PERCNT
      PARAMETER (   SLASH  = '/', BSLASH = '\\',PERCNT = '%' )

      CHARACTER*(*) CARAT,        ATSIGN,       TILDE
      PARAMETER (   CARAT  = '^', ATSIGN = '@', TILDE = '~' )

      INTEGER     CTOUPP,     CTOLOW,     CTOCAP
      PARAMETER ( CTOUPP = 1, CTOLOW = 2, CTOCAP = 3 )

C+++++ PREDEFINED SPECIAL CHARACTERS AND STRINGS +++++++++++++++++++++++


      CHARACTER *(*) UNDEFN
      PARAMETER (    UNDEFN = 'UNDEFN' )
                   CHARACTER *(*) ENDIT,         TESTCH
                   PARAMETER (    ENDIT = 'END', TESTCH = GTHAN )

C-----                              DECODE, READ ERROR MAX'S.
      INTEGER       MAXERR,     RDERMX
      PARAMETER (   MAXERR = 3, RDERMX = 5 )

C+++++ INTEGER ENUMERATED CONSTANTS, A LA PASCAL +++++++++++++++++++++++

C-----                 CODES FOR SORTING.

      INTEGER     SPRNAM,     SPRNUM,     SASIS,     SRECNO
      PARAMETER ( SPRNAM = 1, SPRNUM = 2, SASIS = 3, SRECNO = 4 )

      INTEGER     SFNNAM,     SFNNUM,     SDIMN,     SPROLG
      PARAMETER ( SFNNAM = 5, SFNNUM = 6, SDIMN = 7, SPROLG = 8 )

C-----                                       COMMAND INPUT MODE
      INTEGER     CMODE,     PMODE,     GMODE
      PARAMETER ( CMODE = 1, PMODE = 2, GMODE = 3 )

C-----                                       CODES FOR MODE.
      INTEGER     CINTAC,     CBATCH
      PARAMETER ( CINTAC = 1, CBATCH = 2 )

C-----                                       CODES FOR CHECK.

      INTEGER     CHOFF,     CHON,     CHNAM,     CHNUM
      PARAMETER ( CHOFF = 1, CHON = 2, CHNAM = 3, CHNUM = 4 )

C-----                                       CODES FOR GO.
      INTEGER     CNOGO,      CGOGO
      PARAMETER ( CNOGO = 0,  CGOGO = 1 )

C-----           CODES FOR SMRY.

      INTEGER     CCOLD,     CDOFLE,     CDOTRM,     NWISHS
      PARAMETER ( CCOLD = 1, CDOFLE = 2, CDOTRM = 3, NWISHS = 3 )

C-----           CODES FOR LOOPS.

      INTEGER     LLIST,     LARITH,     LGEOMT
      PARAMETER ( LLIST = 1, LARITH = 2, LGEOMT = 3 )

      DOUBLE PRECISION  DEFADD,          DEFMUL
      PARAMETER       ( DEFADD = 1.0D0,  DEFMUL = 10.0D0 )

C     ANY FORM OF LOOP REQUIRES 5 ENTRIES IN LOOPC, WHEREAS A LIST
C     REQUIRES 2, PLUS THE NUMBER OF LIST ELEMENTS, ENTRIES.

      INTEGER     LOOPSP,     LISTSP
      PARAMETER ( LOOPSP = 5, LISTSP = 2 )

C----- CODES FOR VALUES TO PRINT WHEN CURRENT VALUES REQ'D.

      INTEGER     CINPUT,     CLOOPS,     CCONTR,     CALL
      PARAMETER ( CINPUT = 1, CLOOPS = 2, CCONTR = 3, CALL = 4 )

C----- FLAGS FOR SINGLE/DOUBLE PRECISION, VALUES FOR PARAMETER
C      CLASSES ( NOTE TYPE REAL ), AND CONSTANTS FOR DECODE MODE.


      INTEGER     SINGLE,     DOUBLE
      PARAMETER ( SINGLE = 1, DOUBLE = 2 )

      INTEGER   TLOGIC, TYREAL, TINTGR, TSTRNG
      INTEGER   TINTPW, TYCHAR, TINTLT, TYNONE

      PARAMETER ( TLOGIC = 0,             TINTGR = 3, TINTPW = 4 )
      PARAMETER ( TINTLT = 5, TYCHAR = 6, TSTRNG = 7, TYNONE = 8 )

      PARAMETER ( TYREAL = DOUBLE )
C!!!! PARAMETER ( TYREAL = SINGLE )

C  MODES FOR DECODING.

      INTEGER     DCDNEW,     DCDDON
      PARAMETER ( DCDNEW = 0, DCDDON = DCDNEW )

      INTEGER     DCDOLD,     DCDMOR
      PARAMETER ( DCDOLD = 1, DCDMOR = DCDOLD )

      INTEGER     DCDREP,     DCDERR
      PARAMETER ( DCDREP = 2, DCDERR = DCDREP )

      INTEGER     DCDCON,     DCDBAD
      PARAMETER ( DCDCON = 3, DCDBAD = 4 )

      INTEGER CONT, DEL, ESC, SEP, RADIX, ASSMT, COM1, COM2
      INTEGER RADPRB, RADFUN, RADGRP, STRNG1, STRNG2, LOOPA, LOOPG

      INTEGER  NDCCHS

      PARAMETER ( CONT   = 1, DEL    = 2, ESC    = 3, SEP    = 4,
     -            RADIX  = 5, ASSMT  = 6, COM1   = 7, COM2   = 8,
     -            RADPRB = 9, RADFUN =10, RADGRP =11, STRNG1 =12,
     -            STRNG2 =13, LOOPA  =14, LOOPG  =15            )

      PARAMETER ( NDCCHS = 15 )

C-----          CODES FOR ZZEVAL.

      INTEGER     CANAL,     CDIFF,     CTEST,     CFIRST
      PARAMETER ( CANAL = 1, CDIFF = 2, CTEST = 3, CFIRST = 4 )

      INTEGER     JUSTF,     BOTH,     JUSTG,      NOOP
      PARAMETER ( JUSTF = 1, BOTH = 0, JUSTG = -1, NOOP = 2 )

C-----          CODES FOR ZZTERM.

      INTEGER     NL1,     NL2,     NLINF
      PARAMETER ( NL1 = 1, NL2 = 2, NLINF = 3 )

      INTEGER     NQUITS
      PARAMETER ( NQUITS = 4 )

      INTEGER     PGRAD,     PSTEP,     PSHXG,     PFUNC
      PARAMETER ( PGRAD = 1, PSTEP = 2, PSHXG = 3, PFUNC = 4 )

C-----          STATUS CODES.

C--ON ENTRY:
      INTEGER     CNORML,     CRCSTR,     CRCRPT,     CRCNFG
      PARAMETER ( CNORML = 0, CRCSTR = 1, CRCRPT = 2, CRCNFG = 3 )

      INTEGER     CNRMFG,      CPSTHR
      PARAMETER ( CNRMFG = -1, CPSTHR = -2 )

C--ON EXIT:
      INTEGER     CDONE,     CRCF,     CRCFG,     CRCG
      PARAMETER ( CDONE = 0, CRCF = 1, CRCFG = 2, CRCG = 3 )

      INTEGER     CNSTOR,      CIPMIN,      CIPUNF,      CBDMTH
      PARAMETER ( CNSTOR = -1, CIPMIN = -2, CIPUNF = -3, CBDMTH = -4 )

      INTEGER     CLSFAL,      CNODSC,      CXSFNC,      CPSBCK
      PARAMETER ( CLSFAL = -5, CNODSC = -6, CXSFNC = -7, CPSBCK = -8  )

      INTEGER     CRABRT,      CUSERV
      PARAMETER ( CRABRT = -9, CUSERV = -10 )

C-----                 TERMINAL CHARACTERISTICS, INCLUDING EOF HANDLING
C                      AND AMOUNT OF SUMMARY OUTPUT.

      INTEGER     CNONE,     CMIN,     CMED,     CFULL
      PARAMETER ( CNONE = 1, CMIN = 2, CMED = 3, CFULL = 4 )

      INTEGER     CEOFAC,     CEOFIG
      PARAMETER ( CEOFAC = 1, CEOFIG=2 )

      INTEGER     CCPRSN,     CCMISS
      PARAMETER ( CCPRSN = 1, CCMISS = 2 )

C+++++ CONTROL OVER SIZES OF AND ACCESS TO STRINGS AND ARRAYS ++++++++++

C-----                  STRING LENGTHS.

      INTEGER     PNAMLN,     FNAMLN,          GNAMLN
      PARAMETER ( PNAMLN = 8, FNAMLN = PNAMLN, GNAMLN = PNAMLN )

      INTEGER     TITLEN,      PDESCL
      PARAMETER ( TITLEN = 72, PDESCL = 72 )

      INTEGER      INLINE,      KEYLEN,     PRMPTL
      PARAMETER (  INLINE =100, KEYLEN = 8, PRMPTL = 27 )

C-----          ARRAY SIZES.

      INTEGER     MAXN
      PARAMETER ( MAXN = 10000 )

      INTEGER     NOFNS,      DFPRBS,       MXGRPS,      MXGSZ
      PARAMETER ( NOFNS = 80, DFPRBS = 450, MXGRPS = 50, MXGSZ = 200 )

      INTEGER     NULLIN,   MXCRIT,    RGL
      PARAMETER ( NULLIN=0, MXCRIT=20, RGL=MXCRIT+1 )
      INTEGER     ERL,          CPL,          SVL
      PARAMETER ( ERL=MXCRIT+2, CPL=MXCRIT+3, SVL=MXCRIT+4 )
      INTEGER     NL
      PARAMETER ( NL = MXCRIT+4 )


      INTEGER     MXPARS,      MXPRBS,      MXSOLN
      PARAMETER ( MXPARS = 80, MXPRBS = 50, MXSOLN = 5*MAXN )

      INTEGER     LR,            LI
      PARAMETER ( LR = 10*MAXN,  LI = 5*MAXN )

      INTEGER     EXTRA,          NTR
      PARAMETER ( EXTRA = 5*MAXN, NTR = 15 )

C-----              NUMBER OF SUBROUTINE NAMES.

      INTEGER     MXSUBS
      PARAMETER ( MXSUBS = 5 )

C-----              NUMBER OF FUNCTION ARGUMENTS.

      INTEGER     FNO
      PARAMETER ( FNO = 10 )

C-----              NUMBER OF USER DEFINABLE ARGUMENT NAMES.

      INTEGER     NU
      PARAMETER ( NU = 21 )
                   INTEGER     DUSRNO
                   PARAMETER ( DUSRNO = 0 )

C-----               POSITION FLAGS FOR ENTRIES IN THE PRECNO ARRAY.
C   DEFINITIONS OF THE ROWS IN THE ARRAY PRECNO. ( PRECNO HOLDS THE
C   RECORD NUMBER IN THE DAUF FILE, THE MINIMUM DIMENSION, AND THE
C   FUNCTION NUMBER OF EACH PROBLEM. )

      INTEGER     RECN,     DIMN,     FNO1
      PARAMETER ( RECN = 1, DIMN = 2, FNO1 = 3 )

C-----               POSITION FLAGS FOR ENTRIES IN THE PINTS ARRAY.

      INTEGER     PPTMAX,     PPTIX0,     PPTDES
      PARAMETER ( PPTMAX = 1, PPTIX0 = 2, PPTDES = 3 )

      INTEGER     PPTORD,     PPTLPX,     PPTLPC,     PPTSOL
      PARAMETER ( PPTORD = 4, PPTLPX = 5, PPTLPC = 6, PPTSOL = 7 )

      INTEGER     NPNTS
      PARAMETER ( NPNTS  = 7 )

C----- SET UP OUTER LOOP POINTERS; PTUSER WILL BE INITIALIZED AT
C      THE START OF EXECUTION SINCE IT IS AN ARRAY.

      INTEGER     PTACC,     PTFACT,             PTGXPN
      PARAMETER ( PTACC = 1, PTFACT = PTACC + 1, PTGXPN = PTFACT + 1)

      INTEGER     NOUTER,    PTUSER(NU)
      PARAMETER ( NOUTER = 3 )

C----- SET UP INNER LOOP POINTERS; PTFARG WILL BE INITIALIZED AT
C      THE START OF EXECUTION SINCE IT IS AN ARRAY.

      INTEGER     PTNDIM,     PTSCAL,     PTPXPN
      PARAMETER ( PTNDIM = 1, PTSCAL = 2, PTPXPN = 3 )

      INTEGER     NINNER
      PARAMETER ( NINNER = 3 )

      INTEGER     PTFARG(FNO)

C----- SET UP PARAMETERS DEFINING SIZES OF LOOP ARRAYS.

      INTEGER     ILPXSZ,                ILPCSZ
      PARAMETER ( ILPXSZ = FNO + NINNER, ILPCSZ = 5 * ILPXSZ )

      INTEGER     OLPXSZ,                OLPCSZ
      PARAMETER ( OLPXSZ = NU + NOUTER,  OLPCSZ = 5 * OLPXSZ )

C+++++ DEFINITIONS OF I/O UNITS ++++++++++++++++++++++++++++++++++++++++


      INTEGER     PREPRC,     DAUF,       INPTUN
      PARAMETER ( PREPRC = 1, DAUF =   2, INPTUN = 3 )

      INTEGER     TEMPUN,     STDIN,     TRMOUT
      PARAMETER ( TEMPUN = 4, STDIN = 5, TRMOUT = 6 )

      INTEGER     WRITUN,     TRACUN,     SUMMUN
      PARAMETER ( WRITUN = 7, TRACUN = 8, SUMMUN = 9 )

      INTEGER     COPYUN,     TEXUN
      PARAMETER ( COPYUN =10, TEXUN =11 )

      INTEGER     FILENL,      NFILES
      PARAMETER ( FILENL = 80, NFILES = 15 )


      CHARACTER *( FILENL ) NMPRLG, NMTRMI, NMTEMP, NMPROB, NMGRPS
      CHARACTER *( FILENL ) NMSUMM, NMDAUF, NMCOPY, NMBATC

      PARAMETER ( NMPRLG = 'PROLOG', NMDAUF = 'DAUF', NMTEMP = BLANK,
     -            NMTRMI =  BLANK,   NMSUMM = BLANK,  NMPROB ='DEFNS',
     -            NMGRPS = 'GROUPS', NMCOPY = 'COPY', NMBATC ='BATCH')

C                            RECORD LENGTH FOR SEQUENTIAL FILES.
      INTEGER     RECL
      PARAMETER ( RECL = 0   )

C     LINE LENGTHS REQUIRED FOR DIRECT ACCESS UNFORMATTED RECORDS.

      INTEGER     DCPRLN,      DLPRLN,     DIPRLN,     DRPRLN
      PARAMETER ( DCPRLN = 16, DLPRLN = 4, DIPRLN = 4, DRPRLN = 2 )

C+++++ DEFAULT VALUES ++++++++++++++++++++++++++++++++++++++++++++++++++

C----- TRACE VALUES, MISSING PARAMETERS AND USER PARAMETERS.

      DOUBLE PRECISION             DFLT,        DUSVAL
C!!!! REAL                         DFLT,        DUSVAL
      LOGICAL          DTRVAL
      PARAMETER (      DTRVAL = F, DFLT = ONE , DUSVAL = ZERO )

C----- SPECIAL CHARACTERS FOR DECODING.

      CHARACTER * 1 DCONTN, DDLIMT, DESCAP, DSEPAR, DRADIX, DASSMT
      CHARACTER * 1 DCOM1,  DCOM2,  DRDPRB, DRDFUN, DRDGRP, DSTRG1
      CHARACTER * 1 DSTRG2, DLOOPA, DLOOPG

      PARAMETER  ( DCONTN = '$', DDLIMT = ',', DESCAP = '!' )
      PARAMETER  ( DSEPAR = ';', DRADIX = '/', DASSMT = '='  )
      PARAMETER  ( DCOM1  = '<', DCOM2  = '>', DSTRG1 = '''' )
      PARAMETER  ( DSTRG2 = '"', DLOOPA = ':', DLOOPG = '*'  )
      PARAMETER  ( DRDPRB = 'P', DRDFUN = 'F', DRDGRP = 'G'  )

C-----                           TITLE REQUIRED FOR STEP 1.
      LOGICAL      DTITLR
      PARAMETER (  DTITLR = T  )

C-----                           SORTING.
      LOGICAL                    DASC
      INTEGER     DSORT
      PARAMETER ( DSORT = SASIS, DASC = T )

C-----                     SUBROUTINE NUMBER AND COMMUNICATION METHOD.
      INTEGER     DSUBR
      LOGICAL                DREVRS
      PARAMETER ( DSUBR = 1, DREVRS = F )

C-----                     FOR ZZEVAL.
      INTEGER                                     DGXPNS
      LOGICAL     DTRF,     DTRG,     DETRAC
      PARAMETER ( DTRF = F, DTRG = F, DETRAC = F, DGXPNS = 1 )

      INTEGER     DDERV,         DPXPNS
      PARAMETER ( DDERV = CANAL, DPXPNS = 0 )

C-----                                          FOR ZZPRNT.
      LOGICAL     DGRAD,     DPOINT,     DIGRAD
      PARAMETER ( DGRAD = T, DPOINT = T, DIGRAD = F )

      LOGICAL     DIPT,     DLOCAL
      PARAMETER ( DIPT = T, DLOCAL = F )

      INTEGER     DPRINT,         DIPR
      PARAMETER ( DPRINT = -1000, DIPR = 0 )

C----- FACTOR FOR STARTING POINT FOR ZZSTX0.

      DOUBLE PRECISION  DFACTR
C!!!! REAL              DFACTR
      PARAMETER   (     DFACTR = ONE )

C----- LIST OF CRITERIA.
                         INTEGER     DCRIT
                         PARAMETER ( DCRIT = 0 )
C----- FOR ZZTERM.

      DOUBLE PRECISION         DACC
C!!!! REAL                     DACC
      INTEGER     DNORM
      PARAMETER ( DNORM = NL2, DACC = 1.D-5 )

      LOGICAL     DTTRAC,     DRELF,     DRELG
      PARAMETER ( DTTRAC = F, DRELF = T, DRELG = T )

      CHARACTER *(*)   DQUITS
      PARAMETER  (     DQUITS = 'FTTF' )

C----- PROBLEM DEFAULTS

      INTEGER     DMAXF,       DNDIM,     DSCAL,     DPEXPS
      PARAMETER ( DMAXF = 200, DNDIM = 2, DSCAL = 0, DPEXPS = 0 )

      LOGICAL     DPERM
      PARAMETER ( DPERM = T )

      INTEGER                         DARGNO
      DOUBLE PRECISION  DFARG
C!!!! REAL              DFARG
      PARAMETER       ( DFARG = DFLT, DARGNO = 0 )

      INTEGER           DIX0
      DOUBLE PRECISION            DX1,        DX2
C!!!! REAL                        DX1,        DX2
      PARAMETER       ( DIX0 = 2, DX1 = ZERO, DX2 = ZERO )

C----- OUTPUT LEVEL FOR SMRY.

      INTEGER     DSELEV
      LOGICAL                    DLONGF
      PARAMETER ( DSELEV = CMIN, DLONGF = F )

C+++++ DEFAULTS FOR I/O CONTROL ++++++++++++++++++++++++++++++++++++++++

      CHARACTER *( FILENL ) DNMWRT, DNMTRC, DNTRMO
      PARAMETER ( DNMWRT = 'RESULT', DNMTRC = 'TRACE', DNTRMO = BLANK )

C     INPUT AND OUTPUT FLAGS.

      LOGICAL DWRSUM, DUPCAS, DEOF,   DVRIFY, DIMMED, DCOPY, DTEX
      LOGICAL DINTAC, DCDTRC, DCHECK, DBRIEF, DTRMRD, DFLTRC

      PARAMETER ( DWRSUM = T, DUPCAS = F, DEOF   = F, DCOPY = F,
     -            DVRIFY = F, DINTAC = F, DCDTRC = F, DTEX  = F,
     -            DCHECK = T, DBRIEF = F, DTRMRD = T,
     -            DFLTRC = F, DIMMED = F                  )

C+++++ DEFINE STRUCTURES AND ENTRIES FOR DICTIONARY FOR COMMAND MODE.

C     NUMBER OF ENTRIES IN THE DICTIONARIES.

      INTEGER  NCMDS, NCPARS, NDEFS, NDPARS

C     DECLARE COMMAND AND PARAMETER STRINGS.

      CHARACTER * (*) CCMDS, CPAR, DEFN, DPAR

C     DEFINE KEYWORDS FOR COMMANDS.

      PARAMETER( CCMDS = 'ABORT   '//'ACCURACY'//'ADD     '//'ARITHMET'
     -     //'ASCENDIN'//'ASSIGNME'//'BRIEF   '//'BYE     '//'CC      '
     -     //'CHECK   '//'COMMENT '//'CONTINUA'//'COPY    '//'CRITERIA'
     -     //'DECODE  '//'DEFAULT '//'DEFINITI'//'DELIMITE'//'DERIVATI'
     -     //'DESCENDI'//'DOSUMMAR'//'DROP    '//'END     '
     -     //'EOF     '//'ESCAPE  '//'EVTRACE '//'EXPENSE '//'FABSOLUT'
     -     //'FACTOR  '//'FORWARD '//'FREE    '//'FRELATIV'//'FTRACE  '
     -     //'GABSOLUT'
     -     //
     -       'GEOMETRI'//'GRELATIV'//'GTRACE  '//'IMMEDIAT'//'INPUT   '
     -     //            'LIST    '//'LONGF   '//'MEMORY  '//'MODE    '
     -     //'NORM    '//            'PGRADIEN'//'POINT   '
     -     //'PRINT   '//'QUIT    '//'RADIX   '//'RENAME  '
     -     //'REQUIRED'//'RESET   '//'RESULTS '//'REVERSE '//'SEE     '
     -     //'SELECT  '//'SEPARATO'//'SORT    '//'START   '//'STRING  '
     -     //'SUBROUTI'//'SUMMARY '//'TERMINAT'//'TEX     '//'TITLE   '
     -     //'TRACES  '//'TRACEUN '
     -     //
     -       'TTRACE  '//'UPPERCAS'//'USER    '//'VALUES  '//'VERIFY  '
     -     //'WATCH   '//'WITH    ')

C     DEFINE PARAMETERS.

      PARAMETER( CPAR =  'ABSSUM  '//'ACTIVE  '//'ALL     '//'ANALYTIC'
     -                 //'ASIS    '//'BATCH   '//'CONTROL '
     -     //'DIFFEREN'//'DIMENSIO'//'EUCLIDEA'//'FIRST   '//'FNAME   '
     -     //'FNO     '//'FNUMBER '//'FROBENIU'//'FULL    '//'GO      '
     -     //'IGNORED '//'INFINITY'//'INPUT   '//'INTERACT'
     -     //'LOOPS   '//'L1      '//'L2      '//'MAXIMUM '//'MEDIUM  '
     -     //'MINIMAL '//'MISSING '//'NAMES   '//'NO      '//'NONE    '
     -     //
     -       'NULL    '//'NUMBERS '//'OFF     '//'OK      '//'ON      '
     -     //'PNAME   '//'PNO     '//'PNUMBER '//'PRESENT '//'PROLOG  '
     -     //'RECORDNO'//'RUN     '
     -     //'SUPREMUM'//'TESTMODE'//'YES     '                       )

C      DEFINE STRUCTURE FOR COMMAND DICTIONARY.
C      SET UP NAMED INDEX FOR EACH KEYWORD. ALL ARE INTEGERS.

      INTEGER  XABORT, XACCUR, XADD,   XARITH, XASC,   XASSMT,
     - XBRIEF, XBYE,   XCC,    XCHECK, XCOMME, XCONTI, XCOPY, XCRIT,
     - XDECOD, XDEFAU,
     - XDEFIN, XDELIM, XDERIV, XDESC,  XDOSUM, XDROP,  XEND,
     - XEOF,   XESCAP, XEVTRC, XEXPNS, XFABS,  XFACTO, XFORWO, XFREE,
     - XFREL,  XFTRAC, XGABS,  XGEOME,
     - XGREL,  XGTRAC, XIMMED, XINPUT, XLIST,  XLONGF,
     - XMEMOR, XMODE,  XNORM,  XPGRAD, XPOINT,
     - XPRINT, XQUIT,  XRADIX, XRENAM, XREQUI, XRESET, XRESUL, XREVER,
     - XSEE,   XSELCT, XSEPAR, XSORT,  XSTART,
     - XSTRIN, XSUBRO, XSUMMA, XTERM,  XTEX,   XTITLE, XTRACE, XTRCUN,
     - XTTRAC, XUPPER, XUSER,  XVALUE, XVERIF, XWATCH,  XWITH, XXLAST

      PARAMETER (      XABORT=       1,XACCUR=XABORT+1,XADD  =XACCUR+1,
     -                 XARITH=XADD  +1,XASC  =XARITH+1,XASSMT=XASC  +1,
     - XBRIEF=XASSMT+1,XBYE  =XBRIEF+1,XCC   =XBYE  +1,XCHECK=XCC   +1,
     - XCOMME=XCHECK+1,XCONTI=XCOMME+1,XCOPY =XCONTI+1,XCRIT =XCOPY +1,
     - XDECOD=XCRIT +1,XDEFAU=XDECOD+1,
     - XDEFIN=XDEFAU+1,XDELIM=XDEFIN+1,XDERIV=XDELIM+1,XDESC =XDERIV+1,
     - XDOSUM=XDESC +1,XDROP =XDOSUM+1,XEND  =XDROP +1,XEOF  =XEND  +1,
     - XESCAP=XEOF  +1,XEVTRC=XESCAP+1,XEXPNS=XEVTRC+1,XFABS =XEXPNS+1,
     - XFACTO=XFABS +1,XFORWO=XFACTO+1,XFREE =XFORWO+1,XFREL =XFREE +1,
     - XFTRAC=XFREL +1,XGABS =XFTRAC+1,
     - XGEOME=XGABS +1,XGREL =XGEOME+1,XGTRAC=XGREL +1,XIMMED=XGTRAC+1,
     - XINPUT=XIMMED+1,XLIST =XINPUT+1,XLONGF=XLIST +1,
     - XMEMOR=XLONGF+1,XMODE =XMEMOR+1,XNORM =XMODE +1,XPGRAD=XNORM +1)
      PARAMETER (      XPOINT=XPGRAD+1,
     - XPRINT=XPOINT+1,XQUIT =XPRINT+1,XRADIX=XQUIT +1,XRENAM=XRADIX+1,
     - XREQUI=XRENAM+1,XRESET=XREQUI+1,XRESUL=XRESET+1,XREVER=XRESUL+1,
     - XSEE  =XREVER+1,XSELCT=XSEE  +1,XSEPAR=XSELCT+1,XSORT =XSEPAR+1,
     - XSTART=XSORT +1,
     - XSTRIN=XSTART+1,XSUBRO=XSTRIN+1,XSUMMA=XSUBRO+1,XTERM =XSUMMA+1,
     - XTEX  =XTERM +1,XTITLE=XTEX  +1,
     - XTRACE=XTITLE+1,XTRCUN=XTRACE+1,XTTRAC=XTRCUN+1,XUPPER=XTTRAC+1,
     - XUSER =XUPPER+1,XVALUE=XUSER +1,XVERIF=XVALUE+1,XWATCH=XVERIF+1,
     - XWITH =XWATCH+1,
     - XXLAST=XWITH                                                   )

      PARAMETER (  NCMDS = XXLAST+NU  )

C     DEFINE STRUCTURES FOR KEYWORD PARAMETERS FOR COMMANDS.

      INTEGER  ZABSSU, ZACTIV, ZALL  , ZANALY, ZASIS , ZBATCH,
     -         ZCONTR, ZDIFFE, ZDIMEN, ZEUCLI, ZFIRST, ZFNAME, ZFNO  ,
     - ZFNUMB, ZFROBE, ZFULL , ZGO,    ZIGNOR, ZINFIN, ZINPUT,
     - ZINTER, ZLOOPS, ZL1   , ZL2   , ZMAXIM, ZMEDIM, ZMINIM, ZMISSI,
     - ZNAMES, ZNO   , ZNONE,  ZNULL,  ZNUMBE, ZOFF,   ZOK,    ZON   ,
     - ZPNAME, ZPNO  , ZPNUMB, ZPRESE, ZPROLG, ZRECNO, ZRUN,
     - ZSUPRE, ZTESTM, ZYES,   ZZLAST

      PARAMETER  (     ZABSSU=       1,ZACTIV=ZABSSU+1,ZALL  =ZACTIV+1,
     - ZANALY=ZALL  +1,ZASIS =ZANALY+1,ZBATCH=ZASIS +1,
     - ZCONTR=ZBATCH+1,ZDIFFE=ZCONTR+1,ZDIMEN=ZDIFFE+1,ZEUCLI=ZDIMEN+1,
     - ZFIRST=ZEUCLI+1,ZFNAME=ZFIRST+1,ZFNO  =ZFNAME+1,ZFNUMB=ZFNO  +1,
     - ZFROBE=ZFNUMB+1,ZFULL =ZFROBE+1,ZGO   =ZFULL +1,
     - ZIGNOR=ZGO   +1,ZINFIN=ZIGNOR+1,ZINPUT=ZINFIN+1,ZINTER=ZINPUT+1,
     - ZLOOPS=ZINTER+1,ZL1   =ZLOOPS+1,ZL2   =ZL1   +1,ZMAXIM=ZL2   +1,
     - ZMEDIM=ZMAXIM+1,ZMINIM=ZMEDIM+1,ZMISSI=ZMINIM+1,ZNAMES=ZMISSI+1,
     - ZNO   =ZNAMES+1,ZNONE =ZNO   +1,ZNULL =ZNONE +1,ZNUMBE=ZNULL +1,
     - ZOFF  =ZNUMBE+1,ZOK   =ZOFF  +1,ZON   =ZOK   +1,ZPNAME=ZON   +1,
     - ZPNO  =ZPNAME+1,ZPNUMB=ZPNO  +1,ZPRESE=ZPNUMB+1,ZPROLG=ZPRESE+1,
     - ZRECNO=ZPROLG+1,ZRUN  =ZRECNO+1,
     - ZSUPRE=ZRUN  +1,ZTESTM=ZSUPRE+1,ZYES  =ZTESTM+1,
     - ZZLAST=ZYES                                                    )

      PARAMETER  (  NCPARS = ZZLAST + MXSUBS )

C      DEFINE STRUCTURE FOR PROBLEM DEFINITION DICTIONARY.
C      SET UP NAMED INDEX FOR EACH KEYWORD. ALL ARE INTEGERS.

C-----CREATION OF THE DEFINITION DICTIONARY.

      PARAMETER( DEFN =  'ADD     '//'ARGUMENT'//'DEFINITI'//'DESCRIPT'
     -     //'DIMENSIO'//'DROP    '//'END     '//'EXPENSE '//'FUNCTION'
     -     //'GROUP   '//'LIMIT   '//'MAX     '//'N       '//'PERMANEN'
     -     //'PROBLEM '//'SCALE   '//'SELECT  '
     -     //'SOLUTION'//'START   '//'TEMPORAR'//'USE     '//'X0      ')

C     THERE ARE NO NAMED PARAMETERS IN DEFINITION MODE.

      PARAMETER ( DPAR = '        '                                   )

      INTEGER  QADD,   QARG  , QDEFN,  QDESCR, QDIMEN, QDROP,  QEND  ,
     -         QEXPNS, QFUNCT, QGROUP, QLIMIT, QMAX  , QN    , QPERMA,
     -         QPROBL, QSCALE, QSELCT, QSOLN ,
     - QSTART, QTEMP , QUSE  , QX   ,  QQLAST

      PARAMETER  (     QADD  =       1,QARG  =QADD  +1,QDEFN =QARG  +1,
     -                 QDESCR=QDEFN +1,QDIMEN=QDESCR+1,QDROP =QDIMEN+1,
     - QEND  =QDROP +1,QEXPNS=QEND  +1,QFUNCT=QEXPNS+1,QGROUP=QFUNCT+1,
     - QLIMIT=QGROUP+1,QMAX  =QLIMIT+1,QN    =QMAX  +1,
     - QPERMA=QN    +1,QPROBL=QPERMA+1,QSCALE=QPROBL+1,QSELCT=QSCALE+1,
     - QSOLN =QSELCT+1,
     - QSTART=QSOLN +1,QTEMP =QSTART+1,QUSE  =QTEMP +1,QX    =QUSE  +1,
     - QQLAST=QX                                                      )

      PARAMETER  ( NDEFS  = QQLAST )

      PARAMETER  ( NDPARS = 1         )

C## L O C A L   D E C L:

C----- EXTERNAL FUNCTIONS.

      INTEGER                  ZZLENG,  ZZRECL
      EXTERNAL         ZZFNS,  ZZLENG,  ZZRECL

      DOUBLE PRECISION  ZZNRM2,  RD
C!!!! REAL              ZZNRM2,  RD

C-----REMOTE BLOCKS.

      INTEGER  REMOT1, REMOT2, REMOT4, REMOT5, REMOT7
      INTEGER  RETRN1, RETRN2, RETRN4, RETRN5, RETRN7, RETERR

C-----ARRAYS AND I/O STRINGS, EXCEPT FOR DICTIONARIES.

      INTEGER          IW(EXTRA)
      REAL             RW(EXTRA)
      DOUBLE PRECISION DW(EXTRA)

      DOUBLE PRECISION  G(MAXN), RWORK(LR), X(MAXN), SOLNS(MXSOLN)
C!!!! REAL              G(MAXN), RWORK(LR), X(MAXN), SOLNS(MXSOLN)

      DOUBLE PRECISION  PARS(MXPARS),  USER(NU), USERD(NU), X0(MAXN)
C!!!! REAL              PARS(MXPARS),  USER(NU), USERD(NU), X0(MAXN)

      LOGICAL  TRACES(NTR)

      INTEGER  LIST(MXPRBS), IWORK(LI), PRECNO(3,DFPRBS), GROUPS(MXGRPS)
      INTEGER  MAP1(NCMDS),  INVMP1(NCMDS),  MAP2(NDEFS), INVMP2(NDEFS)
      INTEGER  MAP3(NCPARS), INVMP3(NCPARS)

      INTEGER  ILOOPX(ILPXSZ+1), IORDER(ILPXSZ)
      INTEGER  OLOOPX(OLPXSZ+1), OORDER(OLPXSZ)

      DOUBLE PRECISION   ILOOPC(ILPCSZ), OLOOPC(OLPCSZ)
C!!!! REAL               ILOOPC(ILPCSZ), OLOOPC(OLPCSZ)

      CHARACTER *(KEYLEN) KEYSTR(MXPARS), S1, S2

      CHARACTER *((PNAMLN+FNAMLN)*DFPRBS)  NAMES
      CHARACTER *(GNAMLN*MXGRPS) GNAMES

      CHARACTER *(TITLEN)    TITLE
      CHARACTER *(INLINE)    LL(NL)
      CHARACTER *(FILENL)    NMWRIT, NMTRAC, NMNEXT, NMTRMO, NMCURR
      CHARACTER *(PRMPTL)    PROMPT(9)

C-----DECLARATIONS OF KEYWORD DICTIONARIES.

      CHARACTER * ( KEYLEN*NCMDS ) CMDS
      CHARACTER * ( KEYLEN*NDEFS ) DEFNS

      INTEGER    CINF(NCMDS,2),  DINF(NDEFS,2)

C-----PARAMETER NAME KEYWORDS.

      CHARACTER *(KEYLEN*NCPARS) CPARS
      CHARACTER                         *(KEYLEN*NDPARS) DPARS
      INTEGER       CPINF(NCPARS,2),        DPINF(NDPARS,2)

C-----DECLARATION OF CONTROL ON TITLE REQUIREMENT.

      LOGICAL    TITREQ

C-----I/O DEFINITIONS.

      INTEGER  READUN, SEELEV, NEXTUN, TRCOUT, RESOUT
      INTEGER  CPERLN, IPERLN, LPERLN, RPERLN
      INTEGER  RECLEN, RECNO,  RECP

      LOGICAL  WRTSUM, CHECK,  INTACT, VERIFY, LONGF,  IMMED
      LOGICAL  BRIEF,  DCTRAC, UPCASE, EOFBLK, FLTRAC, COPY, TEX

C-----STATUS CODES.

      INTEGER NORMFG, NORMAL, RCSTRT,  RCRPT, RCNOFG, PSTHRU

      INTEGER DONE,   RCF,    RCFG,     RCG,  NOSTOR, IPMIN,  PSBACK
      INTEGER IPUNDF, BDMETH, LSFAIL, NODESC, XSFUNC, RABORT, USERV

C-----VARIABLE DECLARATIONS OF A MISCELLANEOUS TYPE.

      LOGICAL  GOTDAF, SORTFL, EOPH, OVER, TRMRD, OUTER, TODO(NWISHS)
      LOGICAL  SEPART, CRITLN, NONE, GLBLOK, PRMISS, NOPRLG, FAKEIT

      CHARACTER*10 CNORM(3), CTYPE(5), CDERV(4)
      CHARACTER*10 VCHEC(4), VCC  (2), VSEE (4), VSORT(7)

      CHARACTER*1  LASTDL, CH

      INTEGER  KEYNO,  DCDMOD, PARCT,  NPROBS, DEFNMD, ERRFLG, LNO
      INTEGER  PROBCT, MAPKEY, PROB,   LINELN, PHASE,  IPTYPE, LASTLN
      INTEGER  STATUS, ITCT,   SVPHAS, SAVUNT, LISTCD, VALS, TMPUN
      INTEGER  I, J, K, II, JJ, KK, N, SCAL,   PTSOLN, SOLNX, LPTYPE
      INTEGER   OSCAL, OINDEX, CNEXT,  SOLNF,  CASE,   FREEPT
      INTEGER  USERNO, ARGNO,   TCT,   CRITNO, RDERCT, RPSOUT

      DOUBLE PRECISION  PRTIME, TM, TMIN, GSQ, PAR1, FNC, TFUNC, TIMEIT
C!!!! REAL              PRTIME, TM, TMIN, GSQ, PAR1, FNC, TFUNC, TIMEIT

      DOUBLE PRECISION  VALUE, MING, MAXG, DF, DX, FSTAR
C!!!! REAL              VALUE, MING, MAXG, DF, DX, FSTAR

C-----VARIABLES FOR TERMINAL CHARACTERISTICS.

      INTEGER   SYSCC

C-----DEFINITION OF SUBROUTINE, SORTING, MEMORY AND COMMUNICATION.

      INTEGER    SUBR, SORT, MEMORY

      CHARACTER * ( KEYLEN )  SUBNAM

      LOGICAL   REVERS, ASC

C-----SPECIAL CHARACTERS.

      CHARACTER *(NDCCHS) DCC

C-----ERROR COUNTER FOR ZZDCOD ERRORS.

      INTEGER     ERRCNT

C-----VARIABLES FOR ZZEVAL.

      INTEGER  FUNCCT, GRADCT, DERVMD, INDX, GCNT
      INTEGER  EXPENS, GEXPNS, PEXPNS

      LOGICAL     TRF,  TRG, EVTRAC

      DOUBLE PRECISION  MXERR, DIGS
C!!!! REAL              MXERR, DIGS

C-----VARIABLES FOR ZZFNS.

      DOUBLE PRECISION  FARG(FNO)
C!!!! REAL              FARG(FNO)

C-----VARIABLES FOR ZZPRNT.

      INTEGER   PRINTL, IPRL

      LOGICAL   GRAD,   WRITFL, POINT, IGRAD, IPOINT, LOCAL

C-----STARTING POINT FACTOR FOR ZZSTX0.

      DOUBLE PRECISION  FACTOR
C!!!! REAL              FACTOR

C-----DECLARATIONS FOR VARIABLES FOR ZZTERM AND ACCURACY.

      INTEGER    NORM

      LOGICAL    TTRACE, RELF, RELG

      CHARACTER *(NQUITS) QUITS

      DOUBLE PRECISION ACC
C!!!! REAL             ACC

C----- DECLARE PROBLEM STORAGE VARIABLES FOR GETG, GETP, PUTG, PUTP

      INTEGER   PPNUM,  PFNUM,  PMAX,   IX0,  TPPNUM
      INTEGER   LORDER, LLOOPX, LLOOPC, LDESC

      LOGICAL   PPERM

      CHARACTER * (PNAMLN)  PPNAM,  TPPNAM
      CHARACTER * (FNAMLN)  PFNAM
      CHARACTER * (PDESCL)  PDESC

      DOUBLE PRECISION   LPDATA(ILPCSZ)
C!!!! REAL               LPDATA(ILPCSZ)

C----- DECLARE FOR GROUP DEFINITIONS

      INTEGER   PGNUM,  GRPSZ,  GMEMBS( MXGSZ ), G1( MXGSZ )

      CHARACTER * (GNAMLN)  PGNAM

C## S A V E:                 NONE SELECTED.

C## E Q U I V A L E N C E S:

       INTEGER      PINTS(NPNTS)
       EQUIVALENCE (PINTS(PPTMAX),PMAX  ),(PINTS(PPTIX0),IX0   )
       EQUIVALENCE (PINTS(PPTDES),LDESC ),(PINTS(PPTORD),LORDER)
       EQUIVALENCE (PINTS(PPTLPX),LLOOPX),(PINTS(PPTLPC),LLOOPC)
       EQUIVALENCE (PINTS(PPTSOL),PTSOLN)

C## C O M M O N:             NONE IS DEFINED.

C## D A T A:                 NO DATA VALUES SET.
C-----      STATUS CONSTANTS.
      DATA  NORMFG/CNRMFG/, NORMAL/CNORML/, RCSTRT/CRCSTR/,
     -      RCRPT /CRCRPT/, RCNOFG/CRCNFG/, PSTHRU/CPSTHR/
      DATA  DONE  /CDONE/,  RCF   /CRCF/,   RCFG  /CRCFG/,  RCG/CRCG/
     -      NOSTOR/CNSTOR/, IPMIN /CIPMIN/, IPUNDF/CIPUNF/,
     -      BDMETH/CBDMTH/, LSFAIL/CLSFAL/, NODESC/CNODSC/,
     -      RABORT/CRABRT/, XSFUNC/CXSFNC/, USERV /CUSERV/,
     -      PSBACK/CPSBCK/
C>>
C-----DEFINE I/O UNITS AND CONTROL FOR DIRECT ACCESS I/O .

      DATA  NMWRIT /DNMWRT/, NMTRAC /DNMTRC/

      DATA  CPERLN /DCPRLN/, IPERLN /DIPRLN/
      DATA  LPERLN /DLPRLN/, RPERLN /DRPRLN/

      DATA  TRCOUT/TRACUN/, RESOUT/WRITUN/

C-----DEFINE I/O CONTROL.

      DATA WRTSUM/DWRSUM/, SEELEV/DSELEV/, UPCASE/DUPCAS/
      DATA VERIFY/DVRIFY/, INTACT/DINTAC/, DCTRAC/DCDTRC/
      DATA EOFBLK/DEOF/,   CHECK /DCHECK/, TRMRD /DTRMRD/
      DATA FLTRAC/DFLTRC/, LONGF /DLONGF/, IMMED /DIMMED/
      DATA COPY  /DCOPY /, TEX   /DTEX  /

C-----DEFAULTS FOR COMMAND DECODING.

      DATA  DCDMOD /DCDDON/, DEFNMD /CMODE/, CRITNO/DCRIT/
      DATA  ERRCNT /  0  /

C-----DEFINE TRACES.

      DATA  TRACES/ NTR * DTRVAL /

C-----DEFINE SPECIAL CHARACTERS.

      DATA  DCC(CONT  :CONT  )  /DCONTN/, DCC(DEL   :DEL   )  /DDLIMT/
      DATA  DCC(ESC   :ESC   )  /DESCAP/, DCC(SEP   :SEP   )  /DSEPAR/
      DATA  DCC(RADIX :RADIX )  /DRADIX/, DCC(ASSMT :ASSMT )  /DASSMT/
      DATA  DCC(COM1  :COM1  )  /DCOM1 /, DCC(COM2  :COM2  )  /DCOM2 /
      DATA  DCC(RADPRB:RADPRB)  /DRDPRB/, DCC(RADFUN:RADFUN)  /DRDFUN/
      DATA  DCC(RADGRP:RADGRP)  /DRDGRP/, DCC(STRNG1:STRNG1)  /DSTRG1/
      DATA  DCC(STRNG2:STRNG2)  /DSTRG2/, DCC(LOOPA :LOOPA )  /DLOOPA/
      DATA  DCC(LOOPG :LOOPG )  /DLOOPG/

C-----SET DEFAULT FOR STANDARD USER PARAMETERS.

      DATA  USERD /NU * DUSVAL/, USERNO/DUSRNO/
      DATA  USER  /NU * DUSVAL/

C-----DEFAULTS PROBLEM LIST.

      DATA  LISTCD /CHON/

C-----DEFAULTS FOR TERMINAL CHARACTERISTICS.

      DATA SYSCC /CCMISS/

C-----DEFAULTS FOR ZZFNS.

      DATA ARGNO/DARGNO/

C-----DEFAULTS FOR ZZEVAL.

      DATA  TRF /DTRF/, TRG /DTRG/, EVTRAC/DETRAC/
      DATA  GEXPNS/DGXPNS/, PEXPNS/DPXPNS/

C-----DEFAULTS FOR ZZPRNT.

      DATA  GRAD /DGRAD/,  POINT /DPOINT/, PRINTL/DPRINT/
      DATA IGRAD /DIGRAD/, IPOINT/DIPT  /, LOCAL /DLOCAL/

C-----DEFAULTS FOR ZZTERM.

      DATA NORM  /DNORM/,  QUITS/DQUITS/
      DATA TTRACE/DTTRAC/, RELF /DRELF/, RELG/DRELG/

C-----DEFAULTS FOR ZZSTX0.

      DATA FACTOR /DFACTR/

C-----DEFAULT FOR SUBROUTINE AND COMMUNICATION.

      DATA  SUBR /DSUBR/, REVERS/DREVRS/

C-----DEFAULTS FOR SORT.

      DATA  ASC/DASC/

C-----FOR CRITERIA.
                   DATA LL/NL*BLANK/
C-----DEFAULTS FOR TITLE AND TITLE REQUIREMENT FOR PHASE 1.

      DATA  TITLE  /BLANK /
      DATA  TITREQ /DTITLR/

C-----CREATION OF STANDARD PART OF COMMAND DICTIONARY AND PARAMETERS.

      DATA  DEFNS /DEFN/

      DATA  CMDS /CCMDS/
      DATA  CPARS /CPAR/
      DATA  DPARS /DPAR/

C         # OF PARAMETERS    TYPE OF PARAMETER
      DATA
     -    CINF(XABORT,1)/  0   /,  CINF(XABORT,2)/TYNONE/,
     -    CINF(XACCUR,1)/MXPARS/,  CINF(XACCUR,2)/TYREAL/,
     -    CINF(XADD  ,1)/MXPARS/,  CINF(XADD  ,2)/TINTLT/,
     -    CINF(XARITH,1)/  1   /,  CINF(XARITH,2)/TYCHAR/,
     -    CINF(XASC  ,1)/  0   /,  CINF(XASC  ,2)/TLOGIC/,
     -    CINF(XASSMT,1)/  1   /,  CINF(XASSMT,2)/TYCHAR/,
     -    CINF(XBRIEF,1)/  0   /,  CINF(XBRIEF,2)/TLOGIC/,
     -    CINF(XBYE  ,1)/  0   /,  CINF(XBYE  ,2)/TYNONE/,
     -    CINF(XCC   ,1)/  1   /,  CINF(XCC   ,2)/TINTPW/

      DATA
     -    CINF(XCHECK,1)/  1   /,  CINF(XCHECK,2)/TINTPW/,
     -    CINF(XCOMME,1)/  2   /,  CINF(XCOMME,2)/TYCHAR/,
     -    CINF(XCONTI,1)/  1   /,  CINF(XCONTI,2)/TYCHAR/,
     -    CINF(XCOPY ,1)/  0   /,  CINF(XCOPY ,2)/TLOGIC/,
     -    CINF(XCRIT ,1)/  2   /,  CINF(XCRIT ,2)/TINTLT/,
     -    CINF(XDECOD,1)/  0   /,  CINF(XDECOD,2)/TLOGIC/,
     -    CINF(XDEFAU,1)/  0   /,  CINF(XDEFAU,2)/TYNONE/,
     -    CINF(XDEFIN,1)/  0   /,  CINF(XDEFIN,2)/TYNONE/,
     -    CINF(XDELIM,1)/  1   /,  CINF(XDELIM,2)/TYCHAR/,
     -    CINF(XDERIV,1)/  1   /,  CINF(XDERIV,2)/TINTPW/,
     -    CINF(XDESC ,1)/  0   /,  CINF(XDESC ,2)/TLOGIC/,
     -    CINF(XDOSUM,1)/  0   /,  CINF(XDOSUM,2)/TYNONE/

      DATA
     -    CINF(XDROP ,1)/MXPARS/,  CINF(XDROP ,2)/TINTLT/,
     -    CINF(XEND  ,1)/  0   /,  CINF(XEND  ,2)/TYNONE/,
     -    CINF(XEOF  ,1)/  1   /,  CINF(XEOF  ,2)/TINTPW/,
     -    CINF(XESCAP,1)/  1   /,  CINF(XESCAP,2)/TYCHAR/,
     -    CINF(XEVTRC,1)/  0   /,  CINF(XEVTRC,2)/TLOGIC/,
     -    CINF(XEXPNS,1)/MXPARS/,  CINF(XEXPNS,2)/TINTGR/,
     -    CINF(XFABS ,1)/  0   /,  CINF(XFABS ,2)/TLOGIC/,
     -    CINF(XFACTO,1)/MXPARS/,  CINF(XFACTO,2)/TYREAL/,
     -    CINF(XFORWO,1)/  0   /,  CINF(XFORWO,2)/TLOGIC/
      DATA
     -    CINF(XFREE ,1)/  1   /,  CINF(XFREE ,2)/TINTGR/,
     -    CINF(XFREL ,1)/  0   /,  CINF(XFREL ,2)/TLOGIC/,
     -    CINF(XFTRAC,1)/  0   /,  CINF(XFTRAC,2)/TLOGIC/,
     -    CINF(XGABS ,1)/  0   /,  CINF(XGABS ,2)/TLOGIC/,
     -    CINF(XGEOME,1)/  1   /,  CINF(XGEOME,2)/TYCHAR/,
     -    CINF(XGREL ,1)/  0   /,  CINF(XGREL ,2)/TLOGIC/,
     -    CINF(XGTRAC,1)/  0   /,  CINF(XGTRAC,2)/TLOGIC/,
     -    CINF(XIMMED,1)/  0   /,  CINF(XIMMED,2)/TLOGIC/,
     -    CINF(XINPUT,1)/  1   /,  CINF(XINPUT,2)/TINTLT/

      DATA
     -    CINF(XLIST ,1)/  2   /,  CINF(XLIST ,2)/TINTGR/,
     -    CINF(XLONGF,1)/  0   /,  CINF(XLONGF,2)/TLOGIC/,
     -    CINF(XMEMOR,1)/  1   /,  CINF(XMEMOR,2)/TINTGR/,
     -    CINF(XMODE ,1)/  1   /,  CINF(XMODE ,2)/TINTPW/,
     -    CINF(XNORM ,1)/  1   /,  CINF(XNORM ,2)/TINTPW/,
     -    CINF(XPGRAD,1)/  0   /,  CINF(XPGRAD,2)/TLOGIC/,
     -    CINF(XPOINT,1)/  0   /,  CINF(XPOINT,2)/TLOGIC/,
     -    CINF(XPRINT,1)/  1   /,  CINF(XPRINT,2)/TINTGR/,
     -    CINF(XQUIT ,1)/  0   /,  CINF(XQUIT ,2)/TYNONE/,
     -    CINF(XRADIX,1)/  1   /,  CINF(XRADIX,2)/TYCHAR/,
     -    CINF(XRENAM,1)/  2   /,  CINF(XRENAM,2)/TINTLT/,
     -    CINF(XREQUI,1)/  0   /,  CINF(XREQUI,2)/TLOGIC/

      DATA
     -    CINF(XRESET,1)/  0   /,  CINF(XRESET,2)/TYNONE/,
     -    CINF(XRESUL,1)/  1   /,  CINF(XRESUL,2)/TSTRNG/,
     -    CINF(XREVER,1)/  0   /,  CINF(XREVER,2)/TLOGIC/,
     -    CINF(XSEE  ,1)/  1   /,  CINF(XSEE  ,2)/TINTPW/,
     -    CINF(XSELCT,1)/  1   /,  CINF(XSELCT,2)/TINTGR/,
     -    CINF(XSEPAR,1)/  1   /,  CINF(XSEPAR,2)/TYCHAR/,
     -    CINF(XSORT ,1)/  1   /,  CINF(XSORT ,2)/TINTPW/,
     -    CINF(XSTART,1)/  1   /,  CINF(XSTART,2)/TINTPW/,
     -    CINF(XSTRIN,1)/  2   /,  CINF(XSTRIN,2)/TYCHAR/,
     -    CINF(XSUBRO,1)/  2   /,  CINF(XSUBRO,2)/TINTLT/,
     -    CINF(XSUMMA,1)/  0   /,  CINF(XSUMMA,2)/TLOGIC/

      DATA
     -    CINF(XTERM ,1)/NQUITS/,  CINF(XTERM ,2)/TYCHAR/,
     -    CINF(XTEX  ,1)/  0   /,  CINF(XTEX  ,2)/TLOGIC/,
     -    CINF(XTITLE,1)/  1   /,  CINF(XTITLE,2)/TSTRNG/,
     -    CINF(XTRACE,1)/ NTR  /,  CINF(XTRACE,2)/TYCHAR/,
     -    CINF(XTRCUN,1)/  1   /,  CINF(XTRCUN,2)/TSTRNG/,
     -    CINF(XTTRAC,1)/  0   /,  CINF(XTTRAC,2)/TLOGIC/,
     -    CINF(XUPPER,1)/  0   /,  CINF(XUPPER,2)/TLOGIC/,
     -    CINF(XUSER ,1)/MXPARS/,  CINF(XUSER ,2)/TYREAL/,
     -    CINF(XVALUE,1)/  1   /,  CINF(XVALUE,2)/TINTPW/,
     -    CINF(XVERIF,1)/  0   /,  CINF(XVERIF,2)/TLOGIC/,
     -    CINF(XWATCH,1)/  0   /,  CINF(XWATCH,2)/TLOGIC/,
     -    CINF(XWITH ,1)/MXPARS/,  CINF(XWITH ,2)/TINTPW/

C-----PARAMETER KEYWORDS FOR COMMAND DICTIONARY.

C        KEYWORD INDEX        INTEGER VALUE
      DATA
     - CPINF(ZABSSU,1)/XNORM /, CPINF(ZABSSU,2)/NL1   /,
     - CPINF(ZACTIV,1)/XEOF  /, CPINF(ZACTIV,2)/CEOFAC/,
     - CPINF(ZALL  ,1)/XVALUE/, CPINF(ZALL  ,2)/CALL  /,
     - CPINF(ZANALY,1)/XDERIV/, CPINF(ZANALY,2)/CANAL /,
     - CPINF(ZASIS ,1)/XSORT /, CPINF(ZASIS ,2)/SASIS /,
     - CPINF(ZBATCH,1)/XMODE /, CPINF(ZBATCH,2)/CBATCH/,
     - CPINF(ZCONTR,1)/XVALUE/, CPINF(ZCONTR,2)/CCONTR/,
     - CPINF(ZDIFFE,1)/XDERIV/, CPINF(ZDIFFE,2)/CDIFF /,
     - CPINF(ZDIMEN,1)/XSORT /, CPINF(ZDIMEN,2)/SDIMN /

      DATA
     - CPINF(ZEUCLI,1)/XNORM /, CPINF(ZEUCLI,2)/NL2   /,
     - CPINF(ZFIRST,1)/XDERIV/, CPINF(ZFIRST,2)/CFIRST/,
     - CPINF(ZFNAME,1)/XSORT /, CPINF(ZFNAME,2)/SFNNAM/,
     - CPINF(ZFNO  ,1)/XSORT /, CPINF(ZFNO  ,2)/SFNNUM/,
     - CPINF(ZFNUMB,1)/XSORT /, CPINF(ZFNUMB,2)/SFNNUM/,
     - CPINF(ZFROBE,1)/XNORM /, CPINF(ZFROBE,2)/NL2   /,
     - CPINF(ZFULL ,1)/XSEE  /, CPINF(ZFULL ,2)/CFULL /,
     - CPINF(ZGO   ,1)/XSTART/, CPINF(ZGO   ,2)/CGOGO /,
     - CPINF(ZIGNOR,1)/XEOF  /, CPINF(ZIGNOR,2)/CEOFIG/

      DATA
     - CPINF(ZINFIN,1)/XNORM /, CPINF(ZINFIN,2)/NLINF /,
     - CPINF(ZINPUT,1)/XVALUE/, CPINF(ZINPUT,2)/CINPUT/,
     - CPINF(ZINTER,1)/XMODE /, CPINF(ZINTER,2)/CINTAC/,
     - CPINF(ZLOOPS,1)/XVALUE/, CPINF(ZLOOPS,2)/CLOOPS/,
     - CPINF(ZL1   ,1)/XNORM /, CPINF(ZL1   ,2)/NL1   /,
     - CPINF(ZL2   ,1)/XNORM /, CPINF(ZL2,   2)/NL2   /,
     - CPINF(ZMAXIM,1)/XNORM /, CPINF(ZMAXIM,2)/NLINF /,
     - CPINF(ZMEDIM,1)/XSEE  /, CPINF(ZMEDIM,2)/CMED  /,
     - CPINF(ZMINIM,1)/XSEE  /, CPINF(ZMINIM,2)/CMIN  /,
     - CPINF(ZMISSI,1)/XCC   /, CPINF(ZMISSI,2)/CCMISS/

      DATA
     - CPINF(ZNAMES,1)/XCHECK/, CPINF(ZNAMES,2)/CHNAM /,
     - CPINF(ZNO   ,1)/XSTART/, CPINF(ZNO   ,2)/CNOGO /,
     - CPINF(ZNONE ,1)/XSEE  /, CPINF(ZNONE ,2)/CNONE /,
     - CPINF(ZNULL ,1)/XEOF  /, CPINF(ZNULL ,2)/CEOFIG/,
     - CPINF(ZNUMBE,1)/XCHECK/, CPINF(ZNUMBE,2)/CHNUM /,
     - CPINF(ZOFF  ,1)/XCHECK/, CPINF(ZOFF  ,2)/CHOFF /,
     - CPINF(ZOK   ,1)/XSTART/, CPINF(ZOK   ,2)/CGOGO /,
     - CPINF(ZON   ,1)/XCHECK/, CPINF(ZON   ,2)/CHON  /,
     - CPINF(ZPNAME,1)/XSORT /, CPINF(ZPNAME,2)/SPRNAM/,
     - CPINF(ZPNO  ,1)/XSORT /, CPINF(ZPNO  ,2)/SPRNUM/,
     - CPINF(ZPNUMB,1)/XSORT /, CPINF(ZPNUMB,2)/SPRNUM/

      DATA
     - CPINF(ZPRESE,1)/XCC   /, CPINF(ZPRESE,2)/CCPRSN/,
     - CPINF(ZPROLG,1)/XSORT /, CPINF(ZPROLG,2)/SRECNO/,
     - CPINF(ZRECNO,1)/XSORT /, CPINF(ZRECNO,2)/SRECNO/,
     - CPINF(ZRUN  ,1)/XSTART/, CPINF(ZRUN  ,2)/CGOGO /,
     - CPINF(ZSUPRE,1)/XNORM /, CPINF(ZSUPRE,2)/NLINF /,
     - CPINF(ZTESTM,1)/XDERIV/, CPINF(ZTESTM,2)/CTEST /,
     - CPINF(ZYES  ,1)/XSTART/, CPINF(ZYES  ,2)/CGOGO /

C-----CREATION OF CONTROL PART OF THE DEFINITION DICTIONARY.

C         # OF PARAMETERS    TYPE OF PARAMETER
      DATA
     -  DINF(QADD  ,1)/MXPARS/,  DINF(QADD  ,2)/TINTLT/,
     -  DINF(QARG  ,1)/MXPARS/,  DINF(QARG  ,2)/TYREAL/,
     -  DINF(QDEFN ,1)/  0   /,  DINF(QDEFN ,2)/TYNONE/,
     -  DINF(QDESCR,1)/  1   /,  DINF(QDESCR,2)/TSTRNG/,
     -  DINF(QDIMEN,1)/MXPARS/,  DINF(QDIMEN,2)/TINTGR/,
     -  DINF(QDROP ,1)/MXPARS/,  DINF(QDROP ,2)/TINTLT/,
     -  DINF(QEND  ,1)/  0   /,  DINF(QEND  ,2)/TYNONE/,
     -  DINF(QEXPNS,1)/MXPARS/,  DINF(QEXPNS,2)/TINTGR/,
     -  DINF(QFUNCT,1)/  2   /,  DINF(QFUNCT,2)/TINTLT/,
     -  DINF(QGROUP,1)/  2   /,  DINF(QGROUP,2)/TINTLT/
      DATA
     -  DINF(QLIMIT,1)/  1   /,  DINF(QLIMIT,2)/TINTGR/,
     -  DINF(QMAX  ,1)/  1   /,  DINF(QMAX  ,2)/TINTGR/,
     -  DINF(QN    ,1)/MXPARS/,  DINF(QN    ,2)/TINTGR/,
     -  DINF(QPERMA,1)/  0   /,  DINF(QPERMA,2)/TYNONE/,
     -  DINF(QPROBL,1)/  2   /,  DINF(QPROBL,2)/TINTLT/,
     -  DINF(QSCALE,1)/  1   /,  DINF(QSCALE,2)/TINTGR/,
     -  DINF(QSELCT,1)/  1   /,  DINF(QSELCT,2)/TINTGR/,
     -  DINF(QSOLN ,1)/MXPARS/,  DINF(QSOLN ,2)/TYREAL/,
     -  DINF(QSTART,1)/MXPARS/,  DINF(QSTART,2)/TYREAL/,
     -  DINF(QTEMP ,1)/  0   /,  DINF(QTEMP ,2)/TYNONE/,
     -  DINF(QUSE  ,1)/  1   /,  DINF(QUSE  ,2)/TINTLT/,
     -  DINF(QX    ,1)/MXPARS/,  DINF(QX    ,2)/TYREAL/

      DATA
     - DPINF(1,1)/  0   /, DPINF(  1,2)/  9/

C-----DECLARE HEADINGS FOR PROMPTS.

      DATA PROMPT(1) / ' (1) TITLE LINE? (OR "END")' /
      DATA PROMPT(2) / ' (2) CONTROL INFORMATION?' /
      DATA PROMPT(3) / ' (3) USER PARAMETERS?' /
      DATA PROMPT(4) / ' (4) WHICH PROBLEMS?' /
      DATA PROMPT(5) / ' (5) READY?' /
      DATA PROMPT(6) / ' ERROR CORRECTION IS :' /
      DATA PROMPT(7) / ' ENTER MORE:' /
      DATA PROMPT(8) / ' COMMANDS, THEN "RUN":' /
      DATA PROMPT(9) / ' COMMANDS, IMMEDIATE RUN:' /

C-----STRINGS FOR OUTPUT.


      DATA   CNORM(NL1)  /'ABS SUM   '/, CTYPE(PGRAD)/'GRADIENT  '/
      DATA   CNORM(NL2)  /'EUCLIDEAN '/, CTYPE(PSTEP)/'STEPSIZE  '/
      DATA   CNORM(NLINF)/'MAXIMUM   '/, CTYPE(PSHXG)/'SHANNOXG  '/
      DATA                               CTYPE(PFUNC)/'FUNCTION  '/

      DATA   CDERV(CANAL)/'ANALYTIC  '/, VSORT(SPRNAM)/'PROB NAME '/
      DATA   CDERV(CDIFF)/'DIFFERENCE'/, VSORT(SPRNUM)/'PROB NUMB '/
      DATA   CDERV(CTEST)/'TESTMODE  '/, VSORT(SASIS )/'AS IS     '/
      DATA   CDERV(CFIRST)/'FIRSTSTEP'/, VSORT(SRECNO)/'RECORD NO.'/
      DATA                               VSORT(SFNNAM)/'FUNC NAME '/
      DATA                               VSORT(SFNNUM)/'FUNC NUMB '/
      DATA                               VSORT(SDIMN )/'DIMENSION '/

      DATA   VCC (CCPRSN)/'PRESENT   '/  VCC  (CCMISS)/'MISSING   '/

      DATA   VCHEC(CHOFF)/'OFF       '/, VSEE (CNONE )/'NONE      '/
      DATA   VCHEC(CHON )/'ON        '/, VSEE (CMIN  )/'MINIMAL   '/
      DATA   VCHEC(CHNAM)/'NAMES     '/, VSEE (CMED  )/'MEDIUM    '/
      DATA   VCHEC(CHNUM)/'NUMBERS   '/, VSEE (CFULL )/'FULL      '/

C##                                            E X E C U T I O N
C##                                            E X E C U T I O N
C-----               FUNCTION STATEMENT.
      RD(I) = DBLE(I)
C!!!! RD(I) = REAL(I)
C-----               TIME THE WHOLE RUN.
      CALL ZZSECS (TIMEIT)

      TODO(CCOLD)  = F
      TODO(CDOFLE) = F
      TODO(CDOTRM) = F

C-----             DEFINE 'PARAMETER' ARRAYS I.E. ARRAYS OF CONSTANTS.
      DO 110 I = 1, NU
         PTUSER(I) = NOUTER + I
  110 CONTINUE
      DO 120 I = 1, FNO
         PTFARG(I) = NINNER + I
  120 CONTINUE
C--                      POINTERS FOR SORTING
      DO 130 I = 1, NCMDS
         INVMP1(I) = I
  130 CONTINUE
      CALL ZZDSRT(CMDS,CINF,NCMDS,KEYLEN,MAP1,INVMP1,1,T,S1,S2)
      DO 140 I = 1, NDEFS
         INVMP2(I) = I
  140 CONTINUE
      CALL ZZDSRT(DEFNS,DINF,NDEFS,KEYLEN,MAP2,INVMP2,1,T,S1,S2)
      DO 150 I = 1, NCPARS
         INVMP3(I) = I
  150 CONTINUE
      CALL ZZDSRT(CPARS,CPINF,NCPARS,KEYLEN,MAP3,INVMP3,1,T,S1,S2)

C-----                         DEFINE REMOTE BLOCKS.
      ASSIGN  81000  TO  REMOT1
      ASSIGN  82000  TO  REMOT2
      ASSIGN  84000  TO  REMOT4
      ASSIGN  85000  TO  REMOT5
      ASSIGN  87000  TO  REMOT7
      ASSIGN   2900  TO  RETRN4
      ASSIGN   2900  TO  RETRN7
C---                        SET DEFAULTS FOR BASIC VALUES.
      ASSIGN  600  TO RETRN1
                 GOTO REMOT1
  600 CONTINUE
C                           INITIALIZE OUTER LOOPS AND USER PARAMETERS
      ASSIGN  700  TO RETRN2
                 GOTO REMOT2
  700 CONTINUE
C-----                         EXISTENCE OF A BATCH FILE?

      CALL ZZOPEN ( PREPRC, T, NMBATC, *160, RECL )

C                          SUCCESS: SET MODE TO BATCH AND PROCEED
C                          WITH INPUT TO BE FROM THE BATCH FILE.
      CALL ZZCLSE ( PREPRC, *91000 )
      INTACT = F
      BRIEF  = T
      IMMED  = T
      RPSOUT = COPYUN
      NMTRMO = NMCOPY
      NEXTUN = PREPRC
      NMNEXT = NMBATC
      GOTO 180
C               FAILED: ASSUME INTERACTIVE SESSION.
  160           CONTINUE
      INTACT = T
      BRIEF  = F
      IMMED  = F
      RPSOUT = TRMOUT
      NMTRMO = DNTRMO
      NEXTUN = STDIN
      NMNEXT = NMTRMI
  180                CONTINUE
      CALL ZZOPEN ( RPSOUT, T, NMTRMO, *91000, RECL )
      CALL ZZETRM ( INTACT, RPSOUT )
C-----                              INITIALIZE SUBROUTINES.
C  ZZADDP
         CALL ZZASET ( DCC(RADIX: RADIX ), DCC(RADPRB:RADPRB),
     -                 DCC(RADFUN:RADFUN), DCC(RADGRP:RADGRP))
C  ZZDCOD
         CALL ZZDSET (DCC)

C                  START BY READING PROLOG FILE.
      TITREQ = T
      NMCURR = NMPRLG
      READUN = PREPRC
      CALL ZZOPEN ( PREPRC, T, NMPRLG, *900, RECL )
          NOPRLG = F
          GOTO  950
  900 CALL ZZERRM ( TM, *91000,'NT WARNING: THERE IS NO PROLOG FILE.')
          NOPRLG = T
  950 TRMRD  = F

C >==================================>>COMMAND INPUT SECTION
 1000             CONTINUE
      PHASE  = 0
      TITLE  = BLANK
      LASTLN = NULLIN
      LNO    = RGL
      IF ( NOPRLG ) THEN
          FAKEIT = T
      ELSE
          FAKEIT = F
      ENDIF

C OBTAIN ANOTHER LINE OF INPUT FROM READUN

 2000 IF ( DCDMOD .NE. DCDBAD ) THEN
C                                    GET NEW LINE
         IF ( FAKEIT ) THEN
C                      A KLUDGE TO AVOID JUMP INTO LOOP WHEN
C                      THERE IS NO INITIAL PROLOG FILE.
             FAKEIT = F
             GOTO 2060
         ENDIF
         RDERCT = 0
         IF ( DCDMOD .EQ. DCDCON ) THEN
            SVPHAS = PHASE
            PHASE  = 7
         ELSE IF (DCDMOD .EQ. DCDERR ) THEN

            ERRCNT = ERRCNT + 1
            IF ( ERRCNT .LT. MAXERR ) THEN
               CALL ZZERRM ( TM, *91000,
     -                      'NS STRING IN ERROR IS :'//LL(ERL))
               CALL ZZOPEN ( STDIN, T, NMTRMI, *91000, RECL )
               SAVUNT = READUN
               READUN = STDIN
               SVPHAS = PHASE
               PHASE  = 6
               LL(ERL) = LL(LNO)
               II = MIN( INLINE, INLINE-(ZZLENG(LL(ERL))-LINELN))
               KK = LINELN
            ELSE
               WRITE (RPSOUT,'(A)')' STRING IN ERROR WILL BE IGNORED'
               IF ( COPY ) THEN
                 WRITE (COPYUN,'(A)')' STRING IN ERROR WILL BE IGNORED'
               ENDIF
               IF ( LINELN .LT. INLINE ) THEN
                  CALL ZZSHFT ( LL(LNO), LINELN+1, 1, INLINE )
                  LINELN = ZZLENG( LL(LNO) )
               ELSE
                  LL(LNO) = BLANK
                  LINELN = 0
               ENDIF
               GOTO 2100
            ENDIF
         ENDIF

 2020    IF ( TRMRD ) THEN
            IF ( DCDMOD .EQ. DCDCON .OR.
     -           DCDMOD .EQ. DCDERR ) THEN
                  WRITE ( RPSOUT, '(A)' ) PROMPT(PHASE)
                  IF ( COPY ) WRITE ( COPYUN, '(1X,A)' ) PROMPT(PHASE)
            ELSE IF ( BRIEF ) THEN
               IF ( IMMED ) THEN
                  WRITE ( RPSOUT, '(A)' ) PROMPT(9)
                  IF ( COPY ) WRITE ( COPYUN, '(1X,A)' ) PROMPT(9)
               ELSE
                  WRITE ( RPSOUT, '(A)' ) PROMPT(8)
                  IF ( COPY ) WRITE ( COPYUN, '(1X,A)' ) PROMPT(8)
               ENDIF
               PHASE = 5
            ELSE
               IF ( TITREQ .AND. TITLE .EQ. BLANK ) THEN
                  PHASE = 1
               ELSE IF ( PHASE .EQ. 5  ) THEN
                   IF ( CHECK ) THEN
C                                   PRINT THE CURRENT LIST
                      IF (  TRMRD .AND. NPROBS .NE. 0 ) THEN
C                                              SORT IF NECESSARY.
                         IF ( SORTFL .AND. SORT .NE. SASIS ) THEN
                            SORTFL = F
                            CALL ZZSORT (SORT,LIST,NPROBS,PRECNO,
     -                                   NAMES,PNAMLN,ASC)
                         ENDIF
                         WRITE ( RPSOUT, * )
                         IF ( COPY ) WRITE ( COPYUN, * )
                         IF ( LISTCD .EQ. CHNUM ) THEN
                            WRITE(RPSOUT,'(1X,I3,A,16I4/,(14X,16I4))')
     -                        NPROBS,' PROBLEMS:',(LIST(I),I=1,NPROBS)
                            IF ( COPY ) THEN
                            WRITE(COPYUN,'(1X,I3,A,16I4/,(14X,16I4))')
     -                        NPROBS,' PROBLEMS:',(LIST(I),I=1,NPROBS)
                            ENDIF
                         ELSE IF ( LISTCD .EQ. CHNAM ) THEN
                            J = PNAMLN + FNAMLN
                            WRITE(RPSOUT,'(1X,I3,A,2X,7A9/(16X,7A9))')
     -                      NPROBS,' PROBLEMS:',(NAMES((LIST(I)-1)*J+1
     -                                : LIST(I)*J-FNAMLN), I=1,NPROBS)
                            IF ( COPY ) THEN
                            WRITE(COPYUN,'(1X,I3,A,2X,7A9/(16X,7A9))')
     -                      NPROBS,' PROBLEMS:',(NAMES((LIST(I)-1)*J+1
     -                                : LIST(I)*J-FNAMLN), I=1,NPROBS)
                            ENDIF
                         ENDIF
                      ENDIF
                   ENDIF
               ENDIF
               WRITE ( RPSOUT, '(A)' ) PROMPT(PHASE)
               IF (COPY) WRITE ( COPYUN, '(A)' ) PROMPT(PHASE)
            ENDIF
         ENDIF

 2025    IF ( DCDMOD .EQ. DCDCON .OR. DCDMOD .EQ. DCDERR ) THEN
            PHASE  = SVPHAS
         ENDIF

         READ ( READUN, '(A)' , END=2060, ERR=2030 ) LL(LNO)

         IF ( UPCASE ) THEN
            CALL ZZCASE ( LL(LNO), CTOUPP )
         ENDIF
         LINELN = ZZLENG (LL(LNO))
         IF (COPY .AND. TRMRD) WRITE (COPYUN,'(A)') LL(LNO)(1:LINELN)

         EOPH   = F

         IF ( DCDMOD .EQ. DCDERR ) THEN
            READUN = SAVUNT
            JJ     = MIN ( II, LINELN )
            IF ( JJ .NE. LINELN ) THEN
               CALL ZZERRM ( RD(II), *91000, 'NS DROPPED CHARACTERS : '
     -                      //LL(LNO)(II+1:LINELN) )
            ENDIF
            IF ( II .NE. INLINE ) THEN
               LL(LNO)(JJ+1:INLINE) = LL(ERL)(KK+1:INLINE)
               LINELN = JJ + (INLINE - II)
            ENDIF
         ENDIF

         IF ( DCDMOD .NE. DCDCON .AND. DCDMOD .NE. DCDERR ) THEN
            DCDMOD = DCDNEW
         ENDIF
         GOTO 2100

C----                HANDLE READ ERRORS
 2030    CALL ZZERRM ( RD(READUN), *91000, 'IS READ ERROR ON UNIT ')
         RDERCT = RDERCT + 1
         IF (RDERCT .LE. RDERMX ) THEN
             GOTO 2020
         ELSE
             GOTO 91000
         ENDIF
C----                            END OF FILE
 2060                    CONTINUE
        IF ( TRMRD ) THEN
            IF ( EOFBLK ) THEN
               CALL ZZCLSE ( STDIN , *91000 )
               CALL ZZOPEN ( STDIN , T,  NMTRMI, *91000, RECL )
               LINELN = 0
            ELSE
               WRITE ( RPSOUT, '(A)' )' TERMINATING ON EOF '
               IF ( COPY ) WRITE(COPYUN,'(A)')' TERMINATING ON EOF '
               GOTO 90000
            ENDIF
         ELSE
            IF ( DCDMOD .EQ. DCDCON ) THEN
               CALL ZZERRM(RD(READUN),*90000,'IT END OF FILE, UNIT ')
               CALL ZZERRM(RD(READUN), *91000,
     -                     'IS MISSING CONTINUATION LINE ON UNIT ' )
            ENDIF
            IF      ( NMCURR .EQ. NMPRLG ) THEN
               WRITFL = PRINTL .NE. 0
               CHECK  = LISTCD .NE. CHOFF
C                                              INITIALIZE SUBR'S.
C                   ZZEVAL
               CALL ZZESET ( TRF, TRG, TRG, TRCOUT )
C                   ZZTERM
               CALL ZZTSET ( NORM, QUITS, TTRACE, TRCOUT )
C                   ZZPUTP, ZZGETP, ZZPUTG, ZZGETG
C                                      RECORD LENGTH OF DAUF FILE
               RECLEN = ZZRECL ( CPERLN, IPERLN, LPERLN, RPERLN)
               CALL ZZPDEF ( CPERLN, IPERLN, RPERLN, PTNDIM )
               CALL ZZDEFP ( IPERLN )
               CALL ZZGDEF ( CPERLN, IPERLN, RPERLN )
               CALL ZZDEFG ( IPERLN )
               DO 2061 I = 1,MXGRPS
                  GROUPS(I) = -1
 2061          CONTINUE

C                                      CHECK FOR EXISTENCE OF DAUF.
               CALL ZZOPEN ( DAUF, T, NMDAUF, *2063, RECLEN )
                  GOTDAF = T
                  GOTO 2064
 2063          CONTINUE
                  GOTDAF = F
 2064          CONTINUE
               IF (GOTDAF) THEN
C                                RESTORE DATA AND PROCEED.
                  RECNO  = 1
                  CALL ZZRDIN ( DAUF, IW, 2, IPERLN, RECNO )
                  RECNO  = IW(1)
                  RECP   = IW(2)
                  FREEPT = RECP
                  CALL ZZRDIN ( DAUF, PRECNO,3*DFPRBS,IPERLN,RECNO)
                  CALL ZZRDCH ( DAUF, NAMES,(PNAMLN+FNAMLN)*DFPRBS,
     -                                             CPERLN, RECNO )
                  PRMISS = T
                  DO 2067 I = 1, DFPRBS
                      IF ( PRECNO(1,I) .NE. -1 ) PRMISS = F
 2067             CONTINUE
                  NMCURR = NMGRPS
                  CALL ZZCLSE( PREPRC, *2068)
                  GOTO 2070
 2068             CALL ZZERRM(RD(PREPRC),*91000,'NS SOMETHING IS WRONG:'
     -                                      //' CAN NOT CLOSE '//NMPRLG)
 2070             IF ( .NOT. PRMISS ) THEN
                      CALL ZZOPEN ( PREPRC, T,  NMGRPS, *2080, RECL )
                      GOTO 2083
 2080                 CALL ZZERRM(RD(PREPRC),*90000,
     -                                         'NT NO GROUPS DEFINED')
                  ELSE
                      CALL ZZERRM(RD(I),*2082,'NT NO PROBLEMS DEFINED'
     -                       //' SO IGNORING GROUPS FILE.')
 2082                 CONTINUE
                  ENDIF
                  NPROBS = 0
                  READUN = NEXTUN
                  TRMRD  = READUN .EQ. STDIN
C                                        OPEN THE NEXT INPUT UNIT.
                  CALL ZZOPEN ( READUN, T,  NMNEXT, *91000, RECL )
 2083             CONTINUE
               ELSE
C                 DETERMINE THE RECORD NUMBER FOR THE FIRST PROBLEM
C                 PROBLEMS START IN RECORD 2. THE OTHER DATA FOLLOWS.
C                 RECORD 1 CONTAINS NUMBER WHERE OTHER DATA STARTS.
                  RECP = 2
C                                    INITIALIZE THE PRECNO ARRAY.
                  DO 2084 I=1,DFPRBS
                     PRECNO(RECN,I) = -1
 2084             CONTINUE

                  NMCURR = NMPROB
                  CALL ZZCLSE( PREPRC, *2085 )
                  GOTO 2086
 2085             CALL ZZERRM(RD(PREPRC),*91000,'NS SOMETHING IS WRONG:'
     -                                      //' CAN NOT CLOSE '//NMPRLG)
 2086             CALL ZZOPEN ( PREPRC, T,  NMPROB, *2087, RECL )
                  IF (INTACT) THEN
                     WRITE(RPSOUT,'(A)') ' ************************'
                     WRITE(RPSOUT,'(A)') ' * READING PROBLEM DATA *'
                     WRITE(RPSOUT,'(A)') ' ************************'
                  ENDIF
                  GOTO 2089
 2087             CALL ZZERRM(RD(PREPRC),*90000,'NT WARNING: NO '
     -                      //'PROBLEMS ARE DEFINED IN FILE '//NMPROB)
                  PRMISS = T
                  GOTO 2060
 2089             CONTINUE
               ENDIF
            ELSE IF ( NMCURR .EQ. NMPROB ) THEN
               RECNO = 1
               IW(1) = RECP
               IW(2) = 0
               CALL ZZWRIN ( DAUF, IW, 2, IPERLN, RECNO )
               RECNO = RECP
               CALL ZZWRIN ( DAUF, PRECNO,3*DFPRBS,IPERLN,RECNO)
               CALL ZZWRCH ( DAUF, NAMES, (PNAMLN+FNAMLN)*DFPRBS,
     -                                                  CPERLN,RECNO)
               RECP   = RECNO
               FREEPT = RECP
               NMCURR = NMGRPS
               CALL ZZCLSE( PREPRC, *2090 )
               GOTO 2091
 2090          CALL ZZERRM(RD(PREPRC),*91000,'NS SOMETHING IS WRONG:'
     -                                   //' CAN NOT CLOSE '//NMPROB)
 2091          IF ( .NOT. PRMISS ) THEN
                   CALL ZZOPEN ( PREPRC, T,  NMGRPS, *2092, RECL )
                   GOTO 2093
 2092              CALL ZZERRM(RD(PREPRC),*90000,'NT NO GROUPS')
                ELSE
                   CALL ZZERRM(RD(I),*2093,'NT NO PROBLEMS DEFINED'
     -                       //' SO IGNORING GROUPS FILE.')
                ENDIF
 2093           CONTINUE
                NPROBS = 0
                READUN = NEXTUN
                TRMRD  = READUN .EQ. STDIN
C                                        OPEN THE NEXT INPUT UNIT.
                CALL ZZOPEN ( READUN, T,  NMNEXT, *91000, RECL )
            ELSE IF ( NMCURR .EQ. NMGRPS ) THEN
               NPROBS = 0
               NMCURR = NMNEXT
               READUN = NEXTUN
               TRMRD  = READUN .EQ. STDIN
C                                        OPEN THE NEXT INPUT UNIT.
               CALL ZZCLSE( PREPRC, *2094 )
               GOTO 2095
 2094          CALL ZZERRM(RD(PREPRC),*91000,'NS SOMETHING IS WRONG:'
     -                                   //' CAN NOT CLOSE '//NMGRPS)
 2095          CALL ZZOPEN ( READUN, T,  NMNEXT, *91000, RECL )
            ELSE
               CALL ZZERRM(RD(READUN),*90000,'IT END OF FILE, UNIT ')
               CALL ZZCLSE( PREPRC, *2096 )
               GOTO 2097
 2096          CALL ZZERRM(RD(PREPRC),*91000,'NS SOMETHING IS WRONG:'
     -                                   //' CAN NOT CLOSE '//NMCURR)
 2097          READUN = NEXTUN
               NMCURR = NMNEXT
               TRMRD  = READUN .EQ. STDIN
               CALL ZZOPEN ( READUN, T,  NMNEXT, *91000, RECL )
            ENDIF
            CONTINUE
         ENDIF
         LL(LNO)   = BLANK
         LINELN = 0
         GOTO 2000
      ENDIF

C---- NOW DECODE TO GET NEXT PARAMETER.

 2100 IF ( DCDMOD .NE. DCDCON ) THEN
C                                   SET DEFAULT KEYWORDS
         PARCT = MXPARS
         IF ( DEFNMD .EQ. CMODE ) THEN
            IF      ( PHASE .EQ. 1 ) THEN
               KEYNO = MAP1( XTITLE   )
            ELSE IF ( PHASE .EQ. 2 ) THEN
               KEYNO = MAP1( XACCUR   )
            ELSE IF ( PHASE .EQ. 3 ) THEN
               KEYNO = MAP1( XXLAST+1 )
            ELSE IF ( PHASE .EQ. 4 ) THEN
               KEYNO = MAP1( XADD     )
            ELSE IF ( PHASE .EQ. 5 ) THEN
               KEYNO = MAP1( XSTART   )
            ENDIF
         ELSE
            KEYNO = MAP2(QUSE)
         ENDIF
      ENDIF

      IF ( DEFNMD .EQ. CMODE ) THEN
         CALL ZZDCOD ( DCDMOD, LL, LINELN, LNO, EOPH, VERIFY, RPSOUT,
     -        KEYNO,   CMDS,  CINF,  NCMDS, CPARS,   CPINF,  NCPARS,
     -        KEYSTR, PARS,   PARCT, LASTDL, INTACT, DCTRAC, TRCOUT,
     -        MAP1, UPCASE, *90000 )
      ELSE
         CALL ZZDCOD ( DCDMOD, LL, LINELN, LNO, EOPH, VERIFY, RPSOUT,
     -        KEYNO,   DEFNS,    DINF,  NDEFS, DPARS,  DPINF, NDPARS,
     -        KEYSTR, PARS,   PARCT, LASTDL, INTACT, DCTRAC, TRCOUT,
     -        MAP2, UPCASE, *90000 )

      ENDIF
      IF ( DCTRAC ) THEN
         IF ( KEYNO .GT. 0 ) THEN
            I=(KEYNO-1)*KEYLEN
         ELSE
            I = 1
         ENDIF
         IF ( DEFNMD .EQ. CMODE) THEN
            WRITE(RPSOUT,*)'RETURN FROM DCOD:'//
     -             ' KEYNO=',KEYNO,'<',CMDS(I+1:I+KEYLEN),'>'
         ELSE
            WRITE(RPSOUT,*)'RETURN FROM DCOD:'//
     -             ' KEYNO=',KEYNO,'<',DEFNS(I+1:I+KEYLEN),'>'
         ENDIF
         WRITE(RPSOUT,*)'PARCT=',PARCT,' PARS=<',(PARS(I),I=1,PARCT),'>'
         WRITE(RPSOUT,*)'       KEYSTR=',('<',KEYSTR(I),'>',I=1,PARCT)
      ENDIF

C                                   DETERMINE RESPONSE FROM DECODE.
      IF ( DCDMOD .EQ. DCDERR ) THEN
C                                    REQUEST ERROR CORRECTION.
         GOTO 2000
      ELSE
         ERRCNT = 0
      ENDIF

      IF ( DCDMOD .EQ. DCDCON ) THEN
C                                       GET LINE CONTINUATION.
          GOTO 2000
      ELSEIF ( KEYNO .EQ. 0 ) THEN
C                                  BLANK LINE ENCOUNTERED - IGNORE.
         GOTO 2900
      ENDIF

C                               ALL IS OK, SO CONTINUE WITH PROCESSING.
C     --EXTRACT FIRST PARAMETER.

      IF ( DEFNMD .EQ. CMODE ) THEN
         IPTYPE = CINF( KEYNO,2 )
         KEYNO  = INVMP1( KEYNO )
      ELSE
         IPTYPE = DINF( KEYNO,2 )
         KEYNO  = INVMP2( KEYNO )
      ENDIF

      IF ( PARCT .GT. 0 ) THEN
         PAR1 = PARS  (1)
         S1   = KEYSTR(1)
      ELSE
         S1 = BLANK
         IF ( IPTYPE .EQ. TYREAL .OR. IPTYPE .EQ. TINTGR .OR.
     -        IPTYPE .EQ. TINTPW .OR. IPTYPE .EQ. TINTLT      ) THEN
            PAR1 = DFLT
         ELSEIF ( IPTYPE.EQ.TYCHAR ) THEN
            IF ( KEYNO .NE. XCOMME ) THEN
               CALL ZZERRM ( RD(I), *91000,
     -             'NS MISSING PARAMETER ON DECODE RETURN' )
               DCDMOD = DCDERR
               GOTO 2000
            ENDIF
         ENDIF
      ENDIF

      IF ( DEFNMD .NE. CMODE ) THEN
C                       PROCESS THE PROBLEM OR GROUP INFORMATION
         IF ( KEYNO .EQ. QADD   .OR. KEYNO .EQ. QDROP  ) THEN
C                                           ADD OR DROP PROBLEM.
            IF ( PARCT .GT. 0 ) THEN

               CALL ZZADDP ( KEYNO .EQ. QADD, KEYSTR, PARS, PARCT,
     -                   GMEMBS, GRPSZ, MXGSZ, PRECNO, NAMES, DFPRBS,
     -                   GROUPS, GNAMES, MXGRPS, G1, *91000          )
            ELSE
               CALL ZZERRM ( TM,  *91000,
     -            'NT ADD OR DROP WITH NO PROBLEMS GIVEN'  )
            ENDIF

         ELSE IF ( KEYNO .EQ. QARG ) THEN
C                                          SET FUNCTION PARAMETER
              OUTER = F
              OSCAL = 0
              IF ( ARGNO .NE. 0 ) THEN
                 SEPART = F
                 OINDEX = PTFARG(ARGNO)
              ELSE
                 SEPART = T
                 OINDEX = PTFARG(1)
              ENDIF
              ASSIGN  2900  TO  RETRN5
                                GOTO  REMOT5

         ELSE IF ( KEYNO .EQ. QDEFN  ) THEN
C                        SAVE THE OLD PROBLEM OR GROUP, DEFINE A NEW ONE

            IF ( DEFNMD .EQ. PMODE ) THEN
C                                        STORE THE PROBLEM
               CALL ZZPUTP( DAUF,  PPNUM, PFNUM,  PPNAM,  PFNAM, PDESC,
     -                      SOLNS, PINTS, IORDER, ILOOPX, ILOOPC,
     -                      X, NAMES, PRECNO, RECP, ERRFLG, *91000 )
            ELSE
C                                        STORE THE GROUP
               CALL ZZPUTG( DAUF, PGNUM, PGNAM, GRPSZ, GMEMBS, GNAMES,
     -                      GROUPS, RECP, ERRFLG, *91000        )
            ENDIF

            DEFNMD = PMODE

C             SET PROBLEM DEFAULT VALUES
            GOTO  REMOT4

         ELSE IF ( KEYNO .EQ. QDESCR ) THEN
C                                     SET PROBLEM DESCRIPTON
            PDESC = LL(SVL)
            LDESC = ZZLENG( PDESC )

         ELSE IF ( KEYNO .EQ. QDIMEN  .OR.  KEYNO .EQ. QN ) THEN
C                                          SET THE DIMENSION(S)
              IF ( PARCT .EQ. 0 ) THEN
                 PAR1 = DNDIM
              ENDIF

              OUTER = F
              OSCAL = 2
              OINDEX = PTNDIM
              ASSIGN  2900  TO  RETRN5
                          GOTO  REMOT5

         ELSE IF ( KEYNO .EQ. QEND   ) THEN
C                                          SAVE THE PROBLEM OR GROUP
            IF ( DEFNMD .EQ. PMODE ) THEN
C                                        STORE THE PROBLEM
               CALL ZZPUTP( DAUF,  PPNUM, PFNUM,  PPNAM,  PFNAM, PDESC,
     -                      SOLNS, PINTS, IORDER, ILOOPX, ILOOPC,
     -                      X, NAMES, PRECNO, RECP, ERRFLG, *91000 )
            ELSE
C                                        STORE THE GROUP
               CALL ZZPUTG( DAUF, PGNUM, PGNAM, GRPSZ, GMEMBS, GNAMES,
     -                      GROUPS, RECP, ERRFLG, *91000        )
            ENDIF

            DEFNMD = CMODE

         ELSE IF ( KEYNO .EQ. QEXPNS ) THEN
C                                          SET EXPENSE FACTOR
              IF ( PARCT .EQ. 0 ) THEN
                 PAR1 = DPXPNS
              ENDIF

              OUTER = F
              OSCAL = 0
              OINDEX = PTPXPN
              ASSIGN  2900  TO  RETRN5
                          GOTO  REMOT5

         ELSE IF ( KEYNO .EQ. QFUNCT ) THEN
C                                          SET FUNCTION NAME
                 IF ( S1 .NE. BLANK ) THEN
                    PFNAM = S1
                    CALL ZZCASE(PFNAM,CTOUPP)
                 ELSE
                    PFNUM = NINT(PAR1)
                 ENDIF

         ELSE IF ( KEYNO .EQ. QGROUP ) THEN
C                                          DEFINE A GROUP
              DEFNMD = GMODE

              GRPSZ  = 0

              IF ( PARCT .EQ. 2 ) THEN

                 IF ( S1 .NE. BLANK ) THEN
                    PGNAM = S1
                    PGNUM = NINT(PARS(2))
                 ELSE
                    PGNAM = KEYSTR(2)
                    PGNUM = NINT(PAR1)
                 ENDIF

              ELSE IF ( PARCT .EQ. 1 ) THEN

                 IF ( S1 .NE. BLANK ) THEN
                    PGNAM = S1
                 ELSE
                    PGNUM = NINT(PAR1)
                 ENDIF

              ENDIF

         ELSE IF ( KEYNO .EQ. QMAX  .OR. KEYNO .EQ. QLIMIT ) THEN
C                                  SET THE MAXIMUM NUMBER OF ITERATIONS.
              IF ( PARCT .EQ. 0 ) THEN
                 PMAX = DMAXF
              ELSE
                 PMAX = NINT( PAR1 )
              ENDIF

         ELSE IF ( KEYNO .EQ. QPERMA ) THEN
C                                          SET PERM FLAG
              PPERM = T

         ELSE IF ( KEYNO .EQ. QPROBL ) THEN
C                                          SET PROBLEM NAME AND NUMBER
              IF ( PARCT .EQ. 2 ) THEN

                 IF ( S1 .NE. BLANK ) THEN
                    PPNAM = S1
                    PPNUM = NINT(PARS(2))
                 ELSE
                    PPNAM = KEYSTR(2)
                    PPNUM = NINT(PAR1)
                 ENDIF
                 CALL ZZCASE(PPNAM,CTOUPP)

              ELSE IF ( PARCT .EQ. 1 ) THEN

                 IF ( S1 .NE. BLANK ) THEN
                    PPNAM = S1
                 ELSE
                    PPNUM = NINT(PAR1)
                 ENDIF

              ENDIF

         ELSE IF ( KEYNO .EQ. QSCALE ) THEN
C                                          SET SCALE CODE
              IF ( PARCT .EQ. 0 ) THEN
                 PAR1 = DSCAL
              ENDIF

              OUTER = F
              OSCAL = 2
              OINDEX = PTSCAL
              ASSIGN  2900  TO  RETRN5
                          GOTO  REMOT5

         ELSE IF ( KEYNO .EQ. QSELCT ) THEN
C                                          SET SCALE CODE
             ARGNO = NINT(PAR1)

         ELSE IF ( KEYNO .EQ. QSOLN ) THEN
C                                          STORE THE SOLUTIONS.
            PTSOLN   = PTSOLN + 1
            IF ( PTSOLN + PARCT .GT. MXSOLN ) THEN
               CALL ZZERRM(RD(I),*91000,'NT NO MORE ROOM FOR SOLUTIONS')
            ELSE
               SOLNS(1) = SOLNS(1) + 1
               SOLNS(PTSOLN) = PARCT - 2
               DO 2330 I = 1, PARCT
                  SOLNS(PTSOLN+I) = PARS(I)
 2330          CONTINUE
               PTSOLN = PTSOLN + PARCT
            ENDIF

         ELSE IF ( KEYNO .EQ. QSTART .OR. KEYNO .EQ. QX     ) THEN
C                                          SET THE STARTING POINT
              IF ( PARCT .EQ. 1 ) THEN
                 IX0 = -NINT( ABS(PAR1) )
              ELSE
                 IX0 = PARCT
                 DO 2340 I=1,PARCT
                    X(I) = PARS(I)
 2340            CONTINUE
              ENDIF

         ELSE IF ( KEYNO .EQ. QTEMP  ) THEN
C                                          CANCEL PERM FLAG
              PPERM = F

         ELSE IF ( KEYNO .EQ. QUSE   ) THEN
C                                          DEFINE PROBLEM TO MODIFY
              IF ( PARCT .EQ. 2 ) THEN

                 IF ( S1 .NE. BLANK ) THEN
                    TPPNAM = S1
                    TPPNUM = NINT(PARS(2))
                 ELSE
                    TPPNAM = KEYSTR(2)
                    TPPNUM = NINT(PAR1)
                 ENDIF

              ELSE IF ( PARCT .EQ. 1 ) THEN

                 IF ( S1 .NE. BLANK ) THEN
                    TPPNAM = S1
                    TPPNUM = -1
                 ELSE
                    TPPNAM = BLANK
                    TPPNUM = NINT(PAR1)
                 ENDIF

              ENDIF
              CALL ZZGETP( DAUF,  TPPNUM, PFNUM, TPPNAM,  PFNAM, PDESC,
     -                     SOLNS, PINTS,  IORDER, ILOOPX, ILOOPC,
     -                     X ,   NAMES, PRECNO,  ERRFLG, *91000 )
         ENDIF
      ELSE

C                                            PROCESS THE COMMAND
         IF      ( KEYNO .EQ. XABORT ) THEN
C                                       ABORT.
            IF ( INTACT ) THEN

               WRITE ( RPSOUT, '(A)' ) 'FOR SURE(Y)?'
               IF ( COPY ) WRITE ( COPYUN, '(A)' ) 'FOR SURE(Y)?'

               READ  ( STDIN , '(A)' ) S1
               IF (COPY) WRITE (COPYUN,*) S1

               CALL ZZCASE (S1, CTOUPP)
               IF ( S1(1:1) .EQ. 'Y'  ) THEN
                  GOTO 94000
               ELSE
                  WRITE (RPSOUT, '(A)' ) ' ABORT IGNORED.'
                  IF (COPY) WRITE (COPYUN, '(A)' ) ' ABORT IGNORED.'
               ENDIF

            ELSE

               GOTO 94000

            ENDIF

         ELSE IF ( KEYNO .EQ. XACCUR ) THEN
C                                           RESET ACCURACY.
              TODO(CCOLD) = T
              SEPART = F
              OUTER = T
              OSCAL = 0
              OINDEX = PTACC
              ASSIGN  2900  TO  RETRN5
                          GOTO  REMOT5

         ELSE IF ( KEYNO .EQ. XADD   .OR. KEYNO .EQ. XDROP  ) THEN

C                                           ADD OR DROP PROBLEM.
            IF ( PARCT .GT. 0 ) THEN

               CALL ZZADDP ( KEYNO .EQ. XADD, KEYSTR, PARS, PARCT,
     -                   LIST, NPROBS, MXPRBS, PRECNO, NAMES,
     -                   DFPRBS, GROUPS, GNAMES, MXGRPS, G1, *91000 )

               SORTFL = SORTFL .OR.  KEYNO .EQ. XADD
               IF ( KEYNO .EQ. XADD ) THEN
                  TODO(CCOLD)  = T
               ENDIF
            ELSE
               CALL ZZERRM ( TM,  *91000,
     -            'NT ADD OR DROP WITH NO PROBLEMS GIVEN'  )
            ENDIF

         ELSE IF ( KEYNO .EQ. XARITH ) THEN
C                                   REDEFINE ARITHMETIC LOOP CHARACTER.
            DCC(LOOPA:LOOPA) = S1(1:1)
            CALL ZZDSET (DCC)

         ELSE IF ( KEYNO .EQ. XASC   ) THEN
C                                   SET TO ASCENDING SORT
            ASC = S1 .EQ. TRUE
            SORTFL = T
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XASSMT ) THEN
C                                   REDEFINE ASSIGNMENT CHARACTER.
            DCC(ASSMT:ASSMT) = S1(1:1)
            CALL ZZDSET (DCC)

         ELSE IF ( KEYNO .EQ. XBRIEF ) THEN
C                                        SET UP BRIEF COMMAND INPUT
            BRIEF = S1 .EQ. TRUE

         ELSE IF ( KEYNO .EQ. XBYE  .OR.  KEYNO .EQ. XEND
     -                              .OR.  KEYNO .EQ. XQUIT ) THEN
C                                        EXIT COMMAND INPUT SECTION
            IF ( INTACT ) THEN

               WRITE ( RPSOUT, '(A)' ) ' FOR SURE(Y)?'
               IF (COPY) WRITE ( COPYUN, '(A)' ) ' FOR SURE(Y)?'

               READ  ( STDIN , '(A)' ) S1
               IF (COPY) WRITE(COPYUN,*) S1

               CALL ZZCASE (S1, CTOUPP)
               IF ( S1(1:1) .EQ. 'Y'  ) THEN
                  GOTO 90000
               ELSE
                  WRITE ( RPSOUT, '(A)' ) ' QUIT IGNORED.'
                  IF(COPY) WRITE ( COPYUN, '(A)' ) ' QUIT IGNORED.'
               ENDIF

            ELSE
               GOTO 90000
            ENDIF

         ELSE IF ( KEYNO .EQ. XCC    ) THEN
C                                        SET SYSTEM CARRIAGE CONTROL.
            SYSCC = NINT(PAR1)

         ELSE IF ( KEYNO .EQ. XCHECK ) THEN
C                                        SET CHECK BEGORE GO.
            LISTCD = NINT(PAR1)
            CHECK  = LISTCD .NE. CHOFF

         ELSE IF ( KEYNO .EQ. XCOMME ) THEN
C                                        REDEFINE COMMENT CHARACTERS.
            IF ( PARCT .EQ. 0 ) THEN
               DCDMOD = DCDDON
            ELSE
               DCC(COM1:COM1) = S1(1:1)

               IF ( PARCT .GE. 2 ) THEN
                  DCC(COM2:COM2) = KEYSTR(2)(1:1)
               ELSE
                  DCC(COM2:COM2) = DCC(COM1:COM1)
               ENDIF
            ENDIF

            CALL ZZDSET (DCC)

         ELSE IF ( KEYNO .EQ. XCONTI ) THEN
C                                        REDEFINE CONTINUATION CHARACTER
            DCC(CONT:CONT) = S1 (1:1)
            CALL ZZDSET (DCC)

         ELSE IF ( KEYNO .EQ. XCOPY  ) THEN
C                                        SET COPY FLAG
            COPY = T
            CALL ZZOPEN ( COPYUN, COPY  , NMCOPY, *91000, RECL )

         ELSE IF ( KEYNO .EQ. XCRIT  ) THEN
C                                        SET CRITERION
            IF ( PARCT .EQ. 1 ) THEN
               CRITNO = NINT(PAR1)
               IF ( CRITNO .LT. 1  .OR.  CRITNO .GT. MXCRIT ) THEN
                  CALL ZZERRM( RD(I), *91000,'IS NOT VALID CRITERION')
                  CRITNO = 0
               ELSE
                  LASTLN = LNO
                  LNO = CRITNO
                  CRITLN = T
                  LL(CPL) = LL(LNO)
                  LINELN = ZZLENG(LL(LNO))
                  GOTO 2100
               ENDIF
            ELSE
               IF ( S1 .EQ. BLANK ) THEN
                  I  = NINT(PAR1)
               ELSE
                  I = NINT (PARS(2))
               ENDIF

               IF ( I .LT. 1  .OR.  I .GT. MXCRIT ) THEN
                  CALL ZZERRM( RD(I), *91000,
     -                        'IS NOT VALID CRITERION ' )
               ELSE
                  LL(I) = LL(SVL)
               ENDIF
            ENDIF

         ELSE IF ( KEYNO .EQ. XDECOD ) THEN
C                                        SET TRACE IN DECODE.
            DCTRAC = S1 .EQ. TRUE
            CALL ZZOPEN(TRCOUT,DCTRAC,NMTRAC,*91000,RECL)

         ELSE IF ( KEYNO .EQ. XDEFAU ) THEN
C                                        SET TO  DEFAULT VALUES.
            ASSIGN 82000  TO RETRN1
            ASSIGN  2900  TO RETRN2
                       GOTO REMOT1

         ELSE IF ( KEYNO .EQ. XDEFIN ) THEN
C                                        ENTER PROB DEFN MODE
            DEFNMD = PMODE
C                                        SET PROBLEM DEFAULT VALUES
            GOTO REMOT4

         ELSE IF ( KEYNO .EQ. XDELIM ) THEN
C                                        REDEFINE DELIMITER CHARACTER.
            DCC(DEL:DEL) = S1 (1:1)
            CALL ZZDSET (DCC)

         ELSE IF ( KEYNO .EQ. XDERIV ) THEN
C                                        RESET DERIVATIVE MODE.
            DERVMD = NINT(PAR1)
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XDESC  ) THEN
C                                   SET TO DESCENDING SORT
            ASC = S1 .NE. TRUE
            SORTFL = T
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XDOSUM ) THEN
C                                        DO A SUMMARY
            TODO(CDOTRM)  = T
            GOTO 9000

         ELSE IF ( KEYNO .EQ. XEOF   ) THEN
C                                        RESET EOF HANDLING
            EOFBLK = NINT( PAR1 ) .EQ. CEOFIG

         ELSE IF ( KEYNO .EQ. XESCAP ) THEN
C                                        REDEFINE ESC CHARACTER.
            DCC(ESC:ESC) = S1 (1:1)
            CALL ZZDSET (DCC)

         ELSE IF ( KEYNO .EQ. XEVTRC ) THEN
C                                        SET TRACE OF FIN. DIFFS.
            EVTRAC = S1 .EQ. TRUE
            CALL ZZESET ( TRF, TRG, EVTRAC, TRCOUT )
            CALL ZZOPEN(TRCOUT,EVTRAC,NMTRAC,*91000,RECL)

         ELSE IF ( KEYNO .EQ. XEXPNS ) THEN
C                                    SET UP EXPENSE FACTOR.
            TODO(CCOLD)  = T
            SEPART = F
            OUTER  = T
            OSCAL  = 0
            OINDEX = PTGXPN
            ASSIGN  2900  TO  RETRN5
                        GOTO  REMOT5

         ELSE IF ( KEYNO .EQ. XFABS  ) THEN
C                                    USE ABSOLUTE TESTS ON F.
            RELF = S1 .NE. TRUE
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XFACTO ) THEN
C                                        RESET FACTOR.
            TODO(CCOLD)  = T
            SEPART = F
            OUTER  = T
            OSCAL  = 0
            OINDEX = PTFACT
            ASSIGN  2900  TO  RETRN5
                        GOTO  REMOT5

         ELSE IF ( KEYNO .EQ. XFORWO ) THEN
C                                    USE FORWARD COMMUNICATION.
            REVERS = S1 .NE. TRUE
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XFREE  ) THEN
C                                    FIND FREE PROBLEM NUMBERS.
            K = 0
            DO 2420 I = 1,MAX(1,NINT(PAR1))
 2418          K = K+1
               IF ( K .GT. DFPRBS) THEN
                  GOTO 2422
               ELSE IF (PRECNO(RECN,K) .EQ. -1) THEN
                  WRITE(RPSOUT,'(I4)') K
                  IF ( COPY ) WRITE(COPYUN,'(I4)') K
               ELSE
                  GOTO 2418
               ENDIF
 2420       CONTINUE
 2422       CONTINUE

         ELSE IF ( KEYNO .EQ. XFREL  ) THEN
C                                    USE RELATIVE TESTS ON F.
            RELF = S1 .EQ. TRUE
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XFTRAC ) THEN
C                                        TURN ON FUNCTION TRACE.
            TRF  = S1 .EQ. TRUE
            TODO(CCOLD)  = T
            CALL ZZESET ( TRF, TRG, EVTRAC, TRCOUT )
            CALL ZZOPEN(TRCOUT,TRF,NMTRAC,*91000,RECL)

         ELSE IF ( KEYNO .EQ. XGABS  ) THEN
C                                    USE ABSOLUTE TESTS ON G.
            RELG = S1 .NE. TRUE
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XGEOME ) THEN
C                                     REDEFINE GEOMETRIC LOOP CHARACTER
            DCC(LOOPG:LOOPG) = S1(1:1)
            CALL ZZDSET (DCC)

         ELSE IF ( KEYNO .EQ. XGREL  ) THEN
C                                    USE RELATIVE TESTS ON G.
            RELG = S1 .EQ. TRUE
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XGTRAC ) THEN
C                                        TURN ON GRADIENT TRACE.
            TRG  = S1 .EQ. TRUE
            TODO(CCOLD)  = T
            CALL ZZESET ( TRF, TRG, EVTRAC, TRCOUT )
            CALL ZZOPEN(TRCOUT,TRG,NMTRAC,*91000,RECL)

         ELSE IF ( KEYNO .EQ. XIMMED ) THEN
C                                        SET FOR IMMEDIATE EXECUTION.
            IMMED = S1 .EQ. TRUE

         ELSE IF ( KEYNO .EQ. XINPUT ) THEN
C                                        REDEFINE INPUT UNIT.
            IF ( S1 .EQ. BLANK ) THEN
                NEXTUN = NINT(PAR1)
                NMNEXT = BLANK
            ELSE
                NEXTUN = INPTUN
                NMNEXT = LL(SVL)
            ENDIF
C                               IMMEDIATELY OPEN THE INPUT FILE.
               CALL ZZCLSE ( NEXTUN, *91000 )
               CALL ZZOPEN ( NEXTUN, T, NMNEXT, *2430, RECL )
               I = READUN
               READUN = NEXTUN
               NEXTUN = I
               TRMRD  = F
               CALL ZZCLSE ( STDIN , *2430 )
               GOTO 2440
 2430          CALL ZZERRM (I, *91000,'NS OPEN FAILED ON FILE '//NMNEXT)
               READUN = STDIN
 2440          CONTINUE

         ELSE IF ( KEYNO .EQ. XLIST ) THEN
C                                         LIST PROBLEM SET
             WRITE(RPSOUT,'(A)') 'P#  DIMN  PROBLEM  FUNCTION'
             IF ( PARCT .GE. 2 ) THEN
                II = NINT(PARS(2))
                J  = NINT(PAR1)
             ELSE IF ( PARCT .EQ. 1 ) THEN
                II = NINT(PAR1)
                J  = NINT(PAR1)
             ELSE
                II = DFPRBS
                J  = 1
             ENDIF
             DO 2445 JJ = J, II
                 IF ( PRECNO(RECN,JJ) .NE. -1 ) THEN
                    KK = (JJ-1)*2*PNAMLN
                    WRITE(RPSOUT,'(I3,'':'',I4,2X,A8,1X,A8)')
     -                   JJ,PRECNO(DIMN,JJ),
     -                   NAMES(KK+1:KK+PNAMLN),
     -                   NAMES(KK+PNAMLN+1:KK+2*PNAMLN)
                ENDIF
 2445        CONTINUE

         ELSE IF ( KEYNO .EQ. XLONGF ) THEN
C                                          SET FOR LONG PRINT OF F.
            LONGF = S1 .EQ. TRUE

         ELSE IF ( KEYNO .EQ. XMEMOR ) THEN
C                                        DEFINE ALLOWABLE MEMORY USAGE.
            TODO(CCOLD)  = T
            MEMORY = MIN( NINT(PAR1),LR )

            IF ( MEMORY .LE. 0 ) THEN
               MEMORY = LR
            ENDIF

         ELSE IF ( KEYNO .EQ. XMODE  ) THEN
C                                        SET RUN MODE.
            INTACT = NINT(PAR1) .EQ. CINTAC
            CALL ZZETRM ( INTACT, RPSOUT )
            CALL ZZOPEN ( RPSOUT, INTACT, NMTRMO, *91000, RECL )

         ELSE IF ( KEYNO .EQ. XNORM  ) THEN
C                                        RESET NORM.
            TODO(CCOLD)  = T
            NORM = NINT(PAR1)
            CALL ZZTSET ( NORM, QUITS, TTRACE, TRCOUT )

         ELSE IF ( KEYNO .EQ. XPGRAD ) THEN
C                                        GRADIENT PRINT FLAG SET.
            IF ( LOCAL ) THEN
               IGRAD = S1 .EQ. TRUE
            ELSE
               GRAD  = S1 .EQ. TRUE
            ENDIF
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XPOINT ) THEN
C                                        POINT PRINT FLAG SET.
            IF ( LOCAL ) THEN
               IPOINT = S1 .EQ. TRUE
            ELSE
               POINT  = S1 .EQ. TRUE
            ENDIF
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XPRINT ) THEN
C                                        RESET PRINT FREQUENCY
            IF ( LOCAL ) THEN
               IPRL = NINT(PAR1)
               CALL ZZOPEN ( RPSOUT, T, BLANK, *91000, RECL )
            ELSE
               PRINTL = NINT(PAR1)
               WRITFL = PRINTL .NE. 0
               CALL ZZOPEN ( RESOUT, WRITFL, NMWRIT, *91000, RECL )
            ENDIF
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XRADIX ) THEN
C                                        RESET RADIX CHARACTER.
            DCC(RADIX:RADIX) = S1(1:1)

            CALL ZZASET ( DCC(RADIX: RADIX ), DCC(RADPRB:RADPRB),
     -                    DCC(RADFUN:RADFUN), DCC(RADGRP:RADGRP))


            CALL ZZDSET (DCC)

         ELSEIF ( KEYNO .EQ. XRENAM ) THEN

C        PROCESS SYNONYM; MUST REPLACE KEYWORD AND RESORT DICTIONARY.

            J = NINT(PAR1)
            MAPKEY  = MAP1( XXLAST+J )
            S1 = KEYSTR(2)
            I  = (MAPKEY-1) * KEYLEN + 1
            J  = MAPKEY*KEYLEN
            CINF(MAPKEY,1) = MXPARS
            CINF(MAPKEY,2) = TYREAL

            IF ( LLT( S1, CMDS(I:J) ) ) THEN
C              ADJUST DOWN FROM MAPKEY.
               MAPKEY = -MAPKEY
            ELSE
C              ADJUST UP FROM MAPKEY.
            ENDIF

            CMDS( I : J ) = S1

 2470       CALL ZZDSRT ( CMDS, CINF, NCMDS, KEYLEN, MAP1, INVMP1,
     -                   MAPKEY, T, S1, S2 )

         ELSE IF ( KEYNO .EQ. XREQUI ) THEN
C                                       SET TITLE FLAG
            TITREQ = S1 .EQ. TRUE

         ELSE IF ( KEYNO .EQ. XRESET ) THEN
C                                    RESET THE PROBLEM SET.
            NPROBS = 0

         ELSE IF ( KEYNO .EQ. XRESUL ) THEN
C                                       RENAME RESULT FILE
            NMWRIT = S1
            CALL ZZCASE ( NMWRIT, CTOUPP )
            CALL ZZCLSE ( RESOUT, *91000 )
            IF      (NMWRIT .EQ. NMTRAC ) THEN
               RESOUT = TRACUN
               CALL ZZOPEN( RESOUT,T,NMWRIT,*91000,RECL)
            ELSE IF (NMWRIT .EQ. 'TERMINAL') THEN
               RESOUT = RPSOUT
               CALL ZZOPEN( RESOUT,T,BLANK,*91000,RECL)
            ELSE
               NMWRIT = S1
               RESOUT = WRITUN
               CALL ZZOPEN( RESOUT,T,NMWRIT,*91000,RECL)
            ENDIF
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XREVER ) THEN
C                                       SET COMMUNICATION MODE.
            TODO(CCOLD)  = T
            REVERS = S1 .EQ. TRUE

         ELSE IF ( KEYNO .EQ. XSEE   ) THEN
C                                        SET TERMINAL SUMMARY LEVEL.
            SEELEV = NINT(PAR1)
            TODO(CDOTRM)  = T
            CALL ZZOPEN ( RPSOUT, SEELEV .NE. CNONE, NMTRMO,
     -                    *91000, RECL                      )

         ELSE IF ( KEYNO .EQ. XSELCT ) THEN
C                                        SELECT USER ARGUMENT.
            USERNO = NINT(PAR1)

         ELSE IF ( KEYNO .EQ. XSEPAR ) THEN
C                                     REDEFINE SEPARATOR CHARACTER.
            DCC(SEP:SEP) = S1 (1:1)
            CALL ZZDSET (DCC)

         ELSE IF ( KEYNO .EQ. XSORT  ) THEN
C                                     SET SORT ORDER.
            SORT   = NINT(PAR1)
            SORTFL = SORT .NE. SASIS
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XSTART ) THEN
C                                     START MINIMIZATION
            IF ( PARCT .EQ. 0 ) THEN
                GOTO 3000
            ELSE IF ( INT(PAR1) .EQ. CNOGO ) THEN
C               DO NOTHING
            ELSE
                GOTO 3000
            ENDIF

         ELSE IF ( KEYNO .EQ. XSTRIN ) THEN
C                                    REDEFINE STRING CHARACTER
            DCC(STRNG1:STRNG1) = S1(1:1)

            IF ( PARCT .GE. 2 ) THEN
               DCC(STRNG2:STRNG2) = KEYSTR(2)(1:1)
            ENDIF

            CALL ZZDSET (DCC)

         ELSE IF ( KEYNO .EQ. XSUBRO ) THEN
C                                     DEFINE SUBROUTINE NAME.
            IF ( PARCT .LT. 2 ) THEN

               CALL ZZERRM (TM,*91000,
     -                     'NS SUBROUTINE NAME AND/OR NUMBER MISSING' )
            ELSE
               IF ( S1 .EQ. BLANK ) THEN

                  S1 = KEYSTR(2)
                  II  = NINT(PAR1)
               ELSE
                  II = NINT (PARS(2))
               ENDIF

               IF ( II .LT. 1  .OR.  II .GT. MXSUBS ) THEN
                  CALL ZZERRM( RD(II), *91000,
     -                        'IS NO VALID SUBROUTINE NUMBER ' )
               ELSE
C                   MUST REPLACE KEYWORD AND RESORT DICTIONARY.

                  MAPKEY = MAP3 ( ZZLAST + II )
                  I      = (MAPKEY-1) * KEYLEN + 1
                  J      = MAPKEY*KEYLEN

                  IF ( LLT( S1, CPARS( I : J ) ) ) THEN
C                    ADJUST UP FROM MAPKEY.
                     MAPKEY = -MAPKEY
                  ELSE
C                    ADJUST DOWN FROM MAPKEY.
                  ENDIF

                  CPARS( I : J ) = S1
                  CPINF(MAPKEY,1) = XWITH
                  CPINF(MAPKEY,2) = II
                  CALL ZZDSRT( CPARS, CPINF, NCPARS, KEYLEN, MAP3,
     -                        INVMP3, MAPKEY, T, S1, S2 )

                  TODO(CCOLD)  = T
               ENDIF

            ENDIF

         ELSE IF ( KEYNO .EQ. XSUMMA ) THEN
C                                     SUMMARY  ON WRITUN.
            WRTSUM = S1 .EQ. TRUE
            TODO(CDOFLE)  = T

         ELSE IF ( KEYNO .EQ. XTERM  ) THEN
C                                     RESET TYPE.
            DO 2560 I=1,PARCT
               CALL ZZCASE(KEYSTR(I), CTOUPP)
               IF      ( KEYSTR(I)(1:1) .EQ. QT ) THEN
                  QUITS(I:I) = QT
               ELSE IF ( KEYSTR(I)(1:1) .EQ. QF ) THEN
                  QUITS(I:I) = QF
               ENDIF
 2560       CONTINUE
            CALL ZZTSET ( NORM, QUITS, TTRACE, TRCOUT )
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XTEX   ) THEN
C                                        SET TEX FLAG
            TEX = T
C           CALL ZZOPEN(TEXUN,T,BLANK,*91000,RECL)

         ELSE IF ( KEYNO .EQ. XTITLE ) THEN
C                                    GET TITLE LINE.
            IF ( S1 .EQ. BLANK ) THEN
               TITLE = BLANK
            ELSE
               TITLE = LL(SVL)
            ENDIF

            S2 = TITLE
            CALL ZZCASE ( S2, CTOUPP )
            IF ( S2 .EQ. ENDIT ) THEN
               GOTO 90000
            ENDIF

         ELSE IF ( KEYNO .EQ. XTRACE ) THEN
C                                     SET TRACE FLAGS.
            TODO(CCOLD)  = T
            IF    ( PARCT .EQ. 0 ) THEN
C                                   ALL SET TO TRUE.
               DO 2520 II = 1, NTR
                  TRACES(II) = T
 2520          CONTINUE
            ELSE
               DO 2530 II = 1 , PARCT
                  CALL ZZCASE ( KEYSTR(II), CTOUPP )
                  IF     ( KEYSTR(II)(1:1) .EQ. QT ) THEN
                     TRACES(II) = T
                  ELSEIF ( KEYSTR(II)(1:1) .EQ. QF ) THEN
                     TRACES(II) = F
                  ENDIF
 2530          CONTINUE
            ENDIF

            FLTRAC = F
            DO 2540 II = 1, NTR
               IF (TRACES(II) ) THEN
                  FLTRAC = T
                  GOTO 2550
               ENDIF
 2540       CONTINUE

 2550       CALL ZZOPEN(TRCOUT,T,NMTRAC,*91000,RECL)

         ELSE IF ( KEYNO .EQ. XTRCUN ) THEN
C                                     REASSIGN TRACE UNIT
            CALL ZZCLSE ( TRCOUT, *91000 )
            NMTRAC = S1
            CALL ZZCASE ( NMTRAC, CTOUPP )
            IF      (NMTRAC .EQ. NMWRIT ) THEN
               TRCOUT = WRITUN
               CALL ZZOPEN ( TRCOUT,T,NMTRAC,*91000,RECL)
            ELSE IF (NMTRAC .EQ. 'TERMINAL') THEN
               TRCOUT = RPSOUT
               CALL ZZOPEN ( RPSOUT,T,BLANK,*91000,RECL)
            ELSE IF (NMTRAC .EQ. 'TEMP') THEN
               TRCOUT = TEMPUN
               CALL ZZOPEN ( TEMPUN,T,BLANK,*91000,RECL)
            ELSE
               NMTRAC = S1
               TRCOUT = TRACUN
               CALL ZZOPEN ( TRCOUT,T,NMTRAC,*91000,RECL)
            ENDIF
            CALL ZZESET ( TRF,  TRG,   EVTRAC, TRCOUT )
            CALL ZZTSET ( NORM, QUITS, TTRACE, TRCOUT )
            TODO(CCOLD)  = T

         ELSE IF ( KEYNO .EQ. XTTRAC  ) THEN
C                                     TURN ON TERMINATION TRACE.
            TTRACE = S1 .EQ. TRUE
            CALL ZZTSET ( NORM, QUITS, TTRACE, TRCOUT )
            TODO(CCOLD)  = T
            CALL ZZOPEN(TRCOUT,TTRACE,NMTRAC,*91000,RECL)

         ELSE IF ( KEYNO .EQ. XUPPER ) THEN
C                                     SET UPPER CASE.
            UPCASE = S1  .EQ. TRUE
            IF ( UPCASE ) CALL ZZCASE ( LL(LNO), CTOUPP )

         ELSE IF ( KEYNO .EQ. XUSER  ) THEN
C                                     SET THE USER DEFINED ARGUMENT.
           TODO(CCOLD)  = T
           OUTER = T
           OSCAL = 0
           IF ( USERNO .NE. 0 ) THEN
              SEPART = F
              OINDEX = PTUSER(USERNO)
           ELSE
              SEPART = T
              OINDEX = PTUSER(1)
           ENDIF
              ASSIGN  2900  TO  RETRN5
                                GOTO  REMOT5

         ELSE IF ( KEYNO .EQ. XVALUE ) THEN
C                                        DISPLAY CURRENT SETTINGS.
            IF ( PARCT .GT. 0 ) THEN
               VALS = NINT(PAR1)
            ELSE
               VALS = CALL
            ENDIF

            GOTO REMOT7

         ELSE IF ( KEYNO .EQ. XVERIF ) THEN
C                                        RESET DECODING VERIFICATION.
            VERIFY = S1 .EQ. TRUE

         ELSE IF ( KEYNO .EQ. XWATCH ) THEN
C                                        SET LOCAL ITERATES FLAG.
            LOCAL = S1 .EQ. TRUE

         ELSE IF ( KEYNO .EQ. XWITH  ) THEN
C                                          SET THE SUBROUTINE TO USE.
            IF ( PAR1 .LT. 1 .OR. PAR1 .GT. MXPARS
     -                       .OR. PARCT .EQ. 0     ) THEN
               CALL ZZERRM ( TM, *91000, 'NS UNDEFINED SUBROUTINE' )
            ELSE
               SUBR = NINT(PAR1)
               TODO(CCOLD)  = T
            ENDIF

         ELSE IF ( KEYNO .GT. XXLAST  ) THEN
C                                          SET THE USER ARGUMENT.
            TODO(CCOLD)  = T
            OUTER = T
            OSCAL = 0
            OINDEX = PTUSER( KEYNO - XXLAST )
            ASSIGN  2900  TO  RETRN5
                        GOTO  REMOT5

         ENDIF

      ENDIF

 2900 CONTINUE

      IF ( DCDMOD .EQ. DCDMOR ) THEN
         GOTO 2100
      ELSE IF ( CRITLN ) THEN
         LL(CRITNO) = LL(CPL)
         CRITLN = F
         LNO = LASTLN
         LINELN = ZZLENG(LL(LNO))
         LASTLN = NULLIN
         GOTO 2100
      ELSE IF ( IMMED ) THEN
         PHASE = 5
         GOTO 3000
      ELSE IF ( BRIEF ) THEN
         PHASE = 5
         GOTO 2000
      ELSE IF ( KEYNO .EQ. 0 .AND. PHASE .EQ. 5 ) THEN
         IF (CHECK) THEN
            GOTO 2000
         ELSE
            GOTO 3000
         ENDIF
      ELSE IF ( TRMRD ) THEN
         PHASE = MIN ( 5 , PHASE + 1 )
         GOTO 2000
      ELSE
         GOTO 2000
      ENDIF

 3000 CONTINUE

C >==================================>> EXECUTION  BEGINS HERE.

C-----PREPARE TO EXECUTE A BLOCK OF TESTS. SAVE THE RESULTS.

 6000 REWIND TEMPUN

      IF ( .NOT. TODO(CCOLD) .OR. NPROBS .EQ. 0 ) THEN
         GOTO 9000
      ENDIF

C     SAVE INFORMATION DEFINING THE TEST.

      WRITE ( TEMPUN, 98000 ) TESTCH
      WRITE ( TEMPUN, * ) NPROBS, NORM, CRITNO,
     -                    RELF, RELG, DERVMD, MEMORY,SUBR
      WRITE ( TEMPUN, '(A)' ) QUITS

      MAPKEY = MAP3( ZZLAST + SUBR )
      J      = ( MAPKEY-1 )* KEYLEN + 1
      K      = MAPKEY * KEYLEN
      SUBNAM = CPARS(J:K)

      WRITE ( TEMPUN, '( A, A )' ) SUBNAM, TITLE

C     SORT LIST IF NECESSARY.

      IF ( SORTFL .AND. SORT .NE. SASIS ) THEN
         SORTFL = F
         CALL ZZSORT ( SORT, LIST, NPROBS, PRECNO, NAMES, PNAMLN, ASC )
      ENDIF

C !!! TOP OF OUTER LOOP. SEARCH FOR AND SOLVE EACH SPECIFIED PROBLEM
C VVV   UNTIL THERE ARE NO MORE LEFT. THEN SUMMARIZE. TERMINATE IF
C       A NONZERO ERROR CODE IS FOUND.

 8000 CONTINUE
      CALL ZZLPCK ( OLOOPC, OLOOPX, OORDER, PTACC, ACC )
      GLBLOK = T
      IF ( ACC .GE. ONE .AND. ACC .EQ. NINT(ACC) ) THEN
         ACC = TEN**(-NINT(ACC))
      ENDIF

      CALL ZZLPCK ( OLOOPC, OLOOPX, OORDER, PTFACT, FACTOR )
      CALL ZZLPCK ( OLOOPC, OLOOPX, OORDER, PTGXPN, VALUE  )
      GEXPNS = NINT(VALUE)

      DO 8050 I = 1, NU
         CALL ZZLPCK ( OLOOPC, OLOOPX, OORDER, PTUSER(I), USER(I) )
 8050 CONTINUE

      WRITE ( TEMPUN, '(3E24.18)' )  ACC, FACTOR, USER
      WRITE ( TEMPUN, * )  ' '

C !!! TOP OF MIDDLE (PROBLEM) LOOP
C VVV
      DO 8800 PROBCT = 1, NPROBS

         PROB   = LIST( PROBCT )

         CALL ZZGETP ( DAUF,   PROB  , PFNUM , PPNAM , PFNAM, PDESC,
     -                 SOLNS,  PINTS,  IORDER, ILOOPX, ILOOPC, X0  ,
     -                 NAMES,  PRECNO, ERRFLG, *91000               )

         IF (ERRFLG .NE. 0) THEN
            CALL ZZERRM(RD(PROB), *91000,
     -                 'IFUNEXPECTED ERROR IN ACCESSING PROBLEM ')
            GOTO 8800
         ENDIF

C !!! TOP OF INNER LOOP
C VVV

 8100    CALL ZZLPCK ( ILOOPC, ILOOPX, IORDER, PTNDIM, VALUE )
         N = NINT(VALUE)

         CALL ZZLPCK ( ILOOPC, ILOOPX, IORDER, PTSCAL, VALUE )
         SCAL = NINT(VALUE)
         CALL ZZLPCK ( ILOOPC, ILOOPX, IORDER, PTPXPN, VALUE  )
         PEXPNS = NINT(VALUE)
         IF ( PEXPNS .EQ. 0 ) THEN
             EXPENS = GEXPNS
         ELSE
             EXPENS = PEXPNS
         ENDIF

         DO 8150 I= 1, FNO
            CALL ZZLPCK ( ILOOPC, ILOOPX, IORDER, PTFARG(I), FARG(I) )
 8150    CONTINUE

C        ---PREPARE ZZEVAL AND ZZFNS.
         IF ( N .GT. MAXN ) THEN
            CALL ZZERRM(RD(N),*91000,'ITIGNORE PROBLEM; TOO LARGE N=')
            GOTO 8700
         ENDIF

         CALL ZZESRT ( SCAL, DERVMD, PMAX, EXPENS )
         CALL ZZFPAR ( FARG )
         IF ( PFNUM .EQ. -1 ) THEN
             CALL ZZFSET ( PFNAM, EXTRA, PFNUM, I )
         ENDIF

         DO 8170 I = 1,N
             X(I) = X0(I)
 8170    CONTINUE
         CALL ZZSTX0( IX0, X, N, FACTOR, G, RWORK )

         WRITE ( TEMPUN, '(A1)' ) TESTCH
         WRITE ( TEMPUN, '(A,A)' ) PPNAM, PFNAM
         WRITE ( TEMPUN, * ) PROB, PFNUM, N, SCAL, EXPENS, FARG
         WRITE ( TEMPUN, * ) ' '

         WRITE ( TEMPUN,   *  ) (X(I), I = 1,N )
         WRITE ( TEMPUN, * ) ' '

C        ---PREPARE ZZPRNT.

         CALL ZZP1ST( TEMPUN,  GRAD,  POINT, PRINTL )
         CALL ZZP2ST( RPSOUT, IGRAD, IPOINT, IPRL,  COPY, COPYUN )

C        CALL A USER ROUTINE JUST BEFORE SOLVING PROBLEM.

         CALL ZZBFOR( TESTCH, STATUS, SUBR, WRTSUM, SEELEV, WRITFL,
     -                IW, RW, DW                                  )

C        ---CALL ZZLINK TO DO MINIMIZATION.

         CALL ZZSECS ( TMIN )

         IF ( REVERS ) THEN

            STATUS = RCSTRT
            CASE   = BOTH
            CALL ZZEVAL( ZZFNS,N,X,FNC,G,CASE,IW,RW,DW)

         ELSE

            STATUS = NORMAL

         ENDIF

 8200    CALL ZZLINK ( N, X, FNC, G, ACC, RELF, RELG, STATUS, SUBR,
     -                 TRCOUT, TRACES,
     -                 NTR, PRINTL, PMAX, DERVMD, USER,
     -                 NU, RWORK, MEMORY, IWORK, LI, IW, RW, DW )

C        CHECK FOR REVERSE COMMUNICATION.

         IF ( REVERS .AND. ( STATUS .EQ. RCF .OR. STATUS .EQ. RCFG
     -                  .OR. STATUS .EQ. RCG ) )  THEN
            CASE = BOTH
            CALL ZZEVAL( ZZFNS,N,X,FNC,G,CASE,IW,RW,DW)

            STATUS = RCRPT
            GOTO 8200

         ENDIF

         CALL ZZSECS ( TM )
         TMIN = TM - TMIN

C        DO SUMMARY PROCESSING

C        UPDATE CUMULATIVES AND OUTPUT STATISTICS.

         CALL  ZZEGET ( FUNCCT, GRADCT, TFUNC )
         CALL  ZZPGET ( PRTIME, ITCT )

         IF ( DERVMD .EQ. CTEST .OR. DERVMD .EQ. CFIRST ) THEN
            CALL ZZECHK ( MXERR, DIGS, INDX, GCNT )
         ENDIF

         IF ( STATUS .GT. USERV ) THEN

C           OUTPUT THE SOLUTION.

            GSQ = ZZNRM2 ( N, G )

C           OUTPUT DISTANCE TO TRUE SOLUTION.

            FSTAR = FNC
            CALL ZZDSOL(N, FSTAR, X, RWORK, SOLNS, DF, DX, SOLNF, SOLNX)

            IF ( WRITFL ) THEN
               CALL ZZPRNT(N,X,FNC,G,GSQ,0)
            ENDIF

            IF ( FUNCCT .EQ. 1 ) THEN
               STATUS = IPMIN
            ENDIF

         ELSE

            GSQ   = -ONE
            DF    = -ONE
            DX    = -ONE
            SOLNX = 0
            SOLNF = 0

         ENDIF

         TMIN = TMIN - PRTIME

         WRITE ( TEMPUN, '(A1,A)' ) TESTCH

         MING = ABS(G(1))
         MAXG = MING

         DO 8400 I=1,N
            MING = MIN ( MING, ABS(G(I)) )
            MAXG = MAX ( MAXG, ABS(G(I)) )
 8400    CONTINUE

         WRITE ( TEMPUN, * ) ITCT, FUNCCT, GRADCT, DF, DX, SOLNX,
     -        SOLNF,FNC, GSQ, MING, MAXG, TMIN,TFUNC,PRTIME,STATUS

         IF ( DERVMD .EQ. CTEST .OR. DERVMD .EQ. CFIRST ) THEN

            WRITE ( TEMPUN, * )    MXERR, INDX, GCNT, DIGS

         ENDIF

C        CALL USER ROUTINE  AFTER SOLVING THE PROBLEM.

         CALL ZZAFTR( TESTCH, STATUS, SUBR, WRTSUM, SEELEV, WRITFL,
     -                IW, RW, DW                                  )
         IF ( TEX ) THEN
            I = -NINT(LOG10(ACC))
            CALL ZZTEX(TEXUN, PFNAM, PROB ,FUNCCT, ITCT, FNC, DF,
     -          FSTAR, I, GSQ, MING, DX, CRITNO, STATUS,TFUNC,TMIN )
         ENDIF

C-------------

 8700    CALL ZZLADV ( ILOOPC, ILOOPX, ILPXSZ, OVER )
         GLBLOK = GLBLOK .AND. STATUS .EQ. CDONE .AND. GSQ .NE. ZERO

         IF ( .NOT. OVER ) GOTO 8100
C^^^^^
C-------------END INNER LOOP

 8800 CONTINUE
C^^^^^
C-------------END MIDDLE (PROBLEM) LOOP

      WRITE ( TEMPUN, '(A,A)' ) TESTCH,'END OF SET '

      CALL ZZLADV ( OLOOPC, OLOOPX, OLPXSZ, OVER )

      IF ( GLBLOK .AND. .NOT. OVER ) THEN
           GOTO 8000
      ENDIF
C^^^^^
C-------------END OUTER LOOP.

C >==================================>> SECTION (7) BEGINS HERE.

C-----WRITE SUMMARY OF STATISTICS FOR THE SET OF TESTS.

 9000 IF ( (TODO(CCOLD) .OR. TODO(CDOTRM) .OR. TODO(CDOFLE))
     -    .AND. NPROBS .NE. 0 ) THEN

         CALL ZZSMRY ( TODO, X, SYSCC, WRTSUM, WRITFL, NMWRIT,
     -    COPY,  LL, MXCRIT, NL, RPSOUT,
     -    TESTCH, XXLAST, SEELEV, LONGF, CMDS, MAP1, *91000 )

      ENDIF
      TODO(CCOLD )  = F
      TODO(CDOFLE)  = F
      TODO(CDOTRM)  = F

      GOTO 1000

C## R E M O T E   B L O C K   1:

C  SET DEFAULTS FOR BASIC VARIABLES.

81000 CONTINUE

C-----INITIALIZE MEMORY AND SORT.

      MEMORY = LR
      SORT   = DSORT
      SORTFL = SORT .NE. SASIS

C-----INITIALIZE ZZPRNT.

      PRINTL = DPRINT
      POINT  = DPOINT
      GRAD   = DGRAD
      IPRL   = DIPR
      IPOINT = DIPT
      IGRAD  = DIGRAD
      LOCAL  = DLOCAL

C-----INITIALIZE ZZEVAL.

      DERVMD = DDERV
      REVERS = DREVRS

C-----INITIALIZE ZZTERM AND ACCURACY.

      ACC   = DACC
      RELF  = DRELF
      RELG  = DRELG
      NORM  = DNORM
      QUITS = DQUITS
      CALL ZZTSET ( NORM, QUITS, TTRACE, TRCOUT )

      GOTO RETRN1

C## R E M O T E   B L O C K   2:
C                                SET OUTER LOOP DATA TO DEFAULTS
82000                            CONTINUE
         DO 82100 I = 1, OLPXSZ
            OORDER(I) = I
            OLOOPX(I) = 3*I-2
82100    CONTINUE

         OLOOPX( OLPXSZ+1 ) = 3*OLPXSZ+1

         OLOOPC( OLOOPX( OORDER( PTACC  ) )     ) = ONE
         OLOOPC( OLOOPX( OORDER( PTACC  ) ) + 1 ) = ONE
         OLOOPC( OLOOPX( OORDER( PTACC  ) ) + 2 ) = DACC

         OLOOPC( OLOOPX( OORDER( PTGXPN ) )     ) = ONE
         OLOOPC( OLOOPX( OORDER( PTGXPN ) ) + 1 ) = ONE
         OLOOPC( OLOOPX( OORDER( PTGXPN ) ) + 2 ) = DGXPNS

         OLOOPC( OLOOPX( OORDER( PTFACT ) )     ) = ONE
         OLOOPC( OLOOPX( OORDER( PTFACT ) ) + 1 ) = ONE
         OLOOPC( OLOOPX( OORDER( PTFACT ) ) + 2 ) = DFACTR

         DO 82300 I = 1, NU
            OLOOPC( OLOOPX( OORDER( PTUSER(I) ) )     ) = ONE
            OLOOPC( OLOOPX( OORDER( PTUSER(I) ) ) + 1 ) = ONE
            OLOOPC( OLOOPX( OORDER( PTUSER(I) ) ) + 2 ) = USERD(I)
            USER(I) = USERD(I)
82300    CONTINUE
      GOTO RETRN2


C## R E M O T E   B L O C K   4:
C
C   SET PROBLEM DEFAULT VALUES

84000     PTSOLN   = 1
          SOLNS(1) = 0
          PPNAM  = UNDEFN
          PPNUM  = -1
          PFNAM  = BLANK
          PFNUM  = -1
          PGNAM  = BLANK
          PGNUM  = -1
          PMAX   = DMAXF
          PDESC  = BLANK
          PPERM  = DPERM
          IX0    = DIX0
          X(1)   = DX1
          X(2)   = DX2

          LDESC  = ZZLENG( PDESC )
          LORDER = ILPXSZ
          LLOOPX = ILPXSZ+1
          LLOOPC = ILPXSZ*3

C         INITIALIZE LOOPS

          DO 84100 I=1,ILPXSZ
             IORDER(I) = I
             ILOOPX(I) = 3*I-2
84100     CONTINUE

          ILOOPC(ILOOPX(IORDER(PTNDIM)))   = ONE
          ILOOPC(ILOOPX(IORDER(PTNDIM))+1) = ONE
          ILOOPC(ILOOPX(IORDER(PTNDIM))+2) = RD(DNDIM)

          ILOOPC(ILOOPX(IORDER(PTSCAL)))   = ONE
          ILOOPC(ILOOPX(IORDER(PTSCAL))+1) = ONE
          ILOOPC(ILOOPX(IORDER(PTSCAL))+2) = RD(DSCAL)

          ILOOPC(ILOOPX(IORDER(PTPXPN)))   = ONE
          ILOOPC(ILOOPX(IORDER(PTPXPN))+1) = ONE
          ILOOPC(ILOOPX(IORDER(PTPXPN))+2) = DPXPNS

          DO 84300 I=1,FNO
             ILOOPC(ILOOPX(IORDER(PTFARG(I))))   = ONE
             ILOOPC(ILOOPX(IORDER(PTFARG(I)))+1) = ONE
             ILOOPC(ILOOPX(IORDER(PTFARG(I)))+2) = DFARG
84300     CONTINUE

C---- RECORD NEXT FREE SPOT IN ILOOPC

          ILOOPX( LLOOPX ) = LLOOPC+1

          GOTO RETRN4

C##                                         R E M O T E   B L O C K   5:
C  INSERT INFO INTO THE INNER OR OUTER LOOPS
C  ON ENTRY TO THIS BLOCK :
C
C       LASTDL DETERMINES WHETHER THE VALUES CONSTITUTE A LOOP
C              OR A LIST.
C       OSCAL  DETERMINES WHETHER THE VALUES SHOULD BE TREATED
C              AS INTEGERS OR REALS ( 2 FOR INTEGER, 0 FOR REAL ).
C       PARS   CONTAINS THE ACTUAL LIST OR LOOP DATA.
C       OINDEX THIS IS A POINTER INTO THE ORDER ARRAY ( IORDER
C              OR OORDER ).
C       OUTER  THIS IS TRUE ONLY IF THE OUTER LOOPS ARE TO BE
C              MODIFIED.
85000 CONTINUE
C                    SET THE CODE AND THE STARTING VALUE
         CNEXT = 1

         IF (SEPART) THEN
            TCT = PARCT
            LPDATA ( CNEXT )   = ONE
            LPDATA ( CNEXT+1 ) = ONE
            LPTYPE = LLIST
         ELSE
            IF ( LASTDL .EQ. DCC(LOOPA:LOOPA) ) THEN
               LPDATA ( CNEXT )   = RD ( 0 - OSCAL )
               LPDATA ( CNEXT+1 ) = PAR1
               LPTYPE = LARITH
            ELSE IF ( LASTDL .EQ. DCC(LOOPG:LOOPG) ) THEN
               LPDATA ( CNEXT )   = RD ( -1 - OSCAL )
               LPDATA ( CNEXT+1 ) = PAR1
               LPTYPE = LGEOMT
            ELSE
               LPDATA ( CNEXT ) = RD ( PARCT )
               LPDATA ( CNEXT+1 ) = ONE
               LPTYPE = LLIST
            ENDIF
            TCT = 1
         ENDIF
         DO 85100 II=1,TCT
            CNEXT = 3
C                               STORE THE LOOP OR LIST VALUES
            DO 85010 I=1,PARCT/TCT
               LPDATA ( CNEXT ) = PARS (II-1+I )
               CNEXT = CNEXT + 1
85010       CONTINUE
C  SET DEFAULT LOOP INCREMENTS WHEN THERE ARE ONLY TWO PARAMETERS.
            IF ( PARCT .EQ. 2 ) THEN
               IF ( LPTYPE .EQ. LARITH ) THEN
                  LPDATA(CNEXT) = ONE
               ELSE IF ( LPTYPE .EQ. LGEOMT ) THEN
                  LPDATA(CNEXT) = TEN
               END IF
            END IF
C                               FILL IN THE CONTROL ARRAY
            IF ( OUTER ) THEN
C                                       MODIFY OUTER LOOP
               CALL ZZLMOD ( OLOOPC, OLPCSZ, OLOOPX, OORDER,
     -               OLPXSZ, LPDATA, OINDEX+II-1,LPTYPE, *91000 )
            ELSE
C                                       MODIFY INNER LOOP
               CALL ZZLMOD ( ILOOPC, ILPCSZ, ILOOPX, IORDER,
     -               ILPXSZ, LPDATA, OINDEX+II-1,LPTYPE, *91000 )

               LLOOPC = ILOOPX( LLOOPX ) - 1
            ENDIF
85100    CONTINUE
      SEPART = .FALSE.
      GOTO RETRN5

C## R E M O T E   B L O C K   7:
C
C   DISPLAY USER CONTROLLABLE SETTINGS.

87000 CONTINUE

         TMPUN = RPSOUT
87005                   CONTINUE

         IF ( VALS .EQ. CALL .OR. VALS .EQ. CINPUT ) THEN
C                                    DISPLAY COMMAND CONTROL SETTINGS
            WRITE ( TMPUN, 98050 ) 'CONTROL SETTINGS'
            WRITE ( TMPUN,   *   )
            WRITE ( TMPUN, 98101 ) 'TITLE REQ.',TITREQ,
     -                              'BRIEF',BRIEF,'TO UPPER',UPCASE
            WRITE ( TMPUN, 98101 ) 'TRACE',DCTRAC,'VERIFY',VERIFY,
     -                              'EOFBLK',EOFBLK
            WRITE ( TMPUN, 98150 ) 'ARITHMETIC',DCC(LOOPA:LOOPA),
     -                              'ASSIGNMENT',DCC(ASSMT:ASSMT)
            WRITE ( TMPUN, 98150 ) 'COMMENT1',DCC(COM1:COM1),
     -                              'COMMENT2',DCC(COM2:COM2),
     -                              'CONTINUATION', DCC(CONT:CONT)
            WRITE ( TMPUN, 98150 ) 'DELIMITER',DCC(DEL:DEL),
     -                              'ESCAPE',DCC(ESC:ESC),
     -                              'GEOMETRIC',DCC(LOOPG:LOOPG)
            WRITE ( TMPUN, 98150 ) 'RADIX',DCC(RADIX:RADIX),
     -                              'SEPARATOR',DCC(SEP:SEP),
     -                              'STRING1',DCC(STRNG1:STRNG1)
            WRITE ( TMPUN, 98150 ) 'STRING2',DCC(STRNG2:STRNG2)
            WRITE ( TMPUN, 98201 ) 'PHASE 5 CHECK IS:', VCHEC(LISTCD)
            WRITE ( TMPUN, 98201 ) 'CARRIAGE CONTROL:', VCC  (SYSCC)
         ENDIF

         IF ( VALS .EQ. CALL .OR. VALS .EQ. CLOOPS ) THEN
C                                    DISPLAY NUMERIC CONTROL VALUES
            WRITE ( TMPUN,   *   )
            WRITE ( TMPUN, 98050 ) 'NUMERIC CONTROL DATA'

            J = OLOOPX( OORDER(PTACC) )
            K = OLOOPX( OORDER(PTACC) + 1 ) - 1
            WRITE ( TMPUN, 98400 ) 'ACCURACY', NINT(OLOOPC(J)),
     -                              (OLOOPC(I), I = J+2, K )
            J = OLOOPX( OORDER(PTFACT) )
            K = OLOOPX( OORDER(PTFACT) + 1 ) - 1
            WRITE ( TMPUN, 98400 ) 'FACTOR', NINT(OLOOPC(J)),
     -                              (OLOOPC(I), I = J+2, K )
            J = OLOOPX( OORDER(PTGXPN) )
            K = OLOOPX( OORDER(PTGXPN) + 1 ) - 1
            WRITE ( TMPUN, 98400 ) 'EXPENSE', NINT(OLOOPC(J)),
     -                              (OLOOPC(I), I = J+2, K )
            DO 87100 II = 1, NU
               J = OLOOPX( OORDER(PTUSER(II)) )
               K = OLOOPX( OORDER(PTUSER(II)) + 1 ) - 1
               N = NINT( OLOOPC(J) )
               JJ = MAP1( XXLAST+II ) * 8
               S2 = CMDS( JJ-7 : JJ )
               IF    (  S2 .NE. BLANK ) THEN
                 WRITE(TMPUN,98450) II, S2, N, ( OLOOPC(I), I= J+2, K)
C!!!!            WRITE(TMPUN,98500) II, S2, N, ( OLOOPC(I), I= J+2, K)
               ENDIF
87100       CONTINUE
         ENDIF
         IF ( VALS .EQ. CALL .OR. VALS .EQ. CCONTR ) THEN
C                                    DISPLAY RUN CONTROL SETTINGS
            WRITE ( TMPUN,   *   )
            WRITE ( TMPUN, 98050 ) 'RUN CONTROL'
            WRITE ( TMPUN, 98050 ) '                 '//
     -                             'CRITERIA DEFINITIONS'
            NONE = T
            DO 87200 I = 1, MXCRIT
                IF (LL(I) .NE. BLANK) THEN
                    WRITE ( TMPUN, 98040 ) I, LL(I)(1:74)
                    NONE = F
                ENDIF
87200       CONTINUE
            IF ( NONE ) THEN
                WRITE ( TMPUN, 98050 ) '                    '//
     -                                   'THERE ARE NONE KNOWN.'
            ENDIF
            WRITE ( TMPUN,   *   )
            WRITE ( TMPUN, 98101 ) 'REVERSE',REVERS,'FUNC TRACE',
     -                               TRF,'GRAD TRACE',TRG
            WRITE ( TMPUN, 98101 ) 'PRINT GRAD',GRAD,'WRITE SUMM',
     -                               WRTSUM
            WRITE ( TMPUN, 98101 ) 'COPY',COPY,'TEX',TEX
            WRITE ( TMPUN, 98120 ) 'TRACES',TRACES
            WRITE ( TMPUN,   *   )
            WRITE ( TMPUN, 98200 ) 'DERV MODE',CDERV(DERVMD),
     -             'TERM TYPE',QUITS,'NORM TYPE',CNORM(NORM)
            WRITE ( TMPUN, 98100 ) 'F-RELATIVE',RELF,
     -                              'G-RELATIVE',RELG
            WRITE ( TMPUN, 98200 ) 'SEE LEVEL',VSEE(SEELEV),'SORT',
     -                               VSORT(SORT)
            WRITE ( TMPUN, 98220 ) 'MEMORY',MEMORY,'SUB NUMBER',SUBR,
     -                              'PRINT FREQ',PRINTL
            WRITE ( TMPUN,   *   )
            WRITE ( TMPUN, 98250 ) 'WRITE FILE',NMWRIT
            WRITE ( TMPUN, 98050 ) '     SUBROUTINE NAMES'
            NONE = T
            DO 87300 I=1,MXSUBS
               MAPKEY = MAP3( ZZLAST+I )
               J      = (MAPKEY-1)*KEYLEN+1
               K      = MAPKEY*KEYLEN
               IF ( CPARS(J:K) .NE. BLANK ) THEN
                   NONE = F
                   WRITE ( TMPUN, 98350 ) I, CPARS(J:K)
               ENDIF
87300       CONTINUE
            IF ( NONE ) WRITE ( TMPUN, * ) '      NONE DEFINED.'

            WRITE ( TMPUN,   *   )

         ENDIF

         IF ( COPY .AND. TMPUN .NE. COPYUN ) THEN
            TMPUN = COPYUN
            GOTO 87005
         ENDIF
      GOTO RETRN7

C## E X I T
90000 ASSIGN  95000 TO RETERR
      GOTO    92000

91000 ASSIGN  94000 TO RETERR
      GOTO    92000

C-----CLOSE ALMOST ALL FILES.

92000 CALL ZZCLSE ( SUMMUN, *92500 )
      CALL ZZCLSE ( STDIN , *92500 )
      CALL ZZCLSE ( TEMPUN, *92500 )
      CALL ZZCLSE ( PREPRC, *92500 )
      IF ( TEX ) THEN
         I = -NINT(LOG10(ACC))
         CALL ZZTEX(TEXUN, BLANK, -1 ,FUNCCT, ITCT, FNC, DF,
     -          FSTAR, I, GSQ, MING, DX, CRITNO, -1,TFUNC,TMIN )
      ENDIF
      GOTO   93000

92500 ASSIGN 94000 TO RETERR

C-----PRINT FINAL TIME SUMMARY.

93000 CALL ZZSECS ( TIMEIT )

      IF ( WRITFL ) THEN
         WRITE ( RESOUT, 99999 ) TIMEIT
      ENDIF

         WRITE ( RPSOUT, 99999 ) TIMEIT
         IF (COPY) WRITE ( COPYUN, 99999 ) TIMEIT

C-----CLOSE LAST THREE FILES.

      CALL ZZCLSE ( RESOUT, *94000 )
      CALL ZZCLSE ( TRCOUT, *92500 )
      CALL ZZCLSE ( RPSOUT, *94000 )
      CALL ZZCLSE ( COPYUN, *94000 )

      GOTO RETERR

94000 RECNO = 1
      CALL ZZRDIN(DAUF,IW,1,IPERLN,RECNO)
      IW(2) = FREEPT
      RECNO = 1
      CALL ZZWRIN(DAUF,IW,2,IPERLN,RECNO)
      CALL ZZCLSE(DAUF,*94500)
94500 STOP 'ABORTED'

95000 RECNO = 1
      CALL ZZRDIN(DAUF,IW,2,IPERLN,RECNO)
      IW(2) = FREEPT
      RECNO = 1
      CALL ZZWRIN(DAUF,IW,2,IPERLN,RECNO)
      CALL ZZCLSE(DAUF,*94500)
      STOP 'RUN OK'

C## F O R M A T S:

98000 FORMAT ( A1 )
98040 FORMAT ( 1X, I3,':',1X,  A )
98050 FORMAT ( 1X, A )
98100 FORMAT ( 5X,A,T20,L1,T28,'!',T30,A,T40,L1,T51,'!')
98101 FORMAT ( 5X, A, T20, L1,T28, A, T40, L1, T48, A, T61,L1)
98120 FORMAT ( 5X, A, 6X, 15 ( L3 ) )
98150 FORMAT ( 5X,A,T20,A1,T28, A, T40, A1, T48, A, T61, A1 )
98200 FORMAT ( 5X,A,T17,A,T28,'!',T30,A,T40,A,T51,'!',T53,A,T64, A )
98201 FORMAT ( 5X, A, T28, A )
98220 FORMAT ( 5X,A,T17,I7,T28,'!',T30,A,T41,I5,T51,'!',T53,A, T64,I5)
98250 FORMAT ( 5X, A, T17, ' : ', A40 )
98350 FORMAT ( 5X, I5, A10 )
98400 FORMAT ( 5X, A,                           T29, I3, 5D12.3 )
98450 FORMAT ( 5X, ' USER(', I2, ') =', T17, A8, T29, I3, 5D12.3 )
98500 FORMAT ( 5X, ' USER(', I2, ') =', T17, A8, T29, I3, 5G12.3 )
99999 FORMAT ( // ' TOTAL TIME TAKEN WAS ', F12.4,  ' SECONDS.' )

C##                 E N D OF ZZMT.
                    END
