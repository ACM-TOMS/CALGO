      SUBROUTINE ZZSECS(SECS)

C## A R G U M E N T S:
                      REAL              SECS
C!!!!                 DOUBLE PRECISION  SECS

C## S T A T U S:
C      SINGLE/DOUBLE Conversion:      NEEDED (SEE CONVRT).
C
C      IGNORE LINES BEGINNING WITH  "C!!!!" .
C
C      This version is in   S I N G L E   precision.
C!!!!  This version is in   D O U B L E   precision.
C
C      SYSTEM  DEPENDENCE:   System routine for CPU usage.

C==>CYBER/FTN5
C             This version is for  CYBER/FTN5
C==>VAX/BERK4.2
C             This version is for  VAX/BERK4.2(3)
C==>VAX/VMS
C             This version is for  VAX/VMS
C==>HW6
C             This version is for  HW6
C==>SUN4
C             This version is for  SUN4
C==>SUN3
C             This version is for  SUN3
C==>SSYM
C             THIS IS A VERSION FOR  Sequent Symmetry
C==>MAC/MS
C             This version is for  MAC/MS
C==>LAHEYF77L
C             THIS VERSION IS FOR  Lahey's F77L for PC's
C==>
C
C>RCS $Header: secs.gl,v 2.1 91/11/22 11:45:25 buckley Exp $
C>RCS $Log:	secs.gl,v $
C>RCS Revision 2.1  91/11/22  11:45:25  buckley
C>RCS Final submission to TOMS
C>RCS
C>RCS Revision 2.0  90/07/06  10:48:10  buckley
C>RCS common version for TOMS and MT
C>RCS
C>RCS Revision 1.9  89/06/30  13:30:19  buckley
C>RCS Preparing Submitted Version of Mt
C>RCS
C>RCS Revision 1.3.1.1  89/05/20  13:46:31  buckley
C>RCS Temp. test of Mt before submitting
C>RCS
C>RCS Revision 1.3  89/05/18  12:13:31  buckley
C>RCS Final test of Mt before submitting
C>RCS
C>RCS Revision 1.2  89/05/15  14:35:12  buckley
C>RCS Initial Installation of MT into RCS form.
C>RCS
C>RCS Revision 1.1  89/01/17  16:34:33  buckley
C>RCS Initial revision
C>RCS
C
C## D E S C R I P T I O N:

C     THIS SUBROUTINE SHOULD OBTAIN (FROM THE OPERATING SYSTEM) THE
C     AMOUNT OF CPU TIME USED BY THE CALLING PROGRAM SINCE THE
C     EXECUTION BEGAN. IF DESIRABLE, "SECS" CAN ALSO BE CONVERTED
C     TO DOUBLE PRECISION (SEE CONVRT). HOWEVER, THE ROUTINE ACTUALLY
C     WORKS TOTALLY AS A SINGLE PRECISION ROUTINE, EXCEPT THAT THE
C     VALUE WHICH IS PASSED BACK MAY BE IN EITHER PRECISION AS
C     APPROPRIATE.

C     TIME IS MEASURED FROM THE FIRST CALL TO ZZSECS.  THUS
C     ON THE FIRST CALL TO ZZSECS, A TIME OF  0.0  SECONDS IS ALWAYS
C     RETURNED.

C## E N T R Y   P O I N T S: The natural entry ZZSECS.
C## S U B R O U T I N E S:   A SYSTEM CLOCK.

C## P A R A M E T E R S:

C==>CYBER/FTN5
C==>VAX/BERK4.2
C==>SUN4
C==>SUN3
C==>SSYM

      REAL        ZERO
      PARAMETER ( ZERO = 0.0E0 )
C==>MAC/MS

      REAL        ZERO,         SHIFT,           SIXTY
      PARAMETER ( ZERO = 0.0E0, SHIFT = 2.0**32, SIXTY = 60.0 )
C==>VAX/VMS

      REAL        R100
      PARAMETER ( R100 = 100.0 )
C==>HW6

      INTEGER*8   ZERO
      PARAMETER ( ZERO = 0 )

      REAL        MICROS
      PARAMETER ( MICROS = 1000000.0 )
C==>LAHEYF77L

      INTEGER * 4 ONEDAY
      PARAMETER ( ONEDAY = 8640000 )
      REAL        ZERO,         R100
      PARAMETER ( ZERO = 0.0E0, R100 = 100.0 )
C==>

C## L O C A L   D E C L:

      LOGICAL  FIRST

C==>CYBER/FTN5

      REAL  SECOND
      REAL  STTIME,  SEC
C==>VAX/VMS

      INTEGER  CLOCK
      REAL     STTIME,  SEC
C==>MAC/MS

      INCLUDE  TOOLBX.PAR

      INTEGER  SECNDS, TOOLBX
      REAL     STTIME,  SEC
C==>VAX/BERK4.2
C==>SUN4
C==>SUN3
C==>SSYM

      REAL    ETIME, DUMMY(2)
      REAL    STTIME,  SEC

C==>HW6

      INTEGER*8  TOTAL_CPU_TIME_
      REAL       STTIME, SEC
C==>LAHEYF77L

      INTEGER * 4  STTIME, HUNSEC
      REAL         SEC
C==>

C## S A V E:

      SAVE   FIRST, STTIME

C## E Q U I V A L E N C E S: NONE are defined.
C## C O M M O N:             NONE is defined.

C## D A T A:

      DATA   FIRST/.TRUE./

C##                                            E X E C U T I O N
C##                                            E X E C U T I O N

      IF ( FIRST ) THEN

         FIRST  = .FALSE.
C==>CYBER/FTN5

         STTIME = SECOND()
C==>VAX/BERK4.2
C==>SUN4
C==>SUN3
C==>SSYM

         STTIME = ETIME(DUMMY)
C==>VAX/VMS

         STTIME = LIB$INIT_TIMER ( )

         STTIME = ZERO
C==>MAC/MS

         STTIME = REAL(TOOLBX(TICKCOUNT))/SIXTY
C==>HW6

         STTIME = TOTAL_CPU_TIME_()
C==>LAHEYF77L

         CALL TIMER(STTIME)
C==>

         SEC   = ZERO

      ELSE
C==>CYBER/FTN5

         SEC   = SECOND() - STTIME
C==>VAX/BERK4.2
C==>SUN4
C==>SUN3
C==>SSYM

         SEC = ETIME(DUMMY) - STTIME
C==>VAX/VMS

         SEC   = LIB$STAT_TIMER ( %REF(2), %REF(CLOCK), )
         SEC   = ( REAL(CLOCK)/R100 ) - STTIME
C==>MAC/MS

         SECNDS = TOOLBX(TICKCOUNT)
         SEC    = REAL(SECNDS)/SIXTY - STTIME

         IF ( SEC .LT. ZERO ) THEN
            SEC = SEC + SHIFT
         ENDIF

C==>HW6

         SEC = (TOTAL_CPU_TIME_() - STTIME) / MICROS
C==>LAHEYF77L

         CALL TIMER(HUNSEC)
         HUNSEC = HUNSEC - STTIME

C
C     Routine TIMER returns the time in hundredths of a second since
C     midnight.   Hence HUNSEC will be negative if midnight has been
C     passed.   The following code corrects this for any job which has
C     been running not more than 248 days !
C

   10    IF (HUNSEC .LT. 0) THEN
	    HUNSEC = HUNSEC + ONEDAY
	    GO TO 10
	 END IF
         SEC = HUNSEC / R100
C==>DUMMY

C        TO CHEAT AND QUICKLY CONVERT THIS TO A NON-SYSTEM DEPENDENT
C        ROUTINE, JUST SET SEC = ZERO.

         SEC = ZERO
C==>

      ENDIF

      SECS =      SEC
C!!!! SECS = DBLE(SEC)

C## E X I T
90000      RETURN

C## F O R M A T S:  NONE are defined.
C##                 E N D         of ZZSECS.
                    END
