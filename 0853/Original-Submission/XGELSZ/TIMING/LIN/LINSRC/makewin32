#######################################################################
# This makefile is part of the package for solving rank deficient
# least squares problems. 
# ==================================================================
#     L. Foster                   and   R. Kommu
#     Department of Mathematics         Department of Physics
#     San Jose State University         San Jose State University
#     San Jose, CA 95192                San Jose, CA 95192
#     foster@math.sjsu.edu              rkommu@email.sjsu.edu
# ==================================================================
# 03/05/2004
#
#  This is the makefile to create a library of the least squares
#  routines from LAPACK and xGELSZ that have been instrumented to time
#  specific parts of the code and count operations. 
#  The files are organized as follows:
#
#     SLINSRC -- Single precision real instrumented routines
#     CLINSRC -- Single precision complex instrumented routines
#     DLINSRC -- Double precision real instrumented routines
#     ZLINSRC -- Double precision complex instrumented routines
#
#  The library can be set up to include routines for any combination
#  of the four precisions.  To create or add to the library, enter
#  nmake -f makewin32 followed by one or more of the precisions
#  desired. Some examples:
#       nmake -f makewin32 single
#       nmake -f makewin32 single complex
#       nmake -f makewin32 single double complex complex16
#  Alternatively, the command
#       nmake -f makewin32
#  without any arguments creates a library of all four precisions.
#  The library is called
#       linsrc.a
#  and is created at the next higher directory level.
#
#  To remove the object files after the library is created, enter
#       nmake -f makewin32 clean
#
# Please refer to the readme file in XGELSZ/INSTALL for 
# further documentation on the use of makefiles in the package.
#######################################################################
!include <..\..\..\make.inc>

TIMLINSRC = $(LAPACK)\TIMING\LIN\LINSRC

SCAUX = sopla.obj sopla2.obj

DZAUX = dopla.obj dopla2.obj
 
SLINSRC = \
   sgels.obj  sgelsd.obj sgelss.obj sgelsx.obj sgelsy.obj sgelsz.obj slaic1.obj \
   slals0.obj slalsa.obj slalsd.obj

CLINSRC = \
   cgels.obj  cgelsd.obj cgelss.obj cgelsx.obj cgelsy.obj cgelsz.obj claic1.obj \
   clals0.obj clalsa.obj clalsd.obj

DLINSRC = \
   dgels.obj  dgelsd.obj dgelss.obj dgelsx.obj dgelsy.obj dgelsz.obj dlaic1.obj \
   dlals0.obj dlalsa.obj dlalsd.obj

ZLINSRC = \
   zgels.obj  zgelsd.obj zgelss.obj zgelsx.obj zgelsy.obj zgelsz.obj zlaic1.obj \
   zlals0.obj zlalsa.obj zlalsd.obj

all: single complex double complex16

single: $(SLINSRC) $(SCAUX)
	$(ARCH) $(ARCHFLAGS)..\$(LINSRCLIB) $(SLINSRC) $(SCAUX)

complex: $(CLINSRC) $(SCAUX)
	$(ARCH) $(ARCHFLAGS)..\$(LINSRCLIB) $(CLINSRC) $(SCAUX)

double: $(DLINSRC) $(DZAUX)
	$(ARCH) $(ARCHFLAGS)..\$(LINSRCLIB) $(DLINSRC) $(DZAUX)

complex16: $(ZLINSRC) $(DZAUX)
	$(ARCH) $(ARCHFLAGS)..\$(LINSRCLIB) *.obj

clean:
	del *.obj

sgelsz.obj: sgelsz.f
	$(FORTRAN) $(OPTS) -c $?
sopla.obj: sopla.f
	$(FORTRAN) $(OPTS) -c $?
sopla2.obj: {$(TIMLINSRC)}sopla2.f
	$(FORTRAN) $(OPTS) -c $?
sgels.obj: {$(TIMLINSRC)}sgels.f
	$(FORTRAN) $(OPTS) -c $?
sgelsd.obj: {$(TIMLINSRC)}sgelsd.f
	$(FORTRAN) $(OPTS) -c $?
sgelss.obj: {$(TIMLINSRC)}sgelss.f
	$(FORTRAN) $(OPTS) -c $?
sgelsx.obj: {$(TIMLINSRC)}sgelsx.f
	$(FORTRAN) $(OPTS) -c $?
sgelsy.obj: {$(TIMLINSRC)}sgelsy.f
	$(FORTRAN) $(OPTS) -c $?
slaic1.obj: {$(TIMLINSRC)}slaic1.f
	$(FORTRAN) $(OPTS) -c $?
slals0.obj: {$(TIMLINSRC)}slals0.f
	$(FORTRAN) $(OPTS) -c $?
slalsa.obj: {$(TIMLINSRC)}slalsa.f
	$(FORTRAN) $(OPTS) -c $?
slalsd.obj: {$(TIMLINSRC)}slalsd.f
	$(FORTRAN) $(OPTS) -c $?

cgelsz.obj: cgelsz.f
	$(FORTRAN) $(OPTS) -c $?
cgels.obj: {$(TIMLINSRC)}cgels.f
	$(FORTRAN) $(OPTS) -c $?
cgelsd.obj: {$(TIMLINSRC)}cgelsd.f
	$(FORTRAN) $(OPTS) -c $?
cgelss.obj: {$(TIMLINSRC)}cgelss.f
	$(FORTRAN) $(OPTS) -c $?
cgelsx.obj: {$(TIMLINSRC)}cgelsx.f
	$(FORTRAN) $(OPTS) -c $?
cgelsy.obj: {$(TIMLINSRC)}cgelsy.f
	$(FORTRAN) $(OPTS) -c $?
claic1.obj: {$(TIMLINSRC)}claic1.f
	$(FORTRAN) $(OPTS) -c $?
clals0.obj: {$(TIMLINSRC)}clals0.f
	$(FORTRAN) $(OPTS) -c $?
clalsa.obj: {$(TIMLINSRC)}clalsa.f
	$(FORTRAN) $(OPTS) -c $?
clalsd.obj: {$(TIMLINSRC)}clalsd.f
	$(FORTRAN) $(OPTS) -c $?

dgelsz.obj: dgelsz.f
	$(FORTRAN) $(OPTS) -c $?
dopla.obj: dopla.f
	$(FORTRAN) $(OPTS) -c $?
dopla2.obj: {$(TIMLINSRC)}dopla2.f
	$(FORTRAN) $(OPTS) -c $?
dgels.obj: {$(TIMLINSRC)}dgels.f
	$(FORTRAN) $(OPTS) -c $?
dgelsd.obj: {$(TIMLINSRC)}dgelsd.f
	$(FORTRAN) $(OPTS) -c $?
dgelss.obj: {$(TIMLINSRC)}dgelss.f
	$(FORTRAN) $(OPTS) -c $?
dgelsx.obj: {$(TIMLINSRC)}dgelsx.f
	$(FORTRAN) $(OPTS) -c $?
dgelsy.obj: {$(TIMLINSRC)}dgelsy.f
	$(FORTRAN) $(OPTS) -c $?
dlaic1.obj: {$(TIMLINSRC)}dlaic1.f
	$(FORTRAN) $(OPTS) -c $?
dlals0.obj: {$(TIMLINSRC)}dlals0.f
	$(FORTRAN) $(OPTS) -c $?
dlalsa.obj: {$(TIMLINSRC)}dlalsa.f
	$(FORTRAN) $(OPTS) -c $?
dlalsd.obj: {$(TIMLINSRC)}dlalsd.f
	$(FORTRAN) $(OPTS) -c $?

zgelsz.obj: zgelsz.f
	$(FORTRAN) $(OPTS) -c $?
zgels.obj: {$(TIMLINSRC)}zgels.f
	$(FORTRAN) $(OPTS) -c $?
zgelsd.obj: {$(TIMLINSRC)}zgelsd.f
	$(FORTRAN) $(OPTS) -c $?
zgelss.obj: {$(TIMLINSRC)}zgelss.f
	$(FORTRAN) $(OPTS) -c $?
zgelsx.obj: {$(TIMLINSRC)}zgelsx.f
	$(FORTRAN) $(OPTS) -c $?
zgelsy.obj: {$(TIMLINSRC)}zgelsy.f
	$(FORTRAN) $(OPTS) -c $?
zlaic1.obj: {$(TIMLINSRC)}zlaic1.f
	$(FORTRAN) $(OPTS) -c $?
zlals0.obj: {$(TIMLINSRC)}zlals0.f
	$(FORTRAN) $(OPTS) -c $?
zlalsa.obj: {$(TIMLINSRC)}zlalsa.f
	$(FORTRAN) $(OPTS) -c $?
zlalsd.obj: {$(TIMLINSRC)}zlalsd.f
	$(FORTRAN) $(OPTS) -c $?

.SUFFIXES: .f .obj
.f.obj: 
	$(FORTRAN) $(OPTS) -c $<
