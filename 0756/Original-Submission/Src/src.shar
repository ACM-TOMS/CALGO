#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  Contents.m clipdata.m dderiv.m ddisp.m dederiv.m dedisp.m
#   deimapf1.m deinvmap.m demap.m deparam.m depfun.m deplot.m dequad.m
#   dfixwc.m dimapf1.m dinvmap.m disk2hp.m dmap.m dparam.m dpfun.m
#   dplot.m dquad.m drawcb.m drawpoly.m elongdemo.m faber.m
#   faberdemo.m gaussj.m hp2disk.m hpderiv.m hpdisp.m hpimapf1.m
#   hpinvmap.m hpmap.m hpparam.m hppfun.m hpplot.m hpquad.m infdemo.m
#   modpoly.m moebius.m nebroyuf.m nechdcmp.m neconest.m nedemo.m
#   nefdjac.m nefn.m nehelp.m nehook.m neinck.m nelnsrch.m nemodel.m
#   neqrdcmp.m neqrsolv.m nersolv.m nesolve.m nestop.m netestf1.m
#   netrust.m plotpoly.m ptsource.m r2strip.m rcorners.m rderiv.m
#   rdisp.m rimapf1.m rinvmap.m rmap.m rparam.m rpfun.m rplot.m
#   rptrnsfm.m scaddvtx.m scangle.m sccheck.m scdemo.m scfix.m
#   scgenable.m scgget.m scgprops.m scgset.m scgui.m scguicb.m
#   scimapopt.m scimapz0.m scparmopt.m scplotopt.m scqdata.m
#   scselect.m stderiv.m stdisp.m stimapf1.m stinvmap.m stmap.m
#   stparam.m stpfun.m stplot.m stquad.m toobig.m tutdemo.m
# Wrapped by trh@tempest on Thu Jun 20 15:36:53 1996
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Contents.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Contents.m'\"
else
echo shar: Extracting \"'Contents.m'\" \(2698 characters\)
sed "s/^X//" >'Contents.m' <<'END_OF_FILE'
X% Schwarz-Christoffel Toolbox
X% Version 1.3   June 1, 1995.
X% Written by Toby Driscoll (driscoll@na-net.ornl.gov).
X% See user's guide for full usage details.
X%
X% Graphical user interface (GUI).
X%   scgui      - Activate graphical user interface.
X%   scgget     - Get polygon/solution properties from GUI.
X%   scgset     - Set polygon/solution properties in the GUI.
X% 
X% Working with polygons.
X%   drawpoly   - Draw a polygon with the mouse.
X%   plotpoly   - Plot a polygon.
X%   modpoly    - Modify a polygon with the mouse.
X%   scselect   - Select polygon vertices with the mouse.
X%   scaddvtx   - Add a vertex.
X%   scangle    - Compute turning angles.
X%   scfix      - Make polygon acceptable to other SC routines.
X% 
X% Half-plane->polygon map.
X%   hpparam    - Solve parameter problem.
X%   hpdisp     - Pretty-print solution data.
X%   hpmap      - Compute forward map.
X%   hpinvmap   - Compute inverse map.
X%   hpplot     - Adaptive plotting of the image of a cartesian grid.
X%   hpderiv    - Derivative of the map.
X% 
X% Disk->polygon map.
X%   dparam     - Solve parameter problem.
X%   ddisp      - Pretty-print solution data.
X%   dmap       - Compute forward map.
X%   dinvmap    - Compute inverse map.
X%   dplot      - Adaptive plotting of the image of a polar grid.
X%   dderiv     - Derivative of the map.
X% 
X% Disk->exterior polygon map.
X%   deparam    - Solve parameter problem.
X%   dedisp     - Pretty-print solution data.
X%   demap      - Compute forward map.
X%   deinvmap   - Compute inverse map.
X%   deplot     - Adaptive plotting of the image of a polar grid.
X%   dederiv    - Derivative of the map.
X% 
X% Strip->polygon map.
X%   stparam    - Solve parameter problem.
X%   stdisp     - Pretty-print solution data.
X%   stmap      - Compute forward map.
X%   stinvmap   - Compute inverse map.
X%   stplot     - Adaptive plotting of the image of a polar grid.
X%   stderiv    - Derivative of the map.
X% 
X% Rectangle->polygon map.
X%   rparam    - Solve parameter problem.
X%   rdisp     - Pretty-print solution data.
X%   rmap      - Compute forward map.
X%   rinvmap   - Compute inverse map.
X%   rplot     - Adaptive plotting of the image of a polar grid.
X%   rderiv    - Derivative of the map.
X% 
X% Conversion routines.
X%   hp2disk    - Convert a solution from half-plane to one from disk.
X%   disk2hp    - Convert a solution from disk to one from half-plane.
X%   dfixwc     - Choose conformal center of disk map.
X%   ptsource   - Graphical use of DFIXWC.
X%
X% Demonstrations.
X%   scdemo     - Select demos from a menu.
X%   tutdemo    - Walk through a tutorial.
X%   infdemo    - Explain infinite vertices.
X%   elongdemo  - Maps to elongated polygons.
X%   faberdemo  - Introduce Faber polynomials.
END_OF_FILE
if test 2698 -ne `wc -c <'Contents.m'`; then
    echo shar: \"'Contents.m'\" unpacked with wrong size!
fi
chmod +x 'Contents.m'
# end of 'Contents.m'
fi
if test -f 'clipdata.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'clipdata.m'\"
else
echo shar: Extracting \"'clipdata.m'\" \(971 characters\)
sed "s/^X//" >'clipdata.m' <<'END_OF_FILE'
Xfunction wc = clipdata(w,lim)
X%CLIPDATA (not intended for calling directly by the user)
X%	When adding curves one by one to a plot, it may be desirable to
X%	override the defualt behavior of redrawing the entire plot each
X%	time. This is done with the line's EraseMode property.
X%	Unfortunately, in Matlab 4.0, with no-redraw modes, lines are not
X%	always clipped to the axes box.  This routine clips manually.  The
X%	input vector W should be a vector of closely spaced complex points
X%	tracing out a smooth curve.  A cluster of points outside the box is
X%	replaced with NaN's, except for the first and last points of the
X%	cluster.
X%
X%       See also HPPLOT, DPLOT, DEPLOT, STPLOT, RPLOT.
X%
X%       Written by Toby Driscoll.  Last updated 5/24/95.
X
Xx = real(w);
Xy = imag(w);
Xoutside = (x < lim(1)) | (x > lim(2)) | (y < lim(3)) | (y > lim(4));
Xdout = diff(outside);
Xkill = outside & [1;dout~=1] & [dout~=-1;1];
Xwc = w;
Xjunk = NaN;
Xwc(kill) = junk(ones(size(wc(kill))));
X
X
END_OF_FILE
if test 971 -ne `wc -c <'clipdata.m'`; then
    echo shar: \"'clipdata.m'\" unpacked with wrong size!
fi
chmod +x 'clipdata.m'
# end of 'clipdata.m'
fi
if test -f 'dderiv.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dderiv.m'\"
else
echo shar: Extracting \"'dderiv.m'\" \(591 characters\)
sed "s/^X//" >'dderiv.m' <<'END_OF_FILE'
Xfunction fprime = dderiv(zp,z,beta)
X%DDERIV Derivative of the disk map.
X%	DDERIV(ZP,Z,BETA) returns the derivative at the points of ZP of
X%	the Schwarz-Christoffel disk map whose prevertices are Z and
X%	whose turning angles are BETA.
X%
X%       Don't forget the multiplicative constant in the SC map!
X%
X%	See also DPARAM, DMAP.
X%	
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xz = z(:);
Xbeta = beta(:);
Xzprow = zp(:).';
Xfprime = zeros(size(zp));
Xnpts = length(zp(:));
Xterms = 1 - zprow(ones(length(beta),1),:)./z(:,ones(npts,1));
Xfprime(:) = exp(sum(log(terms).*beta(:,ones(npts,1))));
END_OF_FILE
if test 591 -ne `wc -c <'dderiv.m'`; then
    echo shar: \"'dderiv.m'\" unpacked with wrong size!
fi
chmod +x 'dderiv.m'
# end of 'dderiv.m'
fi
if test -f 'ddisp.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ddisp.m'\"
else
echo shar: Extracting \"'ddisp.m'\" \(927 characters\)
sed "s/^X//" >'ddisp.m' <<'END_OF_FILE'
Xfunction ddisp(w,beta,z,c)
X%DDISP  Display results of Schwarz-Christoffel disk parameter problem.
X%       DDISP(W,BETA,Z,C) displays the results of DPARAM in a pleasant
X%       way.  
X%
X%	See also DPARAM, DPLOT.
X%	
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xdisp(' ')
Xdisp('          w               beta              z               arg(z)/pi')
Xdisp(' -----------------------------------------------------------------------')
Xu = real(w);
Xv = imag(w);
Xx = real(z);
Xy = imag(z);
Xang = angle(z)/pi;
Xang(ang<=0) = ang(ang<=0) + 2;
Xfor j = 1:length(w)
X  if v(j) < 0
X    s1 = '-';
X  else
X    s1 = '+';
X  end
X  if y(j) < 0
X    s2 = '-';
X  else
X    s2 = '+';
X  end
X  disp(sprintf(' %8.5f %c %7.5fi    %8.5f   %8.5f %c %7.5fi    %14.12f',...
X      u(j),s1,abs(v(j)),beta(j),x(j),s2,abs(y(j)),ang(j)));
X  
Xend
Xdisp(' ')
Xif imag(c) < 0
X  s = '-';
Xelse
X  s = '+';
Xend
Xdisp(sprintf('  c = %.8g %c %.8gi',real(c),s,abs(imag(c))))
END_OF_FILE
if test 927 -ne `wc -c <'ddisp.m'`; then
    echo shar: \"'ddisp.m'\" unpacked with wrong size!
fi
chmod +x 'ddisp.m'
# end of 'ddisp.m'
fi
if test -f 'dederiv.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dederiv.m'\"
else
echo shar: Extracting \"'dederiv.m'\" \(637 characters\)
sed "s/^X//" >'dederiv.m' <<'END_OF_FILE'
Xfunction fprime = dederiv(zp,z,beta)
X%DEDERIV Derivative of the exterior map.
X%	DEDERIV(ZP,Z,BETA) returns the derivative at the points of ZP of
X%	the Schwarz-Christoffel exterior map whose prevertices are Z and
X%	whose turning angles are BETA.
X%
X%       Don't forget the multiplicative constant in the SC map!
X%	
X%	See also DEPARAM, DEMAP.
X%	
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xz = z(:);
Xbeta = [beta(:);-2];
Xzprow = zp(:).';
Xfprime = zeros(size(zp));
Xnpts = length(zp(:));
Xterms = 1 - zprow(ones(length(z),1),:)./z(:,ones(npts,1));
Xterms(length(z)+1,:) = zprow;
Xfprime(:) = exp(sum(log(terms).*beta(:,ones(npts,1))));
END_OF_FILE
if test 637 -ne `wc -c <'dederiv.m'`; then
    echo shar: \"'dederiv.m'\" unpacked with wrong size!
fi
chmod +x 'dederiv.m'
# end of 'dederiv.m'
fi
if test -f 'dedisp.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dedisp.m'\"
else
echo shar: Extracting \"'dedisp.m'\" \(935 characters\)
sed "s/^X//" >'dedisp.m' <<'END_OF_FILE'
Xfunction dedisp(w,beta,z,c)
X%DEDISP Display results of Schwarz-Christoffel exterior parameter problem.
X%       DEDISP(W,BETA,Z,C) displays the results of DEPARAM in a pleasant
X%       way.  
X%
X%	See also DEPARAM, DEPLOT.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xdisp(' ')
Xdisp('          w               beta              z               arg(z)/pi')
Xdisp(' -----------------------------------------------------------------------')
Xu = real(w);
Xv = imag(w);
Xx = real(z);
Xy = imag(z);
Xang = angle(z)/pi;
Xang(ang<=0) = ang(ang<=0) + 2;
Xfor j = 1:length(w)
X  if v(j) < 0
X    s1 = '-';
X  else
X    s1 = '+';
X  end
X  if y(j) < 0
X    s2 = '-';
X  else
X    s2 = '+';
X  end
X  disp(sprintf(' %8.5f %c %7.5fi    %8.5f   %8.5f %c %7.5fi    %14.12f',...
X      u(j),s1,abs(v(j)),beta(j),x(j),s2,abs(y(j)),ang(j)));
X  
Xend
Xdisp(' ')
Xif imag(c) < 0
X  s = '-';
Xelse
X  s = '+';
Xend
Xdisp(sprintf('  c = %.8g %c %.8gi',real(c),s,abs(imag(c))))
END_OF_FILE
if test 935 -ne `wc -c <'dedisp.m'`; then
    echo shar: \"'dedisp.m'\" unpacked with wrong size!
fi
chmod +x 'dedisp.m'
# end of 'dedisp.m'
fi
if test -f 'deimapf1.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'deimapf1.m'\"
else
echo shar: Extracting \"'deimapf1.m'\" \(470 characters\)
sed "s/^X//" >'deimapf1.m' <<'END_OF_FILE'
Xfunction zdot = deimapf1(wp,yp);
X%DEIMAPF1 (not intended for calling directly by the user)
X%	Used by DEINVMAP for solution of an ODE.
X
Xglobal SCIMDATA 
X
Xlenyp = length(yp);
Xlenzp = lenyp/2;
Xzp = yp(1:lenzp)+sqrt(-1)*yp(lenzp+1:lenyp);
Xlenz = SCIMDATA(1,4);
Xbigz = SCIMDATA(1:lenz,2)*ones(1,lenzp);
Xbigbeta = SCIMDATA(1:lenz,3)*ones(1,lenzp);
X
Xf = SCIMDATA(1:lenzp,1).*exp(sum(log(1 - (ones(lenz,1)*zp.' )./bigz).*...
X    (-bigbeta))).'.*zp.^2;
Xzdot = [real(f);imag(f)];
END_OF_FILE
if test 470 -ne `wc -c <'deimapf1.m'`; then
    echo shar: \"'deimapf1.m'\" unpacked with wrong size!
fi
chmod +x 'deimapf1.m'
# end of 'deimapf1.m'
fi
if test -f 'deinvmap.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'deinvmap.m'\"
else
echo shar: Extracting \"'deinvmap.m'\" \(3208 characters\)
sed "s/^X//" >'deinvmap.m' <<'END_OF_FILE'
Xfunction zp = deinvmap(wp,w,beta,z,c,qdat,z0,options)
X%DEINVMAP Schwarz-Christoffel exterior inverse map.
X%	DEINVMAP(WP,W,BETA,Z,C,QDAT) computes the inverse of the
X%	Schwarz-Christoffel exterior map (i.e., from the exterior of a
X%	polygon to the disk) at the points given in vector WP.  The other
X%	arguments are as in DEPARAM.  QDAT may be omitted.
X%
X%	The default algorithm is to solve an ODE in order to obtain a fair
X%	approximation for ZP, and then improve ZP with Newton iterations.
X%	The ODE solution at WP requires a vector Z0 whose forward image W0
X%	is such that for each j, the line segment connecting WP(j) and W0(j)
X%	lies inside the polygon.  By default Z0 is chosen by a fairly robust
X%	automatic process.  Using a parameter (see below), you can choose to
X%	use either an ODE solution or Newton iterations exclusively.
X%
X%	DEINVMAP(WP,W,BETA,Z,C,QDAT,Z0) has two interpretations.  If the ODE
X%	solution is being used, Z0 overrides the automatic selection of
X%	initial points.  (This can be handy in convex polygons, where the
X%	choice of Z0 is trivial.)  Otherwise, Z0 is taken as an initial
X%	guess to ZP.  In either case, if length(Z0)==1, the value Z0 is used
X%	for all elements of WP; otherwise, length(Z0) should equal
X%	length(WP).
X%
X%       DEINVMAP(WP,W,BETA,Z,C,QDAT,Z0,OPTIONS) uses a vector of parameters
X%       that control the algorithm.  See SCIMAPOPT.
X%
X%	See also SCIMAPOPT, DEPARAM, DEMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
Xz = z(:);
Xbeta = beta(:);
Xzp = zeros(size(wp));
Xwp = wp(:);
Xlenwp = length(wp);
X
Xif nargin < 8
X  options = [];
X  if nargin < 7
X    z0 = [];
X    if nargin < 6
X      qdat = [];
X    end
X  end
Xend
X
X[ode,newton,tol,maxiter] = scimapopt(options);
X
Xif isempty(qdat)
X  qdat = scqdata(beta,max(ceil(-log10(tol)),2));
Xend
X
X% ODE
Xif ode
X  if isempty(z0)
X    % Pick a value z0 (not a singularity) and compute the map there.
X    [z0,w0] = scimapz0('de',wp,w,beta,z,c,qdat);
X  else
X    w0 = demap(z0,w,beta,z,c,qdat);
X    if length(z0)==1 & lenwp > 1
X      z0 = z0(:,ones(lenwp,1)).';
X      w0 = w0(:,ones(lenwp,1)).';
X    end
X  end
X
X  % Use relaxed ODE tol if improving with Newton.
X  odetol = max(tol,1e-3*(newton));
X
X  % Set up data for the ode function.
X  global SCIMDATA	
X  SCIMDATA = (wp - w0)/c; 		% adjusts "time" interval
X  SCIMDATA(1:n,2:3) = [z, beta];
X  SCIMDATA(1,4) = n;
X
X  z0 = [real(z0);imag(z0)];
X  [t,y] = ode45('deimapf1',0,1,z0,odetol);
X  [m,leny] = size(y);
X  zp(:) = y(m,1:lenwp)+sqrt(-1)*y(m,lenwp+1:leny);
Xend
X
X% Newton iterations
Xif newton
X  if ~ode
X    zn = z0(:);
X    if length(z0)==1 & lenwp > 1
X      zn = zn(:,ones(lenwp,1));
X    end
X  else
X    zn = zp(:);
X  end
X    
X  wp = wp(:);
X  done = zeros(size(zn));
X  k = 0;
X  while ~all(done) & k < maxiter
X    F = wp(~done) - demap(zn(~done),w,beta,z,c,qdat);
X    m = length(F);
X    dF = c*(zn(~done).').^(-2).*...
X      exp(sum(beta(:,ones(m,1)) .* log(1-(zn(~done,ones(n,1)).')./z(:,ones(m,1)))));
X    zn(~done) = zn(~done) + F(:)./dF(:);
X    done(~done) = (abs(F)< tol);
X    k = k+1;
X  end
X  if any(abs(F)> tol)
X    disp('Warning in deinvmap: Solution may be inaccurate')
X    fprintf('Maximum residual = %.3g\n',max(abs(F)))
X  end
X  zp(:) = zn; 
Xend;
X
END_OF_FILE
if test 3208 -ne `wc -c <'deinvmap.m'`; then
    echo shar: \"'deinvmap.m'\" unpacked with wrong size!
fi
chmod +x 'deinvmap.m'
# end of 'deinvmap.m'
fi
if test -f 'demap.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demap.m'\"
else
echo shar: Extracting \"'demap.m'\" \(2003 characters\)
sed "s/^X//" >'demap.m' <<'END_OF_FILE'
Xfunction wp = demap(zp,w,beta,z,c,qdat)
X%DEMAP  Schwarz-Christoffel exterior map.
X%       DEMAP(ZP,W,BETA,Z,C,QDAT) computes the values of the Schwarz-
X%       Christoffel exterior map at the points in vector ZP.  The arguments 
X%       W, BETA, Z, C, and QDAT are as in DEPARAM.  DEMAP returns a vector
X%       the same size as ZP.
X%
X%       DEMAP(ZP,W,BETA,Z,C,TOL) uses quadrature data intended to give an
X%       answer accurate to within roughly TOL.
X%
X%	See also DEPARAM, DEPLOT, DEINVMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/31/95.
X
Xif nargin < 6
X  qdat = scqdata(beta,8);
Xelseif length(qdat)==1
X  qdat = scqdata(beta,max(ceil(-log10(qdat)),8));
Xend
X
Xn = length(w);
Xbeta = beta(:);
Xz = z(:);
Xp = length(zp);
Xwp = zeros(size(zp));
Xws = wp;
Xzs = wp;
X
X% For each point in zp, find nearest prevertex.
X[mindist,sing] = min(abs(ones(n,1)*zp(:).'-z(:,ones(1,p))));
X
X% zs = the starting singularities
X% A MATLAB technicality could cause a mistake if sing is all ones and same
X% length as z, hence a workaround.
Xzs(1:p+1) = z([sing,2]);
Xzs = zs(1:p);
X% ws = SCmap(zs)
Xws(1:p+1) = w([sing,2]);
Xws = ws(1:p);
X
X% Must be careful about the singularity at the origin, since the
X% quadrature routine doesn't pay attention to the right endpoint.
X
Xabszp = abs(zp); 			% dist to sing at 0
Xzp2zs = abs(zp-zs);			% dist from zp to zs
Xbad = zp2zs < 10*eps;
Xunf = ones(size(zp2zs));		% unfinished?
Xdist = unf;
Xznew = unf;
X% Take care of "bad" ones explicitly.
Xwp(bad) = ws(bad);
Xunf(bad) = zeros(size(unf(bad)));
X% Integrate for the rest.
Xdist(unf) = min(1,2*abszp(unf)./zp2zs(unf));	% how far may we go?
Xznew(unf) = zs(unf) + dist(unf).*(zp(unf)-zs(unf));
Xwp(unf) = ws(unf) + c*dequad(zs(unf),znew(unf),sing(unf),z,beta,qdat);
Xunf = (dist<1); 			% unfinished positions
Xwhile any(unf)
X  zold = znew;
X  dist(unf) = min(1,2*abszp(unf)./abs(zp(unf)-zold(unf)));
X  znew(unf) = zold(unf) + dist(unf).*(zp(unf)-zold(unf));
X  wp(unf) = wp(unf) + c*dequad(zold(unf),znew(unf),[],z,beta,qdat);
X  unf = (dist<1);
Xend
X
END_OF_FILE
if test 2003 -ne `wc -c <'demap.m'`; then
    echo shar: \"'demap.m'\" unpacked with wrong size!
fi
chmod +x 'demap.m'
# end of 'demap.m'
fi
if test -f 'deparam.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'deparam.m'\"
else
echo shar: Extracting \"'deparam.m'\" \(3287 characters\)
sed "s/^X//" >'deparam.m' <<'END_OF_FILE'
Xfunction [z,c,qdat] = deparam(w,beta,z0,options)
X%DEPARAM Schwarz-Christoffel exterior parameter problem.
X%       [Z,C,QDAT] = DEPARAM(W,BETA) solves the Schwarz-Christoffel
X%       mapping parameter problem with a disk as fundamental domain and
X%       the exterior of the polygon specified by W as the target.  W
X%       must be a vector of the vertices of the polygon, specified in
X%       clockwise order, and BETA should be a vector of the turning
X%       angles of the polygon; see SCANGLES for details.  If successful,
X%       DEPARAM will return Z, a vector of the pre-images of W; C, the
X%       multiplicative constant of the conformal map; and QDAT, a matrix
X%       of quadrature data used by some of the other S-C routines.
X%
X%       [Z,C,QDAT] = DEPARAM(W,BETA,Z0) uses Z0 as an initial guess for
X%       Z.
X%
X%       [Z,C,QDAT] = DEPARAM(W,BETA,Z0,OPTIONS) uses a vector of control
X%       parameters.  See SCPARMOPT.
X%	
X%	See also SCPARMOPT, DRAWPOLY, DEDISP, DEPLOT, DEMAP, DEINVMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w); 				% no. of vertices
Xw = w(:);
Xbeta = beta(:);
X
X% Set up defaults for missing args
Xif nargin < 4
X  options = [];
X  if nargin < 3
X    z0 = [];
X  end
Xend
X
Xerr = sccheck('de',w,beta);
Xif err==1
X  fprintf('Use SCFIX to make polygon obey requirements\n')
X  error(' ')
Xend
X
X[trace,tol] = scparmopt(options);
Xnqpts = max(ceil(-log10(tol)),2);
Xqdat = scqdata(beta,nqpts); 		% quadrature data
X  
X%%if length(beta)~=n
X%%  error('Mismatched angles and vertices')
X%%elseif any(beta > 1) | any(beta <= -1)
X%%  error('Each entry of beta must be in (-1,1]')
X%%elseif abs(sum(beta)-2) > tol
X%%  disp('Warning: angles do not sum to +2')
X%%  if abs(sum(beta)+2) < tol
X%%    disp('Vertices were probably specified in the wrong order.')
X%%    disp('Use flipud and scangle to reverse ordering.')
X%%    return
X%%  end
X%%elseif (beta(n)==0 | beta(n)==1) & (n > 2)
X%%  error('Sides adjacent to w(n) must not be collinear')
X%%elseif n < 2
X%%  error('Polygon must have at least two vertices')
X%%end
X
Xif n==2					% it's a slit
X  z = [-1;1];
X
Xelse
X  % Set up normalized lengths for nonlinear equations
X  len = abs(diff(w([n,1:n])));
X  nmlen = abs(len(3:n-1)/len(2));
X  
X  % Set up initial guess
X  if isempty(z0)
X    y0 = zeros(n-1,1);
X  else
X    th = angle(z0(:));
X    th(th<=0) = th(th<=0) + 2*pi;
X    dt = diff([0;th(1:n-1);2*pi]);
X    y0 = log(dt(1:n-1)./dt(2:n));
X  end
X  
X  % Solve nonlinear system of equations:
X
X  % package data
X  nrow = max([n,nqpts,3]);
X  ncol = 3+2*(n+1);
X  fdat = zeros(nrow,ncol);
X  fdat(1:3,1) = [n;nqpts;ncol];
X  fdat(1:n,2) = beta;
X  if n > 3
X    fdat(1:n-3,3) = nmlen(:);
X  end
X  fdat(1:nqpts,4:ncol) = qdat;
X  % set options
X  opt = zeros(16,1);
X  opt(1) = trace;
X  opt(6) = 100*(n-3);
X  opt(8) = tol;
X  opt(9) = tol/10;
X  opt(12) = nqpts;
X  % do it
X  [y,termcode] = nesolve('depfun',y0,opt,fdat);
X  if termcode~=1
X    disp('Warning: Nonlinear equations solver did not terminate normally')
X  end
X  
X  % Convert y values to z
X  cs = cumsum(cumprod([1;exp(-y)]));
X  theta = 2*pi*cs/cs(n);
X  z = ones(n,1);
X  z(1:n-1) = [exp(i*theta(1:n-1))];
Xend
X
X% Determine scaling constant
Xmid = exp(i*mean(angle(z(n-1:n))));
Xc = (w(n) - w(n-1)) / (dequad(z(n-1),mid,n-1,z,beta,qdat)-...
X    dequad(z(n),mid,n,z,beta,qdat));
X
X
END_OF_FILE
if test 3287 -ne `wc -c <'deparam.m'`; then
    echo shar: \"'deparam.m'\" unpacked with wrong size!
fi
chmod +x 'deparam.m'
# end of 'deparam.m'
fi
if test -f 'depfun.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'depfun.m'\"
else
echo shar: Extracting \"'depfun.m'\" \(1213 characters\)
sed "s/^X//" >'depfun.m' <<'END_OF_FILE'
Xfunction F = depfun(y,fdat)
X%DEPFUN (not intended for calling directly by the user)
X%	Returns residual for solution of nonlinear equations.
X%	Used by DEPARAM.
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
Xn = fdat(1,1);
Xbeta = fdat(1:n,2);
Xnmlen = fdat(1:n-3,3);
Xqdat = fdat(1:fdat(2,1),4:fdat(3,1));
X
X% Transform y (unconstr. vars) to z (prevertices)
Xcs = cumsum(cumprod([1;exp(-y)]));
Xtheta = 2*pi*cs(1:n-1)/cs(n);
Xz = ones(n,1);
Xz(1:n-1) = exp(i*theta);
X
X% Check crowding.
Xif any(diff(theta)<eps) | any(isnan(theta))
X  % Since abs(y) is large, use it as the penalty function.
X  F = y;
X  disp('Warning: Severe crowding')
X  return
Xend
X
X% Compute the integrals appearing in nonlinear eqns.
Xdtheta = theta(2:n-1) - theta(1:n-2);
Xdtheta(dtheta > pi) = dtheta(dtheta > pi) - 2*pi;
Xmid = exp(i*(theta(1:n-2) + dtheta/2));
X
Xints = dequad(z(1:n-2),mid,1:n-2,z,beta,qdat) - ...
X    dequad(z(2:n-1),mid,2:n-1,z,beta,qdat);
X
Xif any(ints==0)
X  % Singularities were too crowded in practice.
X  F = y;
X  disp('Warning: Severe crowding')
Xelse
X  % Compute equation residual values.
X  F = abs(ints(2:n-2))/abs(ints(1)) - nmlen;  
X
X  % Compute residue.
X  res = -sum(beta./z)/ints(1);
X
X  F = [F;real(res);imag(res)];
Xend
X
X
END_OF_FILE
if test 1213 -ne `wc -c <'depfun.m'`; then
    echo shar: \"'depfun.m'\" unpacked with wrong size!
fi
chmod +x 'depfun.m'
# end of 'depfun.m'
fi
if test -f 'deplot.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'deplot.m'\"
else
echo shar: Extracting \"'deplot.m'\" \(3850 characters\)
sed "s/^X//" >'deplot.m' <<'END_OF_FILE'
Xfunction [H,R2,THETA] = deplot(w,beta,z,c,R,theta,options)
X%DEPLOT Image of polar grid under Schwarz-Christoffel exterior map.
X%       DEPLOT(W,BETA,Z,C) will adaptively plot the images under the
X%       Schwarz-Christoffel exterior map of ten evenly spaced circles
X%       and rays in the unit disk.  The arguments are as in DEPARAM.
X%
X%       DEPLOT(W,BETA,Z,C,M,N) will plot images of M evenly spaced
X%       circles and N evenly spaced rays.
X%
X%       DEPLOT(W,BETA,Z,C,R,THETA) will plot images of circles whose
X%       radii are given in R and rays whose arguments are given in
X%       THETA.  Either argument may be empty.
X%
X%       DEPLOT(W,BETA,Z,C,R,THETA,OPTIONS) allows customization of
X%       DEPLOT's behavior.  See SCPLOTOPT.
X%
X%       H = DEPLOT(W,BETA,Z,C,...) returns a vector of handles to all
X%       the curves drawn in the interior of the polygon.  [H,R,THETA] =
X%       DEPLOT(W,BETA,Z,C,...) also returns the moduli and arguments of
X%       the curves comprising the grid.
X%	
X%	See also SCPLOTOPT, DEPARAM, DEMAP, DEDISP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
Xbeta = beta(:);
Xz = z(:);
X
Xturn_off_hold = ~ishold;
Xif nargin < 7
X  options = [];
X  if nargin < 6
X    theta = [];
X    if nargin < 5 
X      R = [];
X    end
X  end
Xend
X
Xif isempty([R(:);theta(:)])
X  R = 10;
X  theta = 10;
Xend
X
Xif (length(R)==1) & (R == round(R))
X  m = R+2;
X  R = fliplr(linspace(.25,1,m));
X  R([1,m]) = [];
Xend
Xif (length(theta)==1) & (theta == round(theta))
X  m = theta+1;
X  theta = linspace(0,2*pi,m);
X  theta(m) = [];
Xend
X
X[nqpts,maxturn,maxlen,maxrefn] = scplotopt(options);
Xautoscale = strcmp(get(gca,'xlimmode'),'auto') & ...
X    strcmp(get(gca,'ylimmode'),'auto');
Xautoscale = autoscale | ~ishold;
X
Xfig = gcf;
Xfigure(fig);
Xplotpoly(w,beta);
Xhold on
X
Xaxlim = axis;
Xif autoscale
X  axlim(1:2) = axlim(1:2) + 0.25*diff(axlim(1:2))*[-1,1];
X  axlim(3:4) = axlim(3:4) + 0.25*diff(axlim(3:4))*[-1,1];
X  axis(axlim);
Xend
Xdrawnow
X
Xn = length(w);
Xwf = w(~isinf(w));
Xreflen = maxlen*max(abs(diff([wf;wf(1)])));
X
Xqdat = scqdata(beta,nqpts);
XRp0 = linspace(.1,1,15)';
X  
Xfor j = 1:length(R)
X  tp = linspace(0,2*pi,16)';
X  tp = [tp(length(tp)-1)-2*pi;tp];
X  zp = R(j)*exp(i*tp);
X  wp = demap(zp,w,beta,z,c,qdat);
X  bad = find(toobig(wp,maxturn,reflen,axis));
X  iter = 0;
X  while (~isempty(bad)) & (iter < maxrefn)
X    lenwp = length(wp);
X    newt = [(tp(bad-1)+2*tp(bad))/3;(tp(bad+1)+2*tp(bad))/3];
X    newz = R(j)*exp(i*newt);
X    neww = demap(newz,w,beta,z,c,qdat);
X    [k,in] = sort([tp;newt]);
X    tp = [tp;newt];  wp = [wp;neww];
X    tp = tp(in);     wp = wp(in);
X    iter = iter + 1;
X    bad = find(toobig(wp,maxturn,reflen,axis));
X  end
X  tp(tp<0) = tp(tp<0) + 2*pi;
X  [k,in] = sort(tp);
X  linh(j) = plot(clipdata(wp(in),axis), 'g-','erasemode','none');
X  set(linh(j),'erasemode','normal');
X  drawnow
X  Z(1:length(zp),j) = zp;
X  W(1:length(wp),j) = wp;
Xend
X
Xfor j = 1:length(theta)
X  Rp = Rp0;
X  zp = Rp*exp(i*theta(j));
X  wp = demap(zp,w,beta,z,c,qdat);
X  bad = find(toobig(wp,maxturn,reflen,axis));
X  iter = 0;
X  while (~isempty(bad)) & (iter < maxrefn)
X    lenwp = length(wp);
X    newR = [(Rp(bad-1)+2*Rp(bad))/3;(Rp(bad+1)+2*Rp(bad))/3];
X    newz = newR*exp(i*theta(j));
X    neww = demap(newz,w,beta,z,c,qdat);
X    [k,in] = sort([Rp;newR]);
X    Rp = [Rp;newR];  wp = [wp;neww];
X    Rp = Rp(in);     wp = wp(in);
X    iter = iter + 1;
X    bad = find(toobig(wp,maxturn,reflen,axis));
X  end
X  linh(j+length(R)) = plot(clipdata(wp,axis), 'g-','erasemode','none');
X  drawnow
X  set(linh(j+length(R)),'erasemode','normal');
X  Z(1:length(zp),j+length(R)) = zp;
X  W(1:length(wp),j+length(R)) = wp;
Xend
X
X% Force redraw to get clipping enforced.
Xset(fig,'color',get(fig,'color'))
Xif turn_off_hold, hold off, end;
Xif nargout > 0
X  H = linh;
X  if nargout > 1
X    R2 = R;
X    if nargout > 2
X      THETA = theta;
X    end
X  end
Xend 
X
END_OF_FILE
if test 3850 -ne `wc -c <'deplot.m'`; then
    echo shar: \"'deplot.m'\" unpacked with wrong size!
fi
chmod +x 'deplot.m'
# end of 'deplot.m'
fi
if test -f 'dequad.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dequad.m'\"
else
echo shar: Extracting \"'dequad.m'\" \(2519 characters\)
sed "s/^X//" >'dequad.m' <<'END_OF_FILE'
Xfunction I = dequad(z1,z2,sing1,z,beta,qdat)
X%DEQUAD (not intended for calling directly by the user)
X%	Numerical quadrature for the exterior map.
X
X%       z1,z2 are vectors of left and right endpoints.  sing1 is a
X%       vector of integer indices which label the singularities in z1.
X%       So if sing1(5) = 3, then z1(5) = z(3).  A zero means no
X%       singularity.  z is the vector of prevertices (all singularities
X%       except the origin); beta is the vector of associated turning
X%       angles.  qdat is quadrature data from SCQDATA.
X%
X%	Make sure that z and beta are column vectors.
X%	
X%	DEQUAD integrates from a possible singularity at the left end to a
X%	regular point at the right.  If both endpoints are singularities,
X%	you must break the integral into two pieces and make two calls.
X%	
X%	The integral is subdivided, if necessary, so that no
X%	singularity lies closer to the left endpoint than 1/2 the
X%	length of the integration (sub)interval.  But the singularity at the
X%	origin is NOT accounted for in this decision.
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
Xnqpts = size(qdat,1);
Xn = length(z);
Xbigz = z(:,ones(1,nqpts));
Xbeta = [beta(:);-2];
Xbigbeta = beta(:,ones(1,nqpts));
Xif isempty(sing1)
X  sing1 = zeros(length(z1),1);
Xend
X
XI = zeros(size(z1));
Xnontriv = find(z1(:)~=z2(:))';
X
Xfor k = nontriv
X  za = z1(k);
X  zb = z2(k);
X  sng = sing1(k);
X
X  % Allowable integration step, based on nearest singularity.
X  dist = min(1,2*min(abs(z([1:sng-1,sng+1:n])-za))/abs(zb-za));
X  zr = za + dist*(zb-za);
X  % Adjust Gauss-Jacobi nodes and weights to interval.
X  ind = sng + (n+1)*(sng==0);
X  nd = ((zr-za)*qdat(:,ind) + zr + za)/2; % nodes
X  wt = ((zr-za)/2) * qdat(:,ind+n+1);	% weights
X  terms = 1 - nd(:,ones(n,1)).'./bigz;
X  if any(~diff(nd)) | any(any(~terms))
X    % Endpoints are practically coincident.
X    I(k) = 0;
X  else 
X    terms = [terms;nd.'];
X    % Use Gauss-Jacobi on first subinterval, if necessary.
X    if sng > 0
X      terms(sng,:) = terms(sng,:)./abs(terms(sng,:));
X      wt = wt*(abs(zr-za)/2)^beta(sng);
X    end
X    I(k) = exp(sum(log(terms).*bigbeta))*wt;
X    while dist < 1              
X      % Do regular Gaussian quad on other subintervals.
X      zl = zr;
X      dist = min(1,2*min(abs(z-zl))/abs(zl-zb));
X      zr = zl + dist*(zb-zl);
X      nd = ((zr-zl)*qdat(:,n+1) + zr + zl)/2;
X      wt = ((zr-zl)/2) * qdat(:,2*n+2);
X      terms = 1 - nd(:,ones(n,1)).'./bigz;
X      terms = [terms;nd.'];
X      I(k) = I(k) + exp(sum(log(terms).*bigbeta))*wt;
X    end
X  end
Xend
X
END_OF_FILE
if test 2519 -ne `wc -c <'dequad.m'`; then
    echo shar: \"'dequad.m'\" unpacked with wrong size!
fi
chmod +x 'dequad.m'
# end of 'dequad.m'
fi
if test -f 'dfixwc.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dfixwc.m'\"
else
echo shar: Extracting \"'dfixwc.m'\" \(1006 characters\)
sed "s/^X//" >'dfixwc.m' <<'END_OF_FILE'
Xfunction [y,d] = dfixwc(w,beta,z,c,wc,z0)
X%DFIXWC Fix conformal center of disk map.
X%       The conformal center WC of a Schwarz-Christoffel interior disk
X%       map is defined as the image of zero.  The parameter problem
X%       solver DPARAM does not allow control over the placement of the
X%       conformal center.  Using the output Z,C from DPARAM, [Z0,C0] =
X%       DFIXWC(W,BETA,Z,C,WC) computes a Moebius transformation so that
X%       if Z0 and C0 are used in place of Z and C, the conformal center
X%       of the resulting map will be WC.
X%
X%	See also DPARAM, PTSOURCE.
X%	
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
X
Xif nargin < 6
X  z0 = [];
Xend 
X
Xzc = dinvmap(wc,w,beta,z,c,[],z0,[0,1e-10]);
X
X% Transform prevertices.
Xy = ((1-zc')/(1-zc))*(z-zc)./(1-zc'*z);
Xy(n) = 1;				% force it to be exact
X
X% Recalculate constant from scratch.
Xmid = (y(1)+y(2))/2;
Xqdat = scqdata(beta,10);
Xd = (w(1) - w(2))/...
X    (dquad(y(2),mid,2,y,beta,qdat) - dquad(y(1),mid,1,y,beta,qdat));
X
END_OF_FILE
if test 1006 -ne `wc -c <'dfixwc.m'`; then
    echo shar: \"'dfixwc.m'\" unpacked with wrong size!
fi
chmod +x 'dfixwc.m'
# end of 'dfixwc.m'
fi
if test -f 'dimapf1.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dimapf1.m'\"
else
echo shar: Extracting \"'dimapf1.m'\" \(448 characters\)
sed "s/^X//" >'dimapf1.m' <<'END_OF_FILE'
Xfunction zdot = dimapf1(wp,yp);
X%DIMAPF1 (not intended for calling directly by the user)
X%	Used by DINVMAP for solution of an ODE.
X
Xglobal SCIMDATA 
X
Xlenyp = length(yp);
Xlenzp = lenyp/2;
Xzp = yp(1:lenzp)+sqrt(-1)*yp(lenzp+1:lenyp);
Xn = SCIMDATA(1,4);
Xbigz = SCIMDATA(1:n,2)*ones(1,lenzp);
Xbigbeta = SCIMDATA(1:n,3)*ones(1,lenzp);
X
Xf = SCIMDATA(1:lenzp,1).*exp(sum(log(1 - (ones(n,1)*zp.' )./bigz).*...
X    (-bigbeta))).';
Xzdot = [real(f);imag(f)];
END_OF_FILE
if test 448 -ne `wc -c <'dimapf1.m'`; then
    echo shar: \"'dimapf1.m'\" unpacked with wrong size!
fi
chmod +x 'dimapf1.m'
# end of 'dimapf1.m'
fi
if test -f 'dinvmap.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dinvmap.m'\"
else
echo shar: Extracting \"'dinvmap.m'\" \(3252 characters\)
sed "s/^X//" >'dinvmap.m' <<'END_OF_FILE'
Xfunction zp = dinvmap(wp,w,beta,z,c,qdat,z0,options)
X%DINVMAP Schwarz-Christoffel disk inverse map.
X%       DINVMAP(WP,W,BETA,Z,C,QDAT) computes the inverse of the
X%       Schwarz-Christoffel disk map   (i.e., from a polygon to the disk) at
X%       the points given in vector WP.  The other arguments are as in
X%       DPARAM.  QDAT my be omitted.
X%
X%	The default algorithm is to solve an ODE in order to obtain a fair
X%	approximation for ZP, and then improve ZP with Newton iterations.
X%	The ODE solution at WP requires a vector Z0 whose forward image W0
X%	is such that for each j, the line segment connecting WP(j) and W0(j)
X%	lies inside the polygon.  By default Z0 is chosen by a fairly robust
X%	automatic process.  Using a parameter (see below), you can choose to
X%	use either an ODE solution or Newton iterations exclusively.
X%
X%	DINVMAP(WP,W,BETA,Z,C,QDAT,Z0) has two interpretations.  If the ODE
X%	solution is being used, Z0 overrides the automatic selection of
X%	initial points.  (This can be handy in convex polygons, where the
X%	choice of Z0 is trivial.)  Otherwise, Z0 is taken as an initial
X%	guess to ZP.  In either case, if length(Z0)==1, the value Z0 is used
X%	for all elements of WP; otherwise, length(Z0) should equal
X%	length(WP).
X%
X%       DINVMAP(WP,W,BETA,Z,C,QDAT,Z0,OPTIONS) uses a vector of parameters
X%       that control the algorithm.  See SCIMAPOPT.
X%
X%	See also SCIMAPOPT, DPARAM, DMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
Xbeta = beta(:);
Xz = z(:);
Xzp = zeros(size(wp));
Xwp = wp(:);
Xlenwp = length(wp);
X
Xif nargin < 8
X  options = [];
X  if nargin < 7
X    z0 = [];
X    if nargin < 6
X      qdat = [];
X    end
X  end
Xend
X
X[ode,newton,tol,maxiter] = scimapopt(options);
X
Xif isempty(qdat)
X  qdat = scqdata(beta,max(ceil(-log10(tol)),2));
Xend
X
X
X% ODE
Xif ode
X  if isempty(z0)
X    % Pick a value z0 (not a singularity) and compute the map there.
X    [z0,w0] = scimapz0('d',wp,w,beta,z,c,qdat);
X  else
X    w0 = dmap(z0,w,beta,z,c,qdat);
X    if length(z0)==1 & lenwp > 1
X      z0 = z0(:,ones(lenwp,1)).';
X      w0 = w0(:,ones(lenwp,1)).';
X    end
X  end
X
X  % Use relaxed ODE tol if improving with Newton.
X  odetol = max(tol,1e-3*(newton));
X
X  % Set up data for the ode function.
X  global SCIMDATA	
X  SCIMDATA = (wp - w0)/c; 		% adjusts "time" interval
X  SCIMDATA(1:n,2:3) = [z, beta];
X  SCIMDATA(1,4) = n;
X
X  z0 = [real(z0);imag(z0)];
X  [t,y] = ode45('dimapf1',0,1,z0,odetol);
X  [m,leny] = size(y);
X  zp(:) = y(m,1:lenwp)+sqrt(-1)*y(m,lenwp+1:leny);
X  abszp = abs(zp);
X  out = abszp > 1;
X  zp(out) = zp(out)./abszp(out);
Xend
X
X% Newton iterations
Xif newton
X  if ~ode
X    zn = z0(:);
X    if length(z0)==1 & lenwp > 1
X      zn = zn(:,ones(lenwp,1));
X    end
X  else
X    zn = zp(:);
X  end
X    
X  wp = wp(:);
X  done = zeros(size(zn));
X  k = 0;
X  while ~all(done) & k < maxiter
X    F = wp(~done) - dmap(zn(~done),w,beta,z,c,qdat);
X    m = length(F);
X    dF = c*exp(sum(beta(:,ones(m,1)).*...
X          log(1-(zn(~done,ones(n,1)).')./z(:,ones(m,1)))));
X    zn(~done) = zn(~done) + F(:)./dF(:);
X    done(~done) = (abs(F)< tol);
X    k = k+1;
X  end
X  if any(abs(F)> tol)
X    disp('Warning in dinvmap: Solution may be inaccurate')
X    fprintf('Maximum residual = %.3g\n',max(abs(F)))
X  end
X  zp(:) = zn; 
Xend;
X
X
X
X
END_OF_FILE
if test 3252 -ne `wc -c <'dinvmap.m'`; then
    echo shar: \"'dinvmap.m'\" unpacked with wrong size!
fi
chmod +x 'dinvmap.m'
# end of 'dinvmap.m'
fi
if test -f 'disk2hp.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'disk2hp.m'\"
else
echo shar: Extracting \"'disk2hp.m'\" \(764 characters\)
sed "s/^X//" >'disk2hp.m' <<'END_OF_FILE'
Xfunction [x,a] = disk2hp(w,beta,z,c)
X%DISK2HP Convert solution from the disk to one from the half-plane.
X%       [X,C] = DISK2HP(W,BETA,Z,C) quickly transforms the solution Z,C
X%       of the Schwarz-Christoffel disk mapping parameter problem to the
X%       solution X,C of the half-plane problem.
X%	
X%	See also HP2DISK, DPARAM, HPPARAM.
X%       
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
Xx = zeros(size(z));
Xx(n) = Inf;
Xx(1:n-1) = -i*(z(1:n-1)+1)./(z(1:n-1)-1); % Mobius transfmn
Xx = real(x);				  % enforce exactly imag(x)==0
X
X% Recalculate constant from scratch.
Xmid = mean(x(1:2));
Xqdat = scqdata(beta(1:n-1),10);
Xa = (w(1)-w(2))/(hpquad(x(2),mid,2,x(1:n-1),beta(1:n-1),qdat) - ...
X    hpquad(x(1),mid,1,x(1:n-1),beta(1:n-1),qdat));
X
X
END_OF_FILE
if test 764 -ne `wc -c <'disk2hp.m'`; then
    echo shar: \"'disk2hp.m'\" unpacked with wrong size!
fi
chmod +x 'disk2hp.m'
# end of 'disk2hp.m'
fi
if test -f 'dmap.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dmap.m'\"
else
echo shar: Extracting \"'dmap.m'\" \(2284 characters\)
sed "s/^X//" >'dmap.m' <<'END_OF_FILE'
Xfunction wp = dmap(zp,w,beta,z,c,qdat)
X%DMAP  Schwarz-Christoffel disk map.
X%       DMAP(ZP,W,BETA,Z,C,QDAT) computes the values of the Schwarz-
X%       Christoffel disk map at the points in vector ZP.  The arguments 
X%       W, BETA, Z, C, and QDAT are as in DPARAM.  DMAP returns a vector
X%       the same size as ZP.
X%
X%       DMAP(ZP,W,BETA,Z,C,TOL) uses quadrature data intended to give an
X%       answer accurate to within roughly TOL.
X%	
X%	DMAP(ZP,W,BETA,Z,C) uses a tolerance of 1e-8.
X%
X%	See also DPARAM, DPLOT, DINVMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/31/95.
X
Xn = length(z);
Xw = w(:);
Xbeta = beta(:);
Xz = z(:);
Xif nargin < 6
X  qdat = scqdata(beta,8);
Xelseif length(qdat)==1
X  qdat = scqdata(beta,max(ceil(-log10(qdat)),8));
Xend
Xwp = zeros(size(zp));
Xzp = zp(:);
Xp = length(zp);
X
X% For each point in zp, find nearest prevertex.
X[tmp,sing] = min(abs(zp(:,ones(n,1)).'-z(:,ones(1,p))));
Xsing = sing(:);				% indices of prevertices
Xatinf = find(isinf(w)); 		% infinite vertices 
Xatinf = atinf(:);
Xninf = length(atinf);			% # of inf vertices
Xif ninf > 0
X  % "Bad" points are closest to a prevertex of infinity.
X  bad = sing(:,ones(ninf,1))' == atinf(:,ones(1,p));
X  % Can be closest to any pre-infinity.
X  if ninf > 1
X    bad = any(bad);
X  end
X  % Exclude cases which are exactly those prevertices.
X  bad = bad(:) & (abs(zp-z(sing)) > 10*eps);
X  % Can't integrate starting at pre-infinity: find conformal center to use
X  % as integration basis.
X  if ~isinf(w(n-1))
X    wc = w(n-1) + c*dquad(z(n-1),0,n-1,z,beta,qdat);
X  else
X    wc = w(n) + c*dquad(z(n),0,n,z,beta,qdat);
X  end
Xelse
X  bad = zeros(p,1);		% all clear
X  wc = [];				% don't need it
Xend
X
X% zs = the starting singularities
X% A MATLAB technicality could cause a mistake if sing is all ones and same
X% length as z, hence a workaround.
Xzs = wp(:);
Xzs(1:p+1) = z([sing;2]);
Xzs = zs(1:p);
X% ws = SCmap(zs)
Xws = wp(:);
Xws(1:p+1) = w([sing;2]);
Xws = ws(1:p);
X
X% Compute the map directly at "normal" points.
Xwp(~bad) = ws(~bad) + c*dquad(zs(~bad),zp(~bad),sing(~bad),z,beta,qdat);
X% Compute map at "bad" points, using conformal center as basis, to avoid
X% integration where right endpoint is too close to a singularity.
Xwp(bad) = wc - c*dquad(zp(bad),zeros(sum(bad),1),zeros(sum(bad),1),...
X    z,beta,qdat);
X
X
END_OF_FILE
if test 2284 -ne `wc -c <'dmap.m'`; then
    echo shar: \"'dmap.m'\" unpacked with wrong size!
fi
chmod +x 'dmap.m'
# end of 'dmap.m'
fi
if test -f 'dparam.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dparam.m'\"
else
echo shar: Extracting \"'dparam.m'\" \(3278 characters\)
sed "s/^X//" >'dparam.m' <<'END_OF_FILE'
Xfunction [z,c,qdat] = dparam(w,beta,z0,options);
X%DPARAM Schwarz-Christoffel disk parameter problem.
X%	[Z,C,QDAT] = DPARAM(W,BETA) solves the Schwarz-Christoffel
X%	mapping parameter problem with the disk as fundamental domain
X%	and the polygon specified by W as the target.  W must be a
X%	vector of the vertices of the polygon, specified in
X%	counterclockwise order, and BETA should be a vector of the
X%	turning angles of the polygon; see SCANGLE for details.  If
X%	successful, DPARAM will return Z, a vector of the pre-images of
X%	W; C, the multiplicative constant of the conformal map; and
X%	QDAT, a matrix of quadrature data used by some of the other
X%	S-C routines.
X%
X%       [Z,C,QDAT] = DPARAM(W,BETA,Z0) uses Z0 as an initial guess for
X%       Z.
X%
X%       [Z,C,QDAT] = DPARAM(W,BETA,Z0,OPTIONS) uses a vector of control
X%       parameters.  See SCPARMOPT.
X%	
X%	See also SCPARMOPT, DRAWPOLY, DDISP, DPLOT, DMAP, DINVMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/26/95.
X
Xn = length(w);				% no. of vertices
Xw = w(:);
Xbeta = beta(:);
X
X% Set up defaults for missing args
Xif nargin < 4
X  options = [];
X  if nargin < 3
X    z0 = [];
X  end
Xend
X
Xerr = sccheck('d',w,beta);
Xif err==1
X  fprintf('Use SCFIX to make polygon obey requirements\n')
X  error(' ')
Xend
X
X[trace,tol] = scparmopt(options);
Xnqpts = max(ceil(-log10(tol)),4);
Xqdat = scqdata(beta,nqpts); 		% quadrature data
X
Xatinf = (beta <= -1);
X
Xif n==3
X  % Trivial solution
X  z = [-i;(1-i)/sqrt(2);1];
X
Xelse
X
X  % Set up normalized lengths for nonlinear equations:
X
X  % indices of left and right integration endpoints
X  left = 1:n-2;				
X  right = 2:n-1;				
X  % delete indices corresponding to vertices at Inf
X  left(find(atinf)) = [];
X  right(find(atinf) - 1) = [];
X  cmplx = ((right-left) == 2);
X  % normalize lengths by w(2)-w(1)
X  nmlen = (w(right)-w(left))/(w(2)-w(1));
X  % abs value for finite ones; Re/Im for infinite ones
X  nmlen = [abs(nmlen(~cmplx));real(nmlen(cmplx));imag(nmlen(cmplx))];
X  % first entry is useless (=1)
X  nmlen(1) = [];
X  
X  % Set up initial guess
X  if isempty(z0)
X    y0 = zeros(n-3,1);
X  else
X    z0 = z0(:)./abs(z0(:));
X    % Moebius to make th(n-2:n)=[1,1.5,2]*pi;
X    Am = moebius(z0(n-2:n),[-1;-i;1]);
X    z0 = (Am(1)*z0+Am(2))./(Am(3)*z0+Am(4));
X    th = angle(z0);
X    th(th<=0) = th(th<=0) + 2*pi;
X    dt = diff([0;th(1:n-2)]);
X    y0 = log(dt(1:n-3)./dt(2:n-2));
X  end
X  
X  % Solve nonlinear system of equations:
X  
X  % package data
X  nrow = max([n,nqpts,4]);
X  ncol = 6+2*(n+1);
X  fdat = zeros(nrow,ncol);
X  fdat(1:4,1) = [n;length(left);nqpts;ncol];
X  fdat(1:n,2) = beta;
X  fdat(1:n-3,3) = nmlen(:);
X  fdat(1:fdat(2,1),4:6) = [left(:),right(:),cmplx(:)];
X  fdat(1:nqpts,7:ncol) = qdat;
X  % set options
X  opt = zeros(16,1);
X  opt(1) = 2*trace;
X  opt(6) = 100*(n-3);
X  opt(8) = tol;
X  opt(9) = tol/10;
X  opt(12) = nqpts;
X  [y,termcode] = nesolve('dpfun',y0,opt,fdat);
X  if termcode~=1
X    disp('Warning: Nonlinear equations solver did not terminate normally')
X  end
X
X  % Convert y values to z
X  cs = cumsum(cumprod([1;exp(-y)]));
X  theta = pi*cs(1:n-3)/cs(n-2);
X  z = ones(n,1);
X  z([1:n-3]) = exp(i*theta);
X  z(n-2:n-1) = [-1;-i];
Xend
X
X% Determine scaling constant
Xmid = (z(1)+z(2))/2;
Xc = (w(1) - w(2))/...
X    (dquad(z(2),mid,2,z,beta,qdat) - dquad(z(1),mid,1,z,beta,qdat));
X
X
END_OF_FILE
if test 3278 -ne `wc -c <'dparam.m'`; then
    echo shar: \"'dparam.m'\" unpacked with wrong size!
fi
chmod +x 'dparam.m'
# end of 'dparam.m'
fi
if test -f 'dpfun.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dpfun.m'\"
else
echo shar: Extracting \"'dpfun.m'\" \(1424 characters\)
sed "s/^X//" >'dpfun.m' <<'END_OF_FILE'
Xfunction F = dpfun(y,fdat)
X%DPFUN  (not intended for calling directly by the user)
X%       Returns residual for solution of nonlinear equations.
X%       Used by DPARAM.
X%
X% Written by Toby Driscoll.  Last updated 5/26/95.
X
Xn = fdat(1,1);
Xbeta = fdat(1:n,2);
Xnmlen = fdat(1:n-3,3);
Xrows = 1:fdat(2,1);
Xleft = fdat(rows,4);
Xright = fdat(rows,5);
Xcmplx = fdat(rows,6);
Xqdat = fdat(1:fdat(3,1),7:fdat(4,1));
X
X% Convert y values to z (prevertices)
Xcs = cumsum(cumprod([1;exp(-y)]));
Xtheta = pi*cs(1:n-3)/cs(length(cs));
Xz = ones(n,1);
Xz(1:n-3) = exp(i*theta);
Xz(n-2:n-1) = [-1;-i];
X
X% Check crowding.
Xif any(diff(theta)<eps) | any(isnan(theta))
X  % Since abs(y) is large, use it as the penalty function.
X  F = y;
X  disp('Warning: Severe crowding')
X  return
Xend
X
X% Compute the integrals appearing in nonlinear eqns.
Xzleft = z(left);
Xzright = z(right);
Xmid = mean([zleft.' ; zright.']).';
X% For integrals between nonadjacent singularities, choose 0 as intermediate
X% integration point.
Xmid(cmplx) = zeros(size(mid(cmplx)));
Xints = ( dquad(zleft,mid,left,z,beta,qdat) - ...
X    dquad(zright,mid,right,z,beta,qdat) );
X
Xif any(ints==0)
X  % Singularities were too crowded in practice.
X  F = y;
X  disp('Warning: Severe crowding')
Xelse
X  % Compute nonlinear equation residual values.
X  F1 = abs(ints(~cmplx)); 		% F1(1) = abs(ints(1))
X  F1 = F1(2:length(F1))/F1(1);
X  F2 = ints(cmplx)/ints(1);
X  F = [F1;real(F2);imag(F2)] - nmlen;
Xend
X
END_OF_FILE
if test 1424 -ne `wc -c <'dpfun.m'`; then
    echo shar: \"'dpfun.m'\" unpacked with wrong size!
fi
chmod +x 'dpfun.m'
# end of 'dpfun.m'
fi
if test -f 'dplot.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dplot.m'\"
else
echo shar: Extracting \"'dplot.m'\" \(3520 characters\)
sed "s/^X//" >'dplot.m' <<'END_OF_FILE'
Xfunction [H,R2,THETA] = dplot(w,beta,z,c,R,theta,options)
X%DPLOT  Image of polar grid under Schwarz-Christoffel disk map.
X%       DPLOT(W,BETA,Z,C) will adaptively plot the images under the
X%       Schwarz-Christoffel disk map of ten evenly spaced circles and
X%       rays in the unit disk.  The arguments are as in DPARAM.
X%
X%       DPLOT(W,BETA,Z,C,M,N) will plot images of M evenly spaced
X%       circles and N evenly spaced rays.
X%
X%       DPLOT(W,BETA,Z,C,R,THETA) will plot images of circles whose
X%       radii are given in R and rays whose arguments are given in
X%       THETA.  Either argument may be empty.
X%
X%       DPLOT(W,BETA,Z,C,R,THETA,OPTIONS) allows customization of
X%       DPLOT's behavior.  See SCPLOTOPT.
X%
X%       H = DPLOT(W,BETA,Z,C,...) returns a vector of handles to all the
X%       curves drawn in the interior of the polygon.  [H,R,THETA] =
X%       DPLOT(W,BETA,Z,C,...) also returns the moduli and arguments of
X%       the curves comprising the grid.
X%	
X%	See also SCPLOTOPT, DPARAM, DMAP, DDISP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xw = w(:);
Xbeta = beta(:);
Xz = z(:);
Xturn_off_hold = ~ishold;
Xif nargin < 7
X  options = [];
X  if nargin < 6
X    theta = [];
X    if nargin < 5 
X      R = [];
X    end
X  end
Xend
X
Xif isempty([R(:);theta(:)])
X  R = 10;
X  theta = 10;
Xend
X
Xif (length(R)==1) & (R == round(R))
X  m = R+2;
X  R = linspace(0,1,m);
X  R([1,m]) = [];
Xend
Xif (length(theta)==1) & (theta == round(theta))
X  m = theta+1;
X  theta = linspace(0,2*pi,m);
X  theta(m) = [];
Xend
X
X[nqpts,maxturn,maxlen,maxrefn] = scplotopt(options);
X
Xfig = gcf;
Xfigure(fig);
Xplotpoly(w,beta);
Xdrawnow
Xhold on
X
Xn = length(w);
Xwf = w(~isinf(w));
Xreflen = maxlen*max(abs(diff([wf;wf(1)])));
X
Xqdat = scqdata(beta,nqpts);
XRp0 = linspace(0,1,15)';
X  
Xfor j = 1:length(R)
X  tp = linspace(0,2*pi,16)';
X  tp = [tp(length(tp)-1)-2*pi;tp];
X  zp = R(j)*exp(i*tp);
X  wp = dmap(zp,w,beta,z,c,qdat);
X  bad = find(toobig(wp,maxturn,reflen,axis));
X  iter = 0;
X  while (~isempty(bad)) & (iter < maxrefn)
X    lenwp = length(wp);
X    newt = [(tp(bad-1)+2*tp(bad))/3;(tp(bad+1)+2*tp(bad))/3];
X    newz = R(j)*exp(i*newt);
X    neww = dmap(newz,w,beta,z,c,qdat);
X    [k,in] = sort([tp;newt]);
X    tp = [tp;newt];  wp = [wp;neww];
X    tp = tp(in);     wp = wp(in);
X    iter = iter + 1;
X    bad = find(toobig(wp,maxturn,reflen,axis));
X  end
X  tp(tp<0) = tp(tp<0) + 2*pi;
X  [k,in] = sort(tp);
X  linh(j) = plot(clipdata(wp(in),axis), 'g-','erasemode','none');
X  set(linh(j),'erasemode','normal');
X  drawnow
X  Z(1:length(zp),j) = zp;
X  W(1:length(wp),j) = wp;
Xend
X
Xfor j = 1:length(theta)
X  Rp = Rp0;
X  zp = Rp*exp(i*theta(j));
X  wp = dmap(zp,w,beta,z,c,qdat);
X  bad = find(toobig(wp,maxturn,reflen,axis));
X  iter = 0;
X  while (~isempty(bad)) & (iter < maxrefn)
X    lenwp = length(wp);
X    newR = [(Rp(bad-1)+2*Rp(bad))/3;(Rp(bad+1)+2*Rp(bad))/3];
X    newz = newR*exp(i*theta(j));
X    neww = dmap(newz,w,beta,z,c,qdat);
X    [k,in] = sort([Rp;newR]);
X    Rp = [Rp;newR];  wp = [wp;neww];
X    Rp = Rp(in);     wp = wp(in);
X    iter = iter + 1;
X    bad = find(toobig(wp,maxturn,reflen,axis));
X  end
X  linh(j+length(R)) = plot(clipdata(wp,axis), 'g-','erasemode','none');
X  drawnow
X  set(linh(j+length(R)),'erasemode','normal');
X  Z(1:length(zp),j+length(R)) = zp;
X  W(1:length(wp),j+length(R)) = wp;
Xend
X
X% Force redraw to get clipping enforced.
Xset(fig,'color',get(fig,'color'))
Xif turn_off_hold, hold off, end;
Xif nargout > 0
X  H = linh;
X  if nargout > 1
X    R2 = R;
X    if nargout > 2
X      THETA = theta;
X    end
X  end
Xend 
X
END_OF_FILE
if test 3520 -ne `wc -c <'dplot.m'`; then
    echo shar: \"'dplot.m'\" unpacked with wrong size!
fi
chmod +x 'dplot.m'
# end of 'dplot.m'
fi
if test -f 'dquad.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dquad.m'\"
else
echo shar: Extracting \"'dquad.m'\" \(2276 characters\)
sed "s/^X//" >'dquad.m' <<'END_OF_FILE'
Xfunction I = dquad(z1,z2,sing1,z,beta,qdat)
X%DQUAD  (not intended for calling directly by the user)
X%	Numerical quadrature for the disk map.
X
X%	z1,z2 are vectors of left and right endpoints.  sing1 is a vector
X%	of integer indices which label the singularities in z1.  So if
X%	sing1(5) = 3, then z1(5) = z(3).  A zero means no singularity. 
X%	z is the vector of singularities;  beta is the vector of
X%	associated turning angles.  qdat is quadrature data from SCQDATA.
X%
X%	Make sure that z and beta are column vectors.
X%	
X%	DQUAD integrates from a possible singularity at the left end to a
X%	regular point at the right.  If both endpoints are singularities,
X%	you must break the integral into two pieces and make two calls.
X%	
X%	The integral is subdivided, if necessary, so that no
X%	singularity lies closer to the left endpoint than 1/2 the
X%	length of the integration (sub)interval.
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
Xnqpts = size(qdat,1);
Xn = length(z);
Xbigz = z(:,ones(1,nqpts));
Xbigbeta = beta(:,ones(1,nqpts));
Xif isempty(sing1)
X  sing1 = zeros(length(z1),1);
Xend
X
XI = zeros(size(z1));
Xnontriv = find(z1(:)~=z2(:))';
X
Xfor k = nontriv
X  za = z1(k);
X  zb = z2(k);
X  sng = sing1(k);
X
X  % Allowable integration step, based on nearest singularity.
X  dist = min(1,2*min(abs(z([1:sng-1,sng+1:n])-za))/abs(zb-za));
X  zr = za + dist*(zb-za);
X  % Adjust Gauss-Jacobi nodes and weights to interval.
X  ind = rem(sng+n,n+1)+1;
X  nd = ((zr-za)*qdat(:,ind) + zr + za)/2; % G-J nodes
X  wt = ((zr-za)/2) * qdat(:,ind+n+1);	% G-J weights
X  terms = 1 - (nd(:,ones(n,1)).')./bigz;
X  if any(~diff(nd)) | any(any(~terms))
X    % Endpoints are practically coincident.
X    I(k) = 0;
X  else
X    % Use Gauss-Jacobi on first subinterval, if necessary.
X    if sng > 0
X      terms(sng,:) = terms(sng,:)./abs(terms(sng,:));
X      wt = wt*(abs(zr-za)/2)^beta(sng);
X    end
X    I(k) = exp(sum(log(terms).*bigbeta))*wt;
X    while dist < 1              
X      % Do regular Gaussian quad on other subintervals.
X      zl = zr;
X      dist = min(1,2*min(abs(z-zl))/abs(zl-zb));
X      zr = zl + dist*(zb-zl);
X      nd = ((zr-zl)*qdat(:,n+1) + zr + zl)/2;
X      wt = ((zr-zl)/2) * qdat(:,2*n+2);
X      I(k) = I(k) + exp(sum(log(1 - nd(:,ones(n,1)).'./bigz).*bigbeta)) * wt;
X    end
X  end
Xend
X
END_OF_FILE
if test 2276 -ne `wc -c <'dquad.m'`; then
    echo shar: \"'dquad.m'\" unpacked with wrong size!
fi
chmod +x 'dquad.m'
# end of 'dquad.m'
fi
if test -f 'drawcb.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'drawcb.m'\"
else
echo shar: Extracting \"'drawcb.m'\" \(6598 characters\)
sed "s/^X//" >'drawcb.m' <<'END_OF_FILE'
Xfunction [x,y] = drawcb(event,cmd)
X%DRAWCB (not intended for calling directly by the user)
X%       Callback for DRAWPOLY.
X%
X%	Written by Toby Driscoll.  Last updated 5/31/95.
X
Xglobal DRP_LINE DRP_PT DRP_AUX
X
X% DRP_LINE: The preview line.  Also, its Userdata stores the points
X% selected thus far.
X
X% DRP_PT: Selected point.  The ButtonUpFcn sets this according to what it
X% sees in the Userdata of DRP_LINE.  
X
X% DRP_AUX: Parameters.
X%   1: Drawing mode.  
X%     0=normal, 1=2nd point of Inf vertex, 2=after an Inf vertex
X%   2,3: Grid spacing.  If both zero, no grid; else x,y spacings.
X%   4: Angle quantization.  If zero, inactive; else fundamental angle.
X%   5: Length quantization.  If zero, inactive; else fundamental length.
X
Xif strcmp(event,'getpoint')		% get a point from user
X  DRP_PT = [];
X  set(cmd,'windowbuttonmotionfcn','drawcb(''move'');');
X  drawnow
X  while isempty(DRP_PT) 		% wait for point selection
X    drawnow				
X  end;
X  x = DRP_PT(1);
X  y = DRP_PT(2);
X
Xelseif strcmp(event,'move')		% mouse motion
X  ptrpos = get(gca,'currentpoint');
X  P = ptrpos(1,1:2);
X  axlim = axis;
X  pts = get(DRP_LINE, 'userdata');
X  [m,junk] = size(pts);
X  mode = DRP_AUX(1);
X  grid = DRP_AUX(2:3)';
X  qang = DRP_AUX(4);
X  qlen = DRP_AUX(5);
X
X  % Modify point to meet mode constraints.
X  if mode==0 				% normal mode
X    % No constraints.
X  elseif mode==1 			% infinite mode
X    % Point may not be inside axes box.
X    if all(P>axlim([1,3])) & all(P<axlim([2,4]))
X      [junk,j] = min(abs([P(1)-axlim(1:2);P(2)-axlim(3:4)]'));
X      P = axlim(j);
X    end
X  elseif mode==2 			% post-infinite mode
X    % Point may not be outside axes box.
X    P(1) = min(max(P(1),axlim(1)),axlim(2));
X    P(2) = min(max(P(2),axlim(3)),axlim(4));
X    % Angle from infinity may not be acute.
X    ang = scangle([pts(m-3:m-1,1);P(1)]+i*[pts(m-3:m-1,2);P(2)]);
X    ang = ang(2:3);
X    ang(ang>0) = ang(ang>0) - 2;
X    ang = sum(ang);
X    if ang > -1
X      % Would be illegal.  Project to make ang=-1.
X      A = pts(m-1,:);
X      B = pts(m-3,:) + A - pts(m-2,:);
X      P = A + ((B-A)*(P-A)')/((B-A)*(B-A)')*(B-A);
X      ang = -1;
X      qang = 0;				% override other restrictions
X      grid = 0;
X    elseif ang < -3
X      % It's illegal.  Is it even possible?
X      P = [NaN,NaN];
X      ang = NaN;
X    end
X  end
X
X  % Modify point to meet angle, length, or grid constraints.
X
X  if any(mode==[0,2]) & qang & (m > 2)	% quantized angle
X    % Find arg of new side which meets quantization requirements. 
X    if mode==0
X      ang = scangle([pts(m-2:m-1,1);P(1)]+i*[pts(m-2:m-1,2);P(2)]);
X      ang = qang*round(ang(2)/qang);
X      theta = atan2(pts(m-1,2)-pts(m-2,2),pts(m-1,1)-pts(m-2,1))-pi*ang;
X    elseif mode==2
X      % ang was computed above
X      ang = qang*round(ang/qang);
X      theta = atan2(pts(m-2,2)-pts(m-3,2),pts(m-2,1)-pts(m-3,1))-pi*ang;
X    end
X    % Project P to correct angle.
X    A = pts(m-1,:);
X    BA = [cos(theta),sin(theta)];
X    P = A + ((BA)*(P-A)')*(BA);
X    grid = 0;
X  end
X  if (mode==0) & qlen & (m > 1)		% quantized length
X    A = pts(m-1,:);
X    len = norm(P-A);
X    fixlen = qlen*(round(len/qlen));
X    P = A + fixlen/len*(P-A);
X    grid = 0;
X  end
X  if any(mode==[0,1,2]) & all(grid)	% snap to grid
X    minxy = axlim([1,3]);
X    P = minxy + grid.*(round((P-minxy)./grid));
X  end
X  
X  % Update.
X  if m > 1
X    if ~(mode==1)			% preview line
X      set(DRP_LINE, 'xdata',[pts(m-1,1),P(1)], 'ydata',[pts(m-1,2),P(2)]);
X    end
X    set(DRP_LINE, 'userdata',[pts(1:m-1,:);P]);
X  else
X    set(DRP_LINE, 'userdata',P);
X  end
X  drawnow
X
Xelseif strcmp(event,'up')		% mouse up
X  pts = get(DRP_LINE, 'userdata');
X  m = size(pts,1);
X  if ~isnan(pts(m,1))			% valid point
X    set(gcf,'windowbuttonmotionfcn','');
X    set(DRP_LINE,'xdata',[pts(m,1),NaN], 'ydata',[pts(m,2),NaN])
X    set(DRP_LINE,'userdata',[pts;[NaN,NaN]])
X    DRP_PT = pts(m,:);
X  end
X  
Xelseif strcmp(event,'control')		% ui control
X  axlim = axis;
X  data = get(DRP_LINE,'userdata');
X  control = get(gca,'userdata');
X  mode = DRP_AUX(1);
X  if strcmp(cmd,'g')			% grid feature
X    if get(control(2),'value') 		% grid on
X      % Turn off quantizations, if now on.
X      if get(control(3),'value')
X	set(control(3),'value',0)
X	drawcb('control','a');
X      end
X      if get(control(4),'value')
X	set(control(4),'value',0)
X	drawcb('control','l');
X      end
X      % Get number of grid points.
X      N = round(get(control(5),'value'));
X      % Set up allowable x,y values.
X      x = linspace(axlim(1),axlim(2),N+1);
X      y = linspace(axlim(3),axlim(4),N+1);
X      set(gca,'xticklabelmode','auto')
X      set(gca,'yticklabelmode','auto')
X      set(gca,'xtick',x,'ytick',y)
X      % For clarity, keep only about eight of the labels.
X      keep = [1,3:ceil(N/8):N-1,N+1];
X      xl = get(gca,'xticklabels');
X      p = min(size(xl,2),4);
X      xlnew = setstr(ones(N+1,1)*blanks(p));
X      xlnew(keep,:) = xl(keep,1:p);
X      yl = get(gca,'yticklabels');
X      p = min(size(yl,2),4);
X      ylnew = setstr(ones(N+1,1)*blanks(p));
X      ylnew(keep,:) = yl(keep,1:p);
X      % Make it so.
X      set(gca,'xticklabels',xlnew,'xgrid','on',...
X	  'yticklabels',ylnew,'ygrid','on')
X      drawnow
X      DRP_AUX(2:3) = [x(2)-x(1),y(2)-y(1)];
X    else 				% grid off
X      set(gca,'xtickmode','auto','xticklabelmode','auto','xgrid','off')
X      set(gca,'ytickmode','auto','yticklabelmode','auto','ygrid','off')
X      drawnow
X      DRP_AUX(2:3) = [0,0];
X    end
X  elseif strcmp(cmd,'a')		% quantize angle
X    DRP_AUX(4) = get(control(3),'value')/round(get(control(6),'value'));
X    % Turn off grid, if now on.
X    if get(control(2),'value') & get(control(3),'value')
X      set(control(2),'value',0)
X      drawcb('control','g');
X    end
X  elseif strcmp(cmd,'l') 		% quantize length
X    pct = 1/round(get(control(7),'value'));
X    DRP_AUX(5) = get(control(4),'value')*pct*(axlim(2)-axlim(1));
X    % Turn off grid, if now on.
X    if get(control(2),'value') & get(control(4),'value')
X      set(control(2),'value',0)
X      drawcb('control','g');
X    end
X  elseif strcmp(cmd,'sg')
X    set(control(8),'string',sprintf('1/%i',round(get(control(5),'value'))));
X    drawcb('control','g');
X  elseif strcmp(cmd,'sa')
X    set(control(9),'string',sprintf('pi/%i',round(get(control(6),'value'))));
X    drawcb('control','a');
X  elseif strcmp(cmd,'sl')
X    set(control(10),'string',sprintf('1/%i',round(get(control(7),'value'))));
X    drawcb('control','l');
X  end
X  % Call move so new restrictions take effect immediately.
X  if ~strcmp(cmd(1),'s')
X    drawcb('move');
X  end
X
Xelseif strcmp(event,'key')		% key pressed
X  cmd = lower(get(gcf,'currentchar'));
X  drawcb('control',cmd);
X
Xend
X
X
X
END_OF_FILE
if test 6598 -ne `wc -c <'drawcb.m'`; then
    echo shar: \"'drawcb.m'\" unpacked with wrong size!
fi
chmod +x 'drawcb.m'
# end of 'drawcb.m'
fi
if test -f 'drawpoly.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'drawpoly.m'\"
else
echo shar: Extracting \"'drawpoly.m'\" \(6301 characters\)
sed "s/^X//" >'drawpoly.m' <<'END_OF_FILE'
Xfunction [w,beta,handles] = drawpoly(fig,axlim)
X%DRAWPOLY Draw a polygon with the mouse.
X%       [W,BETA] = DRAWPOLY allows the user to draw a polygon with the
X%       mouse.  Use the mouse to position the crosshair and press the
X%       left mouse button to create a vertex.  For use with other S-C
X%       Toolbox functions, the vertices must be specified in a
X%       "positively oriented" manner; i.e.  counterclockwise for
X%       interior polygons and clockwise for exterior regions.  There are
X%       several GUI elements added to the figure to help you snap
X%       vertices to a grid, get specfic angles, etc.  For the last
X%       vertex, use the middle or right mouse button, or double click.
X%       Upon return, W is a vector of complex vertices and BETA is a
X%       vector of turning angles.
X%
X%       [W,BETA] = DRAWPOLY(FIG) draws in figure FIG.  [W,BETA] =
X%       DRAWPOLY(FIG,AXLIM) also uses AXLIM for the axes limits.
X%
X%       [W,BETA,H] = DRAWPOLY also returns a vector of handles to the
X%       plotted edges.
X%
X%	See the user's guide for full details.
X%	
X%	See also PLOTPOLY, MODPOLY, SCGUI.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xif nargin < 2
X  axlim = [-4,4,-4,4];
X  if nargin < 1
X    fig = gcf;
X  end
Xend
X
Xfigure(fig);
X
X% See DRAWCB for documentation of globals.
Xglobal DRP_LINE DRP_PT DRP_AUX
X
X% Set up figure, axes, etc.
Xif ~ishold, cla, end
Xview(2)
Xoldbuf = get(fig,'windowbuttonupfcn');
Xoldbdf = get(fig,'windowbuttondownfcn');
Xset(gca,'xlim',axlim(1:2),'ylim',axlim(3:4),'aspect',[1,NaN],'box','on')
Xhold on
Xptr = get(fig, 'pointer');
Xset(fig, 'pointer','crosshair');
XDRP_LINE = line(NaN,NaN,'linestyle','--','erasemode','xor',...
X    'clipping','off');
X
X% Set up check boxes.
Xoldun = get(fig,'units');
Xset(fig,'units','centi');
Xfigpos = get(fig,'position');
Xset(gca,'units','centi')
Xaxpos = get(gca,'pos');
Xset(gca,'pos',[axpos(1),axpos(2)+1.8,axpos(3:4)])
Xset(fig,'pos',[figpos(1),figpos(2)-1.8,figpos(3),figpos(4)+1.8])
Xcontrol(1) = uicontrol('style','frame','units','centi',...
X    'pos',[0,0,figpos(3),1.8]);
Xset(control(1),'units','norm')
Xoffset = max(0,(figpos(3)-11.6)/2);
Xcontrol(2) = uicontrol('style','check','string','Snap to grid ',...
X    'units','centi','pos',[offset .8 3.7 .8]);
Xset(control(2),'units','norm','call','drawcb(''control'',''g'');')
Xcontrol(3) = uicontrol('style','check','string','Quantize angle',...
X    'units','centi','pos',[offset+3.95 .8 3.7 .8]);
Xset(control(3),'units','norm','call','drawcb(''control'',''a'');')
Xcontrol(4) = uicontrol('style','check','string','Quantize length',...
X    'units','centi','pos',[offset+7.9 .8 3.7 .8]);
Xset(control(4),'units','norm','call','drawcb(''control'',''l'');')
X% Create sliders.
Xcontrol(5) = uicontrol('style','slider','min',4,'max',32,...
X    'value',16,'units','cent','pos',[offset+.45 .2 1.75 .4]);
Xset(control(5),'units','norm','call','drawcb(''control'',''sg'');')
Xcontrol(6) = uicontrol('style','slider','min',2,'max',24,...
X    'value',12,'units','cent','pos',[offset+4.4 .2 1.75 .4]);
Xset(control(6),'units','norm','call','drawcb(''control'',''sa'');')
Xcontrol(7) = uicontrol('style','slider','min',3,'max',20,...
X    'value',8,'units','cent','pos',[offset+8.35 .2 1.75 .4]);
Xset(control(7),'units','norm','call','drawcb(''control'',''sl'');')
X% Text to accompany sliders.
Xcontrol(8) = uicontrol('style','text','string','1/16',...
X    'units','cent','pos',[offset+2.5 .2 1 .4]);
Xset(control(8),'units','norm')
Xcontrol(9) = uicontrol('style','text','string','pi/12',...
X    'units','cent','pos',[offset+6.3 .2 1 .4]);
Xset(control(9),'units','norm')
Xcontrol(10) = uicontrol('style','text','string','1/8',...
X    'units','cent','pos',[offset+10.15 .2 1 .4]);
Xset(control(10),'units','norm')
Xset(gca,'userdata',control)
Xdrawnow
X
X% Preparation.
XDRP_AUX = zeros(5,1);
Xset(DRP_LINE, 'userdata',[NaN,NaN]);
Xif ~strcmp(computer,'SUN4')
X  % Kludge.  Draw preview line when button is pressed.
X  set(fig,'windowbuttondownfcn','drawcb(''move'');');
Xend
Xset(fig,'windowbuttonupfcn', 'drawcb(''up'');');
X%%set(fig,'keypressfcn','drawcb(''key'');');
Xdrawnow
X
X% Get first vertex.
X[x,y] = drawcb('getpoint',fig);
Xw = x+i*y;
Xvertices = plot(x,y,'.', 'markersize',12); 
Xset(DRP_LINE,'xdata',[x NaN], 'ydata',[y,NaN]);
Xdrawnow
Xbutton = 1;
Xn = 1;
X
X% Get rest of vertices.
XDRP_PT = [];				% no point selected
Xmode = 0;				% "normal" mode
Xwhile button==1				% until last was selected
X  DRP_AUX(1) = mode;
X  n = n + 1;
X  [x0,y0] = drawcb('getpoint',fig);
X  m = length(x);
X  x = [x;x0];  y = [y;y0];
X  edges(n-1) = plot(x(m:m+1),y(m:m+1),'-');
X  set(vertices, 'xdata',x, 'ydata',y);
X  drawnow
X  if x0>=axlim(1) & x0<=axlim(2) & y0>=axlim(3) & y0<=axlim(4)
X    % Finite vertex.
X    w(n) = x0+i*y0;
X    mode = 0;
X  else					% infinite vertex
X    % Get re-entry point for next edge.
X    DRP_AUX(1) = 1;			% "inf" mode
X    set(fig,'pointer','cross')
X    [x0,y0] = drawcb('getpoint',fig);
X    set(fig,'pointer','crosshair')
X    x = [x;x0];  y = [y;y0];
X    w(n) = Inf;
X    mode = 2;				% "post-inf" mode
X  end  % if vertex is infinite
X  if n > 2 				% angle at previous vertex
X    if ~isinf(w(n-1))
X      ang = scangle(x(m-1:m+1)+i*y(m-1:m+1));
X      beta(n-1) = ang(2);
X    else
X      ang = scangle(x(m-2:m+1)+i*y(m-2:m+1));
X      ang = ang(2:3);
X      ang(ang>0) = ang(ang>0) - 2;
X      beta(n-1) = sum(ang);
X    end
X  end  % if n > 2
X  % What kind of button press?
X  if strcmp(get(fig,'selectiontype'),'normal')
X    button = 1;
X  else
X    button = 2;
X  end
Xend  % while button==1
X
Xm = length(x);
Xedges(n) = plot(x([m,1]),y([m,1]),'-');
Xdrawnow
X% Angle at vertex n.
Xif ~isinf(w(n))
X  ang = scangle(x([m-1:m,1])+i*y([m-1:m,1]));
X  beta(n) = ang(2);
Xelse
X  ang = scangle(x([m-2:m,1])+i*y([m-2:m,1]));
X  ang = ang(2:3);
X  ang(ang>0) = ang(ang>0) - 2;
X  beta(n) = sum(ang);
Xend
X
X% Angle at first vertex (necessarily finite).
Xang = scangle(x([m,1:2])+i*y([m,1:2]));
Xbeta(1) = ang(2);
X
X% Prepare outputs.
Xw = w(:);
Xbeta = beta(:);
X
X% Clean up the mess.
Xset(fig, 'pointer',ptr, 'windowbuttonupfcn',oldbuf,...
X    'windowbuttondownfcn',oldbdf,...
X    'windowbuttonmotionfcn', '',...
X    'pos',figpos,'units',oldun);
Xset(gca,'pos',axpos,'units','norm')
Xfor j = 1:length(control)
X  delete(control(j))
Xend
Xdelete(DRP_LINE)
Xclear DRP_LINE DRP_PT DRP_AUX
X
Xhold off  
Xaxis auto
Xhandles = plotpoly(w,beta);
X
END_OF_FILE
if test 6301 -ne `wc -c <'drawpoly.m'`; then
    echo shar: \"'drawpoly.m'\" unpacked with wrong size!
fi
chmod +x 'drawpoly.m'
# end of 'drawpoly.m'
fi
if test -f 'elongdemo.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'elongdemo.m'\"
else
echo shar: Extracting \"'elongdemo.m'\" \(4292 characters\)
sed "s/^X//" >'elongdemo.m' <<'END_OF_FILE'
Xmore off
Xecho on
Xclc
X% This script demonstrates mapping to elongated polygons with the
X% Schwarz-Christoffel Toolbox.
X
Xpause     % Strike any key to begin (Ctrl-C to abort)
X
X
X% We begin with a demonstration of "crowding."
X
Xpause     % Strike any key to continue
X
X% Here is a moderately elongated region.
Xw = [3+2.4i; .6-.4i; -1-.4i; -3+2i; -3-2i; -1-.8i; .6-.8i; 3-2i];
Xbeta = scangle(w);
X
Xfigure(gcf)
Xhold off
Xplotpoly(w,beta)
X
Xpause     % Strike any key to continue
X
X% Solve the parameter problem for the half-plane.
X[x,c] = hpparam(w,beta);
X
Xpause     % Strike any key to display results
X
Xhpdisp(w,beta,x,c)
X
Xpause     % Strike any key to continue
X
X% Notice how close together four of the prevertices are.  
X% Although we estimate an aspect ratio of 6/.4 = 15, the 
X% prevertices differ by about 1e-7, or roughly exp(-15).
X% The exponential proximity of the prevertices is commonly
X% known as the crowding phenomenon.  The phenomenon occurs
X% for the disk as well as the half-plane (and for exterior
X% maps, when the exterior region is elongated).
X
Xpause     % Strike any key to continue
Xclc
X% If the polygon above had been much more elongated, the 
X% prevertices would have been indistinguishable in double
X% precision.  Even before this point, the solution of the
X% parameter problem can become extremely difficult.
X
X% While sometimes an elongated polygon can be subdivided 
X% and then mapped, a more elegant solution is to use a more
X% appropriate fundamental domain.  In the important case of 
X% a region which is elongated in only one direction, a natural
X% choice is a rectangle.  
X
Xpause     % Strike any key to continue
Xclc
X% Let's map the same polygon to a rectangle.  The corners of 
X% the rectangle should map to the outermost vertices of the
X% polygon. 
X
X[z,c,L]=rparam(w,beta,[1,4,5,8]);
X
Xrdisp(w,beta,z,c,L)
X
Xpause     % Strike any key to continue
X
X% The corners of the rectangle are found to be about +-pi/2
X% and +-pi/2 + 23i. The conformal modulus of the polygon,
X% which is the aspect ratio of the rectangle, is determined 
X% (as part of the solution) to be about 7.3. 
X
Xpause     % Strike any key to continue
X
X% Here's a plot of the images of 6 vertical and 12 horizontal
X% lines.
X
Xrplot(w,beta,z,c,L,6,12)
X
Xpause     % Strike any key to continue
Xclc
X% Here's another example of a rectangle map.  The solution is
X% given, just to save time. 
Xw = [-3 + 1.5i;-2 + 1.5i;1.5 + 1.5i;1.5 + 0.5i;-2 + 0.5i;-2 - 2i;
X   3 - 2i;3 - 1i;-1.5 - 1i;-1.5;2;2 + 2.5i;-3 + 2.5i];
X 
Xbeta = scangle(w);
X
Xz = [
X -0.75095889852766                    
X  1.57079632679490                    
X  1.57079632679490+13.62792581256858i
X  1.57079632679490+21.47908439726175i
X  1.57079632679490+42.08393917979348i
X  1.57079632679490+51.32236373477432i
X  1.57079632679490+65.40343136968455i
X -1.57079632679490+65.40343136968455i
X -1.57079632679490+49.93558255696847i
X -1.57079632679490+42.08442599909570i
X -1.57079632679490+21.47957121760661i
X -1.57079632679490+12.24115478564419i
X -1.57079632679490 ];
X
Xc = 1.549060450542251e+13 + 1.549060450542251e+13i;
X
XL = 20.37728759500835;
X 
X% In the plot, notice how one rectangle corner is mapped to a
X% trivial vertex---one located in the middle of a side.
X
Xpause     % Strike any key for plot
X
Xrplot(w,beta,z,c,L,6,12)
X 
Xpause     % Strike any key to continue
Xclc
X% Another choice for the fundamental domain for an elongated
X% polygon is the strip 0 <= Im z <= 1.  This is especially
X% appropriate when the target region is a polygonal channel,
X% such as you might encounter in a fluids problem.
X
Xpause     % Strike any key to continue
X
X% Here's a simple example:
X
Xw = [-2-i; -2-2i; -2i; 2-i; Inf; 2.5; Inf];
Xbeta = [.5; -.5; -atan(1/2)/pi; atan(1/2)/pi; -1.2; .2; -1];
Xplotpoly(w,beta)
X
Xpause     % Strike any key to solve the parameter problem
X
X[z,c] = stparam(w,beta,[7,5]);
X
Xpause     % Strike any key to see results
X
Xstdisp(w,beta,z,c)
X
Xstplot(w,beta,z,c)
X
Xpause     % Strike any key to continue
Xclc
X% We close with another strip map.  This time, one end of the
X% strip will map to a finite vertex.  The result is as if a
X% sink or source were placed at this vertex.
X
Xw = [3-.5i; 2+1.5i; .5+.5i; -1+.5i; Inf; -1; .5; 2-1.5i];
Xbeta = scangle(w);
Xbeta(4:6) = [.2;-1.4;.2];
X
X[z,c] = stparam(w,beta,[5,1]);
Xstplot(w,beta,z,c,12,8)
X
Xecho off 	% End of demo
X
END_OF_FILE
if test 4292 -ne `wc -c <'elongdemo.m'`; then
    echo shar: \"'elongdemo.m'\" unpacked with wrong size!
fi
chmod +x 'elongdemo.m'
# end of 'elongdemo.m'
fi
if test -f 'faber.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'faber.m'\"
else
echo shar: Extracting \"'faber.m'\" \(1836 characters\)
sed "s/^X//" >'faber.m' <<'END_OF_FILE'
Xfunction F = faber(m,w,beta,z,c)
X%FABER  Faber polynomial coefficients for polygonal regions.
X%       FABER(M,W,BETA,Z,C) returns the coefficients of Faber
X%       polynomials of degree <= M for the polygonal region described by
X%       W and BETA.  A call to DEPARAM must be made first to obtain the
X%       values of Z and C for the Schwarz-Christoffel exterior map.
X%       FABER will return an upper triangular square matrix P of size
X%       M+1 such that P(1:k,k) is the vector of coefficients for the
X%       Faber polynomial of degree k-1.  Note that the leading (highest
X%       degree) coefficient is always first.
X%	
X%	See also DEPARAM, FABERDEMO.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
X%       This function follows somewhat closely the procedure outlined in
X%       section 4 of Starke and Varga (Num. Math., 1993), except that no
X%       symmetry of the polygon is assumed.
X
Xif nargin < 6
X  qdat = scqdata(beta,8);
Xend
Xn = length(w);
Xgam = ones(n,m+1);			% coeffs of binomial expansion
XZ = ones(n,m-1);			% powers of the z(j)
Xfor k = 1:m
X  gam(:,k+1) = -gam(:,k).*(beta-k+1)./(k*z);
X  if k < m
X    Z(:,k) = z.^k;
X  end
Xend
X
X% Compute the coeffs of the Laurent expansion of Psi
Xe1 = zeros(m+1,1);
Xe1(1) = 1;
XC = -c*e1;
Xfor j = 1:n
X  C = toeplitz(gam(j,:).', e1')*C;
Xend
XC = C(3:m+1)./(-(1:m-1)');
X%c0 = (sum(w) + c*sum(1./z) - sum(Z)*C)/n;
Xx0 = 10^(-10/m);
Xc0 = demap(x0,w,beta,z,c,qdat) + c/x0 - x0.^(1:m-1)*C;
XC = [c0;C];
X
X% Use the Faber recurrence to compute polynomial coeffs
XP = zeros(m+1,m+1);
XP(1,1) = 1;				% poly coeffs, low order first
XF = P;					% high order first (MATLAB style)
Xfor k = 1:m
X  P(1:k+1,k+1) = ([0;P(1:k,k)] - P(1:k+1,1:k)*[k*C(k);C(k-1:-1:1)])/(-c);
X  F(1:k+1,k+1) = flipud(P(1:k+1,k+1));
Xend
X
X% Normalize so that leading coefficients are real
XF = F*diag(exp(-i*angle(F(1,:))));
X
END_OF_FILE
if test 1836 -ne `wc -c <'faber.m'`; then
    echo shar: \"'faber.m'\" unpacked with wrong size!
fi
chmod +x 'faber.m'
# end of 'faber.m'
fi
if test -f 'faberdemo.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'faberdemo.m'\"
else
echo shar: Extracting \"'faberdemo.m'\" \(2136 characters\)
sed "s/^X//" >'faberdemo.m' <<'END_OF_FILE'
Xmore off
Xecho on
Xclc
X% This script demonstrates Faber polynomials.
X
X% Faber polynomials are defined via a conformal map f from the
X% simply connected exterior of a bounded region to the exterior
X% of the unit disk, fixing the point at infinity.  The nth Faber 
X% polynomial is the polynomial part of the Laurent expansion of f^n
X% at infinity.  The Faber polynomials reduce to Chebyshev polynomials
X% when the region is an interval and Taylor polynomials when it is a
X% disk.  If the region is bounded by a polygon, the Schwarz-Christoffel
X% exterior map can be used to compute Faber polynomial coefficients.
X
X% If you are using MATLAB for MS Windows, be sure you have selected the
X% "Enable background process" item on the "Options" menu before proceeding.
X
Xpause    % Strike any key to begin (Ctrl-C to abort)
Xfigure(gcf)
Xhold off
Xclc
X% Use the mouse to draw a polygon.  Be sure to put vertices in
X% clockwise order, and use only finite vertices.
X
X[w,beta] = drawpoly; 
X
Xhold on
Xaxis(axis)
X
Xpause    % Strike any key to compute Faber polynomial coefficients
X
X[z,c] = deparam(w,beta);
X
XF = faber(20,w,beta,z,c);
X
Xpause    % Strike any key to continue
X
X
X% Because the Faber polynomials approximate a function having unit
X% modulus on the polygon, the lemniscates {z: |p(z)|=1} for Faber
X% polynomials p will approximate the polygon.
X
Xlim = axis;
X[X,Y] = meshgrid(linspace(lim(1),lim(2),40),linspace(lim(3),lim(4),40));
Xh = line(NaN,NaN);
Xfor m = 4:4:16
X  delete(h)
X  Z = abs(polyval(F(1:m+1,m+1),X+i*Y));          
X  [con,h] = contour(X,Y,Z,[1,NaN],'c');
X  title(['degree of Faber polynomial = ',int2str(m)])
X  disp(' ')
X  disp([blanks(m/4),'   Strike any key to continue'])
X  pause
Xend
X
X
X% Another way to see this is to look at |p(z)| for z on the polygon.
X% Here we choose Fejer points (images of roots of unity) for z.
X
Xzp = demap(exp(i*linspace(0,2*pi,100)),w,beta,z,c);
X
Xhold off
Xfor m = 4:4:16
X  plot(1:100,abs(polyval(F(1:m+1,m+1),zp)));          
X  title(['degree of Faber polynomial = ',int2str(m)])
X  disp(' ')
X  disp([blanks(m/4),'   Strike any key to continue'])
X  pause
Xend
X
Xecho off    % End of demo
Xtitle(' ')
Xhold off
X
X
END_OF_FILE
if test 2136 -ne `wc -c <'faberdemo.m'`; then
    echo shar: \"'faberdemo.m'\" unpacked with wrong size!
fi
chmod +x 'faberdemo.m'
# end of 'faberdemo.m'
fi
if test -f 'gaussj.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gaussj.m'\"
else
echo shar: Extracting \"'gaussj.m'\" \(1260 characters\)
sed "s/^X//" >'gaussj.m' <<'END_OF_FILE'
Xfunction [z,w] = gaussj(n,alf,bet);
X%GAUSSJ Nodes and weights for Gauss-Jacobi integration.
X%       [X,W] = GAUSSJ(N,ALF,BET) returns nodes and weights for
X%       Gauss-Jacobi integration.  Z and W are N-vectors such that
X%
X%	      / +1
X%	      |               ALF     BET
X%	      |     f(x) (1-x)   (1+x)      dx
X%	      |
X%	      /
X%	     -  -1
X%	
X%	is approximated by sum(f(Z) .* W).
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
X%       Uses the Lanczos iteration connection to orthogonal polynomials.
X%       Borrows heavily from GAUSSJ out of SCPACK Fortran.
X
X% Calculate coeffs a,b of Lanczos recurrence relation (closed form is
X% known).  Break out n=1 specially to avoid possible divide by zero.
Xapb = alf+bet;
Xa(1) = (bet-alf)/(apb+2);
Xb(1) = sqrt(4*(1+alf)*(1+bet) / ((apb+3)*(apb+2)^2));
XN = 2:n;
Xa(N) = (apb)*(bet-alf) ./ ((apb+2*N).*(apb+2*N-2));
XN = 2:(n-1);
Xb(N) = sqrt(4*N.*(N+alf).*(N+bet).*(N+apb) ./ ...
X            (((apb+2*N).^2-1).*(apb+2*N).^2));
X
X% Find eigvals/eigvecs of tridiag "Ritz" matrix
X[V,D] = eig(diag(a) + diag(b,1) + diag(b,-1));
X
X% Compute normalization (integral of w(x))
Xc = 2^(apb+1)*gamma(alf+1)*gamma(bet+1)/gamma(apb+2);
X
X% return the values
Xz = diag(D);
Xw = c*(V(1,:)').^2;
X[z,ind] = sort(z);
Xw = w(ind);
X
END_OF_FILE
if test 1260 -ne `wc -c <'gaussj.m'`; then
    echo shar: \"'gaussj.m'\" unpacked with wrong size!
fi
chmod +x 'gaussj.m'
# end of 'gaussj.m'
fi
if test -f 'hp2disk.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hp2disk.m'\"
else
echo shar: Extracting \"'hp2disk.m'\" \(741 characters\)
sed "s/^X//" >'hp2disk.m' <<'END_OF_FILE'
Xfunction [z,c] = hp2disk(w,beta,x,a)
X%HP2DISK Convert solution from the half-plane to one from the disk.
X%	[Z,C] = HP2DISK(W,BETA,X,C) quickly transforms the solution X,C
X%	of the Schwarz-Christoffel half-plane mapping parameter problem
X%	to the solution Z,C of the disk problem.
X%	
X%	See also DISK2HP, HPPARAM, DPARAM.
X%	
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
Xz = zeros(size(x));
Xif isinf(x(n))
X  z(n) = 1;
X  z(1:n-1) = (x(1:n-1)-i)./(x(1:n-1)+i);
Xelse
X  z = (x-i)./(x+i);
X  z = z/z(n);
Xend
Xz = z./abs(z);  % enforce exactly abs(z)==1
X
X% Recalculate constant from scratch.
Xmid = (z(1)+z(2))/2;
Xqdat = scqdata(beta,10);
Xc = (w(1) - w(2))/...
X    (dquad(z(2),mid,2,z,beta,qdat) - dquad(z(1),mid,1,z,beta,qdat));
X
END_OF_FILE
if test 741 -ne `wc -c <'hp2disk.m'`; then
    echo shar: \"'hp2disk.m'\" unpacked with wrong size!
fi
chmod +x 'hp2disk.m'
# end of 'hp2disk.m'
fi
if test -f 'hpderiv.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hpderiv.m'\"
else
echo shar: Extracting \"'hpderiv.m'\" \(606 characters\)
sed "s/^X//" >'hpderiv.m' <<'END_OF_FILE'
Xfunction fprime = hpderiv(zp,x,beta)
X%HPDERIV Derivative of the half-plane map.
X%	HPDERIV(ZP,X,BETA) returns the derivative at the points of ZP of
X%	the Schwarz-Christoffel half-plane map whose prevertices are X and
X%	whose turning angles are BETA.
X%
X%       Don't forget the multiplicative constant in the SC map!
X%	
X%	See also HPPARAM, HPMAP.
X%	
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xx = x(:);
Xbeta = beta(:);
Xzprow = zp(:).';
Xfprime = zeros(size(zp));
Xnpts = length(zp(:));
Xterms = zprow(ones(length(beta),1),:) - x(:,ones(npts,1));
Xfprime(:) = exp(sum(log(terms).*beta(:,ones(npts,1))));
END_OF_FILE
if test 606 -ne `wc -c <'hpderiv.m'`; then
    echo shar: \"'hpderiv.m'\" unpacked with wrong size!
fi
chmod +x 'hpderiv.m'
# end of 'hpderiv.m'
fi
if test -f 'hpdisp.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hpdisp.m'\"
else
echo shar: Extracting \"'hpdisp.m'\" \(784 characters\)
sed "s/^X//" >'hpdisp.m' <<'END_OF_FILE'
Xfunction hpdisp(w,beta,x,c)
X%HPDISP Display results of Schwarz-Christoffel half-plane parameter problem.
X%       HPDISP(W,BETA,X,C) displays the results of HPPARAM in a pleasant
X%       way.  
X%
X%	See also HPPARAM, HPPLOT.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xif length(x) < length(w)
X  x = [x(:);Inf];
Xend
Xdisp(' ')
Xdisp('          w                beta               x          ')
Xdisp(' --------------------------------------------------------')
Xu = real(w);
Xv = imag(w);
Xfor j = 1:length(w)
X  if v(j) < 0
X    s = '-';
X  else
X    s = '+';
X  end
X  disp(sprintf(' %8.5f %c %7.5fi     %8.5f    %20.12e',...
X      u(j),s,abs(v(j)),beta(j),x(j)));
Xend
Xdisp(' ')
Xif imag(c) < 0
X  s = '-';
Xelse
X  s = '+';
Xend
Xdisp(sprintf('  c = %.8g %c %.8gi',real(c),s,abs(imag(c))))
X
END_OF_FILE
if test 784 -ne `wc -c <'hpdisp.m'`; then
    echo shar: \"'hpdisp.m'\" unpacked with wrong size!
fi
chmod +x 'hpdisp.m'
# end of 'hpdisp.m'
fi
if test -f 'hpimapf1.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hpimapf1.m'\"
else
echo shar: Extracting \"'hpimapf1.m'\" \(459 characters\)
sed "s/^X//" >'hpimapf1.m' <<'END_OF_FILE'
Xfunction zdot = imapf1(wp,yp);
X%HPIMAPF1 (not intended for calling directly by the user)
X%	Used by HPINVMAP for solution of an ODE.
X
Xglobal HPIMDATA 
X
Xlenyp = length(yp);
Xlenzp = lenyp/2;
Xzp = yp(1:lenzp)+sqrt(-1)*yp(lenzp+1:lenyp);
Xlenx = HPIMDATA(1,4);
Xbigx = HPIMDATA(1:lenx,2)*ones(1,lenyp/2);
Xbigbeta = HPIMDATA(1:lenx,3)*ones(1,lenyp/2);
X
Xf = HPIMDATA(1:lenzp,1).*exp(sum(log(ones(lenx,1)*zp.' - bigx).*...
X    (-bigbeta))).';
Xzdot = [real(f);imag(f)];
END_OF_FILE
if test 459 -ne `wc -c <'hpimapf1.m'`; then
    echo shar: \"'hpimapf1.m'\" unpacked with wrong size!
fi
chmod +x 'hpimapf1.m'
# end of 'hpimapf1.m'
fi
if test -f 'hpinvmap.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hpinvmap.m'\"
else
echo shar: Extracting \"'hpinvmap.m'\" \(3269 characters\)
sed "s/^X//" >'hpinvmap.m' <<'END_OF_FILE'
Xfunction zp = hpinvmap(wp,w,beta,x,c,qdat,z0,options)
X%HPINVMAP Schwarz-Christoffel half-plane inverse map.
X%	HPINVMAP(WP,W,BETA,X,C,QDAT) computes the inverse of the
X%	Schwarz-Christoffel half-plane map (i.e., from the polygon
X%	to the upper half-plane ) at the points given in vector WP. The
X%	other arguments are as in HPPARAM.  QDAT may be omitted.
X%
X%	The default algorithm is to solve an ODE in order to obtain a fair
X%	approximation for ZP, and then improve ZP with Newton iterations.
X%	The ODE solution at WP requires a vector Z0 whose forward image W0
X%	is such that for each j, the line segment connecting WP(j) and W0(j)
X%	lies inside the polygon.  By default Z0 is chosen by a fairly robust
X%	automatic process.  Using a parameter (see below), you can choose to
X%	use either an ODE solution or Newton iterations exclusively.
X%
X%	HPINVMAP(WP,W,BETA,X,C,QDAT,Z0) has two interpretations.  If the ODE
X%	solution is being used, Z0 overrides the automatic selection of
X%	initial points.  (This can be handy in convex polygons, where the
X%	choice of Z0 is trivial.)  Otherwise, Z0 is taken as an initial
X%	guess to ZP.  In either case, if length(Z0)==1, the value Z0 is used
X%	for all elements of WP; otherwise, length(Z0) should equal
X%	length(WP).
X%
X%       HPINVMAP(WP,W,BETA,X,C,QDAT,Z0,OPTIONS) uses a vector of parameters
X%       that control the algorithm.  See SCIMAPOPT.
X%
X%	See also SCIMAPOPT, HPPARAM, HPMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
Xw = w(:);
Xbeta = beta(:);
Xx = x(:);
Xzp = zeros(size(wp));
Xwp = wp(:);
Xlenwp = length(wp);
X
Xif nargin < 8
X  options = [];
X  if nargin < 7
X    z0 = [];
X    if nargin < 6
X      qdat = [];
X    end
X  end
Xend
X
X[ode,newton,tol,maxiter] = scimapopt(options);
X
Xnfin = n - isinf(x(n));
Xif isempty(qdat)
X  qdat = scqdata(beta(1:nfin),max(ceil(-log10(tol)),2));
Xend
X
X% ODE
Xif ode
X  if isempty(z0)
X    % Pick a value z0 (not a singularity) and compute the map there.
X    [z0,w0] = scimapz0('hp',wp,w,beta,x,c,qdat);
X  else
X    w0 = hpmap(z0,w,beta,x,c,qdat);
X    if length(z0)==1 & lenwp > 1
X      z0 = z0(:,ones(lenwp,1)).';
X      w0 = w0(:,ones(lenwp,1)).';
X    end
X  end
X
X  % Use relaxed ODE tol if improving with Newton.
X  odetol = max(tol,1e-3*(newton));
X
X  % Set up data for the ode function.
X  global HPIMDATA	
X  HPIMDATA = (wp - w0(:))/c; 		% adjusts "time" interval
X  HPIMDATA(1:nfin,2:3) = [x(1:nfin), beta(1:nfin)];
X  HPIMDATA(1,4) = nfin;
X
X  z0 = [real(z0);imag(z0)];
X  [t,y] = ode45('hpimapf1',0,1,z0,odetol);
X  [m,leny] = size(y);
X  zp(:) = y(m,1:lenwp)+sqrt(-1)*y(m,lenwp+1:leny);
Xend
X
X% Newton iterations
Xif newton
X  if ~ode
X    zn = z0(:);
X    if length(z0)==1 & lenwp > 1
X      zn = zn(:,ones(lenwp,1));
X    end
X  else
X    zn = zp(:);
X  end
X    
X  wp = wp(:);
X  done = zeros(size(zn));
X  k = 0;
X  while ~all(done) & k < maxiter
X    F = wp(~done) - hpmap(zn(~done),w,beta,x,c,qdat);
X    m = length(F);
X    dF = c*exp(sum(beta(1:nfin,ones(m,1)).*...
X         log(zn(~done,ones(nfin,1)).'-x(1:nfin,ones(m,1)))));
X    zn(~done) = zn(~done) + F(:)./dF(:);
X    done(~done) =  (abs(F) < tol);
X    k = k + 1;
X  end
X  if any(abs(F)> tol)
X    disp('Warning in hpinvmap: Solution may be inaccurate')
X    fprintf('Maximum residual = %.3g\n',max(abs(F)))
X  end
X  zp(:) = zn; 
Xend;
X
END_OF_FILE
if test 3269 -ne `wc -c <'hpinvmap.m'`; then
    echo shar: \"'hpinvmap.m'\" unpacked with wrong size!
fi
chmod +x 'hpinvmap.m'
# end of 'hpinvmap.m'
fi
if test -f 'hpmap.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hpmap.m'\"
else
echo shar: Extracting \"'hpmap.m'\" \(2464 characters\)
sed "s/^X//" >'hpmap.m' <<'END_OF_FILE'
Xfunction wp = hpmap(zp,w,beta,x,c,qdat)
X%HPMAP  Schwarz-Christoffel half-plane map.
X%	HPMAP(ZP,W,BETA,X,C,QDAT) computes the values of the
X%	Schwarz-Christoffel half-plane map at the points in vector ZP.  The
X%	polygon's vertices should be given in W and the arguments X, C, and
X%	QDAT should be computed by HPPARAM.  HPMAP returns a vector the same
X%	size as ZP. 
X%	
X%       HPMAP(ZP,W,BETA,X,C,TOL) uses quadrature data intended to give an
X%       answer accurate to within roughly TOL.
X%	
X%	HPMAP(ZP,W,BETA,X,C) uses a tolerance of 1e-8.
X%
X%	See also HPPARAM, HPPLOT, HPINVMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/31/95.
X
Xn = length(w);
Xw = w(:);
Xbeta = beta(:);
Xx = x(:);
Xif any(isinf(x))
X  x(n) = [];
X  beta(n) = [];
Xend
X
Xif nargin < 6
X  qdat = scqdata(beta,8);
Xelseif length(qdat)==1
X  qdat = scqdata(beta,max(ceil(-log10(qdat)),8));
Xend
Xwp = zeros(size(zp));
Xzp = zp(:);
Xp = length(zp);
X
X% For each point in zp, find nearest prevertex.
X[tmp,sing] = min(abs(zp(:,ones(length(x),1)).'-x(:,ones(1,p))));
Xsing = sing(:);				% indices of prevertices
Xatinf = find(isinf(w(1:length(x)))); 	% infinite vertices
Xatinf = atinf(:);
Xninf = length(atinf);			% # of inf vertices
Xif ninf > 0
X  % "Bad" points are closest to a prevertex of infinity.
X  bad = sing(:,ones(ninf,1))' == atinf(:,ones(1,p));
X  % Can be closest to any pre-infinity.
X  if ninf > 1
X    bad = any(bad);
X  end
X  % Exclude cases which are exactly those prevertices.
X  bad = bad(:) & (abs(zp-x(sing)) > 10*eps);
X  % Can't integrate starting at pre-infinity: which neighboring prevertex
X  % to use?
X  direcn = real(zp(bad)-x(sing(bad)));
X  sing(bad) = sing(bad) + sign(direcn) + (direcn==0);
X  % Midpoints of these integrations 
X  mid = (x(sing(bad)) + zp(bad)) / 2;
Xelse
X  bad = zeros(p,1);
Xend
X  
X% xs = the starting singularities
X% A MATLAB technicality could cause a mistake if sing is all ones and same
X% length as x, hence a workaround.
Xxs = wp(:); xs(1:p+1) = x([sing;2]); xs = xs(1:p);
X% ws = f(xs)
Xws = wp(:); ws(1:p+1) = w([sing;2]); ws = ws(1:p);
X
X% Compute the map directly at "normal" points.
Xif any(~bad)
X  wp(~bad) = ws(~bad) + c*hpquad(xs(~bad),zp(~bad),sing(~bad),...
X      x,beta,qdat);
Xend
X% Compute map at "bad" points, stopping at midpoint to avoid integration
X% where right endpoint is close to a singularity.
Xif any(bad)
X  wp(bad) = ws(bad) + c*...
X      (hpquad(xs(bad),mid,sing(bad),x,beta,qdat) -...
X      hpquad(zp(bad),mid,zeros(sum(bad),1),x,beta,qdat));
Xend
X  
X
X
END_OF_FILE
if test 2464 -ne `wc -c <'hpmap.m'`; then
    echo shar: \"'hpmap.m'\" unpacked with wrong size!
fi
chmod +x 'hpmap.m'
# end of 'hpmap.m'
fi
if test -f 'hpparam.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hpparam.m'\"
else
echo shar: Extracting \"'hpparam.m'\" \(3032 characters\)
sed "s/^X//" >'hpparam.m' <<'END_OF_FILE'
Xfunction [x,c,qdat] = hpparam(w,beta,x0,options);
X%HPPARAM Schwarz-Christoffel half-plane parameter problem.
X%	[X,C,QDAT] = HPPARAM(W,BETA) solves the Schwarz-Christoffel
X%	parameter problem with the upper half-plane as fundamental
X%	domain and interior of the specified polygon as the target.  W
X%	must be a vector of the vertices of the polygon, specified in
X%	counterclockwise order.  BETA is a vector of turning angles; see
X%	SCANGLES.  If successful, HPPARAM will return X, a vector of the
X%	pre-images of W; C, the multiplicative constant of the conformal
X%	map; and QDAT, a matrix of quadrature data used by some of
X%	the other S-C routines.
X%
X%       [X,C,QDAT] = HPPARAM(W,BETA,X0) uses X0 as an initial guess for
X%       X.
X%
X%       [X,C,QDAT] = HPPARAM(W,BETA,X0,OPTIONS) uses a vector of control
X%       parameters.  See SCPARMOPT.
X%	
X%	See also SCPARMOPT, DRAWPOLY, HPDISP, HPPLOT, HPMAP, HPINVMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/26/95.
X
Xn = length(w); 				% no. of vertices
Xw = w(:);
Xbeta = beta(:);
X
X% Set up defaults for missing args
Xif nargin < 4
X  options = [];
X  if nargin < 3
X    x0 = [];
X  end
Xend
X
Xerr = sccheck('hp',w,beta);
Xif err==1
X  fprintf('Use SCFIX to make polygon obey requirements\n')
X  error(' ')
Xend
X
X[trace,tol] = scparmopt(options);
Xnqpts = max(ceil(-log10(tol)),4);
Xqdat = scqdata(beta(1:n-1),nqpts); 	% quadrature data
X
Xatinf = (beta <= -1);
X
X% Find prevertices (solve param problem)
Xif n==3
X  x = [-1;0;Inf];
X
Xelse
X
X  % Set up normalized lengths for nonlinear equations:
X
X  % indices of left and right integration endpoints
X  left = 1:n-2;				
X  right = 2:n-1;				
X  % delete indices corresponding to vertices at Inf
X  left(find(atinf)) = [];
X  right(find(atinf) - 1) = [];
X  cmplx = ((right-left) == 2);
X  % normalize lengths by w(2)-w(1)
X  nmlen = (w(right)-w(left))/(w(2)-w(1));
X  % abs value for finite ones; Re/Im for infinite ones
X  nmlen = [abs(nmlen(~cmplx));real(nmlen(cmplx));imag(nmlen(cmplx))];
X  % first entry is useless (=1)
X  nmlen(1) = [];
X  
X  % Set up initial guess
X  if isempty(x0)
X    y0 = zeros(n-3,1);
X  else
X    x0 = x0(:);
X    x0 = (x0-x0(2))/(x0(2)-x0(1));
X    y0 = log(diff(x0(2:n-1)));
X  end
X
X  % Solve nonlinear system of equations:
X
X  % package data
X  nrow = max([n-1,nqpts,4]);
X  ncol = 6+2*n;
X  fdat = zeros(nrow,ncol);
X  fdat(1:4,1) = [n;length(left);nqpts;ncol];
X  fdat(1:n-1,2) = beta(1:n-1);
X  fdat(1:n-3,3) = nmlen(:);
X  fdat(1:fdat(2,1),4:6) = [left(:),right(:),cmplx(:)];
X  fdat(1:nqpts,7:ncol) = qdat;
X  % set options
X  opt = zeros(16,1);
X  opt(1) = 2*trace;
X  opt(6) = 100*(n-3);
X  opt(8) = tol;
X  opt(9) = tol/10;
X  opt(12) = nqpts;
X  % do it
X  [y,termcode] = nesolve('hppfun',y0,opt,fdat);
X  if termcode~=1
X    disp('Warning: Nonlinear equations solver did not terminate normally')
X  end
X
X  % Convert y values to x
X  x = [-1;cumsum([0;exp(y)]);Inf];
Xend
X
X% Determine multiplicative constant
Xmid = mean(x(1:2));
Xg = hpquad(x(2),mid,2,x(1:n-1),beta(1:n-1),qdat) -...
X    hpquad(x(1),mid,1,x(1:n-1),beta(1:n-1),qdat);
Xc = (w(1)-w(2))/g;
X
END_OF_FILE
if test 3032 -ne `wc -c <'hpparam.m'`; then
    echo shar: \"'hpparam.m'\" unpacked with wrong size!
fi
chmod +x 'hpparam.m'
# end of 'hpparam.m'
fi
if test -f 'hppfun.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hppfun.m'\"
else
echo shar: Extracting \"'hppfun.m'\" \(1363 characters\)
sed "s/^X//" >'hppfun.m' <<'END_OF_FILE'
Xfunction F = hppfun(y,fdat)
X%HPPFUN (not intended for calling directly by the user)
X%	Returns residual for solution of nonlinear equations. 
X%	Used by HPPARAM.
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
X
Xn = fdat(1,1);
Xbeta = fdat(1:n-1,2);
Xnmlen = fdat(1:n-3,3);
Xrows = 1:fdat(2,1);
Xleft = fdat(rows,4);
Xright = fdat(rows,5);
Xcmplx = fdat(rows,6);
Xqdat = fdat(1:fdat(3,1),7:fdat(4,1));
X
X% Transform y (unconstr. vars) to x (prevertices)
Xx = [-1;cumsum([0;exp(y)])];
X
X% Check crowding of singularities.
Xif any(diff(x)<eps) | any(isinf(x))
X  % Since abs(y) is large, use it as the penalty function.
X  F = y;
X  disp('Warning: Severe crowding')
X  return
Xend
X
X% Compute the integrals appearing in nonlinear eqns.
Xxleft = x(left);
Xxright = x(right);
Xmid = mean([xleft.' ; xright.']).';
X% For integrals between non-adjacent singularities, choose intermediate
X% points in the upper half-plane.
Xmid(cmplx) = mid(cmplx) + i*(xright(cmplx)-xleft(cmplx))/2;
Xints = hpquad(xleft,mid,left,x,beta,qdat) - ...
X    hpquad(xright,mid,right,x,beta,qdat);
X
Xif any(ints==0)
X  % Singularities were too crowded in practice.
X  F = y;
X  disp('Warning: Severe crowding')
Xelse
X  % Compute nonlinear equation residual values.
X  F1 = abs(ints(~cmplx));		% F1(1) = abs(ints(1))
X  F1 = F1(2:length(F1))/F1(1);
X  F2 = ints(cmplx)/ints(1);
X  F = [F1;real(F2);imag(F2)] - nmlen;
Xend
X
X
END_OF_FILE
if test 1363 -ne `wc -c <'hppfun.m'`; then
    echo shar: \"'hppfun.m'\" unpacked with wrong size!
fi
chmod +x 'hppfun.m'
# end of 'hppfun.m'
fi
if test -f 'hpplot.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hpplot.m'\"
else
echo shar: Extracting \"'hpplot.m'\" \(4486 characters\)
sed "s/^X//" >'hpplot.m' <<'END_OF_FILE'
Xfunction [H,RE,IM] = hpplot(w,beta,x,c,re,im,options)
X%HPPLOT Image of cartesian grid under Schwarz-Christoffel half-plane map.
X%       HPPLOT(W,BETA,X,C) will adaptively plot the images under the
X%       Schwarz-Christoffel exterior map of ten evenly spaced horizontal
X%       and vertical lines in the upper half-plane. The abscissae of the
X%       vertical lines will bracket the finite extremes of X.  The
X%       arguments are as in HPPARAM.
X%
X%       HPPLOT(W,BETA,X,C,M,N) will plot images of M evenly spaced
X%       vertical and N evenly spaced horizontal lines.  The spacing will
X%       be the same in both directions.
X%
X%       HPPLOT(W,BETA,X,C,RE,IM) will plot images of vertical lines
X%       whose real parts are given in RE and horizontal lines whose
X%       imaginary parts are given in IM.  Either argument may be empty.
X%
X%       HPPLOT(W,BETA,X,C,RE,IM,OPTIONS) allows customization of
X%       HPPLOT's behavior.  See SCPLOTOPT.
X%
X%       H = HPPLOT(W,BETA,X,C,...) returns a vector of handles to all
X%       the curves drawn in the interior of the polygon.  [H,RE,IM] =
X%       HPPLOT(W,BETA,X,C,...) also returns the abscissae and ordinates
X%       of the lines comprising the grid.
X%	
X%	See also SCPLOTOPT, HPPARAM, HPMAP, HPDISP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xturn_off_hold = ~ishold;
Xn = length(w);
Xw = w(:);
Xbeta = beta(:);
Xx = x(:);
Xif nargin < 7
X  options = [];
X  if nargin < 6
X    im = [];
X    if nargin < 5
X      re = [];
X    end
X  end
Xend
X
Xif isempty([re(:);im(:)])
X  re = 10;
X  im = 10;
Xend
X
Xif (length(re)==1) & (re == round(re))
X  if re < 1
X    re = [];
X  elseif re < 2
X    re = mean(x([1,n-1]));
X  else
X    m = re;
X    re = linspace(x(1),x(n-1),m);
X    dre = diff(re(1:2));
X    re = linspace(x(1)-dre,x(n-1)+dre,m);
X  end
Xend
Xif (length(im)==1) & (im == round(im))
X  if length(re) < 2
X    im = linspace(0,4,im+1);
X    im(1) = [];
X  else
X    im = mean(diff(re))*(1:im);
X  end
Xend
X
X[nqpts,maxturn,maxlen,maxrefn] = scplotopt(options);
X
Xfig = gcf;
Xfigure(fig);
Xplotpoly(w,beta);
Xdrawnow
Xhold on
X
Xn = length(w);
Xreflen = maxlen*max(abs(diff([w(~isinf(w));w(1)])));
Xif any(isinf(x))
X  qdat = scqdata(beta(1:n-1),nqpts);
Xelse
X  qdat = scqdata(beta,nqpts);
Xend
X
Xy2 = max(x(n-1),10);
Xfor j = 1:length(re)
X  zp = re(j) + i*linspace(0,y2,15).';
X  wp = hpmap(zp,w,beta,x,c,qdat);
X  bad = find(toobig([wp;w(n)],maxturn,reflen,axis));
X  iter = 0;
X  while (~isempty(bad)) & (iter < maxrefn)
X    lenwp = length(wp);
X    newz = [];
X    special = find(bad==lenwp);
X    newz = re(j) + i*5*imag(zp(bad(special)));
X    bad(special) = [];
X    newz = [newz;(zp(bad-1)+2*zp(bad))/3;(zp(bad+1)+2*zp(bad))/3];
X    neww = hpmap(newz,w,beta,x,c,qdat);
X    [k,in] = sort(imag([zp;newz]));
X    zp = [zp;newz];  wp = [wp;neww];
X    zp = zp(in);     wp = wp(in);
X    iter = iter + 1;
X    bad = find(toobig([wp;w(n)],maxturn,reflen,axis));
X  end
X  linh(j) = plot(clipdata([wp;w(n)],axis), 'g-','erasemode','none');
X  drawnow
X  set(linh(j),'erasemode','normal');
X  Z(1:length(zp),j) = zp;
X  W(1:length(wp),j) = wp;
Xend
X
Xx1 = min(-10,x(n-1));
Xx2 = max(40,x(n-1));
Xaxlim = axis;
Xfor j = 1:length(im)
X  zp = linspace(x1,x2,15).' + i*im(j);
X  wp = hpmap(zp,w,beta,x,c,qdat);
X  bad = find(toobig([w(n);wp;w(n)],maxturn,reflen,axis)) - 1;
X  iter = 0;
X  while (~isempty(bad)) & (iter < maxrefn)
X    lenwp = length(wp);
X    special = zeros(2,1);
X    if isinf(w(n))
X      ends = wp([1,lenwp]);
X      special = real(ends)>axlim(1) & real(ends)<axlim(2) & ...
X	  imag(ends)>axlim(3) & imag(ends)<axlim(4);
X    else 
X      special(1) = any(bad==1);
X      special(2) = any(bad==lenwp);
X    end
X    bad(bad==1 | bad==lenwp) = [];
X    newz = [(zp(bad-1)+2*zp(bad))/3;(zp(bad+1)+2*zp(bad))/3];
X    zends = zp([1,lenwp]);
X    newz = [newz;i*imag(zends(special))+5*real(zends(special))];
X    neww = hpmap(newz,w,beta,x,c,qdat);
X    [k,in] = sort(real([zp;newz]));
X    zp = [zp;newz];  wp = [wp;neww];
X    zp = zp(in);     wp = wp(in);
X    iter = iter + 1;
X    bad = find(toobig([w(n);wp;w(n)],maxturn,reflen,axis)) - 1;
X  end
X  linh(j+length(re)) = plot(clipdata([w(n);wp;w(n)],axis),...
X      'g-','erasemode','none');
X  drawnow
X  set(linh(j+length(re)),'erasemode','normal');
X  Z(1:length(zp),j+length(re)) = zp;
X  W(1:length(wp),j+length(re)) = wp;
Xend
X  
X% Force redraw to get clipping enforced.
Xset(fig,'color',get(fig,'color'))
Xif turn_off_hold, hold off, end;
Xif nargout > 0
X  H = linh;
X  if nargout > 1
X    RE = re;
X    if nargout > 2
X      IM = im;
X    end
X  end
Xend 
X
END_OF_FILE
if test 4486 -ne `wc -c <'hpplot.m'`; then
    echo shar: \"'hpplot.m'\" unpacked with wrong size!
fi
chmod +x 'hpplot.m'
# end of 'hpplot.m'
fi
if test -f 'hpquad.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hpquad.m'\"
else
echo shar: Extracting \"'hpquad.m'\" \(2434 characters\)
sed "s/^X//" >'hpquad.m' <<'END_OF_FILE'
Xfunction I = hpquad(z1,z2,sing1,x,beta,qdat)
X%HPQUAD (not intended for calling directly by the user)
X%	Numerical quadrature for the half-plane map.
X
X%	z1,z2 are vectors of left and right endpoints.  sing1 is a vector
X%	of integer indices which label the singularities in z1.  So if
X%	sing1(5) = 3, then z1(5) = x(3).  A zero means no singularity. 
X%	x is the vector of finite singularities;  beta is the vector of
X%	associated turning angles.  qdat is quadrature data from SCQDATA.
X%
X%	Make sure x and beta are column vectors.
X%	
X%	HPQUAD integrates from a possible singularity at the left end to a
X%	regular point at the right.  If both endpoints are singularities,
X%	you must break the integral into two pieces and make two calls.
X%	
X%	The integral is subdivided, if necessary, so that no
X%	singularity lies closer to the left endpoint than 1/2 the
X%	length of the integration (sub)interval.
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
Xnqpts = size(qdat,1);
X% Note: Here n is the total number of *finite* singularities; i.e., the
X% number of terms in the product appearing in the integrand.
Xn = length(x);
Xbigx = x(:,ones(1,nqpts));
Xbigbeta = beta(:,ones(1,nqpts));
Xif isempty(sing1)
X  sing1 = zeros(length(z1),1);
Xend
X
XI = zeros(size(z1));
Xnontriv = find(z1(:)~=z2(:))';
X
Xfor k = nontriv
X  za = z1(k);
X  zb = z2(k);
X  sng = sing1(k);
X
X  % Allowable integration step, based on nearest singularity.
X  dist = min(1,2*min(abs(x([1:sng-1,sng+1:n])-za))/abs(zb-za));
X  zr = za + dist*(zb-za);
X  ind = rem(sng+n,n+1)+1;
X  % Adjust Gauss-Jacobi nodes and weights to interval.
X  nd = ((zr-za)*qdat(:,ind) + zr + za)/2; % G-J nodes
X  wt = ((zr-za)/2) * qdat(:,ind+n+1); 	% G-J weights
X  terms = nd(:,ones(n,1)).' - bigx;
X  if any(~diff(nd)) | any(any(~terms)) 
X    % Endpoints are practically coincident.
X    I(k) = 0;
X  else
X    % Use Gauss-Jacobi on first subinterval, if necessary.
X    if sng > 0
X      terms(sng,:) = terms(sng,:)./abs(terms(sng,:));
X      wt = wt*(abs(zr-za)/2)^beta(sng);
X    end
X    I(k) = exp(sum(log(terms).*bigbeta))*wt;
X    while dist < 1              
X      % Do regular Gaussian quad on other subintervals.
X      zl = zr;
X      dist = min(1,2*min(abs(x-zl))/abs(zl-zb));
X      zr = zl + dist*(zb-zl);
X      nd = ((zr-zl)*qdat(:,n+1) + zr + zl)/2;
X      wt = ((zr-zl)/2) * qdat(:,2*n+2);
X      terms = nd(:,ones(n,1)).' - bigx;
X      I(k) = I(k) + exp(sum(log(terms).*bigbeta)) * wt;
X    end
X  end
Xend
X
END_OF_FILE
if test 2434 -ne `wc -c <'hpquad.m'`; then
    echo shar: \"'hpquad.m'\" unpacked with wrong size!
fi
chmod +x 'hpquad.m'
# end of 'hpquad.m'
fi
if test -f 'infdemo.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'infdemo.m'\"
else
echo shar: Extracting \"'infdemo.m'\" \(3355 characters\)
sed "s/^X//" >'infdemo.m' <<'END_OF_FILE'
Xmore off
Xecho on
Xclc
X% This script demonstrates the interpretation of infinite vertices.
X
Xpause     % Strike any key to begin (Ctrl-C to abort)
X
X% For the purposes of the Schwarz-Christoffel Toolbox, a polygon
X% is represented by two vectors: w, the vertices in positively 
X% oriented order, and beta, the corresponding "turning angles."
X% At a finite vertex w(j), the meaning of beta(j) is simple:
X% pi*beta(j) is the exterior turning angle of the polygon
X% at w(j), with a minus sign for left (counterclockwise) turns.  
X% By convention, beta(j) is +1 at a slit, so at a finite vertex,
X% -1 < beta(j) <= 1.
X
X% If w(j) is infinite, the formal definition of beta(j) is more 
X% cumbersome: pi*beta(j) is -2*pi plus the exterior angle formed by 
X% the two sides incident on w(j) as they are extended *away* from 
X% infinity.  But the interpretation of pi*beta(j) as "turn" is still
X% valid.  It turns out that -3 <= beta(j) <= -1 at an infinite vertex.
X
X% Following are some examples that should help clarify matters.
X
Xpause     % Strike any key to continue
Xecho off
X
Xfigure(gcf)
Xcla
Xaxis square
Xaxis([-2 2 -2 2])
Xhold on
X
Xint = fill([2,0,0,2],[1,1,-1,-1],[.6,.6,.6]);
Xedges = plot([2+i,i,-i,2-i],'y-');
Xplot([-i,i],'.','marker',12)
Xt1 = text(-.1,1,'-1/2','hor','right','ver','mid');
Xt2 = text(-.1,-1,'-1/2','hor','right','ver','mid');
Xt3 = text(2.1,0,'-1','hor','left','ver','mid');
X
Xclc
Xdisp(' ')
Xdisp('Here is a three-vertex polygon.  The values of beta are shown')
Xdisp('next to their associated vertices.  The infinite vertex has a')
Xdisp('turn of -1, which is the least possible.')
Xdisp(' ')
Xdisp('  Strike any key to continue')
Xpause
X
Xset(t1,'string','0');
Xset(t3,'string','-3/2');
Xset(edges,'xdata',[0,0,2],'ydata',[2,-1,-1])
Xset(int,'xdata',[0,0,2,2],'ydata',[2,-1,-1,2])
X
Xdisp(blanks(2)')
Xdisp('The turn at infinity is now -3/2.  Note that the sum of the')
Xdisp('turns is still -2.')
Xdisp(' ')
Xdisp('  Strike any key to continue')
Xpause
X
X
Xset(t1,'string','1/2','pos',[-.1,.9],'ver','top')
Xset(t3,'string','-2')
Xset(edges,'xdata',[-2,0,0,2],'ydata',[1,1,-1,-1])
Xset(int,'xdata',[-2,0,0,2,2,-2],'ydata',[1,1,-1,-1,2,2])
X
Xdisp(blanks(2)')
Xdisp('A turn of -2 isn''t really a turn at all.  But the edge returning')
Xdisp('from infinity doesn''t have to be colinear with the outgoing edge.')
Xdisp(' ')
Xdisp('  Strike any key to continue')
Xpause
X
X
Xset(t1,'pos',[-.1,.4],'string','3/4')
Xset(t3,'string','-9/4')
Xset(edges,'xdata',[-2,0,0,2],'ydata',[-2,1,-1,-1])
Xset(int,'xdata',[-2,0,0,2,2,-2],'ydata',[-2,1,-1,-1,2,2])
X
Xdisp(blanks(2)')
Xdisp('Turning past -2 produces a more "open" region.')
Xdisp(' ')
Xdisp('  Strike any key to continue')
Xpause
X
X
Xset(t1,'string','1/2','pos',[.1,.9],'hor','left')
Xset(t2,'string','1/2','pos',[.1,-.9],'hor','left','ver','bot')
Xset(t3,'string','-3')
Xset(edges,'xdata',[2,0,0,2],'ydata',[1,1,-1,-1])
Xset(int,'xdata',[2,0,0,2,2,-2,-2,2],'ydata',[-1,-1,1,1,2,2,-2,-2])
X
Xdisp(blanks(2)')
Xdisp('Finally, a turn of -3 is the most allowed.  The interior of this')
Xdisp('polygon is the complement of the first example, with a turn of -1.')
Xdisp(' ')
Xdisp('  Strike any key to continue')
Xpause
X
Xdisp(' ')
Xdisp('Here is what a disk map of this region looks like....')
Xdisp(' ')
Xecho on
Xw = [-i; i; Inf];
Xbeta = [.5; .5; -3];
X[z,c] = dparam(w,beta);
X[z,c] = dfixwc(w,beta,z,c,-1+i);
Xcla
Xdplot(w,beta,z,c)
X
Xecho off     % End of demo
X
END_OF_FILE
if test 3355 -ne `wc -c <'infdemo.m'`; then
    echo shar: \"'infdemo.m'\" unpacked with wrong size!
fi
chmod +x 'infdemo.m'
# end of 'infdemo.m'
fi
if test -f 'modpoly.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'modpoly.m'\"
else
echo shar: Extracting \"'modpoly.m'\" \(7511 characters\)
sed "s/^X//" >'modpoly.m' <<'END_OF_FILE'
Xfunction [w,beta,indx] = modpoly(w,beta)
X%MODPOLY Modify a polygon.
X%	[WNEW,BETANEW] = MODPOLY(W,BETA) plots the polygon given by W
X%	and BETA and allows the user to change it with the mouse.  At
X%	the start, MODPOLY allows you to move vertices.  Move the cursor
X%	over a vertex you want to move, hold down the left mouse button,
X%	drag it to its new location, and release.  The vertex changes
X%	color and affected sides become dashed as you move the vertex.
X%	
X%	To delete a vertex, press the Delete button.  The pointer
X%	will change to a fleur.  After your next click and release, the
X%	selected vertex will be deleted and you will return to movement
X%	mode.  To cancel a requested deletion, press Delete again.
X%	
X%	The Add button works similarly.  To add, press the button and
X%	then click and release on a polygon side.  A vertex will be
X%	added to the middle of the side, the polygon is redrawn, and you
X%	return to movement mode.
X%	
X%	Infinite vertices cannot be moved(!), deleted, or added.  When
X%	moving the neighbor of an infinite vertex, the angle at infinity
X%	is kept constant.  When you delete a neighbor of infinity, the
X%	turn at the deleted vertex is lost and the angle at infinity
X%	changes.  You cannot delete a vertex with two infinite
X%	neighbors.  When you add a vertex to an infinite side, the new
X%	vertex appears at a "reasonable" distance from its finite
X%	neighbor.
X%	
X%       [WNEW,BETANEW,IDX] = MODPOLY(W,BETA) also returns an index
X%       vector to help keep track of additions and deletions.  IDX has
X%       the same length as WNEW, and if IDX(J) is an integer, it gives
X%       the index that WNEW(J) had in the original W.  If WNEW(J) was
X%       added, then IDX(J) is NaN.
X%	
X%	Note: MODPOLY makes no attempt to keep the polygon "legal."  You
X%	can easily create things which are not polygons, or change
X%	infinite vertices into unrecognized finite ones.  
X%	
X%	See also DRAWPOLY, PLOTPOLY.
X%	
X%	Written by Toby Driscoll.  Last updated 6/1/95.
X
Xglobal sc_hs sc_hv sc_k sc_w sc_beta sc_idx
Xn = length(sc_w);
Xptr = get(gcf,'pointer');
X
Xif ~isstr(w)				% initial call
X  % Draw polygon and initialize global vars
X  sc_w = w(:);				% vertices
X  sc_beta = beta(:);			% angles
X  hold off
X  sc_hs = plotpoly(w,beta);		% side handles
X  hold on
X  sc_hv = zeros(n,1);			% vertex handles
X  for j=find(~isinf(w))'
X    sc_hv(j) = plot(real(w(j)),imag(w(j)),'.','mark',22);
X  end
X  sc_idx = (1:length(w))';		% indices
X  oldptr = ptr;
X  set(gcf,'pointer','circle')
X  % Create uicontrols
X  pb_done = uicontrol('style','push','string','Done','pos',[5,5,60,22],...
X      'call','set(get(gcf,''currentobj''),''user'',1)');
X  set(pb_done,'user',0);
X  pb_del = uicontrol('style','push','string','Delete','pos',[5,30,60,22],...
X      'call','modpoly(''delete'');');
X  pb_add = uicontrol('style','push','string','Add','pos',[5,55,60,22],...
X      'call','modpoly(''add'');');
X  set(gcf,'windowbuttondown','modpoly(''down'');')
X  % Run in place until finished
X  while ~get(pb_done,'user')
X    drawnow
X  end
X  set(gcf,'windowbuttondown','')
X  % Recover new info and clean up
X  w = sc_w;
X  beta = sc_beta;
X  hold off
X  delete(pb_done)
X  delete(pb_del)
X  delete(pb_add)
X  set(gcf,'pointer',oldptr)
X  plotpoly(w,beta)
X  indx = sc_idx;
X  clear sc_hs sc_hv sc_k sc_w sc_beta sc_idx
X
Xelseif strcmp(w,'down')			% button down
X  h = get(gcf,'currentobj');
X  % Act only if h is a line object
X  if strcmp(get(h,'type'),'line')
X    if ~strcmp(ptr,'crosshair')		% move or delete
X      if strcmp(get(h,'linesty'),'.')	% vertex?
X	sc_k = find(h==sc_hv);
X	colr = get(gca,'colororder');
X	set(h,'color',colr(2,:))
X	set(sc_hs([sc_k,rem(sc_k-2+n,n)+1]),'linesty','--')
X	if strcmp(ptr,'circle')
X	  % Mouse movement needed only when moving vertices
X	  set(gcf,'windowbuttonmotion','modpoly(''move'');')
X	end
X	set(gcf,'windowbuttonup','modpoly(''up'');')
X      end
X    else				% insert
X      if strcmp(get(h,'linesty'),'-')	% edge?
X	sc_k = find(h==sc_hs);
X	set(sc_hs(sc_k),'linesty','--')
X	set(gcf,'windowbuttonup','modpoly(''up'');')
X      end	
X    end
X  end
X
Xelseif strcmp(w,'move')			% mouse move
X  z = get(gca,'currentpoint');
X  k = sc_k;
X  set(sc_hv(k),'xd',z(1,1),'yd',z(1,2))
X  % Must handle case of infinite predecessor/successor separately.
X  j = rem(k,n)+1;			% successor
X  if isinf(sc_w(j))
X    xd = get(sc_hs(k),'xd');
X    yd = get(sc_hs(k),'yd');
X    phi = atan2(diff(yd),diff(xd));
X    r = sqrt(diff(xd)^2+diff(yd)^2);
X    y = sc_w(k) + [0,r*exp(i*phi)];
X  else
X    y = [z(1,1)+i*z(1,2),sc_w(j)];
X    phi = angle(-diff(y)/diff(sc_w([j,k])));
X    sc_beta(k) = sc_beta(k)-phi/pi;
X    sc_beta(j) = sc_beta(j)+phi/pi;
X  end
X  set(sc_hs(k),'xd',real(y),'yd',imag(y))
X  j = rem(k-2+n,n)+1;			% predecessor
X  if isinf(sc_w(j))
X    xd = get(sc_hs(j),'xd');
X    yd = get(sc_hs(j),'yd');
X    phi = atan2(-diff(yd),-diff(xd));
X    r = sqrt(diff(xd)^2+diff(yd)^2);
X    y = sc_w(k) + [r*exp(i*phi),0];
X  else
X    y = [sc_w(j),z(1,1)+i*z(1,2)];
X    phi = angle(diff(y)/diff(sc_w([j,k])));
X    sc_beta(k) = sc_beta(k)+phi/pi;
X    sc_beta(j) = sc_beta(j)-phi/pi;
X  end
X  % Make change effective
X  set(sc_hs(j),'xd',real(y),'yd',imag(y))
X  drawnow
X  sc_w(k) = z(1,1)+i*z(1,2);
X
Xelseif strcmp(w,'up')			% button up
X  set(sc_hs([sc_k,rem(sc_k-2+n,n)+1]),'linesty','-')
X  set(gcf,'windowbuttonup','')
X  if strcmp(ptr,'circle')
X    % Moved a vertex.  Just clean up.
X    colr = get(gca,'colororder');
X    set(sc_hv(sc_k),'color',colr(1,:))
X    set(gcf,'windowbuttonmotion','')
X  elseif strcmp(ptr,'fleur') 		% Delete...
X    colr = get(gca,'colororder');
X    set(sc_hv(sc_k),'color',colr(1,:))
X    set(gcf,'pointer','circle')
X    idx = rem(sc_k+(-2:1)+n-1,n)+1;	% 2 back, here, and 1 forward
X    infb = isinf(sc_w(idx(2)));
X    infa = isinf(sc_w(idx(4)));
X    if n <= 3 | (infa & infb)
X      return				% do nothing
X    elseif ~infb & ~infa 
X      % Finite neighborhs; easy.
X      v = get(sc_hs(idx(1)),'xdata')+i*get(sc_hs(idx(1)),'ydata');
X      v(3:4) = get(sc_hs(idx(4)),'xdata')+i*get(sc_hs(idx(4)),'ydata');
X      b = scangle(v);
X      sc_beta(idx([2,4])) = b(2:3);
X      v = v(2:3);
X    else
X      % An infinite neighbor
X      axlim = axis;
X      r = sqrt(diff(axlim(1:2))^2+diff(axlim(3:4))^2);
X      x = get(sc_hs(sc_k*infb + idx(2)*infa),'xdata');
X      y = get(sc_hs(sc_k*infb + idx(2)*infa),'ydata');
X      ang = atan2(diff(y),diff(x)) + (pi*infb);
X      j = (idx(2)*infb) + (idx(4)*infa);
X      sc_beta(j) = sc_beta(j) + sc_beta(sc_k);
X      if infb
X	v = sc_w(idx(4)) + [1.1*r*exp(i*ang),0];
X      else
X	v = sc_w(idx(2)) + [0,1.1*r*exp(i*ang)];
X      end
X    end
X      
X    set(sc_hs(idx(2)),...
X	'xdata',real(v),'ydata',imag(v),'linesty','-')
X    delete(sc_hv(sc_k))
X    sc_hv(sc_k) = [];
X    sc_w(sc_k) = [];
X    delete(sc_hs(sc_k))
X    sc_hs(sc_k) = [];
X    sc_beta(sc_k) = [];
X    sc_idx(sc_k) = [];
X   
X  elseif strcmp(ptr,'crosshair') 	% Add...
X    [wn,bn] = scaddvtx(sc_w,sc_beta,sc_k);
X    sc_w = wn(:);
X    sc_beta = bn(:);
X    hold off
X    sc_hs = plotpoly(wn,bn);
X    hold on
X    sc_hv = zeros(n+1,1);
X    for j=find(~isinf(wn))'
X      sc_hv(j) = plot(real(wn(j)),imag(wn(j)),'.','mark',22);
X    end
X    sc_idx = [sc_idx(1:sc_k);NaN;sc_idx(sc_k+1:n)];
X    set(gcf,'pointer','circle')
X    
X  end
X
Xelseif strcmp(w,'delete') 		% toggle delete state
X  if ~strcmp(ptr,'fleur')
X    set(gcf,'pointer','fleur')
X  else
X    set(gcf,'pointer','circle')
X  end
X
Xelseif strcmp(w,'add')			% toggle add state
X  if ~strcmp(ptr,'crosshair')
X    set(gcf,'pointer','crosshair')
X  else
X    set(gcf,'pointer','circle')
X  end
X
Xend
END_OF_FILE
if test 7511 -ne `wc -c <'modpoly.m'`; then
    echo shar: \"'modpoly.m'\" unpacked with wrong size!
fi
chmod +x 'modpoly.m'
# end of 'modpoly.m'
fi
if test -f 'moebius.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'moebius.m'\"
else
echo shar: Extracting \"'moebius.m'\" \(515 characters\)
sed "s/^X//" >'moebius.m' <<'END_OF_FILE'
Xfunction A = moebius(z,w)
X%MOEBIUS Moebius transformation parameters.
X%	A = MOEBIUS(Z,W) computes the coefficients of the Moebius
X%	transformation taking the 3-vector Z to W, so that
X%	
X%	         W = (A(1)*Z + A(2))./(A(3)*Z + A(4)).
X%	
X%	Infinities are not recognized and will not work.
X%	
X%	Written by Toby Driscoll.  Last updated 5/26/95.
X
Xt1 = -diff(z(1:2))*diff(w(2:3));
Xt2 = -diff(z(2:3))*diff(w(1:2));
X
XA(1) = w(1)*t1 - w(3)*t2;
XA(2) = w(3)*z(1)*t2 - w(1)*z(3)*t1;
XA(3) = t1 - t2;
XA(4) = z(1)*t2 - z(3)*t1;
END_OF_FILE
if test 515 -ne `wc -c <'moebius.m'`; then
    echo shar: \"'moebius.m'\" unpacked with wrong size!
fi
chmod +x 'moebius.m'
# end of 'moebius.m'
fi
if test -f 'nebroyuf.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nebroyuf.m'\"
else
echo shar: Extracting \"'nebroyuf.m'\" \(824 characters\)
sed "s/^X//" >'nebroyuf.m' <<'END_OF_FILE'
Xfunction A = nebroyuf(A,xc,xp,fc,fp,sx,eta)
X%
X% A = nebroyuf(A,xc,xf,fc,fp,sx,eta)
X%
X% This function is part of the Nonlinear Equations package, see NESOLVE.M.
X%
X% This updates A, a secant approximation to the jacobian, using
X% BROYDEN'S UNFACTORED SECANT UPDATE.
X%
X% Algorithm A8.3.1:  Part of the modular software system from
X% the appendix of the book "Numerical Methods for Unconstrained
X% Optimization and Nonlinear Equations" by Dennis & Schnabel 1983.
X%
X%
X% Coded in Matlab by Sherkat Masoum M., April 1988.
X% Edited by Richard T. Behrens, June 1988.
X%
X
X%
X% Algorithm step 1.
X%
Xn = length(A);
Xs=xp-xc;
X
X%
X% Algorithm step 2.
X%
Xdenom=norm(sx.*s)^2;
X
X%
X% Algorithm step 3.
X%
Xtempi = (fp - fc - A*s);
Xii = find(abs(tempi) < eta*(abs(fp)+abs(fc)));
Xtempi(ii) = zeros(length(ii),1);
XA = A + (tempi/denom)*(s.*(sx.*sx))';
X
END_OF_FILE
if test 824 -ne `wc -c <'nebroyuf.m'`; then
    echo shar: \"'nebroyuf.m'\" unpacked with wrong size!
fi
chmod +x 'nebroyuf.m'
# end of 'nebroyuf.m'
fi
if test -f 'nechdcmp.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nechdcmp.m'\"
else
echo shar: Extracting \"'nechdcmp.m'\" \(1899 characters\)
sed "s/^X//" >'nechdcmp.m' <<'END_OF_FILE'
Xfunction [L,maxadd] = nechdcmp(H,maxoffl)
X%
X% [L,maxadd] = nechdcmp(H,maxoffl)
X%
X% This function is part of the Nonlinear Equations package, see NESOLVE.M.
X%
X% This is a "Perturbed Cholesky Decomposition".  It finds a lower
X% triangular matrix L such that LL' is a factorization of H+D, where
X% D is a diagonal (non-negative) matrix that is added to H if necessary
X% to make it positive definite (so that the factorization is possible).
X% If H is already positive definite, the ordinary Cholesky decomposition
X% (D=0) is carried out.
X%
X% Algorithm A5.5.2: Part of the modular software system from
X% the appendix of the book "Numerical Methods for Unconstrained
X% Optimization and Nonlinear Equations" by Dennis & Schnabel 1983.
X%
X% Coded in Matlab by Sherkat Masoum M., April 1988.
X% Edited by Richard T. Behrens, June 1988.
X%
X
X%
X% Check input arguments.
X%
X[m,n]=size(H);
Xif (m ~=n)
X  error('Matrix H must be square.')
Xend
X
X%
X% Algorithm step 1.
X%
Xminl=(eps^.25) * maxoffl;
X
X%
X% Algorithm step 2.
X%
Xif (maxoffl == 0.)
X% This is the case when H is known to be positive def.
X  maxoffl=sqrt(max(diag(H)));
X  minl2=(eps^.5) * maxoffl;
Xend
X
X%
X% Algorithm step 3.
X%
Xmaxadd=0.;      % the maximum diagonal element (so far) in D.
X
X%
X% Algorithm step 4.
X%
Xfor j=1:n
X  if (j==1)
X    L(j,j)=H(j,j);
X  else
X    L(j,j)=H(j,j)-L(j,1:j-1)*L(j,1:j-1)';
X  end
X  minljj=0.;
X  for i=j+1:n
X    if (j==1)
X      L(i,j)=H(j,i);
X    else
X      L(i,j)=H(j,i)-L(i,1:j-1)*L(j,1:j-1)';
X    end
X    minljj=max(abs(L(i,j)),minljj);
X  end
X  minljj=max(minljj/maxoffl,minl);
X  if (L(j,j) > minljj^2)
X    % Normal Cholesky iteration
X    L(j,j)=sqrt(L(j,j));
X  else
X    % Augment H(j,j)
X    if (minljj < minl2)
X      minljj=minl2;
X      % Only possible when input maxoffl=0
X    end
X    maxadd=max(maxadd,(minljj^2-L(j,j)));
X    L(j,j)=minljj;
X  end
X  for i=j+1:n
X    L(i,j)=L(i,j)/L(j,j);
X  end
X  %L(j+1:n,j)=L(j+1:n,j)/L(j,j);
Xend
X
END_OF_FILE
if test 1899 -ne `wc -c <'nechdcmp.m'`; then
    echo shar: \"'nechdcmp.m'\" unpacked with wrong size!
fi
chmod +x 'nechdcmp.m'
# end of 'nechdcmp.m'
fi
if test -f 'neconest.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'neconest.m'\"
else
echo shar: Extracting \"'neconest.m'\" \(1305 characters\)
sed "s/^X//" >'neconest.m' <<'END_OF_FILE'
Xfunction est = neconest(M,M2)
X%
X%  This function is part of the Nonlinear Equations package, see NESOLVE.M.
X%
X%  est = neconest(M,M2)
X%  This is an estimate of the l-1 condition number of an upper triangular
X%  matrix.
X%
X%  Algorithm A3.3.1:  Part of the modular software system from the
X%  appendix of the book "Numerical Methods for Unconstrained Optimization
X%  and Nonlinear Equations" by Dennis & Schnabel, 1983.
X%
X%  Coded in MATLAB by Richard T. Behrens, March 1988.
X%
X
X%
X% Allocate variables.
X%
Xn = length(M);
Xp = zeros(n,1);
Xpm = zeros(n,1);
Xx = zeros(n,1);
X
X%
X% Algorithm steps 1 & 2.
X%
Xest = norm( triu(M)-diag(diag(M))+diag(M2) ,1);
X
X%
X% Algorithm step 3.
X%
Xx(1) = 1/M2(1);
X
X%
X% Algorithm step 4.
X%
Xp(2:n) = M(1,2:n) * x(1);
X
X%
X% Algorithm step 5.
X%
Xfor j = 2:n
X   xp = (+1-p(j)) / M2(j);
X   xm = (-1-p(j)) / M2(j);
X   temp  = abs(xp);
X   tempm = abs(xm);
X   for i = (j+1):n
X      pm(i) = p(i) + M(j,i)*xm;
X      tempm = tempm + abs(p(i))/abs(M2(i));
X      p(i) = p(i) + M(j,i) * xp;
X      temp = temp + abs(p(i))/abs(M2(i));
X   end
X   if (temp > tempm)
X      x(j) = xp;
X   else
X      x(j) = xm;
X      p((j+1):n) = pm((j+1):n);
X   end
Xend
X
X%
X% Algorithm steps 6 & 7.
X%
Xest = est / norm(x,1);
X
X%
X% Algorithm step 8.
X%
Xx = nersolv(M,M2,x);
X
X%
X% Algorithm steps 9 & 10.
X%
Xest = est * norm(x,1);
X
END_OF_FILE
if test 1305 -ne `wc -c <'neconest.m'`; then
    echo shar: \"'neconest.m'\" unpacked with wrong size!
fi
chmod +x 'neconest.m'
# end of 'neconest.m'
fi
if test -f 'nedemo.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nedemo.m'\"
else
echo shar: Extracting \"'nedemo.m'\" \(2501 characters\)
sed "s/^X//" >'nedemo.m' <<'END_OF_FILE'
X%
X% NEDEMO demonstrates the Nonlinear Equations sovler NESOLVE.
X%
X% Written by Richard T. Behrens, July 1988.
X%
Xformat compact
Xecho on
Xclc
X%
X% Nonlinear Equations DEMO:  Demonstration of the use of NESOLVE.
X%
X%
X% First, we need a set of simultaneous nonlinear equations whose solution
X% we wish to compute numerically.  Let's sovle the 'helical valley function'
X% defined as:
X%
X%                       0 = 10 * (x3 - 10*theta)
X%                       0 = 10 * (sqrt(x1^2 + x2^2) - 1)
X%                       0 = x3
X%
X%                       where:  theta = (1/(2*pi)) * atan(x2/x1)
X%
X%
X% We need to write a function file to define the above set of equations.
X% Given a 3-vector X, it should evaluate the right-hand sides and return
X% a 3-vector F, which will be zero when a solution is found.  Both X and
X% F need to be column-vectors (i.e. n x 1, NOT 1 x n).
X%
Xpause
Xclc
X%
X% Here is the function file:
X%
X%
Xtype netestf1
Xpause
Xclc
X%
X% Next, we need an ititial guess of the solution we are looking for.
X% Nonlinear equations can have multiple solutions, so the starting point
X% should be chosen as close as possible to the desired solution (it is
X% also possible to have no solutions at all).  Since we have no idea where
X% the solution is, we choose an arbitrary starting point. But note that
X% certain starting points like [0;0;0] are unsuitable in this case, because
X% the 'helical valley function' is undefined there.
X%
X% Here is our starting point:
X%
Xecho off
Xx0 = [10;10;10]
Xpause
Xclc
Xecho on
X% The function file and the starting point are the only required inputs
X% to NESOLVE.  We will specify additional inputs (DETAILS) which will
X% cause the intermediate results to be printed and tell the package
X% that the function is cheap (quick) to evaluate.
Xecho off
Xdetails = zeros(16,1);
Xdetails(1) = 1;
Xdetails(3) = 1
Xdisp(' ')
Xdisp('Press any key to begin finding a solution . . .')
Xpause
X%
Xclc
Xdisp('Please stand by ... loading & compiling the functions may take a while.')
Xflops(0);
Xtime1 = clock;
X[xf,termcode,path] = nesolve('netestf1',x0,details);
Xtime2 = clock;
Xclc
Xf = flops;
Xdisp('The solution is:  ')
Xxf
Xdisp('The number of flops required to find it was:  ')
Xf
Xdisp('The time it took was:  ')
Xetime(time2,time1)
Xdisp(' ')
Xdisp('Did you notice that the third component converged in only')
Xdisp('one iteration?  That is because that equation was linear.')
Xdisp(' ')
Xdisp('Press any key to see a plot of the sequence of iterates . . .')
Xpause
Xclc
Xplot(path)
Xtitle('Convergence Path')
Xpause
X
END_OF_FILE
if test 2501 -ne `wc -c <'nedemo.m'`; then
    echo shar: \"'nedemo.m'\" unpacked with wrong size!
fi
chmod +x 'nedemo.m'
# end of 'nedemo.m'
fi
if test -f 'nefdjac.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nefdjac.m'\"
else
echo shar: Extracting \"'nefdjac.m'\" \(1326 characters\)
sed "s/^X//" >'nefdjac.m' <<'END_OF_FILE'
Xfunction [J,nofun] = nefdjac(fvec,fc,xc,sx,details,nofun,fparam)
X%
X% This function is part of the Nonlinear Equations package, see NESOLVE.M.
X%
X% [J,nofun] = nefdjac(fvec,fc,xc,sx,details,nofun,fparam)
X% This is a "Finite Differance Jacobian Approximation". It
X% calculates a finite differance appproximation to J(xc)
X% (the Jacobin of F(x) at x = xc).
X%
X% Algorithm A5.4.1: Part of the modular software system from
X% the appendix of the book "Numerical Methods for Unconstrained
X% Optimization and Nonlinear Equations" by Dennis & Schnabel 1983.
X%
X% Coded in Matlab by Sherkat Masoum M., March 1988.
X% Edited by Richard T. Behrens, June 1988.
X%
X
X%
X% Algorithm step 1.
X%
Xn=length(fc);
Xsqrteta = sqrt(details(13));
X
X%
X% Algorithm step 2.
X%
Xfor j =1:n
X  stepsizej = sqrteta * max(abs(xc(j)),1/sx(j)) * (sign(xc(j))+(xc(j)==0));
X%   To incorporate a different stepsize rule, change the previous line.
X  tempj = xc(j);
X  xc(j) = xc(j) + stepsizej;
X  stepsizej=xc(j)-tempj;
X%   The previous line reduces finite precision error slightly,
X%   see section 5.4 of the book.
X  if details(15)
X    fj =feval(fvec,xc,fparam);       % Evaluate function w/parameters.
X  else
X    fj =feval(fvec,xc);              % Evaluate function w/o parameters.
X  end
X  nofun = nofun + 1;
X  J(1:n,j) = (fj(1:n) - fc(1:n))/stepsizej;
X  xc(j) = tempj;
Xend
X
END_OF_FILE
if test 1326 -ne `wc -c <'nefdjac.m'`; then
    echo shar: \"'nefdjac.m'\" unpacked with wrong size!
fi
chmod +x 'nefdjac.m'
# end of 'nefdjac.m'
fi
if test -f 'nefn.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nefn.m'\"
else
echo shar: Extracting \"'nefn.m'\" \(675 characters\)
sed "s/^X//" >'nefn.m' <<'END_OF_FILE'
Xfunction [fplus,FVplus,nofun] = nefn(xplus,SF,fvec,nofun,fparam)
X%
X%  [fplus,FVplus] = nefn(xplus,SF,fvec)
X%
X%  This function is part of the Nonlinear Equations package, see NESOLVE.M.
X%
X%  It evaluates the vector function and calculates the sum of squares
X%  for nonlinear equations.
X%
X%  Part of the modular software system from the appendix of the book
X%  "Numerical Methods for Unconstrained Optimization and Nonlinear
X%  Equations" by Dennis & Schnabel, 1983.
X%
X%  Coded in MATLAB by Richard T. Behrens, April 1988.
X%
X
Xif (nargin < 5)
X   FVplus = feval(fvec,xplus);
Xelse
X   FVplus = feval(fvec,xplus,fparam);
Xend
Xfplus = .5 * sum((SF .* FVplus).^2);
Xnofun = nofun + 1;
X
END_OF_FILE
if test 675 -ne `wc -c <'nefn.m'`; then
    echo shar: \"'nefn.m'\" unpacked with wrong size!
fi
chmod +x 'nefn.m'
# end of 'nefn.m'
fi
if test -f 'nehelp.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nehelp.m'\"
else
echo shar: Extracting \"'nehelp.m'\" \(8438 characters\)
sed "s/^X//" >'nehelp.m' <<'END_OF_FILE'
X%
X% Help file for NESOLVE.M and its system of subroutines.
X% To access the help information, execute this file by typing NEHELP
X% from within MATLAB.
X%
Xclc
Xecho on
X%
X%                    NONLINEAR EQUATION SOLVER
X%
X% INTRODUCTION
X%
X% NESOLVE and its system of subordinate functions is a software package
X% designed to solve systems of nonlinear equations.  Everything must be
X% REAL; the algorithms are not designed for complex numbers (complex
X% functions could be handled by breaking each equation and each variable
X% into two parts, real and imaginary, and solving a system twice as large).
X% Newton's method, with a few modifications, is used to find the solution.
X% A line search has been included to ensure global convergence (convergence
X% from poor initial guesses).  The necessary derivatives of the function are
X% computed using finite differences unless the user supplies a function
X% which computes them from analytically obtained equations.
X%
X% Detailed descriptions of the algorithmic modules as well as the theory
X% behind them may be found in "Numerical Methods for Unconstrained
X% Optimization and Nonlinear Equations" by J. E. Dennis, Jr. and
X% R. B. Schnabel, 1983.  The user is refered to that book if such
X% information is needed.
X%
Xpause
Xclc
X%
X% HOW TO USE NESOLVE
X%
X% To use the Nonlinear Equations package, you must first create a function
X% file xxxxxx.M which evaluates the simultaneous nonlinear equations you
X% wish to solve.  You may name this function anything you like, just supply
X% the name (in single quotes) as the FVEC argument to NESOLVE.  To develop
X% the function file, first write each equation as
X%
X%                      'expression' = 0.
X%
X% Next write a function file which evaluates each of these 'expressions' and
X% returns the results as an n-vector F(X), where the input X is also an
X% n-vector.  Note that the number of variables and the number of equations
X% must be the same, but that dummy variables or trivial equations (0=0)
X% could be added to accomplish this.  It is possible to write some functions
X% in such a way that the number of variables, n, is determined at run time
X% by the length of the vector X0, the starting point (see netestf4).
X%
X% A solution is any vector X for which F(X) = 0.
X%
Xpause
Xclc
X%                    NESOLVE INPUT ARGUMENTS
X%
X% REQUIRED INPUTS
X%
X% FVEC, the first input argument, must be the name of the function file
X% defining the system of nonlinear equations (as described on the previous
X% screen).  The name must be placed in single quotation marks or contained
X% in a variable as a string.  The '.m' should not be included.
X%
X% X0, the second input augument, must be a column-vector containing an
X% initial guess of the solution.  The size of X0 must be compatible with
X% the function named in FVEC.
X%
Xpause
Xclc
X%
X% OPTIONAL INPUTS
X%
X% NESOLVE has up to four optional input arguments.  To supply any particular
X% optional argument, all arguments preceding it in the input argument list
X% must also be supplied, but may be empty matrices to hold the positions.
X%
X% DETAILS, the third input argument, is an optional 16-vector whose elements
X% specify various algorithmic options and set various tolerances.  Default
X% values are assumed if DETAILS is not present or if an element is set to
X% zero.  If DETAILS is present, but has less than 16 elements, the remaining
X% elements assume their default values.  The next screen lists the specific
X% function of each element of DETAILS.
X%
Xpause
Xclc
X%
X% DETAILS elements (defaults are in square brackets [ ]):
X%
X% ELEMENT   NAME        DESCRIPTION
X% -------   ---------   ---------------------------------------------------
X%    1      PRINTCODE   [0]=No trace;  1=Trace;  2=Trace & Statistics.
X%    2      GLOBMETH    [1]=Line Search;  2=Hookstep; (3-4 reserved).
X%    3      CHEAPF      [0]=No (Use secant update if function is expensive to
X%                       evaluate);  1=Yes (Always use finite differences).
X%    4      ANALJAC     [0]=No; 1=Yes, there is a jacobian function (.M file)
X%                       (if so, supply its name in input argument JAC).
X%    5      FACTSEC     [0]=No; (1 reserved for future use).
X%    6      ITNLIMIT    Maximum number of iterations allowed [100].
X%    7      DELTA       Initial trust radius for GLOBMETH=2,3 [cauchy step].
X%    8      FVECTOL     How small the scaled norm(F) must get [eps^(1/3)].
X%    9      STEPTOL     Minimum step size [eps^(2/3)].
X%   10      MINTOL      For detecting non-root minima [eps^(2/3)].
X%   11      MAXSTEP     Largest allowed step size [see NEINCK.M].
X%   12      FDIGITS     Number of good digits returned by FVEC [-log10(eps)].
X%   13      ETA         ^* Internal use only ^*
X%   14      SAVEPATH    ^* Internal use only ^*
X%   15      PASSPARM    ^* Internal use only ^*
X%   16      SCALEFLG    [0]=No;  1=Yes, by starting point; 2=Yes, by SCALE.
X%                       (use if units in different variables are mismatched)
Xpause
Xclc
X%
X% OPTIONAL INPUT ARGUMENTS (CONTINUED)
X%
X% FPARAM, the fourth input argument, is an optional input.  NESOLVE does
X% not care what it contains, but if it exists and is nonempty it will be
X% passed on to FVEC (and JAC) as a second argument.  This feature allows
X% the function to contain parameters which are held constant during the
X% solution process but may be changed for the next run.  Any number of
X% parameters of any kind may be passed, but it is up to the user to pack
X% them all into one matrix FPARAM and up to the user-written function FVEC
X% (and JAC) to unpack them and use them appropriately.
X%
X% JAC, the fifth input argument, is optional.  To use a function file
X% which evaluates all the first derivatives of the function, the name of
X% that file must be supplied in JAC and the flag DETAILS(4) must be set
X% to one.  The output of JAC should be the Jacobian matrix of the function
X% specified in FVEC, evaluated at the input argument X.  The i,j element of
X% the Jacobian matrix is defined as the derivative of function element i
X% with respect to variable j.  JAC needs to provide a second output
X% variable indicating the computational cost of one call to JAC in terms
X% of the equivalent number of calls to FN (this is only used for reporting
X% statistics on the number of function evaluations when PRINTCODE=2).
X%
Xpause
Xclc
X%
X% OPTIONAL INPUT ARGUMENTS (CONTINUED)
X%
X% SCALE, the sixth and last input argument, is optional.  If supplied, it
X% should be an (n x 2) matrix whose first column contains a 'typical' X
X% vector and whose second column contains a 'typical' F vector.  SCALE must
X% not contain any zeros.  It is used to improve convergence behavior in
X% in situations where the units of the variables are such that some variables
X% are typically several orders of magnitude larger than others.  The flag
X% controling scaling is DETAILS(16) which must be set to 2 if SCALE is
X% to be used.  If DETAILS(16) is 1, X0 and F(X0) are used for scaling.
X%
Xpause
Xclc
X%
X% OUTPUT ARGUMENTS OF NESOLVE
X%
X% XF is the primary output of NESOLVE.  It contains the final approximation
X% of the solution to the system of nonlinear equations.
X%
X% TERMCODE is an optional output (though highly recommended).  If a second
X% output variable is supplied, It will contain the termination code giving
X% the reason the iteration process was stopped.  The reasons are outlined
X% below.  For additional information the user is refered to the files
X% NESTOP.M, NESTOP0.M and NEINCK.M or to the book referenced on screen one
X% of this help file.
X%
X%    TERMINATION CODES
X%    -2 : Input error in Fdigits (DETAILS(12)).
X%    -1 : Input error in starting point (X0).
X%     1 : Normal termination, XF is probably near a root unless fvectol
X%         (DETAILS(8)) is too large.
X%     2 : Two steps too small ( < steptol), maybe near a root.
X%     3 : Can't find a good step. Maybe near a root or jacobian inacurate.
X%     4 : Iteration limit exceeded. Increase DETAILS(6) or restart from XF.
X%     5 : Five steps too big ( > maxstep), looks like asymtotic behavior.
X%     6 : Stuck at a minimizer which is not a root.  Restart with new X0.
Xpause
Xclc
X%
X% OUTPUT ARGUMENTS (CONTINUED)
X%
X% PATH is an optional output.  If a third output variable is supplied it will
X% contain the sequence of points generated by the iterations.  The i-th row
X% of PATH is the transpose of vector X at iteration (i-1), so you can use
X% the command plot(path) to see how the variables converge.
X%
Xecho off
X
END_OF_FILE
if test 8438 -ne `wc -c <'nehelp.m'`; then
    echo shar: \"'nehelp.m'\" unpacked with wrong size!
fi
chmod +x 'nehelp.m'
# end of 'nehelp.m'
fi
if test -f 'nehook.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nehook.m'\"
else
echo shar: Extracting \"'nehook.m'\" \(4227 characters\)
sed "s/^X//" >'nehook.m' <<'END_OF_FILE'
Xfunction [retcode,xp,fp,Fp,maxtaken,details,trustvars,nofun] = ...
X          nehook(xc,fc,fn,g,L,H,sN,sx,sf,details,itn,trustvars,nofun,fparam)
X%
X% [retcode,xp,fp,Fp,maxtaken,details,trustvars,nofun] = ...
X%    nehook(xc,fc,fn,g,L,H,sN,sx,sf,details,trustvars,nofun,fparam)
X%
X%  This function is part of the Nonlinear Equations package and the
X%  Unconstrained Minimization package, see NESOLVE.M or UMSOLVE.M.
X%
X%  It is a driver for locally constrained optimal ("hook") steps for use
X%  with Newton's Method of solving nonlinear equations.  For function
X%  evaluations, it needs to know whether it is doing Nonlinear Equations
X%  (NE) or Unconstrained Minimization (UM); it distinguishes the two by the
X%  length of DETAILS, which is 16 for NE and 17 for UM.
X%
X%  TRUSTVARS is a vector of variables that, though not used externally,
X%  need to be preserved between calls to NEHOOK.  The elements are
X%  defined as:
X%           1 = mu
X%           2 = deltaprev
X%           3 = phi
X%           4 = phiprime
X
X%
X%  Algorithms A6.4.1 and A6.4.2:   Incorporates both the "hookdriver" and
X%  "hookstep" algorithms.  Part of the modular software system from the
X%  appendix of the book "Numerical Methods for Unconstrained Optimization
X%  and Nonlinear Equations" by Dennis & Schnabel, 1983.
X%
X%  Coded in MATLAB by Richard T. Behrens, August 1990.
X%
X
X%
X% Initialization.
X%
Xn = length(xc);
Xumflag = (length(details) == 17);     % This is how we tell NE from UM.
Xxpprev = zeros(n,1);                  % allocation
Xfpprev = 0;                           % allocation
XFpprev = zeros(n,1);                  % allocation
X%
X% Algorithm steps 1-3.
X%
Xretcode = 4;
Xfirsthook = 1;
Xnewtlen = norm(sx.*sN);
X
X%
X% Algorithm step 4.
X%
Xif ((itn==1)|(details(7)==-1))        % details(7) is delta.
X   trustvars(1) = 0;                  % trustvars(1) is mu.
X   if (details(7)==-1)
X      alpha = g./sx; alpha = alpha'*alpha;
X      beta = L'*(g./(sx.*sx)); beta = beta'*beta;
X      details(7) = (alpha^1.5)/beta;
X      if (details(7) > details(11))   % details(11) is maxstep.
X         details(7) = details(11);
X      end
X   end
Xend
X
X%
X% Algorithm step 5 (incorporating algorithm A6.4.2).
X%
Xwhile (retcode >= 2)             % Calculate and check a new step.
X   hi = 1.5; lo = 0.75;          % Start of A6.4.2.
X   if (newtlen <= hi*details(7))
X      newttaken = 1;
X      s = sN;
X      trustvars(1) = 0;          % trustvars(1) is mu.
X      details(7) = min(details(7),newtlen);
X   else
X      newttaken = 0;
X      if (trustvars(1) > 0)
X         trustvars(1) = trustvars(1) - ...
X            ((trustvars(3) + trustvars(2))/details(7))* ...
X            (((trustvars(2)-details(7))+trustvars(3))/trustvars(4));
X      end
X      trustvars(3) = newtlen - details(7);
X      if firsthook
X         firsthook = 0;
X         tempvec = L\((sx.*sx).*sN);
X         phiprimeinit = -(tempvec'*tempvec)/newtlen;
X      end
X      mulow = -trustvars(3)/phiprimeinit;
X      muup = norm(g./sx)/details(7);
X      done = 0;
X      while (~done)
X         if ((trustvars(1) < mulow)|(trustvars(1)>muup))
X            if (mulow<0), disp('warning, mulow<0'), keyboard, end
X            trustvars(1) = max(sqrt(mulow*muup),muup*1e-3);
X         end
X         [L642,maxadd] = nechdcmp(H+trustvars(1)*diag(sx.*sx),0);
X         s = -L642'\(L642\g);    % L642 is a copy of L local to A6.4.2.
X         steplen = norm(sx.*s);
X         trustvars(3) = steplen - details(7);
X         tempvec = L642\((sx.*sx).*s);
X         trustvars(4) = -(tempvec'*tempvec)/steplen;
X         if (((steplen>=lo*details(7))&(steplen<=hi*details(7))) ...
X                 | (muup-mulow<=0))
X            done = 1;
X         else
X            mulow = max(mulow,trustvars(1)-(trustvars(3)/trustvars(4)));
X            if (trustvars(3)<0), muup = trustvars(1); end
X            trustvars(1) = trustvars(1) - ((steplen/details(7))* ...
X                           (trustvars(3)/trustvars(4)));
X         end
X      end
X   end                             % End of A6.4.2.
X   trustvars(2) = details(7);      % trustvars(2) is deltaprev.
X   [xp,fp,Fp,maxtaken,retcode,xpprev,fpprev,Fpprev,details,nofun] = ...
X      netrust(retcode,xpprev,fpprev,Fpprev,xc,fc,fn,g,L,s,sx,sf,...
X      newttaken,details,1,H,umflag,nofun,fparam);
Xend
X
END_OF_FILE
if test 4227 -ne `wc -c <'nehook.m'`; then
    echo shar: \"'nehook.m'\" unpacked with wrong size!
fi
chmod +x 'nehook.m'
# end of 'nehook.m'
fi
if test -f 'neinck.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'neinck.m'\"
else
echo shar: Extracting \"'neinck.m'\" \(1806 characters\)
sed "s/^X//" >'neinck.m' <<'END_OF_FILE'
Xfunction [dout,Sx,SF,termcode] = neinck(x0,F0,din,scale)
X%
X% [dout,Sx,SF,termcode] = neinck(x0,din,scale)
X%
X%  This function is part of the Nonlinear Equations package, see NESOLVE.M.
X%
X%  It checks the input arguments and sets various tolerances and limits.
X%
X%  Based on the description for NEINCK.  Part of the modular software system
X%  from the appendix of the book "Numerical Methods for Unconstrained
X%  Optimization and Nonlinear Equations" by Dennis & Schnabel, 1983.
X%
X%  Coded in MATLAB by Richard T. Behrens, April 1988.
X%
X
Xtermcode = 0;
Xdout = din;
X
X% Step 1.
X[n,nn] = size(x0);
Xif ((n < 1) | (nn > 1))
X   termcode = -1;
X   return
Xend
X
X% Steps 2 & 3.
X[l,m] = size(scale);
Xif (dout(16) == 2)
X   if ((l==n) & (m==2))
X      Sx = ones(n,1)./abs(scale(:,1));
X      SF = ones(n,1)./abs(scale(:,2));
X   else
X      dout(16) = 1;
X   end
Xend
Xif (dout(16) == 0)
X   Sx = ones(n,1);
X   SF = ones(n,1);
Xend
Xif (dout(16) == 1)
X   if (any(x0==0))
X      x0(find(x0==0)) = ones(sum(x0==0),1);
X   end
X   if (any(F0==0))
X      F0(find(F0==0)) = ones(sum(F0==0),1);
X   end
X   Sx = ones(n,1)./abs(x0);
X   SF = ones(n,1)./abs(F0);
Xend
X
X% Step 4.
Xif (dout(12) <= 0)
X   dout(13) = eps;
Xelse
X   dout(13) = max(eps,10^(-dout(12)));
Xend
Xif (dout(13) > .01)
X   termcode = -2;
X   return
Xend
X
X% Step 5.
Xif (dout(2) <= 0)
X   dout(2) = 1;    % Default to linesearch.
Xend
Xif (((dout(2) == 2) | (dout(2) == 3)) & (dout(7) <= 0))
X   dout(7) = -1;
Xend
X
X% Step 6.
Xif (dout(6) <= 1)
X   dout(6) = 100;  % Default to 100 iteration limit.
Xend
Xif (dout(8) <= 0)
X   dout(8) = eps ^ (1/3);        % fvectol.
Xend
Xif (dout(9) <= 0)
X   dout(9) = eps ^ (2/3);        % steptol.
Xend
Xif (dout(10) <= 0)
X   dout(10) = eps ^ (2/3);       % mintol.
Xend
Xif (dout(11) <= 0)
X   dout(11) = 1000 * max(norm(Sx .* x0),norm(diag(Sx)));   % maxstep.
Xend
X
END_OF_FILE
if test 1806 -ne `wc -c <'neinck.m'`; then
    echo shar: \"'neinck.m'\" unpacked with wrong size!
fi
chmod +x 'neinck.m'
# end of 'neinck.m'
fi
if test -f 'nelnsrch.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nelnsrch.m'\"
else
echo shar: Extracting \"'nelnsrch.m'\" \(3418 characters\)
sed "s/^X//" >'nelnsrch.m' <<'END_OF_FILE'
Xfunction [retcode,xp,fp,Fp,maxtaken,nofun,btrack] = ...
X            nelnsrch(xc,fc,fn,g,p,sx,sf,details,nofun,btrack,fparam)
X%
X%  [retcode,xp,fp,Fp,maxtaken,nofun,btrack] = ...
X%         nelnsrch(xc,fc,fn,g,p,sx,sf,details,nofun,btrack,fparam)
X%
X%  This function is part of the Nonlinear Equations package and the
X%  Unconstrained Minimization package, see NESOLVE.M or UMSOLVE.M.
X%
X%  It is a line search for use with Newton's Method of solving nonlinear
X%  equations.  For function evaluations, it needs to know whether it is
X%  doing Nonlinear Equations (NE) or Unconstrained Minimization (UM); it
X%  distinguishes the two by the length of DETAILS, which is 16 for NE and
X%  17 for UM.
X%
X%  Algorithm A6.3.1:  Part of the modular software system from the
X%  appendix of the book "Numerical Methods for Unconstrained Optimization
X%  and Nonlinear Equations" by Dennis & Schnabel, 1983.
X%
X%  Coded in MATLAB by Richard T. Behrens, March 1988.
X%  Modified slightly for UM usage, January 1989.
X%
X
X%
X% Initialization.
X%
Xn = length(xc);
Xxp = zeros(n,1);
Xfp = 0;
Xumflag = (length(details) == 17);     % This is how we tell NE from UM.
X
X%
X% Algorithm step 1.
X%
Xmaxtaken = 0;
X
X%
X% Algorithm step 2.
X%
Xretcode = 2;
X
X%
X% Algorithm step 3.
X%
Xalpha = 1E-4;
X
X%
X% Algorithm step 4.
X%
Xnewtlen = norm(sx .* p);
X
X%
X% Algorithm step 5.
X%
Xif (newtlen > details(11))
X   p = p * (details(11) / newtlen);
X   newtlen = details(11);
Xend
X
X%
X% Algorithm step 6.
X%
Xinitslope = g'*p;
X
X%
X% Algorithm step 7.
X%
Xrellength = max(abs(p)./max(abs(xc),(ones(n,1)./sx)));
X
X%
X% Algorithm step 8.
X%
Xminlambda = details(9)/rellength;
X
X%
X% Algorithm step 9.
X%
Xlambda = 1;
X
X%
X% Algorithm step 10.
X%
Xbt = 0;
Xwhile (retcode >= 2)
X   xp = xc + lambda*p;                      % step 10.1
X   if umflag                                % step 10.2
X      if details(15)
X         fp = feval(fn,xp,fparam);
X      else
X         fp = feval(fn,xp);
X      end
X      nofun = nofun + 1;
X   else
X      if details(15)
X         [fp,Fp,nofun] = nefn(xp,sf,fn,nofun,fparam);
X      else
X         [fp,Fp,nofun] = nefn(xp,sf,fn,nofun);
X      end
X   end
X   if (fp <= fc + alpha*lambda*initslope)   % step 10.3a
X      retcode = 0;
X      maxtaken = ((lambda == 1) & (newtlen > 0.99*details(11)));
X   elseif (lambda < minlambda)              % step 10.3b
X      retcode = 1;
X      xp = xc;
X   else                                     % step 10.3c
X      if (lambda == 1)
X         if (details(1) > 0), disp('Quadratic Backtrack.'), end
X         bt = bt + 1;
X         lambdatemp = -initslope / (2*(fp-fc-initslope));
X      else
X         if (details(1) > 0), disp('Cubic Backtrack.'), end
X         bt = bt + 1;
X         a = (1/(lambda - lambdaprev)) * [1/lambda^2  (-1/lambdaprev^2); ...
X               (-lambdaprev/(lambda^2))  lambda/(lambdaprev^2)] * ...
X               [(fp-fc-lambda*initslope); (fpprev-fc-lambdaprev*initslope)];
X         disc = a(2)^2 - 3*a(1)*initslope;
X         if (a(1)==0)
X            lambdatemp = -initslope/(2*a(2));
X         else
X            lambdatemp = (-a(2)+sqrt(disc))/(3*a(1));
X         end
X         if (lambdatemp > 0.5*lambda)
X            lambdatemp = 0.5*lambda;
X         end
X      end
X      lambdaprev = lambda;
X      fpprev = fp;
X      if (lambdatemp <= 0.1*lambda)
X         lambda = 0.1*lambda;
X      else
X         lambda = lambdatemp;
X      end
X   end
Xend
Xif (bt < length(btrack))
X   btrack(bt+1) = btrack(bt+1) + 1;
Xelse
X   btrack(bt+1) = 1;
Xend
X
END_OF_FILE
if test 3418 -ne `wc -c <'nelnsrch.m'`; then
    echo shar: \"'nelnsrch.m'\" unpacked with wrong size!
fi
chmod +x 'nelnsrch.m'
# end of 'nelnsrch.m'
fi
if test -f 'nemodel.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nemodel.m'\"
else
echo shar: Extracting \"'nemodel.m'\" \(1740 characters\)
sed "s/^X//" >'nemodel.m' <<'END_OF_FILE'
Xfunction [m,h,sn] = nemodel(fc,J,g,sf,sx,globmeth)
X%
X% [m,h,sn] = nemodel(fc,J,g,sf,sx,globmeth)
X%
X% This function is part of the Nonlinear Equations package, see NESOLVE.M.
X%
X% It forms the affine model for use in solving nonlinear equations.
X%
X% Algorithm A6.5.1: Part of the modular software system from
X% the appendix of the book "Numerical Methods for Unconstrained
X% Optimization and Nonlinear Equations" by Dennis & Schnabel 1983.
X%
X% Coded in Matlab by Sherkat Masoum M., March 1988.
X% Edited by Richard T. Behrens, June 1988.
X%
X%
X% Algorithm step 1.
X%
Xn = length(J);
Xm = diag(sf)*J;
X
X%
X% Algorithm step 2.
X%
X[m,m1,m2,sing]=neqrdcmp(m);
X
X%
X% Algorithm step 3.
X%
Xif (sing == 0)
X  for j=2:n
X    m(1:(j-1),j)=m(1:(j-1),j)/sx(j);
X  end
X  m2 = m2./sx;
X  est = neconest(m,m2);
Xelse
X  est=0.;
Xend
X
X%
X% Algorithm step 4.
X%
Xif (sing ==1) | (est > 1./eps)
X  h = J'*diag(sf);
X  h = h*h';
X  % calculate hnorm=norm(invDxHinvDx)
X  tem = abs(h(1,:)) * (ones(n,1)./sx);
X  hnorm=(1./sx(1))*tem;
X  for i=2:n
X    tem1=sum(abs(h(:,i))./sx);
X    tem2=sum(abs(h(i,:))./(sx.'));
X    temp=(1./sx(i))/(tem1+tem2);
X    hnorm=max(temp,hnorm);
X  end
X  h = h + sqrt(n*eps) * hnorm * (diag(sx)^2);
X  % caculate sn=inv(H)*g, and keep m (the cholesky factor) for later use.
X  [m,maxadd] = nechdcmp(h,0);
X  sn = -m'\(m\g);
Xelse
X  % Calculate normal Newton step
X  for j=2:n
X    m(1:(j-1),j)=m(1:(j-1),j)*sx(j);
X  end
X  m2 = m2.*sx;
X  sn = -sf.*fc;
X  sn = neqrsolv(m,m1,m2,sn);
X  if (globmeth ==2) | (globmeth ==3)
X    % the cholesky factor (for later use) is the same as R' from QR.
X    m = triu(m) + triu(m)';
X    m = m - diag(diag(m)) + diag(m2);
X  end
X  if (globmeth == 2)
X    L = tril(m);
X    h = L*L';          % This is J'*J, an approximation of H.
X  end
Xend
X
END_OF_FILE
if test 1740 -ne `wc -c <'nemodel.m'`; then
    echo shar: \"'nemodel.m'\" unpacked with wrong size!
fi
chmod +x 'nemodel.m'
# end of 'nemodel.m'
fi
if test -f 'neqrdcmp.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'neqrdcmp.m'\"
else
echo shar: Extracting \"'neqrdcmp.m'\" \(1218 characters\)
sed "s/^X//" >'neqrdcmp.m' <<'END_OF_FILE'
Xfunction [M,M1,M2,sing] = neqrdcmp(M)
X%
X%  [M,M1,M2,sing] = neqrdcmp(M)
X%
X%  This function is part of the Nonlinear Equations package, see NESOLVE.M.
X%
X%  It is a QR decomposition function.  It differs from the one built
X%  into MATLAB in that the result is encoded as rotation angles.  Also,
X%  it is designed for square matrices only.
X%
X%  Algorithm A3.2.1:  Part of the modular software system from the
X%  appendix of the book "Numerical Methods for Unconstrained Optimization
X%  and Nonlinear Equations" by Dennis & Schnabel, 1983.
X%
X%  Coded in MATLAB by Richard T. Behrens, March 1988.
X%
X
X%
X% Check size of input argument and allocate variables.
X%
Xn = length(M);
XM1 = zeros(n,1);
XM2 = zeros(n,1);
X
X%
X% Algorithm step 1.
X%
Xsing = 0;
X
X%
X% Algorithm step 2.
X%
Xfor k = 1:(n-1)
X   eta = max(M(k:n,k));
X   if (eta == 0)
X      M1(k) = 0;
X      M2(k) = 0;
X      sing = 1;
X   else
X      M(k:n,k) = M(k:n,k) / eta;
X      sigma = (sign(M(k,k))+(M(k,k)==0)) * norm(M(k:n,k));
X      M(k,k) = M(k,k) + sigma;
X      M1(k) = sigma * M(k,k);
X      M2(k) = -eta * sigma;
X      tau = (M(k:n,k)' * M(k:n,(k+1):n)) / M1(k);
X      M(k:n,(k+1):n) = M(k:n,(k+1):n) - M(k:n,k) * tau;
X   end
Xend
X
X%
X% Algorithm step 3.
X%
XM2(n) = M(n,n);
X
END_OF_FILE
if test 1218 -ne `wc -c <'neqrdcmp.m'`; then
    echo shar: \"'neqrdcmp.m'\" unpacked with wrong size!
fi
chmod +x 'neqrdcmp.m'
# end of 'neqrdcmp.m'
fi
if test -f 'neqrsolv.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'neqrsolv.m'\"
else
echo shar: Extracting \"'neqrsolv.m'\" \(652 characters\)
sed "s/^X//" >'neqrsolv.m' <<'END_OF_FILE'
Xfunction b = neqrsolv(M,M1,M2,b)
X%
X%  b = neqrsolv(M,M1,M2,b)
X%
X%  This function is part of the Nonlinear Equations package, see NESOLVE.M.
X%
X%  It is a linear equation solve function using the QR decomposition.
X%
X%  Algorithm A3.2.2:  Part of the modular software system from the
X%  appendix of the book "Numerical Methods for Unconstrained Optimization
X%  and Nonlinear Equations" by Dennis & Schnabel, 1983.
X%
X%  Coded in MATLAB by Richard T. Behrens, March 1988.
X%
X
X%
X% Algorithm step 1.
X%
Xn = length(M);
Xfor j = 1:(n-1)
X   tau = (M(j:n,j)' * b(j:n)) / M1(j);
X   b(j:n) = b(j:n) - tau * M(j:n,j);
Xend
X
X%
X% Algorithm step 2.
X%
Xb = nersolv(M,M2,b);
X
END_OF_FILE
if test 652 -ne `wc -c <'neqrsolv.m'`; then
    echo shar: \"'neqrsolv.m'\" unpacked with wrong size!
fi
chmod +x 'neqrsolv.m'
# end of 'neqrsolv.m'
fi
if test -f 'nersolv.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nersolv.m'\"
else
echo shar: Extracting \"'nersolv.m'\" \(628 characters\)
sed "s/^X//" >'nersolv.m' <<'END_OF_FILE'
Xfunction b = nersolv(M,M2,b)
X%
X%  b = nersolv(M,M2,b)
X%
X%  This function is part of the Nonlinear Equations package, see NESOLVE.M.
X%
X%  It is a linear equation solve function for upper triangular systems.
X%
X%  Algorithm A3.2.2a:  Part of the modular software system from the
X%  appendix of the book "Numerical Methods for Unconstrained Optimization
X%  and Nonlinear Equations" by Dennis & Schnabel, 1983.
X%
X%  Coded in MATLAB by Richard T. Behrens, March 1988.
X%
X
X%
X% Algorithm step 1.
X%
Xn = length(M);
Xb(n) = b(n) / M2(n);
X
X%
X% Algorithm step 2.
X%
Xfor i = (n-1):-1:1
X   b(i) = (b(i) - M(i,(i+1):n) * b((i+1):n)) / M2(i);
Xend
X
END_OF_FILE
if test 628 -ne `wc -c <'nersolv.m'`; then
    echo shar: \"'nersolv.m'\" unpacked with wrong size!
fi
chmod +x 'nersolv.m'
# end of 'nersolv.m'
fi
if test -f 'nesolve.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nesolve.m'\"
else
echo shar: Extracting \"'nesolve.m'\" \(8195 characters\)
sed "s/^X//" >'nesolve.m' <<'END_OF_FILE'
Xfunction [xf,termcode,path] = fsolve(fvec,x0,details,fparam,jac,scale)
X%FSOLVE Solution to a system of nonlinear equations.
X%       X = FSOLVE('f',X0) starts at X0 and produces a new vector X which
X%       solves for f(x) = 0.  'f' is a string containing the name of the
X%       function to be solved, normally an M-file.  For example, to
X%       find the x, y, and z that solve the simultaneous equations
X%
X%            sin(x) + y^2 + log(z) - 7 = 0
X%            3*x + 2^y - z^3 + 1 = 0
X%            x + y + z - 5 = 0
X%
X%       Use X = FSOLVE('xyz',[1 1 1]') where XYZ is the M-file
X%
X%         function q = xyz(p)
X%         x = p(1); y = p(2); z = p(3);
X%         q = zeros(3,1);
X%         q(1) = sin(x) + y^2 + log(z) - 7;
X%         q(2) = 3*x + 2^y - z^3 + 1;
X%         q(3) = x + y + z - 5;
X%
X%       FSOLVE can take many other optional parameters; see the M-file
X%       for more information.
X
X%       Copyright (c) 1988 by the MathWorks, Inc.
X%       Coded in MATLAB by Richard T. Behrens, April 1988.
X%       Revised 11/27/88 JNL
X%       Hookstep option added 8/21/90 RTB.
X
X%  [XF,TERMCODE,PATH] = FSOLVE(FVEC,X0,DETAILS,FPARAM,JAC,SCALE)
X%
X%  This function is for solving systems of nonlinear equations.  For more
X%  information see a users guide.
X%
X%  ^* INPUTS ^*
X%  FVEC     - The name of a function which maps n-vectors into n-vectors.
X%  X0       - An initial guess of a solution (starting point for iterations).
X%  DETAILS  - (optional) A vector whose elements select various algorithmic
X%             options and specify various tolerances.
X%  FPARAM   - (optional) A set of parameters (constants) which, if nonempty,
X%             is passed on as a second argument to FVEC and JAC.
X%  JAC      - (optional) The name of a function which implements the jacobian
X%             matrix (if available) of the function named in FVEC.
X%  SCALE    - (optional) 'Typical' values of X (1st column) and F (2nd col.)
X%             for scaling purposes (no zeros in SCALE, please).
X% ^* OUTPUTS ^*
X%  XF       - The final approximation of the solution.
X%  TERMCODE - (optional) Indicates the stopping reason (equals 1 for normal
X%             termination).
X%  PATH     - (optional) Returns the sequence of iterates.
X%
X%  --> NOTE:  All vectors must be column-vectors.
X
X%  Based on Algorithm D6.1.3:  Part of the modular software system from the
X%  appendix of the book "Numerical Methods for Unconstrained Optimization and
X%  Nonlinear Equations" by Dennis & Schnabel, 1983.  Please refer to that book
X%  if you need more detailed information about the algorithms.
X
X% Initialization.
X%
Xif (nargin < 3)
X   details = zeros(16,1);
Xend
Xi = length(details);
Xif (i < 16)
X   details((i+1):16,1) = zeros(16-i,1);  % For unspecified details.
Xend
Xif (nargin < 4)
X   details(15) = 0;                      % No parameters to pass.
Xelseif isempty(fparam)
X   details(15) = 0;
Xelse
X   details(15) = 1;
Xend
Xif (details(15) == 0)
X   fparam = [];
Xend
Xif (nargin < 5)
X   details(4) = 0;                       % No analytic jacobian.
Xelseif isempty(jac)
X   details(4) = 0;
Xend
Xif (details(4) == 0)
X   jac = '';
Xend
Xif (nargin < 6)
X   scale = [];                           % No scaling given.
X   if (details(16) == 2)
X      details(16) = 1;
X   end
Xend
Xif (nargout < 3)
X   details(14) = 0;                      % No path output.
Xelse
X   details(14) = 1;
Xend
Xif details(14), path = x0.'; end
Xif (details(1) == 2), btrack = []; end
Xnofun = 0;              % Number of function evaluations.
Xtrustvars = zeros(4,1); % variables for trust region methods.
X
X
X%
X% Algorithm step 2.
X%
Xif (details(16) > 0)     % Might need F(x0) for scaling.
X   if details(15)
X      [fc,FVplus,nofun] = nefn(x0,ones(length(x0),1),fvec,nofun,fparam);
X   else
X      [fc,FVplus,nofun] = nefn(x0,ones(length(x0),1),fvec,nofun);
X   end
Xelse
X   FVplus = zeros(length(x0),1);
Xend
X[details,Sx,SF,termcode] = neinck(x0,FVplus,details,scale);
X
X%
X% Algorithm step 3.
X%
Xif (termcode < 0)
X   xf = x0;
X   if details(14), path = [path;xf.']; end
X   return
Xend
X
X%
X% Algorithm step 4.
X%
Xitncount = 0;
X
X%
X% Algorithm step 5.
X%
Xif details(15)
X   [fc,FVplus,nofun] = nefn(x0,SF,fvec,nofun,fparam);
Xelse
X   [fc,FVplus,nofun] = nefn(x0,SF,fvec,nofun);
Xend
X
X%
X% Algorithm step 6.
X%
X%[termcode,consecmax] = nestop0(x0,FVplus,SF,details(8));
Xconsecmax = 0;
Xif (max(SF .* abs(FVplus)) <= 1E-2 * details(8))
X   termcode = 1;
Xelse
X   termcode = 0;
Xend
X
X%
X% Algorithm step 7.
X%
Xif (termcode > 0)
X   xf = x0;
X   if (details(14)), path = [path;xf.']; end
Xelse
X   if details(4)
X      if details(15)
X         [Jc,addfun] = feval(jac,x0,fparam);
X      else
X         [Jc,addfun] = feval(jac,x0);
X      end
X      nofun = nofun + addfun;
X   else
X      [Jc,nofun] = nefdjac(fvec,FVplus,x0,Sx,details,nofun,fparam);
X   end
X   gc = Jc' * (FVplus .* (SF.^2));
X   FVc = FVplus;
Xend
X
X%
X% Algorithm step 8.
X%
Xxc = x0;
X
X%
X% Algorithm step 9.
X%
Xrestart = 1;
Xnorest = 0;
X
X%
X% Algorithm step 10 (iteration).
X%
X%%if (details(1) > 0), clc, end
Xif details(1)
X  disp('ITN    F-COUNT       NORM(F)')
Xend
X  
Xwhile (termcode == 0)
X   if details(1)
X      disp(sprintf('%3d %8d %15g',itncount,nofun,norm(FVc)))
X   end
X   itncount = itncount + 1;
X   if (details(4) | details(3) | (1-details(5)))
X      [M,Hc,sN] = nemodel(FVc,Jc,gc,SF,Sx,details(2));
X   else
X      error('Factored model not implemented.')
X%     [] = nemodfac();
X   end
X   if (details(2) == 1)
X      [retcode,xplus,fplus,FVplus,maxtaken,nofun,btrack] = ...
X      nelnsrch(xc,fc,fvec,gc,sN,Sx,SF,details,nofun,btrack,fparam);
X   elseif (details(2) == 2)
X      [retcode,xplus,fplus,FVplus,maxtaken,details,trustvars,nofun] = ...
X         nehook(xc,fc,fvec,gc,tril(M),Hc,sN,Sx,SF,details,itncount,trustvars,...
X         nofun,fparam);
X   else
X      error('Dogleg not implemented.')
X%     [] = nedogdrv();
X   end
X   if ((retcode ~= 1) | (restart) | (details(4)) | (details(3)))
X      if (details(4))
X         if details(15)
X            [Jc,addfun] = feval(jac,xplus,fparam);
X         else
X            [Jc,addfun] = feval(jac,xplus);
X         end
X         nofun = nofun + addfun;
X      elseif (details(3))
X         [Jc,nofun] = nefdjac(fvec,FVplus,xplus,Sx,details,nofun,fparam);
X      elseif (details(5))
X         error('Factored secant method not implemented.')
X%        [] = nebroyf();
X      else
X         Jc = nebroyuf(Jc,xc,xplus,FVc,FVplus,Sx,details(13));  % Broyden update
X      end
X      if (details(5))
X         error('Gradient calculation for factored method not implemented.')
X         % Calculate gc using QR factorization (see book).
X      else
X         gc = Jc' * (FVplus .* (SF.^2));
X      end
X      [consecmax,termcode] = nestop(xc,xplus,FVplus,fplus,gc,Sx,SF,retcode,...
X                                details,itncount,maxtaken,consecmax);
X   end
X   if (((retcode == 1) | (termcode == 2)) & (1-restart) & ...
X                                     (1-details(4)) & (1-details(3)))
X      [Jc,nofun] = nefdjac(fvec,FVc,xc,Sx,details,nofun,fparam);
X      gc = Jc' * (FVc .* (SF.^2));
X      if ((details(2) == 2) | (details(2) == 3))
X         details(7) = -1;
X      end
X      restart = 1;
X      norest = norest + 1;
X      if termcode==2, termcode = 0; end %***added by TAD
X   else
X      if (termcode > 0)
X         xf = xplus;
X         if (details(14)), path = [path;xf.']; end
X      else
X         restart = 0;
X         if (details(14)), path = [path;xplus.']; end
X      end
X      xc = xplus;
X      fc = fplus;
X      FVc = FVplus;
X%%      if (details(1) > 0)
X%%         clc
X%%         disp('The current iteration is: ')
X%%         xc
X%%      end
X   end
Xend
X
Xif (details(1) == 2)
X   %%disp('Press CR to see statistics . . .')
X   %%fprintf([' ',7])
X   %%pause
X
X   %%clc
X   %%format compact
X   disp(' ')
X   %%disp('Function: ')
X   %%fvec
X   %%disp('Starting point: ')
X   %%x0.'
X   %%disp('Termination condition: ')
X   %%termcode
X   disp(sprintf('Number of iterations: %d',itncount))
X   disp(sprintf('Number of function evaluations: %d',nofun))
X   disp(sprintf('Final norm(F(x)): %.6g',norm(FVc)))
X   if ((1-details(3)) & (1-details(4)))
X      disp(sprintf('Number of restarts for secant methods: %d',norest))
X   end
X%%   if (details(2) == 1)
X%%      disp('Backtrack information: ')
X%%      btrack
X%%   end
X%%   pause
Xend
X
X
X
X
X
X
X
END_OF_FILE
if test 8195 -ne `wc -c <'nesolve.m'`; then
    echo shar: \"'nesolve.m'\" unpacked with wrong size!
fi
chmod +x 'nesolve.m'
# end of 'nesolve.m'
fi
if test -f 'nestop.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nestop.m'\"
else
echo shar: Extracting \"'nestop.m'\" \(1348 characters\)
sed "s/^X//" >'nestop.m' <<'END_OF_FILE'
Xfunction [consecmax,termcode] = nestop(xc,xp,F,Fnorm,g,sx,sf,retcode,...
X                                details,itncount,maxtaken,consecmax)
X%
X%  [consecmax,termcode] = nestop(xc,xp,F,Fnorm,g,sx,sf,retcode,...
X%                                details,itncount,maxtaken,consecmax)
X%
X%  This function is part of the Nonlinear Equations package, see NESOLVE.M.
X%
X%  It decides whether or not to stop iterating when solving a set of
X%  nonlinear equations.
X%
X%  Algorithm A7.2.3:  Part of the modular software system from the
X%  appendix of the book "Numerical Methods for Unconstrained Optimization
X%  and Nonlinear Equations" by Dennis & Schnabel, 1983.
X%
X%  Coded in MATLAB by Richard T. Behrens, March 1988.
X%
X
X%
X% Algorithm step 1.
X%
Xn = length(xc);
Xtermcode = 0;
X
X%
X% Algorithm step 2.
X%
Xif (retcode == 1)
X   termcode = 3;
Xelseif (max(sf .* abs(F)) <= details(8))
X   termcode = 1;
Xelseif (max( abs(xp - xc) ./ max(abs(xp),ones(n,1)./sx)) <= details(9))
X   termcode = 2;
Xelseif (itncount >= details(6))
X   termcode = 4;
Xelseif (maxtaken)
X   consecmax = consecmax + 1;
X   if (consecmax == 5)
X      termcode = 5;
X   end
Xelse
X   consecmax = 0;
X   if (details(4) | details(3))
X      if (max(abs(g).*max(abs(xp),ones(n,1)./sx)/max(Fnorm,(n/2))) ...
X                                         <= details(10))
X         termcode = 6;
X      end
X   end
Xend
X
END_OF_FILE
if test 1348 -ne `wc -c <'nestop.m'`; then
    echo shar: \"'nestop.m'\" unpacked with wrong size!
fi
chmod +x 'nestop.m'
# end of 'nestop.m'
fi
if test -f 'netestf1.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netestf1.m'\"
else
echo shar: Extracting \"'netestf1.m'\" \(519 characters\)
sed "s/^X//" >'netestf1.m' <<'END_OF_FILE'
Xfunction f=netestf1(x)
X%
X% f = netestf1(x)
X%
X% Helical Valley Function.  This function is primarily for testing
X% the nonlinear equations package (see NESOLVE), and is used by NEDEMO.
X% The function is taken from Appendix B of "Numerical Methods for
X% Unconstrained Optimization and Nonlinear Equations" by Dennis and Schnabel.
X%
X
X% n = 3;
Xf = zeros(3,1);
Xtheta = (1/(2*pi)) * atan(x(2)/x(1));
Xif (x(1) < 0), theta = theta + .5; end
Xf(1) = 10 * (x(3) - 10*theta);
Xf(2) = 10 * (sqrt(x(1)^2 + x(2)^2) - 1);
Xf(3) = x(3);
X
END_OF_FILE
if test 519 -ne `wc -c <'netestf1.m'`; then
    echo shar: \"'netestf1.m'\" unpacked with wrong size!
fi
chmod +x 'netestf1.m'
# end of 'netestf1.m'
fi
if test -f 'netrust.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netrust.m'\"
else
echo shar: Extracting \"'netrust.m'\" \(3387 characters\)
sed "s/^X//" >'netrust.m' <<'END_OF_FILE'
Xfunction [xp,fp,Fp,maxtaken,retcode,xpprev,fpprev,Fpprev,details,nofun] = ...
X   netrust(retcode,xpprev,fpprev,Fpprev,xc,fc,fn,g,L,s,sx,sf,...
X   newttaken,details,steptype,H,umflag,nofun,fparam)
X%
X% function [xp,fp,Fp,maxtaken,retcode,xpprev,fpprev,Fpprev,details,nofun] = ...
X%          netrust(retcode,xpprev,fpprev,Fpprev,xc,fc,fn,g,L,s,sx,sf,...
X%          newttaken,details,steptype,H,umflag,nofun,fparam)
X%
X%  This function is part of the Nonlinear Equations package and the
X%  Unconstrained Minimization package, see NESOLVE.M or UMSOLVE.M.
X%
X%  It decides whether or not the proposed step is acceptable, and adjusts
X%  the trust radius accordingly.
X%
X
X%
X%  Algorithm A6.4.5:  Part of the modular software system from the
X%  appendix of the book "Numerical Methods for Unconstrained Optimization
X%  and Nonlinear Equations" by Dennis & Schnabel, 1983.
X%
X%  Coded in MATLAB by Richard T. Behrens, August 1990.
X%
X
X%
X% Initialization.
X%
Xn = length(xc);
Xxp = zeros(n,1);
Xfp = 0;
X
X%
X% Algorithm steps 1-4.
X%
Xmaxtaken = 0;
Xalpha = 1e-4;
Xsteplen = norm(sx.*s);
Xxp = xc + s;
X
X%
X% Algorithm step 5.
X%
Xif umflag
X   if details(15)
X      fp = feval(fn,xp,fparam);
X   else
X      fp = feval(fn,xp);
X   end
X   nofun = nofun + 1;
Xelse
X   if details(15)
X      [fp,Fp,nofun] = nefn(xp,sf,fn,nofun,fparam);
X   else
X      [fp,Fp,nofun] = nefn(xp,sf,fn,nofun);
X   end
Xend
X
X%
X% Algorithm steps 6-8.
X%
Xdeltaf = fp - fc;
Xinitslope = g'*s;
Xif (retcode~=3), fpprev = 0; end
X
X%
X% Algorithm step 9.
X%
Xif ((retcode==3)&((fp>=fpprev)|(deltaf>alpha*initslope)))   % step 9a.
X   retcode = 0;
X   xp = xpprev;
X   fp = fpprev;
X   Fp = Fpprev;
X   details(7) = details(7)/2;
X   if (details(1)>0), disp('Decreasing trust radius.'), end
Xelse
X   if (deltaf >= alpha*initslope)         % step 9b.
X      rellength = max(s./max([abs(xp)'; 1.0./sx'])');
X      if (rellength<details(9))       % details(9) is steptol
X         retcode = 1;
X         xp = xc;
X      else
X         retcode = 2;
X         deltatemp = -initslope*steplen/(2*(deltaf-initslope));
X         if (deltatemp<.1*details(7))
X            details(7) = .1*details(7);
X         elseif (deltatemp>.5*details(7))
X            details(7) = .5*details(7);
X         else
X            details(7) = deltatemp;
X         end
X         if (details(1)>0), disp('Decreasing trust radius.'), end
X      end
X   else                                   % step 9c.
X      deltafpred = initslope;
X      if (steptype==1)
X         deltafpred = deltafpred + .5*(s'*H*s);
X      else
X         ttemp = L'*s;
X         deltafpred = deltafpred + .5*(ttemp'*ttemp);
X      end
X      if ((retcode~=2)&((abs(deltafpred-deltaf)<=.1*abs(deltaf)) | ...
X           (deltaf<=initslope)) & (~newttaken) & (details(7)<=.99*details(11)))
X         retcode = 3;
X         xpprev = xp;
X         fpprev = fp;
X         Fpprev = Fp;
X         details(7) = min(2*details(7),details(11));  % details(11) is maxstep
X         if (details(1)>0), disp('Increasing trust radius.'), end
X      else
X         retcode = 0;
X         if (steplen > .99*details(11)), maxtaken=1; end
X         if (deltaf>=.1*deltafpred)
X            details(7) = details(7)/2;
X            if (details(1)>0), disp('Decreasing trust radius.'), end
X         elseif (deltaf<=.75*deltafpred)
X            details(7) = min(2*details(7),details(11));
X            if (details(1)>0), disp('Increasing trust radius.'), end
X         end
X      end
X   end
Xend
X
END_OF_FILE
if test 3387 -ne `wc -c <'netrust.m'`; then
    echo shar: \"'netrust.m'\" unpacked with wrong size!
fi
chmod +x 'netrust.m'
# end of 'netrust.m'
fi
if test -f 'plotpoly.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'plotpoly.m'\"
else
echo shar: Extracting \"'plotpoly.m'\" \(2618 characters\)
sed "s/^X//" >'plotpoly.m' <<'END_OF_FILE'
Xfunction edgehandles = plotpoly(w,beta)
X%PLOTPOLY Plot a (generalized) polygon.
X%      PLOTPOLY(W,BETA) plots the polygon whose vertices are in vector W
X%      and whose turning angles are in BETA.  Vertices at infinity are
X%      permitted, but there must be at least two consecutive finite
X%      vertices somewhere in W.
X%
X%	H = PLOTPOLY(W,BETA) returns a vector of handles to the polygon
X%	sides.
X%	
X%	See also DRAWPOLY, MODPOLY.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xif nargin < 3
X  thick = 3;
Xend
Xturn_off_hold = ~ishold;
X%set(gcf,'defaultlinelinewidth',2.5*get(gcf,'defaultlinelinewidth'));
Xlw = 2*get(gcf,'defaultlinelinewidth');
Xn = length(w);
X%w = w+i*1e-12;
Xwf = w(~isinf(w));
Xautoscale = strcmp(get(gca,'xlimmode'),'auto') & ...
X    strcmp(get(gca,'ylimmode'),'auto');
Xautoscale = autoscale | turn_off_hold;
Xif autoscale
X  lim = [min(real(wf)),max(real(wf)),min(imag(wf)),max(imag(wf))];
X  maxdiff = max(diff(lim(1:2)),diff(lim(3:4)));
Xelse
X  lim = axis;
Xend
Xfirst = 1;
Xif ~any(isinf(w))
X  for j = 1:n-1
X    edgeh(j) = plot(real(w(j:j+1)),imag(w(j:j+1)),'-','linewid',lw);
X    if j==1, hold on; end;
X  end
X  edgeh(n) = plot(real(w([n,1])), imag(w([n,1])),'-','linewid',lw);
X  if autoscale
X    lim(1:2) = mean(lim(1:2)) + 0.55*maxdiff*[-1,1];
X    lim(3:4) = mean(lim(3:4)) + 0.55*maxdiff*[-1,1];
X  end
X  axis(lim)
Xelse
X  if any(isinf(w(1:2)))
X    first = min(find(~isinf(w) & ~isinf(w([2:n,1]))));
X    if isempty(first), 
X      error('There must be two consecutive finite vertices.')
X    end
X    w = w([first:n,1:first-1]);
X    beta = beta([first:n,1:first-1]);
X  end
X  edgeh(1) = plot(real(w(1:2)),imag(w(1:2)),'-','linewid',lw);
X  ang = angle(w(2)-w(1));
X  if autoscale
X    lim(1:2) = mean(lim(1:2)) + 0.65*maxdiff*[-1,1];
X    lim(3:4) = mean(lim(3:4)) + 0.65*maxdiff*[-1,1];
X  end
X  R = max(lim(2)-lim(1),lim(4)-lim(3));
X  axis(lim)
X  hold on
X  j = 2;
X  while j < n
X    if ~isinf(w(j+1))
X      edgeh(j) = plot(real(w(j:j+1)),imag(w(j:j+1)),'-','linewid',lw);
X      ang = ang - pi*beta(j);
X      j = j+1;
X    else
X      ang = ang-pi*beta(j);
X      z = [w(j);w(j)+R*exp(i*ang)];
X      edgeh(j) = plot(real(z),imag(z),'-','linewid',lw);
X      ang = ang-pi*beta(j+1);
X      z = [w(rem(j+1,n)+1)-R*exp(i*ang);w(rem(j+1,n)+1)];
X      edgeh(j+1) = plot(real(z),imag(z),'-','linewid',lw);
X      j = j+2;
X    end
X  end 
X  if j==n
X    edgeh(n) = plot(real(w([n,1])),imag(w([n,1])),'-','linewid',lw);
X  end
Xend
X
Xaxis square
Xaxis equal
Xif nargout 
X  edgehandles([first:n,1:first-1]) = edgeh;
Xend
X%set(gcf,'defaultlinelinewidth',get(gcf,'defaultlinelinewidth')/1.6);
Xif turn_off_hold
X  hold off
Xend 
X
END_OF_FILE
if test 2618 -ne `wc -c <'plotpoly.m'`; then
    echo shar: \"'plotpoly.m'\" unpacked with wrong size!
fi
chmod +x 'plotpoly.m'
# end of 'plotpoly.m'
fi
if test -f 'ptsource.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptsource.m'\"
else
echo shar: Extracting \"'ptsource.m'\" \(1350 characters\)
sed "s/^X//" >'ptsource.m' <<'END_OF_FILE'
Xfunction ptsource(w,beta,z,c,ws,R,theta,options)
X%PTSOURCE Field due to point source in a polygon.
X%       PTSOURCE plots evenly spaced equipotential and force lines for a
X%       point source located in a polygonal region.  This is equivalent
X%       to the disk map with conformal center at the source.  With no
X%       arguments the user draws the polygon and clicks the mouse at the
X%       source.
X%
X%       PTSOURCE(W,BETA) uses the polygon described by W and BETA.
X%
X%       PTSOURCE(W,BETA,Z,C) assmues that Z and C comprise the solution
X%       to the disk mapping parameter problem, as returned by DPARAM.
X%      
X%       PTSOURCE(W,BETA,Z,C,WS) uses WS as the source location.
X%
X%	PTSOURCE(W,BETA,Z,C,WS,R,THETA,OPTIONS) uses the R, THETA, and
X%	OPTIONS parameter as described in SCPLOTOPT.
X%	
X%	See also DFIXWC.
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
Xif nargin < 2
X  [w,beta] = drawpoly;
Xend 
Xn = length(w);
Xif nargin < 8
X  options = [];
X  if nargin < 7
X    theta = [];
X    if nargin < 6
X      R = [];
X      if nargin < 5
X	ws = [];
X	if nargin < 4
X	  z = [];
X	end
X      end
X    end
X  end
Xend
X
Xif isempty(z)
X  [z,c] = dparam(w,beta);
Xend
X
Xif isempty(ws)
X  plotpoly(w,beta)
X  disp('Click mouse at source location.')
X  [xc,yc] = ginput(1);
X  ws = xc+i*yc;
Xend
X
X[z,c] = dfixwc(w,beta,z,c,ws);
Xdplot(w,beta,z,c,R,theta,options);
END_OF_FILE
if test 1350 -ne `wc -c <'ptsource.m'`; then
    echo shar: \"'ptsource.m'\" unpacked with wrong size!
fi
chmod +x 'ptsource.m'
# end of 'ptsource.m'
fi
if test -f 'r2strip.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'r2strip.m'\"
else
echo shar: Extracting \"'r2strip.m'\" \(1487 characters\)
sed "s/^X//" >'r2strip.m' <<'END_OF_FILE'
Xfunction [yp,yprime] = r2strip(zp,z,L)
X%R2STRIP Map from rectangle to strip.
X%	R2STRIP(ZP,Z,L) maps from a rectangle to the strip 0 <= Im z
X%	<= 1, with the function log(sn(z|m))/pi, where sn is a Jacobi
X%	elliptic function and m = exp(-2*pi*L).  The prevertices of the
X%	map (in the rectangle domain) are given by Z; only the corners
X%	of the rectangle defined by Z are used.
X%
X%       The functionality is NOT parallel to HP2DISK and DISK2HP.
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
X% Uses different forms based on conformal modulus of the rectangle to avoid
X% underflow when modulus is large (as measured by L, separation between
X% corner images on the strip).  Also returns the derivative of the map at
X% the given points.
X
XK = max(real(z));
XKp = max(imag(z));
Xyp = zp;
Xyprime = zp;
Xif L < 5.9
X  m = exp(-2*pi*L);
X  [sn1,cn1,dn1] = ellipj(real(zp),m);
X  [sn2,cn2,dn2] = ellipj(imag(zp),1-m);
X  sn = (sn1.*dn2 + i*sn2.*cn2.*cn1.*dn1)./(cn2.^2 + m*sn1.^2.*sn2.^2);
X  yp(:) = log(sn)/pi;
X  yprime(:) = sqrt((1-sn.^2)).*sqrt((1-m*sn.^2))./(pi*sn);
Xelse
X  high = imag(zp) > Kp/2;
X  yp(~high) = (-i*zp(~high) + log(-i/2*(exp(2*i*zp(~high))-1)))/pi;
X  yprime(~high) = i*(2./(1-exp(-2*i*zp(~high)))-1)/pi;
X  u = i*Kp-zp(high);
X  yp(high) = L + i+ (i*u - log(-i/2*(exp(2*i*u)-1)))/pi;
X  yprime(high) = i*(2./(1-exp(-2*i*u))-1)/pi;
Xend
X
X% Make sure everything is in the strip (roundoff could put it outside)
Xyp = real(yp) + i*max(0,imag(yp));
Xyp = real(yp) + i*min(1,imag(yp));
X
END_OF_FILE
if test 1487 -ne `wc -c <'r2strip.m'`; then
    echo shar: \"'r2strip.m'\" unpacked with wrong size!
fi
chmod +x 'r2strip.m'
# end of 'r2strip.m'
fi
if test -f 'rcorners.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rcorners.m'\"
else
echo shar: Extracting \"'rcorners.m'\" \(848 characters\)
sed "s/^X//" >'rcorners.m' <<'END_OF_FILE'
Xfunction [w,beta,z,corners] = rcorners(w,beta,z)
X%RCORNERS (not intended for calling directly by the user)
X%	Find corners of rectangle whose map is represented by
X%	prevertices z on the strip, then renumber w, beta, and z (and
X%	the corners) so that corners(1)=1.
X%
X%       Written by Toby Driscoll.  Last updated 5/23/95.
X
Xn = length(w);
X
X% Deduce corner locations
Xleft = abs(real(z)-min(real(z))) < eps;
Xright = abs(real(z)-max(real(z))) < eps;
Xtop = abs(imag(z)-max(imag(z))) < eps;
Xbot = abs(imag(z)-min(imag(z))) < eps;
Xcorners = find(left+right+top+bot - 1);
Xc1 = find(abs(z-max(real(z))) < eps);
Xoffset = find(corners==c1);
Xcorners = corners([offset:4,1:offset-1]);
X
X% Renumber vertices so that corners(1)=1
Xrenum = [corners(1):n,1:corners(1)-1];
Xw = w(renum);
Xbeta = beta(renum);
Xz = z(renum);
Xcorners = rem(corners-corners(1)+1+n-1,n)+1;
X
END_OF_FILE
if test 848 -ne `wc -c <'rcorners.m'`; then
    echo shar: \"'rcorners.m'\" unpacked with wrong size!
fi
chmod +x 'rcorners.m'
# end of 'rcorners.m'
fi
if test -f 'rderiv.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rderiv.m'\"
else
echo shar: Extracting \"'rderiv.m'\" \(1099 characters\)
sed "s/^X//" >'rderiv.m' <<'END_OF_FILE'
Xfunction fprime = rderiv(zp,z,beta,L,zs)
X%RDERIV Derivative of the rectangle map.
X%	RDERIV(ZP,Z,BETA,L) returns the derivative at the points of ZP of
X%	the Schwarz-Christoffel rectangle map whose prevertices are Z,
X%	turning angles are BETA, and aspect ratio parameter is L.
X%	
X%	If a fifth argument is supplied, it is assumed to be the image
X%	of Z on the intermediate strip; see R2STRIP.
X%	
X%	Don't forget the multiplicative constant in the SC map!
X%	
X%	See also RPARAM, RMAP, R2STRIP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(z);
X
Xif nargin < 5
X  % Find prevertices on the strip
X  zs = r2strip(z,z,L);
X  zs = real(zs) + i*round(imag(zs)); 	% put them *exactly* on edges
Xend
X
X% First compute map and derivative from rectangle to strip
X[F,dF] = r2strip(zp,z,L);
X
X% Now compute derivative of map from strip to polygon
X[tmp,j1] = min(zs);
Xrenum = [j1:n,1:j1-1];
Xzs = zs(renum);
Xbeta = beta(renum);
Xnb = sum(~imag(zs));
Xzs = zs(:);
Xzs = [-Inf; zs(1:nb); Inf; zs(nb+1:n)];
Xbetas = [0; beta(1:nb); 0; beta(nb+1:n)];
XdG = stderiv(F,zs,betas);
X
X% Put it together
Xfprime = dF.*dG;
X
END_OF_FILE
if test 1099 -ne `wc -c <'rderiv.m'`; then
    echo shar: \"'rderiv.m'\" unpacked with wrong size!
fi
chmod +x 'rderiv.m'
# end of 'rderiv.m'
fi
if test -f 'rdisp.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rdisp.m'\"
else
echo shar: Extracting \"'rdisp.m'\" \(1674 characters\)
sed "s/^X//" >'rdisp.m' <<'END_OF_FILE'
Xfunction rdisp(w,beta,z,c,L)
X%RDISP Display results of Schwarz-Christoffel rectangle parameter problem.
X%       RDISP(W,BETA,RECT,Z,C) displays the results of RPARAM in a 
X%       pleasant way.  
X%
X%	See also RPARAM, RPLOT.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
X% Deduce corner locations
Xleft = abs(real(z)-min(real(z))) < eps;
Xright = abs(real(z)-max(real(z))) < eps;
Xtop = abs(imag(z)-max(imag(z))) < eps;
Xbot = abs(imag(z)-min(imag(z))) < eps;
Xcorners = find(left+right+top+bot - 1);
Xc1 = find(abs(z-max(real(z))) < eps);
Xoffset = find(corners==c1);
Xcorners = corners([offset:4,1:offset-1]);
Xrect = z(corners);
X
Xdisp(' ')
Xdisp(' cnr          w               beta                      z              ')
Xdisp(' ------------------------------------------------------------------------')
Xu = real(w);
Xv = imag(w);
Xfor j = 1:length(w)
X  if v(j) < 0
X    s = '-';
X  else
X    s = '+';
X  end
X  cnr = find(j==corners);
X  if isempty(cnr)
X    cstr = '    ';
X  else
X    cstr = sprintf('  %i ',cnr);
X  end
X  if ~imag(z(j))
X    disp(sprintf('%s %8.5f %c %7.5fi    %8.5f   %16.8e',...
X      cstr,u(j),s,abs(v(j)),beta(j),z(j)));
X  else
X    disp(sprintf('%s %8.5f %c %7.5fi    %8.5f   %16.8e + %14.8ei',...
X      cstr,u(j),s,abs(v(j)),beta(j),real(z(j)),imag(z(j))));
X  end    
Xend
Xdisp(' ')
Xif imag(c) < 0
X  s = '-';
Xelse
X  s = '+';
Xend
Xdisp(sprintf('  c = %.8g %c %.8gi',real(c),s,abs(imag(c))))
Xdisp(sprintf('\n  Conformal modulus = %.8g',imag(rect(2))/rect(1)/2));
X%disp(sprintf('\n  Rectangle corners:'))
X%R = [rect(1);real(rect(2));imag(rect(2));real(rect(3));imag(rect(3));rect(4)];
X%disp(sprintf('    %.4f,  %.4f + %.4fi,  %.4f + %.4fi,  %.4f',R))
X
END_OF_FILE
if test 1674 -ne `wc -c <'rdisp.m'`; then
    echo shar: \"'rdisp.m'\" unpacked with wrong size!
fi
chmod +x 'rdisp.m'
# end of 'rdisp.m'
fi
if test -f 'rimapf1.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rimapf1.m'\"
else
echo shar: Extracting \"'rimapf1.m'\" \(385 characters\)
sed "s/^X//" >'rimapf1.m' <<'END_OF_FILE'
Xfunction zdot = rimapf1(wp,yp);
X%RIMAPF1 (not intended for calling directly by the user)
X%	Used by RINVMAP for solution of an ODE.
X
Xglobal SCIMDATA 
X
Xlenyp = length(yp);
Xlenzp = lenyp/2;
Xzp = yp(1:lenzp)+sqrt(-1)*yp(lenzp+1:lenyp);
Xn = SCIMDATA(1,5);
X
Xf = SCIMDATA(1:lenzp,1)./rderiv(zp,SCIMDATA(1:n,2),SCIMDATA(1:n,3),...
X    SCIMDATA(2,5),SCIMDATA(1:n,4));
Xzdot = [real(f);imag(f)];
END_OF_FILE
if test 385 -ne `wc -c <'rimapf1.m'`; then
    echo shar: \"'rimapf1.m'\" unpacked with wrong size!
fi
chmod +x 'rimapf1.m'
# end of 'rimapf1.m'
fi
if test -f 'rinvmap.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rinvmap.m'\"
else
echo shar: Extracting \"'rinvmap.m'\" \(3410 characters\)
sed "s/^X//" >'rinvmap.m' <<'END_OF_FILE'
Xfunction zp = rinvmap(wp,w,beta,z,c,L,qdat,z0,options)
X%RINVMAP Schwarz-Christoffel rectangle inverse map.
X%	RINVMAP(WP,W,BETA,CORNERS,Z,C,L,QDAT) computes the inverse of
X%	the Schwarz-Christoffel rectangle map (i.e., from the polygon to
X%	the rectangle) at the points given in vector WP. The other
X%	arguments are as in RPARAM.  QDAT may be omitted.
X%	
X%	The default algorithm is to solve an ODE in order to obtain a fair
X%	approximation for ZP, and then improve ZP with Newton iterations.
X%	The ODE solution at WP requires a vector Z0 whose forward image W0
X%	is such that for each j, the line segment connecting WP(j) and W0(j)
X%	lies inside the polygon.  By default Z0 is chosen by a fairly robust
X%	automatic process.  Using a parameter (see below), you can choose to
X%	use either an ODE solution or Newton iterations exclusively.
X%
X%	RINVMAP(WP,...,QDAT,Z0) has two interpretations.  If the ODE
X%	solution is being used, Z0 overrides the automatic selection of
X%	initial points.  (This can be handy in convex polygons, where the
X%	choice of Z0 is trivial.)  Otherwise, Z0 is taken as an initial
X%	guess to ZP.  In either case, if length(Z0)==1, the value Z0 is used
X%	for all elements of WP; otherwise, length(Z0) should equal
X%	length(WP).
X%
X%       RINVMAP(WP,...,QDAT,Z0,OPTIONS) uses a vector of parameters
X%       that control the algorithm.  See SCIMAPOPT.
X%
X%	See also SCIMAPOPT, RPARAM, RMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
Xw = w(:);
Xbeta = beta(:);
Xz = z(:);
X[w,beta,z,corners] = rcorners(w,beta,z);
Xrect = z(corners);
XK = max(real(z));
XKp = max(imag(z));
Xzs = r2strip(z,z,L);
Xzs = real(zs) + i*round(imag(zs));	% put them *exactly* on edges
X
Xzp = zeros(size(wp));
Xwp = wp(:);
Xlenwp = length(wp);
X
Xif nargin < 9
X  options = [];
X  if nargin < 8
X    z0 = [];
X    if nargin < 7
X      qdat = [];
X    end
X  end
Xend
X
X[ode,newton,tol,maxiter] = scimapopt(options);
X
Xif isempty(qdat)
X  qdat = scqdata(beta,max(ceil(-log10(tol)),2));
Xend
X
X% ODE
Xif ode
X  if isempty(z0)
X    % Pick a value z0 (not a singularity) and compute the map there.
X    [z0,w0] = scimapz0('r',wp,w,beta,z,c,L,qdat);
X  else
X    w0 = rmap(z0,w,beta,z,c,L,qdat);
X    if length(z0)==1 & lenwp > 1
X      z0 = z0(:,ones(lenwp,1)).';
X      w0 = w0(:,ones(lenwp,1)).';
X    end
X  end
X
X  % Use relaxed ODE tol if improving with Newton.
X  odetol = max(tol,1e-3*(newton));
X
X  % Set up data for the ode function.
X  global SCIMDATA	
X  SCIMDATA = zeros(max(lenwp,n),5);
X  SCIMDATA = (wp - w0(:))/c; 		% adjusts "time" interval
X  SCIMDATA(1:n,2) = z;
X  SCIMDATA(1:n,3) = beta;
X  SCIMDATA(1:n,4) = zs;
X  SCIMDATA(1,5) = n;
X  SCIMDATA(2,5) = L;
X
X  z0 = [real(z0);imag(z0)];
X  [t,y] = ode45('rimapf1',0,1,z0,odetol);
X  [m,leny] = size(y);
X  zp(:) = y(m,1:lenwp)+sqrt(-1)*y(m,lenwp+1:leny);
Xend
X
X% Newton iterations
Xif newton
X  if ~ode
X    zn = z0(:);
X    if length(z0)==1 & lenwp > 1
X      zn = zn(:,ones(lenwp,1));
X    end
X  else
X    zn = zp(:);
X  end
X    
X  wp = wp(:);
X  done = zeros(size(zn));
X  k = 0;
X  while ~all(done) & k < maxiter
X    F = wp(~done) - rmap(zn(~done),w,beta,z,c,L,qdat);
X    dF = c*rderiv(zn(~done),z,beta,L,zs);
X    zn(~done) = zn(~done) + F(:)./dF(:);
X    done(~done) =  (abs(F) < tol);
X    k = k + 1;
X  end
X  if any(abs(F)> tol)
X    disp('Warning in rinvmap: Solution may be inaccurate')
X    fprintf('Maximum residual = %.3g\n',max(abs(F)))
X  end
X  zp(:) = zn; 
Xend;
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
END_OF_FILE
if test 3410 -ne `wc -c <'rinvmap.m'`; then
    echo shar: \"'rinvmap.m'\" unpacked with wrong size!
fi
chmod +x 'rinvmap.m'
# end of 'rinvmap.m'
fi
if test -f 'rmap.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rmap.m'\"
else
echo shar: Extracting \"'rmap.m'\" \(1423 characters\)
sed "s/^X//" >'rmap.m' <<'END_OF_FILE'
Xfunction wp = rmap(zp,w,beta,z,c,L,qdat)
X%RMAP   Schwarz-Christoffel rectangle map.
X%       RMAP(ZP,W,BETA,Z,C,L,QDAT) computes the values of the
X%       Schwarz-Christoffel rectangle map at the points in vector ZP.
X%       The remaining arguments are as in RPARAM.  RMAP returns a vector
X%       the same size as ZP.
X%	
X%       RMAP(ZP,W,BETA,Z,C,L,TOL) uses quadrature data intended to give
X%       an answer accurate to within TOL.
X%	
X%	RMAP(ZP,W,BETA,Z,C,L) uses a tolerance of 1e-8.
X%
X%	See also RPARAM, RPLOT, RINVMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
Xwp = z;
Xw = w(:);
Xbeta = beta(:);
Xz = z(:);
X[w,beta,z,corners] = rcorners(w,beta,z);
X
X% Map prevertices to strip
XK = max(real(z));
XKp = max(imag(z));
Xzs = r2strip(z,z,L);
Xzs = real(zs) + i*round(imag(zs));	% put them *exactly* on edges
X
Xif nargin < 7
X  qdat = scqdata(beta,8);
Xelseif length(qdat)==1
X  qdat = scqdata(beta,max(ceil(-log10(qdat)),8));
Xend
Xwp = zeros(size(zp));
Xzp = zp(:);
Xp = length(zp);
X
X% Trap points which map to +/-Inf on the strip.
Xbad = abs(zp) < 2*eps;
Xzp(bad) = zp(bad) + 100*eps;
Xbad = abs(zp-i*Kp) < 2*eps;
Xzp(bad) = zp(bad) - i*100*eps*Kp;
X
X% Map from rectangle to strip.
Xyp = r2strip(zp,z,L);
X
X% Now map from strip to polygon.
Xi1 = 1:corners(3)-1;
Xi2 = corners(3):n;
Xws = [NaN; w(i1); NaN; w(i2)];
Xbs = [0; beta(i1); 0; beta(i2)];
Xzs = [Inf; zs(i1); Inf; zs(i2)];
Xwp(:) = stmap(yp,ws,bs,zs,c,qdat);
X
X
END_OF_FILE
if test 1423 -ne `wc -c <'rmap.m'`; then
    echo shar: \"'rmap.m'\" unpacked with wrong size!
fi
chmod +x 'rmap.m'
# end of 'rmap.m'
fi
if test -f 'rparam.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rparam.m'\"
else
echo shar: Extracting \"'rparam.m'\" \(6727 characters\)
sed "s/^X//" >'rparam.m' <<'END_OF_FILE'
Xfunction [z,c,L,qdat] = rparam(w,beta,cnr,z0,options);
X%RPARAM Schwarz-Christoffel rectangle parameter problem.
X%       [Z,C,L,QDAT] = RPARAM(W,BETA,CORNERS) solves the
X%       Schwarz-Christoffel parameter problem with a rectangle as
X%       fundamental domain and interior of the specified polygon as the
X%       target.  W must be a vector of the vertices of the polygon,
X%       specified in counterclockwise order.  BETA is a vector of
X%       turning angles; see SCANGLES.  CORNERS is a 4-component vector
X%       specifying the indices of the vertices which are the images of
X%       the corners of the rectangle.  *BE SURE* the first two entries
X%       describe the LONG sides of the rectangle, and go in
X%       counterclockwise order.  If CORNERS is omitted, the user is
X%       requested to select these vertices using the mouse.
X%
X%       If successful, RPARAM will return Z, a vector of the
X%       prevertices; C, the multiplicative constant of the conformal
X%       map; L, a parameter related to aspect ratio; and QDAT, a matrix
X%       of quadrature data used by some of the other SC routines.
X%
X%       [Z,C,L,QDAT] = RPARAM(W,BETA,CORNERS,Z0) uses Z0 as an initial
X%       guess for Z.  In this case, Z0 represents the image of
X%       prevertices on the strip 0 <= Im z <= 1.  You can use R2STRIP to
X%       transform prevertices from the rectangle to the strip.
X%
X%       [Z,C,L,QDAT] = RPARAM(W,BETA,CORNERS,Z0,OPTIONS) uses a vector of
X%       control parameters.  See SCPARMOPT.  
X%	
X%	See also SCPARMOPT, DRAWPOLY, RDISP, RPLOT, RMAP, RINVMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w); 				% no. of vertices
Xw = w(:);
Xbeta = beta(:);
X
X% Set up defaults for missing args
Xif nargin < 5
X  options = [];
X  if nargin < 4
X    z0 = [];
X    if nargin < 3
X      cnr = [];
X    end
X  end
Xend
X
Xif isempty(cnr)
X  disp('Use mouse to select images of rectangle corners.')
X  disp('Go in counterclockwise order and select a long edge first.')
X  figure(gcf)
X  cnr = scselect(w,beta,4);
Xend
X
X% Renumber vertices so that cnr(1)=1
Xrenum = [cnr(1):n,1:cnr(1)-1];
Xw = w(renum);
Xbeta = beta(renum);
Xcnr = rem(cnr-cnr(1)+1+n-1,n)+1;
X
X[trace,tol] = scparmopt(options);
Xnqpts = max(ceil(-log10(tol)),4);
Xqdat = scqdata(beta,nqpts); 		% quadrature data
X
X% Check input data.
Xerr = sccheck('r',w,beta,cnr);
Xif err==1
X  fprintf('Use SCFIX to make polygon obey requirements\n')
X  error(' ')
Xend
X
Xatinf = (beta <= -1);
X
Xif isempty(z0)
X  % Try to find a reasonable initial guess.
X  dw = abs(diff(w([1:n,1])));		% side lengths
X  dw(isinf(dw)) = mean(dw(~isinf(dw)))*ones(size(dw(isinf(dw))));
X  % Estimate length and width, and thus conformal modulus
X  len = mean([sum(dw(cnr(1):cnr(2)-1)), sum(dw(cnr(3):cnr(4)-1))]);
X  wid = mean([sum(dw(cnr(2):cnr(3)-1)), sum(dw([cnr(4):n,1:cnr(1)-1]))]);
X  modest = len/wid;
X  % Evenly space prevertices to match this conformal modulus
X  z0(cnr(1):cnr(2)) = linspace(0,modest,diff(cnr(1:2))+1);
X  dx = z0(cnr(1)+1)-z0(cnr(1));
X  z0(cnr(1)-1:-1:1) = z0(cnr(1))-dx*(1:cnr(1)-1);
X  z0(cnr(2)+1:cnr(3)-1) = z0(cnr(2)) + dx*(1:diff(cnr(2:3))-1);
X  z0(cnr(4):-1:cnr(3)) = linspace(0,modest,diff(cnr(3:4))+1);
X  dx = z0(cnr(4)-1)-z0(cnr(4));
X  z0(cnr(4)+1:n) = z0(cnr(4))-dx*(1:n-cnr(4));
X
Xelse
X  if length(z0)~=n
X    error('Initial guess has wrong number of prevertices')
X  end
X  z0 = z0(renum);
X  if any(imag(z0(1:cnr(3)-1))) | any(~imag(z0(cnr(3):n)))
X    error('Initial guess has prevertices on wrong side of strip')
X  end
Xend
X
X% Convert z0 to unconstrained vars
Xy0 = zeros(n-3,1);
Xdz = diff(z0);
Xdz(cnr(3):n-1) = -dz(cnr(3):n-1);
Xy0(1:cnr(2)-2) = log(dz(1:cnr(2)-2));
Xy0(cnr(2)-1) = mean(log(dz([cnr(2)-1,cnr(3)])));
Xy0(cnr(2):n-3) = log(dz([cnr(2):cnr(3)-2,cnr(3)+1:n-1]));
X
X% Find prevertices (solve param problem)
X
X% Set up normalized lengths for nonlinear equations:
X% indices of left and right integration endpoints
Xleft = 1:n-2;				
Xright = 2:n-1;				
X% delete indices corresponding to vertices at Inf
Xleft(find(atinf)) = [];
Xright(find(atinf) - 1) = [];
Xif atinf(n-1)
X  right = [right,n];
Xend
Xcmplx = ((right-left) == 2);
X% normalize lengths by w(2)-w(1)
Xnmlen = (w(right)-w(left))/(w(2)-w(1));
X% abs value for finite ones
Xnmlen(~cmplx) = abs(nmlen(~cmplx));
X% first entry is useless (=1)
Xnmlen(1) = [];
X
Xbeta = [0;beta(1:cnr(3)-1);0;beta(cnr(3):n)];
X
X% Solve nonlinear system of equations:
X% package data
Xnrow = max([n+2,nqpts,8]);
Xncol = 6+2*n+2;
Xfdat = zeros(nrow,ncol);
Xfdat(1:4,1) = [n;length(left);nqpts;ncol];
Xfdat(5:8,1) = cnr(:);
Xfdat(1:n+2,2) = beta;
Xfdat(1:fdat(2,1)-1,3) = nmlen(:);
Xfdat(1:fdat(2,1),4:6) = [left(:),right(:),cmplx(:)];
Xfdat(1:nqpts,7:ncol) = qdat;
X% set options
Xopt = zeros(16,1);
Xopt(1) = 2*trace;
Xopt(6) = 100*(n-3);
Xopt(8) = tol;
Xopt(9) = tol/10;
Xopt(12) = nqpts;
X% do it
X[y,termcode] = nesolve('rpfun',y0,opt,fdat);
Xif termcode~=1
X  disp('Warning: Nonlinear equations solver did not terminate normally')
Xend
X
X% Convert y values to z on strip
Xzs = rptrnsfm(y,cnr);
Xnb = cnr(3)-1;
X
X% Determine multiplicative constant
Xmid = mean(zs(1:2));
Xg = stquad(zs(2),mid,2,zs,beta,qdat) -...
X    stquad(zs(1),mid,1,zs,beta,qdat);
Xc = (w(1)-w(2))/g;
X
X% Find corners of rectangle
XL = zs(cnr(2))-zs(cnr(1));
Xif L < 5.9
X  m = exp(-2*pi*L);
X  K = ellipke(m);
X  Kp = ellipke(1-m);
Xelse
X  K = pi/2;
X  Kp = pi*L + log(4);
Xend
Xrect = [K;K+i*Kp;-K+i*Kp;-K];
Xbounds = [-K,K,0,Kp];
X
X% Find prevertices on the rectangle:
X%   initial values evenly spaced on the rectangle
Xz = zeros(size(zs));
Xz(cnr) = rect;
Xz(1:cnr(2)) = linspace(rect(1),rect(2),diff(cnr(1:2))+1).';
Xtmp = linspace(rect(2),i*imag(rect(3)),diff(cnr(2:3))+1).';
Xz(cnr(2):cnr(3)-1) = tmp(1:diff(cnr(2:3)));
Xz(cnr(3):cnr(4)) = linspace(rect(3),rect(4),diff(cnr(3:4))+1).';
Xtmp = linspace(rect(4),0,n-cnr(4)+2).';
Xz(cnr(4):n) = tmp(1:n-cnr(4)+1);
Xzn = z(:);
X
X% Which are on left/right sides?
Xlr = zeros(n,1);
Xlr([1:cnr(2),cnr(3):cnr(4)]) = ones(cnr(2)+cnr(4)-cnr(3)+1,1);
X
X%   Newton iteration
Xmaxiter = 50;
Xdone = zeros(size(zn));
Xdone(cnr) = ones(4,1);
Xk = 0;
Xwhile ~all(done) & k < maxiter
X  [F,dF] = r2strip(zn(~done),z(cnr),L);
X  F = zs(~done) - F;
X  % Must keep points from leaving the rectangle:
X  %   pure real/imaginary, and not too big
X  step = 2*F./dF;
X  step(lr(~done)) = i*imag(step(lr(~done)));
X  step(~lr(~done)) = real(step(~lr(~done)));
X  bad = ones(size(step));
X  while any(bad)
X    step(bad) = step(bad)/2;
X    znew = zn(~done) + step;
X    bad = real(znew) < bounds(1) | real(znew) > bounds(2) |...
X	imag(znew) < bounds(3) | imag(znew) > bounds(4);
X  end
X  % Update
X  zn(~done) = znew;
X  done(~done) =  (abs(F) < tol);
X  k = k + 1;
Xend
Xif any(abs(F)> tol)
X  disp('Warning in rparam: Iteration for rectangle prevertices DNC')
Xend
Xz(:) = zn; 
X
X% Undo renumbering
Xz(renum) = z;
X
X
X
END_OF_FILE
if test 6727 -ne `wc -c <'rparam.m'`; then
    echo shar: \"'rparam.m'\" unpacked with wrong size!
fi
chmod +x 'rparam.m'
# end of 'rparam.m'
fi
if test -f 'rpfun.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rpfun.m'\"
else
echo shar: Extracting \"'rpfun.m'\" \(1382 characters\)
sed "s/^X//" >'rpfun.m' <<'END_OF_FILE'
Xfunction F = rpfun(y,fdat)
X%RPFUN  (not intended for calling directly by the user)
X%	Returns residual for solution of nonlinear equations. 
X%	Used by RPARAM.
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
Xn = fdat(1,1);
Xbeta = fdat(1:n+2,2);
Xnmlen = fdat(1:fdat(2,1)-1,3);
Xrows = 1:fdat(2,1);
Xleft = fdat(rows,4);
Xright = fdat(rows,5);
Xcmplx = fdat(rows,6);
Xqdat = fdat(1:fdat(3,1),7:fdat(4,1));
Xcorners = fdat(5:8,1);
X
X% Transform y (unconstr. vars) to z (actual params)
Xz = rptrnsfm(y,corners);
Xnb = corners(3)-1;
X
X% Check crowding of singularities.
Xif any(abs(diff(z))<eps) | any(isinf(z))
X  F = y;
X  disp('Warning: Severe crowding')
X  return
Xend
X
X% Compute the integrals appearing in nonlinear eqns.
Xzleft = z(left);
Xzright = z(right);
Xmid = mean([zleft.' ; zright.']).';
Xints = stquad(zleft,mid,left,z,beta,qdat) - ...
X    stquad(zright,mid,right,z,beta,qdat);
X
Xif any(ints==0)|any(isnan(ints))
X  % Singularities were too crowded.  Try returning a
X  % big residual to get fsolve to try something else.
X  %%F = 10*(5+randn(1))*ones(n-3,1);
X  F = y;
X  disp('Warning: Severe crowding')
Xelse
X  % Compute nonlinear equation residual values.
X  cmplx2 = cmplx(2:length(cmplx));
X  F1 = abs(ints(~cmplx)); 		% F1(1) = abs(ints(1))
X  F1 = log( (F1(2:length(F1))/F1(1)) ./ nmlen(~cmplx2) );
X  F2 = log( (ints(cmplx)/ints(1)) ./ nmlen(cmplx2) );
X  F = [F1;real(F2);imag(F2)];
Xend
X
X
END_OF_FILE
if test 1382 -ne `wc -c <'rpfun.m'`; then
    echo shar: \"'rpfun.m'\" unpacked with wrong size!
fi
chmod +x 'rpfun.m'
# end of 'rpfun.m'
fi
if test -f 'rplot.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rplot.m'\"
else
echo shar: Extracting \"'rplot.m'\" \(3587 characters\)
sed "s/^X//" >'rplot.m' <<'END_OF_FILE'
Xfunction [H,RE,IM] = rplot(w,beta,z,c,L,re,im,options)
X%RPLOT  Image of cartesian grid under Schwarz-Christoffel rectangle map.
X%       RPLOT(W,BETA,Z,C,L) will adaptively plot the images under the
X%       Schwarz-Christoffel rectangle map of ten evenly spaced
X%       horizontal and vertical lines in the retangle RECT.  The
X%       arguments are as in RPARAM.
X%
X%       RPLOT(W,BETA,Z,C,L,M,N) will plot images of M evenly spaced
X%       vertical and N evenly spaced horizontal lines.
X%
X%       RPLOT(W,BETA,Z,C,L,RE,IM) will plot images of vertical lines
X%       whose real parts are given in RE and horizontal lines whose
X%       imaginary parts are given in IM.  Either argument may be empty.
X%
X%       RPLOT(W,BETA,Z,C,L,RE,IM,OPTIONS) allows customization of
X%       RPLOT's behavior.  See SCPLOTOPT.
X%
X%       H = RPLOT(W,BETA,Z,C,L,...) returns a vector of handles to all
X%       the curves drawn in the interior of the polygon.  [H,RE,IM] =
X%       RPLOT(W,BETA,Z,C,L,...) also returns the abscissae and ordinates
X%       of the lines comprising the grid.
X%	
X%	See also SCPLOTOPT, RPARAM, RMAP, RDISP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xturn_off_hold = ~ishold;
Xn = length(w);
Xw = w(:);
Xbeta = beta(:);
Xz = z(:);
X[w,beta,z,corners] = rcorners(w,beta,z);
Xrect = z(corners);
X
Xif nargin < 8
X  options = [];
X  if nargin < 7
X    im = [];
X    if nargin < 7
X      re = [];
X    end
X  end
Xend
X
XKp = imag(rect(2));
XK = rect(1);
X
Xif isempty([re(:);im(:)])
X  re = 10;
X  im = 10;
Xend
X
Xif (length(re)==1) & (re == round(re))
X  if re < 1
X    re = [];
X  else
X    m = re;
X    re = linspace(-K,K,m+2);
X    re([1,m+2]) = [];
X  end
Xend
Xif (length(im)==1) & (im == round(im))
X  if im < 1
X    im = [];
X  else
X    m = im;
X    im = linspace(0,Kp,m+2);
X    im([1,m+2]) = [];
X  end
Xend
X
X[nqpts,maxturn,maxlen,maxrefn] = scplotopt(options);
X
Xfig = gcf;
Xfigure(fig);
Xplotpoly(w,beta);
Xdrawnow
Xhold on
X
Xreflen = maxlen*max(abs(diff([w(~isinf(w));w(2)])));
Xqdat = scqdata(beta,4);
X
Xfor j = 1:length(re)
X  zp = re(j) + i*linspace(0,Kp,15).';
X  wp = rmap(zp,w,beta,z,c,L,qdat);
X  bad = find(toobig(wp,maxturn,reflen,axis));
X  iter = 0;
X  while (~isempty(bad)) & (iter < maxrefn)
X    lenwp = length(wp);
X    newz = [(zp(bad-1)+2*zp(bad))/3;(zp(bad+1)+2*zp(bad))/3];
X    neww = rmap(newz,w,beta,z,c,L,qdat);
X    [k,in] = sort(imag([zp;newz]));
X    zp = [zp;newz];  wp = [wp;neww];
X    zp = zp(in);     wp = wp(in);
X    iter = iter + 1;
X    bad = find(toobig(wp,maxturn,reflen,axis));
X  end
X  linh(j) = plot(clipdata(wp,axis), 'g-','erasemode','none');
X  drawnow
X  set(linh(j),'erasemode','normal');
X  Z(1:length(zp),j) = zp;
X  W(1:length(wp),j) = wp;
Xend
X
Xfor j = 1:length(im)
X  zp = linspace(-K,K,15).' + i*im(j);
X  wp = rmap(zp,w,beta,z,c,L,qdat);
X  bad = find(toobig(wp,maxturn,reflen,axis));
X  iter = 0;
X  while (~isempty(bad)) & (iter < maxrefn)
X    lenwp = length(wp);
X    newz = [(zp(bad-1)+2*zp(bad))/3;(zp(bad+1)+2*zp(bad))/3];
X    neww = rmap(newz,w,beta,z,c,L,qdat);
X    [k,in] = sort(real([zp;newz]));
X    zp = [zp;newz];  wp = [wp;neww];
X    zp = zp(in);     wp = wp(in);
X    iter = iter + 1;
X    bad = find(toobig(wp,maxturn,reflen,axis));
X  end
X  linh(j+length(re)) = plot(clipdata(wp,axis), 'g-','erasemode','none');
X  drawnow
X  Z(1:length(zp),j+length(re)) = zp;
X  W(1:length(wp),j+length(re)) = wp;
X  set(linh(j+length(re)),'erasemode','normal');
Xend
X  
X% Force redraw to get clipping enforced.
Xset(fig,'color',get(fig,'color'))
X
Xif turn_off_hold, hold off, end;
Xif nargout > 0
X  H = linh;
X  if nargout > 1
X    RE = re;
X    if nargout > 2
X      IM = im;
X    end
X  end
Xend 
X
END_OF_FILE
if test 3587 -ne `wc -c <'rplot.m'`; then
    echo shar: \"'rplot.m'\" unpacked with wrong size!
fi
chmod +x 'rplot.m'
# end of 'rplot.m'
fi
if test -f 'rptrnsfm.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rptrnsfm.m'\"
else
echo shar: Extracting \"'rptrnsfm.m'\" \(823 characters\)
sed "s/^X//" >'rptrnsfm.m' <<'END_OF_FILE'
Xfunction z = rptrnsfm(y,corners)
X%RPTRNSFM (not intended for calling directly by the user)
X%       Transform optimization vars to prevertices for rectangle
X%       parameter problem. 
X%
X%       Written by Toby Driscoll.  Last updated 5/23/95.
X
Xn = length(y)+3;
Xz = zeros(n,1);
Xz(corners(1)-1:-1:1) = cumsum(-exp(y(corners(1)-1:-1:1)));
Xz(corners(1)+1:corners(2)-1) = cumsum(exp(y(corners(1):corners(2)-2)));
Xz(corners(4)+1:n) = cumsum(-exp(y(corners(4)-2:n-3)));
Xz(corners(4)-1:-1:corners(3)+1) = cumsum(...
X    exp(y(corners(4)-3:-1:corners(3)-1)));
Xxr = z([corners(2)-1,corners(3)+1]);
Xz(corners(2)) = mean(xr)+sqrt(diff(xr/2)^2+exp(2*y(corners(2)-1)));
Xz(corners(3)) = z(corners(2));
Xz(corners(2)+1:corners(3)-1) = z(corners(2)) + cumsum(...
X    exp(y(corners(2):corners(3)-2)));
Xz(corners(3):n) = i + z(corners(3):n);
X
END_OF_FILE
if test 823 -ne `wc -c <'rptrnsfm.m'`; then
    echo shar: \"'rptrnsfm.m'\" unpacked with wrong size!
fi
chmod +x 'rptrnsfm.m'
# end of 'rptrnsfm.m'
fi
if test -f 'scaddvtx.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scaddvtx.m'\"
else
echo shar: Extracting \"'scaddvtx.m'\" \(1234 characters\)
sed "s/^X//" >'scaddvtx.m' <<'END_OF_FILE'
Xfunction [wn,betan] = scaddvtx(w,beta,pos)
X%SCADDVTX Add a vertex to a polygon.
X%	[WN,BETAN] = SCADDVTX(W,BETA,POS) adds a new vertex to the
X%	polygon described by W and BETA immediately after vertex POS.
X%	If W(POS:POS+1) are finite, the new vertex is at the midpoint of
X%	an edge; otherwise, the new vertex is a reasonable distance from
X%	its finite neighbor.
X%	
X%	See also SCFIX.
X%	
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xw = w(:);
Xbeta = beta(:);
Xn = length(w);
Xif ~pos, pos=n; end
Xpos1 = rem(pos,n)+1;
Xif ~any(isinf(w([pos,pos1])))	% easy case
X  new = mean(w([pos,pos1]));
Xelse					% messy case
X  % Find a pair of adjacent finite vertices as a basis.
X  base = min(find(~isinf(w) & ~isinf(w([2:n,1]))));
X  ang(base) = angle(w(rem(base,n)+1)-w(base));
X  
X  % Determine absolute angle of side pos->pos1.
X  for j = [base+1:n,1:base-1]
X    ang(j) = ang(rem(j-2+n,n)+1)-pi*beta(j);
X    if j==pos, break, end
X  end
X  
X  % Find a nice side length.
X  len = abs(w([2:n,1])-w);
X  avglen = mean(len(~isinf(len)));
X
X  % Do it.
X  if isinf(w(pos))
X    new = w(pos1) + avglen*exp(i*(ang(pos)+pi));
X  else
X    new = w(pos) + avglen*exp(i*(ang(pos)));
X  end
Xend
X
Xwn = [w(1:pos);new;w(pos+1:n)];
Xbetan = [beta(1:pos);0;beta(pos+1:n)];
END_OF_FILE
if test 1234 -ne `wc -c <'scaddvtx.m'`; then
    echo shar: \"'scaddvtx.m'\" unpacked with wrong size!
fi
chmod +x 'scaddvtx.m'
# end of 'scaddvtx.m'
fi
if test -f 'scangle.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scangle.m'\"
else
echo shar: Extracting \"'scangle.m'\" \(1313 characters\)
sed "s/^X//" >'scangle.m' <<'END_OF_FILE'
Xfunction beta = scangle(w)
X%SCANGLE Turning angles of a polygon.
X%       SCANGLE(W) computes the turning angles of the polygon whose
X%       vertices are specified in the vector W.  The turning angle of a
X%       vertex measures how much the heading changes at that vertex from
X%       the incoming to the outgoing edge, normalized by pi.  For a
X%       finite vertex, it is equal in absolute value to (exterior
X%       angle)/pi, with a negative sign for left turns and positive for
X%       right turns.  Thus the turn at a finite vertex is in (-1,1],
X%       with 1 meaning a slit.
X%
X%       At an infinite vertex the turning angle is in the range [-3,-1]
X%       and is equal to the exterior angle of the two sides extended
X%       back from infinity, minus 2.  SCANGLE cannot determine the angle
X%       at an infinite vertex or its neighbors, and will return NaN's in
X%       those positions.  If infinite vertices are confusing, try
X%       INFDEMO. 
X%	
X%	See also DRAWPOLY.
X%
X%       Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
Xinf = isinf(w);
Xmask = ~(inf | inf([2:n,1]) | inf([n,1:n-1]));
Xdw = [w(1)-w(n); diff(w(:))];
Xdwshift = dw([2:n,1]);
Xbeta = NaN*ones(size(w));
Xbeta(mask) = angle(dw(mask).*conj(dwshift(mask)))/pi;
Xmod = abs(beta+1) < eps;
Xbeta(mod) = ones(size(beta(mod)));
X
END_OF_FILE
if test 1313 -ne `wc -c <'scangle.m'`; then
    echo shar: \"'scangle.m'\" unpacked with wrong size!
fi
chmod +x 'scangle.m'
# end of 'scangle.m'
fi
if test -f 'sccheck.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sccheck.m'\"
else
echo shar: Extracting \"'sccheck.m'\" \(3348 characters\)
sed "s/^X//" >'sccheck.m' <<'END_OF_FILE'
Xfunction err = sccheck(type,w,beta,aux)
X%SCCHECK Check polygon inputs to Schwarz-Christoffel functions.
X%	
X%	SCCHECK is used by the xxPARAM functions to check the validity
X%	of inputs describing the polygon to be mapped.  If errors are
X%	found, execution will terminate.  Sometimes the trouble has to
X%	do with how the parameter problem is posed, which imposes a few
X%	nonobvious constraints.  The function SCFIX is provided to
X%	automatically fix such difficulties, by renumbering or perhaps
X%	adding vertices.
X
X%	Calling sequence: SCCHECK(map,w,beta), where map is one of 'hp',
X%	'd', 'de', etc.  Output is 1 if the problem is rectifiable by
X%	SCFIX, 2 if warning status only.  Breaks execution when problem
X%	is fatal.
X
X%	By Toby Driscoll.  Last modified 3/24/95.
X
Xw = w(:);
Xbeta = beta(:);
Xn = length(w);
Xatinf = (beta <= -1);
Xrenum = 1:n;
Xerr = 0;
X
X% Universal truths
Xif length(beta)~=n
X  error('Mismatched angles and vertices')
Xelseif any(beta > 1) | any(beta < -3)
X  error('Each angle must be in [-3,1]')
Xend
X
X% Infinite vertices
Xif ~strcmp(type,'de')
X  if any(isinf(w(~atinf))) | any(~isinf(w(atinf)))
X    error('Infinite vertices must correspond to angle <= -1')
X  elseif any(diff(find(atinf))==1)
X    error('Infinite vertices must not be adjacent')
X  end
X  sumb = -2;
Xelse
X  if any(atinf) | any(isinf(w))
X    error('Infinite vertices not allowed in exterior mapping')
X  end
X  sumb = 2;
Xend
X
X% Orientation conventions
Xif abs(sum(beta)+sumb) < 1e-9
X  fprintf('\nVertices were probably given in wrong order\n')
X  err = 1;
Xelseif abs(sum(beta)-sumb) > 1e-9
X  fprintf('\nWarning: Angles do not sum to %d\n\n',sumb)
X  err = 2;
Xend
X
X% Some finer points
Xif strcmp(type,'hp') | strcmp(type,'d')
X  if n < 3
X    error('Polygon must have at least three vertices')
X  elseif any(isinf(w([1,2,n-1])))
X    fprintf('\nInfinite vertices must not be at positions 1, 2, or n-1\n')
X    err = 1;
X  elseif any(abs(beta(n)-[0,1])<eps)
X    fprintf('\nSides adjacent to w(n) must not be collinear\n')
X    err = 1;
X  end
Xelseif strcmp(type,'de')
X  if n < 2
X    error('Polygon must have at least two vertices')
X  elseif (beta(n)==0 | beta(n)==1) & (n > 2)
X    fprintf('\nSides adjacent to w(n) must not be collinear\n')
X    err = 1;
X  end
Xelseif strcmp(type,'st')
X  if n < 5
X    error('Polygon must have at least five vertices')
X  end
X  ends = aux;
X  renum = [ends(1):n,1:ends(1)-1];
X  w = w(renum);
X  beta = beta(renum);
X  k = find(renum==ends(2));
X  if any(atinf([2,3,n]))
X    fprintf('\nVertices at (w(ends(1)) + [1,2,-1]) must be finite\n')
X    err = 1;
X  elseif k-2 < 2
X    fprintf('\nThere must be at least 2 vertices between ends 1 and 2\n')
X    err = 1;
X  elseif k==n
X    fprintf('\nThere must be at least one vertex between ends 2 and 1\n')
X    err = 1;
X  end
Xelseif strcmp(type,'r')
X  corner = aux;
X  renum = [corner(1):n,1:corner(1)-1];
X  w = w(renum);
X  beta = beta(renum);
X  corner = rem(corner-corner(1)+1+n-1,n)+1;
X  if n < 4
X    error('Polygon must have at least four vertices')
X  elseif corner~=sort(corner)
X    error('Corners must be specified in ccw order')
X  elseif isinf(w(1))
X    error('Corner(1) must be finite')
X  end
X  if isinf(w(2))
X    fprintf('\nVertex corner(1)+1 must be finite\n')
X    err = 1;
X  end
X  if any(abs(beta(n)-[0,1])<eps)
X    fprintf('\nSides adjacent to w(corner(1)-1) must not be collinear\n')
X    err = 1;
X  end
X   
Xend
X
END_OF_FILE
if test 3348 -ne `wc -c <'sccheck.m'`; then
    echo shar: \"'sccheck.m'\" unpacked with wrong size!
fi
chmod +x 'sccheck.m'
# end of 'sccheck.m'
fi
if test -f 'scdemo.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scdemo.m'\"
else
echo shar: Extracting \"'scdemo.m'\" \(451 characters\)
sed "s/^X//" >'scdemo.m' <<'END_OF_FILE'
X%	  * Schwarz-Christoffel Toolbox demonstrations *
X%
X%		1)  Tutorial
X%		2)  Infinite vertices
X%               3)  Elongated polygons
X%		4)  Faber polynomials
X%
X%		0)  Quit
X%
X%    Warning: All current workspace variables will be lost.
Xecho off
X
Xwhile 1
X  demos = str2mat('tutdemo','infdemo','elongdemo','faberdemo');
X  clc
X  help scdemo
X  n = input('Select a demo number: ');
X  if ((n <= 0) | (n > 4)) 
X    break
X  end
X  eval(demos(n,:))
X  clear
Xend
X
X
END_OF_FILE
if test 451 -ne `wc -c <'scdemo.m'`; then
    echo shar: \"'scdemo.m'\" unpacked with wrong size!
fi
chmod +x 'scdemo.m'
# end of 'scdemo.m'
fi
if test -f 'scfix.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scfix.m'\"
else
echo shar: Extracting \"'scfix.m'\" \(4880 characters\)
sed "s/^X//" >'scfix.m' <<'END_OF_FILE'
Xfunction [w,beta,aux] = scfix(type,w,beta,aux)
X%SCFIX  Fix polygon to meet Schwarz-Christoffel toolbox constraints.
X%	
X%	[W,BETA] = SCFIX(TYPE,W,BETA) attempts to fix a problem in the
X%	given polygon that arises from the posing of the parameter
X%	problem.  SCFIX is used when a call to xxPARAM results in an
X%	error and so advises.  In this case the polygon as given
X%	violates some fairly arbitrary constraint.  SCFIX remedies the
X%	situation by renumbering the vertices, or, if necessary, adding
X%	a trivial (zero-turn) vertex.  TYPE is one of
X%	{'hp','d','de','st','r'}.  If one additional input and output
X%	argument is given, it represents the indices of the strip ends
X%	or the rectangle corners.
X%	
X%       See also SCCHECK, SCADDVTX.
X% 
X%	Written by Toby Driscoll.  Last modified 5/31/95.
X
X%	You may wonder, why not let the xxPARAM functions call SCFIX
X%	automatically?  The trouble with that approach is that since a
X%	function can't modify its inputs in the calling workspace,
X%	either the xxPARAM functions would have to return more
X%	arguments, or the mapping and plotting functions also would have
X%	to detect and correct the problem every time they're called.
X%	The problem is rare enough that this method seems adequate.
X
Xw = w(:);
Xbeta = beta(:);
Xn = length(w);
Xrenum = 1:n;
X
X% Orientation conventions
Xsumb = -2 + 4*strcmp(type,'de');
Xif abs(sum(beta)+sumb) < 1e-9
X  % Reverse order
X  w = w([1,n:-1:2]);
X  beta = scangle(w);
X  renum = renum([1,n:-1:2]);
Xend
X
X% Less obvious restrictions
Xif strcmp(type,'hp') | strcmp(type,'d')
X  shift = [2:n,1];
X  % Renumber, if necessary, to meet requirements:
X  %   w([1,2,n-1]) finite & sides at w(n) not collinear
X  while any(isinf(w([1,2,n-1]))) | any(abs(beta(n)-[0,1])<eps)
X    renum = renum(shift);
X    w = w(shift);
X    beta = beta(shift);
X    if renum(1)==1 			% tried all orderings
X      % First, be sure beta(n) is no longer a problem.
X      if all((abs(beta-1)<eps)|(abs(beta)<eps))
X	error('Polygon has empty interior!')
X      end
X      while any(abs(beta(n)-[0,1])<eps)
X	w = w(shift);
X	beta = beta(shift);
X      end
X      % Next, add one or two vertices as needed.
X      if any(isinf(w(1:2)))
X	[w,beta] = scaddvtx(w,beta,1);
X	n = n+1;
X      end
X      if isinf(w(n-1))
X	[w,beta] = scaddvtx(w,beta,n-1);
X	n = n+1;
X      end
X      renum = 1:n;
X      fprintf('\nWarning: A vertex has been added.\n\n')
X      break
X    end
X  end
Xelseif strcmp(type,'de')
X  shift = [2:n,1];
X  % Renumber, if necessary, to ensure sides at w(n) not collinear
X  %   (except if n==2, which is handled explicitly anyway)
X  while any(abs(beta(n)-[0,1])<eps) & (n > 2)
X    renum = renum(shift);
X    w = w(shift);
X    beta = beta(shift);
X    if renum(1)==1
X      deg = abs(beta) < eps;
X      w(deg) = [];
X      beta(deg) = [];
X      renum = 1:2;
X      n = 2;
X      fprintf('\nPolygon is a line segment; removing superfluous vertices\n\n')
X      break
X    end
X  end
Xelseif strcmp(type,'st')
X  ends = aux;
X  if isempty(ends)
X    disp('Use mouse to select images of left and right ends of the strip.')
X    figure(gcf)
X    ends = scselect(w,beta,2);
X  end
X  renum = [ends(1):n,1:ends(1)-1];
X  w = w(renum);
X  beta = beta(renum);
X  k = find(renum==ends(2));
X  if k < 4
X    if k < n-1
X      % Switch ends.
X      renum = [k:n,1:k-1];
X      w = w(renum);
X      beta = beta(renum);
X      k = find(renum==1);
X    else
X      % Add one or two vertices.
X      for j=1:4-k
X	[w,beta] = scaddvtx(w,beta,j);
X	n = n+1;
X	k = k+1;
X	fprintf('\nWarning: A vertex has been added.\n\n')
X      end
X    end
X  end
X  
X  if k==n
X    % Must add a vertex in any case.
X    [w,beta] = scaddvtx(w,beta,n);
X    n = n+1;
X    fprintf('\nWarning: A vertex has been added.\n\n')
X  end      
X
X  
X  if isinf(w(2))
X    % Add two vertices.
X    for j=1:2
X      [w,beta] = scaddvtx(w,beta,j);
X      n = n+1;
X      k = k+1;
X      fprintf('\nWarning: A vertex has been added.\n\n')
X    end
X  elseif isinf(w(3))
X    % Add one vertex.
X    [w,beta] = scaddvtx(w,beta,2);
X    n = n+1;
X    k = k+1;
X    fprintf('\nWarning: A vertex has been added.\n\n')
X  elseif isinf(w(n))
X    [w,beta] = scaddvtx(w,beta,n);
X    n = n+1;
X    fprintf('\nWarning: A vertex has been added.\n\n')
X  end
X  
X  aux = [1,k];
X
Xelseif strcmp(type,'r')
X  corner = aux;
X  renum = [corner(1):n,1:corner(1)-1];
X  w = w(renum);
X  beta = beta(renum);
X  corner = rem(corner-corner(1)+1+n-1,n)+1;
X  % Note: These problems are pretty rare.
X  if any(abs(beta(n)-[0,1])<eps)
X    % Try swapping sides 1-2 and 3-4.
X    if ~any(abs(beta(corner(3)-1)-[0,1])<eps) & ~isinf(w(corner(3)))
X      renum = [corner(3):n,1:corner(3)-1];
X      w = w(renum);
X      beta = beta(renum);
X      corner = sort(rem(corner-corner(3)+1+n-1,n)+1);
X    else
X      error('Collinear sides make posing problem impossible')
X    end
X  end
X  if isinf(w(2))
X    [w,beta] = scaddvtx(w,beta,1);
X    n = n+1;
X    corner(2:4) = corner(2:4)+1;
X  end
X
X  aux = corner;
Xend
END_OF_FILE
if test 4880 -ne `wc -c <'scfix.m'`; then
    echo shar: \"'scfix.m'\" unpacked with wrong size!
fi
chmod +x 'scfix.m'
# end of 'scfix.m'
fi
if test -f 'scgenable.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scgenable.m'\"
else
echo shar: Extracting \"'scgenable.m'\" \(754 characters\)
sed "s/^X//" >'scgenable.m' <<'END_OF_FILE'
Xfunction scgenable(fig,type,action)
X%SCGENABLE Enables/disables menus in the SCM Toolbox GUI.
X%	Menu items created by SCGUI are at times disabled, when they
X%	appear to have no current meaning.  However, if you use SCGSET,
X%	conditions may change.  SCGENABLE(FIG,TYPE,ACTION) will change
X%	the status of a class(es) of menus.  TYPE is an integer.
X%	Generally, TYPE=1 is on when a polygon is known to the GUI, and
X%	TYPE=2 is on when a parameter problem solution is known.  ACTION
X%	is either 'on' or 'off'.
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
X%       This whole mechanism could be a lot friendlier.
X
Xmenus = get(fig,'userdata');
Xfor i = 1:length(type);
X  for j = find(menus(:,2)==type(i))
X    set(menus(j,1), 'enable',action)
X  end
Xend
END_OF_FILE
if test 754 -ne `wc -c <'scgenable.m'`; then
    echo shar: \"'scgenable.m'\" unpacked with wrong size!
fi
chmod +x 'scgenable.m'
# end of 'scgenable.m'
fi
if test -f 'scgget.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scgget.m'\"
else
echo shar: Extracting \"'scgget.m'\" \(1941 characters\)
sed "s/^X//" >'scgget.m' <<'END_OF_FILE'
Xfunction [val1,val2,val3,val4,val5] = scgget(fig,p1,p2,p3,p4,p5)
X%SCGGET Get data from the SC Toolbox GUI.
X%	SCGGET(FIG,'property') returns the value of the specified property
X%	associated with the Schwarz-Christoffel Toolbox GUI in
X%	figure FIG.  The properties are:
X%	
X%	   vertices    (polygon vertices)
X%	   angles      (turning angles)
X%	   prevertices (solution of parameter problem)
X%	   constant    (multiplicative constant)
X%	   maptype     ('hp2p', 'd2p', 'd2ep', 'st2p', 'r2p')
X%	
X%	Only the first three characters need be specified.  If additional
X%	property names are given, values will be returned in additional
X%	output arguments in the same order.
X%	
X%	SCGGET(FIG) is shorthand for SCGGET(FIG,'ver','ang','pre','con',...
X%	'map').
X%
X%       See also SCGSET, SCGUI.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
X
Xif nargin==1
X  p1 = 'ver';
X  p2 = 'ang';
X  p3 = 'pre';
X  p4 = 'con';
X  p5 = 'map';
X  nargin = 6;
Xelseif nargout~=(nargin-1) & nargout~=0
X  error('Incorrect number of output parameters.')
Xend
X
Xmaptypes = str2mat('hp2p','d2p','d2ep','st2p','r2p');
X
Xmenus = get(fig,'userdata');
Xdata = get(menus(1,1),'userdata');
X[n,p] = size(data);
Xif p==0
X  return
Xend
X
Xw = data(:,1);
Xif ~any(w), w = []; end;
Xbeta = [];
Xz = [];
Xc = [];
Xmapnum = 0;
Xif p > 1
X  beta = data(:,2);
X  if ~any(beta), beta = []; end
X  if p > 2
X    z = data(:,3);
X    if ~any(z), z = []; end
X    if p > 3
X      c = data(1,4);
X      if ~any(c), c = []; end
X      mapnum = data(2,4);
X    end
X  end
Xend
X
Xfor k = 1:(nargin-1)
X  prop = eval(['p',int2str(k)]);
X  if strcmp(lower(prop(1:3)),'ver')
X    val = w;
X  elseif strcmp(lower(prop(1:3)),'ang')
X    val = beta;
X  elseif strcmp(lower(prop(1:3)),'pre')
X    val = z;
X  elseif strcmp(lower(prop(1:3)),'con')
X    val = c;
X  elseif strcmp(lower(prop(1:3)),'map')
X    if ~mapnum
X      val = [];
X    else
X      val = deblank(maptypes(mapnum,:));
X    end
X  end
X  eval(['val',int2str(k),' = val;']);
Xend
X
X
X
END_OF_FILE
if test 1941 -ne `wc -c <'scgget.m'`; then
    echo shar: \"'scgget.m'\" unpacked with wrong size!
fi
chmod +x 'scgget.m'
# end of 'scgget.m'
fi
if test -f 'scgprops.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scgprops.m'\"
else
echo shar: Extracting \"'scgprops.m'\" \(335 characters\)
sed "s/^X//" >'scgprops.m' <<'END_OF_FILE'
Xfunction [trace,tol,v1,v2] = scgprops(fig)
X%SCGPROPS (not intended for calling directly by the user)
X%	Read current values from SCGUI Properties window.
X%	
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
Xmenus = get(fig,'user');
Xprops = get(menus(4,1),'user');
Xtrace = props(3);
Xtol = 10^(-props(4));
Xv1 = props(5);
Xv2 = props(6);
END_OF_FILE
if test 335 -ne `wc -c <'scgprops.m'`; then
    echo shar: \"'scgprops.m'\" unpacked with wrong size!
fi
chmod +x 'scgprops.m'
# end of 'scgprops.m'
fi
if test -f 'scgset.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scgset.m'\"
else
echo shar: Extracting \"'scgset.m'\" \(2125 characters\)
sed "s/^X//" >'scgset.m' <<'END_OF_FILE'
Xfunction scgset(fig,p1,v1,p2,v2,p3,v3,p4,v4,p5,v5)
X%SCGSET Set data in the SCM Toolbox GUI.
X%	SCGSET(FIG,'property',VALUE) sets the value of the specified
X%	property to VALUE in the Schwarz-Christoffel Mapping Toolbox GUI in
X%	igure FIG.  Valid properties are:
X%	
X%	   vertices    (polygon vertices)
X%	   angles      (turning angles)
X%	   prevertices (solution of parameter problem)
X%	   constant    (multiplicative constant)
X%	   maptype     ('hp2p', 'd2p', 'd2ep', 'st2p', 'r2p')
X%	
X%	Only the first three characters need be specified.  If additional
X%	property name-value pairs are given, they will be set appropriately.
X%	
X%	SCGSET(FIG,'clear') removes all data associated with the GUI.
X%
X%	See also SCGGET, SCGUI.
X%	
X%	Written by Toby Driscoll.  Last updated 5/26/95.
X
Xmaptypes = str2mat('hp2p','d2p','d2ep','st2p','r2p');
X
Xmenus = get(fig,'userdata');
X
Xif (nargin==2) & strcmp(lower(p1),'clear')
X  set(menus(1,1),'userdata',[]);
X  return
Xend
X
Xif rem(nargin,2) ~= 1
X  error('Wrong number of input parameters.')
Xend
Xdata = get(menus(1,1),'userdata');
X
Xfor k = 1:(nargin-1)/2
X  prop = eval(['p',int2str(k)]);
X  if ~isstr(prop)
X    error('Property name expected.')
X  else
X    prop = lower(prop);
X  end
X  val = eval(['v',int2str(k)]);
X  if isempty(val)
X    if strcmp(prop(1:3),'con')  
X      val = 0;
X    elseif ~strcmp(prop(1:3),'map')
X      val = zeros(size(data(:,1)));
X    end
X  end
X      
X  if strcmp(prop(1:3),'ver')
X    data = [];
X    data(1:length(val),1) = val(:);
X  elseif strcmp(prop(1:3),'ang')
X    data(1:length(val),2) = val(:);
X  elseif strcmp(prop(1:3),'pre')
X    data(1:length(val),3) = val(:);
X  elseif strcmp(prop(1:3),'con')
X    if length(val) > 1
X      error('Invalid value for property ''constant''.')
X    end
X    data(1,4) = val;
X  elseif strcmp(prop(1:3),'map')
X    found = 0;
X    [m,n] = size(maptypes);
X    for j = 1:m
X      if strcmp(lower(val),deblank(maptypes(j,:)))
X	data(2,4) = j;
X	found = 1;
X	break
X      end
X    end
X    if ~found & ~isempty(val)
X      error(['Map type ',val,' unknown.'])
X    end
X  else
X    error(['Property ',prop,' unknown.'])
X  end
Xend
X
Xset(menus(1,1),'userdata',data);
X
END_OF_FILE
if test 2125 -ne `wc -c <'scgset.m'`; then
    echo shar: \"'scgset.m'\" unpacked with wrong size!
fi
chmod +x 'scgset.m'
# end of 'scgset.m'
fi
if test -f 'scgui.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scgui.m'\"
else
echo shar: Extracting \"'scgui.m'\" \(2741 characters\)
sed "s/^X//" >'scgui.m' <<'END_OF_FILE'
Xfunction scgui(fig)
X%SCGUI  Create graphical user interface for SCM Toolbox.
X%
X%	By itself, SCGUI creates the graphical user interface (GUI)
X%	menus for the Schwarz-Christoffel Toolbox in the current
X%	figure window.
X%
X%	SCGUI(FIG) creates the GUI in figure window FIG.
X%
X%	Use of the GUI is straightforward.  For complete details, see
X%	the user's guide.
X%
X%       See also SCGGET, SCGSET.
X%
X%	Written by Toby Driscoll.  Last updated 5/31/95.
X
Xif nargin < 1
X  fig = gcf;
Xend
Xfigure(fig)
Xclf
Xreset(fig)
X
X% menus: column 1 holds menu handles, col 2 is menu group id:
X%   0: always available
X%   1: available if a polygon has been input
X%   2: available if parameter problem has been solved
X
Xmenus = zeros(30,2);
X
Xmenus(1) = uimenu('label','Schwarz-Christoffel');
X
Xmenus(4) = uimenu(menus(1), 'label','Properties...',...
X    'call','scguicb(''prop'')','user',[-1,fig,0,8,10,10]);
Xmenus(2) = uimenu(menus(1),'label','Draw new polygon',...
X    'separator','on','call','scguicb(''draw'')','interrupt','yes');
Xmenus(5) = uimenu(menus(1),'label','Modify polygon',...
X    'call','scguicb(''modify'')','interrupt','yes');
Xmenus(3) = uimenu(menus(1),'label','Load data file...',...
X    'call','scguicb(''load'')','interrupt','yes');
Xmenus(5,2) = 1;
X
Xmenus(10) = uimenu(menus(1),'label','Save data file...',...
X    'call','scguicb(''save'')','interrupt','yes');
X
Xmenus(12) = uimenu(menus(1),'label','Solve parameter problem',...
X    'separator','on');
Xmenus(13) = uimenu(menus(12), 'label','half plane -> polygon', ...
X    'call','scguicb(''hp2p'')','interrupt','yes');
Xmenus(14) = uimenu(menus(12), 'label','disk -> polygon', ...
X    'call','scguicb(''d2p'')','interrupt','yes');
Xmenus(15) = uimenu(menus(12), 'label','disk -> exterior polygon', ...
X    'call','scguicb(''d2ep'')','interrupt','yes');
Xmenus(16) = uimenu(menus(12), 'label','strip -> polygon', ...
X    'call','scguicb(''st2p'')','interrupt','yes');
Xmenus(17) = uimenu(menus(12), 'label','rectangle -> polygon', ...
X    'call','scguicb(''r2p'')','interrupt','yes');
Xmenus(18) = uimenu(menus(12), 'label','continuation', ...
X    'call','scguicb(''contin'')','interrupt','yes');
Xmenus([10,12:17],2) = ones(7,1);
Xmenus(18,2) = 2;
X
Xmenus(20) = uimenu(menus(1),'label','Display results', ...
X    'call','scguicb(''disp'')', 'enable','off','interrupt','yes');
Xmenus(21) = uimenu(menus(1),'label','Plot grid image',...
X    'call','scguicb(''plot'')', 'enable','off','interrupt','yes');
Xmenus(20:21,2) = 2*ones(2,1);
X
Xmenus(22) = uimenu(menus(1), 'label','Point source',...
X    'call', 'scguicb(''source'')');
Xmenus(22,2) = 2;
X
X% Save menus in figure userdata.
Xset(fig,'userdata',menus);
X
X% Force compilation of scguicb to speed up later.
Xif 0, scguicb('draw'), end
X
Xscgenable(fig,1:2,'off');
X
X
END_OF_FILE
if test 2741 -ne `wc -c <'scgui.m'`; then
    echo shar: \"'scgui.m'\" unpacked with wrong size!
fi
chmod +x 'scgui.m'
# end of 'scgui.m'
fi
if test -f 'scguicb.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scguicb.m'\"
else
echo shar: Extracting \"'scguicb.m'\" \(8897 characters\)
sed "s/^X//" >'scguicb.m' <<'END_OF_FILE'
Xfunction scguicb(func)
X%SCGUICB (not intended for calling directly by the user)
X%       Callback function for SCGUI.
X%
X%	Written by Toby Driscoll.  Last updated 5/31/95.
X
Xfig = gcf;
Xmaptypes = str2mat('hp2p','d2p','d2ep','st2p','r2p');
Xprefixes = str2mat('hp','d','de','st','r');
X
Xif strcmp(func,'draw')			%** draw new polygon
X  scgset(fig, 'clear');
X  % If drawpoly dies, clear the figure's callbacks.
X  errfun = ['set(fig,''windowbuttondownfcn'',''''),',...
X          'set(fig,''windowbuttonmotionfcn'',''''),',...
X          'set(fig,''windowbuttonupfcn'',''''),',...
X          'set(fig,''keypressfcn'',''''),',...
X          'return'];
X  w = [];
X  beta = [];
X  eval('[w,beta] = drawpoly(fig);',errfun);
X  scgset(fig,'vertices',w,'angles',beta)
X  scgenable(fig,2,'off');
X  scgenable(fig,1,'on');
X  
Xelseif strcmp(func,'modify')		%** modify polygon
X  [w,beta] = scgget(fig,'ver','ang');
X  [w,beta] = modpoly(w,beta);
X  scgset(fig,'ver',w,'ang',beta)
X  scgenable(fig,2,'off')
X
Xelseif strcmp(func,'load') 		%** load data file
X  [fname,pname] = uigetfile('*.mat','Load S-C data file');
X  if fname
X    w = []; beta = []; z = []; c = []; maptype = [];
X    eval(['load ',pname,fname]);
X    scgset(fig, 'clear');
X    scgset(fig,'ver',w,'ang',beta,'pre',z,'con',c,'map',maptype);
X    if ~isempty(w)
X      scgenable(fig,1,'on');
X      hold off
X      plotpoly(w,beta);
X      if ~isempty(z)
X	scgenable(fig,2,'on');
X      else 
X	scgenable(fig,2,'off');
X      end
X    else 
X      scgenable(fig,1,'off');
X    end
X    if strcmp(maptype,'r2p') 		% rectangle is special
X      menus = get(fig,'userdata');
X      set(menus(17),'userdata',L);
X    end
X  end
X
Xelseif strcmp(func,'save')		%** save data file
X  [fname,pname] = uiputfile('*.mat','Save S-C data file');
X  if fname
X    [w,beta,z,c,maptype] = scgget(fig); 
X    evalstr = ['save ',pname,fname,' w beta z c maptype'];
X    if strcmp(maptype,'r2p') 		% rectangle is special
X      menus = get(fig,'userdata');
X      L= get(menus(17),'userdata');
X      evalstr = [evalstr,' L'];
X    end
X    eval(evalstr);
X  end
X
Xelseif strcmp(func,'hp2p') 		%** half plane -> polygon
X  [w,beta] = scgget(fig, 'vertices','angles');
X  [w,beta] = scfix('hp',w,beta);
X  scgset(fig,'ver',w,'ang',beta)
X  disp('Solving parameter problem...')
X  [trace,tol,v1,v2] = scgprops(fig);
X  [x,c] = hpparam(w,beta,[],[trace,tol]);
X  disp('Finished parameter problem.')
X  scgset(fig, 'prevertices',x, 'const',c, 'maptype','hp2p')
X  scgenable(fig,2,'on');
X  
Xelseif strcmp(func,'d2p')		%** disk -> polygon
X  [w,beta] = scgget(fig, 'vertices','angles');
X  [w,beta] = scfix('d',w,beta);
X  scgset(fig,'ver',w,'ang',beta)
X  disp('Solving parameter problem...')
X  [trace,tol,v1,v2] = scgprops(fig);
X  [z,c] = dparam(w,beta,[],[trace,tol]);
X  disp('Finished parameter problem.')
X  scgset(fig, 'prevertices',z, 'const',c, 'maptype','d2p')
X  scgenable(fig,2,'on');
X
Xelseif strcmp(func,'d2ep')		%** disk -> exterior polygon
X  [w,beta] = scgget(fig, 'vertices','angles');
X  [w,beta] = scfix('de',w,beta);
X  scgset(fig,'ver',w,'ang',beta)
X  disp('Solving parameter problem...')
X  [trace,tol,v1,v2] = scgprops(fig);
X  [z,c] = deparam(w,beta,[],[trace,tol]);
X  disp('Finished parameter problem.')
X  scgset(fig, 'prevertices',z, 'const',c, 'maptype','d2ep')
X  scgenable(fig,2,'on');
X
Xelseif strcmp(func,'st2p')		%** strip -> polygon
X  [w,beta] = scgget(fig, 'vertices','angles');
X  disp('Use mouse to select images of left and right ends of the strip.')
X  figure(gcf)
X  ends = scselect(w,beta,2);
X  [w,beta,ends] = scfix('st',w,beta,ends);
X  scgset(fig,'ver',w,'ang',beta)
X  disp('Solving parameter problem...')
X  [trace,tol,v1,v2] = scgprops(fig);
X  [z,c] = stparam(w,beta,ends,[],[trace,tol]);
X  disp('Finished parameter problem.')
X  scgset(fig, 'prevertices',z, 'const',c, 'maptype','st2p')
X  scgenable(fig,2,'on');
X
Xelseif strcmp(func,'r2p')		%** rectangle -> polygon
X  [w,beta] = scgget(fig, 'vertices','angles');
X  disp('Use mouse to select images of rectangle corners.')
X  disp('Go in counterclockwise order and select a long edge first.')
X  figure(gcf)
X  corner = scselect(w,beta,4);
X  [w,beta,corner] = scfix('r',w,beta,corner);
X  scgset(fig,'ver',w,'ang',beta)
X  disp('Solving parameter problem...')
X  [trace,tol,v1,v2] = scgprops(fig);
X  [z,c,L] = rparam(w,beta,corner,[],[trace,tol]);
X  disp('Finished parameter problem.')
X  scgset(fig, 'prevertices',z, 'const',c, 'maptype','r2p')
X  menus = get(fig,'userdata');
X  set(menus(17),'userdata',L)
X  scgenable(fig,2,'on');
X
Xelseif strcmp(func,'contin')		%** continuation
X  [w,beta,z,c,maptype] = scgget(fig);
X  n = length(w);
X  [w,beta,idx] = modpoly(w,beta);
X  if any(isnan(idx)) | any(diff([0;idx;n+1])~=1)
X    fprintf('\nCannot continue after vertices have been added or deleted.\n')
X    fprintf('Use direct solution instead.\n')
X    scgset(fig,'ver',w,'ang',beta)
X    scgenable(fig,2,'off')
X    return
X  end
X  z0 = z;
X  [trace,tol,v1,v2] = scgprops(fig);
X  disp('Solving parameter problem...')
X  if strcmp(maptype,'r2p')
X    menus = get(fig,'userdata');
X    L= get(menus(17),'userdata');
X    [w,beta,z0,corners] = rcorners(w,beta,z0);
X    z0 = r2strip(z0,z,L);
X    [z,c,L] = rparam(w,beta,corners,z0,[trace,tol]);
X    set(menus(17),'userdata',L)
X  elseif strcmp(maptype,'st2p')
X    ends = [find(isinf(z0)&(z0<0)),find(isinf(z0)&(z0>0))];
X    [z,c] = stparam(w,beta,ends,z0,[trace,tol]);
X  else
X    m = size(maptypes,1);
X    for j = 1:m 			% find correct prefix
X      if strcmp(maptype,deblank(maptypes(j,:)))
X	eval(['[z,c]=',...
X		deblank(prefixes(j,:)),'param(w,beta,z0,[trace,tol]);']);
X	break
X      end
X    end  
X  end
X  disp('Finished parameter problem.')
X  scgset(fig,'ver',w,'ang',beta,'pre',z,'const',c,'map',maptype)
X  
Xelseif strcmp(func,'disp') 		%** pretty print
X  [w,beta,z,c,maptype] = scgget(fig);
X  m = size(maptypes,1);
X  if strcmp(maptype,'r2p')   % rectangle is special
X    menus = get(fig,'userdata');
X    L= get(menus(17),'userdata');
X    rdisp(w,beta,z,c,L);
X  else
X    for j = 1:m 			% find correct prefix
X      if strcmp(maptype,deblank(maptypes(j,:)))
X	eval([deblank(prefixes(j,:)),'disp(w,beta,z,c)']);
X	break
X      end
X    end  
X  end
X  
Xelseif strcmp(func,'plot') 		%** plot images of grid
X  [w,beta,z,c,maptype] = scgget(fig,'ver','ang','pre','con','map');
X  [trace,tol,v1,v2] = scgprops(fig);
X  if strcmp(maptype,'r2p')
X    menus = get(fig,'userdata');
X    L =get(menus(17),'userdata');
X    rplot(w,beta,z,c,L,v1,v2)
X  else
X    m = size(maptypes,1);
X    for j = 1:m 			% find correct prefix
X      if strcmp(maptype,deblank(maptypes(j,:)))
X	eval([deblank(prefixes(j,:)),'plot(w,beta,z,c,v1,v2)']);
X	break
X      end
X    end
X  end
X  disp('Finished plot.')
X
Xelseif strcmp(func,'source')		%** point source
X  [w,beta,z,c,mtype] = scgget(fig);
X  [trace,tol,v1,v2] = scgprops(fig);
X  if strcmp(mtype,'hp2p')
X    [z,c] = hp2disk(w,beta,z,c);
X    mtype = 'd2p';
X  end
X  if strcmp(mtype,'d2p')
X    ptsource(w,beta,z,c,[],v1,v2);
X  else
X    ptsource(w,beta,[],[],[],v1,v2);
X  end
X  
Xelseif strcmp(func,'prop')		%** Properties window
X  menus = get(fig,'userdata');
X  data = get(menus(4,1),'userdata');
X  propfig = data(1);
X  deleted = 0;
X  eval('get(propfig,''pos'');','deleted=1;');
X  if deleted
X    screen = get(0,'screensize');
X    pos = [100, screen(4)-210, 300,200];
X    propfig = figure('numbertitle','off','name','SC Properties','pos',pos);
X    uicontrol('style','frame','units','norm','pos',[0 0 1 1]);
X    uicontrol('style','push','pos',[120,10,60,20],'string','Done',...
X	'call','set(gcf,''vis'',''off'')')
X    uicontrol('style','check','pos',[20,170,260,20],...
X	'string','Trace parameter problem solution',...
X	'call','scguicb(''pr_01'')','value',data(3));
X    uicontrol('style','text','pos',[20,140,120,20],...
X	'string','Error tolerace: 1e-');
X    uicontrol('style','edit','pos',[143,140,20,20],...
X	'string',int2str(data(4)),'call','scguicb(''pr_02'')');
X    uicontrol('style','text','pos',[20,110,160,20],...
X	'string','Number of curves to plot:');
X    uicontrol('style','text','pos',[60,85,103,20],...
X	'string','vertical/circular:');
X    uicontrol('style','edit','pos',[170,85,20,20],...
X	'string',int2str(data(5)),'call','scguicb(''pr_03'')');
X    uicontrol('style','text','pos',[60,60,105,20],...
X	'string','horizontal/radial:');
X    uicontrol('style','edit','pos',[170,60,20,20],...
X	'string',int2str(data(6)),'call','scguicb(''pr_04'')');
X    set(menus(4,1),'userdata',[propfig,data(2:6)]);
X    set(propfig,'user',[propfig,data(2:6)]);
X    drawnow
X  else
X    set(propfig,'vis','on')
X    figure(propfig)
X  end
X  
Xelseif strcmp(func(1:3),'pr_')		%** set properties
X  data = get(gcf,'user');
X  propfig = data(1);
X  fig = data(2);
X  propnum = eval(func(4:5));
X  ctrl = get(propfig,'currentobject');
X  if propnum==1,
X    data(3) = get(ctrl,'value');
X  else 
X    data(2+propnum) = eval(get(ctrl,'string'));
X  end
X  set(propfig,'user',data);
X  menus = get(fig,'user');
X  set(menus(4,1),'user',data)
X    
X  
X  
Xend
X
X  
X
X
END_OF_FILE
if test 8897 -ne `wc -c <'scguicb.m'`; then
    echo shar: \"'scguicb.m'\" unpacked with wrong size!
fi
chmod +x 'scguicb.m'
# end of 'scguicb.m'
fi
if test -f 'scimapopt.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scimapopt.m'\"
else
echo shar: Extracting \"'scimapopt.m'\" \(818 characters\)
sed "s/^X//" >'scimapopt.m' <<'END_OF_FILE'
Xfunction [ode,newton,tol,maxiter] = scimapopt(options)
X%SCIMAPOPT Parameters used by S-C inverse-mapping routines.
X%       OPTIONS(1): Algorithm (default 0)
X%	            0--use ode to get initial guess, then Newton iters.
X%	            1--use ode only
X%	            2--use Newton only; take Z0 as initial guess
X%       OPTIONS(2): Error tolerance for solution (default 1e-8)
X%	OPTIONS(3): Maximum number of Newton iterations (default 10)
X%
X%	See also HPINVMAP, DINVMAP, DEINVMAP, RINVMAP, STINVMAP.
X%	
X%       Written by Toby Driscoll.  Last updated 5/24/95.
X
Xuser = options;
Xlenu = length(user);
Xoptions = zeros(1,3);
Xoptions(1:lenu) = user(1:lenu);
Xoptions = options + (options==0).*[0,1e-8,10];
X
Xode = options(1)==0 | options(1)==1;
Xnewton = options(1)==0 | options(1)==2;
Xtol = options(2);
Xmaxiter = options(3);
X
END_OF_FILE
if test 818 -ne `wc -c <'scimapopt.m'`; then
    echo shar: \"'scimapopt.m'\" unpacked with wrong size!
fi
chmod +x 'scimapopt.m'
# end of 'scimapopt.m'
fi
if test -f 'scimapz0.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scimapz0.m'\"
else
echo shar: Extracting \"'scimapz0.m'\" \(4424 characters\)
sed "s/^X//" >'scimapz0.m' <<'END_OF_FILE'
Xfunction [z0,w0] = scimapz0(prefix,wp,w,beta,z,c,qdat,aux)
X%SCIMAPZ0 (not intended for calling directly by the user)
X%       SCIMAPZ0 returns starting points for computing inverses of
X%       Schwarz-Christoffel maps.
X%
X%	Each wp(j) (in the polygon plane) requires z0(j) (in the
X%	fundamental domain) whose image w0(j) is such that the line
X%	segment from w0(j) to wp(j) lies in the target (interior or
X%	exterior) region.  The algorithm here is to choose z0(j) as a
X%	(weighted) average of successive pairs of adjacent prevertices.
X%	The resulting w0(j) is on a polygon side.  Each choice is tested
X%	by looking for intersections of the segment with (other) sides
X%	of the polygon.
X%
X%	After randomly trying 10 weights with such prevertex pairs, the
X%	routine gives up.  Failures are pretty rare.  Slits are the most
X%	likely cause of trouble, since the intersection method doesn't
X%	know "which side" of the slit it's on.  In such a case you will
X%	have to supply starting points manually, perhaps by a
X%	continuation method.
X%
X%	See also HPINVMAP, DINVMAP, DEINVMAP, RINVMAP, STINVMAP.
X%
X%	Written by Toby Driscoll.  Last updated 7/7/95.
X
X%	P.S. This file illustrates why the different domains in the SC
X%	Toolbox have mostly independent M-files.  The contingencies for
X%	the various geometries become rather cumbersome.
X
Xn = length(w);
Xshape = wp;
Xwp = wp(:);
Xz0 = wp;
Xw0 = wp;
Xfrom_disk = strcmp(prefix(1),'d');
Xfrom_hp = strcmp(prefix,'hp');
Xfrom_strip = strcmp(prefix,'st');
Xfrom_rect = strcmp(prefix,'r');
Xif from_strip
X  kinf = max(find(isinf(z)));
X  argw = cumsum([angle(w(3)-w(2));-pi*beta([3:n,1])]);
X  argw = argw([n,1:n-1]);
Xelse
X  argw = cumsum([angle(w(2)-w(1));-pi*beta(2:n)]);
Xend
Xif from_disk
X  argz = angle(z);
X  argz(argz<=0) = argz(argz<=0) + 2*pi;
Xend
X
Xfactor = 0.5;				% images of midpoints of preverts
Xdone = zeros(1,length(wp));
Xm = length(wp);
Xiter = 0;
X
Xwhile m > 0				% while some not done
X  % Choose a point on each side of the polygon.
X  for j = 1:n 	
X    if from_disk
X      if j<n
X	zbase(j) = exp(i*(factor*argz(j) + (1-factor)*argz(j+1)));
X      else 
X	zbase(j) = exp(i*(factor*argz(n) + (1-factor)*(2*pi+argz(1))));
X      end
X    elseif from_hp
X      if j < n-1			% between two finite points
X	zbase(j) = z(j) + factor*(z(j+1)-z(j));
X      elseif j==n-1			% between x(n-1) & Inf
X	zbase(j) = max(10,z(n-1))/factor;
X      else				% between -Inf and x(1)
X	zbase(j) = min(-10,z(1))/factor;
X      end
X    elseif from_strip
X      if j==1
X	zbase(j) = min(-1,real(z(2)))/factor/4;
X      elseif j==kinf-1
X	zbase(j) = max(1,real(z(kinf-1)))/factor/4;
X      elseif j==kinf
X	zbase(j) = i+max(1,real(z(kinf+1)))/factor/4;
X      elseif j==n
X	zbase(j) = i+min(-1,real(z(n)))/factor/4;
X      else 
X	zbase(j) = z(j) + factor*(z(j+1)-z(j));
X      end
X    elseif from_rect
X      zbase(j) = z(j) + factor*(z(rem(j,n)+1)-z(j));
X    end
X    if ~from_rect
X      wbase(j) = feval([prefix,'map'],zbase(j),w,beta,z,c,qdat);
X    else 
X      wbase(j) = feval([prefix,'map'],zbase(j),w,beta,z,c,qdat,aux);
X    end
X    
X  end
X
X  % Now, cycle thru starting points
X  for j = 1:n 				
X    z0(~done) = ones(m,1)*zbase(j);
X    w0(~done) = ones(m,1)*wbase(j);
X    notdone = find(~done);
X    done = ones(1,length(wp));
X    % Test line segment for intersections with other sides.
X    % We'll parameterize line segment and polygon side, compute parameters
X    % at intersection, and check parameters at intersection.
X    for k=[1:j-1,j+1:n]
X      if isinf(w(k))
X	A(:,1) = [cos(argw(k)+pi);sin(argw(k)+pi)];
X	wk = w(rem(k,n)+1);
X	s1max = Inf;
X      else
X	A(:,1) = [cos(argw(k));sin(argw(k))];
X	wk = w(k);
X	s1max = abs(w(rem(k,n)+1)-w(k));
X      end
X      for p = notdone
X	A(:,2) = [real(w0(p)-wp(p));imag(w0(p)-wp(p))];
X	% Get line segment and side parameters at intersection.
X	s = A\[real(w0(p)-wk);imag(w0(p)-wk)];
X	% Intersection occurs interior to side? and segment? 
X	if s(1)>=0 & s(1)<=s1max 
X	  if abs(s(2)-1) < 30*eps
X	    % Special case: wp(p) is on polygon side k
X	    z0(p) = zbase(k);
X	    w0(p) = wbase(k);
X	  elseif s(2) > -10*eps & s(2) < 1
X	    % Intersection interior to segment: it's no good
X	    done(p) = 0;
X	  end
X	end
X      end
X    end
X    m = sum(~done);
X    if ~m, break, end
X  end
X  if iter > 10
X    error('Can''t seem to choose starting points.  Supply them yourself.')
X  else
X    iter = iter + 1;
X  end
X  factor = rand(1);			% abandon midpoints
Xend
X
Xshape(:) = z0;
Xz0 = shape;
Xshape(:) = w0;
Xw0 = shape;
END_OF_FILE
if test 4424 -ne `wc -c <'scimapz0.m'`; then
    echo shar: \"'scimapz0.m'\" unpacked with wrong size!
fi
chmod +x 'scimapz0.m'
# end of 'scimapz0.m'
fi
if test -f 'scparmopt.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scparmopt.m'\"
else
echo shar: Extracting \"'scparmopt.m'\" \(563 characters\)
sed "s/^X//" >'scparmopt.m' <<'END_OF_FILE'
Xfunction [trace,tol] = scparmopt(options)
X%SCPARMOPT Parameters used by S-C parameter problem routines.
X%       OPTIONS(1): Nonzero causes some intermediate results to be
X%                   displayed (default 0)
X%       OPTIONS(2): Error tolerance for solution (default 1e-8)
X%	
X%	See also HPPARAM, DPARAM, DEPARAM, STPARAM, RPARAM.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xuser = options;
Xlenu = length(user);
Xoptions = zeros(1,2);
Xoptions(1:lenu) = user(1:lenu);
Xoptions = options + (options==0).*[0,1e-8];
X
Xtrace = options(1);
Xtol = options(2);
X
END_OF_FILE
if test 563 -ne `wc -c <'scparmopt.m'`; then
    echo shar: \"'scparmopt.m'\" unpacked with wrong size!
fi
chmod +x 'scparmopt.m'
# end of 'scparmopt.m'
fi
if test -f 'scplotopt.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scplotopt.m'\"
else
echo shar: Extracting \"'scplotopt.m'\" \(1053 characters\)
sed "s/^X//" >'scplotopt.m' <<'END_OF_FILE'
Xfunction [nqpts,maxturn,maxlen,maxrefn] = scplotopt(options)
X%SCPLOTOPT Parameters used by S-C plotting routines.
X%       OPTIONS(1): Number of quadrature points per integration.
X%                   Approximately equals -log10(error).  Increase if plot
X%                   has false little zigzags in curves (default 4). 
X%       OPTIONS(2): Maximum allowed turning angle at each plotted point,
X%                   in degrees (default 12).
X%       OPTIONS(3): Max allowed line segment length, as a proportion of the
X%                   largest finite polygon side (default 0.05).
X%       OPTIONS(4): Max allowed number of adaptive refinements made to meet
X%                   other requirements (default 10).
X%      
X%       See also HPPLOT, DPLOT, DEPLOT, STPLOT, RPLOT.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xuser = options;
Xlenu = length(user);
Xoptions = zeros(1,4);
Xoptions(1:lenu) = user(1:lenu);
Xoptions = options + (options==0).*[4,12,.05,10];
X
Xnqpts = options(1);
Xmaxturn = options(2);
Xmaxlen = options(3);
Xmaxrefn = options(4);
X
END_OF_FILE
if test 1053 -ne `wc -c <'scplotopt.m'`; then
    echo shar: \"'scplotopt.m'\" unpacked with wrong size!
fi
chmod +x 'scplotopt.m'
# end of 'scplotopt.m'
fi
if test -f 'scqdata.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scqdata.m'\"
else
echo shar: Extracting \"'scqdata.m'\" \(928 characters\)
sed "s/^X//" >'scqdata.m' <<'END_OF_FILE'
Xfunction qdat = scqdata(beta,nqpts);
X%SCQDATA Gauss-Jacobi quadrature data for SC Toolbox.
X%       SCQDATA(BETA,NQPTS) returns a matrix of quadrature data suitable
X%       for other SC routines.  BETA is a vector of turning angles
X%       corresponding to *finite* singularities (prevertices and, for
X%       exterior map, the origin).  NQPTS is the number of quadrature
X%       points per subinterval, roughly equal to -log10(error).
X%	
X%	All the SC routines call this routine as needed, and the work
X%	required is small, so you probably never have to call this
X%	function directly.
X%	
X%	See also GAUSSJ, HPPARAM, DPARAM, DEPARAM, STPARAM, RPARAM.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(beta);
Xqnode = zeros(nqpts,n+1);
Xqwght = zeros(nqpts,n+1);
Xfor j = find(beta(:)>-1)'
X  [qnode(:,j),qwght(:,j)] = gaussj(nqpts,0,beta(j));
Xend
X[qnode(:,n+1),qwght(:,n+1)] = gaussj(nqpts,0,0);
Xqdat = [qnode,qwght];
X
END_OF_FILE
if test 928 -ne `wc -c <'scqdata.m'`; then
    echo shar: \"'scqdata.m'\" unpacked with wrong size!
fi
chmod +x 'scqdata.m'
# end of 'scqdata.m'
fi
if test -f 'scselect.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scselect.m'\"
else
echo shar: Extracting \"'scselect.m'\" \(2189 characters\)
sed "s/^X//" >'scselect.m' <<'END_OF_FILE'
Xfunction K = scselect(w,beta,m)
X%SCSELECT Select one or more vertices in a polygon.
X%	K = SCSELECT(W,BETA,M) draws the polygon given by W and BETA
X%	into the current figure window and then allows the user to
X%	select M vertices using the mouse.  If M is not given, it
X%	defaults to 1.  On exit K is a vector of indices into W.
X%
X%       See also DRAWPOLY, PLOTPOLY, MODPOLY.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xn = length(w);
Xif any(isinf(w) & isinf(w([2:n,1])))
X  error('Infinite vertices must not be adjacent')
Xend
X
Xplotpoly(w,beta)
Xturn_off_hold = ~ishold;
Xhold on
X
Xfirst = min(find(~isinf(w) & ~isinf(w([2:n,1]))));
Xrenum = [first:n,1:first-1];
Xw = w(renum);
Xbeta = beta(renum);
X
Xaxlim = axis;
Xmaxdiff = max(diff(axlim(1:2)),diff(axlim(3:4)));
Xaxlim(1:2) = mean(axlim(1:2)) + 0.57*maxdiff*[-1.05,1];
Xaxlim(3:4) = mean(axlim(3:4)) + 0.57*maxdiff*[-1,1];
X    
Xh = zeros(n,2);
Xh(1,1) = plot(real(w(1)),imag(w(1)),'.','mark',22);
Xang = angle(w(2)-w(1));
Xcolrs = get(gca,'colororder');
Xcolr = colrs(1,:);
Xfor j = 2:n
X  if ~isinf(w(j))
X    if ~imag(w(j))
X      w(j) = w(j) + eps*i;
X    end 
X    h(j,1) = plot(w(j),'.','mark',22);
X    ang = ang - pi*beta(j);
X  else
X    for p = 1:2
X      theta = ang + pi*(p==2);
X      base = w(rem(j-2+2*(p==2),n)+1);
X      Rx = (axlim(1:2) - real(base)) / (cos(theta)+eps*(cos(theta)==0));
X      Ry = (axlim(3:4) - imag(base)) / (sin(theta)+eps*(sin(theta)==0));
X      R = [Rx,Ry];
X      wj = base + min(R(R>0))*exp(i*theta);
X      str = sprintf('inf (%i)',renum(j));
X      h(j,p) = text(real(wj),imag(wj),str,'horiz','center',...
X	  'fontsize',14,'fontweight','bold','color',colr);
X      ang = ang - pi*beta(j)*(p==1);
X    end 
X  end 
Xend 
X
Xcolr = colrs(min(2,size(colrs,1)),:);
Xoldptr = get(gcf,'pointer');
Xset(gcf,'pointer','circle');
Xif nargin < 3
X  m = 1;
Xend
Xfor j = 1:m
X  k = [];
X  while isempty(k)
X    waitforbuttonpress;
X    obj = get(gcf,'currentobj');
X    [k,tmp] = find(obj==h);
X    if isempty(k)
X      disp('Selected object not a vertex.  Try again.')
X    end
X  end
X  set(h(k,(h(k,:)>0)),'color',colr)
X  drawnow
X  K(j) = k;
Xend
Xset(gcf,'pointer',oldptr)
X
Xdelete(h(h>0))
Xdrawnow
Xif turn_off_hold
X  hold off
Xend 
X
XK = renum(K);
END_OF_FILE
if test 2189 -ne `wc -c <'scselect.m'`; then
    echo shar: \"'scselect.m'\" unpacked with wrong size!
fi
chmod +x 'scselect.m'
# end of 'scselect.m'
fi
if test -f 'stderiv.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stderiv.m'\"
else
echo shar: Extracting \"'stderiv.m'\" \(1374 characters\)
sed "s/^X//" >'stderiv.m' <<'END_OF_FILE'
Xfunction fprime = stderiv(zp,z,beta,j)
X%STDERIV Derivative of the strip map.
X%	STDERIV(ZP,Z,BETA) returns the derivative at the points of ZP of
X%	the Schwarz-Christoffel strip map whose prevertices are Z and
X%	whose turning angles are BETA.
X%
X%       Don't forget the multiplicative constant in the S-C map!
X%	
X%	See also STPARAM, STMAP.
X%       
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
X%	If a fourth argument j is supplied, the terms corresponding to
X%	z(j) are normalized by abs(zp-z(j)).  This is for Gauss-Jacobi
X%	quadrature.
X
Xlog2 = 0.69314718055994531;
Xfprime = zeros(size(zp));
Xzprow = zp(:).';
Xnpts = length(zprow);
X
X% Strip out infinite prevertices
Xif length(z)==length(beta)
X  ends = find(isinf(z));
X  theta = diff(beta(ends));
X  if z(ends(1)) < 0
X    theta = -theta;
X  end
X  z(ends) = [];
X  beta(ends) = [];
Xelse
X  error('Vector of prevertices must include +/-Inf entries')
Xend
Xzcol = z(:);
Xbcol = beta(:);
Xn = length(z);
X
Xterms = -pi/2*(zprow(ones(n,1),:) - zcol(:,ones(npts,1)));
Xlower = (~imag(z));
Xterms(lower,:) = -terms(lower,:);
Xrt = real(terms);
Xbig = abs(rt) > 40;
Xif any(any(~big))
X  terms(~big) = log(-i*sinh(terms(~big)));
Xend
Xterms(big) = sign(rt(big)).*(terms(big)-i*pi/2) - log2;
Xif nargin==4
X  if j > 0
X    terms(j,:) = terms(j,:)-log(abs(zprow-z(j)));
X  end
Xend
Xfprime(:) = exp(pi/2*theta*zprow + sum(terms.*bcol(:,ones(npts,1))));
X
END_OF_FILE
if test 1374 -ne `wc -c <'stderiv.m'`; then
    echo shar: \"'stderiv.m'\" unpacked with wrong size!
fi
chmod +x 'stderiv.m'
# end of 'stderiv.m'
fi
if test -f 'stdisp.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stdisp.m'\"
else
echo shar: Extracting \"'stdisp.m'\" \(880 characters\)
sed "s/^X//" >'stdisp.m' <<'END_OF_FILE'
Xfunction stdisp(w,beta,z,c)
X%STDISP Display results of Schwarz-Christoffel strip parameter problem.
X%       STDISP(W,BETA,Z,C) displays the results of STPARAM in a pleasant
X%       way.  
X%
X%	See also STPARAM, STPLOT.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xdisp(' ')
Xdisp('          w                beta                  z           ')
Xdisp(' ------------------------------------------------------------')
Xu = real(w);
Xv = imag(w);
Xfor j = 1:length(w)
X  if v(j) < 0
X    s = '-';
X  else
X    s = '+';
X  end
X  if ~imag(z(j))
X    disp(sprintf(' %8.5f %c %7.5fi     %8.5f    %20.12e',...
X      u(j),s,abs(v(j)),beta(j),z(j)));
X  else
X    disp(sprintf(' %8.5f %c %7.5fi     %8.5f    %20.12e + i',...
X      u(j),s,abs(v(j)),beta(j),z(j)));
X  end    
Xend
Xdisp(' ')
Xif imag(c) < 0
X  s = '-';
Xelse
X  s = '+';
Xend
Xdisp(sprintf('  c = %.8g %c %.8gi',real(c),s,abs(imag(c))))
X
END_OF_FILE
if test 880 -ne `wc -c <'stdisp.m'`; then
    echo shar: \"'stdisp.m'\" unpacked with wrong size!
fi
chmod +x 'stdisp.m'
# end of 'stdisp.m'
fi
if test -f 'stimapf1.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stimapf1.m'\"
else
echo shar: Extracting \"'stimapf1.m'\" \(351 characters\)
sed "s/^X//" >'stimapf1.m' <<'END_OF_FILE'
Xfunction zdot = stimapf1(wp,yp);
X%STIMAPF1 (not intended for calling directly by the user)
X%	Used by STINVMAP for solution of an ODE.
X
Xglobal SCIMDATA 
X
Xlenyp = length(yp);
Xlenzp = lenyp/2;
Xzp = yp(1:lenzp)+sqrt(-1)*yp(lenzp+1:lenyp);
Xn = SCIMDATA(1,4);
X
Xf = SCIMDATA(1:lenzp,1)./stderiv(zp,SCIMDATA(1:n,2),SCIMDATA(1:n,3));
Xzdot = [real(f);imag(f)];
END_OF_FILE
if test 351 -ne `wc -c <'stimapf1.m'`; then
    echo shar: \"'stimapf1.m'\" unpacked with wrong size!
fi
chmod +x 'stimapf1.m'
# end of 'stimapf1.m'
fi
if test -f 'stinvmap.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stinvmap.m'\"
else
echo shar: Extracting \"'stinvmap.m'\" \(3439 characters\)
sed "s/^X//" >'stinvmap.m' <<'END_OF_FILE'
Xfunction zp = stinvmap(wp,w,beta,z,c,qdat,z0,options)
X%STINVMAP Schwarz-Christoffel strip inverse map.
X%	STINVMAP(WP,W,BETA,Z,C,QDAT) computes the inverse of the
X%	Schwarz-Christoffel strip map (i.e., from the polygon
X%	to the strip) at the points given in vector WP. The
X%	other arguments are as in STPARAM.  QDAT may be omitted.
X%
X%	The default algorithm is to solve an ODE in order to obtain a fair
X%	approximation for ZP, and then improve ZP with Newton iterations.
X%	The ODE solution at WP requires a vector Z0 whose forward image W0
X%	is such that for each j, the line segment connecting WP(j) and W0(j)
X%	lies inside the polygon.  By default Z0 is chosen by a fairly robust
X%	automatic process.  Using a parameter (see below), you can choose to
X%	use either an ODE solution or Newton iterations exclusively.
X%
X%	STINVMAP(WP,W,BETA,Z,C,QDAT,Z0) has two interpretations.  If the ODE
X%	solution is being used, Z0 overrides the automatic selection of
X%	initial points.  (This can be handy in convex polygons, where the
X%	choice of Z0 is trivial.)  Otherwise, Z0 is taken as an initial
X%	guess to ZP.  In either case, if length(Z0)==1, the value Z0 is used
X%	for all elements of WP; otherwise, length(Z0) should equal
X%	length(WP).
X%
X%       STINVMAP(WP,W,BETA,Z,C,QDAT,Z0,OPTIONS) uses a vector of parameters
X%       that control the algorithm.  See SCIMAPOPT.
X%
X%	See also SCIMAPOPT, STPARAM, STMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
XN = length(w);
Xn = N-2;
Xw = w(:);
Xbeta = beta(:);
Xz = z(:);
X% Renumber vertices so that the ends of the strip map to w([1,k])
Xwend = [find(isinf(z)&(z<0)),find(isinf(z)&(z>0))];
Xrenum = [wend(1):N,1:wend(1)-1];
Xw = w(renum);
Xbeta = beta(renum);
Xz = z(renum);
Xk = find(renum==wend(2));
Xzp = zeros(size(wp));
Xwp = wp(:);
Xlenwp = length(wp);
Xmask = ones(N,1);
Xmask([1,k]) = zeros(2,1);
X
Xif nargin < 8
X  options = [];
X  if nargin < 7
X    z0 = [];
X    if nargin < 6
X      qdat = [];
X    end
X  end
Xend
X
X[ode,newton,tol,maxiter] = scimapopt(options);
X
Xif isempty(qdat)
X  qdat = scqdata(beta(mask),max(ceil(-log10(tol)),2));
Xend
X
X% ODE
Xif ode
X  if isempty(z0)
X    % Pick a value z0 (not a singularity) and compute the map there.
X    [z0,w0] = scimapz0('st',wp,w,beta,z,c,qdat);
X  else
X    w0 = stmap(z0,w,beta,z,c,qdat);
X    if length(z0)==1 & lenwp > 1
X      z0 = z0(:,ones(lenwp,1)).';
X      w0 = w0(:,ones(lenwp,1)).';
X    end
X  end
X
X  % Use relaxed ODE tol if improving with Newton.
X  odetol = max(tol,1e-3*(newton));
X
X  % Set up data for the ode function.
X  global SCIMDATA	
X  SCIMDATA = zeros(max(lenwp,N),4);
X  SCIMDATA = (wp - w0(:))/c; 		% adjusts "time" interval
X  SCIMDATA(1:N,2) = z;
X  SCIMDATA(1:N,3) = beta;
X  SCIMDATA(1,4) = N;
X
X  z0 = [real(z0);imag(z0)];
X  [t,y] = ode45('stimapf1',0,1,z0,odetol);
X  [m,leny] = size(y);
X  zp(:) = y(m,1:lenwp)+sqrt(-1)*y(m,lenwp+1:leny);
Xend
X
X% Newton iterations
Xif newton
X  if ~ode
X    zn = z0(:);
X    if length(z0)==1 & lenwp > 1
X      zn = zn(:,ones(lenwp,1));
X    end
X  else
X    zn = zp(:);
X  end
X    
X  wp = wp(:);
X  done = zeros(size(zn));
X  k = 0;
X  while ~all(done) & k < maxiter
X    F = wp(~done) - stmap(zn(~done),w,beta,z,c,qdat);
X    dF = c*stderiv(zn(~done),z,beta);
X    zn(~done) = zn(~done) + F(:)./dF(:);
X    done(~done) =  (abs(F) < tol);
X    k = k + 1;
X  end
X  if any(abs(F)> tol)
X    disp('Warning in stinvmap: Solution may be inaccurate')
X    fprintf('Maximum residual = %.3g\n',max(abs(F)))
X  end
X  zp(:) = zn; 
Xend;
X
END_OF_FILE
if test 3439 -ne `wc -c <'stinvmap.m'`; then
    echo shar: \"'stinvmap.m'\" unpacked with wrong size!
fi
chmod +x 'stinvmap.m'
# end of 'stinvmap.m'
fi
if test -f 'stmap.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stmap.m'\"
else
echo shar: Extracting \"'stmap.m'\" \(2805 characters\)
sed "s/^X//" >'stmap.m' <<'END_OF_FILE'
Xfunction wp = stmap(zp,w,beta,z,c,qdat)
X%STMAP  Schwarz-Christoffel strip map.
X%       STMAP(ZP,W,BETA,Z,C,QDAT) computes the values of the Schwarz-
X%       Christoffel strip map at the points in vector ZP.  The arguments 
X%       W, BETA, Z, C, and QDAT are as in STPARAM.  STMAP returns a vector
X%       the same size as ZP.
X%
X%       STMAP(ZP,W,BETA,Z,C,TOL) uses quadrature data intended to give an
X%       answer accurate to within roughly TOL.
X%	
X%	STMAP(ZP,W,BETA,Z,C) uses a tolerance of 1e-8.
X%
X%	See also STPARAM, STPLOT, STINVMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/31/95.
X
XN = length(w);
Xn = N-2;
Xw = w(:);
Xbeta = beta(:);
Xz = z(:);
X% Renumber vertices so that the ends of the strip map to w([1,k])
Xwend = [find(isinf(z)&(z<0)),find(isinf(z)&(z>0))];
Xrenum = [wend(1):N,1:wend(1)-1];
Xw = w(renum);
Xbeta = beta(renum);
Xz = z(renum);
Xk = find(renum==wend(2));
X% nb = Number of prevertices on bottom edge of strip
Xnb = k-2;
Xz([1,k]) = [];
Xw([1,k]) = [];
X
Xif nargin < 6
X  qdat = scqdata(beta([2:k-1,k+1:N]),8);
Xelseif length(qdat)==1
X  qdat = scqdata(beta([2:k-1,k+1:N]),max(ceil(-log10(qdat)),8));
Xend
Xwp = zeros(size(zp));
Xzp = zp(:);
Xp = length(zp);
X
X% For each point in zp, find nearest prevertex.
X[tmp,sing] = min(abs(zp(:,ones(n,1)).'-z(:,ones(1,p))));
Xsing = sing(:);				% indices of prevertices
Xatinf = find(isinf(w)); 		% infinite vertices 
Xatinf = atinf(:);
Xninf = length(atinf);			% # of inf vertices
Xif ninf > 0
X  % "Bad" points are closest to a prevertex of infinity.
X  bad = sing(:,ones(ninf,1))' == atinf(:,ones(1,p));
X  % Can be closest to any pre-infinity.
X  if ninf > 1
X    bad = any(bad);
X  end
X  % Exclude cases which are exactly those prevertices.
X  bad = bad(:) & (abs(zp-z(sing)) > 10*eps);
X  % Can't integrate starting at pre-infinity: which prevertex
X  % is next closest?
X  zf = z(~isinf(w));
X  [tmp,s2] = min(abs(zp(bad,ones(n-ninf,1)).'-zf(:,ones(1,sum(bad)))));
X  shift = cumsum(isinf(w));
X  shift(atinf) = [];
X  sing(bad) = s2(:) + shift(s2(:));
X  % Midpoints of these integrations 
X  mid = (z(sing(bad)) + zp(bad)) / 2;
Xelse
X  bad = zeros(p,1);		% all clear
Xend
X
X% zs = the starting singularities
X% A MATLAB technicality could cause a mistake if sing is all ones and same
X% length as z, hence a workaround.
Xzs = wp(:);
Xzs(1:p+1) = z([sing;2]);
Xzs = zs(1:p);
X% ws = map(zs)
Xws = wp(:);
Xws(1:p+1) = w([sing;2]);
Xws = ws(1:p);
X
X% Compute the map directly at "normal" points.
Xif any(~bad)
X  wp(~bad) = ws(~bad) + ...
X      c*stquad(zs(~bad),zp(~bad),sing(~bad),z,beta,qdat);
Xend
X% Compute map at "bad" points, stopping at midpoint to avoid integration
X% where right endpoint is close to a singularity.
Xif any(bad)
X  wp(bad) = ws(bad) + c*...
X      (stquad(zs(bad),mid,sing(bad),z,beta,qdat) -...
X      stquad(zp(bad),mid,zeros(sum(bad),1),z,beta,qdat));
Xend
X
X
END_OF_FILE
if test 2805 -ne `wc -c <'stmap.m'`; then
    echo shar: \"'stmap.m'\" unpacked with wrong size!
fi
chmod +x 'stmap.m'
# end of 'stmap.m'
fi
if test -f 'stparam.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stparam.m'\"
else
echo shar: Extracting \"'stparam.m'\" \(4700 characters\)
sed "s/^X//" >'stparam.m' <<'END_OF_FILE'
Xfunction [z,c,qdat] = stparam(w,beta,ends,z0,options);
X%STPARAM Schwarz-Christoffel strip parameter problem.
X%       [Z,C,QDAT] = STPARAM(W,BETA,ENDS) solves the Schwarz-Christoffel
X%       parameter problem with the infinite strip as fundamental domain
X%       and interior of the specified polygon as the target.  W must be
X%       a vector of the vertices of the polygon, specified in
X%       counterclockwise order.  BETA is a vector of turning angles; see
X%       SCANGLES.  ENDS is a 2-vector whose entries are the indices of
X%       the vertices which are the images of the left and right ends of
X%       the strip.  If ENDS is omitted, the user is requested to select
X%       these vertices using the mouse.
X%
X%       If successful, STPARAM will return Z, a vector of the pre-images
X%       of W; C, the multiplicative constant of the conformal map; and
X%       QDAT, a matrix of quadrature data required by some of the other
X%       SC routines.
X%
X%       [Z,C,QDAT] = STPARAM(W,BETA,ENDS,Z0) uses Z0 as an initial guess
X%       for Z.
X%
X%       [Z,C,QDAT] = STPARAM(W,BETA,ENDS,Z0,OPTIONS) uses a vector of
X%       control parameters.  See SCPARMOPT.
X%	
X%	See also SCPARMOPT, DRAWPOLY, STDISP, STPLOT, STMAP, STINVMAP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
X% Set up defaults for missing args
Xif nargin < 5
X  options = [];
X  if nargin < 4
X    z0 = [];
X    if nargin < 3
X      ends = [];
X    end
X  end
Xend
X
Xif isempty(ends)
X  disp('Use mouse to select images of left and right ends of the strip.')
X  figure(gcf)
X  ends = scselect(w,beta,2);
Xend
X
XN = length(w); 				% no. of vertices
Xw = w(:);
Xbeta = beta(:);
X% Renumber vertices so that the ends of the strip map to w([1,k])
Xrenum = [ends(1):N,1:ends(1)-1];
Xw = w(renum);
Xbeta = beta(renum);
Xk = find(renum==ends(2));
X% n: number of finite prevertices
Xn = N-2;
X% nb: number of prevertices on bottom edge of strip
Xnb = k-2;
X
X% Check input data.
Xerr = sccheck('st',w,beta,ends);
Xif err==1
X  fprintf('Use SCFIX to make polygon obey requirements\n')
X  error(' ')
Xend
X
X[trace,tol] = scparmopt(options);
Xnqpts = max(ceil(-log10(tol)),4);
Xqdat = scqdata(beta([2:k-1,k+1:N]),nqpts); 		% quadrature data
Xatinf = (beta <= -1);
X
X% Ignore images of ends of strip.
Xw([1,k]) = [];
Xatinf([1,k]) = [];
X
Xif isempty(z0)
X  % Make initial guess based on polygon.
X  % This is from Louis Howell's code.
X  z0 = zeros(n,1);
X%%  scale = (abs(w(nb)-w(1))+abs(w(n)-w(nb+1)))/2;
X%%  z0(1:nb) = linspace(0,scale,nb)';
X%%  z0(nb+1:n) = i + flipud(linspace(0,scale,n-nb)');
X  scale = (abs(w(n)-w(1))+abs(w(nb)-w(nb+1)))/2;
X  z0(1:nb) = cumsum([0;abs(w(2:nb)-w(1:nb-1))]/scale);
X  if nb+1==n
X    z0(n) = mean(z0([1,nb]));
X  else
X    z0(n:-1:nb+1) = cumsum([0;abs(w(n:-1:nb+2)-w(n-1:-1:nb+1))]/scale);
X  end
X  scale = sqrt(z0(nb)/z0(nb+1));
X  z0(1:nb) = z0(1:nb)/scale;
X  z0(nb+1:n) = i + z0(nb+1:n)*scale;
Xelse
X  z0 = z0(renum);
X  if length(z0)==N 
X    if ~all(isinf(z0([1,k])))
X      error('Starting guess does not match ends of strip')
X    end
X    z0([1,k]) = [];
X  elseif length(z0)==n-1
X    z0 = [0;z0];
X  end
Xend
Xy0 = [log(diff(z0(1:nb)));real(z0(nb+1));log(-diff(z0(nb+1:n)))];
X
X% Find prevertices (solve param problem)
X
X% Set up normalized lengths for nonlinear equations:
X% indices of left and right integration endpoints
X%%left = [1,1:nb-1,nb+1:n-1];				
X%%right = [n,2:nb,nb+2:n];				
Xleft = [1,1:n-1];				
Xright = [n,2:n];				
X% delete indices corresponding to vertices at Inf
X%%left(find(atinf)+1) = [];
X%%right(find(atinf)) = [];
Xleft([find(atinf)+1,nb+1]) = [];
Xright([find(atinf),nb+1]) = [];
Xcmplx = ((right-left) == 2);
Xcmplx(1) = 0;
Xcmplx(2) = 1;
X% normalize lengths 
Xnmlen = (w(right)-w(left))/(w(n)-w(1));
X% abs value for finite ones
Xnmlen(~cmplx) = abs(nmlen(~cmplx));
X% first entry is useless (=1)
Xnmlen(1) = [];
X  
X% Solve nonlinear system of equations:
X
X% package data
Xnrow = max([n,nqpts,5]);
Xncol = 6+2*N-2;
Xfdat = zeros(nrow,ncol);
Xfdat(1:5,1) = [n;nb;length(left);nqpts;ncol];
Xfdat(1:N,2) = beta;
Xfdat(1:fdat(3,1)-1,3) = nmlen(:);
Xfdat(1:fdat(3,1),4:6) = [left(:),right(:),cmplx(:)];
Xfdat(1:nqpts,7:ncol) = qdat;
X% set options
Xopt = zeros(16,1);
Xopt(1) = 2*trace;
Xopt(6) = 100*(n-1);
Xopt(8) = tol;
Xopt(9) = tol/10;
Xopt(12) = nqpts;
X% do it
X[y,termcode] = nesolve('stpfun',y0,opt,fdat);
Xif termcode~=1
X  disp('Warning: Nonlinear equations solver did not terminate normally')
Xend
X
X% Convert y values to z
Xz = zeros(n,1);
Xz(2:nb) = cumsum(exp(y(1:nb-1)));
Xz(nb+1:n) = i+cumsum([y(nb);-exp(y(nb+1:n-1))]);
X
Xend
X
X% Determine multiplicative constant
Xmid = mean(z(1:2));
Xg = stquad(z(2),mid,2,z,beta,qdat) -...
X    stquad(z(1),mid,1,z,beta,qdat);
Xc = (w(1)-w(2))/g;
X
Xz = [-Inf;z(1:nb);Inf;z(nb+1:n)];
X
X% Undo renumbering
Xz(renum) = z;
X
X
END_OF_FILE
if test 4700 -ne `wc -c <'stparam.m'`; then
    echo shar: \"'stparam.m'\" unpacked with wrong size!
fi
chmod +x 'stparam.m'
# end of 'stparam.m'
fi
if test -f 'stpfun.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stpfun.m'\"
else
echo shar: Extracting \"'stpfun.m'\" \(1709 characters\)
sed "s/^X//" >'stpfun.m' <<'END_OF_FILE'
Xfunction F = stpfun(y,fdat)
X%STPFUN (not intended for calling directly by the user)
X%	Returns residual for solution of nonlinear equations. 
X%	Used by STPARAM.
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
Xn = fdat(1,1);
Xnb = fdat(2,1);
Xbeta = fdat(1:n+2,2);
Xnmlen = fdat(1:fdat(3,1)-1,3);
Xrows = 1:fdat(3,1);
Xleft = fdat(rows,4);
Xright = fdat(rows,5);
Xcmplx = fdat(rows,6);
Xqdat = fdat(1:fdat(4,1),7:fdat(5,1));
X
X% In this function, n refers to the number of FINITE prevertices.
X
X% Transform y (unconstr. vars) to z (actual params)
Xz = zeros(n,1);
Xz(2:nb) = cumsum(exp(y(1:nb-1)));
Xz(nb+1:n) = i+cumsum([y(nb);-exp(y(nb+1:n-1))]);
X
X% Check crowding of singularities.
Xif any(abs(diff(z))<eps) | any(isinf(z))
X  % Try to make fsolve take a different step.
X  F = y;
X  disp('Warning: Severe crowding')
X  return
Xend
X
X% Compute the integrals appearing in nonlinear eqns.
Xzleft = z(left);
Xzright = z(right);
Xmid = mean([zleft.' ; zright.']).';
Xc2 = cmplx;
Xc2(2) = 0;
Xmid(c2) = mid(c2) - sign(left(c2)'-nb)*i/2;
Xints = stquad(zleft,mid,left,z,beta,qdat) - ...
X    stquad(zright,mid,right,z,beta,qdat);
X
Xabsval = abs(ints(~cmplx)); 		% absval(1) = abs(ints(1))
Xif ~absval(1)
X  rat1 = 0;
X  rat2 = 0;
Xelse
X  rat1 = absval(2:length(absval))/absval(1);
X  rat2 = ints(cmplx)/ints(1);
Xend
X
Xif any([rat1;rat2]==0) | any(isnan([rat1;rat2])) | any(isinf([rat1;rat2]))
X  % Singularities were too crowded.  Try returning a
X  % big residual to get fsolve to try something else.
X  F = y;
X  disp('Warning: Severe crowding')
Xelse
X  % Compute nonlinear equation residual values.
X  cmplx2 = cmplx(2:length(cmplx));
X  F1 = log( rat1 ./ nmlen(~cmplx2) );
X  F2 = log( rat2 ./ nmlen(cmplx2) );
X  F = [F1;real(F2);imag(F2)];
Xend
X
X
END_OF_FILE
if test 1709 -ne `wc -c <'stpfun.m'`; then
    echo shar: \"'stpfun.m'\" unpacked with wrong size!
fi
chmod +x 'stpfun.m'
# end of 'stpfun.m'
fi
if test -f 'stplot.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stplot.m'\"
else
echo shar: Extracting \"'stplot.m'\" \(4851 characters\)
sed "s/^X//" >'stplot.m' <<'END_OF_FILE'
Xfunction [H,RE,IM] = stplot(w,beta,z,c,re,im,options)
X%STPLOT Image of cartesian grid under Schwarz-Christoffel strip map.
X%       STPLOT(W,BETA,Z,C) will adaptively plot the images under the
X%       Schwarz-Christoffel exterior map of ten evenly spaced horizontal
X%       and vertical lines in the upper half-plane. The abscissae of the
X%       vertical lines will bracket the finite extremes of real(Z).  The
X%       arguments are as in STPARAM.
X%
X%       STPLOT(W,BETA,Z,C,M,N) will plot images of M evenly spaced
X%       vertical and N evenly spaced horizontal lines.  Horizontal lines
X%       are spaced to bracket real(Z); vertical lines are evenly spaced
X%       between 0 and 1.
X%
X%       STPLOT(W,BETA,Z,C,RE,IM) will plot images of vertical lines
X%       whose real parts are given in RE and horizontal lines whose
X%       imaginary parts are given in IM.  Either argument may be empty.
X%
X%       STPLOT(W,BETA,Z,C,RE,IM,OPTIONS) allows customization of
X%       HPPLOT's behavior.  See SCPLOTOPT.
X%
X%       H = STPLOT(W,BETA,Z,C,...) returns a vector of handles to all
X%       the curves drawn in the interior of the polygon.  [H,RE,IM] =
X%       STPLOT(W,BETA,Z,C,...) also returns the abscissae and ordinates
X%       of the lines comprising the grid.
X%	
X%	See also SCPLOTOPT, STPARAM, STMAP, STDISP.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xturn_off_hold = ~ishold;
XN = length(w);
Xn = N-2;
Xw = w(:);
Xbeta = beta(:);
Xz = z(:);
X% Renumber vertices so that the ends of the strip map to w([1,k])
Xwend = [find(isinf(z)&(z<0)),find(isinf(z)&(z>0))];
Xrenum = [wend(1):N,1:wend(1)-1];
Xw = w(renum);
Xbeta = beta(renum);
Xz = z(renum);
Xk = find(renum==wend(2));
X% nb = Number of prevertices on bottom edge of strip
Xnb = k-2;
X
Xif nargin < 7
X  options = [];
X  if nargin < 6
X    im = [];
X    if nargin < 5
X      re = [];
X    end
X  end
Xend
X
Xif isempty([re(:);im(:)])
X  re = 10;
X  im = 10;
Xend
X
Xminre = min(real(z(~isinf(z))));
Xmaxre = max(real(z(~isinf(z))));
Xif (length(re)==1) & (re == round(re))
X  if re < 1
X    re = [];
X  elseif re < 2
X    re = mean([minre,maxre]);
X  else
X    m = re;
X    re = linspace(minre,maxre,m);
X    dre = diff(re(1:2));
X    re = linspace(minre-dre,maxre+dre,m);
X  end
Xend
Xif (length(im)==1) & (im == round(im))
X  if im < 1
X    im = [];
X  else
X    m = im;
X    im = linspace(0,1,m+2);
X    im([1,m+2]) = [];
X  end
Xend
X
X[nqpts,maxturn,maxlen,maxrefn] = scplotopt(options);
X
Xfig = gcf;
Xfigure(fig);
Xplotpoly(w,beta);
Xdrawnow
Xhold on
X
Xreflen = maxlen*max(abs(diff([w(~isinf(w));w(2)])));
Xqdat = scqdata(beta([2:k-1,k+1:N]),4);
X
Xfor j = 1:length(re)
X  zp = re(j) + i*linspace(0,1,15).';
X  wp = stmap(zp,w,beta,z,c,qdat);
X  bad = find(toobig(wp,maxturn,reflen,axis));
X  iter = 0;
X  while (~isempty(bad)) & (iter < maxrefn)
X    lenwp = length(wp);
X    newz = [(zp(bad-1)+2*zp(bad))/3;(zp(bad+1)+2*zp(bad))/3];
X    neww = stmap(newz,w,beta,z,c,qdat);
X    [tmp,in] = sort(imag([zp;newz]));
X    zp = [zp;newz];  wp = [wp;neww];
X    zp = zp(in);     wp = wp(in);
X    iter = iter + 1;
X    bad = find(toobig(wp,maxturn,reflen,axis));
X  end
X  linh(j) = plot(clipdata(wp,axis), 'g-','erasemode','none');
X  drawnow
X  set(linh(j),'erasemode','normal');
X  Z(1:length(zp),j) = zp;
X  W(1:length(wp),j) = wp;
Xend
X
Xx1 = min(-5,minre);
Xx2 = max(5,maxre);
Xaxlim = axis;
Xfor j = 1:length(im)
X  zp = linspace(x1,x2,15).' + i*im(j);
X  wp = stmap(zp,w,beta,z,c,qdat);
X  bad = find(toobig([w(1);wp;w(k)],maxturn,reflen,axis))-1;
X  iter = 0;
X  while (~isempty(bad)) & (iter < maxrefn)
X    lenwp = length(wp);
X    special = zeros(2,1);
X    if isinf(w(1))
X      if real(wp(1))>axlim(1) & real(wp(1))<axlim(2)&...
X	    imag(wp(1))>axlim(3) & imag(wp(1))<axlim(4)
X	special(1) = 1;
X      end
X    elseif any(bad==1)
X      special(1) = 1;
X    end
X    if isinf(w(k))
X      if real(wp(lenwp))>axlim(1) & real(wp(lenwp))<axlim(2)&...
X	    imag(wp(lenwp))>axlim(3) & imag(wp(lenwp))<axlim(4)
X	special(2) = 1;
X      end
X    elseif any(bad==lenwp)
X      special(2) = 1;
X    end
X    bad(bad==1 | bad==lenwp) = [];
X    newz = [(zp(bad-1)+2*zp(bad))/3;(zp(bad+1)+2*zp(bad))/3];
X    zends = zp([1,lenwp]);
X    newz = [newz;i*imag(zends(special))+5*real(zends(special))];
X    neww = stmap(newz,w,beta,z,c,qdat);
X    [tmp,in] = sort(real([zp;newz]));
X    zp = [zp;newz];  wp = [wp;neww];
X    zp = zp(in);     wp = wp(in);
X    iter = iter + 1;
X    bad = find(toobig([w(1);wp;w(k)],maxturn,reflen,axis))-1;
X  end
X  linh(j+length(re)) = plot(clipdata([w(1);wp;w(k)],axis), ...
X      'g-','erasemode','none');
X  drawnow
X  set(linh(j+length(re)),'erasemode','normal');
X  Z(1:length(zp),j+length(re)) = zp;
X  W(1:length(wp),j+length(re)) = wp;
Xend
X  
X% Force redraw to get clipping enforced.
Xset(fig,'color',get(fig,'color'))
Xif turn_off_hold, hold off, end;
Xif nargout > 0
X  H = linh;
X  if nargout > 1
X    RE = re;
X    if nargout > 2
X      IM = im;
X    end
X  end
Xend 
X
END_OF_FILE
if test 4851 -ne `wc -c <'stplot.m'`; then
    echo shar: \"'stplot.m'\" unpacked with wrong size!
fi
chmod +x 'stplot.m'
# end of 'stplot.m'
fi
if test -f 'stquad.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stquad.m'\"
else
echo shar: Extracting \"'stquad.m'\" \(2536 characters\)
sed "s/^X//" >'stquad.m' <<'END_OF_FILE'
Xfunction I = stquad(z1,z2,sing1,z,beta,qdat)
X%STQUAD (not intended for calling directly by the user)
X%	Numerical quadrature for the strip map.
X
X%	z1,z2 are vectors of left and right endpoints.  sing1 is a vector of
X%	integer indices which label the singularities in z1.  So if sing1(5)
X%	= 3, then z1(5) = z(3).  A zero means no singularity.  z is the
X%	vector of *finite* singularities; beta is the vector of associated
X%	turning angles.  z(1) must be the leftmost prevertex on the bottom
X%	edge of the strip.  If nb=sum(~imag(z)), then z(1:nb) are on the
X%	bottom edge and z(nb+1:n) are on the top (going right to left).
X%	Note that length(beta) = length(z)+2, because the angles at the ends
X%	of the strip are significant.  Hence beta(1) is the turn at the left
X%	end and beta(nb+2) is at the right end.  qdat is quadrature data
X%	from SCQDATA.
X%
X%	Make sure z and beta are column vectors.
X%	
X%	STQUAD integrates from a possible singularity at the left end to a
X%	regular point at the right.  If both endpoints are singularities,
X%	you must break the integral into two pieces and make two calls.
X%	
X%	The integral is subdivided, if necessary, so that no
X%	singularity lies closer to the left endpoint than 1/2 the
X%	length of the integration (sub)interval.
X%
X%	Written by Toby Driscoll.  Last updated 5/23/95.
X
Xn = length(z);
Xnb = sum(~imag(z));
Xif isempty(sing1)
X  sing1 = zeros(length(z1),1);
Xend
X
XI = zeros(size(z1));
Xnontriv = find(z1(:)~=z2(:))';
X
Xfor k = nontriv
X  za = z1(k);
X  zb = z2(k);
X  sng = sing1(k);
X
X  % Allowable integration step, based on nearest singularity.
X  dist = min(1,2*min(abs(z([1:sng-1,sng+1:n])-za))/abs(zb-za));
X  zr = za + dist*(zb-za);
X  ind = rem(sng+n,n+1)+1;
X  % Adjust Gauss-Jacobi nodes and weights to interval.
X  nd = ((zr-za)*qdat(:,ind) + zr + za)/2; % G-J nodes
X  wt = ((zr-za)/2) * qdat(:,ind+n+1); 	% G-J weights
X  if any(~diff([za;nd;zr])) %| any(any(~terms)) 
X    % Endpoints are practically coincident.
X    I(k) = 0;
X  else
X    % Use Gauss-Jacobi on first subinterval, if necessary.
X    if sng > 0
X      wt = wt*(abs(zr-za)/2)^beta(sng+1+(sng>nb));
X    end
X    I(k) = stderiv(nd.',[-Inf;z(1:nb);Inf;z(nb+1:n)],beta,sng)*wt;
X    while (dist < 1) & ~isnan(I(k))
X      % Do regular Gaussian quad on other subintervals.
X      zl = zr;
X      dist = min(1,2*min(abs(z-zl))/abs(zl-zb));
X      zr = zl + dist*(zb-zl);
X      nd = ((zr-zl)*qdat(:,n+1) + zr + zl)/2;
X      wt = ((zr-zl)/2) * qdat(:,2*n+2);
X      I(k) = I(k) + stderiv(nd.',[-Inf;z(1:nb);Inf;z(nb+1:n)],beta)*wt;
X    end
X  end
Xend
X
END_OF_FILE
if test 2536 -ne `wc -c <'stquad.m'`; then
    echo shar: \"'stquad.m'\" unpacked with wrong size!
fi
chmod +x 'stquad.m'
# end of 'stquad.m'
fi
if test -f 'toobig.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'toobig.m'\"
else
echo shar: Extracting \"'toobig.m'\" \(730 characters\)
sed "s/^X//" >'toobig.m' <<'END_OF_FILE'
Xfunction bad = toobig(wp,maxturn,reflen,clip)
X%TOOBIG (not intended for calling directly by the user)
X%	Used by plotting functions to spot points in a polyline at which
X%	turning angles or line segments are too large.
X%
X%       See also HPPLOT, DPLOT, DEPLOT, STPLOT, RPLOT.
X%
X%	Written by Toby Driscoll.  Last updated 5/24/95.
X
Xm = length(wp);
Xdwp = abs(diff(wp(:)));
Xdwp = max([dwp(1:m-2).';dwp(2:m-1).']).';
Xangl = abs(scangle(wp(:)));
Xbad = [0;(((angl(2:m-1) > maxturn/180)&(dwp > reflen/8)) | (dwp > reflen));0];
Xif nargin >= 4				% ignore clipped points
X  xp = real(wp);
X  yp = imag(wp);
X  inside = (xp>clip(1)) & (xp<clip(2)) & (yp>clip(3)) & (yp<clip(4));
X  bad = bad & (inside | [1;inside(1:m-1)] | [inside(2:m);1]);
Xend
END_OF_FILE
if test 730 -ne `wc -c <'toobig.m'`; then
    echo shar: \"'toobig.m'\" unpacked with wrong size!
fi
chmod +x 'toobig.m'
# end of 'toobig.m'
fi
if test -f 'tutdemo.m' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tutdemo.m'\"
else
echo shar: Extracting \"'tutdemo.m'\" \(1995 characters\)
sed "s/^X//" >'tutdemo.m' <<'END_OF_FILE'
Xmore off
Xecho on
Xclc
X% This script demonstrates the basic capabilities of the
X% Schwarz-Christoffel Toolbox.
X
Xpause     % Strike any key to begin (Ctrl-C to abort)
X
X
X% We begin with an L-shaped region.
X
Xpause     % Strike any key to continue
X
Xw = [i; -1+i; -1-i; 1-i; 1; 0];
Xbeta = scangle(w);
X
Xfigure(gcf)
Xhold off
Xplotpoly(w,beta)
X
Xpause     % Strike any key to continue
X
X% Now we solve the parameter problem for the half-plane.
X[x,c] = hpparam(w,beta);
X
Xpause     % Strike any key to display results
X
Xhpdisp(w,beta,x,c)
X
Xpause     % Strike any key to continue
X
X% Now let's visualize the map by plotting the image of
X% a square grid of 12 vertical and 6 horizontal lines.
X
Xpause     % Strike any key to begin plot
X
Xhpplot(w,beta,x,c,12,6)
X
X% Note how the lines intersect at right angles.  Also, 
X% note how they converge at the last vertex, the origin,
X% since that is the image of the point at infinity.
X
Xpause     % Strike any key to continue
Xclc
X% Let's change the fundamental domain from the half-plane 
X% to the unit disk.
X
X[z,c]=hp2disk(w,beta,x,c);
X
Xddisp(w,beta,z,c)
X
Xpause     % Strike any key to continue
X
X% What's the inverse image of the point -.3-.3i?
X
Xzp = dinvmap(-.3-.3i,w,beta,z,c)
X
Xpause     % Strike any key to continue
X
X% We should get at least 8 accurate digits, by default.
X
Xabs(-.3-.3i - dmap(zp,w,beta,z,c))
X
Xpause     % Strike any key to continue
X
X% We can change the map so that -.3-.3i is the image of 0...
X
X[z,c] = dfixwc(w,beta,z,c,-.3-.3i);
X
Xpause     % Strike any key to continue
X
X% ...and look at the resulting image of a certain polar grid.
X
Xdplot(w,beta,z,c,.1:.1:.9,pi*(.25:.25:2))
X
Xpause     % Strike any key to continue
Xclc
X% Now suppose we want an exterior map.  First, the vertices
X% have to be given in clockwise order:
X
Xw = flipud(w);
Xbeta = scangle(w);
X
Xpause     % Strike any key to solve the parameter problem
X
X[z,c] = deparam(w,beta);
X
Xpause     % Strike any key to see results
X
Xdedisp(w,beta,z,c)
X
Xdeplot(w,beta,z,c)
X
Xecho off      % End of demo
X
END_OF_FILE
if test 1995 -ne `wc -c <'tutdemo.m'`; then
    echo shar: \"'tutdemo.m'\" unpacked with wrong size!
fi
chmod +x 'tutdemo.m'
# end of 'tutdemo.m'
fi
echo shar: End of shell archive.
exit 0
