%\usepackage{CJK}%
%\usepackage{epstopdf}
\documentclass[12pt]{article}%
\usepackage{latexsym,amssymb,amsmath,amscd,amscd,amsxtra,graphicx}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts,color}
\usepackage[english]{babel}%
\usepackage{color}
\usepackage{framed}
\definecolor{shadecolor}{gray}{0.85}
\setcounter{MaxMatrixCols}{30}
%TCIDATA{OutputFilter=latex2.dll}
%TCIDATA{Version=5.50.0.2953}
%TCIDATA{LastRevised=Thursday, April 24, 2008 13:26:55}
%TCIDATA{<META NAME="GraphicsSave" CONTENT="32">}
%TCIDATA{<META NAME="SaveForMode" CONTENT="1">}
%TCIDATA{BibliographyScheme=Manual}
%BeginMSIPreambleData
\providecommand{\U}[1]{\protect\rule{.1in}{.1in}}
%EndMSIPreambleData

\numberwithin{equation}{section}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}
\numberwithin{remark}{section}
\numberwithin{example}{section}

\renewcommand{\vec}[1]{\mbox{\boldmath \small $#1$}}

\begin{document}
 \title{User's Manual for the code for Helmholtz transmission eigenvalues}
 \author{Xia Ji, Jiguang Sun, Tiara Turner}
 \maketitle

\section{Introduction}
This is a program written in MATLAB for solving the transmission eigenvalues for Helmholtz equation. For the case
of scattering of time-harmonic acoustic waves by a bounded simply connected inhomogeneous
medium $D\in \mathbb{R}^2$, the transmission eigenvalue problem is to find $k\in \mathbb{C}, u,v \in L^2(D), u-v
\in H^2(D)$ such that
\begin{eqnarray*}
&\Delta u+k^2(1+q(x))u=0,\\
&\Delta v+k^2 v=0,\\
&u-v=0,\\
&\frac{\partial u}{\partial \nu}-\frac{\partial v}{\partial \nu}=0,
\end{eqnarray*}
where $n(x)=1+q(x)$ is the index of refraction. Using the mixed method, we can obtain the following weak problem, find $(k^2,u,v)\in \mathbb{C}\times H^1_0(D)\times H^1(D)$ such that
\begin{eqnarray*}
(\Delta v,\Delta \phi)=k^2(v,\phi),\quad \forall \phi \in H_0^1(D),\\
(\Delta u,\Delta \phi)+(qv,\phi)=k^2((1+q)u,\phi),
\quad  \forall \phi\in H^1(D).
\end{eqnarray*}
Given finite dimensional spaces $S_h \subset H^1(D)$ and $S_h^0\subset H_0^1(D)$ such that
$S_h^0\subset S_h$, the discrete problem is to find $(k_h^2,u_h,v_h)\in \mathbb{C}\times S_h^0\times S_h$ such that
\begin{eqnarray*}
(\Delta v_h,\Delta \phi_h)=k_h^2(v_h,\phi_h),\quad \forall \phi_h \in S_h^0,\\
(\Delta u_h,\Delta \phi_h)+(qv_h,\phi_h)=k_h^2((1+q)u_h,\phi_h),
\quad  \forall \phi\in S_h.
\end{eqnarray*}
Standard piecewise linear finite elements  are used to discretize the
problem
\begin{eqnarray*}
S_h&=&\mbox{ the space of continuous piecewise } \mbox{ linear finite elements on }D,\\
S_{h}^{0}&=&S_h\cap H_0^1(D)\\
&=&  \mbox{ the subspace of functions in } S_h \mbox{ that have vanishing DoF  on }\partial D,
\end{eqnarray*}
where DoF stands for degree of freedom.
Let $\psi_1, \ldots, \psi_K$ be a basis for $S_h^0$ and $\psi_1, \ldots, \psi_K, \psi_{K+1}, \ldots, \psi_T$
be a basis for $S_h$.
Let $u_h = \sum_{i=1}^K u_i \psi_i$ and $v_h =  \sum_{i=1}^T v_i \psi_i$. Furthermore, let
${\bf u} = (u_1, \ldots, u_K)^T$  and ${\bf v} = (v_1, \ldots, v_T)^T$.
Then the corresponding matrix problem is
\begin{eqnarray*}
S_{K \times T} {\bf v} & = & k_h^2 M_{K \times T} {\bf v},\\
S_{T \times K}{\bf u} + M_{T \times T}^q {\bf v} &=& k_h^2 M_{T\times K}^{1+q} {\bf u},
\end{eqnarray*}
where the matrices are defined as follows
\begin{center}
\begin{tabular}{||l|l|l||}
\hline\hline
Matrix& Dimension & Definition\\\hline\hline
$S_{K \times T}$ & $K \times T $& $S_{K \times T}^{i,j} = (\nabla \psi_i, \nabla \psi_j), 1 \le i \le K, 1\le j \le T$\\
$S_{T \times K}$ & $T \times K$& $S_{T \times K}^{i,j} = (\nabla \psi_i, \nabla \psi_j), 1 \le i \le T, 1\le j \le K$\\
$M_{K \times T}$&$K \times T $&$M_{K \times T}^{i,j} = (\psi_i, \psi_j), 1 \le i \le K, 1\le j \le T$\\
$M_{T \times K}^{1+q}$&$T \times K$&$(M_{T \times K}^{1+q})^{i,j} = ((1+q)\psi_i, \psi_j), 1 \le i \le T, 1\le j \le K$\\
$M_{T \times T}^{q}$&$T \times T $&$(M_{T \times T}^{q})^{i,j} = (q\psi_i, \psi_j), 1 \le i \le T, 1\le j \le T$\\\hline\hline
\end{tabular}
\end{center}
The generalized eigenvalue problem we need to solve is
\[
\left(\begin{array}{cc}
S_{K \times T}&0_{K \times K}\\
M_{T \times T}^q & S_{T \times K} \end{array}\right)
\left(\begin{array}{c}
{\bf v} \\
{\bf u}  \end{array}\right)
= k^2
\left(\begin{array}{cc}
M_{K \times T}&0_{K \times K}\\
0_{T \times T} & M_{T \times K}^{1+q} \end{array}\right)
\left(\begin{array}{c}
{\bf v} \\
{\bf u}  \end{array}\right).
\]
For simplicity, we shall write this problem as
\begin{equation}\label{GEPab}
A {\bf x} = \lambda B{\bf x}
\end{equation}
where
\[
A = \left(\begin{array}{cc}
S_{K \times T}&0_{K \times K}\\
M_{T \times T}^q & S_{T \times K} \end{array}\right), \quad B= \left(\begin{array}{cc}
M_{K \times T}&0_{K \times K}\\
0_{T \times T} & M_{T \times K}^{1+q} \end{array}\right)
, \quad {\bf x} =\left(\begin{array}{c}
{\bf v} \\
{\bf u}  \end{array}\right).
\]
The idea of the code is to construct the matrices first, then solve the generalized eigenvalue problems.
\section{How to run this code}
The main m-file is \textbf{`mixFemTE'}. To compute transmission eigenvalues, first type \textbf{`mixFemTE'} in Matlab Command Window.
The program first asks the user to input the mesh file by displaying
\begin{verbatim}
Input name of the mesh file -->
\end{verbatim}
The user types the mesh file name, for example,
\begin{verbatim}
`halfcircle'
\end{verbatim}
Then the program asks the user to input the supremum of index of refraction by displaying
\begin{verbatim}
Input the supremum of index of refraction -->
\end{verbatim}
The user could type, for example,
\begin{verbatim}
16
\end{verbatim}
Note that the actual definition for the index of refraction $n(x)$ is defined in \textbf{`Rindex'}.
16 is the supremum of index
in the current \textbf{`Rindex'}. You must change this file to change the index of refraction.

Finally the program asks how many transmission eigenvalues to be computed by displaying
\begin{verbatim}
Input the number of transmission eigenvalues -->
\end{verbatim}
The user could type, for example,
\begin{verbatim}
4
\end{verbatim}
Taking all above input, the program does the following
\begin{itemize}
\item[1.] Construct the stiffness matrix S, mass matrix M and weighted mass matrix Mn (by calling subroutine \textbf{`assemble'}).
\item[2.] Identify the interior and boundary nodes and store them in `Inode' and `Bnode' (by calling subroutine \textbf{`intnode'}).
\item[3.] Compute the first Dirichlet eigenvalue (by calling subroutine \textbf{`DirichletEig'}).
\item[4.] Construct the matrices $A$ and $B$ for the generalized eigenvalue problem (by calling subroutine \textbf{`MixMethod'}).
\item[5.] Compute transmission eigenvalues (by calling subroutine \textbf{`sptarnite'}).
\end{itemize}
\section{Modula of this code}
This program consists of the following parts:
\begin{itemize}
\item Mesh generation.
\item Construct the mass matrix, stiffness matrix and weighted mass matrix.
\item Identify the interior and boundary nodes.
\item Compute the first Dirichlet
eigenvalue for $-\Delta $ in $D$.
\item Construct the matrices for the transmission eigenvalues problem.
\item Solve the eigenvalue problem by an iterative algorithm using restarted Arnoldi method.
\end{itemize}
\subsection{Mesh generation}
We use the PDE toolbox in MATLAB to generate the mesh, for example,
 \begin{shaded}
 {pdecirc}(0,0,1/2,`{C}1')
 \end{shaded}
This command can generate the mesh on a circle centered at $(0,0)$ with radius $1/2$.
the command \textbf{`Export Mesh'} can be used to save the information of the mesh.

We may load the information of the mesh

\begin{shaded}
 p= mesh.p'; t =  {mesh.t}(1:3,:)';  {e}= {mesh.e}(1:2,:)';
 \end{shaded}

\begin{itemize}
\item In the Point matrix p, the first and second rows contain x- and y-coordinates of the points in the mesh.
\item In the Edge matrix e, the first and second rows contain indices of the starting and ending point,
the third and fourth rows contain the starting and ending parameter values, the fifth row contains the
edge segment number, and the sixth and seventh row contain the left- and right-hand side subdomain numbers.
\item In the Triangle matrix t, the first three rows contain indices to the corner points,
given in counter clockwise order, and the fourth row contains the subdomain number.
\end{itemize}
Any other tools which can generate such information can also be used in the mesh generation part.

\subsection{Construct the related matrices }
 We construct the stiffness matrix, mass matrix and weighted mass matrix
with the following four subroutines:
\begin{itemize}
\item \textbf{`assemble'} (function [S, M, Mn]=assemble(mesh))

\textbf{Description:} construct the stiffness matrix, mass matrix and weighted
mass matrix

\textbf{Input:} the matrix `mesh'

\textbf{Output:} mass matrices `M', stiffness matrices `S' and the weighted
mass matrix `Mn'

\item \textbf{`quad}$\_$\textbf{setup2'}  (function [weight,place]=quad setup2())

\textbf{Description:} get the quadrature weights and points on the reference
element

\textbf{Input:} no

\textbf{Output:} quadrature weights `weight' and quadrature points `place'

\item \textbf{`phihat'} (function [y,grady]=phihat(xhat))

\textbf{Description:} gets all the basis function values and gradients at the
quadrature points on the reference element

\textbf{Input:} the position on the reference element `xhat'

\textbf{Output:} function values `y' and gradients `grrady' at `xhat'

\item \textbf{`Rindex'} (n=Rindex(x,index))

\textbf{Description:} give the refractive index at `x'

\textbf{Input:} position `x', index of the medium `index'

\textbf{Output:} refractive index `n'
\end{itemize}

The physical element is mapped by an affine transformation onto the reference
triangle $\{(x, y)|, 0\leq x, y \leq 1, 0 \leq x + y  \leq1\}$, then the information
on the physical element can be derived from the reference one. The information
of the reference element is obtained in \textbf{`quad}$\_$\textbf{setup2'}  and \textbf{`phihat'}. In
\textbf{`assemble'}, we construct the desired information on each physical element,
then assemble it into big matrices.






 \subsection{Identify interior and boundary nodes}
 The subroutine \textbf{`intnode'} (function [Inode,Bnode]=intnode(mesh)) fulfills
the task of finding the interior and boundary nodes.

\textbf{Description}: identify the interior and boundary nodes and store them

\textbf{Input}: the matrix `mesh'

\textbf{Output}: interior nodes index `Inode' and boundary nodes index `Bnode'

The following are the codes \textbf{`intnode'}, the lines starting with $\%$ are
comments.
 \begin{shaded}
 function [Inode,Bnode]=intnode(mesh)

$\%$ find boundary points using boundary edge

Bnode = sort(unique([mesh.e(1,:) mesh.e(2,:)]))';

$\%$ find interior points using boundary points

Inode = setdiff((1:length(mesh.p)),Bnode)';
 \end{shaded}
 \subsection{Compute the first Dirichlet eigenvalue for $-\triangle$}
 This subroutine \textbf{`Dirichlet'} (function lambda=DirichletEig(SS, MM)) gives
the first Dirichlet eigenvalue for $-\triangle$.

\textbf{Description}: compute the first Dirichlet eigenvalue for $-\triangle$ on $D$

\textbf{Input}: the mass matrix `MM' and stiffness matrix `SS' after applying
the boundary condition

\textbf{Output}: the first Dirichlet eigenvalue `lambda'
 \begin{shaded}
 function lambda=DirichletEig(SS, MM)

lambda=eigs(SS, MM, 1, `SM');
 \end{shaded}
\textbf{ `eigs'} is used to compute the eigenvalues, we compute the Dirichlet eigenvalues
by calling
\begin{shaded}
lambda=DirichletEig(S(Inode,Inode), M(Inode,Inode));
\end{shaded}
S, M are the stiffness and mass matrices generated in \textbf{`assemble'}.
\subsection{The matrices for the transmission eigenvalues prob-
lem}
With the subroutine \textbf{`assemble'} and \textbf{`intnode'}, we are ready to construct
the matrices for the transmission eigenvalues problem, this is the subroutine
\textbf{`MixMethod'} ([A,B]=MixMethod(S, M, Mn, Inode, Bnode)), this code is
clear with the definition of the matrices A and B (1.1).

\textbf{Description}: construct the matrices for the transmission eigenvalues
problem

\textbf{Input}: the mass matrix M, stiffness matrix S, weighted mass matrix Mn,
interior nodes index `Inode' and boundary nodes index `Bnode'

\textbf{Output}: matrices A and B in (1.1)

\subsection{Solve the eigenvalue problem}
Now we can solve the eigenvalue problem by the restarted Arnoldi method.
This is the subroutine \textbf{`sptarnite'} (function k=sptarnite(A,B,lb,noe)),

\textbf{Description:} solve the eigenvalue problem by the restarted Arnoldi
method

\textbf{Input:} matrices `A' and `B', left lower bound `lb', number of eigenvalues
`noe'

\textbf{Output:} `noe' eigenvalues

At beginning, the left bound is given by $lb = \lambda_0/ sup_D(n)$ and the right
bound is given by $rb=lb+1$. It calls \textbf{`sptarn'} to compute generalized eigenvalues.
Complex eigenvalues are excluded and real eigenvalues are stored.
Then the interval is shifted to right by one unit and \textbf{`sptarn'} is called again
until `noe' eigenvalues are found.

Here the subroutine \textbf{`test'} (function mark=test(D)) is used to determine
weather to do the loop or not,

\textbf{Description:} determine weather to do the loop or not

\textbf{Input:} eigenvalues `D'

\textbf{Output:} if no real eigenvalue in this interval, return 1, else return 0

\end{document}
