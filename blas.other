          AXR$
$(1).
.
.   SINGLE PRECISION INNER PRODUCT
.
. TO BE USED AS FORTRAN FUNCTION  SDOT(N,X,INCX,Y,INCY)
. WHERE SDOT, X, AND Y ARE OF TYPE REAL
. AND    SDOT= SUM FROM I=1 TO N OF A(I)*B(I)  WHERE
. A(I) = X(1-INCX+I*INCX)    IF  INCX.GE.0
. A(I) = X(1-N*INCX+I*INCX)  IF  INCX.LT.0
. B(I)   DEFINED SIMILARLY, WITH X AND INCX REPLACED BY Y AND INCY
.
SDOT*     SZ        A0               . STORE 0 IN A0
          SZ        A3               . 0 A3 FOR INDIRECT ADDRESS. OPT.
          LR        R3,*0,X11        . STORE N IN R3
          JGD       R3,NPOS          . STORE N-1 IN R3 AND TEST N
          J         6,X11            . EXIT IF N.LE.0
NPOS      LA,U      A2,*1,X11        . LOAD ADDRESS OF X
          LXI       A2,*2,X11        . LOAD INCREMENT ON X
          LXI       A3,*4,X11        . LOAD INCREMENT ON Y
          LXM,U     A3,*3,X11        . LOAD ADDRESS OF Y
          JP        A2,TINCY         . TEST IF INCX.GE.0
          LNA       A4,A2            . ADD -INCX*(N-1)
          SSA       A4,18            .    TO THE BASE
          MSI       A4,R3            .    ADDRESS
          AH        A2,A4            .    FOR X
TINCY     JP        A3,LOOP          . TEST IF INCY.GE.0
          LNA       A4,A3            . ADD -INCY*(N-1)
          SSA       A4,18            .    TO THE BASE
          MSI       A4,R3            .    ADDRESS
          AH        A3,A4            .    FOR Y
.                               BEGIN LOOP TO FORM INNER PRODUCT
LOOP      LA        A4,0,*A2         . LOAD X AND INCREMENT INDEX
          FM        A4,0,*A3         . MULTIPLY BY Y AND INCREMENT INDEX
          FA        A0,A4            . ACCUMULATE INNER PRODUCT
          JGD       R3,LOOP          . END OF INNER PRODUCT LOOP
          J         6,X11            . RETURN FOR N.GT.0
.
          END .
          AXR$
$(1).
.
.   DOUBLE PRECISION ACCUMULATION INNER PRODUCT
.
. TO BE USED AS FORTRAN FUNCTION  DSDOT(N,X,INCX,Y,INCY)
. WHERE DSDOT IS OF TYPE DOUBLE PRECISION, X AND Y ARE OF TYPE REAL,
. AND   DSDOT= SUM FROM I=1 TO N OF A(I)*B(I)  WHERE
. A(I) = X(1-INCX+I*INCX)    IF  INCX.GE.0
. A(I) = X(1-N*INCX+I*INCX)  IF  INCX.LT.0
. B(I)   DEFINED SIMILARLY, WITH X AND INCX REPLACED BY Y AND INCY
.
DSDOT*    DSL       A0,72            . STORE 0 IN A0 AND A1
          SZ        A3               . 0 A3 FOR INDIRECT ADDRESS. OPT.
          LR        R3,*0,X11        . STORE N IN R3
          JGD       R3,NPOS          . STORE N-1 IN R3 AND TEST N
          J         6,X11            . EXIT IF N.LE.0
NPOS      DS        A6,SAVE          . SAVE REGISTERS A6 AND A7
          LA,U      A2,*1,X11        . LOAD ADDRESS OF X
          LXI       A2,*2,X11        . LOAD INCREMENT ON X
          LXI       A3,*4,X11        . LOAD INCREMENT ON Y
          LXM,U     A3,*3,X11        . LOAD ADDRESS OF Y
          JP        A2,TINCY         . TEST IF INCX.GE.0
          LNA       A4,A2            . ADD -INCX*(N-1)
          SSA       A4,18            .    TO THE BASE
          MSI       A4,R3            .    ADDRESS
          AH        A2,A4            .    FOR X
TINCY     JP        A3,LOOP          . TEST IF INCY.GE.0
          LNA       A4,A3            . ADD -INCY*(N-1)
          SSA       A4,18            .    TO THE BASE
          MSI       A4,R3            .    ADDRESS
          AH        A3,A4            .    FOR Y
.                               BEGIN LOOP TO FORM INNER PRODUCT
LOOP      FEL       A4,0,*A2         . LOAD X, CONVERT TO DOUBLE, AND IN
          FEL       A6,0,*A3         . LOAD Y, CONVERT TO DOUBLE, AND IN
          DFM       A4,A6            . MULTIPLY X TIMES Y
          DFA       A0,A4            . ACCUMULATE INNER PRODUCT
          JGD       R3,LOOP          . END OF INNER PRODUCT LOOP
          DL        A6,SAVE          . RESTORE REGISTERS A6 AND A7
          J         6,X11            . RETURN FOR N.GT.0
.
$(0)
SAVE      +         0D               . PLACE TO SAVE A6 AND A7
          END .
          AXR$
$(1).
.
.  DOUBLE PRECISION INNER PRODUCT
.
. TO BE USED AS FORTRAN FUNCTION  DDOT(N,X,INCX,Y,INCY)
. WHERE DDOT, X, AND Y ARE OF TYPE DOUBLE PRECISION
. AND DDOT= SUM FROM I=1 TO N OF A(I)*B(I)  WHERE
. A(I) = X(1-INCX+I*INCX)    IF  INCX.GE.0
. A(I) = X(1-N*INCX+I*INCX)  IF  INCX.LT.0
. B(I)   DEFINED SIMILARLY, WITH X AND INCX REPLACED BY Y AND INCY
.
DDOT*     DSL       A0,72            . STORE 0 IN A0 AND A1
          SZ        A3               . 0 A3 FOR INDIRECT ADDRESS. OPT.
          LR        R3,*0,X11        . STORE N IN R3
          JGD       R3,NPOS          . STORE N-1 IN R3 AND TEST N
          J         6,X11            . EXIT IF N.LE.0
NPOS      LA,XH2    A2,*2,X11        . LOAD INCREMENT ON X
          LA,XH2    A3,*4,X11        . LOAD INCREMENT ON Y
          LSSC      A2,19            . DOUBLE INCREMENTS FOR
          LSSC      A3,19            .   DOUBLE PRECISION
          LXM,U     A2,*1,X11        . LOAD ADDRESS OF X
          LXM,U     A3,*3,X11        . LOAD ADDRESS OF Y
          JP        A2,TINCY         . TEST IF INCX.GE.0
          LNA       A4,A2            . ADD -INCX*(N-1)
          SSA       A4,18            .    TO THE BASE
          MSI       A4,R3            .    ADDRESS
          AH        A2,A4            .    FOR X
TINCY     JP        A3,LOOP          . TEST IF INCY.GE.0
          LNA       A4,A3            . ADD -INCY*(N-1)
          SSA       A4,18            .    TO THE BASE
          MSI       A4,R3            .    ADDRESS
          AH        A3,A4            .    FOR Y
.                               BEGIN LOOP TO FORM INNER PRODUCT
LOOP      DL        A4,0,*A2         . LOAD X AND INCREMENT INDEX
          DFM       A4,0,*A3         . MULTIPLY BY Y AND INCREMENT INDEX
          DFA       A0,A4            . ACCUMULATE INNER PRODUCT
          JGD       R3,LOOP          . END OF INNER PRODUCT LOOP
          J         6,X11            . RETURN FOR N.GT.0
.
          END .
          AXR$
$(1).
.
.         COMPLEX ACCUMULATION INNER PRODUCT
.
.    TO BE USED AS FORTRAN FUNCTION CDOTC(N,X,INCX,Y,INCY)
.    WHERE CDOTC, X AND Y ARE OF TYPE COMPLEX
.    AND CDOTC = SUM FROM 1 TO N OF B(I) * COMPLEX CONJUGATE OF A(I)
.    WHERE A(I)=X(1-INCX+I*INCX)    IF INCX.GE.0
.    AND   A(I)=X(1-N*INCX+I*INCX)  IF INCX.LT.0
.    AND   B(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED
.          BY Y AND INCY
.
CDOTC*    DSL       A0,72 .        STORE ZERO IN A4 AND A5
          SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         6,X11 .        IF N.LE.0 RETURN
NPOS      SR        R3,A5 .        STORE N-1 IN A5
          DS        A6,A6A7 .      SAVE CONTENTS OF A6 AND A7 REGISTERS
          DS        A8,A8A9 .      SAVE CONTENTS OF A8 AND A9 REGISTERS
          SZ        A8 .           STORE ZERO IN A8
          LA,XH2    A2,*2,X11 .    LOAD 2*INCX AND 2*INCY
          LA,XH2    A3,*4,X11 .    IN THE LEFT HALVES
          LSSC      A2,19 .        OF A2 AND A3,
          LSSC      A3,19 .        RESPECTIVELY
          LXM,U     A2,*1,X11 .    LOAD ADDRESS OF X
          LXM,U     A3,*3,X11 .    LOAD ADDRESS OF Y
          LSSC      A5,1 .         FORM 2*(N-1) IN A5
          JP        A2,TINCY .     IF INCX IS NEGATIVE
          LNA       A4,*2,X11 .    ADD -2*INCX*(N-1)
          MSI       A4,A5 .        TO THE BASE
          AH        A2,A4 .        ADDRESS FOR X
TINCY     JP        A3,LOOP .      IF INCY IS NEGATIVE
          MSI       A5,*4,X11 .    ADD -2*INCY*(N-1)
          ANH       A3,A5 .        TO THE BASE ADDRESS FOR Y
.                                  BEGIN LOOP
LOOP      LA        A5,0,A2 .      LOAD REAL PART OF X
          FM        A5,0,A3 .      FORM REAL X * REAL Y
LOAD      LNA       A4,1,A2 .      LOAD IMAG. PART OF X
          SA        A4,A6 .        STORE IMAG. X IN A6
          FM        A6,1,A3 .      FORM IMAG. X * IMAG. Y
          FAN       A5,A6 .        FORM REAL X*Y AND
          FA        A0,A5 .        ACCUMULATE IN A0
          FM        A4,0,A3 .      FORM IMAG. X * REAL Y
          LA        A5,0,*A2 .     LOAD REAL X AND INCREMENT X INDEX
          FM        A5,1,*A3 .     FORM REAL X * IMAG. Y, INCREMENT Y IN
          FA        A4,A5 .        FORM IMAG. X*Y AND
          FA        A8,A4 .        ACCUMULATE IN A8
          JGD       R3,LOOP .      END OF LOOP
          SA        A8,A1 .        STORE SUM OF IMAG X*Y IN A1
          DL        A6,A6A7 .      RESTORE A6 AND A7 REGISTERS
          DL        A8,A8A9 .      RESTORE A8 AND A9 REGISTERS
          J         6,X11 .        RETURN
$(0).
A6A7      +         0D .           PLACE TO SAVE A6 AND A7 REGISTERS
A8A9      +         0D .           PLACE TO SAVE A8 AND A9 REGISTERS
.
          END .
          AXR$
$(1).
.
.         COMPLEX ACCUMULATION INNER PRODUCT
.
.    TO BE USED AS FORTRAN FUNCTION CDOTU(N,X,INCX,Y,INCY)
.    WHERE CDOTU, X AND Y ARE OF TYPE COMPLEX
.    AND CDOTU = SUM FROM 1 TO N OF A(I)*B(I)
.    WHERE A(I)=X(1-INCX+I*INCX)    IF INCX.GE.0
.    AND   A(I)=X(1-N*INCX+I*INCX)  IF INCX.LT.0
.    AND   B(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED
.          BY Y AND INCY
.
CDOTU*    DSL       A0,72 .        STORE ZERO IN A4 AND A5
          SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         6,X11 .        IF N.LE.0 RETURN
NPOS      SR        R3,A5 .        STORE N-1 IN A5
          DS        A6,A6A7 .      SAVE CONTENTS OF A6 AND A7 REGISTERS
          DS        A8,A8A9 .      SAVE CONTENTS OF A8 AND A9 REGISTERS
          SZ        A8 .           STORE ZERO IN A8
          LA,XH2    A2,*2,X11 .    LOAD 2*INCX AND 2*INCY
          LA,XH2    A3,*4,X11 .    IN THE LEFT HALVES
          LSSC      A2,19 .        OF A2 AND A3,
          LSSC      A3,19 .        RESPECTIVELY
          LXM,U     A2,*1,X11 .    LOAD ADDRESS OF X
          LXM,U     A3,*3,X11 .    LOAD ADDRESS OF Y
          LSSC      A5,1 .         FORM 2*(N-1) IN A5
          JP        A2,TINCY .     IF INCX IS NEGATIVE
          LNA       A4,*2,X11 .    ADD -2*INCX*(N-1)
          MSI       A4,A5 .        TO THE BASE
          AH        A2,A4 .        ADDRESS FOR X
TINCY     JP        A3,LOOP .      IF INCY IS NEGATIVE
          MSI       A5,*4,X11 .    ADD -2*INCY*(N-1)
          ANH       A3,A5 .        TO THE BASE ADDRESS FOR Y
.                                  BEGIN LOOP
LOOP      LA        A5,0,A2 .      LOAD REAL PART OF X
          FM        A5,0,A3 .      FORM REAL X * REAL Y
LOAD      LA        A4,1,A2 .      LOAD IMAG. PART OF X
          SA        A4,A6 .        STORE IMAG. X IN A6
          FM        A6,1,A3 .      FORM IMAG. X * IMAG. Y
          FAN       A5,A6 .        FORM REAL X*Y AND
          FA        A0,A5 .        ACCUMULATE IN A0
          FM        A4,0,A3 .      FORM IMAG. X * REAL Y
          LA        A5,0,*A2 .     LOAD REAL X AND INCREMENT X INDEX
          FM        A5,1,*A3 .     FORM REAL X * IMAG. Y, INCREMENT Y IN
          FA        A4,A5 .        FORM IMAG. X*Y AND
          FA        A8,A4 .        ACCUMULATE IN A8
          JGD       R3,LOOP .      END OF LOOP
          SA        A8,A1 .        STORE SUM OF IMAG X*Y IN A1
          DL        A6,A6A7 .      RESTORE A6 AND A7 REGISTERS
          DL        A8,A8A9 .      RESTORE A8 AND A9 REGISTERS
          J         6,X11 .        RETURN
$(0).
A6A7      +         0D .           PLACE TO SAVE A6 AND A7 REGISTERS
A8A9      +         0D .           PLACE TO SAVE A8 AND A9 REGISTERS
.
          END .
          AXR$
$(1).
.
.         SINGLE PRECISION ELEMENTARY VECTOR OPERATION
.
.    TO BE USED AS FORTRAN SUBROUTINE SAXPY(N,A,X,INCX,Y,INCY)
.    A, X, AND Y ARE TYPE SINGLE PRECISION
.    YY(I) IS REPLACED BY A*XX(I) + YY(I), I = 1,N
.    WHERE XX(I)=X(1-INCX+I*INCX) IF INCX.GE.0
.    AND   XX(I)=X(1-N*INCX+I*INCX) IF INCX.LT.0
.    AND YY(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED BY
.             Y AND INCY
.
SAXPY*    SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         7,X11 .        IF N.LE.0 RETURN
NPOS      LA        A0,*1,X11 .    STORE A IN A0
          JZ        A0,EXIT .      FAST EXIT IF A=0
          LA,U      A2,*2,X11 .    LOAD THE ADDRESS OF X AND
          LXI       A2,*3,X11 .    INCX
          LXI       A3,*5,X11 .    LOAD INCY AND
          LXM,U     A3,*4,X11 .    THE ADDRESS OF Y
          JP        A2,TINCY .     TEST IF INCX .GE. 0
          LNA       A4,A2 .        ADD -INCX*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A2,A4 .           FOR X
TINCY     JP        A3,LOOP .      TEST IF INCY .GE. 0
          LNA       A4,A3 .        ADD -INCY*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A3,A4 .           FOR Y
.                                  BEGIN LOOP TO
LOOP      LA        A4,0,*A2 .     LOAD X AND INCREMENT INDEX
          FM        A4,A0 .        FORM A*X
          FA        A4,0,A3 .      FORM A*X+Y AND
          SA        A4,0,*A3 .     STORE RESULT IN Y AND INCREMENT INDEX
          JGD       R3,LOOP .      END OF LOOP
EXIT      J         7,X11 .        RETURN
.
          END .
          AXR$
$(1).
.
.         DOUBLE PRECISION ELEMENTARY VECTOR OPERATION
.
.    TO BE USED AS FORTRAN SUBROUTINE DAXPY(N,A,X,INCX,Y,INCY)
.    A, X, AND Y ARE TYPE DOUBLE PRECISION
.    YY(I) IS REPLACED BY A*XX(I) + YY(I), I = 1,N
.    WHERE XX(I)=X(1-INCX+I*INCX) IF INCX.GE.0  (I=1,N)
.    AND   XX(I)=X(1-N*INCX+INCX*I) IF INCX.LT.0  (I=1,N)
.    AND YY(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED
.             BY Y AND INCY
.
DAXPY*    SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         7,X11 .        IF N.LE.0 RETURN
NPOS      DL        A0,*1,X11 .    STORE A IN A0 AND A1
          JZ        A0,EXIT .      FAST EXIT IF A=0
          LA,XH2    A2,*3,X11 .    STORE 2*INCX IN
          LSSC      A2,19 .        THE LEFT HALF OF A2
          LA,XH2    A3,*5,X11 .    STORE 2*INCY IN
          LSSC      A3,19 .        THE LEFT HALF OF A3
          LXM,U     A2,*2,X11 .    LOAD THE ADDRESS OF X
          LXM,U     A3,*4,X11 .    LOAD THE ADDRESS OF Y
          JP        A2,TINCY .     TEST IF INCX .GE. 0
          LNA       A4,A2 .        ADD -INCX*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A2,A4 .           FOR X
TINCY     JP        A3,LOOP .      TEST IF INCY .GE. 0
          LNA       A4,A3 .        ADD -INCY*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A3,A4 .           FOR V
LOOP      DL        A4,0,*A2 .     LOAD X AND INCREMENT INDEX
          DFM       A4,A0 .        FORM A*X
          DFA       A4,0,A3 .      FORM A*X+Y AND
          DS        A4,0,*A3 .     STORE IN Y, INCREMENT Y INDEX
          JGD       R3,LOOP .      END OF LOOP
EXIT      J         7,X11 .        RETURN
.
          END .
$(1).
          AXR$ .
.
.         APPLY MODIFIED GIVENS TRANSFORMATION TO (XX(1) ... XX(N))
.                                                 (YY(1) ... YY(N))
.    TO BE USED AS FORTRAN SUBROUTINE SROT(N,X,INCX,Y,INCY,PARAM)
.    X,Y, AND PARAM ARE SINGLE PRECISION -- SEE SROTMG FOR DEF. OF PARAM
.
.         XX(I)=X(1-INCX+I*INCX)    IF INCX .GE. 0
.         XX(I)=X(1-N*INCX+I*INCX)  IF INCY .LT. 0
.         YY(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED
.               BY Y AND INCY.
.
SROTM*      SZ        A3           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         7,X11 .        IF N .LE. 0 RETURN
.
NPOS      LA,U      A1,*1,X11 .    LOAD X ADDRESS
          LA,U      A2,*3,X11 .    LOAD Y ADDRESS
          LXI       A1,*2,X11 .    LOAD INCX
          LXI       A2,*4,X11 .    LOAD INCY
          JP        A1,TINCY .     IF INCX IS NEGATIVE
          LNA       A5,*2,X11 .    ADD -INCX*(N-1)
          MSI       A5,R3 .        TO THE BASE
          AH        A1,A5 .        ADDRESS FOR X
TINCY     JP        A2,LOOP .      IF INCY IS NEGATIVE
          LNA       A4,*4,X11 .    ADD -INCY*(N-1)
          MSI       A4,R3 .        TO THE BASE
          AH        A2,A4 .        ADDRESS FOR Y
.
LOOP      LA,U      A0,*5,X11 .    LOAD PARAM STARTING ADDRESS
          LA        A3,0,A0 .      LOAD FLAG
          JZ        A3,ZERO .      IF FLAG=0, TAKE ROUTE ZERO
          JN        A3,NEG .       IF FLAG .LT. 0, TAKE ROUTE NEG
.                                  FLAG IS POSITIVE
POS       LA        A3,0,A1 .      LOAD X
          FM        A3,1,A0 .      FORM H11 * X
          FA        A3,0,A2 .      ADD Y TO IT
          LA        A4,0,A2 .      LOAD Y
          FM        A4,4,A0 .      FORM H22 * 4
          FAN       A4,0,A1 .      ADD -X TO IT
          SA        A3,0,*A1 .     STORE NEW X, INCREMENT INDEX
          SA        A4,0,*A2 .     STORE NEW Y, INCREMENT INDEX
          JGD       R3,POS .       BOTTOM OF LOOP
          J         7,X11 .        RETURN
.                                  FLAG IS ZERO
ZERO      LA        A3,0,A2 .      LOAD Y
          FM        A3,3,A0 .      FORM H12 * Y
          FA        A3,0,A1 .      ADD X TO IT
          LA        A4,0,A1 .      LOAD X
          FM        A4,2,A0 .      FORM H21 * X
          FA        A4,0,A2 .      ADD Y TO IT
          SA        A3,0,*A1 .     STORE NEW X, INCREMENT INDEX
          SA        A4,0,*A2 .     STORE NEW Y, INCREMENT INDEX
          JGD       R3,ZERO .      BOTTOM OF LOOP
          J         7,X11 .        RETURN
.                                  FLAG IS NEGATIVE
NEG       TNE       A3,(-2.0) .    TEST FOR FLAG = -2
          J         7,X11 .        IF FLAG = -2, RETURN
          SA        A6,SAVE .      SAVE A6 CONTENTS
NEGL      LA        A3,0,A1 .      LOAD X
          FM        A3,1,A0 .      FORM H11 * X
          LA        A4,0,A2 .      LOAD Y
          FM        A4,3,A0 .      FORM H12 * Y AND
          FA        A3,A4 .        ADD TO H11 * X
          LA        A4,0,A1 .      LOAD X
          FM        A4,2,A0 .      FORM H21 * X
          LA        A5,0,A2 .      LOAD Y
          FM        A5,4,A0 .      FORM H22 * Y AND
          FA        A4,A5 .        ADD TO H21 * X
          SA        A3,0,*A1 .     STORE NEW X, INCREMENT INDEX
          SA        A4,0,*A2 .     STORE NEW Y, INCREMENT INDEX
          JGD       R3,NEGL .      BOTTOM OF LOOP
          LA        A6,SAVE .      RESTORE A6
          J         7,X11 .        RETURN
.
$(0).
SAVE      +         0 .            PLACE TO SAVE A6
          END
          AXR$
$(1).
.
.         SINGLE PRECISION COPY X INTO Y
.
.    TO BE USED AS FORTRAN SUBROUTINE SCOPY(N,X,INCX,Y,INCY)
.    WHERE X AND Y ARE OF TYPE SINGLE PRECISION.
.    XX(I) IS COPIED INTO YY(I), I=1,N  WHERE
.    XX(I)=X(1-INCX+I*INCX)    IF INCX.GE.0   AND
.    XX(I)=X(1-N*INCX+I*INCX)  IF INCX.LT.0   AND
.    YY(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED BY Y AND INCY
.
SCOPY*    SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R1,*0,X11 .    LOAD N IN R1
          LA        A4,R1 .        LOAD N IN A4
          JGD       A4,NPOS .      STORE N-1 IN A4, TEST N
          J         6,X11 .        IF N.LE.0 RETURN
NPOS      LA,U      A0,*1,X11 .    LOAD ADDRESS OF X
          LA,U      A1,*3,X11 .    LOAD ADDRESS OF Y
          LXI       A0,*2,X11 .    LOAD INCX
          LXI       A1,*4,X11 .    LOAD INCY
          JP        A0,TINCY .     IF INCX IS NEGATIVE,
          LNA       A2,*2,X11 .    ADD -INCX*(N-1)
          MSI       A2,A4 .        TO THE BASE
          AH        A0,A2 .        ADDRESS FOR X
TINCY     JP        A1,LOOP .      IF INCY IS NEGATIVE,
          MSI       A4,*4,X11 .    ADD -INCY*(N-1)
          ANH       A1,A4 .        TO THE BASE ADDRESS FOR Y
.
LOOP      BT        A1,0,*A0 .     COPY X INTO Y
          J         6,X11 .        RETURN
          END .
          AXR$
$(1).
.
.         DOUBLE PRECISION COPY X INTO Y AND COMPLEX COPY X INTO Y
.
.    TO BE USED AS FORTRAN SUBROUTINE DCOPY(N,X,INCX,Y,INCY)
.                                  OR CCOPY(N,X,INCX,Y,INCY)
.    WHERE X AND Y ARE OF TYPE DOUBLE PRECISION FOR DCOPY
.    AND TYPE COMPLEX FOR CCOPY.
.    XX(I) IS COPIED INTO YY(I), I=1,N  WHERE
.    XX(I)=X(1-INCX+I*INCX)    IF INCX.GE.0   AND
.    XX(I)=X(1-N*INCX+I*INCX)  IF INCX.LT.0   AND
.    YY(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED BY Y AND INCY
CCOPY*
DCOPY*    SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R1,*0,X11 .    STORE N IN R1
          LA        A4,R1 .        LOAD N INTO A4
          JGD       A4,NPOS .      TEST N, STORE N-1 IN A4
          J         6,X11 .        IF N.LE.0 RETURN
NPOS      SR        R1,R3 .        STORE N IN R3
          LA,XH2    A0,*2,X11 .    LOAD 2*INCX IN THE
          LSSC      A0,19 .        LEFT HALF OF A0
          LA,XH2    A1,*4,X11 .    LOAD 2*INCY IN THE
          LSSC      A1,19 .        LEFT HALF OF A1
          LXM,U     A0,*1,X11 .    LOAD THE ADDRESS OF X
          LXM,U     A1,*3,X11 .    LOAD THE ADDRESS OF Y
          LSSC      A4,1 .         FORM 2*(N-1)
          JP        A0,TINCY .     IF INCX IS NEGATIVE
          LNA       A2,*2,X11 .    ADD -2*INCX*(N-1)
          MSI       A2,A4 .        TO THE BASE
          AH        A0,A2 .        ADDRESS FOR X
TINCY     JP        A1,SAVE .      IF INCY IS NEGATIVE,
          MSI       A4,*4,X11 .    ADD -2*INCY*(N-1)
          ANH       A1,A4 .        TO THE BASE ADDRESS FOR Y
SAVE      DS        A0,A2 .        STORE X AND Y INDEXES
          BT        A1,0,*A0 .     BLOCK TRANSFER FIRST HALF OF EACH NO.
          SR        R3,R1 .        RELOAD R1 WITH N
          AH        A2,(1) .       ADD 1 TO THE BASE ADDRESS FOR X
          AH        A3,(1) .       ADD 1 TO THE BASE ADDRESS FOR Y
          BT        A3,0,*A2 .     BLOCK TRANS. SECOND HALF OF EACH NO.
          J         6,X11 .        RETURN
.
          END .
          AXR$
$(1).
.
.         INTERCHANGE INCREMENTED X AND Y COMPONENTS
.
.    TO BE USED AS FORTRAN SUBROUTINE DSWAP(N,X,INCX,Y,INCY)
.           AND AS FORTRAN SUBROUTINE CSWAP(N,X,INCX,Y,INCY)
.    WHERE X AND Y ARE OF TYPE DOUBLE PRECISION FOR DSWAP
.    AND TYPE COMPLEX FOR CSWAP
.    XX(I) IS INTERCHANGED WITH YY(I), I=1,N WHERE
.    XX(I)=X(1-INCX+I*INCX)    IF INCX.GE.0 AND
.    XX(I)=X(1-N*INCX+I*INCX)  IF INCX.LT.0 AND
.    YY(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED BY Y AND INCY
.
CSWAP*
DSWAP*    SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         6,X11 .        IF N.LE.0 RETURN
NPOS      LA,XH2    A2,*2,X11 .    LOAD 2*INCX IN THE
          LSSC      A2,19 .        LEFT HALF OF A2
          LA,XH2    A3,*4,X11 .    LOAD 2*INCY IN THE
          LSSC      A3,19 .        LEFT HALF OF A3
          LXM,U     A2,*1,X11 .    LOAD THE ADDRESS OF X
          LXM,U     A3,*3,X11 .    LOAD THE ADDRESS OF Y
          JP        A2,TINCY .     TEST IF INCX .GE. 0
          LNA       A4,A2 .        ADD -INCX*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A2,A4 .           FOR X
TINCY     JP        A3,LOOP .      TEST IF INCY .GE. 0
          LNA       A4,A3 .        ADD -INCY*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A3,A4 .           FOR Y
LOOP      DL        A0,0,A2 .      LOAD X
          DL        A4,0,A3 .      LOAD Y
          DS        A4,0,*A2 .     STORE Y IN X AND INCREMENT X INDEX
          DS        A0,0,*A3 .     STORE X IN Y AND INCREMENT Y INDEX
          JGD       R3,LOOP .      END OF LOOP
          J         6,X11 .        RETURN
          END .
          AXR$
$(1).
.
.         SQRT OF SUM OF SQUARES OF COMPONENTS OF X
.
.    TO BE USED AS FORTRAN FUNCTION  SNRM2(N,X,INCX)
.    WHERE SNRM2 IS THE SQUARE ROOT OF THE SUM FROM I=1 TO N OF
.                X(1-INCX+I*INCX)
.    SNRM2 AND X ARE OF TYPE REAL
.
.    THIS VERSION OF SNRM2 USES MACHINE-DEPENDENT CONSTANTS TO
.    AVOID UNDERFLOW AND OVERFLOW.
.    THE CONSTANTS FOR THE UNIVAC 1108 ARE...
.    UNDERFLOW -- 1.E-15
.    OVERFLOW--  1.E17   OVERFLOW PROTECTION--  1.E21
.
SNRM2*    SZ        A0 .           STORE ZERO IN A0
          SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         4,X11 .        IF N.LE.0 RETURN
NPOS      LA,U      A2,*1,X11 .    LOAD X ADDRESS AND
          LXI       A2,*2,X11 .    INCX IN A2
          SA        A2,A3 .        AND A3
          SZ        A5 .           STORE ZERO IN A5
          DS        A6,A6A7 .      SAVE THE CONTENTS OF A6 AND A7 REGIST
          SR        R3,R1 .        STORE N-1 IN R1
.                                  BEGIN UNDERFLOW LOOP
UNDER     LMA       A4,0,*A3 .     LOAD ABS X AND INCREMENT X INDEX
          TG        A4,MIN .       IF ABS X .GT. MACHINE MIN,
          J         OVER .         GO TO TEST FOR OVERFLOW. OTHERWISE
          TLE       A5,A4 .        IF U .LT. ABS X,
          SA        A4,A5 .        U= ABS X THAT WAS .GT. U
          JGD       R3,UNDER .     END OF UNDERFLOW LOOP
          JZ        A5,4,X11 .     IF U=0, RETURN. OTHERWISE
          AND       A5,MASK .      STORE A5 EXPONENT IN A6
          J         EXP+1 .        GO COMPUTE SNRM2
.                                  BEGIN OVERFLOW LOOP
OVER      LMA       A4,0,*A2 .     LOAD ABS X AND INCREMENT X INDEX
          TG        A4,MAX .       IF ABS X IS TOO LARGE,
          J         EXP .          GO PROTECT FROM OVERFLOW. OTHERWISE
          FM        A4,A4 .        SQUARE X
          FA        A0,A4 .        ACCUMULATE SUM OF SQUARES
          JGD       R1,OVER .      END OF OVERFLOW LOOP
          LA        A7,(1.0) .     STORE 1.E0 IN A7
ROOT      SX        X11,WB+1 .     SAVE X11 CONTENTS
          SA        A0,SUM .       STORE SUM OF SQUARES IN SUM
          LMJ       X11,SQRT .     GO COMPUTE SQUARE ROOT OF SUM
          +         SUM .
          +         $-SNRM2,WB .
          FM        A0,A7 .        COMPUTE THE TRUE VALUE OF SNRM2
          LX        X11,WB+1 .     RESTORE X11
          DL        A6,A6A7 .      RESTORE A6 AND A7
          J         4,X11 .        RETURN
EXP       LA        A6,COMP .      STORE 1.E22 EXPONENT IN A6
          AU        A6,FRAC .      STORE 1.E22 IN A7
          ANA       A6,BIAS .      COMPUTE BIASED EXPONENT
          JZ        A0,MOD+1 .     IF SNRM2=0, GO COMPUTE SNRM2. OTHERWI
          ANA       A0,A6 .        COMPUTE SNRM2/U
          ANA       A0,A6 .                       /U
          JP        A0,MOD+1 .     IF SNRM2 .GT.0 GO COMPUTE THE REST OF
          SZ        A0 .           OTHERWISE ZERO IT OUT, THEN
          J         MOD+1 .        GO FINISH THE COMPUTATIONS
MOD       LMA       A4,0,*A2 .     LOAD ABS X AND INCREMENT X INDEX
          ANA       A4,A6 .        MODIFY EXPONENT OF X
          FM        A4,A4 .        SQUARE X
          FA        A0,A4 .        ACCUMULATE SUM OF SQUARES
          JGD       R1,MOD .       END OF LOOP TO ACCUMULATE SQUARES
          J         ROOT .         GO COMPUTE SQUARE ROOT
$(0) .
A6A7      +         0D .           PLACE TO SAVE A6 AND A7 CONTENTS
SUM       +         0 .            PLACE TO SAVE SUM OF SQUARES
WB        +         'SNRM2' .      WALKBACK WORD
          +         0 .            PLACE TO STORE X11
MIN       +         (01150,0,0)    MACHINE MINIMUM EXPONENT
MAX       +         (02700,0,0)    MACHINE MAXIMUM EXPONENT
COMP      +         (03130,0,0)    VALUE TO COMPENSATE FOR OVERFLOW (EXP
BIAS      +         (02000,0,0)    BIAS ON THE EXPONENT
MASK      +         (07770,0,0)    MASK FOR 1.E-15 EXPONENT
FRAC      +         (00014,0,0)    MANTISSA FOR 1.E-15 AND 1.E22
.
          END .
          AXR$
$(1).
.
.         DOUBLE PRECISION SQRT OF SUM OF SQUARES OF X COMPONENTS
.    TO BE USED AS FORTRAN SUBROUTINE DNRM2(N,X,INCX)
.    WHERE DNRM2 IS THE SQUARE ROOT OF THE SUM FROM I=1 TO N OF
.                X(1-INCX+I*INCX)
.    DNRM2 AND X ARE OF TYPE DOUBLE PRECISION
.
.    THIS VERSION OF DNRM2 USES MACHINE-DEPENDENT CONSTANTS TO
.    AVOID OVERFLOW AND UNDERFLOW
.    THE CONSTANTS FOR THE UNIVAC 1108 ARE ...
.    UNDERFLOW-- 1.D-149
.    OVERFLOW--  1.D+149      OVERFLOW PROTECTION-- 1.D+157
DNRM2*    DSL       A0,72 .        STORE ZERO IN A0 AND A1
          SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         4,X11 .        IF N.LE.0, RETURN
NPOS      LA,XH2    A3,*2,X11 .    LOAD 2*INCX IN THE
          LSSC      A3,19 .        LEFT HALF OF A3
          LXM,U     A3,*1,X11 .    LOAD THE ADDRESS OF X
          SA        A3,A2 .        STORE X INDEX IN A2
          DS        A6,A6A7 .      SAVE CONTENTS OF A6 AND A7 REGISTERS
          SA        A8,SAVE .      SAVE CONTENTS OF A8 REGISTER
          SZ        A5 .           STORE ZERO IN A5
          SZ        A8 .           STORE ZERO IN A8
          SR        R3,R1 .        STORE N-1 IN R1
.                                  BEGIN UNDERFLOW LOOP
UNDER     LMA       A4,0,*A3 .     LOAD TOP HALF OF ABS X, INCREMENT X I
          TG        A4,MIN .       IF ABS X .GT. MACHINE MIN,
          J         OVER .         GO TO TEST FOR OVERFLOW. OTHERWISE
          TLE       A5,A4 .        IF U .LT. ABS X
          SA        A4,A5 .        U= ABS X THAT WAS .GT. U
          JGD       R3,UNDER .     END OF UNDERFLOW LOOP
          JZ        A5,4,X11 .     IF U=0, RETURN.  OTHERWISE
          AND       A5,MASK .      STORE AS EXPONENT IN A6
.                                  BEGIN OVERFLOW LOOP (USUAL CASE)
          AU        A6,FRAC .      STORE U IN A7
          ANA       A6,BIAS .      COMPUTE BIASED EXPONENT
         J          MOD .          GO COMPUTE DNRM2
OVER      DLM       A4,0,*A2 .     LOAD ABS X
          TG        A4,MAX .       IF ABS X IS TOO LARGE,
          J         EXP .          GO PROTECT FROM OVERFLOW. OTHERWISE
          DFM       A4,A4 .        SQUARE X
          DFA       A0,A4 .        ACCUMULATE SUM OF SQUARES
          JGD       R1,OVER .      END OF OVERFLOW LOOP
          LA        A7,ONE .       STORE 1.DO IN A7 (A8 ALREADY = ZERO)
ROOT      SX        X11,WB+1 .     SAVE X11 CONTENTS
          DS        A0,SUM .       STORE SUM OF SQUARES IN SUM
          LMJ       X11,DSQRT .    GO COMPUTE SQUARE ROOT OF SUM
          +         SUM .
          +         $-DNRM2,WB .
          DFM       A0,A7 .        COMPUTE THE TRUE VALUE OF DNRM2
          LX        X11,WB+1 .     RESTORE X11
          DL        A6,A6A7 .      RESTORE A6 AND A7
          LA        A8,SAVE .      RESTORE A8
          J         4,X11 .        RETURN
EXP       LA        A6,COMP .      STORE 1.D157 EXPONENT IN A6
          AU        A6,FRAC .      STORE U IN A7
          ANA       A6,BIAS .      COMPUTE BIASED EXPONENT
          ANA       A0,A6 .        COMPUTE DNRM2/U
          ANA       A0,A6 .                       /U
          JP        A0,MOD+1 .     IF DNRM2 .GE.0 GO COMPUTE THE REST OF
          DSL       A0,72 .        OTHERWISE ZERO IT OUT, THEN
          J         MOD+1 .        GO FINISH THE COMPUTATIONS
MOD       DLM       A4,0,*A2 .     LOAD ABS X AND INCREMENT X INDEX
          ANA       A4,A6 .        MODIFY EXPONENT OF X
          DFM       A4,A4 .        SQUARE X
          DFA       A0,A4 .        ACCUMULATE SUM OF SQUARES
          JGD       R1,MOD .       END OF LOOP TO ACCUMULATE SQUARES
          J         ROOT .         GO COMPUTE SQUARE ROOT
$(0).
A6A7      +         0D .           PLACE TO SAVE A6 AND A7 CONTENTS
SAVE      +         0 .            PLACE TO SAVE A8 CONTENTS
SUM       +         0D .           PLACE TO SAVE SUM OF SQUARES
WB        +         'DNRM2' .      WALKBACK WORD
          +         0 .            PLACE TO STORE X11
MIN       +         (01036,0,0) .       MIN EXPONEN,2**-482, APPROX 1.D-
MAX       +         (02761,0,0) .       MAX EXPONENT=2**497, APPROX 1.D1
COMP      +         (03016,0,0) .       OVERFLOW PROTECTION EXPONENT
BIAS      +         (02000,0,0) .       BIAS ON THE EXPONENT
MASK      +         (03777,0,0) .       MASK FOR MIN EXPONENT
FRAC      +         (00001,04000,0) .    CONVERTS EXPONENT TO EXPONENT W
.                                       FRACTION OF .5
ONE       +         (02001,04000,0) .    TOP PART OF 1.D0
.
          END .
          AXR$
$(1).
.
.         SQRT OF SUM OF SQUARES OF COMPONENTS OF X
.
.    TO BE USED AS FORTRAN FUNCTION  SCNRM2(N,X,INCX)
.    WHERE SCNRM2 IS THE SQUARE ROOT OF THE SUM FROM I=1 TO N OF
.                (ABS(X(1-INCX+I*INCX)))**2
.    SCNRM2 IS OF TYPE REAL AND X IS OF TYPE COMPLEX
.
.    THIS VERSION OF SCNRM2 USES MACHINE DEPENDENT CONSTANTS TO
.    AVOID UNDERFLOW AND OVERFLOW
.    THE CONSTANTS FOR THE UNIVAC 1108 ARE ...
.    UNDERFLOW -- 1.E-15
.    OVERFLOW  -- 1.E+17      OVERFLOW PROTECTION -- 1.E+22
.
SCNRM2*   SZ        A0 .           STORE ZERO IN A0
          SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         4,X11 .        IN N.LE.0 RETURN
NPOS      SR        R3,R1 .        STORE N-1 IN R1
          DS        A6,A6A7 .      SAVE THE CONTENTS OF A6 AND A7 REGIST
          SZ        A6 .           STORE ZERO IN A6
          LA,XH2    A3,*2,X11 .    LOAD 2* INCX IN THE
          LSSC      A3,19 .        LEFT HALF OF A3
          LXM,U     A3,*1,X11 .    LOAD THE ADDRESS OF X
          SA        A3,A2 .        STORE X INDEX IN A2
.                                  TOP OF UNDERFLOW LOOP
UNDER     LMA       A4,0,A3 .      LOAD ABS REAL X
          LMA       A5,1,*A3 .     LOAD ABS IMAG X AND INCREMENT INDEX
          FA        A4,A5 .        ADD THE TWO PARTS OF X
          TG        A4,MIN .       IF ABS X .GT. MACHINE MIN
          J         OVER .         GO TO TEST FOR OVERFLOW.  OTHERWISE
          TLE       A6,A4 .        IF U .LT. ABS X
          SA        A4,A6 .        STORE ABS X IN U
          JGD       R3,UNDER .     BOTTOM OF UNDERFLOW LOOP
          JZ        A6,4,X11 .     IF U=0, RETURN.  OTHERWISE
          SA        A6,A5 .        STORE U IN A5
          AND       A5,MASK .      STORE EXPONENT OF U IN A6
          AU        A6,FRAC .      STORE U IN A7
          ANA       A6,BIAS .      COMPUTE BIASED EXPONENT AND
          SA        A6,BIAS .      STORE IN BIAS
          J         MOD .          GO COMPUTE SCNRM2
.                                  TOP OF OVERFLOW LOOP
OVER      LMA       A3,0,A2 .      LOAD ABS REAL X
          LMA       A5,1,*A2 .     LOAD ABS IMAG X AND INCREMENT INDEX
          TLE       A3,MAX .       TEST OT SEE IF EITHER PART OF X
          TG        A5,MAX .       WILL CAUSE AN OVERFLOW
          J         EXP .          IF YES, GO PROTECT FROM OVERFLOW.  EL
          FM        A3,A3 .        SQUARE REAL X
          FM        A5,A5 .        SQUARE IMAG X AND
          FA        A3,A5 .        ADD TO REAL PART, THEN
          FA        A0,A3 .        ACCUMULATE THE SUM OF SQUARES
          JGD       R1,OVER .      BOTTOM OF OVERFLOW LOOP
          LA        A7,ONE .       STORE 1.E0 IN A7
ROOT      SX        X11,WB+1 .     SAVE X11 CONTENTS
          SA        A0,SUM .       STORE SUM OF SQUARES IN SUM
          LMJ       X11,SQRT .     GO COMPUTE SQUARE ROOT OF SUM
          +         SUM .
          +         $-SCNRM2,WB .
          FM        A0,A7 .        COMPUTE THE TRUE VALUE OF SCNRM2
          LX        X11,WB+1 .     RESTORE X11
          DL        A6,A6A7 .      RESTORE A6 AND A7
          J         4,X11 .
EXP       LA        A6,COMP .      STORE 1.E22 EXPONENT IN A6
          AU        A6,FRAC .      STORE U IN A7
          ANA       A6,BIAS .      COMPUTE BIASED EXPONENT
          SA        A6,BIAS .      AND STORE IN BIAS
          ANA       A0,BIAS .      COMPUTE SCNRM2/U
          ANA       A0,BIAS .                      /U
          JP        A0,MOD+2 .     IF SCNRM2.GT.0, GO COMPUTE THE REST O
          SZ        A0 .           OTHERWISE ZERO IT OUT, THEN
          J         MOD+2 .        GO FINISH THE COMPUTATIONS
.                                  TOP OF LOOP WITH MODIFIED EXPONENT
MOD       LMA       A3,0,A2 .      LOAD ABS REAL X
          LMA       A5,1,*A2 .     LOAD ABS IMAG X AND INCREMENT INDEX
          ANA       A3,BIAS .      MODIFY EXPONENT OF REAL X
          ANA       A5,BIAS .      AND IMAG X
          FM        A3,A3 .        SQUARE REAL X
          FM        A5,A5 .        SQUARE IMAG X AND
          FA        A3,A5 .        ADD TO REAL PART, THEN
          FA        A0,A3 .        ACCUMULATE THE SUM IN A0
          JGD       R1,MOD .       BOTTOM OF LOOP WITH MODIFIED EXPONENT
          J         ROOT .         GO COMPUTE SQUARE ROOT
$(0).
A6A7      +         0D .           PLACE TO SAVE A6 AND A7 CONTENTS
SUM       +         0 .            PLACE TO SAVE SUM OF SQUARES
WB        +         'SCNRM2' .     WALKBACK WORD
          +         0 .            PLACE TO STORE X11
MIN       +         (01150,0,0) .  MACHINE MINIMUM EXPONENT
MAX       +         (02700,0,0) .  MACHINE MAXIMUM EXPONENT
COMP      +         (03130,0,0) .  EXPONENT OF VALUE TO COMPENSATE FOR O
BIAS      +         (02000,0,0) .  BIAS ON THE EXPONENT
MASK      +         (07770,0,0) .  MASK FOR MINIMUM EXPONENT
FRAC      +         (00014,0,0) .  MANTISSA FOR U
ONE       +         (02014,0,0) .  1.E0
.
          END .
          AXR$
$(1).
.         SINGLE PRECISION
.         SUM OF ABSOLUTE VALUES OF INCREMENTED X COMPONENTS
.
.    TO BE USED AS FORTRAN FUNCTION SASUM(N,X,INCX)
.    WHERE SASUM IS THE SUM FROM 1 TO N OF ABS(X(I*INCX-INCX+1))
.    AND SASUM AND X ARE OF TYPE SINGLE PRECISION
.
SASUM*    SZ        A0 .           STORE ZERO IN A0
          SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         4,X11 .        IF N.LE.0 RETURN
NPOS      LA,U      A2,*1,X11 .    LOAD ADDRESS OF X
          LXI       A2,*2,X11 .    LOAD INCX
.                                  BEGIN LOOP TO
LOOP      LMA       A3,0,*A2 .     LOAD ABS X  AND
          FA        A0,A3 .        ACCUMULATE SUM OF ABS X IN A0
          JGD       R3,LOOP .      END LOOP
          J         4,X11 .        RETURN
          END .
          AXR$
$(1).
.         DOUBLE PRECISION
.         SUM OF ABSOLUTE VALUES OF INCREMENTED X COMPONENTS
.
.    TO BE USED AS FORTRAN FUNCTION DASUM(N,X,INCX)
.    WHERE DASUM IS THE SUM FROM 1 TO N OF ABS(X(I*INCX-INCX+1))
.    AND DASUM AND X ARE OF TYPE DOUBLE PRECISION
.
DASUM*    DSL       A0,72 .        STORE ZERO IN A0 AND A1
          SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         4,X11 .        IF N.LE.0 RETURN
NPOS      LA,XH2    A2,*2,X11 .    LOAD 2*INCX IN THE
          LSSC      A2,19 .        LEFT HALF OF A2
          LXM,U     A2,*1,X11 .    LOAD THE ADDRESS OF X
.                                  BEGIN LOOP TO
LOOP      DLM       A3,0,*A2 .     LOAD ABS X  AND
          DFA       A0,A3 .        ACCUMULATE SUM OF ABS X
          JGD       R3,LOOP .      END LOOP
          J         4,X11 .        RETURN
          END .
          AXR$
$(1).
.
.         SUM OF ABSOLUTE VALUES OF REAL AND IMAGINARY PARTS OF X
.
.    TO BE USED AS FORTRAN FUNCTION SCASUM(N,X,INCX)
.    WHERE SCASUM IS THE SUM FROM I=1 TO N OF REAL X(I) + IMAG. X(I),
.    X IS OF TYPE COMPLEX AND SCASUM IS OF TYPE REAL
.
SCASUM*   SZ        A0 .           STORE ZERO IN A0
          SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         4,X11 .        IF N.LE.0 RETURN
NPOS      LA,XH2    A3,*2,X11 .    LOAD 2*INCX IN THE
          LSSC      A3,19 .        LEFT HALF OF A3
          LXM,U     A3,*1,X11 .    LOAD THE ADDRESS OF X
LOOP      LMA       A4,0,A3 .      LOAD ABS REAL X
          LMA       A5,1,*A3 .     LOAD ABS IMAG. X
          FA        A4,A5 .        ADD THE TWO PARTS OF X AND
          FA        A0,A4 .        ACCUMULATE THE SUM IN A0
          JGD       R3,LOOP .      END OF LOOP
          J         4,X11 .        RETURN
          END .
         AXR$
$(1).
.
.        SINGLE PRECISION SCALING
.
.    TO BE USED AS FORTRAN SUBROUTINE SSCAL(N,A,X,INCX).
.    REPLACES X(I*INCX-INCX+1) WITH A*X(I*INCX-INCX+1), I=1,N
.
SSCAL*    SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         5,X11 .        IF N.LE.0 RETURN
NPOS      LA        A0,*1,X11 .    LOAD A IN A0
          LA,U      A2,*2,X11 .    LOAD ADDRESS OF X, AND
          LXI       A2,*3,X11 .    INCX IN A2
.                                  BEGIN LOOP TO
LOOP      LA        A4,0,A2 .      LOAD X
          FM        A4,A0          FORM  A*X AND
          SA        A4,0,*A2 .     STORE IN X, INCREMENT X INDEX
          JGD       R3,LOOP .      END OF LOOP
          J         5,X11 .        RETURN
.
          END .
         AXR$
$(1).
.
.        DOUBLE PRECISION SCALING
.
.    TO BE USED AS FORTRAN SUBROUTINE DSCAL(N,A,X,INCX).
.    REPLACES X(I*INCX-INCX+1) WITH A*X(I*INCX-INCX+1), I=1,N.
.    A AND X ARE TYPE DOUBLE PRECISION
.
DSCAL*    SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         5,X11 .        IF N.LE.0 RETURN
NPOS      DL        A0,*1,X11 .    LOAD A IN A0 AND A1
          LA,XH2    A3,*3,X11 .    LOAD 2*INCX IN THE
          LSSC      A3,19 .        LEFT HALF OF A3
          LXM,U     A3,*2,X11 .    LOAD THE ADDRESS OF X
.                                  BEGIN LOOP TO
LOOP      DL        A4,0,A3 .      LOAD X IN A4 AND A5
          DFM       A4,A0 .        FORM A*X AND
          DS        A4,0,*A3 .     STORE IN X, INCREMENT X INDEX
          JGD       R3,LOOP .      END OF LOOP
          J         5,X11 .        RETURN
.
          END .
         AXR$
$(1).
.
.        COMPLEX SCALING
.
.    TO BE USED AS FORTRAN SUBROUTINE CSCAL(N,A,X,INCX).
.    REPLACES X(I*INCX-INCX+1) WITH A*X(I*INCX-INCX+1), I=1,N.
.    A AND X ARE TYPE COMPLEX
.
CSCAL*    SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         5,X11 .        IF N.LE.0 RETURN
NPOS      LA,U      A1,*1,X11 .    LOAD THE ADDRESS OF A
          LR        R1,0,A1 .      LOAD REAL A IN R1
          LR        R2,1,A1 .      LOAD IMAG. A IN R2
          SA        A6,SAVE .      SAVE THE CONTENTS OF A6 REGISTER
          LA,XH2    A3,*3,X11 .    LOAD 2*INCX IN THE
          LSSC      A3,19 .        LEFT HALF OF A3
          LXM,U     A3,*2,X11 .    LOAD THE ADDRESS OF X
LOOP      LA        A0,0,A3 .      LOAD REAL X IN A0
          SA        A0,A1 .        AND A1
          FM        A1,R1 .        FORM REAL A * REAL X
          LA        A4,1,A3 .      LOAD IMAG. X IN A4
          LNA       A5,A4 .        STORE -IMAG. X IN A5
          FM        A5,R2 .        FORM IMAG. A * -IMAG. X
          FA        A5,A1 .        FORM REAL A*X AND
          SA        A5,0,A3 .      STORE IN REAL X
          FM        A0,R2 .        FORM IMAG. A * REAL X
          FM        A4,R1 .        FORM REAL A * IMAG. X
          FA        A0,A4 .        FORM IMAG. A*X AND STORE
          SA        A0,1,*A3 .     IN IMAG. X, INCREMENT X INDEX
          JGD       R3,LOOP .      END OF LOOP
          LA        A6,SAVE .      RESTORE A6
          J         5,X11 .        RETURN
$(0).
SAVE      +         0.
.
          END .
          AXR$
$(1).
.
.         REAL SCALING ON COMPLEX VECTORS
.
.    TO BE USED AS FORTRAN SUBROUTINE CSSCAL(N,A,X,INCX)
.    WHERE A IS OF TYPE SINGLE PRECISION AND X IS OF TYPE COMPLEX.
.    X(REAL)+X(IMAGINARY) IS REPLACED BY A*X(REAL)+A*X(IMAGINARY)
.    X=X(I*INCX-INCX+1), I=1,N
.
CSSCAL*   SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         5,X11 .        IF N.LE.0 RETURN
NPOS      LA        A0,*1,X11 .    LOAD A IN A0
          LA,XH2    A3,*3,X11 .    LOAD 2*INCX IN THE
          LSSC      A3,19 .        LEFT HALF OF A1
          LXM,U     A3,*2,X11 .    LOAD THE ADDRESS OF X
.                                  BEGIN LOOP TO
LOOP      LA        A1,0,A3 .      LOAD REAL X IN A1
          FM        A1,A0 .        FORM A*REAL X
          SA        A1,0,A3 .      STORE A*REAL X
          LA        A1,1,A3 .      LOAD IMAG. X IN A1
          FM        A1,A0 .        FORM A*IMAG. X
          SA        A1,1,*A3       STORE A*IMAG. X AND INCREMENT X INDEX
          JGD       R3,LOOP .      END OF LOOP
          J         5,X11 .        RETURN
.
          END .
          AXR$
$(1).
.
.         FIND THE INDEX OF MAX. ABSOLUTE VALUE OF X COMPONENTS
.
.    TO BE USED AS FORTRAN FUNCTION ISAMAX(N,X,INCX)
.    WHERE X IS OF TYPE REAL AND ISAMAX IS THE INDEX OF THE MAXIMUM
.    ABSOLUTE VALUE OF X(I), I=1,N. X(I)=X(1-INCX+I*INCX)
.
ISAMAX*   SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          LA        A0,R3 .        AND A0
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         4,X11 .        IF N.LE.0 RETURN
NPOS      LXI       A3,*2,X11 .    LOAD INCX IN LEFT OF A3
          LXM,U     A3,*1,X11 .    LOAD THE ADDRESS OF X
          LA,XU     A2,-1 .        LOAD -1 IN A2
LOOP      LMA       A4,0,*A3 .     LOAD ABS X, INCREMENT INDEX
          TG        A2,A4 .        TEST IF X IS OUT OF BOUNDS
          J         END .          IF NO, GO TO BOTTOM OF LOOP
          LA        A2,A4 .        IF YES, RESET MAXIMUJM VALUE AND
MOVEI     LA        A1,R3 .        STORE THE INDEX OF X
END       JGD       R3,LOOP .      BOTTOM OF LOOP
          ANA       A0,A1 .        GET THE CORRECT INDEX FOR MAX X
          J         4,X11 .        RETURN
          END .
          AXR$
$(1).
.
.         DOUBLE PRECISION
.         FIND THE INDEX OF MAX. ABSOLUTE VALUE OF X COMPONENTS
.
.    TO BE USED AS FORTRAN FUNCTION IDAMAX(N,X,INCX)
.    WHERE X IS OF TYPE DOUBLE PRECISION AND IDAMAX IS THE INDEX OF
.    THE MAXIMUM ABSOLUTE VALUE OF X(I), I=1,N. X(I)=X(1-INCX+I*INCX)
.
IDAMAX*   SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          LA        A0,R3 .        AND A0
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         4,X11 .        IF N.LE.0 RETURN
NPOS      LA,XH2    A3,*2,X11 .    LOAD 2*INCX IN THE
          LSSC      A3,19 .        LEFT HALF OF A3
          LXM,U     A3,*1,X11 .    LOAD THE ADDRESS OF X
          DL        A1,(-1D) .     LOAD -1 IN A1 AND A2
LOOP      DLM       A4,0,*A3 .     LOAD ABS X, INCREMENT INDEX
          TLE       A1,A4 .        TEST IF 1ST HALF OF X IS OUT OF BOUND
          J         MOVEX .        IF YES, GO STORE NEW MAX
          TNE       A4,A1 .        TEST IF IT IS EQUAL TO LAST MAX
          TG        A2,A5 .        IF YES, TEST IF 2ND HALF OF X EXCEEDS
          J         END .          IF NO, GO TO BOTTOM OF LOOP
MOVEX     DL        A1,A4 .        IF YES, RESET MAXIMUM VAUE AND
MOVEI     LR        R1,R3 .        STORE THE INDEX OF X
END       JGD       R3,LOOP .      BOTTOM OF LOOP
          ANA       A0,R1 .        GET THE CORRECT INDEX FOR MAX X
          J         4,X11 .        RETURN
          END .
          AXR$
$(1).
.
.         FIND THE INDEX OF COMPLEX X COMPONENT HAVING MAXIMUM SUM OF
.         MAGNITUDES OF REAL AND IMAGINARY PARTS
.
.    TO BE USED AS FORTRAN FUNCTION ICAMAX(N,X,INCX)
.    WHERE X IS OF TYPE COMPLEX AND ICAMAX IS THE INDEX OF THE MAXIMUM
.    VALUE OF ABS(REAL X(I)) + ABS(IMAG. X(I)), I=1,N.
.    X(I)=X(1-INCX+I*INCX)
.
ICAMAX*   SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          LA        A0,R3 .        AND A0
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         4,X11 .        IF N.LE.0 RETURN
NPOS      LA,XH2    A3,*2,X11 .    LOAD 2*INCX IN THE
          LSSC      A3,19 .        LEFT HALF OF A3
          LXM,U     A3,*1,X11 .    LOAD THE ADDRESS OF X
          LA,XU     A2,-1 .        LOAD -1 IN A2
LOOP      LMA       A4,0,A3 .      LOAD ABS REAL X
          LMA       A5,1,*A3 .     LOAD ABS IMAG X
          FA        A4,A5 .        ADD THE TWO PARTS OF X
          TG        A2,A4 .        TEST IF X IS OUT OF BOUNDS
          J         END .          IF NO, GO TO BOTTOM OF LOOP
          LA        A2,A4 .        IF YES, RESET MAXIMUM VALUE AND
MOVEI     LA        A1,R3 .        STORE THE INDEX OF X
END       JGD       R3,LOOP .      BOTTOM OF LOOP
          ANA       A0,A1 .        GET THE CORRECT INDEX FOR MAX X
          J         4,X11 .        RETURN
.
          END .
          AXR$
$(1).
.
.         COMPLEX TYPE ELEMENTARY VECTOR OPERATION
.
.    TO BE USED AS FORTRAN SUBROUTINE CAXPY(N,A,X,INCX,Y,INCY)
.    A, X, AND Y ARE TYPE COMPLEX
.    YY(I) IS REPLACED BY A*XX(I) + YY(I), I = 1,N
.    WHERE XX(I)=X(1-INCX+I*INCX)    IF INCX.GE.0
.    AND   XX(I)=X(1-N*INCX+I*INCX)  IF INCX.LT.0
.    AND YY(I) IS SIMILARLY DEFINED, WITH X AND INCY REPLACED
.             BY Y AND INCY
.
CAXPY*    SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11      LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         7,X11 .        IF N.LE.0 RETURN
NPOS      DL        A4,*1,X11 .    LOAD A IN A4 AND A5
          JNZ       A4,$+2 .       FAST EXIT
          JZ        A5,EXIT .      IF A = 0
          DS        A6,A6A7 .      SAVE A6 AND A7
          DS        A4,R1 .        STORE A IN R1 AND R2
          LA,XH2    A2,*3,X11 .    STORE 2*INCX IN THE
          LSSC      A2,19 .        LEFT HALF OF A2
          LA,XH2    A3,*5,X11 .    STORE 2*INCY IN THE
          LSSC      A3,19 .        LEFT HALF OF A3
          LXM,U     A2,*2,X11 .    LOAD THE ADDRESS OF X
          LXM,U     A3,*4,X11 .    LOAD THE ADDRESS OF Y
          JP        A2,TINCY .     TEST IF INCX .GE. 0
          LNA       A4,A2 .        ADD -INCX*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A2,A4 .           FOR X
TINCY     JP        A3,LOOP .      TEST IF INCY .GE. 0
          LNA       A4,A3 .        ADD -INCY*(N-1)
          SSA       A4,18 .          TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A3,A4 .           FOR Y
LOOP      LA        A4,0,A2 .      LOAD THE REAL PART OF X IN A4
          SA        A4,A0 .        AND A0
          FM        A4,R1 .        FORM REAL A * REAL X
          LA        A5,1,*A2 .     LOAD IMAG. X IN A5 AND
          LNA       A6,A5 .        STORE -IMAG. X IN A6
          FM        A6,R2 .        FORM IMAG A * -IMAG. X
          FA        A6,A4 .        FORM REAL A*X
          FA        A6,0,A3 .      FORM REAL A*X+Y AND
          SA        A6,0,A3 .      STORE IN REAL Y
          FM        A0,R2 .        FORM IMAG. A * REAL X
          FM        A5,R1 .        FORM REAL A * IMAG. X
          FA        A0,A5 .        FORM IMAG. A*X
          FA        A0,1,A3 .      FORM IMAG. A*X+Y AND
          SA        A0,1,*A3 .     STORE IN IMAG. Y, INCREMENT Y INDEX
          JGD       R3,LOOP .      END OF LOOP
          DL        A6,A6A7 .      RESTORE A6 AND A7 REGISTERS
EXIT      J         7,X11 .        RETURN
$(0).
A6A7      +         0D .           PLACE TO SAVE A6 AND A7 REGISTERS
.
          END .
$(1).
          AXR$ .
.
.         APPLY MODIFIED GIVENS TRANSFORMATION TO (XX(1) ... XX(N))
.                                                 (YY(1) ... YY(N))
.    TO BE USED AS FORTRAN SUBROUTINE DROT(N,X,INCX,Y,INCY,PARAM)
.    X,Y, AND PARAM ARE DOUBLE PRECISION -- SEE DROTMG FOR DEF. OF PARAM
.
.         XX(I)=X(1-INCX+I*INCX)    IF INCX .GE. 0
.         XX(I)=X(1-N*INCX+I*INCX)  IF INCY .LT. 0
.         YY(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED
.               BY Y AND INCY.
.
DROTM*    SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         7,X11 .        IF N.LE.0 RETURN
NPOS
          SA        A6,SAVE .      SAVE A6 CONTENTS
          LA,XH2    A1,*2,X11 .    LOAD 2*INCX
          LA,XH2    A2,*4,X11 .    AND
          LSSC      A1,19 .        2*INCY
          LSSC      A2,19 .        IN A1 AND A2
          LXM,U     A1,*1,X11 .    LOAD X ADDRESS
          LXM,U     A2,*3,X11 .    LOAD Y ADDRESS
          JP        A1,TINCY .     TEST IF INCX .GE. 0
          LNA       A4,A1 .        ADD -INCX*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A1,A4 .           FOR X
TINCY     JP        A2,LOOP .      TEST IF INCY .GE. 0
          LNA       A4,A2 .        ADD -INCY*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A2,A4 .           FOR Y
LOOP
          LA,U      A0,*5,X11 .    LOAD SPARAM STARTING ADDRESS
          LA        A3,0,A0 .      LOAD FLAG
          JZ        A3,ZERO .      IF FLAG = 0, TAKE ROUTE ZERO
          JN        A3,NEG .       IF FLAG.LT.0, TAKE ROUTE NEG
.                        FLAG IS POSITIVE
POS       DL        A3,0,A1 .      LOAD X
          DFM       A3,2,A0 .      FORM H11 * X
          DFA       A3,0,A2 .      ADD Y TO IT
          DL        A5,0,A2 .      LOAD Y
          DFM       A5,8,A0 .      FORM H22 * Y
          DFAN      A5,0,A1 .      ADD -X TO IT
          DS        A3,0,*A1 .     STORE NEW X, INCREMENT INDEX
          DS        A5,0,*A2 .     STORE NEW Y, INCREMENT INDEX
          JGD       R3,POS .       BOTTOM OF LOOP
RETN
          LA        A6,SAVE .      RESTORE A6
          J         7,X11 .        RETURN
.                        FLAG IS ZERO
ZERO      DL        A3,0,A2 .      LOAD Y
          DFM       A3,6,A0 .      FORM H12 * Y
          DFA       A3,0,A1 .      ADD X TO IT
          DL        A5,0,A1 .      LOAD X
          DFM       A5,4,A0 .      FORM H21 * X
          DFA       A5,0,A2 .      ADD Y TO IT
          DS        A3,0,*A1 .     STORE NEW X, INCREMENT INDEX
          DS        A5,0,*A2 .     STORE NEW Y, INCREMENT INDEX
          JGD       R3,ZERO .      BOTTOM OF LOOP
          J         RETN .         RETURN
.                        FLAG IS NEGATIVE
NEG       TNE       A3,MTWO .      TEST FOR FLAG = -2.D0
          J         RETN .         IF FLAG = -2, RETURN
          DS        A7,A7A8 .      SAVE A7 AND A8 CONTENTS
NEGL      DL        A3,0,A1 .      LOAD X
          DFM       A3,2,A0 .      FORM H11 * X
          DL        A5,0,A2 .      LOAD Y
          DFM       A5,6,A0 .      FORM H12 * Y AND
          DFA       A3,A5 .        ADD TO H11 * X
          DL        A5,0,A1 .      LOAD X
          DFM       A5,4,A0 .      FORM H21 * X
          DL        A7,0,A2 .      LOAD Y
          DFM       A7,8,A0 .      FORM H22 * Y AND
          DFA       A5,A7 .        ADD TO H21 * X
          DS        A3,0,*A1 .     STORE NEW X, INCREMENT INDEX
          DS        A5,0,*A2 .     STORE NEW Y, INCREMENT INDEX
          JGD       R3,NEGL .      BOTTOM OF LOOP
          DL        A7,A7A8 .      RESTORE A7 AND A8
          J         RETN .         RETURN
$(0).
SAVE      +         0 .
A7A8      +         0D .
MTWO      -         2.0D .
          END
$(1) .
          AXR$ .
.
.         COMPUTE CONSTANTS FOR MODIFIED GIVENS TRANSFORMATION
.
.    TO BE USED AS FORTRAN SUBROUTINE DROTMG(D1,D2,B1,B2,PARAM)
.    ALL VARIABLES ARE DOUBLE PRECISION
.    THE MATRIX H IS DETERMINED SUCH THAT
.
.     (H11 H12) * (SQRT(D1)    0    ) * (B1) = (SQRT(ND1)    0     ) = (
.     (H21 H22)   (   0     SQRT(D2))   (B2)   (   0      SQRT(ND2))   (
.
.    WHERE ND1, ND2, NB1 ARE NEW VALUES STORED IN D1,D2, AND B1. THE
.    MATRIX H IS STORED IN PARAM, WITH PARAM(2)=H11, PARAM(3)=H12,
.    PARAM(4)=H21, PARAM(5)=H22, AS FOLLOWS
.
.     PARAM(1)=1   PARAM(1)=0   PARAM(1)=-1  PARAM(1)=-2
.
.  H=  (H11  1.)    (1.  H12)    (H11 H12)    ( 1.  0.)
.      (-1. H22)    (H21  1.)    (H21 H22)    ( 0.  1.)
.
.    VALUE OF + OR - 1 ARE NOT STORED, PARAM(1) IS SET BY THE SUBROUTINE
.
DROTMG*   SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          LA,U      A0,*4,X11 .    LOAD PARAM STARTING ADDRESS
          DS        A6,A6A7 .      SAVE
          DS        A8,A8A9 .      CONTENTS
          DS        A10,A10A11 .   OF
          DS        A12,A12A13 .   'A'
          DS        A14,A14A15 .   REGISTERS
          DL        A6,*0,X11 .    LOAD D1
          DL        A8,*1,X11 .    LOAD D2
          DL        A10,*2,X11 .   LOAD B1
          DL        A12,*3,X11 .   LOAD B2
          DL        A14,A6 .       FORM P1 =
          DFM       A14,A10 .      D1 * B1
          DL        A4,A8 .        FORM P2 =
          DFM       A4,A12 .       D2 * B2
          DL        A2,A14 .       STORE ABS(P1*B1)
          DFM       A2,A10 .       INTO
          DLM       A2,A2 .
          DS        A2,R1 .        R1 .
          DL        A2,A4 .        STORE P2*B2 INTO
          DFM       A2,A12 .       TEMP
          DS        A2,TEMP .      AND
          DLM       A2,A2 .        ABS(P2*B2) INTO A2
          DFAN      A2,R1 .        GET ABS(P2*B2)-ABS(P1*B1)
          JP        A2,LESS .      GO TO LESS IF RESULT.GT.0
          DFD       A4,A14 .       STORE P2/P1
          DS        A4,6,A0 .      INTO H12
          DFD       A12,A10 .      STORE -B2/B1
          SNA       A12,4,A0 .     INTO H21
          SNA       A13,5,A0 .     (A12 = -H21)
          DFM       A4,A12 .       FORM U=1-H12*H21
          DFA       A4,ONE .       AND STORE IN A4
          DL        A2,A4          IF U
          DFAN      A2,TOL .       .LT. TOL
          JN        A2,FALSE .     JUMP TO FALSE
          DFD       A6,A4 .        DIVIDE D1 AND
          DFD       A8,A4 .        D2 BY U
          DFM       A10,A4 .       MULTIPLY B1 BY U
          DSL       A14,72 .       STORE 0 IN FLAG
          J         SCALE .        GO TEST FOR SCALING PROBLEMS
LESS
          DL        A2,TEMP .
          JZ        A2,ZEROP .     IF P2*B2 = 0 JUMP TO ZEROP
          JN        A2,FALSE .     IF P2*B2.LT.0 JUMP TO FALSE
          DFD       A14,A4 .       STORE P1/P2
          DS        A14,2,A0 .     INTO H11
          DFD       A10,A12 .      STORE B1/B2
          DS        A10,8,A0 .     INTO H22
          DFM       A10,A14 .      FORM U=1+H11*H22
          DFA       A10,ONE .      AND STORE IN A10
          DFD       A6,A10 .       SET
          DL        A4,A6 .        D2=
          DFD       A8,A10 .       D1/U
          DL        A6,A8 .        AND D1=
          DL        A8,A4 .        D2/U.
          DFM       A10,A12 .      SET B1=U*B2
          DL        A14,ONE .      STORE 1.D0 IN FLAG
          J         SCALE .        GO TEST FOR SCALING PROBLEMS
ZEROP
          DLN       A14,TWO .      STORE -2.0D IN FLAG
          J         EXIT .         JUMP TO EXIT CODE
FALSE
          DLN       A14,ONE .      STORE -1.0D IN FLAG
          DL        A2,(0D) .      0 A2 AND A3 (NOTE A3=0 FOR IND. ADD.)
          DS        A2,2,A0 .      STORE ZERO IN
          DS        A2,4,A0 .      THE
          DS        A2,6,A0 .      MATRIX H,
          DS        A2,8,A0 .      AND IN
          DS        A2,*0,X11 .    D1,
          DS        A2,*1,X11 .    D2,
          DS        A2,*2,X11 .    AND B1
          J         EXIT           JUMP TO EXIT CODE
SCALE     DLM       A12,A6 .       LOAD ABS(D1)
          DFAN      A12,CSQINV .   IF ABS(D1) .LT.
          JP        A12,$+2 .      C**-2
          LMJ       A3,CASE1 .     JUMP TO CASE1
          DLM       A12,A6 .       IF ABS(D1)
          DFAN      A12,CSQ .      .GT.
          JN        A12,$+2 .      C**2
          LMJ       A3,CASE2 .     JUMP TO CASE2
STD1B1    SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          DS        A6,*0,X11 .    STORE D1
          DS        A10,*2,X11 .   STORE B1
          DL        A6,A8 .        STORE D2 IN A6
          DLM       A12,A6 .       LOAD ABS(D2)
          DFAN      A12,CSQINV .   IF ABS(D2)
          JP        A12,$+2 .      .LT. C**-2
          LMJ       A3,CASE3 .     JUMP TO CASE3
          DLM       A12,A6 .       IF ABS(D2)
          DFAN      A12,CSQ .      .GT.
          JN        A12,$+2 .      C**2
          LMJ       A3,CASE4 .     JUMP TO CASE4
STD2      SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          DS        A6,*1,X11 .    STORE D2
EXIT
          DS        A14,0,A0 .     STORE FLAG
          DL        A6,A6A7 .      RESTORE REGISTER CONTENTS
          DL        A8,A8A9 .
          DL        A10,A10A11 .
          DL        A12,A12A13 .
          DL        A14,A14A15 .
          J         6,X11 .        RETURN
CASE1
          JZ        A6,STD1B1      IF D1=0, JUMP TO STD1B1
          LA,XU     A2,4 .         LOAD C INDEX OF 2
          J         CASE2+1 .
CASE2
          LA,XU     A2,0 .         LOAD C INDEX OF 0
          DFM       A10,C,A2 .     COMPUTE NEW B1
          AU,U      A0,2 .         STORE FIRST H INDEX IN A1
          J         TFLAG .
CASE3
          JZ        A6,STD2 .      IF D2=0, JUMP TO STD2
          LA,XU     A2,4 .         LOAD C INDEX OF 2
          J         CASE4+1 .
CASE4
          LA,XU     A2,0 .         LOAD C INDEX OF 0
          AU,U      A0,4 .         STORE SECOND H INDEX IN A1
TFLAG
          DL        A4,ONE .       LOAD 1.D0 IN A4
          JZ        A14,FLAG0 .    IF FLAG=0, JUMP TO FLAG0
          JN        A14,CONT .     IF FLAG.LT.0, JUMP TO CONT
          DS        A4,6,A0 .      H12 = 1.D0
          SNA       A4,4,A0 .      H21 =
          SNA       A5,5,A0 .      -1.D0
          J         FLAG0+2 .
FLAG0
          DS        A4,2,A0 .      H11 = 1.D0
          DS        A4,8,A0 .      H22 = 1.D0
          DLN       A14,ONE .      FLAG =
CONT
          DFM       A6,C+2,A2 .    (D1 OR D2) * (C**2 OR C**-2)
          DLM       A12,A6 .       A12 = ABS(NEW D1 OR D2)
          DL        A4,0,A1 .      (H11 OR H12) *
          DFM       A4,C,A2 .      (C OR C**-1)
          DS        A4,0,A1 .      IS STORED IN (H11 OR H12)
          DL        A4,4,A1 .      (H21 OR H22) *
          DFM       A4,C,A2 .      (C OR C**-1)
          DS        A4,4,A1 .      IS STORED IN (H21 OR H22)
          AN,XU     A3,3 .         SUBTRACT 3 FROM RETURN ADDRESS
          J         0,A3 .         JUMP TO REPEAT TEST ON ABS(D1 OR D2)
$(0).
C         +         4096.0D .
CSQINV    +         5.9604644775390625D*-8  .
CINV      +         2.44140625D*-4 .
CSQ       +         16777216.0D .
TOL       +         0D .
ONE       +         1.0D .
TWO       +         2.0D .
TEMP      +         0D .
A6A7      +         0D .
A8A9      +         0D .
A10A11    +         0D .
A12A13    +         0D .
A14A15    +         0D .
          END .
         AXR$ .
$(1).
 .
.         COMPUTE CONSTANTS FOR MODIFIED GIVENS TRANSFORMATION
.
.    TO BE USED AS FORTRAN SUBROUTINE SROTMG(D1,D2,B1,B2,PARAM)
.    ALL VARIABLES ARE SINGLE PRECISION
.    THE MATRIX H IS DETERMINED SUCH THAT
.
.     (H11 H12) * (SQRT(D1)    0    ) * (B1) = (SQRT(ND1)    0     ) = (
.     (H21 H22)   (   0     SQRT(D2))   (B2)   (   0      SQRT(ND2))   (
.
.    WHERE ND1, ND2, NB1 ARE NEW VALUES STORED IN D1,D2, AND B1. THE
.    MATRIX H IS STORED IN PARAM, WITH PARAM(2)=H11, PARAM(3)=H12,
.    PARAM(4)=H21, PARAM(5)=H22, AS FOLLOWS
.
.     PARAM(1)=1   PARAM(1)=0   PARAM(1)=-1  PARAM(1)=-2
.
.  H=  (H11  1.)    (1.  H12)    (H11 H12)    ( 1.  0.)
.      (-1. H22)    (H21  1.)    (H21 H22)    ( 0.  1.)
.
.    VALUE OF + OR - 1 ARE NOT STORED, PARAM(1) IS SET BY THE SUBROUTINE
.
 . REGISTER ALLOCATION   (SOME USE AS TEMPOARY STORAGE IS NOT MENTIONED)
 .    A0  SPARAM STARTING ADDRESS.
 .    A1  USED FOR FIRST H ADDRESS WHEN SCALING.
 .    A2  TEMP. STORAGE OF P1*B1, P2*B2, ABS(P2*B2)    ALSO USED
 .        FOR C INDEX WHEN SCALING
 .    A3  USED TO STORE RETURN ADDRESS + 2  WHEN SCALING
 .    A4  P2=D2*B2 AND P2/P1 U  AND  TEMP. STORAGE WHEN SCALING
 .    A6  D1   ALSO USED FOR D2 WHEN SCALING
 .    A8  D2
 .    A10 B1
 .    A12 B2   ALSO USED FOR ABS(D1 OR D2) WHEN SCALING
 .    A14 P1=D1*B1      ALSO USED TO STORE VALUE OF FLAG (= SPARAM(1))
 .
SROTMG*   SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          LA,U      A0,*4,X11 .    LOAD PARAM STARTING ADDRESS.
          DS        A6,A6A7 .      SAVE CONTENTS OF A REGISTERS.
          DS        A8,A8A9 .
          DS        A10,A10A11 .
          DS        A12,A12A13 .
          DS        A14,A14A15 .
          LA        A6,*0,X11 .    LOAD D1.
          LA        A8,*1,X11 .    LOAD D2.
          LA        A10,*2,X11 .   LOAD B1.
          LA        A12,*3,X11 .   LOAD B2.
          LA        A14,A6 .       FORM P1 =
          FM        A14,A10 .      D1 * B1.
          LA        A4,A8 .        FORM P2 =
          FM        A4,A12 .       D2 * B2.
          LA        A2,A14 .       STORE ABS(P1*B1)
          FM        A2,A10 .       INTO
          SMA       A2,R1 .        R1.
          LA        A2,A4 .        STORE  P2 * B2 INTO
          FM        A2,A12 .       TEMP
          SA        A2,TEMP .      AND  ABS(P2*B2) INTO
          SMA       A2,A2 .        A2.
          TG        A2,R1 .        JUMP TO LESS IF
          J         LESS .         ABS(P2*B2) .GE. ABS(P1*B1).
          FD        A4,A14 .       STORE  P2/P1
          SA        A4,3,A0 .      INTO H12.
          FD        A12,A10 .      STORE -B2/B1
          SNA       A12,2,A0 .     INTO H21. (A12 = -H21.)
          FM        A4,A12 .       FORM U = 1 - H12 * H21
          FA        A4,ONE .       AND STORE IN A4.
          TLE       A4,TOL .       IF  U .LT. TOL
          J         FALSE .        JUMP TO FALSE.
          FD        A6,A4 .        DIVIDE D1 AND
          FD        A8,A4 .        D2 BY U.
          FM        A10,A4 .       MULTIPLY B1 BY U.
          SZ        A14 .          STORE 0 IN A14 (FLAG)
          J         SCALE .        GO TEST FOR SCALING PROBLEMS.
LESS      JZ        A2,ZEROP       IF P2 * B2 = 0  JUMP TO ZEROP
          LA        A2,TEMP .      IF P2 * B2 .LT. 0
          JN        A2,FALSE .     THEN JUMP TO FALSE
          FD        A14,A4 .       STORE P1/P2
          SA        A14,1,A0 .     INTO H11
          FD        A10,A12 .      STORE B1/B2
          SA        A10,4,A0 .     INTO H22.
          FM        A10,A14 .      FORM U = 1 + H11 * H22
          FA        A10,ONE .      AND STORE IN A10.
          FD        A6,A10 .       SET
          LA        A4,A6 .        D2 =
          FD        A8,A10 .       D1 / U
          LA        A6,A8 .        AND D1 =
          LA        A8,A4 .        D2 / U.
          FM        A10,A12 .      SET B1 = U * B2
          LA        A14,ONE .      STORE 1.0 IN A14 (FLAG)
          J         SCALE .        GO TEST FOR SCALING PROBLEMS.
ZEROP     LNA       A14,TWO .      STORE -2.0 IN A14 (FLAG)
          J         EXIT .         JUMP TO EXIT CODE.
FALSE     LNA       A14,ONE .      STORE -1.0 IN A14 (FLAG).
          SZ        1,A0 .         STORE ZERO IN
          SZ        2,A0 .         IN
          SZ        3,A0 .         THE
          SZ        4,A0 .         MATRIX H, AND IN
          SZ        *0,X11 .       D1,
          SZ        *1,X11 .       D2,
          SZ        *2,X11 .       AND B1.
          J         EXIT .         JUMP TO EXIT CODE
SCALE     LMA       A12,A6 .       LOAD ABS(D1).
          TLE       A12,CSQINV .   IF ABS(D1) .LT. C ** -2
          LMJ       A3,CASE1 .     JUMP TO CASE1.
          TG        A12,CSQ .      IF ABS(D1) .GE. C ** 2
          LMJ       A3,CASE2 .     JUMP TO CASE2.
          SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
STD1B1    SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          SA        A6,*0,X11 .    STORE D1.
          SA        A10,*2,X11 .   STORE B1.
          LA        A6,A8 .        STORE D2 IN A6.
          LMA       A12,A6 .       LOAD ABS(D2).
          TLE       A12,CSQINV .   IF  ABS(D2) .LT. C ** -2
          LMJ       A3,CASE3 .     JUMP TO CASE3.
          TG        A12,CSQ .      IF  ABS(D2) .GE. C ** 2
          LMJ       A3,CASE4 .     JUMP TO CASE4.
STD2      SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          SA        A6,*1,X11 .    STORE D2.
EXIT      SA        A14,0,A0 .     STORE FLAG
          DL        A6,A6A7 .      RESTORE REGISTER CONTENTS.
          DL        A8,A8A9 .
          DL        A10,A10A11 .
          DL        A12,A12A13 .
          DL        A14,A14A15 .
          J         6,X11 .        RETURN.
CASE1     JZ        A12,STD1B1 .   IF D1 = 0  JUMP TO STD1B1.
          LA,XU     A2,2 .         LOAD C INDEX OF 2.
          J         CASE2+1 .
CASE2     LA,XU     A2,0 .         LOAD C INDEX OF 0.
          FM        A10,C,A2 .     COMPUTE NEW B1.
          AU,U      A0,1 .         STORE FIRST H INDEX IN A1.
          J         TFLAG
CASE3     JZ        A12,STD2 .     IF D2 = 0  JUMP TO STD2.
          LA,XU     A2,2 .         LOAD C INDEX OF 2
          J         CASE4+1 .
CASE4     LA,XU     A2,0 .         LOAD C INDEX OF 0.
          AU,U      A0,2 .         STORE FIRST H INDEX IN A1.
TFLAG     LA        A4,ONE .       LOAD 1.0 IN A4.
          JZ        A14,FLAG0 .    IF FLAG=0, JUMP TO FLAG0.
          JN        A14,CONT .     IF FLAG .LT. 0, JUMP TO CONT.
          SA        A4,3,A0 .      H12 = 1.0
          SNA       A4,2,A0 .      H21 = -1.0
          J         FLAG0+2 .
FLAG0     SA        A4,1,A0 .      H11 = 1.0
          SA        A4,4,A0 .      H22 = 1.0
          LNA       A14,A4         FLAG = -1.0
CONT      FM        A6,C+1,A2 .    (D1 OR D2) * (C**2 OR C**-2).
          SMA       A6,A12 .       A12 = ABS(NEW(D1 OR D2)).
          LA        A4,0,A1 .      (H11 OR H12) * (C OR C**-1)
          FM        A4,C,A2 .      IS STORED IN
          SA        A4,0,A1 .      (H11 OR H12).
          LA        A4,2,A1 .      (H21 OR H22) * (C OR C**-1)
          FM        A4,C,A2 .      IS STORED IN
          SA        A4,2,A1 .      (H21 OR H22)
         AN,XU      A3,2 .         SUBTRACT 2 FROM RETURN ADDRESS
          J         0,A3 .         JUMP TO REPEAT TEST ON ABS(D1 OR D2)
$(0).
C         +         4096.0 .        2**12
CSQINV    +         5.96046448*-8 . 2**-24
CINV      +         2.44140625*-4 . 2**-12
CSQ       +         16777216.0 .    2**24
TOL       +         0 .
ONE       +         1.0 .
TWO       +         2.0 .
TEMP      +         0 .
A6A7      +         0D .
A8A9      +         0D .
A10A11    +         0D .
A12A13    +         0D .
A14A15    +         0D .
          END .
          AXR$
$(1).
.
.         INTERCHANGE INCREMENTED X AND Y COMPONENTS
.
.    TO BE USED AS FORTRAN SUBROUTINE SSWAP(N,X,INCX,Y,INCY)
.    WHERE X AND Y ARE OF TYPE REAL
.    XX(I) IS INTERCHANGED WITH YY(I), I=1,N WHERE
.    XX(I)=X(1-INCX+I*INCX)    IF INCX.GE.0 AND
.    XX(I)=X(1-N*INCX+I*INCX)  IF INCX.LT.0 AND
.    YY(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED BY Y AND INCY
.
SSWAP*    SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    LOAD N IN R3
          JGD       R3,NPOS .      STORE N-1 IN R3, TEST N
          J         6,X11 .        IF N.LE.0 RETURN
NPOS      LA,U      A2,*1,X11 .    LOAD ADDRESS OF X AND
          LXI       A2,*2,X11 .    INCX
          LXI       A3,*4,X11 .    LOAD INCY AND
          LXM,U     A3,*3,X11 .    ADDRESS OF Y
          JP        A2,TINCY .     TEST IF INCX .GE. 0
          LNA       A4,A2 .        ADD -INCX*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A2,A4 .           FOR X
TINCY     JP        A3,LOOP .      TEST IF INCY .GE. 0
          LNA       A4,A3 .        ADD -INCY*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A3,A4 .           FOR Y
LOOP      LA        A0,0,A2 .      LOAD X
          LA        A1,0,A3 .      LOAD Y
          SA        A1,0,*A2 .     STORE Y IN X AND INCREMENT X INDEX
          SA        A0,0,*A3 .     STORE X IN Y AND INCREMENT Y INDEX
          JGD       R3,LOOP .      END OF LOOP
          J         6,X11 .        RETURN
          END .
          AXR$
$(1).
.
.         EXTENDED PRECISION ACCUMULATION INNER PRODUCT
.
.    TO BE USED AS FORTRAN FUNCTIONS
.              DQDOTI(N,B,C,X,INCX,Y,INCY)
.              DQDOTA(N,B,C,X,INCX,Y,INCY)
.    WHERE  DQDOTI, DQDOTA, B, X, AND Y ARE ALL OF TYPE DOUBLE PRECISION
.    C IS AN EXTENDED PRECISION RESULT REPRESENTED IN A REAL ARRAY OF
.    LENGTH 5. FOR THE TWO CALLS,
.        DQDOTI  AND C  ARE REPLACED BY B + XX(I)*YY(I), I = 1,N
.        DQDOTA  AND C  ARE REPLACED BY B + C + XX(I)*YY(I), I = 1,N
.    WHERE FOR DQDOTA, C HAS BEEN COMPUTED BY AN EARLIER CALL TO EITHER
.    DQDOTI OR DQDOTA. XX(I) IS DEFINED BY
.        XX(I) = X(1-INCX+I*INCX)      FOR  INCX .GE. 0
.        XX(I) = X(1-N*INCX+I*INCX     FOR  INCX .LT. 0
.    AND YY(I) IS DEFINED SIMILARLY, WITH X, INCX REPLACED BY Y, INCY.
.    EXTENDED PRECISION ARITHMETIC IS USED INTERNALLY.
.
DQDOTA*   LA,U      A2,MODEA          . SET UP TO INCLUDE C
          J         START
DQDOTI*   LA,U      A2,MODEI          . SET UP TO EXCLUDE C
START     SZ        A3                . 0 A3 FOR INDIRECT ADDRESS. OPT.
          DS        A6,A6A7           . STORE A REGISTERS
          DS        A8,A8A9           .
          DS        A10,A10A11        .
          DS        A12,A12A13        .
          DS        A14,A14A15        .
          LR,U      R1,*2,X11         . R1 = ADDRESS OF SAVED VALUE
          J         0,A2              . JUMP TO MODEA OR MODEI
MODEA     LA        A0,R1             . LOAD SAVED VALUE (5 CELLS)
          LA        A11,0,A0          . EXPONENT IN A11
          DL        A12,1,A0          . S...  ...   IN A12 AND A13
          DL        A14,3,A0          . S...  ...   IN A14 AND A15
                                      . WHERE S IS A SIGN BIT, AND
                                      . ... ARE BINARY BITS
          J         $+2
MODEI     LNA,XU    A11,32768         . EFFECTIVELY SETS SAVED VALUE =0
          LR        R3,*0,X11         . R3=N
          DFU       A6,*1,X11         . GET B -- A6=EXPONENT, A7,A8 = FR
          LA        A2,*4,X11         . INCX IN LEFT OF
          LSSC      A2,19             . A2 AND X ADDRESS
          LXM,U     A2,*3,X11         . IN RIGHT OF A2 .
          LA        A3,*6,X11         . STORE INCY IN LEFT OF A3 AND
          LSSC      A3,19             . 0 IN RIGHT OF A3
          LXM,U     A3,*5,X11         . Y ADDRESS IN RIGHT OF A3.
          LA        A5,R3             . STORE
          AN,XU     A5,1              . N - 1 IN A5
          JP        A2,TINCY          . TEST IF INCX.GE.0
          LNA       A4,A2             . ADD -INCX*(N-1)
          SSA       A4,18             .    TO THE BASE
          MSI       A4,A5             .    ADDRESS
          AH        A2,A4             .    FOR X
TINCY     JP        A3,BSET           . TEST IF INCY.GE.0
          LNA       A4,A3             . ADD -INCY*(N-1)
          SSA       A4,18             .    TO THE BASE
          MSI       A4,A5             .    ADDRESS
          AH        A3,A4             .    FOR Y
.                              TAKE CARE OF B
BSET      SA        A7,A9             . LOAD SIGNS IN
          DSA       A9,71             . A9 AND A10
          SA        A6,A4             . STORE EXPONENT IN A4
          JNZ       A4,GETDIF         . ADD TO C IF B IS NON-ZERO
.                              START OF LOOP
.   BEGIN BY FORMING X(I)*Y(I)
LOOP      DFU       A4,0,*A2          . GET X(I), A4 = BIASED EXPONENT
          LDSC      A5,6              . A5 = FIRST PART OF FRACTION = X1
          SSC       A6,1              . A6 = 2-ND  PART OF FRACTION = X2
          SA        A5,X1F            . SAVE X1F
          DFU       A7,0,*A3          . GET Y(I), A7 = BIASED EXPONENT
          LDSC      A8,6              . A8 = FIRST PART OF FRACTION = Y1
          SSC       A9,1              . A9 = 2-ND  PART OF FRACTION =Y2F
          SA        A8,Y1F            . SAVE Y1F
          A         A4,A7             . ADD EXPONENTS
          ANA,U     A4,0002000        . ACCOUNT FOR BIAS AND SHIFTING
          SA        A6,A7             . A7 = X2F
          MF        A5,A9             . A5-A6 = X1F*Y2F
          MF        A9,A7             . A9-A10= X2F*Y2F
          MF        A7,A8             . A7-A8 = X2F*Y1F
          DA        A7,A5             . A7-A8 = X2F*Y1F + X1F*Y2F =MID
                                      . LEFTMOST BIT NOT USED FOR SIGN
          SSC       A8,1              . GET SIGN BIT FOR A8
          AA        A9,A8             . ADD RIGHT OF MID TO X2F*Y2F
          SA        A7,A8             . LEFT OF MID MOVED TO A8
          JNO       $+5               . JUMP IF NO OVERFLOW
          JP        A9,$+3            . COMPENSATE FOR OVERFLOW ****
          DAN       A8,DBIGM          . RESULT SHOULD BE .GE. 0    *
          J         $+2               .                            *
          DA        A8,DBIGM          . RESULT SHOULD BE .LE. 0 ****
          LA        A5,X1F            . A5-A6 =
          MI        A5,Y1F            .  X1F*Y1F
          SA        A5,A7             . STORE SIGN BITS
          SSA       A7,35             . IN A7.
          DA        A7,A5             . ADD IN MOST SIG. PART OF FRAC.
 .  END OF CODE FOR FORMING X(I)*Y(I)
.   END OF CODE FOR FORMING X(I)*Y(I)
 .  SHIFT  A7-A10  OR  A12-A15  TO RIGHT IF NECESSARY
GETDIF    ANU       A4,A11            . A5 = DIFFERENCE IN EXPONENTS
          LMA       A0,A5             . A0 = SHIFT COUNT
          JZ        A5,DONESH         . IF A5=0  NO SHIFTING IS REQUIRED
          ANU,U     A0,35             . A1= A0 - 35
          JN        A1,TESTSH
          LA,U      A0,35             . SET A0=35
          TLE,U     A1,86             .
          J         TESTSH            .
          JN        A5,ELOOP          . NO ADD NECESSARY, IF A4.GT.A11
          DS        A7,A12            . MOVE A7-A10 TO A12-A15,
          DS        A9,A14            .
          SA        A4,A11            . AND MOVE A4 TO A11
          J         TEST0             . BEFORE GOING TO END OF LOOP
TESTSH    JN        A5,SA7A10         . TEST WHICH TO SHIFT
          SA        A4,A11            . MOVE A4 TO A11 (A4.GT.A11)
          DSA       A14,0,A0          . SHIFT  A12-A15 TO THE RIGHT
          LSSC      A14,1,A0          . A0 POSITIONS (A0.LE.35)
          DSA       A13,0,A0          .
          SSC       A14,1             .
          LSSC      A13,0,A0          .
          DSA       A12,0,A0          . END OF SHIFT   (A12-A15)
          JN        A1,DONESH         . JUMP IF DONE SHIFTING
          JZ        A5,ELOOP          . JUMP IF SHIFT DUE TO LARGE FRAC.
CONTSH    JZ        A1,DONESH         . JUMP IF DONE SHIFTING
          LA        A0,A1             . GET NEXT
          ANU,U     A0,35             . SHIFT
          JN        A1,TESTSH         . INDEX AND
          LA,U      A0,35             . CONTINUE
          JP        A5,TESTSH+2       . SHIFTING
SA7A10    DSA       A9,0,A0           . SHIFT  A7-A10 TO THE RIGHT
          LSSC      A9,1,A0           . A0 POSITIONS (A0.LE.35)
          DSA       A8,0,A0           .
          SSC       A9,1              .
          LSSC      A8,0,A0           .
          DSA       A7,0,A0           . END OF SHIFT   (A7-A10)
          JP        A1,CONTSH
.   END OF CODE FOR SHIFTING TO THE RIGHT
.   ADD   A7-A10  TO  A12-A15
DONESH    DA        A14,A9            . ADD LEAST SIGNIFICANT PARTS
          JNO       NOOVER            . JUMP IF NO OVERFLOW
          DA        A12,A7            . ADD MOST SIGNIFICANT PARTS
          JP        A14,POSA14        . COMPENSATE FOR OVERFLOW ****
          DA        A12,(1D)          . RESULT SHOULD BE .GE.0     *
          AA        A14,DBIG          .                            *
          JP        A14,BIGTST        .                            *
A14ZER    LNA       A14,A14           . A14 = 0 AND HAD WRONG SIGN *
          J         BIGTST            .                            *
POSA14    DAN       A12,(1D)          . RESULT SHOULD BE .LE.0     *
          ANA       A14,DBIG          .                            *
          JP        A14,A14ZER        .                            *
          J         BIGTST            .                         ****
NOOVER    DA        A12,A7            . ADD MOST SIGNIFICANT PARTS
          JP        A12,A12POS        . TEST IF LEAST AND MOST SIGNIF.
          JN        A14,TEST0         . PARTS HAVE THE SAME SIGN
          DJZ       A14,ZERA14        .
          DJZ       A12,ZERA12        .
          DA        A12,(1D)          . A14-A15 SHOULD BE .LT.0
          DA        A14,DBIG          .
          J         TEST0
A12POS    JP        A14,TEST0         .
          DJZ       A14,ZERA14        .
          DJZ       A12,ZERA12        .
          DAN       A12,(1D)          .  A14-A15 SHOULD BE .GT.0
          DAN       A14,DBIG          .
          J         TEST0             .
ZERA14    DLN       A14,A14           . A14 WAS =0 AND OF WRONG SIGN
          J         TEST0             .
ZERA12    DLN       A12,A12           . A12 WAS =0 AND OF WRONG SIGN
 .  A12 IS ZERO, SHIFT A12-A15 LEFT 35 PLACES
          LDSC      A12,35            .
          SSC       A13,35            .
          LSSC      A14,1             .
          LDSC      A13,35            .
          LDSC      A14,35            . END OF SHIFT
          ANA,U     A11,35            . ADJUST EXPONENT FOR THE SHIFT
TEST0     JNZ       A12,BIGTST        . IF A12 IS 0, EITHER A SHIFT
          JNZ       A13,ZERA12+1      . TO THE LEFT IS MADE, OR IF
          JNZ       A14,ZERA12+1      .
          JNZ       A15,ZERA12+1      .
          LNA,XU    A11,32768         . RESULT=0, SET EXPONENT SMALL
          J         ELOOP             . AND GO TO END OF LOOP
BIGTST    LSC       A4,A12            . SET A5=NO. OF BITS=TO SIGN BIT-1
          JNZ       A5,ELOOP          . IF A5=0,A12-15 IS SHIFTED TO THE
          LA,U      A0,10             . RIGHT 10 PLACES TO ELIMINATE
          SZ        A1                . DANGER OF OVERFLOW.
          AA        A11,A0            . INCREASE EXPONENT, AND GO SHIFT
          J         TESTSH+2          . A12-A15 TO RIGHT 10 PLACES
ELOOP     JGD       R3,LOOP           . END OF LOOP
 .  END OF LOOP -- STORE RESULTS
          LA        A0,R1             . SAVE THE RESULT
          SA        A11,0,A0          .
          DS        A12,1,A0          .
          DS        A14,3,A0          .
          LSC       A0,A12             . GET FINAL EXPONENT
          ANU,U     A1,11              .
          ANA       A11,A2             .
          JP        A11,$+3            . IF BIASED EXPONENT IS NEGATIVE
          DSL       A0,72              . STORE ZERO FOR RESULT AND
          J         SAVE               . GET READY TO RETURN
          LDSC      A12,0,A1           . SHIFT A12 - A14 TO THE
          SSC       A13,0,A1           . LEFT    A1
          LSSC      A14,1              . POSITIONS
          LDSC      A13,0,A1           .
          DSA       A12,11             . SHIFT A12 - A13 BACK 11 POSITIO
          DLCF      A11,A12            . STORE RESULT AS D.P. NUMBER
          DS        A12,A0             . IN A0 - A1
SAVE      DL        A6,A6A7           . RESTORE A REGISTERS
          DL        A8,A8A9           .
          DL        A10,A10A11        .
          DL        A12,A12A13        .
          DL        A14,A14A15        .
          J         8,X11             .
$(0).
X1F       +         0 .
Y1F       +         0 .
A6A7      +         0D .
A8A9      +         0D .
A10A11    +         0D .
A12A13    +         0D .
A14A15    +         0D .
DBIGM     +         0777777777777     .
DBIG      +         0377777777777     .
          +         0777777777777     .
.
          END .
          AXR$
$(1).
.
.   DOUBLE PRECISION ACCUMULATION INNER PRODUCT
.
. TO BE USED AS FORTRAN FUNCTION  SDSDOT(N,SB,X,INCX,Y,INCY)
. AND   SDSDOT= SB + SUM FROM I=1 TO N OF A(I)*B(I)  WHERE
. WHERE SDSDOT, SB, X, AND Y ARE ALL OF TYPE REAL,
. A(I) = X(1-INCX+I*INCX)    IF  INCX.GE.0
. A(I) = X(1-N*INCX+I*INCX)  IF  INCX.LT.0
. B(I)   DEFINED SIMILARLY, WITH X AND INCX REPLACED BY Y AND INCY
.
SDSDOT*   SZ        A3               . 0 A3 FOR INDIRECT ADDRESS. OPT.
          FEL       A0,*1,X11        . LOAD SB IN A0
          LR        R3,*0,X11        . STORE N IN R3
          JGD       R3,NPOS          . STORE N-1 IN R3 AND TEST N
          J         END              . EXIT IF N.LE.0
NPOS      DS        A6,SAVE          . SAVE REGISTERS A6 AND A7
          LA,U      A2,*2,X11        . LOAD ADDRESS OF X
          LXI       A2,*3,X11        . LOAD INCREMENT ON X
          LXI       A3,*5,X11        . LOAD INCREMENT ON Y
          LXM,U     A3,*4,X11        . LOAD ADDRESS OF Y
          JP        A2,TINCY         . TEST IF INCX.GE.0
          LNA       A4,A2            . ADD -INCX*(N-1)
          SSA       A4,18            .    TO THE BASE
          MSI       A4,R3            .    ADDRESS
          AH        A2,A4            .    FOR X
TINCY     JP        A3,LOOP          . TEST IF INCY.GE.0
          LNA       A4,A3            . ADD -INCY*(N-1)
          SSA       A4,18            .    TO THE BASE
          MSI       A4,R3            .    ADDRESS
          AH        A3,A4            .    FOR Y
.                               BEGIN LOOP TO FORM INNER PRODUCT
LOOP      FEL       A4,0,*A2         . LOAD X, CONVERT TO DOUBLE, AND IN
          FEL       A6,0,*A3         . LOAD Y, CONVERT TO DOUBLE, AND IN
          DFM       A4,A6            . MULTIPLY X TIMES Y
          DFA       A0,A4            . ACCUMULATE INNER PRODUCT
          JGD       R3,LOOP          . END OF INNER PRODUCT LOOP
          DL        A6,SAVE          . RESTORE REGISTERS A6 AND A7
END       FCL       A0,A0            . ANSWER = SNGL(ANSWER)
          J         7,X11            . RETURN FOR N.GT.0
.
$(0)
SAVE      +         0D               . PLACE TO SAVE A6 AND A7
          END .
          AXR$
$(1).
.
.         DOUBLE PRECISION APPLICATION OF A GIVENS TRANSFORMATION
.
.    TO BE USED AS FORTRAN SUBROUTINE DROT(N,X,INCX,Y,INCY,C,S)
.    APPLY  ( C  S)  TO A 2 BY N MATRIXX (XX(1) ... XX(N))
.           (-S  C)                      (YY(1) ... YY(N))
.    WHERE XX(I)=X(1-INCX+I*INCX)    IF INCX.GE.0
.    AND   XX(I)=X(1-N*INCX+I*INCX)  IF INCX.LT.0
.    AND YY(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED
.             BY Y AND INCY
.
DROT*     SZ        A3             0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    STORE N IN R3
          DL        A0,*5,X11 .    STORE C IN A0 AND A1
          DL        A4,*6,X11 .    STORE S IN A4 AND A5
          JNZ       A4,$+2 .       TEST FOR RETURN  S=0
          DTE       A0,ONE .           AND           C=1
          JGD       R3,NPOS .          OR           N.LE.0
          J         8,X11 .        RETURN
NPOS      DS        A6,A6A7 .      SAVE CONTENTS OF A6 AND A7 REGISTERS
          DS        A8,A8A9 .      SAVE CONTENTS OF A8 AND A9 REGISTERS
          LA,XH2    A2,*2,X11 .    LOAD INCREMENT ON X
          LA,XH2    A3,*4,X11 .    LOAD INCREMENT ON Y
          LSSC      A2,19 .        DOUBLE INCREMENTS FOR
          LSSC      A3,19 .           DOUBLE PRECISION
          LXM,U     A2,*1,X11 .    LOAD ADDRESS OF X
          LXM,U     A3,*3,X11 .    LOAD ADDRESS OF Y
          JP        A2,TINCY .     TEST IF INCX .GE. 0
          LNA       A6,A2 .        ADD -INCX*(N-1)
          SSA       A6,18 .           TO THE BASE
          MSI       A6,R3 .           ADDRESS
          AH        A2,A6 .           FOR X
TINCY     JP        A3,LOOP .      TEST IF INCY .GE. 0
          LNA       A6,A3 .        ADD -INCY*(N-1)
          SSA       A6,18 .           TO THE BASE
          MSI       A6,R3 .           ADDRESS
          AH        A3,A6 .           FOR Y
LOOP      DL        A6,0,A2 .      LOAD X
          DL        A8,0,A3 .      LOAD Y
XPART     DFM       A6,A0 .        FORM C*X
          DFM       A8,A4 .        FORM S*Y
          DFA       A8,A6 .        FORM C*X+S*Y
          DL        A6,0,A2 .      LOAD X
          DS        A8,0,*A2 .     STORE NEW X, AND INCREMENT INDEX
          DL        A8,0,A3 .      LOAD Y
          DFM       A6,A4 .        FORM S*X
          DFM       A8,A0 .        FORM C*Y
          DFAN       A8,A6 .       FORM C*Y-S*X
          DS        A8,0,*A3 .     STORE NEW Y, AND INCREMENT INDEX
ENDLOOP   JGD       R3,LOOP .      END OF LOOP
          DL        A6,A6A7 .      RESTORE A6 AND A7 REGISTERS
          DL        A8,A8A9 .      RESTORE A8 AND A9 REGISTERS
          J         8,X11 .        RETURN
.
$(0).
ONE       +         1.0D           1.0D0
A6A7      +         0D .           PLACE TO SAVE A6 AND A7 CONTENTS
A8A9      +         0D .           PLACE TO SAVE A8 AND A9 CONTENTS
.
          END .
          AXR$
$(1).
.
.         COMPUTE CONSTANTS FOR GIVENS TRANSFORMATION
.
.    TO BE USED AS FORTRAN SUBROUTINE  SROTG(A,B,C,S)
.    TO COMPUTE (ALL VARIABLES OF TYPE REAL)
.               C = A/R,   S = B/R, WHERE  R = (+ OR -) SQRT(A*A + B*B)
.               (R HAS THE SAME SIGN AS A IF ABS(A) .GT. ABS(B) AND
.               OTHERWISE HAS THE SIGN OF B.)
.               R IS STORED IN A AND S (IF ABS(C) .GT. ABS(S)) OR  1/C
.               (IF (ABS(C) .LE. ABS(S)) IS STORED IN B. (IF C = 0, 1
.               IS STORED IN B.)
.    THE GIVENS ROTATION MATRIX IS GIVEN BY     (C  S)
.                                               (-S C)
.
SROTG*    SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LMA       A0,*0,X11 .    LOAD ABS A
          LMA       A1,*1,X11 .    LOAD ABS B
          TG        A1,A0 .        TEST IF ABS A .LE. ABS B
          J         BFIRST .       IF YES GO TO BFIRST
AFIRST    SNA       A3,CASE .      STORE -0 IN CASE IF ABS A .GT. ABS B
          LA        A0,*0,X11 .    LOAD A IN A0
          LA        A2,*1,X11 .    LOAD B IN A2
          J         STORE .        GO STORE VARIABLE VALUES
BFIRST    LA        A0,*1,X11 .    LOAD B IN A0
          LA        A2,*0,X11 .    LOAD A IN A2
          JZ        A2,ZIP .       ZIP IS SPECIAL CASE FOR A=0
          SZ        CASE .         STORE 0 IN CASE IF ABS A .LT. ABS B
STORE     SA        A0,RMULT .     STORE CONTENTS OF A0 IN RMULT
          FD        A2,A0 .        FORM A/B (OR B/A) AND
          SA        A2,SMULT .     STORE IN SMULT
          FM        A2,A2 .        SQUARE A/B (OR B/A) AND
          FA        A2,ONE .       ADD 1.E0 AND
          SA        A2,YR .        STORE RESULT IN YR
          SX        X11,WB+1 .     SAVE X11 CONTENTS
          LMJ       X11,SQRT .     GET THE SQUARE ROOT OF YR
          +         YR .
          +         $-SROTG,WB .
          LX        X11,WB+1 .     RESTORE X11
          LA        A4,ONE .       PUT 1.E0 IN A4
          FD        A4,A0 .        GET THE INVERSE OF SQRT(YR)
          FM        A0,RMULT .     GET R WITH APPROPRIATE SIGN
          SA        A0,*0,X11 .    STORE R IN A
          TN        CASE .         JUMP TO BIGA
          J         BIGA .         IF ABS A .LE. ABS B
          SA        A4,*2,X11 .    STORE C  = 1 / SQRT(1 + (B/A)**2)
          FM        A4,SMULT .     MULTIPLY BY B/A
          SA        A4,*3,X11 .    STORE S
          SA        A4,*1,X11 .    STORE S IN B
          J         5,X11 .        RETURN
BIGA      SA        A4,*3,X11 .    STORE S  = 1 / SQRT(1 + (A/B)**2)
          FM        A4,SMULT .     MULTIPLY BY A/B
          SA        A4,*2,X11 .    STORE C
          LA        A0,ONE .       STORE
          FD        A0,A4 .        1 / C  IN
          SA        A0,*1,X11 .    B.
          J         5,X11 .        RETURN
ZIP       LA        A4,ONE .       LOAD A 1.
          JZ        A0,BZERO .     JUMP IF B=0 (A IS ALSO 0)
          SA        A0,*0,X11 .    STORE B IN A,
          SA        A4,*1,X11 .    1 IN B  (CASE OF C=0),
          SA        A4,*3,X11 .    1 IN S, AND
          SZ        *2,X11.        0 IN C.
          J         5,X11 .        RETURN
BZERO     SZ        *3,X11 .       STORE 0 IN S AND
          SA        A4,*2,X11 .    1 IN C.
          J         5,X11 .        RETURN
$(0).
ONE       +         1.0 .          1.E0
CASE      +         0 .            PLACE TO SAVE CASE
RMULT     +         0 .            PLACE TO STORE A (OR B)
SMULT     +         0 .            PLACE TO STORE A/B (OR B/A)
YR        +         0 .
WB        +         'SROTG' .        WALKBACK WORD
          +         0 .            PLACE TO SAVE X11
.
          END .
          AXR$
$(1).
.
.         COMPUTE CONSTANTS FOR GIVENS TRANSFORMATION
.
.    TO BE USED AS FORTRAN SUBROUTINE DROTG(A,B,C,C)
.    TO COMPUTE (ALL VARIABLES OF TYPE DOUBLE PRECISION)
.               C = A/R,   S = B/R, WHERE  R = (+ OR -) SQRT(A*A + B*B)
.               (R HAS THE SAME SIGN AS A IF ABS(A) .GT. ABS(B) AND
.               OTHERWISE HAS THE SIGN OF B.)
.               R IS STORED IN A AND S (IF ABS(C) .GT. ABS(S)) OR  1/C
.               (IF (ABS(C) .LE. ABS(S)) IS STORED IN B. (IF C = 0, 1
.               IS STORED IN B.)
.    THE GIVENS ROTATION MATRIX IS GIVEN BY     (C  S)
.                                               (-S C)
.
DROTG*    SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LMA       A0,*0,X11 .    LOAD ABS A
          LMA       A1,*1,X11 .    LOAD ABS B
          TG        A1,A0 .        TEST IF ABS A .LE. ABS B
          J         BFIRST .       IF YES GO TO BFIRST
AFIRST    SNA       A3,CASE .      STORE -0 IN CASE IF ABS A .GT. ABS B
          DL        A0,*0,X11 .    LOAD A IN A0
          DL        A2,*1,X11 .    LOAD B IN A2
          J         STORE .        GO STORE VARIABLE VALUES
BFIRST    DL        A0,*1,X11 .    LOAD B IN A0
          DL        A2,*0,X11 .    LOAD A IN A2
          JZ        A2,ZIP .       ZIP IS SPECIAL CASE FOR A=0
          SZ        CASE .         STORE 0 IN CASE IF ABS A .LT. ABS B
STORE     DS        A0,RMULT .     STORE CONTENTS OF A0 IN RMULT
          DFD       A2,A0 .        FORM A/B (OR B/A) AND
          DS        A2,SMULT .     STORE IN SMULT
          DFM       A2,A2 .        SQUARE A/B (OR B/A) AND
          DFA       A2,ONE .       ADD 1.D0 AND
          DS        A2,YR .        STORE RESULT IN YR
          SX        X11,WB+1 .     SAVE X11 CONTENTS
          LMJ       X11,DSQRT .    GET THE SQUARE ROOT OF YR
          +         YR .
          +         $-DROTG,WB .
          LX        X11,WB+1 .     RESTORE X11
          DL        A4,ONE .       PUT 1.D0 IN A4
          DFD       A4,A0 .        GET THE INVERSE OF SQRT(YR)
          DFM       A0,RMULT .     GET R WITH APPROPRIATE SIGN
          DS        A0,*0,X11 .    STORE R IN A
          TN        CASE .         JUMP TO BIGA IF
          J         BIGA .         ABS A .LE. ABS B
          DS        A4,*2,X11 .    STORE C = 1 / SQRT(1 + (B/A)**2)
          DFM       A4,SMULT .     MULTIPLY BY B/A
          DS        A4,*3,X11 .    STORE S
          DS        A4,*1,X11 .    STORE S IN B
          J         5,X11 .        RETURN
BIGA      DS        A4,*3,X11 .    STORE S = 1 / SQRT(1 + (A/B)**2)
          DFM       A4,SMULT .     MULTIPLY BY A/B
          DS   A4,*2,X11 .         STORE C
          DL        A0,ONE .       STORE
          DFD       A0,A4 .        1 / C IN
          DS        A0,*1,X11 .    B.
          J         5,X11 .        RETURN
ZIP       DL        A4,ONE .       LOAD A4,A5 WITH A 1.
          JZ        A0,BZERO .     JUMP IF B=0 (A IS ALSO 0)
          DS        A0,*0,X11 .    STORE B IN A,
          DS        A4,*1,X11 .    1 IN B.(CASE OF C=0),
          DS        A4,*3,X11 .    1 IN S,
          SZ        *2,X11 .       0 IN
          SZ        *2,X11 .       C.
          J         5,X11 .        RETURN
BZERO     SZ        *3,X11 .       STORE 0 IN
          SZ        *3,X11 .       S AND
          DS        A4,*2,X11 .    1 IN C.
          J         5,X11 .        RETURN
$(0).
ONE       +         1.0D .         1.D0
CASE      +         0 .            PLACE TO STORE CASE
ZERO      +         0D .           0.0D
RMULT     +         0D .           PLACE TO STORE A (OR B)
SMULT     +         0D .           PLACE TO STORE A/B (OR B/A)
YR        +         0D .
WB        +         'DROTG' .      WALKBACK WORD
          +         0 .            PLACE TO SAVE X11
.
          END .
          AXR$
$(1).
.         SINGLE PRECISION APPLICATION OF A GIVENS TRANSFORMATION
.
.    TO BE USED AS FORTRAN SUBROUTINE SROT(N,X,INCX,Y,INCY,C,S)
.    APPLY (C  S)  TO A 2 BY N MATRIX  (XX(1) ... XX(N))
.          (-S C)                      (YY(1) ... YY(N))
.    WHERE XX(I)=X(1-INCX+I*INCX)    IF INCX .GE. 0
.    AND   XX(I)=X(1-N*INCX+I*INCX)  IF INCX .LT. 0
.    AND YY(I) IS SIMILARLY DEFINED, WITH X AND INCX REPLACED
.             BY Y AND INCY.
.
SROT*     SZ        A3 .           0 A3 FOR INDIRECT ADDRESSING OPTION
          LR        R3,*0,X11 .    STORE N IN R3
          LA        A0,*5,X11 .    STORE C IN A0
          LA        A1,*6,X11 .    STORE S IN A1
          JNZ       A1,$+2 .       TEST FOR RETURN  S=0
          TE        A0,ONE .           AND          C=1
          JGD       R3,NPOS .          OR           N.LE.0
          J         8,X11 .        RETURN
NPOS      DS        A6,A6A7 .      SAVE CONTENTS OF A6 AND A7 REGISTERS
          LA,U      A2,*1,X11 .    LOAD ADDRESS OF X
          LXI       A2,*2,X11 .    LOAD INCREMENT ON X
          LXI       A3,*4,X11 .    LOAD INCREMENT ON Y
          LXM,U     A3,*3,X11 .    LOAD ADDRESS OF Y
          JP        A2,TINCY .     TEST IF INCX .GE. 0
          LNA       A4,A2 .        ADD -INCX*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A2,A4 .           FOR X
TINCY     JP        A3,LOOP .      TEST IF INCY .GE. 0
          LNA       A4,A3 .        ADD -INCY*(N-1)
          SSA       A4,18 .           TO THE BASE
          MSI       A4,R3 .           ADDRESS
          AH        A3,A4 .            FOR Y
LOOP      LA        A4,0,A2 .      LOAD X
          LA        A6,0,A3 .      LOAD Y
          FM        A4,A0 .        FORM C*X
          FM        A6,A1 .        FORM S*Y
          FA        A6,A4 .        FORM C*X + S*Y
          LA        A4,0,A2 .      LOAD X
          SA        A6,0,*A2 .     STORE NEW X
          FM        A4,A1 .        FORM S*X
          LA        A6,0,A3 .      LOAD Y
          FM        A6,A0 .        FORM C*Y
          FAN       A6,A4 .        FORM C*Y - S*X
          SA        A6,0,*A3 .     STORE NEW Y
          JGD       R3,LOOP .      END OF LOOP
          DL        A6,A6A7 .      RESTORE A6 AND A7 REGISTERS
          J         8,X11 .        RETURN
.
$(0).
ONE       +         1.0 .          1.0
A6A7      +         0D .           PLACE TO SAVE A6 AND A7 REGISTERS
.
          END .
