//----------------------------------------------------------------------------------
// File:        EC/ECSpaces.h
// Library:     cagd{32|64}[d]
//              An OpenGL and C++ based function library for curve and surface
//              modeling in a large class of extended Chebyshev spaces
// Version:     1.0.0 | August 15, 2017 - October 11, 2018
// Author:      (c) Agoston Roth
// Affiliation: Babes-Bolyai University
//              Department of Mathematics and Computer Science of the Hungarian Line
//              RO-400084, Cluj-Napoca, Romania
//----------------------------------------------------------------------------------

#ifndef ECSPACES_H
#define ECSPACES_H

#include "CharacteristicPolynomials.h"
#include "../Core/Math/RealMatrices.h"
#include "../Core/SmartPointers/SpecializedSmartPointers.h"
#include "../Core/Geometry/Curves/GenericCurves3.h"

#include <string>
#include <vector>

namespace cagd
{
    //(*@\Green{// The class ECSpace below represents an EC vector space $\mathbb{S}_{n}^{\alpha,\beta}$ of functions that comprises the constants and can}@*)
    //(*@\Green{// be identified with the solution space of the constant-coefficient homogeneous linear differential equation (\mref{eq:differential_equation})}@*)
    //(*@\Green{// defined on an interval $\left[\alpha,\beta\right]$ for which the space $D\mathbb{S}_{n}^{\alpha,\beta}$ of derivatives is also EC.}@*)
    //(*@\Green{// Note that the underlying EC space is spanned by those ordinary basis functions (\mref{eq:ordinary_basis}) that are generated by}@*)
    //(*@\Green{// the (higher oder) zeros of the characteristic polynomial (\mref{eq:characteristic_polynomial}) associated with the differential equation (\mref{eq:differential_equation}).}@*)
    //(*@\Green{// In order to ensure that the underlying EC space also contains the constant functions and also has normalizable}@*)
    //(*@\Green{// bases, we have to assume that $z = 0$ is at least a first order zero of the characteristic polynomial (\mref{eq:characteristic_polynomial}).}@*)
    class ECSpace
    {
        //(*@\Green{// overloaded friend output to stream operator that lists the conjugately equivalent zeros of the}@*)
        //(*@\Green{// characteristic polynomial}@*)
        friend std::ostream& operator <<(std::ostream &lhs, const ECSpace &rhs);

    public:
        //(*@\Green{// The class is able to determine both the ordinary basis (\mref{eq:ordinary_basis}) and the normalized B-basis (\mref{eq:B-basis}) of the}@*)
        //(*@\Green{// underlying EC vector space of functions and it can also be used to compute their derivatives of arbitrary}@*)
        //(*@\Green{// order. In order to specify the type of the basis functions that have to be differentiated at a given parameter}@*)
        //(*@\Green{// value $u \in \left[\alpha, \beta\right]$, one has to use the named constants provided by the public enumaration BasisFunctionType.}@*)
        enum BasisFunctionType{ORDINARY_BASIS, B_BASIS};

    protected:
        //(*@\Green{// The protected nested class \_OrdinaryBasisFunction below represents an ordinary basis function generated}@*)
        //(*@\Green{// by a possible higher order root of the given characterteristic polynomial (\mref{eq:characteristic_polynomial}).}@*)
        //(*@\Green{// Based on the real and imaginary parts of a possible complex root $z = a \pm \mathbf{i}b$ of order $m$, we will}@*)
        //(*@\Green{// differentiate algebraic-exponential-trigonometric (AET), algebraic-exponential (AE), algebraic-}@*)
        //(*@\Green{// trigonometric (AT) and pure polynomial (P) ordinary basis functions of types (\mref{eq:AET}), (\mref{eq:AE}), (\mref{eq:AT})}@*)
        //(*@\Green{// and (\mref{eq:P}), respectively.}@*)
        class _OrdinaryBasisFunction
        {
        public:
            //(*@\Green{// Possible ordinary basis function types can be specified by the following named constants.}@*)
            //(*@\Green{// Note that enumerators AE\_SINE and P\_SINE denote the constant zero function.}@*)
            enum Type{AET_COSINE, AET_SINE,
                      AE_COSINE,  AE_SINE,
                      AT_COSINE,  AT_SINE,
                      P_COSINE,   P_SINE};

        protected:
            Type    _type;     //(*@\Green{// properties of the ordinary basis function $u^{r} \cdot \left[e^{au}\right] \cdot \left\{\cos(bu)|\sin(bu)\right\}$,}@*)
            double  _a, _b;    //(*@\Green{// where the arguments of parantheses $\left[\right]$ and $\left\{\right\}$ are optional and obligatory,}@*)
            int     _r;        //(*@\Green{// respectively, and the bar $|$ denotes a possible choice}@*)

        public:
            //(*@\Green{// default/special constructors based on a possible complex root $z = a \pm \mathbf{i}b$ of order $m\geq 1$, where}@*)
            //(*@\Green{// $r\in\left\{0,\ldots, m-1\right\}$; if the boolean parameter cosine is true, the generated ordinary basis function}@*)
            //(*@\Green{// corresponds to $u^{r} \cdot \left[e^{au}\right] \cdot \cos(bu)$, otherwise to $u^{r} \cdot \left[e^{au}\right] \cdot \sin(bu)$}@*)
            _OrdinaryBasisFunction(double a = 0.0, double b = 0.0, int r = 0,
                                   bool cosine = true);

            //(*@\Green{// overloaded function operator that evaluates the $j$th order ($j\geq 0$) derivative of the stored ordinary}@*)
            //(*@\Green{// basis function at the parameter value $u \in \left[\alpha, \beta\right]$}@*)
            double operator ()(int j, double u) const;

            //(*@\Green{// getters}@*)
            Type    type() const;
            double  a() const;
            double  b() const;
            int     r() const;
        };

        //(*@\Green{// user-specified endpoints of the definition domain $\left[\alpha, \beta\right]$, where $0 < \beta-\alpha < \ell^{\prime}\left(\mathbb{S}_{n}^{\alpha,\beta}\right)$}@*)
        double                                  _alpha, _beta;

        //(*@\Green{// The member variable \_polynomial represents the characteristic polynomial (\mref{eq:characteristic_polynomial}) associated with the}@*)
        //(*@\Green{// differential equation (\mref{eq:differential_equation}). During the maintenance of its factorization (i.e., in case of root insertion}@*)
        //(*@\Green{// and deletion) conjugate zeros will be considered equivalent. Therefore the variable \_polynomial only}@*)
        //(*@\Green{// stores conjugately pairwise different zeros, and if one tries to insert an already existing root, only its}@*)
        //(*@\Green{// order (i.e., multiplicity) will be updated to the maximum of its former and newly given values.}@*)
        //(*@\Green{// An existing root can also be indetified by its conjugately equivalent variant and, if its requested,}@*)
        //(*@\Green{// it will be deleted independently of its order.}@*)
        CharacteristicPolynomial                _polynomial;

        //(*@\Green{// represents the ordinary basis $\left\{\varphi_{n,i}\left(u\right):u\in\left[\alpha,\beta\right]\right\}_{i=0}^n$ of type (\mref{eq:ordinary_basis}) that is generated by the (higher}@*)
        //(*@\Green{// order) zeros of the given characteristic polynomial}@*)
        std::vector<_OrdinaryBasisFunction>     _phi;

        //(*@\Green{// By solving the linear system ($\mref{eq:boundary_conditions}$) for all indices $i=0,1,...,n$, one can build the unique real square}@*)
        //(*@\Green{// matrix $\left[\rho_{i,k}\right]_{i=0,k=0}^{n,n}$ that transforms the ordinary basis functions $\left\{\varphi_{n,i} : u \in [\alpha,\beta]\right\}_{i=0}^n$ to the particular}@*)
        //(*@\Green{// integrals (i.e., bicanonical basis) $\left\{v_{n,i}(u) : u \in [\alpha,\beta]\right\}_{i=0}^n$ described by equation (\mref{eq:particular_integrals}), i.e.,}@*)
        //(*@\Green{// $v_{n,i}\left(u\right) = \sum_{k = 0}^{n} \rho_{i, k} \varphi_{n,k}\left(u\right),~\forall u \in \left[\alpha, \beta\right],~\forall i = 0,1,\ldots,n$. The address of the matrix $\left[\rho_{i,k}\right]_{i=0,k=0}^{n,n}$ will}@*)
        //(*@\Green{// be stored in the next smart pointer.}@*)
        SP<RealMatrix>::Default                 _rho;

        //(*@\Green{// a smart pointer to the Wronskian $W_{\left[  v_{n,n},v_{n,n-1},\ldots,v_{n,0}\right]}\left(\beta\right)$ of the reverse ordered system}@*)
        //(*@\Green{// $\left\{v_{n,n-i}(u) : u \in [\alpha,\beta]\right\}_{i=0}^{n}$ at the parameter value $u = \beta$}@*)
        SP<RealMatrix>::Default                 _reversed_v_Wronskian_beta;

        //(*@\Green{// smart pointers to the lower and upper triangular matrices that appear in the Doolittle-type $LU$}@*)
        //(*@\Green{// decomposition $L\cdot U=W_{\left[  v_{n,n},v_{n,n-1},\ldots,v_{n,0}\right]  }\left(\beta\right)$}@*)
        SP<RealMatrix>::Default                 _L, _U;

        //(*@\Green{// a smart pointer to the first column of the inverse matrix ${L^{-1}}$}@*)
        SP< ColumnMatrix<double> >::Default    _lambda;

        //(*@\Green{// a smart pointer that stores -- based on the reflection invariance of the underlying EC space -- the}@*)
        //(*@\Green{// address of a matrix that consists of either all or first half of the columns of the inverse matrix $U^{-1}$}@*)
        SP<RealMatrix>::Default                _mu;

        //(*@\Green{// determines whether the underlying EC space is reflection invariant or not}@*)
        bool                                   _is_reflection_invariant;

    private:
        //(*@\Green{// Our smart pointers automatically delete the dynamically allocated objects referenced by them when they}@*)
        //(*@\Green{// go out of scope. However, it may happen that we need to manually delete the referenced objects and to}@*)
        //(*@\Green{// re-initialize the smart pointers to their default null values in order to highlight that some mathematical}@*)
        //(*@\Green{// operation could not be performed successfully. For such special cases we will use the next private method.}@*)
        void _deleteAllDynamicallyAllocatedObjects();

    public:
        //(*@\Red{// \textbf{Remark}}@*)
        //(*@\Red{//}@*)
        //(*@\Red{// Several methods of this class expect a boolean flag named check\_for\_ill\_conditioned\_matrices and a}@*)
        //(*@\Red{// non-negative integer named expected\_correct\_significant\_digits.}@*)
        //(*@\Red{//}@*)
        //(*@\Red{// If the flag check\_for\_ill\_conditioned\_matrices is set to true, the method will calculate the condition number}@*)
        //(*@\Red{// of each matrix that appears in the construction of the unique normalized B-basis of the underlying EC space.}@*)
        //(*@\Red{// Using singular value decomposition, each condition number is determined as the ratio of the largest}@*)
        //(*@\Red{// and smallest smallest singular values of the corresponding matrices.}@*)
        //(*@\Red{//}@*)
        //(*@\Red{// If at least one of the obtained condition numbers is too large, i.e., when the number of estimated correct}@*)
        //(*@\Red{// significant digits is less than number of expected ones, the method will throw an exception that states}@*)
        //(*@\Red{// that one of the systems of linear equations is ill-conditioned and therefore its solution may be not accurate.}@*)
        //(*@\Red{//}@*)
        //(*@\Red{// If the user catches such an exception, one can try:}@*)
        //(*@\Red{// \ \ 1) to lower the number of expected correct significant digits;}@*)
        //(*@\Red{// \ \ 2) to decrease the dimension of the underlying EC space;}@*)
        //(*@\Red{// \ \ 3) to change the endpoints of the definition domain $\left[\alpha, \beta\right]$;}@*)
        //(*@\Red{// \ \ 4) to run the code without testing for ill-conditioned matrices and hope for the best.}@*)
        //(*@\Red{//}@*)
        //(*@\Red{// Note that the standard condition number may lead to an overly pessimistic estimate for the overall error}@*)
        //(*@\Red{// and, by activating this boolean flag, the run-time of these methods will increase. Several numerical tests}@*)
        //(*@\Red{// show that ill-conditioned matrices appear either when one defines EC spaces with relatively big dimensions,}@*)
        //(*@\Red{// or when the endpoints of the definition domain are poorly chosen. Considering that, in practice, curves and}@*)
        //(*@\Red{// surfaces are mostly composed of smoothly joined lower order arcs and patches, by default we opted for speed,}@*)
        //(*@\Red{// i.e., initially the flag check\_for\_ill\_conditioned\_matrices is set to false. Naturally, if one obtains mathematically}@*)
        //(*@\Red{// or geometrically unexpected results, then one should (also) study the condition numbers mentioned above.}@*)

        //(*@\Green{// default/special constructor}@*)
        ECSpace(double alpha = 0.0, double beta = 1.0,
                bool check_for_ill_conditioned_matrices = false,
                int expected_correct_significant_digits = 5);

        //(*@\Green{// Inserts an $m$th order complex root of the form $z = a \pm \mathbf{i}b$ into the factorization of the characteristic polynomial.}@*)
        bool insertZero(
                double a, double b, int m,
                bool update_both_bases = true,
                bool check_for_ill_conditioned_matrices = false,
                int expected_correct_significant_digits = 5);

        bool insertZero(
                const CharacteristicPolynomial::Zero &zero,
                bool update_both_bases = true,
                bool check_for_ill_conditioned_matrices = false,
                int expected_correct_significant_digits = 5);

        //(*@\Green{// If exists, deletes a complex root of the form  $z = a \pm \mathbf{i}b$ independently of its order. Note that the}@*)
        //(*@\Green{// root $z = 0$ will never be deleted since its existence its critical.}@*)
        bool deleteZero(
                double a, double b,
                bool update_both_bases = true,
                bool check_for_ill_conditioned_matrices = false,
                int expected_correct_significant_digits = 5);

        bool deleteZero(
                const CharacteristicPolynomial::Zero &zero,
                bool update_both_bases = true,
                bool check_for_ill_conditioned_matrices = false,
                int expected_correct_significant_digits = 5);

        //(*@\Green{// Generates/updates all ordinary basis functions $\left\{\varphi_{n,i}\left(u\right) : u \in \left[\alpha, \beta\right]\right\}_{i=0}^{n}$ and also calculates all}@*)
        //(*@\Green{// information necessary for the evaluation and differentiation of all normalized B-basis functions}@*)
        //(*@\Green{// $\left\{b_{n,i}\left(u\right) : u \in \left[\alpha, \beta\right]\right\}_{i=0}^{n}$.}@*)
        bool updateBothBases(
                bool check_for_ill_conditioned_matrices = false,
                int expected_correct_significant_digits = 5);

        //(*@\Green{// Returns the dimension of the underlying EC vector space of functions.}@*)
        int dimension() const;

        //(*@\Green{// Returns the starting point of the definition domain.}@*)
        double alpha() const;

        //(*@\Green{// Returns the ending point of the definition domain.}@*)
        double beta() const;

        //(*@\Green{// Overloaded function operator that evaluates the $j$th order ($j\geq 0$) derivative either of the $i$th ordinary basis }@*)
        //(*@\Green{// function or of the normalized B-basis function at the parameter value $u \in \left[\alpha, \beta\right]$.}@*)
        double operator ()(BasisFunctionType type, int i, int j, double u) const;

        //(*@\Green{// Calculates the entries of the matrix $[t_{i,j}^{n}]_{i=0,j=0}^{n,n}$ that appears in the general basis transformation (\mref{eq:basis_transformation})}@*)
        //(*@\Green{// that maps the normalized B-basis $\left\{b_{n,i}\left(u\right) : u \in \left[\alpha, \beta\right]\right\}_{i=0}^{n}$ of the underlying EC vector space of functions}@*)
        //(*@\Green{// to its ordinary basis $\left\{\varphi_{n,i}\left(u\right) : u \in \left[\alpha, \beta\right]\right\}_{i=0}^{n}$.}@*)
        RealMatrix* basisTransformationFromNBToOrdinary() const;

        //(*@\Green{// Determines whether the specified EC vector space is reflection invariant.}@*)
        bool isReflectionInvariant() const;

        //(*@\Green{// If possible, generates the \LaTeX{} expression of the $i$th ordinary basis functions.}@*)
        bool LaTeXExpression(int i, std::string &expression) const;

        //(*@\Green{// Sets the endpoints of the definition domain (in case of modifications the normalized B-basis has to be}@*)
        //(*@\Green{// udated).}@*)
        bool setDefinitionDomain(double alpha, double beta,
                                 bool check_for_ill_conditioned_matrices = false,
                                 int expected_correct_significant_digits = 5);

        //(*@\Green{// Returns whether the ordninary basis and the normalized B-basis have to be updated.}@*)
        bool factorizationOfTheCharacteristicPolynomialChanged() const;

        //(*@\Green{// Generates images of all ordinary or normalized B-basis functions.}@*)
        RowMatrix<SP<GenericCurve3>::Default>* generateImagesOfAllBasisFunctions(
                BasisFunctionType type,
                int maximum_order_of_derivatives, int div_point_count) const;

        //(*@\Green{// clone function required by smart pointers based on the deep copy ownership policy}@*)
        virtual ECSpace* clone() const;

        //(*@\Green{// destructor}@*)
        virtual ~ECSpace();
    };

    //(*@\Green{// overloaded output to stream operator}@*)
    std::ostream& operator <<(std::ostream &lhs, const ECSpace &rhs);
}

#endif //(*@\Green{// ECSPACES\_H}@*)
