Given a matrix $A \in \mathbb R^{n \times n}$, the {\itshape standard eigenvalue problem} (S\+EP) consists of finding {\itshape eigenvalues} $\lambda_i \in \mathbb C$ and associated {\itshape eigenvectors} $0 \neq v_i \in \mathbb C^{n}$ such that \[ A v_i = \lambda_i v_i, \text{ for } i = 1, 2, \dots, n. \] The eigenvalues are the $n$ (potentially complex) roots of the polynomial $\text{det}(A - \lambda I) = 0$ of degree $n$. There is often a full set of $n$ linearly independent eigenvectors, but if there are {\itshape multiple} eigenvalues (i.\+e., if $\lambda_{i} = \lambda_{j}$ for some $i \neq j$) then there might not be a full set of independent eigenvectors.

The library provides 12 interface functions for the standard case.

\doxysection*{Hessenberg reduction}

Given a general matrix $A$, the \mbox{\hyperlink{group__starneig__sm__sep_ga3180b21861b10ebf4016ee15e2f79d82}{starneig\+\_\+\+S\+E\+P\+\_\+\+S\+M\+\_\+\+Hessenberg()}} and \mbox{\hyperlink{group__starneig__dm__sep_gab328fae0d50eaab2e35110da6d6812c8}{starneig\+\_\+\+S\+E\+P\+\_\+\+D\+M\+\_\+\+Hessenberg()}} interface functions compute a Hessenberg decomposition \[ A = U * H * U^T, \] where $H$ is upper Hessenberg and $U$ is orthogonal. On exit, $A$ is overwritten by $H$ and $Q$ (which is an orthogonal matrix on entry) is overwritten by \[ Q \gets Q * U. \]

This is done in order to greatly accelerate the subsequent computation of a Schur decomposition since when working on $H$ of size $n \times n$, the amount of work in each iteration of the QR algorithm is reduced from $\mathcal{O}(n^3)$ to $\mathcal{O}(n^2)$ flops.

\doxysection*{Schur reduction}

Given a Hessenberg decomposition \[ A = Q * H * Q^T, \] of a general matrix $A$, the \mbox{\hyperlink{group__starneig__sm__sep_ga357a2d35c0087d984f69987ac23aedfc}{starneig\+\_\+\+S\+E\+P\+\_\+\+S\+M\+\_\+\+Schur()}} and \mbox{\hyperlink{group__starneig__dm__sep_ga84f941b63f8bfee1f7535fc072b186ce}{starneig\+\_\+\+S\+E\+P\+\_\+\+D\+M\+\_\+\+Schur()}} interface functions compute a Schur decomposition \[ A = Q * ( U * S * U^T ) * Q^T \] where $S$ is upper quasi-\/triangular with $1 \times 1$ and $2 \times 2$ blocks on the diagonal (Schur matrix) and $U$ is orthogonal. The $1 \times 1$ blocks correspond to the real eigenvalues and each $2 \times 2$ block corresponds to a pair of complex conjugate eigenvalues. On exit, $H$ is overwritten by $S$ and $Q$ is overwritten by \[ Q \gets Q * U. \]

\doxysection*{Eigenvalue reordering}

Given a Schur decomposition \[ A = Q * S * Q^T \] of a general matrix $A$ and a selection of eigenvalues, the \mbox{\hyperlink{group__starneig__sm__sep_ga03cc4e4c45d6ca0d156a3d70d4b91408}{starneig\+\_\+\+S\+E\+P\+\_\+\+S\+M\+\_\+\+Reorder\+Schur()}} and \mbox{\hyperlink{group__starneig__dm__sep_ga22daf6b10b6da2750125dce46b663e07}{starneig\+\_\+\+S\+E\+P\+\_\+\+D\+M\+\_\+\+Reorder\+Schur()}} interface functions attempt to compute an updated Schur decomposition \[ A = Q * \left( U * \begin{bmatrix} \hat S_{11} & \hat S_{12} \\ 0 & \hat S_{22} \end{bmatrix} * U^T \right) * Q^T, \] where the selected eigenvalues appear in $\hat S_{11}$. On exit, $S$ is overwritten by $\hat{S}$ and $Q$ is overwritten by \[ Q \gets Q * U. \]

Reordering may in rare cases fail. In such cases the output is guaranteed to be a Schur decomposition and all (if any) selected eigenvalues that are correctly placed are marked in the selection array on exit. Reordering may perturb the eigenvalues and the eigenvalues after reordering are returned.

\doxysection*{Combined reduction to Schur form and eigenvalue reordering}

Given a general matrix $A$, the \mbox{\hyperlink{group__starneig__sm__sep_ga8e038624fecd9f1abb604bef3eb56d3b}{starneig\+\_\+\+S\+E\+P\+\_\+\+S\+M\+\_\+\+Reduce()}} and \mbox{\hyperlink{group__starneig__dm__sep_gacda636c9bbb32bb65f03b0797998f1bc}{starneig\+\_\+\+S\+E\+P\+\_\+\+D\+M\+\_\+\+Reduce()}} interface functions compute a (reordered) Schur decomposition \[ A = U * S * U^T. \] Optionally, the interface functions attempt to reorder selected eigenvalues to the top left corner of the Schur matrix $S$. On exit, $A$ is overwritten by $S$ and $Q$ (which is an orthogonal matrix on entry) is overwritten by \[ Q \gets Q * U. \]

Reordering may in rare cases fail. In such cases the output is guaranteed to be a Schur decomposition and all (if any) selected eigenvalues that are correctly placed are marked in the selection array on exit. Reordering may perturb the eigenvalues and the eigenvalues after reordering are returned.

\doxysection*{Eigenvectors}

Given a subset consisting of $m \leq n$ of the eigenvalues $\lambda_{i}$ for $i = 1, 2, \ldots, m$ and a Schur decomposition $A = Q S Q^{H}$, we can compute for each $\lambda_{i}$ an {\itshape eigenvector} $v_{i} \neq 0$ such that $A v_{i} = \lambda_{i} v_{i}$ by first computing an eigenvector $w_{i}$ of $S$ and then transform it back to the original basis by pre-\/multiplication with $Q$.

Given a Schur decomposition \[ A = Q * S * Q^T \] of a general matrix $A$ and a selection of eigenvalues, the \mbox{\hyperlink{group__starneig__sm__sep_ga63f72c90a9911f670610c102029b8ea0}{starneig\+\_\+\+S\+E\+P\+\_\+\+S\+M\+\_\+\+Eigenvectors()}} and \mbox{\hyperlink{group__starneig__dm__sep_gaa3e495a9ba099cdbc56266d078871b28}{starneig\+\_\+\+S\+E\+P\+\_\+\+D\+M\+\_\+\+Eigenvectors()}} interface functions compute and return an eigenvector for each of the selected eigenvalues.

The eigenvectors are stored as columns in the output matrix $X$ in the same order as their corresponding eigenvalues appear in the selection array. A real eigenvector is stored as a single column. The real and imaginary parts of a complex eigenvector are stored as consecutive columns.

For a selected pair of complex conjugate eigenvalues, an eigenvector is computed only for the eigenvalue with positive imaginary part. Thus, every selected eigenvalue contributes one column to the output matrix and thus the number of selected eigenvalues is equal to the number of columns of $X$.

\doxysection*{Eigenvalue selection helper}

Given a Schur matrix and a predicate function, the \mbox{\hyperlink{group__starneig__sm__sep_ga9d824d76e75f00a2f6a9b0bdc37e159c}{starneig\+\_\+\+S\+E\+P\+\_\+\+S\+M\+\_\+\+Select()}} and \mbox{\hyperlink{group__starneig__dm__sep_ga2387379625b60d79ad9ae20ec58ff64a}{starneig\+\_\+\+S\+E\+P\+\_\+\+D\+M\+\_\+\+Select()}} interface functions conveniently generate a correct selection array and count the number of selected eigenvalues. The count is useful when allocating storage for the eigenvector matrix computed by the \mbox{\hyperlink{group__starneig__sm__sep_ga63f72c90a9911f670610c102029b8ea0}{starneig\+\_\+\+S\+E\+P\+\_\+\+S\+M\+\_\+\+Eigenvectors()}} and \mbox{\hyperlink{group__starneig__dm__sep_gaa3e495a9ba099cdbc56266d078871b28}{starneig\+\_\+\+S\+E\+P\+\_\+\+D\+M\+\_\+\+Eigenvectors()}} interface functions.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// a predicate function that selects all eigenvalues that have a real}}
\DoxyCodeLine{\textcolor{comment}{// part that is larger than a given value}}
\DoxyCodeLine{\textcolor{keyword}{static} \textcolor{keywordtype}{int} predicate(\textcolor{keywordtype}{double} real, \textcolor{keywordtype}{double} imag, \textcolor{keywordtype}{void} *arg)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordtype}{double} value = * (\textcolor{keywordtype}{double} *) arg;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (value < real)}
\DoxyCodeLine{        \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} func(...)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordtype}{double} *S; \textcolor{keywordtype}{int} ldS;}
\DoxyCodeLine{}
\DoxyCodeLine{    ...}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{double} value = 0.5;}
\DoxyCodeLine{    \textcolor{keywordtype}{int} num\_selected, *selected = malloc(n*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));}
\DoxyCodeLine{    \mbox{\hyperlink{group__starneig__sm__sep_ga9d824d76e75f00a2f6a9b0bdc37e159c}{starneig\_SEP\_SM\_Select}}(}
\DoxyCodeLine{        n, S, ldS, \&predicate, \&value, selected, \&num\_selected);}
\DoxyCodeLine{}
\DoxyCodeLine{    ...}
\DoxyCodeLine{\}}
\end{DoxyCode}


See modules \mbox{\hyperlink{group__starneig__sm__sep}{Shared Memory / Standard E\+VP}} and \mbox{\hyperlink{group__starneig__dm__sep}{Distributed Memory / Standard E\+VP}} for further information. See also examples \mbox{\hyperlink{sep_sm_full_chain_8c-example}{sep\+\_\+sm\+\_\+full\+\_\+chain.\+c}}, \mbox{\hyperlink{sep_dm_full_chain_8c-example}{sep\+\_\+dm\+\_\+full\+\_\+chain.\+c}} and \mbox{\hyperlink{sep_sm_eigenvectors_8c-example}{sep\+\_\+sm\+\_\+eigenvectors.\+c}}. 