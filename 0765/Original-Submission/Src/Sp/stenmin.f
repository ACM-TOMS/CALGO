*
* STENMIN: A SOFTWARE PACKAGE FOR LARGE, SPARSE UNCONSTRAINED
* OPTIMIZATION USING TENSOR METHODS.
*
*
* AUTHOR:
* ------
*           ALI BOUARICHA
*           ARGONNE NATIONAL LABORATORY
*           MCS DIVISION
*           9700 SOUTH CASS AVENUE
*           ARGONNE, IL 60439
*           E-MAIL: BOUARICH@MCS.ANL.GOV
*
* DATE:     OCTOBER, 1994
* ----
*
* PURPOSE:
* -------
*
* STENMIN MINIMIZES AN UNCONSTRAINED NONLINEAR FUNCTION IN N UNKNOWNS
* WHERE THE HESSIAN IS LARGE AND SPARSE USING A NEW CLASS OF METHODS
* CALLED TENSOR METHODS.  THE SOFTWARE ALLOWS THE USER TO SELECT BETWEEN
* A TENSOR METHOD AND A STANDARD METHOD BASED UPON A QUADRATIC MODEL.
* THE TENSOR METHOD MODELS THE OBJECTIVE FUNCTION BY A FOURTH-ORDER
* MODEL, WHERE THE THIRD- AND FOURTH-ORDER TERMS ARE CHOSEN SUCH THAT
* THE EXTRA COST OF FORMING AND SOLVING THE MODEL IS SMALL.  THE TEST
* RESULTS INDICATE THAT, IN GENERAL, THE TENSOR METHOD IS OFTEN MORE
* EFFICIENT AND MORE RELIABLE THAN THE STANDARD nEWTON METHOD FOR
* SOLVING LARGE, SPARSE UNCONSTRAINED OPTIMIZATION PROBLEMS. IT IS
* ESPECIALLY USEFUL ON PROBLEMS WHERE THE HESSIAN AT THE SOLUTION IS
* SINGULAR.
*
* TWO INTERFACES ARE PROVIDED WITH STENMIN.  IF THE USER WISHES TO USE
* ALL THE DEFAULTS OPTIONS PROVIDED BY THE PACKAGE, THEN HE (OR SHE)
* SHOULD CALL STUMSD (STUMSS IF SINGLE-PRECISION IS USED). THE OTHER
* INTERFACE, STUMCD (STUMCS IF SINGLE-PRECISION IS USED), REQUIRES THE
* USER TO SUPPLY ALL PARAMETERS.  THE USER MAY SPECIFY SELECTED
* PARAMETERS ONLY BY FIRST INVOKING THE SUBROUTINE STDFLT, WHICH SETS
* ALL PARAMETERS TO THEIR DEFAULT VALUES, AND THEN OVERRIDING ONLY THE
* DESIRED VALUES.
*
*
* LIST OF SUBROUTINE AND FUNCTION NAMES CALLED BY STENMIN:
*
* STCHKG,STCHKH,STCHKI,STCHKS,STCZ3P,STDFLT,STDRUO,STDUGR,STDUSH,
* STFDGR,STFDHS,STFTSM,STHMUV,STLSCH,STMA27,STMNEC,STMSLV,STRSLT,
* STSORT,STUMCD,STUMSD.
*
* PACKAGES CALLED BY STENMIN:
*
*
* MA27 (I. S. DUFF AND J. K. REID, "MA27: A SET OF FORTRAN SUBROUTINES
* FOR SOLVING SPARSE SYMMETRIC SETS OF LINEAR EQUATIONS", TECH. REP.
* R-10533, AERE HARWELL LABORATORY, HARWELL, UK, 1983.)
*
* DSSM (T. F. COLEMAN, B. S. GARBOW, and J. J. MORE', "SOFTWARE FOR
* ESTIMATING SPARSE HESSIAN MATRICES", ACM TRANS. MATH. SOFTW., 11:
* 363-377,1985.)
*
* DSYPRC FROM LANCELOT (A. R. CONN, N. I. M. GOULD, AND C PH. L. TOINT,
* "LANCELOT", SPRINGER SERIES IN COMPUTATIONAL MATHEMATICS,
* SPRINGER-VERLAG, 1992.)
*
* R1MACH (FOX P.A., HALL A.D., SCHRYER N.L., FRAMEWORK FOR A PORTABLE
* LIBRARY, ACM TRANS. MATH. SOFTW., 4:177-188, 1978.)
*
* BLAS CALLED BY STENMIN:
*
* LEVEL 1 BLAS: DCOPY,DDOT,DNRM2,DSCAL
*

      SUBROUTINE STCHKG(N,X,FCN,F,G,TYPX,RNF,ANALTL,WRK1,MSG,IPR)
*
* PURPOSE:
* -------
*
* THIS ROUTINE CHECKS THE USER'S ANALYTIC GRADIENT AGAINST A
* FINITE-DIFFERENCE GRADIENT.
*
* PARAMETERS:
* ----------
*
* N            --> DIMENSION OF PROBLEM
* X            --> CURRENT ITERATE
* FCN          --> NAME OF SUBROUTINE THAT EVALUATES THE
*                  OPTIMIZATION FUNCTION
* F            --> FUNCTION VALUE AT X
* G            --> GRADIENT VALUE AT X
* TYPX         --> TYPICAL SIZE FOR EACH COMPONENT OF X
* RNF          --> RELATIVE NOISE IN FCN
* ANALTL       --> TOLERANCE FOR COMPARISON OF ESTIMATED AND ANALYTICAL
*                  GRADIENTS
* WRK1         --> WORKSPACE.  IT IS USED TO HOLD THE FINITE-DIFFERENCE
*                  APPROXIMATION OF THE GRADIENT AT X
* MSG         <--  MESSAGE OR ERROR CODE. IF PROBABLE CODING ERROR OF
*                  GRADIENT IS DETECTED THEN MSG = -8
* IPR          --> DEVICE TO WHICH TO SEND OUTPUT
*
      INTEGER          N,MSG,IPR
      REAL             X(N),F,G(N),TYPX(N),RNF,ANALTL,WRK1(N)
*
*  LOCAL VARIABLES
*
      INTEGER          KER,I
      REAL             GS,ONE
      EXTERNAL         FCN
      INTRINSIC        ABS,MAX
      DATA             ONE/1.0E0/
*
* COMPUTE FIRST-ORDER FINITE DIFFERENCE GRADIENT AND COMPARE TO
* ANALYTIC GRADIENT
*
      CALL STFDGR(N,X,FCN,F,RNF,WRK1)
      KER = 0
      DO 10 I = 1,N
          GS = MAX(ABS(F),ONE)/MAX(ABS(X(I)),ONE/TYPX(I))
          IF (ABS(G(I)-WRK1(I)).GT.MAX(ABS(G(I)),GS)*ANALTL) KER = 1
   10 CONTINUE
      IF (KER.EQ.0) GO TO 20
      WRITE (IPR,9000)
      WRITE (IPR,9010) (I,G(I),WRK1(I),I=1,N)
      MSG = -8
   20 CONTINUE
      RETURN

 9000 FORMAT (' STCHKG    PROBABLE ERROR IN CODING OF ANALYTIC',
     +       ' GRADIENT FUNCTION.'/' STCHKG     COMP',12X,'ANALYTIC',
     +       12X,'ESTIMATE')
 9010 FORMAT (' STCHKG    ',I5,3X,E20.13,3X,E20.13)
      END


      SUBROUTINE STCHKH(N,X,NPAIRS,NZ,IRN,LIRN,ICN,LICN,FCN,UGR,SCALE,
     +                  TYPX,GRDFLG,F,G,RNF,ANALTL,FCALL,CHECKH,LISTP,
     +                  NGRP,IPNTR,JPNTR,IWA,LIWA,FHESD,XD,ETA,HESS,IPR,
     +                  MSG)
*
* PURPOSE
* -------
*
* THIS ROUTINE CHECKS THE USER'S ANALYTIC HESSIAN AGAINST A
* FINITE-DIFFERENCE HESSIAN.
*
* PARAMETERS:
* ----------
*
*   N       --> NUMBER OF VARIABLES IN THE PROBLEM
*   X       --> CURRENT ITERATE
*   NPAIRS  --> A POSITIVE INTEGER INPUT VARIABLE SET TO THE NUMBER
*               OF (IRN,ICN) PAIRS USED TO DESCRIBE THE SPARSITY
*               PATTERN OF THE HESSIAN MATRIX
*   NZ      <-- ACTUAL NUMBER OF NONZEROS STORED IN THE LOWER
*               HALF OF THE HESSIAN MATRIX
*   IRN     <-->ROW INDEX OF EACH NONZERO STORED IN THE LOWER
*               OR UPPER HALF OF THE HESSIAN MATRIX ON ENTRY.  ON EXIT,
*               IT HOLDS THE ROW INDEX OF EACH NONZERO STORED IN THE
*               LOWER HALF OF THE HESSIAN MATRIX
*   ICN     <-->COLUMN INDEX OF THE NONZEROS STORED IN THE LOWER
*               OR UPPER HALF OF THE HESSIAN MATRIX ON ENTRY. ON EXIT,
*               IT HOLDS THE COLUMN INDEX OF EACH NONZERO STORED IN THE
*               LOWER HALF OF THE HESSIAN MATRIX
*   FCN     --> THE NAME OF A USER SUPPLIED SUBROUTINE THAT EVALUATES
*               THE FUNCTION F AT AN ARBITRARY VECTOR X
*   UGR     --> THE NAME OF A USER SUPPLIED SUBROUTINE THAT RETURNS IN
*               THE VALUE OF THE GRADIENT
*   SCALE   --> LOGICAL VARIABLE INDICATING WHETHER OR NOT SCALING
*               OF THE VARIABLES IS PERFORMED
*   TYPX    --> TYPICAL SIZE OF THE COMPONENTS OF X
*   GRDFLG  --> INTEGER FLAG DESIGNATING WHETHER OR NOT ANALYTIC
*               GRADIENT HAS BEEN SUPPLIED BY THE USER
*   F       --> FUNCTION VALUE AT CURRENT ITERATE
*   G       --> GRADIENT VALUE AT CURRENT ITERATE
*   RNF     --> RELATIVE NOISE IN FUNCTION FCN
*   ANALTL  --> TOLERANCE FOR COMPARISON OF ESTIMATED AND ANALYTICAL
*               GRADIENTS
*   FCALL   --> A LOGICAL FLAG. IF THE HESSIAN MATRIX IS EVALUATED FOR
*               THE FIRST TIME, THEN FCALL IS SET TO TRUE; OTHERWISE
*               IT IS SET TO FALSE
*   CHECKH  --> A LOGICAL FLAG. IF IT IS SET TO TRUE THEN THE USER'S
*               ANALYTIC HESSIAN IS CHECKED AGAINST THE FINITE
*               DIFFERENCE APPROXIMATION ONE
*   LISTP,NGRP,IPNTR,JPNTR,IWA --> WORSPACE FOR THE STFDHS SUBROUTINE
*               (SEE SUBROUTINE STFDHS FOR MORE DETAIL)
*   LIWA    --> LENGTH OF ARRAY IWA
*   FHESD,XD,ETA --> WORKSPACE FOR THE STFDHS SUBROUTINE
*   HESS   <--> ANALYTIC HESSIAN ON INPUT.  ON OUTPUT, IT ALSO HOLDS
*               A FINITE-DIFFERENCE APPROXIMATION OF THE HESSIAN
*               (FROM NZ+1 TO 2*NZ)
*   IPR     --> DEVICE TO WHICH TO SEND OUTPUT
*   MSG    <--  MESSAGE OR ERROR CODE. IF PROBABLE CODING ERROR OF
*               HESSIAN IS DETECTED THEN MSG = -9
*
      INTEGER          N,NPAIRS,NZ,GRDFLG,LIWA,IPR,MSG,LIRN,LICN
      INTEGER          IRN(LIRN),ICN(LICN),LISTP(N),NGRP(N),IPNTR(N+1)
      INTEGER          JPNTR(N+1),IWA(LIWA)
      REAL             X(N),TYPX(N),F,G(N),RNF,ANALTL,FHESD(N)
      REAL             XD(N),ETA(N),HESS(LICN)
      LOGICAL          SCALE,FCALL,CHECKH
*
*  LOCAL VARIABLES
*
      INTEGER          IST,IEND,KER,I,IR,J,JP,K,MAXGRP,MINGRP
      REAL             HS,ONE
      EXTERNAL         FCN,UGR
      INTRINSIC        ABS,MAX,MIN
      DATA             ONE/1.0E+0/
*
* CHECK USER'S INPUT DATA.
*
* IF NPAIRS IS NOT POSITIVE THEN SET MSG TO -2 AND ABORT.
*
      IF (NPAIRS.LE.0) THEN
          WRITE (IPR,9000) NPAIRS
          MSG = -4
          RETURN

      END IF
*
* IF THE K-TH ELEMENT OF IRN OR THE K-TH ELEMENT OF ICN IS
* NOT AN INTEGER BETWEEN 1 AND N THEN SET MSG TO -4 AND ABORT.
*
      DO 10 K = 1,NPAIRS
          IF (IRN(K).LT.1 .OR. IRN(K).GT.N .OR. ICN(K).LT.1 .OR.
     +        ICN(K).GT.N) THEN
              WRITE (IPR,9010) K,IRN(K),K,ICN(K)
              MSG = -5
              RETURN

          END IF

   10 CONTINUE
*
* GENERATE THE SPARSITY PATTERN FOR THE LOWER
* TRIANGULAR PART OF HESSIAN.
*
      DO 20 K = 1,NPAIRS
          I = IRN(K)
          J = ICN(K)
          IRN(K) = MAX(I,J)
          ICN(K) = MIN(I,J)
   20 CONTINUE
*
* SORT THE DATA STRUCTURE BY COLUMNS
*
      CALL STSORT(N,NPAIRS,HESS,IRN,ICN,JPNTR,IWA)
*
* COMPRESS THE DATA AND DETERMINE THE NUMBER OF NONZERO
* ELEMENTS IN THE LOWER TRIANGULAR PART OF HESSIAN.
*
      DO 30 I = 1,N
          IWA(I) = 0
   30 CONTINUE
      NZ = 0
      DO 50 J = 1,N
          K = NZ
          DO 40 JP = JPNTR(J),JPNTR(J+1) - 1
              IR = IRN(JP)
              IF (IWA(IR).NE.J) THEN
                  NZ = NZ + 1
                  IRN(NZ) = IR
                  ICN(NZ) = J
                  IWA(IR) = J
              END IF

   40     CONTINUE
          JPNTR(J) = K + 1
   50 CONTINUE
      JPNTR(N+1) = NZ + 1
      IF (NZ.NE.NPAIRS) THEN
          MSG = -7
          WRITE (IPR,9020) NPAIRS - NZ
          RETURN

      END IF
*
      IF (.NOT.CHECKH) RETURN
*
* COMPUTE FINITE-DIFFERENCE APPROXIMATION OF THE HESSIAN
*
      CALL STFDHS(N,NZ,X,IRN,ICN,G,RNF,GRDFLG,FCN,UGR,SCALE,TYPX,FCALL,
     +            LISTP,NGRP,IPNTR,JPNTR,IWA,LIWA,FHESD,XD,ETA,MAXGRP,
     +            MINGRP,HESS(NZ+1))
*
* COMPARE USER'S ANALYTIC HESSIAN TO THE FINITE-DIFFERENCE
* APPROXIMATION
*
      KER = 0
      DO 70 J = 1,N
          HS = MAX(ABS(G(J)),ONE)/MAX(ABS(X(J)),ONE/TYPX(J))
          IST = JPNTR(J)
          IEND = JPNTR(J+1)
          DO 60 I = IST,IEND - 1
              IF (ABS(HESS(I)-HESS(NZ+I)).GT.
     +            MAX(ABS(HESS(I)),HS)*ANALTL) KER = 1
   60     CONTINUE
   70 CONTINUE
*
      IF (KER.EQ.0) GO TO 90
      WRITE (IPR,9030)
      DO 80 I = 1,NZ
          WRITE (IPR,9040) IRN(I),ICN(I),HESS(I),HESS(NZ+I)
   80 CONTINUE
      MSG = -9
   90 CONTINUE
      RETURN
*
 9000 FORMAT (' STCHKH    ILLEGAL NUMBER OF NONZEROS NZ=',I10)
 9010 FORMAT (' STCHKH    ILLEGAL ROW OR COLUMN INDEX IN ANALYTIC',
     +       ' HESSIAN'/,' STCHKH    IRN( ',I6,' )=',I6,2X,' ICN( ',I6,
     +       ' )=',I6)
 9020 FORMAT (' STCHKH    ',I5,' REDUNDANT ENTRIES IN SPARSITY',
     +       ' PATTERN ENCOUNTERED')
 9030 FORMAT (' STCHKH    PROBABLE ERROR IN CODING OF ANALYTIC',
     +       ' HESSIAN FUNCTION'/' STCHKH      IRN  ICN',14X,'ANALYTIC',
     +       14X,'(ESTIMATE)')
 9040 FORMAT (' STCHKH    ',2I5,2X,E20.13,2X,'(',E20.13,')')
      END

      SUBROUTINE STCHKI(N,NPAIRS,NZ,X,IRN,LIRN,ICN,LICN,LIWRK,LWRK,
     +                  SCALE,TYPX,FSCALE,GRADTL,STEPTL,ILIM,NDIGIT,EPS,
     +                  METHOD,GRDFLG,HSNFLG,STEPMX,IWA,LIWA,JPNTR,MSG,
     +                  IPR)
*
* PURPOSE:
* -------
*
* THIS ROUTINE CHECKS THE INPUT FOR REASONABLENESS.
*
* PARAMETERS:
* ----------
* N         --> DIMENSION OF PROBLEM
* NPAIRS    --> A POSITIVE INTEGER INPUT VARIABLE SET TO THE NUMBER
*               OF (IRN,ICN) PAIRS USED TO DESCRIBE THE SPARSITY
*               PATTERN OF THE HESSIAN MATRIX
* NZ        <-- NUMBER OF NONZEROS IN THE LOWER TRIANGULAR PART
*               OF THE HESSIAN MATRIX
* X         --> ON ENTRY, ESTIMATE TO ROOT OF FCN
* IRN      <--> AN INTEGER ARRAY OF LENGTH NPAIRS. ON INPUT IRN MUST
*               CONTAIN THE ROW INDICES OF THE NONZERO ELEMENTS IN
*               THE LOWER TRIANGULAR PART OF THE HESSIAN. ON OUTPUT
*               IRN IS PERMUTED SO THAT THE CORRESPONDING COLUMN
*               INDICES ARE IN NON-DECREASING ORDER. THE COLUMN
*               INDICES CAN BE RECOVERED FROM THE ARRAY JPNTR
* LIRN      --> LENGTH OF ARRAY IRN
* ICN      <--> AN INTEGER ARRAY OF LENGTH NPAIRS. ON INPUT ICN MUST
*               CONTAIN THE COLUMN INDICES OF THE NONZERO ELEMENTS
*               IN THE LOWER TRIANGULAR PART OF THE HESSIAN. ON
*               OUTPUT ICN IS PERMUTED SO THAT THE CORRESPONDING
*               ROW INDICES ARE IN NON-DECREASING ORDER
* LICN     -->  LENGTH OF ARRAY ICN
* LIWRK    -->  LENGTH OF WORKSPACE ARRAY IWRK
* LWRK     -->  LENGTH OF WORKSPACE ARRAY WRK
* SCALE    <--  LOGICAL VARIABLE INDICATING WHETHER OR NOT SCALING
*               OF THE X VARIABLES IS PERFORMED
* TYPX     <--> TYPICAL SIZE OF EACH COMPONENT OF X
* FSCALE   <--> ESTIMATE OF SCALE OF OBJECTIVE FUNCTION FCN
* GRADTL   <--> TOLERANCE AT WHICH GRADIENT CONSIDERED CLOSE
*               ENOUGH TO ZERO TO TERMINATE ALGORITHM
* STEPTL   <--> TOLERANCE AT WHICH STEP LENGTH CONSIDERED CLOSE
*               ENOUGH TO ZERO TO TERMINATE ALGORITHM
* ILIM     <--> MAXIMUM NUMBER OF ALLOWABLE ITERATIONS
* NDIGIT   <--> NUMBER OF GOOD DIGITS IN OPTIMIZATION FUNCTION FCN
* EPS       --> MACHINE PRECISION
* METHOD   <--> METHOD TO BE USED (NEWTON OR TENSOR)
* GRDFLG   <--> =1 IF ANALYTIC GRADIENT SUPPLIED
* HSNFLG   <--> =1 IF ANALYTIC HESSIAN SUPPLIED
* STEPMX   <--> MAXIMUM STEP SIZE
* IWA       --> WORKSPACE ARRAY
* LIWA     <--  ACTUAL LENGTH OF ARRAY IWA ON EXIT
* JPNTR    <--  AN INTEGER OUTPUT ARRAY OF LENGTH N + 1 WHICH
*               SPECIFIES THE LOCATIONS OF THE ROW INDICES IN IRN.
*               THE ROW INDICES FOR COLUMN J ARE
*               IRN(K), K = JPNTR(J),...,JPNTR(J+1)-1. NOTE THAT
*               JPNTR(N+1)-1 IS THEN THE NUMBER OF NONZERO ELEMENTS
*               IN THE LOWER TRIANGULAR PART OF THE MATRIX HESSIAN
* MSG      <--> AN INTEGER VARIABLE THAT THE USER MAY SET ON INPUT TO
*               INHIBIT CERTAIN AUTOMATIC CHECKS OR OVERRIDE CERTAIN
*               DEFAULT CHARACTERISTICS OF THE PACKAGE. ON INPUT:
*               MSG = 0 : NO OUTPUT WILL BE PRODUCED
*               MSG = 1 : PRINT THE INPUT STATE, THE FINAL RESULTS,
*                         AND THE STOPPING CONDITIONS
*               MSG = 2 : PRINT THE INTERMEDIATE RESULTS, THAT IS, THE
*                         INPUT STATE, THE VALUES OF THE OBJECTIVE
*                         FUNCTION AND THE SCALED GRADIENT AT EACH
*                         ITERATION, AND THE FINAL RESULTS INCLUDING
*                         THE STOPPING CONDITIONS AND THE NUMBER OF
*                         FUNCTION, GRADIENT, AND HESSIAN
*
*          ON OUTPUT, IF THE PROGRAM HAS TERMINATED BECAUSE OF
*          ERRONEOUS INPUT, MSG CONTAINS AN ERROR CODE INDICATING
*          THE REASON:
*
*          MSG = -1 : ILLEGAL DIMENSION N; N <= 0. THE PROGRAM ABORTS
*          MSG = -2 : ILLEGAL LENGTH OF LIRN OR LICN; LIRN <= 0 OR
*                     LICN <= 0. THE PROGRAM ABORTS
*          MSG = -3 : ILLEGAL LENGTH OF LIWRK OR LWRK; LIWRK < 2*LIRN
*                     +12*N+2 OR LWRK < 7*N. THE PROGRAM ABORTS
*          MSG = -4 : ILLEGAL NUMBER OF NONZEROS NZ; NZ <= 0. THE
*                     PROGRAM ABORTS
*          MSG = -5 : THE K-TH ELEMENT OF IRN OR THE K-TH ELEMENT OF
*                     ICN IS NOT AN INTEGER BETWEEN 1 AND N; (IRN(K)
*                     < 1 OR IRN(K) > N) OR (ICN(K) < 1 OR ICN(K) > N).
*                     THE PROGRAM ABORTS
*          MSG = -6 : THE K-TH DIAGONAL ELEMENT IS NOT IN THE SPARSITY
*                     PATTERN. THIS IS CHECKED ONLY IF HSNFLG = 0.
*                     THE PROGRAM ABORTS
*          MSG = -7 : REDUNDANT ENTRIES IN SPARSITY PATTERN WAS
*                     ENCOUNTERED. WHEN HSNFLG = 1 OR HSNFLG = 2, THE
*                     PROGRAM ABORTS. WHEN HSNFLG = 0, THE PROGRAM
*                     ELIMINATES THE REDUNDANT ENTRIES AND CONTINUES
*                     THE EXECUTION
*          MSG = -8 : PROBABLE CODING ERROR IN THE USER'S ANALYTIC
*                     GRADIENT ROUTINE UGR. THE PROGRAM ABORTS. (THIS
*                     CHECK CAN BE OVERRIDDEN BY SETTING GRDFLG = 2.)
*                     (SEE SUBROUTINE STCHKG)
*          MSG = -9 : PROBABLE CODING ERROR IN THE USER'S ANALYTIC
*                     HESSIAN ROUTINE USH. THE PROGRAM ABORTS. (THIS
*                     CHECK CAN BE OVERRIDDEN BY SETTING HSNFLG = 2.)
*                    (SEE SUBROUTINE STCHKH)
*
* IPR          --> DEVICE TO WHICH TO SEND OUTPUT
*
      INTEGER          N,NPAIRS,NZ,LIRN,LICN,LIWRK,LWRK,ILIM,NDIGIT,
     +                 METHOD
      INTEGER          GRDFLG,HSNFLG,LIWA,MSG,IPR
      INTEGER          IRN(LIRN),ICN(LICN),IWA(N),JPNTR(N+1)
      REAL             X(N),TYPX(N),FSCALE,GRADTL,STEPTL,STEPMX
      LOGICAL          SCALE
*
*  LOCAL VARIABLES
*
      INTEGER          I,IR,J,JP,K
      REAL             STPSIZ,TEMP,EPS,ZERO,ONE,THREE,TEN,THOUS
      INTRINSIC        LOG10,MAX,MIN,SQRT
      DATA             ZERO,ONE,THREE,TEN,THOUS/0.0E+0,1.0E+0,3.0E+0,
     +                 10.0E+0,1000.0E+0/
*
* CHECK THAT PARAMETERS ONLY TAKE ON ACCEPTABLE VALUES.
* IF NOT, SET THEM TO DEFAULT VALUES.
*
* CHECK DIMENSION OF THE PROBLEM
*
      IF (N.LE.0) THEN
          WRITE (IPR,9000) N
          MSG = -1
          RETURN

      END IF
*
      IF (LIRN.LE.0 .OR. LICN.LE.0) THEN
          WRITE (IPR,9010) LIRN,LICN
          MSG = -2
          RETURN

      END IF
*
* IF LIWRK IS LESS THAN 2*LIRN+12*N+2 OR LWRK LESS THAN 7*N
* SET MSG = -3 AND ABORT.
*
      IF (LIWRK.LT.2*LIRN+12*N+2 .OR. LWRK.LT.7*N) THEN
          WRITE (IPR,9020) LIWRK,LWRK
          MSG = -3
          RETURN

      END IF
*
* SET THE LENGTH OF LIWA
*
      LIWA = 2*LIRN + 8*N
*
      IF (HSNFLG.EQ.0) THEN
*
* IF NPAIRS IS NOT POSITIVE THEN SET MSG TO -4 AND ABORT.
*
          IF (NPAIRS.LE.0) THEN
              WRITE (IPR,9030) NPAIRS
              MSG = -4
              RETURN

          END IF
*
* IF THE K-TH ELEMENT OF IRN OR THE K-TH ELEMENT OF ICN IS
* NOT AN INTEGER BETWEEN 1 AND N THEN SET MSG TO -5 AND ABORT.
*
          DO 10 K = 1,NPAIRS
              IF (IRN(K).LT.1 .OR. IRN(K).GT.N .OR. ICN(K).LT.1 .OR.
     +            ICN(K).GT.N) THEN
                  WRITE (IPR,9040) K,IRN(K),K,ICN(K)
                  MSG = -5
                  RETURN

              END IF

   10     CONTINUE
*
* GENERATE THE SPARSITY PATTERN FOR THE LOWER
* TRIANGULAR PART OF HESSIAN.
*
          DO 20 K = 1,NPAIRS
              I = IRN(K)
              J = ICN(K)
              IRN(K) = MAX(I,J)
              ICN(K) = MIN(I,J)
   20     CONTINUE
*
* IF HSNFLG = 0 AND THE K-TH DIAGONAL ELEMENT IS NOT IN THE
* SPARSITY PATTERN THEN ABORT.
*
          I = 0
          DO 30 K = 1,N
              IWA(K) = 0
   30     CONTINUE
          DO 40 K = 1,NPAIRS
              IF (IRN(K).EQ.ICN(K)) IWA(IRN(K)) = 1
   40     CONTINUE
          DO 50 K = 1,N
              IF (IWA(K).NE.1) THEN
                  WRITE (IPR,9050) K
                  MSG = -6
                  RETURN

              END IF

   50     CONTINUE
*
* SORT THE DATA STRUCTURE BY COLUMNS.
*
          CALL SRTDAT(N,NPAIRS,IRN,ICN,JPNTR,IWA)
*
*     COMPRESS THE DATA AND DETERMINE THE NUMBER OF NONZERO
*     ELEMENTS IN THE LOWER TRIANGULAR PART OF HESSIAN.
*
          DO 60 I = 1,N
              IWA(I) = 0
   60     CONTINUE
          NZ = 0
          DO 80 J = 1,N
              K = NZ
              DO 70 JP = JPNTR(J),JPNTR(J+1) - 1
                  IR = IRN(JP)
                  IF (IWA(IR).NE.J) THEN
                      NZ = NZ + 1
                      IRN(NZ) = IR
                      ICN(NZ) = J
                      IWA(IR) = J
                  END IF

   70         CONTINUE
              JPNTR(J) = K + 1
   80     CONTINUE
          JPNTR(N+1) = NZ + 1
*
      END IF
*
* CHECK METHOD USED
*
      IF (METHOD.NE.0) METHOD = 1
*
* CHECK GRADIENT FLAG
*
      IF (GRDFLG.NE.2 .AND. GRDFLG.NE.1) GRDFLG = 0
*
* CHECK HESSIAN FLAG
*
      IF (HSNFLG.NE.2 .AND. HSNFLG.NE.1) HSNFLG = 0
*
* CHECK MSG
*
      IF (MSG.NE.2 .AND. MSG.NE.0) MSG = 1
*
* CHECK SCALE MATRIX
*
      DO 90 I = 1,N
          IF (TYPX(I).EQ.ZERO) TYPX(I) = ONE
          IF (TYPX(I).LT.ZERO) TYPX(I) = -TYPX(I)
   90 CONTINUE
*
* SET THE LOGICAL VARIABLE SCALE
*
      SCALE = .FALSE.
      DO 100 I = 1,N
          IF (TYPX(I).NE.ONE) THEN
              SCALE = .TRUE.
              GO TO 110

          END IF

  100 CONTINUE
  110 CONTINUE
*
* CHECK MAXIMUM STEP SIZE
*
      IF (STEPMX.GT.ZERO) GO TO 130
      STPSIZ = ZERO
      DO 120 I = 1,N
          STPSIZ = STPSIZ + X(I)*X(I)/TYPX(I)*TYPX(I)
  120 CONTINUE
      STPSIZ = SQRT(STPSIZ)
      STEPMX = MAX(THOUS*STPSIZ,THOUS)
  130 CONTINUE
*
* CHECK FUNCTION SCALE
*
      IF (FSCALE.EQ.ZERO) FSCALE = ONE
      IF (FSCALE.LT.ZERO) FSCALE = -FSCALE
*
* CHECK GRADIENT TOLERANCE
*
      IF (GRADTL.LT.ZERO) GRADTL = EPS** (ONE/THREE)
*
* CHECK STEP TOLERANCE
*
      IF (STEPTL.LT.ZERO) THEN
          TEMP = EPS** (ONE/THREE)
          STEPTL = TEMP*TEMP
      END IF
*
* CHECK ITERATION LIMIT
*
      IF (ILIM.LE.0) ILIM = 150
*
* CHECK NUMBER OF DIGITS OF ACCURACY IN FUNCTION FCN
*
      IF (NDIGIT.LE.0) NDIGIT = -LOG10(EPS)
      IF (TEN** (-NDIGIT).LE.EPS) NDIGIT = -LOG10(EPS)
      RETURN
*
* ERROR EXITS AND WARNINGS
*
 9000 FORMAT (' STCHKI    ILLEGAL DIMENSION N=',I10)
 9010 FORMAT (' STCHKI    ILLEGAL LENGTH OF LIRN',I10,' OR LICN=',I10)
 9020 FORMAT (' STCHKI    ILLEGAL LENGTH OF INTEGER WORKSPACE'/,
     +       ' STCHKI    IWRK=',I10,' OR REAL WORKSPACE WRK=',I10)
 9030 FORMAT (' STCHKI    ILLEGAL NUMBER OF NONZEROS NZ=',I10)
 9040 FORMAT (' STCHKI    ILLEGAL ROW OR COLUMN INDEX'/,
     +       ' STCHKI    IRN( ',I6,' )=',I6,2X,' ICN( ',I6,' )=',I5)
 9050 FORMAT (' STCHKI    DIAGONAL ELEMENT',I6,' IS NOT IN THE',
     +       ' SPARSITY PATTERN'/,
     +       ' STCHKI    THE FINITE-DIFFERENCE HESSIAN APPROXIMATION',
     +       ' REQUIRE'/,
     +       ' STCHKI    THAT DIAGONAL ELEMENTS BE IN THE SPARSITY',
     +       ' PATTERN')
      END


      SUBROUTINE STCHKS(N,XPLS,FPLS,GPLS,X,ITNCNT,ICSCMX,ITRMCD,GRADTL,
     +                  STEPTL,FSCALE,ILIM,IRETCD,MXTAKE,RGX,IPR,MSG)
*
* PURPOSE:
* -------
*
* THIS ROUTINE CHECKS THE STOPPING CRITERIA AND TERMINATES THE
* OPTIMIZATION ALGORITHM IF ANY OF THE FOLLOWING IS SATISFIED:
*
* 1. THE SCALED GRADIENT IS LESS THAN GRADTL
* 2. THE LENGTH OF THE CURRENT STEP IS LESS THAN STEPTL
* 3. THE CURRENT GLOBAL STEP FAILED TO LOCATE A POINT LOWER THAN XPLS
* 4. THE ITERATION LIMIT HAS BEEN EXCEEDED
* 5. FIVE CONSECUTIVE STEPS OF LENGTH STEPMX HAVE BEEN TAKEN
*
* PARAMETERS:
* ----------
*
* N            --> DIMENSION OF PROBLEM
* XPLS         --> CURRENT ITERATE
* FPLS         --> FUNCTION VALUE AT XPLS
* GPLS         --> GRADIENT AT XPLS
* X            --> OLD ITERATE
* ITNCNT       --> CURRENT ITERATION NUMBER
* ICSCMX      <--> NUMBER CONSECUTIVE STEPS .GE. STEPMX
*                  (RETAIN VALUE BETWEEN SUCCESSIVE CALLS)
* ITRMCD      <--  TERMINATION CODE
* GRADTL       --> TOLERANCE AT WHICH RELATIVE GRADIENT CONSIDERED
*                  CLOSE ENOUGH TO ZERO TO TERMINATE ALGORITHM
* STEPTL       --> RELATIVE STEP SIZE AT WHICH SUCCESSIVE ITERATES
*                  CONSIDERED CLOSE ENOUGH TO TERMINATE ALGORITHM
* FSCALE       --> ESTIMATE OF SCALE OF OBJECTIVE FUNCTION
* ILIM         --> MAXIMUM NUMBER OF ALLOWABLE ITERATIONS
* IRETCD       --> RETURN CODE FROM SUBROUTINE STLSCH
* MXTAKE       --> BOOLEAN FLAG INDICATING STEP OF MAXIMUM LENGTH
* RGX         <--  SCALED GRADIENT
* IPR          --> USED DEVICE TO WHICH TO SEND OUTPUT
* MSG          --> CONTROL OUTPUT
*                  MSG = 0 MEANS NO INFORMATION IS OUTPUT
*                  MSG >= 1 MEANS INFORMATION ABOUT STOPPING CONDITIONS
*                  IS OUTPUT
*
      INTEGER          N,ITNCNT,ICSCMX,ITRMCD,ILIM,IRETCD,IPR,MSG
      REAL             XPLS(N),FPLS,GPLS(N),X(N),GRADTL,STEPTL
      REAL             FSCALE,RGX
*
*  LOCAL VARIABLES
*
      INTEGER          I
      REAL             D,RELGRD,RSX,RELSTP,ZERO,ONE
      LOGICAL          MXTAKE
      INTRINSIC        ABS,MAX
      DATA             ZERO,ONE/0.0E+0,1.0E+0/
*
      ITRMCD = 0
*
* LAST GLOBAL STEP FAILED TO LOCATE A POINT LOWER THAN X
*
      IF (IRETCD.EQ.1) THEN
          ITRMCD = 3
          IF (MSG.GE.1) WRITE (IPR,9020)
          RETURN

      END IF
*
* COMPUTE SCALED GRADIENT AND CHECK WHETHER IT IS WITHIN TOLERANCE
*
      D = MAX(ABS(FPLS),FSCALE)
*     D=ONE
      RGX = ZERO
      DO 10 I = 1,N
          RELGRD = ABS(GPLS(I))*MAX(ABS(XPLS(I)),ONE)/D
          RGX = MAX(RGX,RELGRD)
   10 CONTINUE
      IF (RGX.LE.GRADTL) THEN
          ITRMCD = 1
          IF (MSG.GE.1) WRITE (IPR,9000)
          RETURN

      END IF
*
      IF (ITNCNT.EQ.0) RETURN
*
* FIND DIRECTION IN WHICH RELATIVE STEPSIZE MAXIMUM
* CHECK WHETHER WITHIN TOLERANCE
*
      RSX = 0.0
      DO 20 I = 1,N
          RELSTP = ABS(XPLS(I)-X(I))/MAX(ABS(XPLS(I)),ONE)
          RSX = MAX(RSX,RELSTP)
   20 CONTINUE
      IF (RSX.LE.STEPTL) THEN
          ITRMCD = 2
          IF (MSG.GE.1) WRITE (IPR,9010)
          RETURN

      END IF
*
* CHECK ITERATION LIMIT
*
      IF (ITNCNT.GE.ILIM) THEN
          ITRMCD = 4
          IF (MSG.GE.1) WRITE (IPR,9030)
          RETURN

      END IF
*
* CHECK NUMBER OF CONSECUTIVE STEPS \ STEPMX
*
      IF (MXTAKE) THEN
          ICSCMX = ICSCMX + 1
          IF (ICSCMX.GE.5) THEN
              ITRMCD = 5
              IF (MSG.GE.1) WRITE (IPR,9040)
              RETURN

          END IF

      ELSE
          ICSCMX = 0
          RETURN

      END IF
*
 9000 FORMAT ('  STCHKS    RELATIVE GRADIENT CLOSE TO ZERO'/
     +       '  STCHKS    CURRENT ITERATE IS PROBABLY SOLUTION')
 9010 FORMAT ('  STCHKS    SUCCESSIVE ITERATES WITHIN TOLERANCE'/
     +       '  STCHKS    CURRENT ITERATE IS PROBABLY SOLUTION')
 9020 FORMAT ('  STCHKS    LAST GLOBAL STEP FAILED TO LOCATE A POINT',
     +       ' LOWER THAN X',/
     +       '  STCHKS    EITHER X IS AN APPROXIMATE LOCAL MINIMUM',
     +       ' OF THE FUNCTION',/
     +       '  STCHKS    THE FUNCTION IS TOO NON-LINEAR FOR THIS',
     +       ' ALGORITHM',/'  STCHKS    OR STEPTL IS TOO LARGE')
 9030 FORMAT ('  STCHKS    ITERATION LIMIT EXCEEDED',
     +       /'  STCHKS    ALGORITHM FAILED')
 9040 FORMAT ('  STCHKS    MAXIMUM STEP SIZE EXCEEDED 5',
     +       ' CONSECUTIVE TIMES',/
     +       '  STCHKS    EITHER THE FUNCTION IS UNBOUNDED BELOW',
     +       /'  STCHKS    BECOMES ASYMPTOTIC TO A FINITE VALUE',
     +       ' FROM ABOVE IN SOME DIRECTION',
     +       /'  STCHKS    OR STEPMX IS TOO SMALL')
      END


      SUBROUTINE STCZ3P(A1,A2,A3,XP,NZEROS)
*
* PURPOSE:
* --------
*
* THIS ROUTINE COMPUTES THE ROOTS OF A THIRD DEGREE
* POLYNOMIAL OF THE FORM : X**3 + A1*X**2 + A2*X + A3.
*
* PARAMETERS:
* ----------
*
*   A1, A2, A3  ---> COEFFICIENTS OF THE CUBIC POLYNOMIAL
*           XP <---  ZEROS OF THE CUBIC POLYNOMIAL
*       NZEROS <---  NUMBER OF ZEROS FOUND
*
*
      INTEGER          NZEROS
      REAL             A1,A2,A3,XP(3)
*
*  LOCAL VARIABLES
*
      REAL             CST1,CST2,Q,R,D,S,T,THETA,PI,CONST
      REAL             ZERO,HALF,ONE,TWO,THREE,FOUR,NINE
      REAL             TSEVEN,FFOUR
      INTRINSIC        ACOS,COS,SQRT
      PARAMETER        (PI=3.141592741012573E+0)
      DATA             ZERO,HALF,ONE,TWO,THREE,FOUR,NINE,TSEVEN,
     +                 FFOUR/0.0E+0,5.0E-1,1.0E+0,2.0E+0,3.0E+0,4.0E+0,
     +                 9.0E+0,27.0E+0,54.0E+0/
*
      NZEROS = 0
      CST1 = ONE/THREE
      CST2 = CST1*A1
      Q = (THREE*A2-A1**TWO)/NINE
      R = (NINE*A1*A2-TSEVEN*A3-TWO*A1**THREE)/FFOUR
      D = Q**THREE + R**TWO
      IF (D.GT.ZERO) THEN
          S = R + SQRT(D)
          IF (S.LT.ZERO) THEN
              S = - ((-S)**CST1)

          ELSE
              S = S**CST1
          END IF

          T = R - SQRT(D)
          IF (T.LT.ZERO) THEN
              T = - ((-T)**CST1)

          ELSE
              T = T**CST1
          END IF
*
* COMPUTE THE ONLY REAL ZERO
*
          NZEROS = 1
          XP(1) = S + T - CST2

      ELSE IF (D.EQ.ZERO) THEN
          IF (R.LT.ZERO) THEN
              S = - ((-R)**CST1)

          ELSE
              S = R**CST1
          END IF

          T = S
*
* COMPUTE THE TWO REAL ZEROS
*
          NZEROS = 2
          XP(1) = S + T - CST2
          XP(2) = -HALF* (S+T)

      ELSE
          THETA = ACOS(R/SQRT(-Q**THREE))
          CONST = TWO*SQRT(-Q)
          THETA = CST1*THETA
*
* COMPUTE THE THREE REAL ZEROS
*
          NZEROS = 3
          XP(1) = CONST*COS(THETA) - CST2
          XP(2) = CONST*COS(THETA+TWO*PI*CST1) - CST2
          XP(3) = CONST*COS(THETA+FOUR*PI*CST1) - CST2
      END IF

      RETURN

      END


      SUBROUTINE STDFLT(N,TYPX,FSCALE,GRADTL,STEPTL,ILIM,STEPMX,IPR,
     +                  METHOD,GRDFLG,HSNFLG,NDIGIT,INFORM,MSG)
*
* PURPOSE:
*--------
*
* THIS ROUTINE SETS THE DEFAULT VALUES OF THE PACKAGE.
*
*   N      -->  A POSITIVE INTEGER VARIABLE SPECIFYING THE NUMBER OF
*               VARIABLES IN THE PROBLEM
*   TYPX   <--  AN ARRAY OF LENGTH N IN WHICH THE TYPICAL SIZE OF THE
*               COMPONENTS OF X ARE SPECIFIED
*   FSCALE <--  A POSITIVE REAL NUMBER ESTIMATING THE MAGNITUDE
*               OF F(X) NEAR THE MINIMIZER
*   GRADTL <--  POSITIVE SCALAR GIVING THE TOLERANCE AT WHICH THE
*               SCALED GRADIENT OF F(X) IS CONSIDERED CLOSE ENOUGH TO
*               ZERO TO TERMINATE THE ALGORITHM
*   STEPTL <--  A POSITIVE SCALAR PROVIDING THE MINIMUM ALLOWABLE
*               RELATIVE STEP LENGTH
*   ILIM   <--  POSITIVE INTEGER SPECIFYING THE MAXIMUM ITERATIONS TO BE
*               PERFORMED BEFORE THE PROGRAM IS TERMINATED
*   STEPMX <--  A POSITIVE SCALAR PROVIDING THE MAXIMUM ALLOWABLE SCALED
*               STEP LENGTH
*   IPR    <--  THE UNIT ON WHICH THE ROUTINE OUTPUTS INFORMATION
*   METHOD <--  AN INTEGER FLAG DESIGNATING WHICH METHOD TO USE
*               METHOD = 0  :  USE NEWTON'S METHOD
*               METHOD = 1  :  USE THE TENSOR METHOD
*   GRDFLG <--  INTEGER FLAG DESIGNATING WHETHER OR NOT ANALYTIC HESSIAN
*               HAS BEEN SUPPLIED BY THE USER
*               GRDFLG = 0 : NO ANALYTIC GRADIENT SUPPLIED
*               GRDFLG = 1 : ANALYTIC GRADIENT SUPPLIED (WILL BE CHECKED
*                            AGAINST FINITE DIFFERENCE GRADIENT)
*               GRDFLG = 2 : ANALYTIC GRADIENT SUPPLIED (WILL NOT BE
*                            CHECKED AGAINST FINITE DIFFERENCE GRADIENT)
*   HSNFLG <--  INTEGER FLAG DESIGNATING WHETHER OR NOT ANALYTIC HESSIAN
*               HAS BEEN SUPPLIED BY THE USER
*               HSNFLG = 0 : NO ANALYTIC HESSIAN SUPPLIED
*               HSNFLG = 1 : ANALYTIC HESSIAN SUPPLIED (WILL BE CHECKED
*                            AGAINST FINITE DIFFERENCE HESSIAN)
*               HSNFLG = 2 : ANALYTIC HESSIAN SUPPLIED (WILL NOT BE
*                            CHECKED AGAINST FINITE DIFFERENCE HESSIAN)
*   NDIGIT <--  INTEGER ESTIMATING THE NUMBER OF ACCURATE DIGITS ON THE
*               OBJECTIVE FUNCTION F(X)
*   INFORM <--  AN INTEGER VARIABLE.  IF IT IS SET TO 1, THE USER MUST
*               OBTAIN HESS TIMES VECTOR AND RE-ENTER WITH INFORM
*               UNCHANGED.  THE RESULT OF HESS TIMES VECTOR MUST BE
*               STORED IN VECTOR.  THE DEFAULT VALUE OF INFORM IS 0,
*               MEANING THAT HESS TIMES VECTOR IS COMPUTED BY THE
*               PACKAGE
*   MSG    <--  AN INTEGER VARIABLE THAT THE USER MAY SET ON INPUT TO
*               INHIBIT CERTAIN AUTOMATIC CHECKS OR OVERRIDE CERTAIN
*               DEFAULT CHARACTERISTICS OF THE PACKAGE
*
      INTEGER          N,ILIM,IPR,METHOD,GRDFLG,HSNFLG,NDIGIT,INFORM,MSG
      REAL             TYPX(N),FSCALE,GRADTL,STEPTL,STEPMX
*
*  LOCAL VARIABLES
*
      INTEGER          I
      REAL             EPS,TEMP,ZERO,ONE,THREE
      REAL             R1MACH
      INTRINSIC        LOG10
      DATA             ZERO,ONE,THREE/0.0E+0,1.0E+0,3.0E+0/
*
      EPS = R1MACH(4)
      METHOD = 1
      FSCALE = ONE
      GRDFLG = 0
      HSNFLG = 0
      DO 10 I = 1,N
          TYPX(I) = ONE
   10 CONTINUE
      TEMP = EPS** (ONE/THREE)
      GRADTL = TEMP
      STEPTL = TEMP*TEMP
      NDIGIT = -LOG10(EPS)
*
*     SET ACTUAL DFAULT VALUE OF STEPMX IN STCHKI
*
      STEPMX = ZERO
      ILIM = 500
      IPR = 6
      MSG = 1
      INFORM = 0
      RETURN

      END


      SUBROUTINE STDRUO(N,X,NPAIRS,IRN,LIRN,ICN,LICN,FCN,UGR,USH,TYPX,
     +                  FSCALE,GRADTL,STEPTL,ILIM,STEPMX,IPR,METHOD,
     +                  GRDFLG,HSNFLG,NDIGIT,MSG,XPLS,FPLS,GPLS,HESS,G,
     +                  S,D,DN,E,XD,BV,LISTP,NGRP,IPNTR,JPNTR,IWA,LIWRK,
     +                  LWRK,TERMCD,VECTOR,INFORM)
*
* PURPOSE:
* -------
*
* THIS ROUTINE IS THE DRIVER FOR SOLVING LARGE, SPARSE UNCONSTRAINED
* OPTIMIZATION PROBLEMS USING TENSOR METHODS.
*
* PARAMETERS:
* ----------
*
*   N       --> A POSITIVE INTEGER VARIABLE SPECIFYING THE NUMBER OF
*               VARIABLES IN THE PROBLEM
*   X       --> AN ARRAY OF LENGTH N THAT CONTAINS AN INITIAL
*               ESTIMATE OF THE MINIMIZER
*   NPAIRS  --> AN INTEGER VARIABLE THAT MUST BE SET BY THE USER TO
*               THE NUMBER OF NONZEROS STORED IN THE LOWER OR UPPER
*               HALF OF THE HESSIAN MATRIX
*   IRN     --> AN INTEGER ARRAY OF LENGTH LIRN.  ON ENTRY, IT MUST
*               HOLD THE ROW INDEX OF EACH NONZERO STORED IN THE
*               LOWER OR UPPER HALF OF THE HESSIAN MATRIX
*   LIRN    --> AN INTEGER VARIABLE THAT MUST BE SET BY THE USER TO
*               THE LENGTH OF ARRAY IRN.  LIRN NEED NOT BE AS LARGE
*               AS LICN; NORMALLY IT NEED NOT BE VERY MUCH GREATER
*               THAN NPAIRS
*   ICN     --> AN INTEGER ARRAY OF LENGTH LICN.  ON ENTRY, IT MUST
*               HOLD THE COLUMN INDEX OF THE NONZEROS STORED IN THE
*               LOWER OR UPPER HALF OF THE HESSIAN MATRIX
*   LICN    --> AN INTEGER VARIABLE THAT MUST BE SET BY THE USER TO THE
*               LENGTH OF THE HESSIAN ARRAY HESS AND ICN.  LICN SHOULD
*               ORDINARILY BE 2 TO 4 TIMES AS LARGE AS NPAIRS
*   FCN     --> THE NAME OF A USER SUPPLIED SUBROUTINE THAT EVALUATES
*               THE FUNCTION F AT AN ARBITRARY VECTOR X.  THE SUBROUTINE
*               MUST BE DECLARED EXTERNAL IN THE USER'S CALLING PROGRAM
*               AND MUST CONFORM TO
*                              CALL FCN(N, X, F)
*   UGR     --> THE NAME OF A USER SUPPLIED SUBROUTINE THAT RETURNS IN
*               THE VALUE OF THE GRADIENT. UGR MUST BE DECLARED EXTERNAL
*               IN THE USER'S CALLING PROGRAM AND MUST CONFORM TO THE
*               USAGE
*                              CALL UGR(N, X, G)
*               IF NO ANALYTIC GRADIENT IS SUPPLIED (GRDFLG = 0), THE
*               USER MUST USE THE DUMMY NAME STDUGR
*   USH     --> THE NAME OF A USER SUPPLIED SUBROUTINE THAT RETURNS
*               IN HESS THE VALUE OF THE HESSIAN AT THE CURRENT POINT X.
*               USH MUST BE DECLARED EXTERNAL IN THE USER'S CALLING
*               PROGRAM AND MUST CONFORM TO THE USAGE
*                         CALL USH(N,X,NPAIRS,LICN,HESS,IRN,ICN)
*               ONLY THE LOWER OR UPPER TRIANGULAR PART AND THE DIAGONAL
*               OF HESS SHOULD BE GIVEN, WITH THEIR CORRESPONDING ROW
*               AND COLUMN INDICES.  IF NO ANALYTIC GRADIENT IS SUPPLIED
*               (HSNFLG = 0), THE USER MUST USE THE DUMMY NAME STDUSH
*   TYPX   -->  AN ARRAY OF LENGTH N IN WHICH THE TYPICAL SIZE OF THE
*               COMPONENTS OF X ARE SPECIFIED
*   FSCALE -->  A POSITIVE REAL NUMBER ESTIMATING THE MAGNITUDE
*               OF F(X) NEAR THE MINIMIZER
*   GRADTL -->  POSITIVE SCALAR GIVING THE TOLERANCE AT WHICH THE
*               SCALED GRADIENT OF F(X) IS CONSIDERED CLOSE ENOUGH TO
*               ZERO TO TERMINATE THE ALGORITHM
*   STEPTL -->  A POSITIVE SCALAR PROVIDING THE MINIMUM ALLOWABLE
*               RELATIVE STEP LENGTH
*   ILIM   -->  POSITIVE INTEGER SPECIFYING THE MAXIMUM ITERATIONS
*               TO BE PERFORMED BEFORE THE PROGRAM IS TERMINATED
*   STEPMX -->  A POSITIVE SCALAR PROVIDING THE MAXIMUM ALLOWABLE
*               SCALED STEP LENGTH
*   IPR    -->  THE UNIT ON WHICH THE ROUTINE OUTPUTS INFORMATION
*   METHOD -->  AN INTEGER FLAG DESIGNATING WHICH METHOD TO USE
*               METHOD = 0 :  USE NEWTON'S METHOD
*               METHOD = 1 :  USE THE TENSOR METHOD
*   GRDFLG -->  INTEGER FLAG DESIGNATING WHETHER OR NOT ANALYTIC
*               HESSIAN HAS BEEN SUPPLIED BY THE USER
*               GRDFLG = 0 : NO ANALYTIC GRADIENT SUPPLIED
*               GRDFLG = 1 : ANALYTIC GRADIENT SUPPLIED (WILL BE CHECKED
*                            AGAINST FINITE DIFFERENCE GRADIENT)
*               GRDFLG = 2 : ANALYTIC GRADIENT SUPPLIED (WILL NOT BE
*                            CHECKED AGAINST FINITE DIFFERENCE GRADIENT)
*   HSNFLG -->  INTEGER FLAG DESIGNATING WHETHER OR NOT ANALYTIC
*               HESSIAN HAS BEEN SUPPLIED BY THE USER
*               HSNFLG = 0 : NO ANALYTIC HESSIAN SUPPLIED
*               HSNFLG = 1 : ANALYTIC HESSIAN SUPPLIED (WILL BE CHECKED
*                            AGAINST FINITE DIFFERENCE HESSIAN)
*               HSNFLG = 2 : ANALYTIC HESSIAN SUPPLIED (WILL NOT BE
*                            CHECKED AGAINST FINITE DIFFERENCE HESSIAN)
*   NDIGIT -->  INTEGER ESTIMATING THE NUMBER OF ACCURATE DIGITS IN THE
*               OBJECTIVE FUNCTION F(X)
*   MSG    <--> AN INTEGER VARIABLE THAT THE USER MAY SET ON INPUT TO
*               INHIBIT CERTAIN AUTOMATIC CHECKS OR OVERRIDE CERTAIN
*               DEFAULT CHARACTERISTICS OF THE PACKAGE
*   XPLS   <--  AN ARRAY OF LENGTH N CONTAINING THE BEST APPROXIMATION
*               TO THE MINIMIZER UPON RETURN. (IF THE ALGORITHM HAS NOT
*               CONVERGED, THE LAST ITERATE IS RETURNED)
*   FPLS   <--  A SCALAR VARIABLE THAT CONTAINS THE FUNCTION VALUE AT
*               THE FINAL ITERATE XPLS
*   GPLS   <--  AN ARRAY OF LENGTH N CONTAINING THE GRADIENT VALUE
*               AT XPLS
*   HESS   <--  AN ARRAY THAT IS USED TO STORE THE HESSIAN MATRIX AT
*               EACH ITERATION.  IT NEEDS TO BE AT LEAST OF DIMENSION
*               LICN. ON EXIT, HESS CONTAINS THE HESSIAN VALUE AT THE
*               MINIMIZER
*   G,S,D,DN,E,XD,BV,LISTP,NGRP,IPNTR,JPNTR,IWA --> WORKSPACE
*   LIWRK  -->  AN INTEGER VARIABLE. IT MUST BE SET BY THE USER TO THE
*               LENGTH OF ARRAY IWRK AND IS NOT ALTERED BY THE PACKAGE
*               (SEE SUBROUTINE STUMCD (STUMCS))
*   LWRK   -->  AN INTEGER VARIABLE. IT MUST BE SET BY THE USER TO THE
*               LENGTH OF ARRAY WRK AND IS NOT ALTERED BY THE PACKAGE
*               (SEE SUBROUTINE STUMCD (STUMCS))
*   TERMCD <--  AN INTEGER THAT SPECIFIES THE REASON WHY THE ALGORITHM
*               HAS TERMINATED
*   VECTOR<-->  AN ARRAY OF LENGTH N.  IT NEED NOT BE SET BY THE USER
*               ON ENTRY.  IF INFORM IS SET TO 1, A RE-ENTRY MUST BE
*               MADE WITH VECTOR SET TO HESS TIMES VECTOR (SEE INFORM)
*   INFORM<-->  AN INTEGER VARIABLE.  IF IT IS SET TO 1, THE USER MUST
*               OBTAIN HESS TIMES VECTOR AND RE-ENTER WITH INFORM
*               UNCHANGED. THE RESULT OF HESS TIMES VECTOR MUST BE
*               STORED IN VECTOR. THE DEFAULT VALUE OF INFORM IS 0,
*               MEANING THAT HESS TIMES VECTOR IS COMPUTED BY THE
*               PACKAGE
*
* BLAS SUBROUTINES: DCOPY,DDOT,DNRM2
*
      INTEGER          N,NPAIRS,LIRN,LICN,ILIM,IPR,METHOD,GRDFLG,HSNFLG
      INTEGER          NDIGIT,MSG,LIWRK,LWRK,TERMCD,INFORM
      INTEGER          IRN(LIRN),ICN(LICN),LISTP(N),NGRP(N),IPNTR(N+1)
      INTEGER          JPNTR(N+1),IWA(*)
      REAL             X(N),TYPX(N),FSCALE,GRADTL,STEPTL,STEPMX
      REAL             XPLS(N),FPLS,GPLS(N),HESS(LICN),G(N)
      REAL             S(N),D(N),DN(N),E(N),XD(N),BV(N),VECTOR(N)
      LOGICAL          SCALE
*
*  LOCAL VARIABLES
*
      INTEGER          ITNNO,ICSCMX,I,MAXGRP,MINGRP,IFCNT,IGCNT,IHCNT
      INTEGER          IFLAG,IRETCD,NZ,LIWA
      REAL             RNF,ANALTL,F,GNORM,FP,SUM1,SUM2
      REAL             ALMBDA,OCENT,ONE,TWO,THREE,TEN
      REAL             EPS,GAMMA,ALPHA,BETA,FN,RGX
      REAL             SDOT,SNRM2,R1MACH
      LOGICAL          MXTAKE,DSCENT,FCALL,CHECKH
      COMMON           /ALMB/ALMBDA
      COMMON           /COUNT/IFCNT,IGCNT,IHCNT
      EXTERNAL         FCN,UGR,USH
      EXTERNAL         SCOPY,SNRM2,SDOT
      DATA             OCENT,ONE,TWO,THREE,TEN/1.0E-2,1.0E+0,2.0E+0,
     +                 3.0E+0,10.0E+0/
*
* IF INFORM = 2 THEN USER MUST SUPPLY VECTOR = HESS * S
*
      IF (INFORM.EQ.2) GO TO 160
*
* COMPUTE MACHINE EPSILON
*
      EPS = R1MACH(4)
*
* CHECK USER'S INPUT DATA
*
      CALL STCHKI(N,NPAIRS,NZ,X,IRN,LIRN,ICN,LICN,LIWRK,LWRK,SCALE,TYPX,
     +            FSCALE,GRADTL,STEPTL,ILIM,NDIGIT,EPS,METHOD,GRDFLG,
     +            HSNFLG,STEPMX,IWA,LIWA,JPNTR,MSG,IPR)
      IF (MSG.LT.0) RETURN
*
* PRINT OUT USED PARAMETERS
*
      IF (MSG.GE.1) THEN
          WRITE (IPR,9000) GRDFLG
          WRITE (IPR,9010) HSNFLG
          WRITE (IPR,9020) METHOD
          WRITE (IPR,9030) ILIM
          WRITE (IPR,9040) EPS
          WRITE (IPR,9050) STEPTL
          WRITE (IPR,9060) GRADTL
          WRITE (IPR,9070) STEPMX
      END IF
*
* INITIALIZATION
*
      ITNNO = 0
      ICSCMX = 0
      TERMCD = 0
      IFCNT = 0
      IGCNT = 0
      IHCNT = 0
*
* SCALE X
*
      IF (SCALE) THEN
          DO 10 I = 1,N
              X(I) = X(I)/TYPX(I)
   10     CONTINUE
      END IF
*
* INITIAL ITERATION
*
      RNF = MAX(TEN** (-NDIGIT),EPS)
      ANALTL = MAX(OCENT,SQRT(RNF))
*
* UNSCALE X AND COMPUTE F AND G
*
      IF (SCALE) THEN
          DO 20 I = 1,N
              VECTOR(I) = X(I)*TYPX(I)
   20     CONTINUE

      ELSE
          DO 30 I = 1,N
              VECTOR(I) = X(I)
   30     CONTINUE
      END IF

      IFCNT = IFCNT + 1
      CALL FCN(N,VECTOR,F)
      IGCNT = IGCNT + 1
      IF (GRDFLG.EQ.1) THEN
          CALL UGR(N,VECTOR,G)
          CALL STCHKG(N,VECTOR,FCN,F,G,TYPX,RNF,ANALTL,XD,MSG,IPR)
          IF (MSG.LT.0) RETURN

      ELSE IF (GRDFLG.EQ.2) THEN
          CALL UGR(N,VECTOR,G)

      ELSE
          CALL STFDGR(N,VECTOR,FCN,F,RNF,G)
      END IF
*
* SCALE G
*
      IF (SCALE) THEN
          DO 40 I = 1,N
              G(I) = G(I)*TYPX(I)
   40     CONTINUE
      END IF
*
      GNORM = SNRM2(N,G,1)
*
* PRINT OUT INITIAL ITERATION
*
      IF (MSG.GE.1) THEN
          CALL STRSLT(N,VECTOR,F,G,RGX,ITNNO,TERMCD,IPR)
      END IF
*
* TEST WHETHER INITIAL GUESS SATISFIES THE STOPPING CRITERIA
*
      IF (GNORM.LE.GRADTL) THEN
          TERMCD = 1
          RETURN

      END IF
*
* ITERATION 1
*
      ITNNO = ITNNO + 1
*
* COMPUTE HESSIAN
*
      IHCNT = IHCNT + 1
      IF (HSNFLG.EQ.1) THEN
          CALL USH(N,VECTOR,NPAIRS,LICN,HESS,IRN,ICN)
          FCALL = .TRUE.
          CHECKH = .TRUE.
          CALL STCHKH(N,VECTOR,NPAIRS,NZ,IRN,LIRN,ICN,LICN,FCN,UGR,
     +                SCALE,TYPX,GRDFLG,F,G,RNF,ANALTL,FCALL,CHECKH,
     +                LISTP,NGRP,IPNTR,JPNTR,IWA,LIWA,D,XD,E,HESS,IPR,
     +                MSG)
          IF (MSG.LT.0) RETURN
          FCALL = .FALSE.

      ELSE IF (HSNFLG.EQ.2) THEN
          CALL USH(N,VECTOR,NPAIRS,LICN,HESS,IRN,ICN)
          CHECKH = .FALSE.
          CALL STCHKH(N,VECTOR,NPAIRS,NZ,IRN,LIRN,ICN,LICN,FCN,UGR,
     +                SCALE,TYPX,GRDFLG,F,G,RNF,ANALTL,FCALL,CHECKH,
     +                LISTP,NGRP,IPNTR,JPNTR,IWA,LIWA,D,XD,E,HESS,IPR,
     +                MSG)
          IF (MSG.LT.0) RETURN

      ELSE
          FCALL = .TRUE.
          CALL STFDHS(N,NZ,VECTOR,IRN,ICN,G,RNF,GRDFLG,FCN,UGR,SCALE,
     +                TYPX,FCALL,LISTP,NGRP,IPNTR,JPNTR,IWA,LIWA,D,XD,E,
     +                MAXGRP,MINGRP,HESS)
          FCALL = .FALSE.
      END IF
*
* SCALE HESS
*
      IF (SCALE) THEN
          DO 50 I = 1,NZ
              HESS(I) = HESS(I)*TYPX(IRN(I))*TYPX(ICN(I))
   50     CONTINUE
      END IF
*
* SOLVE FOR NEWTON STEP D
*
      DO 60 I = 1,N
          D(I) = -G(I)
   60 CONTINUE
*
* SPARSE CHOLESKY DECOMPOSITION FOR HESS (HESS = L D LT)
*
      CALL STMA27(N,NZ,IRN,ICN,HESS,LICN,IWA,LIWA,D,XD,1,.TRUE.,EPS,
     +            IFLAG)
*
* COOMPUTE NEWTON STEP USING A LINE SEARCH
*
      CALL STLSCH(N,X,F,G,D,XPLS,FPLS,MXTAKE,IRETCD,STEPMX,STEPTL,SCALE,
     +            TYPX,FCN,VECTOR)
*
* UPDATE GRADIENT AT XPLS
*
* UNSCALE XPLS AND COMPUTE GPLS
*
      IF (SCALE) THEN
          DO 70 I = 1,N
              VECTOR(I) = XPLS(I)*TYPX(I)
   70     CONTINUE

      ELSE
          DO 80 I = 1,N
              VECTOR(I) = XPLS(I)
   80     CONTINUE
      END IF

      IGCNT = IGCNT + 1
      IF (GRDFLG.EQ.0) THEN
          CALL STFDGR(N,VECTOR,FCN,FPLS,RNF,GPLS)

      ELSE
          CALL UGR(N,VECTOR,GPLS)
      END IF
*
* SCALE GPLS
*
      IF (SCALE) THEN
          DO 90 I = 1,N
              GPLS(I) = GPLS(I)*TYPX(I)
   90     CONTINUE
      END IF
*
* CHECK STOPPING CONDITIONS
*
      CALL STCHKS(N,XPLS,FPLS,GPLS,X,ITNNO,ICSCMX,TERMCD,GRADTL,STEPTL,
     +            FSCALE,ILIM,IRETCD,MXTAKE,RGX,IPR,MSG)
*
* IF TERMCD > 0 THEN STOPPING CONDITIONS SATISFIED
*
      IF (TERMCD.GT.0) GO TO 300
*
* UPDATE X, F AND S FOR TENSOR MODEL
*
      FP = F
      F = FPLS
      DO 100 I = 1,N
          S(I) = X(I) - XPLS(I)
          X(I) = XPLS(I)
  100 CONTINUE
*
*     IF MSG >= 2 THEN PRINT OUT EACH ITERATION
*
      IF (MSG.GE.2) THEN
          CALL STRSLT(N,XPLS,FPLS,GPLS,RGX,ITNNO,TERMCD,IPR)
      END IF
*
*     ITERATION > 1
*
* UNSCALE X AND COMPUTE HESS
*
  110 CONTINUE
*
      IF (SCALE) THEN
          DO 120 I = 1,N
              VECTOR(I) = X(I)*TYPX(I)
  120     CONTINUE

      ELSE
          DO 130 I = 1,N
              VECTOR(I) = X(I)
  130     CONTINUE
      END IF

      IHCNT = IHCNT + 1
      IF (HSNFLG.EQ.0) THEN
          CALL STFDHS(N,NZ,VECTOR,IRN,ICN,GPLS,RNF,GRDFLG,FCN,UGR,SCALE,
     +                TYPX,FCALL,LISTP,NGRP,IPNTR,JPNTR,IWA,LIWA,D,XD,E,
     +                MAXGRP,MINGRP,HESS)

      ELSE
          CALL USH(N,VECTOR,NZ,LICN,HESS,IRN,ICN)
      END IF
*
* SCALE HESS
*
      IF (SCALE) THEN
          DO 140 I = 1,NZ
              HESS(I) = HESS(I)*TYPX(IRN(I))*TYPX(ICN(I))
  140     CONTINUE
      END IF
*
* IF METHOD = 0 THEN USE NEWTON STEP ONLY
*
      IF (METHOD.EQ.0) THEN
*
* COMPUTE NEWTON STEP
*
          DO 150 I = 1,N
              D(I) = -GPLS(I)
  150     CONTINUE
*
* CHOLESKY DECOMPOSITION FOR HESS
*
          CALL STMA27(N,NZ,IRN,ICN,HESS,LICN,IWA,LIWA,D,XD,1,.TRUE.,EPS,
     +                IFLAG)
          GO TO 190
*
      END IF
*
      IF (INFORM.EQ.1) THEN
          INFORM = 2
          CALL SCOPY(N,S(1),1,VECTOR(1),1)
          RETURN

      ELSE
          CALL STHMUV(N,NZ,IRN,ICN,HESS,S,VECTOR)
          GO TO 170

      END IF
*
  160 INFORM = 1
  170 CONTINUE
*
* FORM TENSOR MODEL
*
      CALL STFTSM(N,F,FP,GPLS,G,S,ALPHA,BETA,VECTOR,D)
*
      SUM1 = SDOT(N,S(1),1,S(1),1)
      SUM2 = SDOT(N,S(1),1,D(1),1)
*
      DO 180 I = 1,N
          BV(I) = (THREE*SUM1*D(I)-TWO*S(I)*SUM2)/ (THREE*SUM1**3)
  180 CONTINUE
      GAMMA = BETA/SUM1**4
*
* SOLVE TENSOR MODEL AND COMPUTE TENSOR STEP
*
      CALL STMSLV(N,D,S,GPLS,E,VECTOR,DN,BV,GAMMA,NZ,IRN,ICN,HESS,LICN,
     +            IWA,LIWA,XD,EPS,DSCENT,IFLAG)
*
      IF (.NOT.DSCENT) THEN
          CALL SCOPY(N,DN(1),1,D(1),1)
      END IF
*
  190 ITNNO = ITNNO + 1
      CALL SCOPY(N,GPLS(1),1,G(1),1)
*
* COMPUTE TENSOR (OR NEWTON) STEP USING A LINE SEARCH
*
      CALL STLSCH(N,X,F,G,D,XPLS,FPLS,MXTAKE,IRETCD,STEPMX,STEPTL,SCALE,
     +            TYPX,FCN,VECTOR)
*
      IF (METHOD.EQ.0) GO TO 260
      IF (ALMBDA.EQ.ONE) GO TO 240
*
      IF (DSCENT) THEN
*
* FULL TENSOR STEP IS A DESCENT DIRECTION BUT DOES NOT
* PROVIDE ENOUGH DECREASE IN THE OBJECTIVE FUNCTION.
* CALCULATE NEWTON STEP ONLY IF HESSIAN IS INDEFINITE;
* OTHERWISE NEWTON STEP WAS ALREADY COMPUTED AS PART
* OF THE TENSOR STEP COMPUTATION
*
          IF (IFLAG.EQ.3) THEN
              DO 200 I = 1,N
                  DN(I) = -E(I)
  200         CONTINUE
              GO TO 230

          END IF
          CALL SCOPY(N,G(1),1,DN(1),1)
          CALL STMA27(N,NZ,IRN,ICN,HESS,LICN,IWA,LIWA,DN,XD,3,.TRUE.,
     +                EPS,IFLAG)
          IF (IFLAG.EQ.30) THEN
              DO 210 I = 1,N
                  DN(I) = -E(I)
  210         CONTINUE

          ELSE
              DO 220 I = 1,N
                  DN(I) = -DN(I)
  220         CONTINUE
          END IF

  230     CONTINUE
*
* CALCULATE A STEP IN THE NEWTON DIRECTION
*
          CALL STLSCH(N,X,F,G,DN,XD,FN,MXTAKE,IRETCD,STEPMX,STEPTL,
     +                SCALE,TYPX,FCN,VECTOR)
*
* COMPARE TENSOR STEP TO NEWTON STEP
* IF NEWTON STEP IS BETTER, SET NEXT ITERATE TO NEW NEWTON POINT
*
          IF (FN.LT.FPLS) THEN
              FPLS = FN
              CALL SCOPY(N,DN(1),1,D(1),1)
              CALL SCOPY(N,XD(1),1,XPLS(1),1)
          END IF

      END IF

  240 CONTINUE
      DO 250 I = 1,N
          D(I) = XPLS(I) - X(I)
  250 CONTINUE
*
  260 CONTINUE
*
* UNSCALE XPLS, AND COMPUTE FPLS AND GPLS
*
      IF (SCALE) THEN
          DO 270 I = 1,N
              VECTOR(I) = XPLS(I)*TYPX(I)
  270     CONTINUE

      ELSE
          DO 280 I = 1,N
              VECTOR(I) = XPLS(I)
  280     CONTINUE
      END IF

      IGCNT = IGCNT + 1
      IF (GRDFLG.EQ.0) THEN
          CALL STFDGR(N,VECTOR,FCN,FPLS,RNF,GPLS)

      ELSE
          CALL UGR(N,VECTOR,GPLS)
      END IF
*
* SCALE GPLS
*
      IF (SCALE) THEN
          DO 290 I = 1,N
              GPLS(I) = GPLS(I)*TYPX(I)
  290     CONTINUE
      END IF
*
* CHECK STOPPING CONDITIONS
*
      CALL STCHKS(N,XPLS,FPLS,GPLS,X,ITNNO,ICSCMX,TERMCD,GRADTL,STEPTL,
     +            FSCALE,ILIM,IRETCD,MXTAKE,RGX,IPR,MSG)
*
* IF TERMCD = 0 THEN EXECUTION CONTINUES
*
      IF (TERMCD.EQ.0) GO TO 330
*
  300 CONTINUE
*
* TRANSFORM XPLS BACK TO ORIGINAL SPACE
*
      IF (SCALE) THEN
          DO 310 I = 1,N
              XPLS(I) = XPLS(I)*TYPX(I)
  310     CONTINUE
      END IF
*
*  IF MSG >= 1 THEN PRINT OUT FINAL ITERATION
*
      IF (MSG.GE.1) THEN
          CALL STRSLT(N,XPLS,FPLS,GPLS,RGX,ITNNO,TERMCD,IPR)
      END IF
*
* UPDATE THE HESSIAN
*
      IHCNT = IHCNT + 1
      IF (HSNFLG.EQ.0) THEN
          CALL STFDHS(N,NZ,VECTOR,IRN,ICN,GPLS,RNF,GRDFLG,FCN,UGR,SCALE,
     +                TYPX,FCALL,LISTP,NGRP,IPNTR,JPNTR,IWA,LIWA,D,XD,E,
     +                MAXGRP,MINGRP,HESS)

      ELSE
          CALL USH(N,XPLS,NZ,LICN,HESS,IRN,ICN)
      END IF
*
* SCALE HESS
*
      IF (SCALE) THEN
          DO 320 I = 1,NZ
              HESS(I) = HESS(I)*TYPX(IRN(I))*TYPX(ICN(I))
  320     CONTINUE
      END IF

      RETURN
*
* UPDATE INFORMATION AT THE CURRENT POINT
*
  330 CONTINUE
      CALL SCOPY(N,XPLS(1),1,X(1),1)
      DO 340 I = 1,N
          S(I) = -D(I)
  340 CONTINUE
*
* IF ITERATION LIMIT EXCEEDED THEN RETURN
*
      IF (ITNNO.GT.ILIM) GO TO 300
*
* IF MSG >= 2 THEN PRINT OUT EACH ITERATION
*
      IF (MSG.GE.2) THEN
          CALL STRSLT(N,XPLS,FPLS,GPLS,RGX,ITNNO,TERMCD,IPR)
      END IF
*
* UPDATE F
*
      FP = F
      F = FPLS
*
*  PERFORM NEXT ITERATION
*
      GO TO 110
*
*     END OF ITERATION > 1
*
*
 9000 FORMAT ('  STDRUO      GRADIENT FLAG      = ',I1)
 9010 FORMAT ('  STDRUO      HESSIAN FLAG       = ',I1)
 9020 FORMAT ('  STDRUO      METHOD             = ',I1)
 9030 FORMAT ('  STDRUO      ITERATION LIMIT    =',I5)
 9040 FORMAT ('  STDRUO      MACHINE EPSILON    = ',E20.13)
 9050 FORMAT ('  STDRUO      STEP TOLERANCE     = ',E20.13)
 9060 FORMAT ('  STDRUO      GRADIENT TOLERANCE = ',E20.13)
 9070 FORMAT ('  STDRUO      MAXIMUM STEP SIZE  = ',E20.13)
      END


      SUBROUTINE STDUGR(N,X,G)
*
* PURPOSE:
* -------
*
* THIS IS A DUMMY ROUTINE TO PREVENT UNSATISFIED EXTERNAL DIAGNOSTIC
* WHEN SPECIFIC ANALYTIC GRADIENT IS NOT SUPPLIED.
*
      INTEGER          N
      REAL             X(N),G(N)

      RETURN

      END

      SUBROUTINE STDUSH(N,X,NZ,LICN,HESS,IRN,ICN)
*
* PURPOSE:
* -------
*
* THIS IS A DUMMY ROUTINE TO PREVENT UNSATISFIED EXTERNAL DIAGNOSTIC
* WHEN SPECIFIC ANALYTIC HESSIAN IS NOT SUPPLIED.
*
      INTEGER          N,NZ,LICN
      INTEGER          IRN(NZ),ICN(LICN)
      REAL             X(N),HESS(LICN)

      RETURN

      END


      SUBROUTINE STFDGR(N,XPLS,FCN,FPLS,RNOISE,FDG)
*
* PURPOSE
* -------
*
* THIS ROUTINE FINDS A FORWARD FINITE-DIFFERENCE APPROXIMATION "FDG"
* TO THE FIRST DERIVATIVE OF THE FUNCTION DEFINED BY THE SUBPROGRAM
* "FCN" EVALUATED AT THE NEW ITERATE "XPLS".
*
* PARAMETERS:
* ----------
* N            --> DIMENSION OF PROBLEM
* XPLS         --> NEW ITERATE
* FCN          --> NAME OF SUBROUTINE THAT EVALUATES THE
*                  OPTIMIZATION FUNCTION
* FPLS         --> FUNCTION VALUE AT NEW ITERATE
* RNOISE       --> RELATIVE NOISE IN FCN
* FDG          <-- FINITE-DIFFERENCE APPROXIMATION OF GRADIENT AT XPLS
*
      INTEGER          N
      REAL             XPLS(N),FPLS,RNOISE,FDG(N)
*
*  LOCAL VARIABLES
*
      INTEGER          J
      REAL             XTMPJ,STEPSZ,FHAT,ONE
      EXTERNAL         FCN
      INTRINSIC        ABS,MAX,SQRT
      DATA             ONE/1.0E+0/
*
* FIND DERIVATIVE OF FCN WITH RESPECT TO XPLS(J), J=1,N
*
      DO 10 J = 1,N
          XTMPJ = XPLS(J)
          STEPSZ = SQRT(RNOISE)*MAX(ABS(XPLS(J)),ONE)
          XPLS(J) = XTMPJ + STEPSZ
          CALL FCN(N,XPLS,FHAT)
          XPLS(J) = XTMPJ
          FDG(J) = (FHAT-FPLS)/STEPSZ
   10 CONTINUE
      RETURN

      END


      SUBROUTINE STFDHS(N,NZ,X,IRN,ICN,G,RNF,GRDFLG,FCN,UGR,SCALE,TYPX,
     +                  FCALL,LISTP,NGRP,IPNTR,JPNTR,IWA,LIWA,FHESD,XD,
     +                  ETA,MAXGRP,MINGRP,HESS)
*
* PURPOSE:
* -------
*
* THIS ROUTINE FINDS A FORWARD FINITE-DIFFERENCE APPROXIMATION "HESS"
* TO THE SECOND DERIVATIVE (HESSIAN) OF THE FUNCTION DEFINED BY THE
* SUBPROGRAM "FCN" EVALUATED AT THE NEW ITERATE "XPLS".
*
* PARAMETERS:
* ----------
*
* N            --> DIMENSION OF PROBLEM
* NZ           --> NUMBER OF NONZEROS IN THE LOWER TRIANGULAR PART
*                  OF THE HESSIAN MATRIX
* X            --> CURRENT ITERATE
* IRN          --> ROW INDEX OF THE NONZERO ELEMENTS IN THE LOWER
*                  TRIANGULAR PART OF THE HESSIAN
* ICN          --> COLUMN INDEX OF THE NONZERO ELEMENTS IN THE LOWER
*                  TRIANGULAR PART OF THE HESSIAN
* G            --> GRADIENT VALUE AT X
* RNF          --> RELATIVE NOISE IN OPTIMIZATION FUNCTION FCN
* GRDFLG       --> =1 IF ANALYTIC GRADIENT SUPPLIED
* FCN          --> NAME OF A USER SUPPLIED SUBROUTINE THAT EVALUATES
*                  THE FUNCTION F AT AN ARBITRARY VECTOR X
* UGR          --> NAME OF A USER SUPPLIED SUBROUTINE THAT RETURNS IN
*                  THE VALUE OF THE GRADIENT AT AN ARBITRARY VECTOR X
* SCALE        --> LOGICAL VARIABLE INDICATING WHETHER OR NOT SCALING
*                  OF THE VARIABLES IS PERFORMED
* TYPX         --> AN ARRAY OF LENGTH N IN WHICH THE TYPICAL SIZE OF THE
*                  COMPONENTS OF X ARE SPECIFIED
* FCALL        --> LOGICAL FLAG. IF THE HESSIAN MATRIX IS EVALUATED FOR
*                  THE FIRST TIME, THEN FCALL IS SET TO TRUE; OTHERWISE
*                  IT IS SET TO FALSE
* LISTP,NGRP,IPNTR,JPNTR,IWA  -->  WORKSPACE
*                  (SEE SUBROUTINE DSSM FOR DETAILS)
* LIWA         --> LENGTH OF IWA ARRAY
* FHESD,XD,ETA --> WORKSPACE
* MAXGRP,MINGRP<-- SEE SUBROUTINE DSSM FOR DETAILS
* HESS         <-- FINITE-DIFFERENCE HESSIAN ON EXIT
*
*
      INTEGER          N,NZ,GRDFLG,LIWA,MAXGRP,MINGRP
      INTEGER          IRN(NZ),ICN(NZ),LISTP(N),NGRP(N),IPNTR(N+1)
      INTEGER          JPNTR(N+1),IWA(LIWA)
      REAL             X(N),G(N),TYPX(N),RNF,FHESD(N)
      REAL             XD(N),ETA(N),HESS(NZ)
      LOGICAL          SCALE
*
*  LOCAL VARIABLES
*
      INTEGER          JP,I,INFO,J,METHOD,NUMGRP
      REAL             FD,ONE
      LOGICAL          FCALL
      EXTERNAL         FCN,UGR
      INTRINSIC        ABS,MAX,SQRT
      DATA             ONE/1.0E+0/
*
      METHOD = 1
*
*     CALL DSM ONLY IF IT IS THE FIRST TIME
*
      IF (FCALL) THEN
          CALL DSSM(N,NZ,IRN,ICN,METHOD,LISTP,NGRP,MAXGRP,MINGRP,INFO,
     +              IPNTR,JPNTR,IWA,LIWA)

      ELSE
          CALL SETR(N,N,IRN,JPNTR,ICN,IPNTR,IWA)
      END IF
*
* UNSCALE G
*
      IF (SCALE) THEN
          DO 10 I = 1,N
              G(I) = G(I)/TYPX(I)
   10     CONTINUE
      END IF
*
*  APPROXIMATE THE HESSIAN MATRIX
*
      DO 40 NUMGRP = 1,MAXGRP
          DO 20 J = 1,N
              ETA(J) = SQRT(RNF)*MAX(ABS(X(J)),ONE)
              XD(J) = X(J)
              IF (NGRP(J).EQ.NUMGRP) XD(J) = X(J) + ETA(J)
   20     CONTINUE
          IF (GRDFLG.EQ.0) THEN
              CALL FCN(N,XD,FD)
              CALL STFDGR(N,XD,FCN,FD,RNF,FHESD)

          ELSE
              CALL UGR(N,XD,FHESD)
          END IF

          DO 30 I = 1,N
              FHESD(I) = FHESD(I) - G(I)
   30     CONTINUE
          CALL FDHS(N,IRN,JPNTR,ICN,IPNTR,LISTP,NGRP,MAXGRP,NUMGRP,ETA,
     +              FHESD,HESS,IWA)
   40 CONTINUE
      DO 60 J = 1,N
          DO 50 JP = JPNTR(J),JPNTR(J+1) - 1
              ICN(JP) = J
   50     CONTINUE
   60 CONTINUE
*
* SCALE G
*
      IF (SCALE) THEN
          DO 70 I = 1,N
              G(I) = G(I)*TYPX(I)
   70     CONTINUE
      END IF
*
      END



      SUBROUTINE STFTSM(N,F,FP,G,GP,S,ALPHA,BETA,SH,A)
*
* PURPOSE:
* -------
*
* THIS ROUTINE FORMS THE TENSOR MODEL.
*
* PARAMETERS:
* ----------
*
*   N       --> DIMENSION OF PROBLEM
*   F       --> CURRENT FUNCTION VALUE
*   FP      --> PREVIOUS FUNCTION VALUE
*   G       --> CURRENT GRADIENT
*   GP      --> PREVIOUS GRADIENT
*   S       --> STEP TO PREVIOUS POINT
*   ALPHA   <-- SCALAR TO FORM 3RD ORDER TERM OF TENSOR MODEL
*   BETA    <-- SCALAR TO FORM 4TH ORDER TERM OF TENSOR MODEL
*   SH      <-- HESSIAN MATRIX TIMES S (SEE SUBROUTINE STHMUV)
*   A       <-- A=2*(GP-G-SH-S*BETA/(6*(S-TRANS*S)))
*
* BLAS SUBROUTINES: DDOT
*
      INTEGER          N
      REAL             F,FP,G(N),GP(N),S(N),ALPHA,BETA,SH(N),A(N)
*
*  LOCAL VARIABLES
*
      INTEGER          I
      REAL             GS,GPS,SHS,B1,B2,STS
      REAL             HALF,TWO,SIX,TFOUR,STWO
      REAL             SDOT
      EXTERNAL         SDOT
      DATA             HALF,TWO,SIX,TFOUR,STWO/5.0E-1,2.0E+0,6.0E+0,
     +                 24.0E+0,72.0E+0/
*
      GS = SDOT(N,G(1),1,S(1),1)
      GPS = SDOT(N,GP(1),1,S(1),1)
      SHS = SDOT(N,SH(1),1,S(1),1)
      B1 = GPS - GS - SHS
      B2 = FP - F - GS - HALF*SHS
      ALPHA = TFOUR*B2 - SIX*B1
      BETA = TFOUR*B1 - STWO*B2
*
*     COMPUTE A
*
      STS = SDOT(N,S(1),1,S(1),1)
      DO 10 I = 1,N
          A(I) = TWO* (GP(I)-G(I)-SH(I)-S(I)*BETA/ (SIX*STS))
   10 CONTINUE
      RETURN

      END

      SUBROUTINE STHMUV(N,NZ,IRN,ICN,HESS,S,SH)
*
* PURPOSE:
* -------
*
* THIS ROUTINE COMPUTES SH = HESS * S.
*
* PARAMETERS:
* ----------
*   N       --> A POSITIVE INTEGER VARIABLE SPECIFYING THE NUMBER OF
*               VARIABLES IN THE PROBLEM
*   NZ      --> NUMBER OF NONZEROS STORED IN THE LOWER HALF OF
*               THE HESSIAN MATRIX
*   IRN     --> AN INTEGER ARRAY OF LENGTH LIRN.  ON ENTRY, IT MUST
*               HOLD THE ROW INDEX OF EACH NONZERO STORED IN THE LOWER
*               HALF OF THE HESSIAN MATRIX
*   ICN     --> AN INTEGER ARRAY OF LENGTH LICN.  ON ENTRY, IT MUST
*               HOLD THE COLUMN INDEX OF THE NONZEROS STORED IN LOWER
*               HALF OF THE HESSIAN MATRIX
*   HESS    --> HESSIAN MATRIX AT CURRENT ITERATE
*   S       --> STEP TO PREVIOUS POINT
*   SH      <-- HESS * S ON EXIT
*
*
      INTEGER          N,NZ
      INTEGER          IRN(NZ),ICN(NZ)
      REAL             HESS(NZ),S(N),SH(N)
*
*  LOCAL VARIABLES
*
      INTEGER          I,II,JJ
      REAL             ZERO
      DATA             ZERO/0.0E0/
*
      DO 10 I = 1,N
          SH(I) = ZERO
   10 CONTINUE
      DO 20 I = 1,NZ
          II = IRN(I)
          JJ = ICN(I)
          SH(II) = SH(II) + HESS(I)*S(JJ)
          IF (II.NE.JJ) THEN
              SH(JJ) = SH(JJ) + HESS(I)*S(II)
          END IF

   20 CONTINUE
      RETURN

      END


      SUBROUTINE STLSCH(N,X,F,G,P,XPLS,FPLS,MXTAKE,IRETCD,STEPMX,STEPTL,
     +                  SCALE,TYPX,FCN,W2)
*
* PURPOSE:
* -------
*
*  THIS ROUTINE FIND A NEXT ITERATE BY A LINE SEARCH.
*  THIS IS THE ALPHA CONDITION ONLY LINE SEARCH.
*
* PARAMETERS:
* ----------
* N            --> DIMENSION OF PROBLEM
* X            --> OLD ITERATE
* F            --> FUNCTION VALUE AT OLD ITERATE
* G            --> GRADIENT AT OLD ITERATE
* P            --> NEWTON OR TENSOR DIRECTION
* XPLS         <-- NEW ITERATE
* FPLS         <-- FUNCTION VALUE AT NEW ITERATE
* MXTAKE       <-- BOOLEAN FLAG INDICATING STEP OF MAXIMUM LENGTH USED
* IRETCD       <-- RETURN CODE
* STEPMX       --> MAXIMUM ALLOWABLE STEP SIZE
* STEPTL       --> RELATIVE STEP SIZE AT WHICH SUCCESSIVE ITERATES
*                  CONSIDERED CLOSE ENOUGH TO TERMINATE ALGORITHM
* SCALE        --> LOGICAL VARIABLE INDICATING WHETHER OR NOT SCALING
*                  OF THE VARIABLES IS PERFORMED
* TYPX         --> DIAGONAL SCALING MATRIX FOR X
* FCN          --> NAME OF SUBROUTINE TO EVALUATE OPTIMIZATION FUNCTION
* W2           --> WORKING SPACE
*
* BLAS SUBROUTINES: DDOT,DSCAL
*
      INTEGER          N,IRETCD
      REAL             X(N),F,G(N),P(N),XPLS(N),FPLS,STEPMX
      REAL             STEPTL,TYPX(N),W2(N)
      LOGICAL          SCALE
*
*  LOCAL VARIABLES
*
      INTEGER          I,K
      INTEGER          IFCNT,IGCNT,IHCNT
      REAL             TMP,SLN,SCL,SLP,RLN
      REAL             TEMP,TEMP1,TEMP2,ALMBMN,ALMBDA
      REAL             TLMBDA,T1,T2,T3,PLMBDA
      REAL             A,B,DISC,PFPLS,ZERO,TENTH
      REAL             HALF,Z99,ONE,TWO,THREE,ALPHA
      REAL             SDOT
      LOGICAL          MXTAKE
      COMMON           /COUNT/IFCNT,IGCNT,IHCNT
      COMMON           /ALMB/ALMBDA
      EXTERNAL         FCN,SSCAL,SDOT
      INTRINSIC        ABS,MAX,SQRT
      DATA             ZERO,TENTH,HALF,Z99,ONE,TWO,THREE,ALPHA/0.0E+0,
     +                 1.0E-1,5.0E-1,0.99E+0,1.0E+0,2.0E+0,3.0E+0,
     +                 1.0E-4/
*
      MXTAKE = .FALSE.
      IRETCD = 2
*$    WRITE(IPR,954)
*$    WRITE(IPR,955) (P(I),I=1,N)
      TMP = ZERO
      DO 10 I = 1,N
          TMP = TMP + P(I)*P(I)
   10 CONTINUE
      SLN = SQRT(TMP)
      IF (SLN.LE.STEPMX) GO TO 20
*
* STEP LONGER THAN MAXIMUM ALLOWED
*
      SCL = STEPMX/SLN
      CALL SSCAL(N,SCL,P(1),1)
      SLN = STEPMX
*$     WRITE(IPR,954)
*$     WRITE(IPR,955) (P(I),I=1,N)
   20 CONTINUE
      SLP = SDOT(N,G(1),1,P(1),1)
      RLN = ZERO
      DO 30 I = 1,N
          TEMP = ONE
          TEMP1 = ABS(X(I))
          TEMP2 = MAX(TEMP1,TEMP)
          TEMP1 = ABS(P(I))
          RLN = MAX(RLN,TEMP1/TEMP2)
   30 CONTINUE
      ALMBMN = STEPTL/RLN
      ALMBDA = ONE
*$    WRITE(IPR,952) SLN,SLP,RMNLMB,STEPMX,STEPTL
*
* LOOP
* CHECK IF NEW ITERATE SATISFACTORY.  GENERATE NEW LAMBDA IF NECESSARY.
*
   40 CONTINUE
      IF (IRETCD.LT.2) THEN
          RETURN

      END IF

      DO 50 I = 1,N
          XPLS(I) = X(I) + ALMBDA*P(I)
   50 CONTINUE
      IFCNT = IFCNT + 1
      IF (SCALE) THEN
          DO 60 K = 1,N
              W2(K) = XPLS(K)*TYPX(K)
   60     CONTINUE
          CALL FCN(N,W2,FPLS)

      ELSE
          CALL FCN(N,XPLS,FPLS)
      END IF
*$    WRITE(IPR,956) ALMBDA
*$    WRITE(IPR,951)
*$    WRITE(IPR,955) (XPLS(I),I=1,N)
*$    WRITE(IPR,953) FPLS
      IF (FPLS.GT.F+SLP*ALPHA*ALMBDA) GO TO 70
*     IF(FPLS.LE. F+SLP*1.E-4*ALMBDA)
*     THEN
*
* SOLUTION FOUND
*
      IRETCD = 0
      IF (ALMBDA.EQ.TENTH .AND. SLN.GT.Z99*STEPMX) MXTAKE = .TRUE.
      GO TO 40
*
* SOLUTION NOT (YET) FOUND
*
*     ELSE
   70 IF (ALMBDA.GE.ALMBMN) GO TO 80
*       IF(ALMBDA .LT. ALMBMN)
*       THEN
*
* NO SATISFACTORY XPLS FOUND SUFFICIENTLY DISTINCT FROM X
*
      IRETCD = 1
      GO TO 40
*       ELSE
*
* CALCULATE NEW LAMBDA
*
   80 IF (ALMBDA.NE.ONE) GO TO 90
*         IF(ALMBDA.EQ.1.0)
*         THEN
*
* FIRST BACKTRACK: QUADRATIC FIT
*
      TLMBDA = -SLP/ (TWO* (FPLS-F-SLP))
      GO TO 120
*         ELSE
*
* ALL SUBSEQUENT BACKTRACKS: CUBIC FIT
*
   90 T1 = FPLS - F - ALMBDA*SLP
      T2 = PFPLS - F - PLMBDA*SLP
      T3 = ONE/ (ALMBDA-PLMBDA)
      A = T3* (T1/ (ALMBDA*ALMBDA)-T2/ (PLMBDA*PLMBDA))
      B = T3* (T2*ALMBDA/ (PLMBDA*PLMBDA)-T1*PLMBDA/ (ALMBDA*ALMBDA))
      DISC = B*B - THREE*A*SLP
      IF (DISC.LE.B*B) GO TO 100
*           IF(DISC.GT. B*B)
*           THEN
*
* ONLY ONE POSITIVE CRITICAL POINT, MUST BE MINIMUM
*
      TLMBDA = (-B+SIGN(ONE,A)*SQRT(DISC))/ (THREE*A)
      GO TO 110
*           ELSE
*
* BOTH CRITICAL POINTS POSITIVE, FIRST IS MINIMUM
*
  100 TLMBDA = (-B-SIGN(ONE,A)*SQRT(DISC))/ (THREE*A)
*           ENDIF
  110 IF (TLMBDA.GT.HALF*ALMBDA) TLMBDA = HALF*ALMBDA
*         ENDIF
  120 PLMBDA = ALMBDA
      PFPLS = FPLS
      IF (TLMBDA.GE.ALMBDA*TENTH) GO TO 130
*         IF(TLMBDA.LT.ALMBDA/TENTH)
*         THEN
      ALMBDA = ALMBDA*TENTH
      GO TO 140
*         ELSE
  130 ALMBDA = TLMBDA
*         ENDIF
*       ENDIF
*     ENDIF
  140 GO TO 40
*$951 FORMAT(' STLSCH    NEW ITERATE (XPLS)')
*$952 FORMAT(' STLSCH    SLN   =',E20.13/
*$   *       ' STLSCH    SLP   =',E20.13/
*$   *       ' STLSCH    ALMBMN=',E20.13/
*$   *       ' STLSCH    STEPMX=',E20.13/
*$   *       ' STLSCH    STEPTL=',E20.13)
*$953 FORMAT(' STLSCH    F(XPLS)=',E20.13)
*$954 FORMAT(' STLSCH    COMPUTED STEP (P)')
*$955 FORMAT(' STLSCH       ',5(E20.13,3X))
*$956 FORMAT(' STLSCH    ALMBDA=',E20.13)
      END

      SUBROUTINE STMA27(N,NZ,IRN,ICN,A,MAXA,IW,MAXIW,RHS,W,ISLV,NEWTON,
     +                  EPS,IFLAG)
*
* PURPOSE:
* --------
*
*  THIS ROUTINE SOLVES A SPARSE SYMMETRIC SYSTEM OF LINEAR EQUATIONS:
*  A * X = RHS.
*
* PARAMETERS:
* ----------
*
*   N       --> DIMENSION OF MATRIX A
*   NZ      --> NUMBER OF NONZEROS IN THE LOWER HALF OF MATRIX A
*   IRN     --> ROW INDEX OF A. IRN IS UNALTERED BY MA27
*   ICN     --> COLUMN INDEX OF A. ICN IS UNALTERED BY MA27
*   A       <-> A SYMMETRIC MATRIX OF DIMENSION N. ON EXIT, IT HOLDS
*               THE FACTORS L AND D OF THE L D L-TRANS FACTORIZATION
*   MAXA    --> MAXIMUM LENGTH OF MATRIX A
*   IW      <-- WORKSPACE OF DIMENSION MAXIW. IT IS USED TO
*               HOLD INTEGER INFORMATION ON THE FACTORS L AND D
*   RHS     <-> RIGHT HAND SIDE VECTOR OF THE EQUATIONS BEING SOLVED.
*               ON EXIT, IT HOLDS THE SOLUTION VECTOR
*   W       --> WORKSPACE OF DIMENSION N
*   ISLV    --> FLAG WITH THE FOLLOWING MEANINGS:
*               ISLV = 0 : ANALAYSE AND FACTORIZE MATRIX A
*               ISLV = 1 : ANALAYSE, FACTORIZE, AND SOLVE SYSTEMS OF
*                          EQUATIONS
*               ISLV = 2 : PERFORM A SOLVE ONLY (A HAS ALREADY BEEN
*                          FACTORIZED PREVIOUSLY)
*               ISLV = 3 : CHANGE THE NEGATIVE SIGNS OF THE EIGENVALUES
*                          TO PLUS IF ANY
*   NEWTON  --> LOGICAL PARAMETER. IT IS SET TO TRUE IF NEWTON'S METHOD
*               IS USED AND TO FALSE IF THE TENSOR METHOD IS USED
*   EPS     --> MACHINE PRECISION
*   IFLAG   <-- A VALUE OF ZERO INDICATES THAT THE SUBROUTINE HAS
*               PERFORMED SUCCESSFULLY
*
      INTEGER          N,NZ,MAXA,MAXIW,ISLV,IFLAG
      INTEGER          IRN(NZ),ICN(MAXA),IW(MAXIW)
      REAL             A(MAXA),RHS(N),W(N),EPS
      LOGICAL          NEWTON
*
*  LOCAL VARIABLES
*
      INTEGER          NEG1,NEG2,LDIAG,LP,MP,ISTIW,LIW,NSTEPS,MAXFRT
      REAL             U,TENTH
      COMMON           /MA27DD/U,LP,MP,LDIAG
      DATA             TENTH/0.1E+0/
*
      IF (ISLV.EQ.2) GO TO 20
      IF (ISLV.EQ.3) GO TO 10
      U = TENTH
      LDIAG = 0
*
* SET UP SUBDIVISION OF ARRAYS
*
      ISTIW = 5*N + 1
      LIW = MAXIW - 5*N
      IFLAG = 0
*
*  ANALYSE SPARSITY PATTERN
*
      CALL MA27A(N,NZ,IRN,ICN,IW(ISTIW),LIW,IW,IW(3*N+1),NSTEPS,IFLAG)
*
*  FACTORIZE MATRIX
*
      CALL MA27B(N,NZ,IRN,ICN,A,MAXA,IW(ISTIW),LIW,IW,NSTEPS,MAXFRT,
     +           IW(3*N+1),IFLAG)
*
* CHANGE THE NEGATIVE SIGNS OF THE EIGENVALUES TO PLUS
*
   10 CONTINUE
      IF (NEWTON .OR. IFLAG.EQ.3) THEN
          CALL DSYPRC(MAXA,LIW,A,IW(ISTIW),EPS,NEG1,NEG2)
      END IF
*
      IF (ISLV.EQ.3 .AND. (NEG1.EQ.0.AND.NEG2.EQ.0)) THEN
          IFLAG = 30
          GO TO 30

      END IF
*
   20 CONTINUE
      IF (ISLV.EQ.0) GO TO 30
*
* SOLVE THE EQUATIONS
*
      CALL MA27C(N,A,MAXA,IW(ISTIW),LIW,W,MAXFRT,RHS,IW(3*N+1),NSTEPS)
   30 RETURN

      END


      SUBROUTINE STMSLV(N,DT,S,G,W1,W2,W3,BV,GAMMA,NZ,IRN,ICN,HESS,LICN,
     +                  IWA,LIWA,WK,EPS,DSCENT,IFLAG)
*
* PURPOSE:
* -------
*
* THIS ROUTINE COMPUTES THE TENSOR STEP. IT ALSO COMPUTES THE
* NEWTON STEP IF THE TENSOR STEP IS NOT DESCENT.
*
* PARAMETERS:
* ----------
*
*   N       --> DIMENSION OF PROBLEM
*   DT      <-- TENSOR STEP ON EXIT
*   S       --> STEP TO PREVIOUS POINT
*   G       --> GRADIENT AT CURRENT ITERATE
*   W1      --> WORKSPACE ARRAY OF DIMENSION N.  IT IS USED TO HOLD
*               THE SOLUTION OF HESS W1 = G
*   W2      --> WORKSPACE ARRAY OF DIMENSION N.  IT IS USED TO HOLD
*               THE SOLUTION OF HESS W2 = S
*   W3      <-- NEWTON STEP (IF REQUIRED)
*   BV      --> (3*(S-TRANS*S)*D-2*(S-TRANS*D)*S)/(3*(S-TRANS*S)**3)
*               (SEE D IN SUBROUTINE STFTSM)
*   GAMMA   --> BETA/(S-TRANS*S)**4 (SEE BETA IN SUBROUTINE STFTSM)
*   NZ      --> NUMBER OF NONZEROS IN THE LOWER TRIANGULAR PART
*               OF THE HESSIAN MATRIX
*   IRN     --> ROW INDEX OF THE NONZEROS STORED IN THE LOWER
*               HALF OF THE HESSIAN MATRIX
*   ICN     --> COLUMN INDEX OF THE NONZEROS STORED IN THE LOWER
*               HALF OF THE HESSIAN MATRIX
*   HESS    --> HESSIAN MATRIX
*   LICN    --> LENGTH OF ARRAY HESS
*   IWA     --> WORKSPACE
*   LIWA    --> LENGTH OF ARRAY IWA
*   WK      --> WORKSPACE OF DIMENSION N
*   EPS     --> MACHINE PRECISION
*   DSCENT  <-- LOGICAL VARIABLE INDICATING WHETHER OR NOT THE TENSOR
*               STEP IS DESCENT
*   IFLAG   <-- OUTPUT PARAMETER FROM THE MA27 PACKAGE.  A VALUE OF
*               ZERO INDICATES THAT THE FACTORIZATION WAS PERFORMED
*               SUCCESSFULLY
*
* BLAS SUBROUTINES: DCOPY,DDOT
*
      INTEGER          N,NZ,LICN,LIWA,IFLAG
      INTEGER          IRN(NZ),ICN(LICN),IWA(6*N)
      REAL             DT(N),S(N),G(N),W1(N),W2(N),W3(N)
      REAL             BV(N),GAMMA,HESS(LICN),WK(N),EPS
      LOGICAL          DSCENT
*
*  LOCAL VARIABLES
*
      INTEGER          NZEROS,I
      REAL             BETA(3),THETA(3),UU,WW,VV,YY,ZZ
      REAL             AA,A1,A2,A3,AMINB,AMINT,GD
      REAL             SDOT,ZERO,HALF,ONE,OHALF,TWO,SIX
      DATA             ZERO,HALF,ONE,OHALF,TWO,SIX/0.0E0,0.5E+0,1.0E+0,
     +                 1.5E+0,2.0E+0,6.0E+0/
*
      DSCENT = .TRUE.
      CALL STMA27(N,NZ,IRN,ICN,HESS,LICN,IWA,LIWA,W1,WK,0,.FALSE.,EPS,
     +            IFLAG)
*
* SOLVE HESS W1 =  G FOR W1
*
      CALL SCOPY(N,G(1),1,W1(1),1)

      CALL STMA27(N,NZ,IRN,ICN,HESS,LICN,IWA,LIWA,W1,WK,2,.FALSE.,EPS,
     +            IFLAG)
*
* SOLVE HESS W2 = S FOR W2
*
      CALL SCOPY(N,S(1),1,W2(1),1)
      CALL STMA27(N,NZ,IRN,ICN,HESS,LICN,IWA,LIWA,W2,WK,2,.FALSE.,EPS,
     +            IFLAG)
*
* SOLVE HESS W3 =  B FOR W3
*
      CALL SCOPY(N,BV(1),1,W3(1),1)
      CALL STMA27(N,NZ,IRN,ICN,HESS,LICN,IWA,LIWA,W3,WK,2,.FALSE.,EPS,
     +            IFLAG)
*
* COMPUTE COEFFICIENTS OF THE SYSTEM OF TWO EQUATIONS
* OF THE 3RD ORDER IN 2 UNKNOWS
*
      UU = SDOT(N,S(1),1,W1(1),1)
      WW = SDOT(N,S(1),1,W2(1),1)
      VV = SDOT(N,S(1),1,W3(1),1)
      YY = SDOT(N,BV(1),1,W1(1),1)
      ZZ = SDOT(N,BV(1),1,W3(1),1)
*
* CALCULATE COEFFICIENTS OF THIRD DEGREE POLYNOMIAL
*
      AA = HALF*WW*ZZ - (ONE/SIX)*GAMMA*WW - HALF*VV**2
      A1 = -OHALF*VV/AA
      A2 = (YY*WW-UU*VV-ONE)/AA
      A3 = -UU/AA
*
* COMPUTE ZEROS OF THIRD DEGREE POLYNOMIAL
*
      CALL STCZ3P(A1,A2,A3,BETA,NZEROS)
*
      DO 10 I = 1,NZEROS
          THETA(I) = - (UU+BETA(I)+HALF*VV*BETA(I)**2+
     +               (ONE/SIX)*GAMMA*WW*BETA(I)**3)/ (WW*BETA(I))
   10 CONTINUE
*
* COMPUTE SMALLEST BETA IN ABSOLUTE VALUE
*
      AMINB = BETA(1)
      AMINT = THETA(1)
      IF (NZEROS.EQ.2) THEN
          IF (AMINB.GT.ABS(BETA(2))) THEN
              AMINB = BETA(2)
              AMINT = THETA(2)
          END IF

      ELSE IF (NZEROS.EQ.3) THEN
          IF (AMINB.GT.ABS(BETA(2))) THEN
              AMINB = BETA(2)
              AMINT = THETA(2)
          END IF

          IF (AMINB.GT.ABS(BETA(3))) THEN
              AMINB = BETA(3)
              AMINT = THETA(3)
          END IF

      END IF
*
* COMPUTE TENSOR STEP
*
      DO 20 I = 1,N
          DT(I) = -W1(I) - (ONE/TWO)*W3(I)*AMINB**2 -
     +            W2(I)*AMINB*AMINT - (ONE/SIX)*W2(I)*GAMMA*AMINB**3
   20 CONTINUE
*
* IF TENSOR STEP IS NOT A DESCENT DIRECTION THEN COMPUTE NEWTON STEP
*
      GD = SDOT(N,G(1),1,DT(1),1)
*
      IF (GD.GT.ZERO) THEN
*
* COMPUTE THE NEWTON STEP
*
          DSCENT = .FALSE.
          IF (IFLAG.EQ.3) THEN
              DO 30 I = 1,N
                  W3(I) = -W1(I)
   30         CONTINUE
              GO TO 60

          END IF
          CALL SCOPY(N,G(1),1,W3(1),1)
          CALL STMA27(N,NZ,IRN,ICN,HESS,LICN,IWA,LIWA,W3,WK,3,.TRUE.,
     +                EPS,IFLAG)
          IF (IFLAG.EQ.30) THEN
              DO 40 I = 1,N
                  W3(I) = -W1(I)
   40         CONTINUE

          ELSE
              DO 50 I = 1,N
                  W3(I) = -W3(I)
   50         CONTINUE
          END IF

      END IF
*
   60 CONTINUE
      RETURN

      END


      SUBROUTINE STRSLT(N,XPLS,FVAL,GPLS,RGX,ITN,TERMCD,IPR)
*
* PURPOSE:
* -------
*
* THIS ROUTINE PRINTS INFORMATION.
*
* PARAMETERS:
* ----------
*
*       N    --->  DIMENSION OF PROBLEM
*       XPLS --->  ITERATE TO BE PRINTED OUT
*       FVAL --->  FUNCTION VALUE AT XPLS
*       GPLS --->  GRADIENT AT XPLS
*       RGX  --->  MAXIMUM RELATIVE GRADIENT
*       ITN  --->  ITERATION NUMBER
*       IPR  --->  DEVICE TO WHICH TO SEND OUTPUT
*
*
      INTEGER          N,ITN,TERMCD,IPR
      REAL             XPLS(N),FVAL,GPLS(N),RGX
*
*  LOCAL VARIABLES
*
      INTEGER          I,IFCNT,IGCNT,IHCNT
      REAL             D,RELGRD,ZERO,ONE
      COMMON           /COUNT/IFCNT,IGCNT,IHCNT
      DATA             ZERO,ONE/0.0E0,1.0E0/
*
* FIND DIRECTION IN WHICH RELATIVE GRADIENT MAXIMUM
* CHECK WHETHER WITHIN TOLERANCE
*
      IF (ITN.EQ.0) THEN
          D = ONE
          RGX = ZERO
          DO 10 I = 1,N
              RELGRD = ABS(GPLS(I))*MAX(ABS(XPLS(I)),ONE)/D
              RGX = MAX(RGX,RELGRD)
   10     CONTINUE
      END IF

      WRITE (IPR,9000)
      WRITE (IPR,9010)
      WRITE (IPR,9020) ITN
      WRITE (IPR,9030)
      WRITE (IPR,9040) FVAL
      WRITE (IPR,9050)
      WRITE (IPR,9060) RGX
      WRITE (IPR,9010)
      WRITE (IPR,9000)
      IF (TERMCD.GT.0) THEN
          WRITE (IPR,9070) IFCNT,IGCNT,IHCNT
      END IF
*
*
      RETURN

 9000 FORMAT (' ')
 9010 FORMAT ('---------------------------------------------')
 9020 FORMAT ('  STRSLT    ITERATION K   =',I5)
 9030 FORMAT ('  STRSLT    FUNCTION AT X(K)')
 9040 FORMAT ('  STRSLT       ',E20.13)
 9050 FORMAT ('  STRSLT    SCALED GRADIENT AT X(K)')
 9060 FORMAT ('  STRSLT       ',E20.13)
 9070 FORMAT ('  STRSLT    NUMBER OF FUNCTION EVALUATIONS',I5/,
     +       '  STRSLT    NUMBER OF GRADIENT EVALUATIONS',I5/,
     +       '  STRSLT    NUMBER OF HESSIAN EVALUATIONS',I5/)
      END

      SUBROUTINE STSORT(N,NNZ,A,INDROW,INDCOL,JPNTR,IWA)
      INTEGER          N,NNZ
      INTEGER          INDROW(NNZ),INDCOL(NNZ),JPNTR(N+1),IWA(N)
      REAL             A(NNZ)
*     **********
*
*     SUBROUTINE STSORT
*
*     GIVEN THE NONZERO ELEMENTS OF AN M BY N MATRIX A IN
*     ARBITRARY ORDER AS SPECIFIED BY THEIR ROW AND COLUMN
*     INDICES, THIS SUBROUTINE PERMUTES THESE ELEMENTS SO
*     THAT THEIR COLUMN INDICES ARE IN NON-DECREASING ORDER.
*     IT ALSO PERMUTES THE CORRESPONDING A ELEMENTS.
*
*     ON INPUT IT IS ASSUMED THAT THE ELEMENTS ARE SPECIFIED IN
*
*           INDROW(K),INDCOL(K), A(K), K = 1,...,NNZ.
*
*     ON OUTPUT THE ELEMENTS ARE PERMUTED SO THAT INDCOL IS
*     IN NON-DECREASING ORDER. IN ADDITION, THE ARRAY JPNTR
*     IS SET SO THAT THE ROW INDICES FOR COLUMN J ARE
*
*           INDROW(K), K = JPNTR(J),...,JPNTR(J+1)-1.
*
*     THE SUBROUTINE STATEMENT IS
*
*       SUBROUTINE STSORT(N,NNZ,A,INDROW,INDCOL,JPNTR,IWA)
*
*     WHERE
*
*       N IS A POSITIVE INTEGER INPUT VARIABLE SET TO THE NUMBER
*         OF COLUMNS OF A.
*
*       NNZ IS A POSITIVE INTEGER INPUT VARIABLE SET TO THE NUMBER
*         OF NONZERO ELEMENTS OF A.
*
*       A IS AN ARRAY OF LENGTH NNZ. ON INPUT A CONTAINS THE
*         THE NONZEROS ELEMENTS.  ON OUTPUT A IS PERMUTED SO THAT
*         THE CORRESPONDING COLUMN INDICES OF INDCOL ARE IN
*         NON-DECREASING ORDER.
*
*       INDROW IS AN INTEGER ARRAY OF LENGTH NNZ. ON INPUT INDROW
*         MUST CONTAIN THE ROW INDICES OF THE NONZERO ELEMENTS OF A.
*         ON OUTPUT INDROW IS PERMUTED SO THAT THE CORRESPONDING
*         COLUMN INDICES OF INDCOL ARE IN NON-DECREASING ORDER.
*
*       INDCOL IS AN INTEGER ARRAY OF LENGTH NNZ. ON INPUT INDCOL
*         MUST CONTAIN THE COLUMN INDICES OF THE NONZERO ELEMENTS
*         OF A. ON OUTPUT INDCOL IS PERMUTED SO THAT THESE INDICES
*         ARE IN NON-DECREASING ORDER.
*
*       JPNTR IS AN INTEGER OUTPUT ARRAY OF LENGTH N + 1 WHICH
*         SPECIFIES THE LOCATIONS OF THE ROW INDICES IN THE OUTPUT
*         INDROW. THE ROW INDICES FOR COLUMN J ARE
*
*               INDROW(K), K = JPNTR(J),...,JPNTR(J+1)-1.
*
*         NOTE THAT JPNTR(1) IS SET TO 1 AND THAT JPNTR(N+1)-1
*         IS THEN NNZ.
*
*       IWA IS AN INTEGER WORK ARRAY OF LENGTH N.
*
*     SUBPROGRAMS CALLED
*
*       FORTRAN-SUPPLIED ... MAX
*
*     ARGONNE NATIONAL LABORATORY. MINPACK PROJECT. JULY 1983.
*     THOMAS F. COLEMAN, BURTON S. GARBOW, JORGE J. MORE'
*     MODIFIED BY ALI BOUARICHA, OCTOBER 1994.
*
*     **********
      INTEGER          I,J,K,L
      REAL             S
*
*     STORE IN ARRAY IWA THE COUNTS OF NONZEROES IN THE COLUMNS.
*
      DO 10 J = 1,N
          IWA(J) = 0
   10 CONTINUE
      DO 20 K = 1,NNZ
          IWA(INDCOL(K)) = IWA(INDCOL(K)) + 1
   20 CONTINUE
*
*     SET POINTERS TO THE START OF THE COLUMNS IN INDROW.
*
      JPNTR(1) = 1
      DO 30 J = 1,N
          JPNTR(J+1) = JPNTR(J) + IWA(J)
          IWA(J) = JPNTR(J)
   30 CONTINUE
      K = 1
*
*     BEGIN IN-PLACE SORT.
*
   40 CONTINUE
      J = INDCOL(K)
      IF (K.GE.JPNTR(J)) THEN
*
*           CURRENT ELEMENT IS IN POSITION. NOW EXAMINE THE
*           NEXT ELEMENT OR THE FIRST UN-SORTED ELEMENT IN
*           THE J-TH GROUP.
*
          K = MAX(K+1,IWA(J))

      ELSE
*
*           CURRENT ELEMENT IS NOT IN POSITION. PLACE ELEMENT
*           IN POSITION AND MAKE THE DISPLACED ELEMENT THE
*           CURRENT ELEMENT.
*
          L = IWA(J)
          IWA(J) = IWA(J) + 1
          I = INDROW(K)
          S = A(K)
          INDROW(K) = INDROW(L)
          INDCOL(K) = INDCOL(L)
          A(K) = A(L)
          INDROW(L) = I
          INDCOL(L) = J
          A(L) = S
      END IF

      IF (K.LE.NNZ) GO TO 40
      RETURN
*
*     LAST CARD OF SUBROUTINE SRTDAT.
*
      END


      SUBROUTINE STUMCS(N,X,NPAIRS,IRN,LIRN,ICN,LICN,FCN,UGR,USH,TYPX,
     +                  FSCALE,GRADTL,STEPTL,ILIM,STEPMX,IPR,METHOD,
     +                  GRDFLG,HSNFLG,NDIGIT,MSG,XPLS,FPLS,GPLS,HESS,
     +                  WRK,LWRK,IWRK,LIWRK,TERMCD,VECTOR,INFORM)
*
* PURPOSE:
* -------
*
* THIS ROUTINE PROVIDES A COMPLETE INTERFACE TO STENMIN. THE USER
* HAS FULL CONTROL OVER THE OPTIONS.
*
* PARAMETERS:
* ----------
*
*   N       --> A POSITIVE INTEGER VARIABLE SPECIFYING THE NUMBER
*               OF VARIABLES IN THE PROBLEM
*   X       --> AN ARRAY OF LENGTH N THAT CONTAINS AN INITIAL
*               ESTIMATE OF THE MINIMIZER
*   NPAIRS  --> AN INTEGER VARIABLE THAT MUST BE SET BY THE USER TO
*               THE NUMBER OF NONZEROS STORED IN THE LOWER OR UPPER
*               HALF OF THE HESSIAN MATRIX
*   IRN     --> AN INTEGER ARRAY OF LENGTH LIRN.  ON ENTRY, IT MUST
*               HOLD THE ROW INDEX OF EACH NONZERO STORED IN THE
*               LOWER OR UPPER HALF OF THE HESSIAN MATRIX
*   LIRN    --> AN INTEGER VARIABLE THAT MUST BE SET BY THE USER TO
*               THE LENGTH OF ARRAY IRN.  LIRN NEED NOT BE AS LARGE
*               AS LICN; NORMALLY IT NEED NOT BE VERY MUCH GREATER
*               THAN NPAIRS
*   ICN     --> AN INTEGER ARRAY OF LENGTH LICN.  ON ENTRY, IT MUST
*               HOLD THE COLUMN INDEX OF THE NONZEROS STORED IN THE
*               LOWER OR UPPER HALF OF THE HESSIAN MATRIX
*   LICN    --> AN INTEGER VARIABLE THAT MUST BE SET BY THE USER TO
*               THE LENGTH OF THE HESSIAN ARRAY HESS AND ICN.  LICN
*               SHOULD ORDINARILY BE 2 TO 4 TIMES AS LARGE AS NPAIRS
*   FCN     --> THE NAME OF A USER SUPPLIED SUBROUTINE THAT EVALUATES
*               THE FUNCTION F AT AN ARBITRARY VECTOR X. THE SUBROUTINE
*               MUST BE DECLARED EXTERNAL IN THE USER'S CALLING PROGRAM
*               AND MUST CONFORM TO
*                              CALL FCN(N, X, F)
*   UGR     --> THE NAME OF A USER SUPPLIED SUBROUTINE THAT RETURNS IN
*               THE VALUE OF THE GRADIENT. UGR MUST BE DECLARED EXTERNAL
*               IN THE USER'S CALLING PROGRAM AND MUST CONFORM TO THE
*               USAGE
*                              CALL UGR(N, X, G)
*               IF NO ANALYTIC GRADIENT IS SUPPLIED (GRDFLG = 0), THE
*               USER MUST USE THE DUMMY NAME STDUGR
*   USH     --> THE NAME OF A USER SUPPLIED SUBROUTINE THAT RETURNS
*               IN HESS THE VALUE OF THE HESSIAN AT THE CURRENT POINT X.
*               USH MUST BE DECLARED EXTERNAL IN THE USER'S CALLING
*               PROGRAM AND MUST CONFORM TO THE USAGE
*                         CALL USH(N,X,NPAIRS,LICN,HESS,IRN,ICN)
*               ONLY THE LOWER OR UPPER TRIANGULAR PART AND THE DIAGONAL
*               OF HESS SHOULD BE GIVEN, WITH THEIR CORRESPONDING ROW
*               AND COLUMN INDICES.  IF NO ANALYTIC GRADIENT IS SUPPLIED
*               (HSNFLG = 0), THE USER MUST USE THE DUMMY NAME STDUSH
*   TYPX   -->  AN ARRAY OF LENGTH N IN WHICH THE TYPICAL SIZE OF THE
*               COMPONENTS OF X ARE SPECIFIED
*   FSCALE -->  A POSITIVE REAL NUMBER ESTIMATING THE MAGNITUDE
*               OF F(X) NEAR THE MINIMIZER
*   GRADTL -->  POSITIVE SCALAR GIVING THE TOLERANCE AT WHICH THE
*               SCALED GRADIENT OF F(X) IS CONSIDERED CLOSE ENOUGH TO
*               ZERO TO TERMINATE THE ALGORITHM
*   STEPTL -->  A POSITIVE SCALAR PROVIDING THE MINIMUM ALLOWABLE
*               RELATIVE STEP LENGTH
*   ILIM   -->  POSITIVE INTEGER SPECIFYING THE MAXIMUM ITERATIONS TO BE
*               PERFORMED BEFORE THE PROGRAM IS TERMINATED
*   STEPMX -->  A POSITIVE SCALAR PROVIDING THE MAXIMUM ALLOWABLE SCALED
*               STEP LENGTH
*   IPR    -->  THE UNIT ON WHICH THE ROUTINE OUTPUTS INFORMATION
*   METHOD -->  AN INTEGER FLAG DESIGNATING WHICH METHOD TO USE
*               METHOD = 0 :  USE NEWTON'S METHOD
*               METHOD = 1 :  USE THE TENSOR METHOD
*   GRDFLG -->  INTEGER FLAG DESIGNATING WHETHER OR NOT ANALYTIC HESSIAN
*               HAS BEEN SUPPLIED BY THE USER
*               GRDFLG = 0 : NO ANALYTIC GRADIENT SUPPLIED
*               GRDFLG = 1 : ANALYTIC GRADIENT SUPPLIED (WILL BE CHECKED
*                            AGAINST FINITE DIFFERENCE GRADIENT)
*               GRDFLG = 2 : ANALYTIC GRADIENT SUPPLIED (WILL NOT BE
*                            CHECKED AGAINST FINITE DIFFERENCE GRADIENT)
*   HSNFLG -->  INTEGER FLAG DESIGNATING WHETHER OR NOT ANALYTIC HESSIAN
*               HAS BEEN SUPPLIED BY THE USER
*               HSNFLG = 0 : NO ANALYTIC HESSIAN SUPPLIED
*               HSNFLG = 1 : ANALYTIC HESSIAN SUPPLIED (WILL BE CHECKED
*                            AGAINST FINITE DIFFERENCE HESSIAN)
*               HSNFLG = 2 : ANALYTIC HESSIAN SUPPLIED (WILL NOT BE
*                            CHECKED AGAINST FINITE DIFFERENCE HESSIAN)
*   NDIGIT -->  INTEGER ESTIMATING THE NUMBER OF ACCURATE DIGITS IN THE
*               OBJECTIVE FUNCTION F(X)
*   MSG    <--> AN INTEGER VARIABLE THAT THE USER MAY SET ON INPUT TO
*               INHIBIT CERTAIN AUTOMATIC CHECKS OR OVERRIDE CERTAIN
*               DEFAULT CHARACTERISTICS OF THE PACKAGE
*   XPLS   <--  AN ARRAY OF LENGTH N CONTAINING THE BEST APPROXIMATION
*               TO THE MINIMIZER UPON RETURN. (IF THE ALGORITHM HAS NOT
*               CONVERGED, THE LAST ITERATE IS RETURNED)
*   FPLS   <--  A SCALAR VARIABLE THAT CONTAINS THE FUNCTION VALUE AT
*               THE FINAL ITERATE XPLS
*   GPLS   <--  AN ARRAY OF LENGTH N CONTAINING THE GRADIENT VALUE
*               AT XPLS
*   HESS   <--  AN ARRAY THAT IS USED TO STORE THE HESSIAN MATRIX AT
*               EACH ITERATION.  IT NEEDS TO BE AT LEAST OF DIMENSION
*               LICN. ON EXIT, HESS CONTAINS THE HESSIAN VALUE AT THE
*               MINIMIZER
*   WRK    -->  AN ARRAY OF LENGTH LWRK.  THIS IS USED AS WORKSPACE
*               BY THE PACKAGE.  ITS LENGTH MUST BE AT LEAST 7*N
*   LWRK   -->  AN INTEGER VARIABLE. IT MUST BE SET BY THE USER TO THE
*               LENGTH OF ARRAY WRK AND IS NOT ALTERED BY THE PACKAGE
*   IWRK   -->  AN INTEGER ARRAY OF LENGTH LIWRK.  THIS IS USED AS
*               WORKSPACE BY THE PACKAGE.  ITS LENGTH MUST BE AT LEAST
*               2*NPAIRS+12*N+2
*   LIWRK  -->  AN INTEGER VARIABLE. IT MUST BE SET BY THE USER TO THE
*               LENGTH OF ARRAY IWRK AND IS NOT ALTERED BY THE PACKAGE
*   TERMCD <--  AN INTEGER THAT SPECIFIES THE REASON WHY THE ALGORITHM
*               HAS TERMINATED
*   VECTOR<-->  AN ARRAY OF LENGTH N.  IT NEED NOT BE SET BY THE USER
*               ON ENTRY.  IF INFORM IS SET TO 1, A RE-ENTRY MUST BE
*               MADE WITH VECTOR SET TO HESS TIMES VECTOR (SEE INFORM)
*   INFORM<-->  AN INTEGER VARIABLE.  IF IT IS SET TO 1, THE USER MUST
*               OBTAIN HESS TIMES VECTOR AND RE-ENTER WITH INFORM
*               UNCHANGED.  THE RESULT OF HESS TIMES VECTOR MUST BE
*               STORED IN VECTOR.  THE DEFAULT VALUE OF INFORM IS 0,
*               MEANING THAT HESS TIMES VECTOR IS COMPUTED BY THE
*               PACKAGE
*
      INTEGER          N,NPAIRS,LIRN,LICN,ILIM,IPR,METHOD
      INTEGER          GRDFLG,HSNFLG,NDIGIT,MSG,LWRK,LIWRK,TERMCD
      INTEGER          INFORM
      INTEGER          IRN(LIRN),ICN(LICN),IWRK(LIWRK)
      REAL             X(N),TYPX(N),FSCALE,GRADTL,STEPTL,STEPMX
      REAL             XPLS(N),FPLS,GPLS(N),HESS(LICN),WRK(LWRK)
      REAL             VECTOR(N)
*
      EXTERNAL         FCN,UGR,USH
*
*  LOCAL VARIABLES
*
*     NONE
*
*
* EQUIVALENCE FOR DOUBLE PRECISION/REAL ARRAYS
*
*   EQUIVALENCE WRK(1) = G(N)
*               WRK(N+1) = S(N)
*               WRK(2*N+1) = D(N)
*               WRK(3*N+1) = DN(N)
*               WRK(4*N+1) = E(N)
*               WRK(5*N+1) = XD(N)
*               WRK(6*N+1) = BV(N)
*
* EQUIVALENCE FOR INTEGER ARRAYS
*
*   EQUIVALENCE IWRK(1) = LISTP(N)
*               IWRK(N+1) = NGRP(N)
*               IWRK(2*N+1) = IPNTR(N+1)
*               IWRK(3*N+2) = JPNTR(N+1)
*               IWRK(4*N+3) = IWA(2*NZ+8*N)
*
      CALL STDRUO(N,X,NPAIRS,IRN,LIRN,ICN,LICN,FCN,UGR,USH,TYPX,FSCALE,
     +            GRADTL,STEPTL,ILIM,STEPMX,IPR,METHOD,GRDFLG,HSNFLG,
     +            NDIGIT,MSG,XPLS,FPLS,GPLS,HESS,WRK(1),WRK(N+1),
     +            WRK(2*N+1),WRK(3*N+1),WRK(4*N+1),WRK(5*N+1),
     +            WRK(6*N+1),IWRK(1),IWRK(N+1),IWRK(2*N+1),IWRK(3*N+2),
     +            IWRK(4*N+3),LIWRK,LWRK,TERMCD,VECTOR,INFORM)

      RETURN

      END


      SUBROUTINE STUMSS(N,X,NPAIRS,IRN,LIRN,ICN,LICN,FCN,TYPX,MSG,XPLS,
     +                  FPLS,GPLS,HESS,WRK,LWRK,IWRK,LIWRK,TERMCD)
*
* PURPOSE:
* -------
*
* THIS ROUTINE PROVIDES A SIMPLE INTERFACE TO STENMIN. THE USER
* HAS NO CONTROL OVER THE OPTIONS.
*
* PARAMETERS:
* ----------
*
*   N       --> A POSITIVE INTEGER VARIABLE SPECIFYING THE NUMBER OF
*               VARIABLES IN THE PROBLEM
*   X       --> AN ARRAY OF LENGTH N THAT CONTAINS AN INITIAL
*               ESTIMATE OF THE MINIMIZER
*   NPAIRS  --> AN INTEGER VARIABLE THAT MUST BE SET BY THE USER TO
*               THE NUMBER OF NONZEROS STORED IN THE LOWER OR UPPER
*               HALF OF THE HESSIAN MATRIX
*   IRN     --> AN INTEGER ARRAY OF LENGTH LIRN.  ON ENTRY, IT MUST
*               HOLD THE ROW INDEX OF EACH NONZERO STORED IN THE LOWER
*               OR UPPER HALF OF THE HESSIAN MATRIX
*   LIRN    --> AN INTEGER VARIABLE THAT MUST BE SET BY THE USER TO
*               THE LENGTH OF ARRAY IRN.  LIRN NEED NOT BE AS LARGE
*               AS LICN; NORMALLY IT NEED NOT BE VERY MUCH GREATER
*               THAN NPAIRS
*   ICN     --> AN INTEGER ARRAY OF LENGTH LICN.  ON ENTRY, IT MUST
*               HOLD THE COLUMN INDEX OF THE NONZEROS STORED IN THE
*               LOWER OR UPPER HALF OF THE HESSIAN MATRIX.
*   LICN    --> AN INTEGER VARIABLE THAT MUST BE SET BY THE USER TO THE
*               LENGTH OF THE HESSIAN ARRAY HESS AND ICN.  LICN SHOULD
*               ORDINARILY BE 2 TO 4 TIMES AS LARGE AS NPAIRS
*   FCN     --> THE NAME OF A USER SUPPLIED SUBROUTINE THAT EVALUATES
*               THE FUNCTION F AT AN ARBITRARY VECTOR X.  THE SUBROUTINE
*               MUST BE DECLARED EXTERNAL IN THE USER'S CALLING PROGRAM
*               AND MUST CONFORM TO
*                              CALL FCN(N, X, F)
*   TYPX   -->  AN ARRAY OF LENGTH N IN WHICH THE TYPICAL SIZE OF THE
*               COMPONENTS OF X ARE SPECIFIED.  IT NEED NOT BE SET ON
*               ENTRY
*   MSG    <--> AN INTEGER VARIABLE THAT THE USER MAY SET ON INPUT TO
*               INHIBIT CERTAIN AUTOMATIC CHECKS OR OVERRIDE CERTAIN
*               DEFAULT CHARACTERISTICS OF THE PACKAGE
*   XPLS   <--  AN ARRAY OF LENGTH N CONTAINING THE BEST APPROXIMATION
*               TO THE MINIMIZER UPON RETURN. (IF THE ALGORITHM HAS NOT
*               CONVERGED, THE LAST ITERATE IS RETURNED)
*   FPLS   <--  A SCALAR VARIABLE THAT CONTAINS THE FUNCTION VALUE AT
*               THE FINAL ITERATE XPLS
*   GPLS   <--  AN ARRAY OF LENGTH N CONTAINING THE GRADIENT VALUE
*               AT XPLS
*   HESS   <--  AN ARRAY THAT IS USED TO STORE THE HESSIAN MATRIX AT
*               EACH ITERATION.  IT NEEDS TO BE AT LEAST OF DIMENSION
*               LICN.  ON EXIT, HESS CONTAINS THE HESSIAN VALUE AT THE
*               MINIMIZER
*   WRK    -->  AN ARRAY OF LENGTH LWRK.  THIS IS USED AS WORKSPACE
*               BY THE PACKAGE.  ITS LENGTH MUST BE AT LEAST 8*N
*   LWRK   -->  AN INTEGER VARIABLE. IT MUST BE SET BY THE USER TO THE
*               LENGTH OF ARRAY WRK AND IS NOT ALTERED BY THE PACKAGE
*   IWRK   -->  AN INTEGER ARRAY OF LENGTH LIWRK.  THIS IS USED AS
*               WORKSPACE BY THE PACKAGE.  ITS LENGTH MUST BE AT LEAST
*               2*NPAIRS+12*N+2
*   LIWRK  -->  AN INTEGER VARIABLE. IT MUST BE SET BY THE USER TO THE
*               LENGTH OF ARRAY IWRK AND IS NOT ALTERED BY THE PACKAGE
*   TERMCD <--  AN INTEGER THAT SPECIFIES THE REASON WHY THE ALGORITHM
*               HAS TERMINATED
*
*
      INTEGER          N,NPAIRS,LIRN,LICN
      INTEGER          MSG,LWRK,LIWRK,TERMCD
      INTEGER          IRN(LIRN),ICN(LICN),IWRK(LIWRK)
      REAL             X(N),TYPX(N),XPLS(N),FPLS,GPLS(N)
      REAL             HESS(LICN),WRK(LWRK)
*
*  LOCAL VARIABLES
*
      INTEGER          ILIM,IPR,METHOD,GRDFLG,HSNFLG,NDIGIT,INFORM
      REAL             FSCALE,GRADTL,STEPTL,STEPMX
*
      EXTERNAL         FCN,STDUGR,STDUSH
*
* EQUIVALENCE FOR DOUBLE PRECISION/REAL ARRAYS
*
*   EQUIVALENCE WRK(1) = G(N)
*               WRK(N+1) = S(N)
*               WRK(2*N+1) = D(N)
*               WRK(3*N+1) = DN(N)
*               WRK(4*N+1) = E(N)
*               WRK(5*N+1) = XD(N)
*               WRK(6*N+1) = BV(N)
*               WRK(7*N+1) = VECTOR(N)
*
* EQUIVALENCE FOR INTEGER ARRAYS
*
*   EQUIVALENCE IWRK(1) = LISTP(N)
*               IWRK(N+1) = NGRP(N)
*               IWRK(2*N+1) = IPNTR(N+1)
*               IWRK(3*N+2) = JPNTR(N+1)
*               IWRK(4*N+3) = IWA(2*NZ+8*N)
*
      CALL STDFLT(N,TYPX,FSCALE,GRADTL,STEPTL,ILIM,STEPMX,IPR,METHOD,
     +            GRDFLG,HSNFLG,NDIGIT,INFORM,MSG)
*
      CALL STDRUO(N,X,NPAIRS,IRN,LIRN,ICN,LICN,FCN,STDUGR,STDUSH,TYPX,
     +            FSCALE,GRADTL,STEPTL,ILIM,STEPMX,IPR,METHOD,GRDFLG,
     +            HSNFLG,NDIGIT,MSG,XPLS,FPLS,GPLS,HESS,WRK(1),WRK(N+1),
     +            WRK(2*N+1),WRK(3*N+1),WRK(4*N+1),WRK(5*N+1),
     +            WRK(6*N+1),IWRK(1),IWRK(N+1),IWRK(2*N+1),IWRK(3*N+2),
     +            IWRK(4*N+3),LIWRK,LWRK,TERMCD,WRK(7*N+1),INFORM)

      RETURN

      END

      SUBROUTINE DSYPRC(LA,LIW,A,IW,EPSMCH,NEG1,NEG2)
      INTEGER          LA,LIW,NEG1,NEG2
      INTEGER          IW(LIW)
      REAL             A(LA),EPSMCH
*
*  THE GILL-MURRAY-PONCELEON-SAUNDERS CODE FOR MODIFYING THE NEGATIVE
*  EIGEN-COMPONENTS OBTAINED WHEN FACTORIZING A SYMMETRIC INDEFINITE
*  MATRIX USING THE HARWELL CODE MA27. (SEE SOL 90-8, P.19-21)
*
*  NICK GOULD, 20TH JULY 1990.
*
      INTEGER          ALEN,APOS,IBLK,NBLK,IPOS,NROWS,NCOLS,J,K
      REAL             ZERO,ONE,TWO,ALPHA,BETA,GAMMA,TAU,T,C,S,E1,E2
      LOGICAL          SINGLE
      INTRINSIC        ABS,SQRT
*
*  SET DATA.
*
      PARAMETER        (ZERO=0.0E+0,ONE=1.0E+0,TWO=2.0E+0)
*
*  NEG1 AND NEG2 ARE THE NUMBER OF NEGATIVE EIGENVALUES WHICH ARISE
*  FROM NEGATIVE 1x1 AND 2x2 BLOCK PIVOTS.
*
      NEG1 = 0
      NEG2 = 0
      NBLK = ABS(IW(1))
      IPOS = 2
      APOS = 1
*
*  LOOP OVER ALL THE BLOCK PIVOTS.
*
      DO 20 IBLK = 1,NBLK
          NCOLS = IW(IPOS)
          IF (NCOLS.LT.0) THEN
              NROWS = 1
              NCOLS = -NCOLS

          ELSE
              IPOS = IPOS + 1
              NROWS = IW(IPOS)
          END IF
*
*  PROCESS THE DIAGONALS IN THIS BLOCK.
*
          ALEN = NCOLS
          SINGLE = .TRUE.
          DO 10 K = IPOS + 1,IPOS + NROWS
              IF (SINGLE) THEN
                  ALPHA = A(APOS)
                  J = IW(K)
                  SINGLE = J .GT. 0
                  IF (SINGLE) THEN
*
*  NEGATIVE 1x1 BLOCK.
*
                      IF (ALPHA.LT.ZERO) THEN
                          NEG1 = NEG1 + 1
                          A(APOS) = -ALPHA

                      ELSE
                          IF (ALPHA.GT.ONE/EPSMCH) THEN
                              NEG1 = NEG1 + 1
                              A(APOS) = ONE/EPSMCH
                          END IF

                      END IF

                  ELSE
                      BETA = A(APOS+1)
                      GAMMA = A(APOS+ALEN)
*
*  2x2 BLOCK: ( ALPHA  BETA  ) = ( C  S ) ( E1    ) ( C  S )
*             ( BETA   GAMMA )   ( S -C ) (    E2 ) ( S -C )
*
                      IF (ALPHA*GAMMA.LT.BETA**2) THEN
                          TAU = (GAMMA-ALPHA)/ (TWO*BETA)
                          T = -ONE/ (ABS(TAU)+SQRT(ONE+TAU**2))
                          IF (TAU.LT.ZERO) T = -T
                          C = ONE/ (ONE+T**2)
                          S = T*C
                          E1 = ALPHA + BETA*T
                          E2 = GAMMA - BETA*T
*
*  CHANGE E1 AND E2 TO THEIR ABSOLUTE VALUES AND THEN MULTIPLY THE
*  THREE 2 * 2 MATRICES TO GET THE MODIFIED ALPHA, BETA AND GAMMA.
*
                          IF (E1.LT.ZERO) THEN
                              NEG2 = NEG2 + 1
                              E1 = -E1
                          END IF

                          IF (E2.LT.ZERO) THEN
                              NEG2 = NEG2 + 1
                              E2 = -E2
                          END IF

                          A(APOS) = C**2*E1 + S**2*E2
                          A(APOS+1) = C*S* (E1-E2)
                          A(APOS+ALEN) = S**2*E1 + C**2*E2
                      END IF

                  END IF

              ELSE
                  SINGLE = .TRUE.
              END IF

              APOS = APOS + ALEN
              ALEN = ALEN - 1
   10     CONTINUE
          IPOS = IPOS + NCOLS + 1
   20 CONTINUE
      RETURN

      END
