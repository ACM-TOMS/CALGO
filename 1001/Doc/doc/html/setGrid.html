
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>setGrid</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-30"><meta name="DC.source" content="setGrid.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>setGrid</h1><!--introduction--><p>Essentially set grids on ROI and CD.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Example</a></li><li><a href="#4">Input Arguments</a></li><li><a href="#5">Output Arguments</a></li><li><a href="#6">More About</a></li><li><a href="#7">References</a></li><li><a href="#8">See Also</a></li><li><a href="#9">Code</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">seti = setGrid(seti)
seti = setGrid(seti,dispDepth)
</pre><h2 id="2">Description</h2><p><tt>seti = setGrid(seti)</tt> essentially sets grids on ROI and CD in <tt>seti.grid</tt> and <tt>seti.gridROI</tt> for <tt>seti.dim</tt> dimensions, <tt>seti.nCD</tt> discretization points for each dimension of CD, which has a size of <tt>[-seti.rCD,seti.rCD)^seti.dim</tt>.</p><p><tt>seti = setGrid(seti,dispDepth)</tt> does the same, but allows to control the depth of displayed messages by <tt>dispDepth</tt>.</p><p>ROI is the biggest square in 2D (and cube in 3D) in the mathematical sensible region (open ball with radius rCD/2).</p><h2 id="3">Example</h2><p><b>Example 1</b></p><pre class="language-matlab">init;
seti.dim = 2;           <span class="comment">% dimension 2</span>
seti.rCD = 0.2;         <span class="comment">% size of computational domain [-rCD,rCD)^dim</span>
seti.nCD = 256;         <span class="comment">% number of discretization points for each dimension of CD</span>
seti = setGrid(seti);
</pre><p><b>Example 2</b></p><pre class="language-matlab">init;
seti.dim = 2;           <span class="comment">% dimension 2</span>
seti.rCD = 0.2;         <span class="comment">% size of computational domain [-rCD,rCD)^dim</span>
seti.nCD = 256;         <span class="comment">% number of discretization points for each dimension of CD</span>
seti = setGrid(seti,1);
</pre><h2 id="4">Input Arguments</h2><div><ul><li>seti    :   structure array</li></ul></div><p>If input arguments are not set, default values will be used.</p><div><ul><li>seti.dim     :  dimension of the problem (2 or 3) (default: 2)</li><li>seti.nCD     :  number of discretization points for each dimension                   of computational domain (CD) (in samples)                   (default: 256).</li><li>seti.rCD     :  Size of computational domain [-rCD,rCD)^dim                   (default: 0.2) (in meters)</li></ul></div><p><b>Optional Input Argument</b></p><div><ul><li>dispDepth   : Depth of displayed messages (0: no, 1 or greater: yes).</li></ul></div><h2 id="5">Output Arguments</h2><div><ul><li>seti    :   structure array</li></ul></div><div><ul><li>seti.h          :   length of the infinitesimal element of CD.</li><li>seti.dV         :   area/volume of the infinitesimal element (pixel/voxel) of CD</li><li>seti.grid       :   grid of computational domain (CD)                       (seti.dim x seti.nCD^seti.dim)</li><li>seti.ballMask   :   mask (logical matrix of size seti.nCD x seti.nCD)                       to restrict (later) the contrast in CD                       to the mathematical sensible region.</li><li>seti.nROI       :   discretization points for each dimension                       of region of interest (ROI) (in samples)</li><li>seti.gridROI    :   grid of region of interest (ROI)                       (matrix of size seti.dim x seti.nROI^seti.dim)</li><li>seti.ROImask    :   mask (logical matrix of size seti.nCD x seti.nCD)                       to restrict (later) the contrast in CD                       to the region of interest (ROI).</li><li>seti.ballMaskROI :  mask (logical matrix of size seti.nROI x seti.nROI)                       to restrict (later) the contrast in ROI                       to the mathematical sensible region.                       (This mask is currently useless, see "More About".)</li></ul></div><h2 id="6">More About</h2><div><ul><li>CD: computational domain: square [-rCD,rCD)^dim</li><li>mathematical sensible region: open ball with radius rCD/2</li><li>ROI: region of interest: biggest square in 2D (and cube in 3D)   in the mathematical sensible region, i.e. for <img src="setGrid_eq02851722028237398026.png" alt="$x = (x_1, x_2)$"> in ROI:</li></ul></div><p><img src="setGrid_eq09194098514400639562.png" alt="$-\frac{r_\mathrm{CD}}{2} \cdot \frac{1}{\sqrt{2}} < x_i < \frac{r_\mathrm{CD}}{2} \cdot \frac{1}{\sqrt{2}}$"></p><p>The areas are also defined and illustrated in Section 3 in [1]. (Note that in [1] is a small mistake: The interval must be open to be inside the mathematical sensible region <img src="setGrid_eq13202202739008048721.png" alt="$B_R$">.) Note that the radius <img src="setGrid_eq03442895190380135198.png" alt="$R$"> in [1] is related to the mentioned <img src="setGrid_eq10816367494811927576.png" alt="$\texttt{rCD}$"> by <img src="setGrid_eq06325201695805240227.png" alt="$\texttt{rCD} = 2 R$">.</p><p><b>The masks...</b></p><div><ul><li>The mask "ballMask" is defined to restrict   the contrast in CD to the mathematical sensible region.</li></ul></div><div><ul><li>The mask "ballMaskROI" is defined to restrict   the contrast in ROI to the mathematical sensible region.   Note that this does only make sense, if the alternative   definition of ROI is used, because otherwise ROI is already inside the   mathematical sensible region. The alternative definition of ROI is:</li></ul></div><pre class="language-matlab"><span class="comment">% Alternative:</span>
indx = (-seti.rCD/2&lt;x1)&amp;(x1&lt;seti.rCD/2); <span class="comment">% ROI with length rCD</span>
</pre><div><ul><li>The mask "ROImask" restricts the contrast in CD to the biggest square   inside the mathematical sensible region.</li></ul></div><h2 id="7">References</h2><div><ul><li>[1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. <i>Journal of Computational Physics</i>, 339:1-30, 2017.</li></ul></div><h2 id="8">See Also</h2><div><ul><li><a href="setGeomSim.html">setGeomSim.html</a></li></ul></div><h2 id="9">Code</h2><pre class="codeinput"><span class="keyword">function</span> seti = setGrid(seti,varargin)
</pre><pre class="codeinput"><span class="keyword">if</span> nargin == 2
    dispDepth = varargin{1};
<span class="keyword">else</span>
    dispDepth = 0;
<span class="keyword">end</span>
</pre><p><b>Check consistency</b></p><pre class="codeinput"><span class="keyword">if</span> ~(isfield(seti,<span class="string">'dim'</span>) &amp;&amp; seti.dim &gt;= 2 &amp;&amp; seti.dim &lt;= 3)
    seti.dim = 2;
    setmessage(seti,<span class="string">'dim'</span>,dispDepth);
<span class="keyword">end</span>

seti = checkfield(seti,<span class="string">'rCD'</span>,0.2,dispDepth);

seti = checkfield(seti,<span class="string">'nCD'</span>,256,dispDepth);
</pre><p><b>Element size and volume</b></p><pre class="codeinput"><span class="comment">% Length of the infinitesimal element of CD</span>
seti.h = 2*seti.rCD/seti.nCD;

<span class="comment">% Volume of the infinitesimal element of CD</span>
seti.dV = seti.h^seti.dim;
</pre><p><b>Set grid on CD in <tt>seti.grid</tt></b></p><pre class="codeinput">x1 = (-seti.rCD:seti.h:seti.rCD-seti.h);
<span class="comment">% x1: discr. intervall [-rCD,rCD)</span>
<span class="comment">% in setKernel [-N/2, N/2) is used analog</span>

<span class="keyword">if</span> seti.dim == 2
    [X1CD, X2CD] = meshgrid(x1,x1);
    seti.grid = [X1CD(:).'; X2CD(:).'];
<span class="keyword">elseif</span> seti.dim == 3
    [X1CD,X2CD,X3CD] = meshgrid(x1,x1,x1);
    seti.grid = [X1CD(:).'; X2CD(:).'; X3CD(:).'];
<span class="keyword">else</span>
    error(<span class="string">'Error - please choose seti.dim = 2 or 3.'</span>);
<span class="keyword">end</span>
</pre><p><b>Set ballMask on CD in <tt>seti.ballMask</tt>...</b></p><p>... to restrict (later) the contrast to the mathematical sensible region (ball with radius rCD/2).</p><pre class="codeinput"><span class="keyword">switch</span> seti.dim
    <span class="keyword">case</span> 2
        seti.ballMask = (hypot(X1CD,X2CD) &lt; seti.rCD/2);
    <span class="keyword">case</span> 3
        h3 = @(a,b,c) sqrt(abs(a).^2+abs(b).^2+abs(c).^2);
        seti.ballMask = (h3(X1CD,X2CD,X3CD) &lt; seti.rCD/2);
<span class="keyword">end</span>

seti.ballMask = logical(seti.ballMask); <span class="comment">% logical is important(!)</span>
</pre><p><b>Set grid <tt>seti.gridROI</tt> and for restriction <tt>seti.ballMaskROI</tt> on ROI</b></p><pre class="codeinput"><span class="comment">% ROI will be the biggest square in 2D (and cube in 3D) in ballMask:</span>
indx = (-seti.rCD/2*1/sqrt(2)&lt;x1)&amp;(x1&lt;seti.rCD/2*1/sqrt(2));

x1ROI = x1(indx);
seti.nROI = length(x1ROI);

<span class="keyword">if</span> seti.dim == 2
    [X1ROI,X2ROI] = meshgrid(x1ROI,x1ROI);
    seti.gridROI = [X1ROI(:).'; X2ROI(:).'];

    seti.ROImask = zeros(seti.nCD,seti.nCD);
    seti.ROImask(indx,indx) = 1;

    seti.ballMaskROI = (hypot(X1ROI,X2ROI) &lt; seti.rCD/2);

<span class="keyword">elseif</span> seti.dim == 3
    [X1ROI,X2ROI,X3ROI] = meshgrid(x1ROI,x1ROI,x1ROI);
    seti.gridROI = [X1ROI(:).'; X2ROI(:).'; X3ROI(:).'];

    <span class="comment">% To reconstruct X1ROI, X2ROI and X3ROI later you could use:</span>
    <span class="comment">% X1ROI = reshape(seti.gridROI(1,:),seti.nROI,seti.nROI,seti.nROI);</span>
    <span class="comment">% X2ROI = reshape(seti.gridROI(2,:),seti.nROI,seti.nROI,seti.nROI);</span>
    <span class="comment">% X3ROI = reshape(seti.gridROI(3,:),seti.nROI,seti.nROI,seti.nROI);</span>

    seti.ROImask = zeros(seti.nCD,seti.nCD,seti.nCD);
    seti.ROImask(indx,indx,indx) = 1;

    seti.ballMaskROI = (h3(X1ROI,X2ROI,X3ROI) &lt; seti.rCD/2);

<span class="keyword">else</span>
    error(<span class="string">'Error - please choose seti.dim = 2 or 3.'</span>); <span class="comment">% checked in checkConsistency</span>
<span class="keyword">end</span>

seti.ROImask = logical(seti.ROImask); <span class="comment">% logical is important(!)</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% setGrid
% Essentially set grids on ROI and CD.
%
%% Syntax
%
%   seti = setGrid(seti)
%   seti = setGrid(seti,dispDepth)
%
%% Description
%
% |seti = setGrid(seti)| essentially sets grids 
% on ROI and CD in |seti.grid| and |seti.gridROI|
% for |seti.dim| dimensions, 
% |seti.nCD| discretization points for each dimension of CD, which
% has a size of |[-seti.rCD,seti.rCD)^seti.dim|.
%
% |seti = setGrid(seti,dispDepth)| does the same, but allows to control the
% depth of displayed messages by |dispDepth|.
%
% ROI is the biggest square in 2D (and cube in 3D)
% in the mathematical sensible region (open ball with radius rCD/2).
%
%% Example
%
% *Example 1*
%
%   init;
%   seti.dim = 2;           % dimension 2
%   seti.rCD = 0.2;         % size of computational domain [-rCD,rCD)^dim
%   seti.nCD = 256;         % number of discretization points for each dimension of CD
%   seti = setGrid(seti);
%
% *Example 2*
%
%   init;
%   seti.dim = 2;           % dimension 2
%   seti.rCD = 0.2;         % size of computational domain [-rCD,rCD)^dim
%   seti.nCD = 256;         % number of discretization points for each dimension of CD
%   seti = setGrid(seti,1);
%
%% Input Arguments
%
% * seti    :   structure array
%
% If input arguments are not set, default values will be used.
%
% * seti.dim     :  dimension of the problem (2 or 3) (default: 2)
% * seti.nCD     :  number of discretization points for each dimension
%                   of computational domain (CD) (in samples)
%                   (default: 256).
% * seti.rCD     :  Size of computational domain [-rCD,rCD)^dim
%                   (default: 0.2) (in meters)
%
% *Optional Input Argument*
%
% * dispDepth   : Depth of displayed messages (0: no, 1 or greater: yes).
%
%% Output Arguments
%
% * seti    :   structure array
%
% * seti.h          :   length of the infinitesimal element of CD.
% * seti.dV         :   area/volume of the infinitesimal element (pixel/voxel) of CD
% * seti.grid       :   grid of computational domain (CD)
%                       (seti.dim x seti.nCD^seti.dim)
% * seti.ballMask   :   mask (logical matrix of size seti.nCD x seti.nCD)
%                       to restrict (later) the contrast in CD 
%                       to the mathematical sensible region.
% * seti.nROI       :   discretization points for each dimension
%                       of region of interest (ROI) (in samples)
% * seti.gridROI    :   grid of region of interest (ROI) 
%                       (matrix of size seti.dim x seti.nROI^seti.dim)
% * seti.ROImask    :   mask (logical matrix of size seti.nCD x seti.nCD)
%                       to restrict (later) the contrast in CD
%                       to the region of interest (ROI).
% * seti.ballMaskROI :  mask (logical matrix of size seti.nROI x seti.nROI)
%                       to restrict (later) the contrast in ROI
%                       to the mathematical sensible region.
%                       (This mask is currently useless, see "More About".)
%
%% More About
%
% * CD: computational domain: square [-rCD,rCD)^dim
% * mathematical sensible region: open ball with radius rCD/2
% * ROI: region of interest: biggest square in 2D (and cube in 3D)
%   in the mathematical sensible region, i.e. for $x = (x_1, x_2)$ in ROI:
%
% $-\frac{r_\mathrm{CD}}{2} \cdot \frac{1}{\sqrt{2}} < x_i < \frac{r_\mathrm{CD}}{2} \cdot \frac{1}{\sqrt{2}}$
%
% The areas are also defined and illustrated in Section 3 in [1].
% (Note that in [1] is a small mistake: The interval must be open to be
% inside the mathematical sensible region $B_R$.) 
% Note that the radius $R$ in [1] is related to the mentioned
% $\texttt{rCD}$ by $\texttt{rCD} = 2 R$.
%
% *The masks...*
%
% * The mask "ballMask" is defined to restrict
%   the contrast in CD to the mathematical sensible region.
%
% * The mask "ballMaskROI" is defined to restrict
%   the contrast in ROI to the mathematical sensible region. 
%   Note that this does only make sense, if the alternative
%   definition of ROI is used, because otherwise ROI is already inside the
%   mathematical sensible region. The alternative definition of ROI is:
%
%   % Alternative:
%   indx = (-seti.rCD/2<x1)&(x1<seti.rCD/2); % ROI with length rCD
%
% * The mask "ROImask" restricts the contrast in CD to the biggest square
%   inside the mathematical sensible region.
%
%
%% References
% * [1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. _Journal of Computational Physics_, 339:1-30, 2017.
%
%% See Also
% * <setGeomSim.html>
%
%% Code
function seti = setGrid(seti,varargin)

if nargin == 2
    dispDepth = varargin{1};
else 
    dispDepth = 0;
end

%%
% *Check consistency*

if ~(isfield(seti,'dim') && seti.dim >= 2 && seti.dim <= 3)
    seti.dim = 2;
    setmessage(seti,'dim',dispDepth);
end

seti = checkfield(seti,'rCD',0.2,dispDepth);

seti = checkfield(seti,'nCD',256,dispDepth);

%%
% *Element size and volume*

% Length of the infinitesimal element of CD
seti.h = 2*seti.rCD/seti.nCD;

% Volume of the infinitesimal element of CD
seti.dV = seti.h^seti.dim;

%%
% *Set grid on CD in |seti.grid|*

x1 = (-seti.rCD:seti.h:seti.rCD-seti.h);
% x1: discr. intervall [-rCD,rCD)
% in setKernel [-N/2, N/2) is used analog

if seti.dim == 2
    [X1CD, X2CD] = meshgrid(x1,x1);
    seti.grid = [X1CD(:).'; X2CD(:).'];
elseif seti.dim == 3
    [X1CD,X2CD,X3CD] = meshgrid(x1,x1,x1);
    seti.grid = [X1CD(:).'; X2CD(:).'; X3CD(:).'];
else
    error('Error - please choose seti.dim = 2 or 3.');
end

%%
% *Set ballMask on CD in |seti.ballMask|...*
%
% ... to restrict (later) the contrast to the mathematical sensible region
% (ball with radius rCD/2).

switch seti.dim
    case 2
        seti.ballMask = (hypot(X1CD,X2CD) < seti.rCD/2);
    case 3
        h3 = @(a,b,c) sqrt(abs(a).^2+abs(b).^2+abs(c).^2);
        seti.ballMask = (h3(X1CD,X2CD,X3CD) < seti.rCD/2);
end

seti.ballMask = logical(seti.ballMask); % logical is important(!)

%%
% *Set grid |seti.gridROI| and for restriction |seti.ballMaskROI| on ROI*

% ROI will be the biggest square in 2D (and cube in 3D) in ballMask:
indx = (-seti.rCD/2*1/sqrt(2)<x1)&(x1<seti.rCD/2*1/sqrt(2));

x1ROI = x1(indx);
seti.nROI = length(x1ROI);

if seti.dim == 2
    [X1ROI,X2ROI] = meshgrid(x1ROI,x1ROI);
    seti.gridROI = [X1ROI(:).'; X2ROI(:).'];
    
    seti.ROImask = zeros(seti.nCD,seti.nCD);
    seti.ROImask(indx,indx) = 1;

    seti.ballMaskROI = (hypot(X1ROI,X2ROI) < seti.rCD/2);

elseif seti.dim == 3
    [X1ROI,X2ROI,X3ROI] = meshgrid(x1ROI,x1ROI,x1ROI);
    seti.gridROI = [X1ROI(:).'; X2ROI(:).'; X3ROI(:).'];

    % To reconstruct X1ROI, X2ROI and X3ROI later you could use:
    % X1ROI = reshape(seti.gridROI(1,:),seti.nROI,seti.nROI,seti.nROI);
    % X2ROI = reshape(seti.gridROI(2,:),seti.nROI,seti.nROI,seti.nROI);
    % X3ROI = reshape(seti.gridROI(3,:),seti.nROI,seti.nROI,seti.nROI);

    seti.ROImask = zeros(seti.nCD,seti.nCD,seti.nCD);
    seti.ROImask(indx,indx,indx) = 1;

    seti.ballMaskROI = (h3(X1ROI,X2ROI,X3ROI) < seti.rCD/2);
    
else
    error('Error - please choose seti.dim = 2 or 3.'); % checked in checkConsistency
end

seti.ROImask = logical(seti.ROImask); % logical is important(!)
end

##### SOURCE END #####
--></body></html>