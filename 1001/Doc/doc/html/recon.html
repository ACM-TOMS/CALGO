
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>recon</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-30"><meta name="DC.source" content="recon.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>recon</h1><!--introduction--><p>Variational reconstruction of the contrast.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Example</a></li><li><a href="#4">Input Arguments</a></li><li><a href="#5">Output Arguments</a></li><li><a href="#6">Output Figures</a></li><li><a href="#7">More About</a></li><li><a href="#8">References</a></li><li><a href="#9">See Also</a></li><li><a href="#10">Code</a></li><li><a href="#15">Code: subfunction: minimization</a></li><li><a href="#24">Code: Further Subfunctions</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">seti = recon(seti)
seti = recon(seti,dispDepth)
seti = recon(seti,dispDepth,out)
</pre><h2 id="2">Description</h2><p><tt>seti = recon(seti)</tt> does the variational reconstruction of the contrast by minimizing the Tikhonov functional by <i>soft-shrinkage</i> or <i>primal-dual algorithm</i>.</p><p><tt>seti = recon(seti,dispDepth)</tt> does the same as <tt>seti = recon(seti)</tt>, but the depth of displayed messages is controlled by <tt>dispDepth</tt>.</p><p><tt>seti = recon(seti,dispDepth,out)</tt> does the same as <tt>seti = recon(seti,dispDepth)</tt> in case of <tt>out = 0</tt>, but plots the figures in case of <tt>out = 1</tt> and additionally saves them in case of <tt>out = 2</tt>.</p><div><ul><li>In public version only primal-dual algorithm is available.</li><li>The result is the contrast <tt>seti.qROIcomp</tt> after <tt>seti.iOutStop</tt> outer iterations.</li><li>The reconstruction is plotted in case of <tt>out = 1</tt> and in case of   <tt>out = 2</tt> additionally stored in the folder output.</li></ul></div><div><ul><li>The reconstruction is stopped after maximal <tt>seti.nOut</tt> iterations.</li><li>If <tt>seti.useDis = 1</tt> and a tolerance parameter <tt>seti.tau &gt; 1</tt> was set, the reconstruction is stopped by <b>discrepancy principle</b>, i.e.</li></ul></div><p>stop if discrepancy <img src="recon_eq08702962754466044616.png" alt="$\leq$"> <img src="recon_eq11131985798389450908.png" alt="$\texttt{seti.tau*seti.delta}$">.</p><div><ul><li>If <tt>seti.loadqROIcomp</tt> is not empty, a path to a mat-file is expected, that contains the reconstruction result <tt>qROIcomp</tt> after <tt>iOutStop</tt> outer iterations from a previous computation. Then this file is loaded. Further, the contrast and the stop index of outer iteration are set as initial contrast <tt>seti.qROIcomp</tt> and iteration number <tt>seti.iOutIni</tt> for current computation.</li></ul></div><div><ul><li>If <tt>seti.saveqROIcomp</tt> is not empty (i.e. <tt>''</tt> or <tt>[]</tt>), a filename to save <tt>qROIcomp</tt> and <tt>iOut</tt> is expected. Default in <a href="checkConsisRec.html">checkConsisRec.html</a> is</li></ul></div><pre>sprintf('%s/save_qROIcomp_iOutStop%s.mat',seti.dirname,seti.fileSuffix)</pre><p>(i.e. the mat-file is stored in the same folder as the figures). Then <tt>seti.qROIcomp</tt> and <tt>seti.iOutStop</tt> are saved as <tt>qROIcomp</tt> and <tt>iOutStop</tt>.</p><div><ul><li>If <tt>seti.savedata</tt> is 1 (default: 0),   relative discrepancies, errors, and differences of iterated contrasts   are saved in mat-files in the folder of the   figures (filenames are essentially save_dis.mat, save_err.mat, save_dif.mat.)</li></ul></div><p><b>Structure of this file</b></p><div><ol><li>Optional: loads reconstruction result from previously computation.</li><li>Initialization.</li><li>Evaluation of previous outer iteration.   (Stop if maximal number of iterations is reached or   discrepancy principle is fullfilled (optional)).</li><li>Plot results from previous outer iteration   and stores them in folder output (optional, depends on argument <tt>out</tt>).</li><li>Compute next step (minimization by soft-shrinkage or primal-dual algorithm). Go to 3.</li><li>Optional: save discrepancy, error and reconstruction results.</li></ol></div><h2 id="3">Example</h2><p><b>Example 1</b></p><pre class="language-matlab">init;                   <span class="comment">% Initialization (addpath...)</span>
seti = struct;
seti = setData(seti);   <span class="comment">% Set data: (experimental data, geometry, exact and noisy data)</span>
seti = setRecon(seti);  <span class="comment">% Settings for variational reconstruction</span>
seti = recon(seti);     <span class="comment">% Variational reconstruction (process)</span>
</pre><p><b>Example 2</b></p><p>This example does the same as the first one, but displays more messages.</p><pre class="language-matlab">init;                     <span class="comment">% Initialization (addpath...)</span>
seti = struct;
seti = setData(seti,4);   <span class="comment">% Set data: (experimental data, geometry, exact and noisy data)</span>
seti = setRecon(seti,4);  <span class="comment">% Settings for variational reconstruction</span>
seti = recon(seti,4);     <span class="comment">% Variational reconstruction (process)</span>
</pre><p><b>Example 3</b></p><p>The example is essentially the code in start.m (<a href="start.html">start.html</a>) because we need previously definitions.</p><p>Warning: variables are cleared and figures as well as files are saved without demand.</p><p>The results are stored in the folder output.</p><pre class="language-matlab">init;                       <span class="comment">% Initialization (addpath...)</span>
setInput;                   <span class="comment">% Set input and make directories for output</span>
seti = setData(seti,4,2);   <span class="comment">% Set data: (experimental data, geometry, exact and noisy data)</span>
seti = setRecon(seti,4);    <span class="comment">% Settings for variational reconstruction</span>
seti = recon(seti,4,2);     <span class="comment">% Variational reconstruction (process)</span>
</pre><h2 id="4">Input Arguments</h2><div><ul><li><tt>seti</tt>    :   structure array</li></ul></div><p>Because this is a internal function we do not explain all fields in seti.</p><div><ul><li><tt>seti.loadqROIcomp</tt> : Path to load a mat-file containing the reconstructed                         contrast <tt>qROIcomp</tt> after <tt>iOutStop</tt> outer iterations                         (default: empty, i.\,e. <tt>''</tt> or <tt>[]</tt>, then no data is loaded).</li><li><tt>seti.saveqROIcomp</tt> : Optional: Path to save reconstructed contrast                         (default: same folder as figures, i.e.                         <tt>sprintf('%s/save_qROIcomp_iOutStop%s.mat',seti.dirname,seti.fileSuffix)</tt>)</li></ul></div><div><ul><li><tt>seti.nOut</tt>         : Maximal number of outer iterations.</li></ul></div><div><ul><li><tt>seti.useDis</tt>       : Use discrepancy principle to stop outer iteration?                         (If yes set it to 1.)</li><li><tt>seti.tau</tt>          : Tolerance parameter for discrepancy principle                         (seti.tau &gt; 1).</li></ul></div><div><ul><li><tt>seti.plotFreq</tt>     : Frequency to plot figures of outer iteration steps                         (0: no figures).</li><li><tt>seti.savedata</tt>     : If it is set to 1,                         relative discrepancies, errors, and differences                         of iterated contrasts are saved                         (as <tt>save_dis.mat</tt>, <tt>save_err.mat</tt> and <tt>save_dif.mat</tt>).</li></ul></div><div><ul><li><tt>seti.qROIexact</tt>    : Predefined (exact) contrast                         (complex vector of <tt>size seti.nROI</tt>^|seti.dim| x 1).</li></ul></div><p><b>Further specific input parameters</b> for primal-dual algorithm can be found in <a href="minPda.html">minPda.html</a> and <a href="pda.html">pda.html</a>.</p><p><b>Optional Input Argument</b></p><div><ul><li><tt>dispDepth</tt>     : depth of displayed text.                     (from 0 to 5, default sparse: 2; default details: 4; too much information: 5);</li><li><tt>out</tt>           : output depth for figures and files: no figure (0), plot figure (1),                     save figures and files (2).                     (This argument requires that argument <tt>dispDepth</tt> was                     defined.)</li></ul></div><h2 id="5">Output Arguments</h2><div><ul><li><tt>seti</tt>    :   structure array</li></ul></div><p>Because this is a internal function we do not explain all fields in seti.</p><div><ul><li><tt>seti.qROIcomp</tt>     : Reconstructed contrast                         (complex vector of size <tt>seti.nROI</tt>^|seti.dim| x 1).</li><li><tt>seti.iOutStop</tt>     : Stop index of outer iterations.</li></ul></div><p><b>Discrepancy, error, and difference</b></p><div><ul><li><tt>seti.dis</tt>        : Relative discrepancy for each outer iteration                       (vector of size 1 x seti.nOut).</li><li><tt>seti.err</tt>        : Relative error for each outer iteration                       (vector of size 1 x seti.nOut).</li><li><tt>seti.dif</tt>        : Relative difference of iterated contrast qROI to previously qROI                       for each outer iteration                       (vector of size 1 x seti.nOut).</li></ul></div><p>Note that <tt>seti.dis(iOut)</tt> is the relative discrepancy <i>after</i> iteration <tt>iOut</tt>. (Analog seti.err(iOut) and seti.dif(iOut).)</p><p><b>Minimized Tikhonov functional</b></p><div><ul><li><tt>seti.MTv</tt>        :   Result of minimized Tikhonov functional                         for each outer iteration                         (vector of size 1 x seti.nOut).</li><li><tt>seti.M1v</tt>        :   Result of first part of min. functional                         for each outer iteration                         (vector of size 1 x seti.nOut).</li><li><tt>seti.M2v</tt>        :   Result of second part of min. functional                         for each outer iteration                         (vector of size 1 x seti.nOut).</li></ul></div><p><i>More about M1v and M2v</i></p><div><ul><li>In case of primal-dual algorithm (i.e. <tt>seti.inv = 'pda'</tt>)   <tt>M1v</tt> is F and <tt>M2</tt> is G, see <a href="pda.html">pda.html</a> for F and G.</li><li>In case of shrinkage (i.e. <tt>seti.inv = 'shrinkage'</tt>)   (not available in public version)   <tt>M1</tt> = discrepancy and <tt>M2</tt> = sparsity (setFuncsShrink.m)</li></ul></div><p><b>structure array pdas</b></p><div><ul><li><tt>pdas</tt>        : Structure array                   (only in case of pda, i.e. <tt>seti.inv = 'pda'</tt>).</li></ul></div><div><ul><li><tt>pdas.disLin</tt> : Last relative discrepancy of linearized problem in inner iteration of pda                   for each outer iteration                   (vector of size 1 x seti.nOut).</li><li><tt>pdas.relDis</tt> : Quotient disLin/dis                   for each outer iteration                   (rel. discrepancy of linearized problem / rel. discrepancy of the non-linearized problem)                   (vector of size 1 x seti.nOut).</li><li><tt>pdas.pdaNv</tt>  : Number of inner iterations for each outer iteration                   (vector of size 1 x seti.nOut).</li><li><tt>pdas.ThetaiOutV</tt> : Inner tolerance for each outer iteration                       (in case of inner tolerance principle, see                       <a href="minTolIn.html">minTolIn.html</a>).</li></ul></div><p><b>Further output arguments</b></p><div><ul><li><tt>seti.disIni</tt>   : Relative discrepancy before 1st iteration.</li><li><tt>seti.errIni</tt>   : Relative error before 1st iteration.</li></ul></div><h2 id="6">Output Figures</h2><p>The functions in the code, that plot figures are:</p><div><ul><li>subplots            :   figure 11</li><li>plotAndSaveFigures  :   figures 12-16 and in 3D case figures 21-26</li><li>pdaPlot             :   figures 31--36</li></ul></div><p>A description of all figures in the package are in <a href="start.html">start.html</a>, Section "Output: Figures".</p><p>Note that the creation and saving of plots also depends on the input argument <tt>out</tt>.</p><h2 id="7">More About</h2><p>The outer iteration of the variational reconstruction process is briefly described in <a href="start.html">start.html</a>, Section "More About". More information are available in [1].</p><p>The primal-dual algorithm and its application to the inverse scattering problem is briefly described in <a href="pda.html">pda.html</a>, Section "More About". For further information of application see Section 4 in [1]. For details in context of primal-dual algorithm see [2].</p><p>The initial contrast <tt>seti.qROIcomp</tt> is set to zero if no contrast is loaded from a previous reconstruction.</p><h2 id="8">References</h2><div><ul><li>[1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. <i>Journal of Computational Physics</i>, 339:1-30, 2017.</li><li>[2] Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. <i>Journal of Mathematical Imaging and Vision</i>, 40(1):120-145, 2011.</li></ul></div><h2 id="9">See Also</h2><div><ul><li><a href="start.html">start.html</a></li><li><a href="pda.html">pda.html</a></li><li><a href="setFuncsPda.html">setFuncsPda.html</a></li><li><a href="minPda.html">minPda.html</a></li><li><a href="minTolIn.html">minTolIn.html</a></li></ul></div><h2 id="10">Code</h2><pre class="codeinput"><span class="keyword">function</span> seti = recon(seti,varargin)
</pre><pre class="codeinput"><span class="keyword">if</span> nargin == 2
    dispDepth = varargin{1};
    out = 0;
<span class="keyword">elseif</span> nargin == 3
    dispDepth = varargin{1};
    out = varargin{2};
<span class="keyword">else</span>
    dispDepth = 0;
    out = 0;
<span class="keyword">end</span>
</pre><p><b>Optional: loads reconstruction result from a previous computation.</b></p><pre class="codeinput"><span class="keyword">if</span> ~isempty(seti.loadqROIcomp)
    disp(<span class="string">'# Loading qROI from previous calculation.'</span>)
<span class="comment">% -- load old: start --</span>
<span class="comment">%     load(sprintf('%s',seti.loadqROIcomp)); % qROIcomp and iOutStop are inside</span>
<span class="comment">%     seti.qROIcomp = qROIcomp;</span>
<span class="comment">%     seti.iOutIni = iOutStop;</span>
<span class="comment">%     clear qROIcomp iOutStop;</span>
<span class="comment">% -- load old: end --</span>
<span class="comment">% -- load new: start --</span>
    sloaded = load(sprintf(<span class="string">'%s'</span>,seti.loadqROIcomp)); <span class="comment">% qROIcomp and iOutStop are inside (sloaded: struct)</span>
    seti.qROIcomp = sloaded.qROIcomp;
    seti.iOutIni = sloaded.iOutStop;
    clear <span class="string">sloaded</span>;
<span class="comment">% -- load new: end --</span>
<span class="keyword">else</span>
    seti.qROIcomp = zeros(size(seti.qROIexact));
    seti.iOutIni = 0;
<span class="keyword">end</span>

<span class="comment">% FmeasDelta = seti.FmeasDelta; % perturbed data.</span>
<span class="comment">% If you call pertuped data, use consequently seti.FmeasDelta,</span>
<span class="comment">% if you are not in a function.</span>
</pre><pre class="codeinput"><span class="comment">% -- iteration - start with q_0 = 0 or loaded qROI</span>
seti = minimization(seti,out,dispDepth);
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="15">Code: subfunction: minimization</h2><pre class="codeinput"><span class="keyword">function</span> seti = minimization(seti,out,dispDepth)
</pre><pre class="codeinput"><span class="keyword">if</span> dispDepth &gt;= 1
    disp(<span class="string">' '</span>)
    fprintf(<span class="string">'   Remind: alpha = %g\n'</span>,seti.alpha);
    fprintf(<span class="string">'   Remind: beta  = %g\n'</span>,seti.beta);
<span class="keyword">end</span>

<span class="comment">% qROIexact = seti.qROIexact; % use consequently seti.qROIexact</span>
<span class="comment">% qROIcomp = seti.qROIcomp; % use consequently seti.qROIcomp</span>

seti.dis = zeros(1,seti.nOut); <span class="comment">% seti.dis(iOut) = relative discrepancy after iOut</span>
seti.err = zeros(1,seti.nOut); <span class="comment">% seti.err(iOut) = relative error after iOut</span>
seti.dif = zeros(1,seti.nOut); <span class="comment">% seti.dif(iOut) = relative difference of iterated qROI to previously qROI after iOut</span>

seti.MTv = zeros(1,seti.nOut); <span class="comment">% results of minimized Tikhonov functional</span>
seti.M1v = zeros(1,seti.nOut); <span class="comment">% results of first part of min. functional</span>
seti.M2v = zeros(1,seti.nOut); <span class="comment">% results of second part of min. functional</span>

<span class="keyword">if</span> strcmp(seti.inv,<span class="string">'pda'</span>)
    pdas.disLin = ones(1,seti.nOut); <span class="comment">% store results of last relative lin. discrepancy in inner iteration of pda</span>
    pdas.relDis = zeros(1,seti.nOut); <span class="comment">% disLin/dis (not in pda, but outside)</span>

    pdas.pdaNv = zeros(1,seti.nOut); <span class="comment">% number of inner iterations in each outer iteration</span>
    pdas.ThetaiOutV = zeros(1,seti.nOut);
<span class="keyword">end</span>
</pre><p><b>minimization: Initialization</b></p><pre class="codeinput">ticMin = tic;

iOut = seti.iOutIni; <span class="comment">% outer iteration</span>
<span class="comment">% (default: 0; higher if previously computed qROI is used; is set in start.m)</span>

<span class="comment">% initial input is seti.qROIcomp</span>
<span class="keyword">if</span> dispDepth &gt;= 1
    disp(<span class="string">' '</span>)
    fprintf(<span class="string">' - iOut = %02d (initial, no reconstruction done)\n'</span>,iOut); <span class="comment">% initial...</span>
<span class="keyword">end</span>
<span class="keyword">if</span> iOut ~= 0
    FFqMeas = mimo(seti, seti.qROIcomp, <span class="string">'simo'</span>); <span class="comment">% only needed to compute dis</span>
    seti.disIni = compDis(seti,FFqMeas,seti.FmeasDelta); <span class="comment">% relative discrepancy before 1st iteration</span>
    seti.errIni = compErr(seti.qROIexact,seti.qROIcomp); <span class="comment">% relative error before 1st iteration</span>
<span class="keyword">else</span>
    <span class="keyword">if</span> dispDepth &gt;= 1
        disp(<span class="string">'   Because iOut == 0 set disIni = 1 and errIni = 1 (otherwise compute them).'</span>)
    <span class="keyword">end</span>
    seti.disIni = 1;
    seti.errIni = 1;
<span class="keyword">end</span>
<span class="keyword">if</span> dispDepth &gt;= 1
    fprintf(<span class="string">'   disIni = %g \n'</span>,seti.disIni)
    fprintf(<span class="string">'   errIni = %g \n'</span>,seti.errIni)
<span class="keyword">end</span>

<span class="keyword">if</span> ~exist(<span class="string">'ilast'</span>,<span class="string">'var'</span>)
    ilast = false;
<span class="keyword">end</span>

<span class="keyword">while</span> 1
</pre><p><b>minimization: Evaluation of previous outer iteration</b></p><pre class="codeinput">    <span class="comment">% qROIcomp: real and imag</span>
    <span class="keyword">if</span> dispDepth &gt;= 1
        fprintf(<span class="string">'   qROIcomp: real [%+3.2f,%+3.2f], imag [%+3.2f,%+3.2f].\n'</span>,<span class="keyword">...</span>
            min(real(seti.qROIcomp)),max(real(seti.qROIcomp)),min(imag(seti.qROIcomp)),max(imag(seti.qROIcomp)));
        fprintf(<span class="string">'   qROIexact: real [%+3.2f,%+3.2f], imag [%+3.2f,%+3.2f].\n'</span>,<span class="keyword">...</span>
            min(real(seti.qROIexact)),max(real(seti.qROIexact)),min(imag(seti.qROIexact)),max(imag(seti.qROIexact)));
    <span class="keyword">end</span>

    <span class="keyword">if</span> iOut == seti.iOutIni
        dis = seti.disIni;
    <span class="keyword">else</span>
        dis = seti.dis(iOut);
    <span class="keyword">end</span>
    [ibreak,seti.iOutStop] = reconStop(seti,iOut,dis,dispDepth);

    <span class="keyword">if</span> ilast == true
        seti.iOutStop = iOut;
        ibreak = true;
    <span class="keyword">elseif</span> ilast == false &amp;&amp; isfield(seti,<span class="string">'pdaNlast'</span>) &amp;&amp; seti.pdaNlast &gt; 0
        <span class="keyword">if</span> iOut == seti.nOut-1 <span class="comment">% set ilast = true because last iteration will follow</span>
            disp(<span class="string">' '</span>)
            disp(<span class="string">'   seti.pdaNlast &gt; 0. The last iteration will done by a higher number of inner iterations.'</span>)
            seti.pdaN = seti.pdaNlast; <span class="comment">% pdaN is overwritten for the last step.</span>
            ibreak = false;
            ilast = true;
        <span class="keyword">elseif</span> ibreak == true <span class="comment">% in the case of discrepancy principle</span>
            disp(<span class="string">' '</span>);
            fprintf(<span class="string">'   Start the last outer iteration with %g inner iterations.\n'</span>, seti.pdaNlast)
            seti.pdaN = seti.pdaNlast; <span class="comment">% pdaN is overwritten for the last step.</span>
            ibreak = false;
            ilast = true;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><p><b>minimization: Plot results from previous outer iteration</b></p><p>The figures are described in <a href="start.html">start.html</a>.</p><pre class="codeinput">    <span class="keyword">if</span> (out &gt;= 1 &amp;&amp; seti.plotFreq ~= 0 &amp;&amp;<span class="keyword">...</span>
            (iOut == 1 || ibreak == true || (isfield(seti,<span class="string">'pdaNlast'</span>) &amp;&amp; seti.pdaNlast &gt; 0 &amp;&amp; iOut == seti.nOut-1)<span class="keyword">...</span>
             || ilast == true || floor(iOut/seti.plotFreq) == iOut/seti.plotFreq))
    <span class="comment">% condition "iOut == seti.nOut-1" etc. to plot the step before the last step (interesting in the case of pdaNlast...)</span>

        <span class="keyword">if</span> iOut ~= seti.iOutIni
            subplots(seti,seti.qROIexact,seti.qROIcomp,iOut); <span class="comment">% figure 11</span>
        <span class="keyword">end</span>
        plotAndSaveFigures(seti,seti.qROIexact,seti.qROIcomp,iOut,out); <span class="comment">% save figure 11; generate figures 12--16 and in 3D case 21--26</span>

        <span class="keyword">if</span> iOut &gt; 0 &amp;&amp; strcmp(seti.inv,<span class="string">'pda'</span>) &amp;&amp; isfield(pdas,<span class="string">'pdaStopInd'</span>)
            pdaPlot(iOut,seti,pdas,out) <span class="comment">% figures 31--36</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% time</span>
    <span class="keyword">if</span> iOut ~= seti.iOutIni
        tocOut = toc(ticOut);
        <span class="keyword">if</span> dispDepth &gt;= 1
            disp(<span class="string">' '</span>)
            fprintf(<span class="string">'   Elapsed time of outer minimization iOut = %03d is %05.1f min.\n'</span>,iOut,tocOut/60);
        <span class="keyword">end</span>

        tocMin = toc(ticMin);
        <span class="keyword">if</span> dispDepth &gt;= 1
            disp(<span class="string">' '</span>)
            fprintf(<span class="string">'   Elapsed time of overall minimization process is %05.1f min.\n'</span>,tocMin/60);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> ibreak == true
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
    <span class="comment">% break does mean: result is seti.qROIcomp after iOut iterations</span>
</pre><p><b>minimization: Compute next step</b></p><p>(The new contrast "qROInew" is seti.qROIcomp after minShrink or minPda.)</p><pre class="codeinput">    ticOut = tic;
    iOut = iOut + 1;
    <span class="keyword">if</span> dispDepth &gt;= 1
        disp(<span class="string">' '</span>)
        fprintf(<span class="string">' - iOut = %02d\n'</span>,iOut);
    <span class="keyword">end</span>

    <span class="keyword">switch</span> seti.inv
        <span class="keyword">case</span> <span class="string">'shrinkage'</span>
            <span class="comment">% Note that the case seti.inv = 'shrinkage' is not available in</span>
            <span class="comment">% public version.</span>
            <span class="keyword">if</span> iOut == seti.iOutIni+1
                ADFFqPrev = zeros(seti.nROI^seti.dim,1); <span class="comment">% to have a value</span>
                qROIcompPrev = zeros(seti.nROI^seti.dim,1); <span class="comment">% to have a value</span>
            <span class="keyword">end</span>
            <span class="comment">% ADFFqPrev is needed in minShrink in case of Barzilai-Borwein</span>
            [seti,FFqMeas,qROIcompPrev,ADFFqPrev] = minShrink(seti,iOut,seti.qROIcomp,qROIcompPrev,ADFFqPrev);
        <span class="keyword">case</span> <span class="string">'pda'</span>
            <span class="keyword">if</span> dispDepth &gt;= 2
                disp(<span class="string">'    - Start minimization by PDA'</span>)
            <span class="keyword">end</span>
            <span class="keyword">if</span> iOut == seti.iOutIni + 1 <span class="comment">% otherwise it is done after pda algorithm</span>
                FFqMeas = mimo(seti, seti.qROIcomp,<span class="string">'simo'</span>); <span class="comment">% needs upscaled qROI</span>
            <span class="keyword">end</span>
            qROIcompPrev = seti.qROIcomp;
            [seti,FFqMeas,pdas] = minPda(seti,iOut,seti.qROIcomp,pdas,FFqMeas,dispDepth);
    <span class="keyword">end</span>
    <span class="comment">% output: seti.qROIcomp (new reconstructed contrast after step iOut)</span>

    <span class="comment">% *Compute discrepancy, error and difference*</span>
    <span class="comment">%</span>
    seti = disErrDif(FFqMeas,qROIcompPrev,seti,iOut,dispDepth);

    <span class="comment">% *Compute quotient disLin/dis*</span>
    <span class="comment">% disLin/dis = rel. discrepancy of linearized problem / rel. discrepancy of the non-linearized problem</span>
    <span class="comment">%</span>
    <span class="keyword">if</span> iOut &gt; 0 &amp;&amp; strcmp(seti.inv,<span class="string">'pda'</span>)
        pdas.relDis(iOut) = pdas.disLin(iOut)/seti.dis(iOut);
        <span class="keyword">if</span> dispDepth &gt;= 3
            fprintf(<span class="string">'   relDis = %5.3f \n'</span>,pdas.relDis(iOut));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p><b>minimization: Optional: save relative discrepancies, errors, and differences of iterated contrasts</b></p><pre class="codeinput"><span class="keyword">if</span> out == 2
    savedata(seti,seti.dis,seti.err,seti.dif);
<span class="keyword">end</span>

<span class="comment">% *Optional: save reconstructed contrast qROIcomp and stop index iOutStop</span>
<span class="comment">% for further computations*</span>
<span class="comment">%</span>
<span class="keyword">if</span> out == 2 &amp;&amp; isfield(seti,<span class="string">'saveqROIcomp'</span>) &amp;&amp; ~isempty(seti.saveqROIcomp)
    saveqROI(seti);
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="24">Code: Further Subfunctions</h2><p><b>subfunction: savedata</b></p><p>Save relative discrepancies, errors, and differences of iterated contrasts.</p><pre class="codeinput"><span class="keyword">function</span> savedata(seti,dis,err,dif)

<span class="keyword">if</span> seti.savedata
    <span class="comment">% Remove zeros from dis, err, and dif.</span>
    <span class="comment">% (dis ~= 0) or 1:iOutStop... should work too...</span>
    disNonZeros = dis(dis ~= 0); <span class="comment">%#ok (suppress MATLAB warning, because will be saved.)</span>
    errNonZeros = err(err ~= 0); <span class="comment">%#ok (suppress MATLAB warning, because will be saved.)</span>
    difNonZeros = dif(dif ~= 0); <span class="comment">%#ok (suppress MATLAB warning, because will be saved.)</span>
    <span class="comment">%  Save relative discrepancies, errors, and differences of iterated contrasts.</span>
    save(sprintf(<span class="string">'%s/save_dis%s.mat'</span>,seti.dirname,seti.fileSuffix),<span class="string">'disNonZeros'</span>);
    save(sprintf(<span class="string">'%s/save_err%s.mat'</span>,seti.dirname,seti.fileSuffix),<span class="string">'errNonZeros'</span>);
    save(sprintf(<span class="string">'%s/save_dif%s.mat'</span>,seti.dirname,seti.fileSuffix),<span class="string">'difNonZeros'</span>);
    clear <span class="string">disNonZeros</span>;
    clear <span class="string">errNonZeros</span>;
    clear <span class="string">difNonZeros</span>;
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p><b>Subfunction: reconStop</b></p><p>Stops the reconstruction process, when maximal number of outer iterations <tt>seti.nOut</tt> is reached or discrepancy principle is fullfilled (optional).</p><pre class="codeinput"><span class="keyword">function</span> [ibreak,iOutStop] = reconStop(seti,iOut,dis,dispDepth)

<span class="keyword">if</span> iOut == seti.nOut
    iOutStop = iOut;
    <span class="keyword">if</span> dispDepth &gt;= 1
        disp(<span class="string">' '</span>)
        fprintf(<span class="string">'   Reconstruction stopped after %0d outer iterations (max. number reached).\n'</span>,iOutStop)
    <span class="keyword">end</span>
    ibreak = true;
<span class="keyword">end</span>

<span class="keyword">if</span> iOut &gt; 0 &amp;&amp; isnan(dis)
    iOutStop = iOut;
    <span class="keyword">if</span> dispDepth &gt;= 1
        disp(<span class="string">' '</span>)
        fprintf(<span class="string">'   Reconstruction stopped after %0d outer iterations (discrepancy not a number).\n'</span>,iOutStop);
    <span class="keyword">end</span>
    ibreak = true;
<span class="keyword">end</span>

<span class="keyword">if</span> iOut &gt; 0 &amp;&amp; seti.useDis == 1 &amp;&amp; (dis &lt;= seti.tau*seti.delta)
    iOutStop = iOut;
    <span class="keyword">if</span> dispDepth &gt;= 1
        disp(<span class="string">' '</span>)
        fprintf(<span class="string">'   Reconstruction stopped after %0d outer iterations (by discrepancy principle).\n'</span>,iOutStop);
    <span class="keyword">end</span>
    ibreak = true;
<span class="keyword">end</span>

<span class="keyword">if</span> ~exist(<span class="string">'ibreak'</span>,<span class="string">'var'</span>)
    ibreak = false;
<span class="keyword">end</span>

<span class="keyword">if</span> ~exist(<span class="string">'iOutStop'</span>,<span class="string">'var'</span>)
    iOutStop = [];
<span class="keyword">end</span>

<span class="keyword">end</span>
</pre><p><b>Subfunction: compDis</b></p><p>Computes relative discrepancy</p><pre class="codeinput"><span class="keyword">function</span> dis = compDis(seti,FFqMeas,FmeasDelta)
dis = normws(FFqMeas-FmeasDelta,seti)/normws(FmeasDelta,seti); <span class="comment">% relative discrepancy</span>
<span class="keyword">end</span>
</pre><p><b>Subfunction: compErr</b></p><p>Computes relative error</p><pre class="codeinput"><span class="keyword">function</span> err = compErr(qROIexact,qROIcomp)
err = norm(qROIexact-qROIcomp,2)/norm(qROIexact,2); <span class="comment">% relative error in 2-Norm</span>
<span class="keyword">end</span>
</pre><p><b>Subfunction: disErrDif</b></p><p>Computes, stores and displays:</p><div><ul><li>realtive discrepancy,</li><li>relative error, and</li><li>relative difference of iterated contrast to previous one</li></ul></div><pre class="codeinput"><span class="keyword">function</span> seti = disErrDif(FFqMeas,qROIcompPrev,seti,iOut,dispDepth)
<span class="comment">% relative discrepancy</span>
seti.dis(iOut) = compDis(seti,FFqMeas,seti.FmeasDelta);
clear <span class="string">FFqmF</span>;
<span class="comment">% relative error</span>
seti.err(iOut) = compErr(seti.qROIexact,seti.qROIcomp);
<span class="comment">% relative difference of iterated qROI to previously qROI</span>
seti.dif(iOut) = normroi(seti.qROIcomp-qROIcompPrev,seti)/normroi(seti.qROIcomp,seti);
<span class="comment">% display:</span>
<span class="keyword">if</span> dispDepth &gt;= 2
    fprintf(<span class="string">'   dis = %5.3f \n'</span>,seti.dis(iOut))
    fprintf(<span class="string">'   err = %5.3f \n'</span>,seti.err(iOut))
    fprintf(<span class="string">'   dif = %5.3f \n'</span>,seti.dif(iOut))
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p><b>Subfunction: saveqROI</b></p><p>Saves the reconstructed contrast <tt>qROIcomp</tt> and the stop index <tt>iOutStop</tt> in a file <tt>seti.saveqROIcomp</tt>.</p><pre class="codeinput"><span class="keyword">function</span> seti = saveqROI(seti)
    disp(<span class="string">' '</span>)
    disp(<span class="string">'# Save qROIcomp for further calculations'</span>)
    qROIcomp = seti.qROIcomp; <span class="comment">%#ok (suppress MATLAB warning, because will be saved.)</span>
    iOutStop = seti.iOutStop; <span class="comment">%#ok (suppress MATLAB warning, because will be saved.)</span>
    save(seti.saveqROIcomp,<span class="string">'qROIcomp'</span>,<span class="string">'iOutStop'</span>); <span class="comment">% save qROIcomp and iOutStop</span>
    clear <span class="string">qROIcomp</span> <span class="string">iOutStop</span>;
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% recon
% Variational reconstruction of the contrast.
%
%% Syntax
%
%   seti = recon(seti)
%   seti = recon(seti,dispDepth)
%   seti = recon(seti,dispDepth,out)
%
%% Description
% |seti = recon(seti)| 
% does the variational reconstruction of the contrast by
% minimizing the Tikhonov functional 
% by _soft-shrinkage_ or _primal-dual algorithm_.
%
% |seti = recon(seti,dispDepth)| does the same as |seti =
% recon(seti)|, but the depth of displayed messages is controlled by
% |dispDepth|.
%
% |seti = recon(seti,dispDepth,out)| does the same as |seti = recon(seti,dispDepth)| in 
% case of |out = 0|, but plots the figures in case of |out = 1| and 
% additionally saves them in case of |out = 2|.
%
% * In public version only primal-dual algorithm is available.
% * The result is the contrast |seti.qROIcomp| after |seti.iOutStop| 
% outer iterations.
% * The reconstruction is plotted in case of |out = 1| and in case of 
%   |out = 2| additionally stored in the folder output.
%
% * The reconstruction is stopped after maximal |seti.nOut| iterations.
% * If |seti.useDis = 1| and a tolerance parameter |seti.tau > 1| was set,
% the reconstruction is stopped by *discrepancy principle*, i.e.
%
% stop if discrepancy $\leq$ $\texttt{seti.tau*seti.delta}$.
%
% * If |seti.loadqROIcomp| is not empty, 
% a path to a mat-file is expected, that contains 
% the reconstruction result |qROIcomp| after |iOutStop| outer iterations 
% from a previous computation. Then this file is loaded. 
% Further, the contrast and the stop index of outer iteration are set as 
% initial contrast |seti.qROIcomp| and iteration number |seti.iOutIni| 
% for current computation.
%
% * If |seti.saveqROIcomp| is not empty (i.e. |''| or |[]|), a filename to save 
% |qROIcomp| and |iOut| is expected. Default in <checkConsisRec.html> is
%
%  sprintf('%s/save_qROIcomp_iOutStop%s.mat',seti.dirname,seti.fileSuffix)
%
% (i.e. the mat-file is stored in the same folder as the figures).
% Then |seti.qROIcomp| and |seti.iOutStop| are saved as |qROIcomp| and
% |iOutStop|.
%
% * If |seti.savedata| is 1 (default: 0), 
%   relative discrepancies, errors, and differences of iterated contrasts
%   are saved in mat-files in the folder of the
%   figures (filenames are essentially save_dis.mat, save_err.mat, save_dif.mat.)
%
%
% *Structure of this file*
%
% # Optional: loads reconstruction result from previously computation.
% # Initialization.
% # Evaluation of previous outer iteration.
%   (Stop if maximal number of iterations is reached or 
%   discrepancy principle is fullfilled (optional)).
% # Plot results from previous outer iteration 
%   and stores them in folder output (optional, depends on argument |out|).
% # Compute next step (minimization by soft-shrinkage or primal-dual algorithm). Go to 3.
% # Optional: save discrepancy, error and reconstruction results.
%
%
%% Example
%
% *Example 1*
%
%   init;                   % Initialization (addpath...)
%   seti = struct;
%   seti = setData(seti);   % Set data: (experimental data, geometry, exact and noisy data)
%   seti = setRecon(seti);  % Settings for variational reconstruction
%   seti = recon(seti);     % Variational reconstruction (process)
%
% *Example 2*
%
% This example does the same as the first one, but displays more messages.
%
%   init;                     % Initialization (addpath...)
%   seti = struct;
%   seti = setData(seti,4);   % Set data: (experimental data, geometry, exact and noisy data)
%   seti = setRecon(seti,4);  % Settings for variational reconstruction
%   seti = recon(seti,4);     % Variational reconstruction (process)
%
% *Example 3*
%
% The example is essentially the code in start.m (<start.html>) 
% because we need previously definitions.
%
% Warning: variables are cleared and figures as well as files are saved
% without demand.
%
% The results are stored in the folder output.
%
%   init;                       % Initialization (addpath...)
%   setInput;                   % Set input and make directories for output
%   seti = setData(seti,4,2);   % Set data: (experimental data, geometry, exact and noisy data)
%   seti = setRecon(seti,4);    % Settings for variational reconstruction
%   seti = recon(seti,4,2);     % Variational reconstruction (process)
%
%% Input Arguments
%
% * |seti|    :   structure array
%
% Because this is a internal function we do not explain all fields in seti.
%
% * |seti.loadqROIcomp| : Path to load a mat-file containing the reconstructed 
%                         contrast |qROIcomp| after |iOutStop| outer iterations 
%                         (default: empty, i.\,e. |''| or |[]|, then no data is loaded).
% * |seti.saveqROIcomp| : Optional: Path to save reconstructed contrast
%                         (default: same folder as figures, i.e. 
%                         |sprintf('%s/save_qROIcomp_iOutStop%s.mat',seti.dirname,seti.fileSuffix)|)
%
% * |seti.nOut|         : Maximal number of outer iterations.
%
% * |seti.useDis|       : Use discrepancy principle to stop outer iteration?
%                         (If yes set it to 1.)
% * |seti.tau|          : Tolerance parameter for discrepancy principle
%                         (seti.tau > 1).
%
% * |seti.plotFreq|     : Frequency to plot figures of outer iteration steps
%                         (0: no figures).
% * |seti.savedata|     : If it is set to 1,
%                         relative discrepancies, errors, and differences 
%                         of iterated contrasts are saved
%                         (as |save_dis.mat|, |save_err.mat| and |save_dif.mat|).
%
% * |seti.qROIexact|    : Predefined (exact) contrast
%                         (complex vector of |size seti.nROI|^|seti.dim| x 1).
%
% *Further specific input parameters* for primal-dual algorithm can be found in
% <minPda.html> and <pda.html>.
%
% *Optional Input Argument*
%
% * |dispDepth|     : depth of displayed text.
%                     (from 0 to 5, default sparse: 2; default details: 4; too much information: 5);
% * |out|           : output depth for figures and files: no figure (0), plot figure (1), 
%                     save figures and files (2).
%                     (This argument requires that argument |dispDepth| was
%                     defined.)
%
%% Output Arguments
%
% * |seti|    :   structure array
%
% Because this is a internal function we do not explain all fields in seti.
%
% * |seti.qROIcomp|     : Reconstructed contrast
%                         (complex vector of size |seti.nROI|^|seti.dim| x 1).
% * |seti.iOutStop|     : Stop index of outer iterations.
%
%
% *Discrepancy, error, and difference*
%
% * |seti.dis|        : Relative discrepancy for each outer iteration
%                       (vector of size 1 x seti.nOut).
% * |seti.err|        : Relative error for each outer iteration
%                       (vector of size 1 x seti.nOut).
% * |seti.dif|        : Relative difference of iterated contrast qROI to previously qROI
%                       for each outer iteration
%                       (vector of size 1 x seti.nOut).
%
% Note that |seti.dis(iOut)| is the relative discrepancy 
% _after_ iteration |iOut|. (Analog seti.err(iOut) and seti.dif(iOut).)
%
% *Minimized Tikhonov functional*
%
% * |seti.MTv|        :   Result of minimized Tikhonov functional 
%                         for each outer iteration 
%                         (vector of size 1 x seti.nOut).
% * |seti.M1v|        :   Result of first part of min. functional
%                         for each outer iteration 
%                         (vector of size 1 x seti.nOut).
% * |seti.M2v|        :   Result of second part of min. functional 
%                         for each outer iteration 
%                         (vector of size 1 x seti.nOut).
%
% _More about M1v and M2v_
%
% * In case of primal-dual algorithm (i.e. |seti.inv = 'pda'|)
%   |M1v| is F and |M2| is G, see <pda.html> for F and G.
% * In case of shrinkage (i.e. |seti.inv = 'shrinkage'|)
%   (not available in public version) 
%   |M1| = discrepancy and |M2| = sparsity (setFuncsShrink.m)
%
% *structure array pdas*
%
% * |pdas|        : Structure array
%                   (only in case of pda, i.e. |seti.inv = 'pda'|).
%
% * |pdas.disLin| : Last relative discrepancy of linearized problem in inner iteration of pda
%                   for each outer iteration 
%                   (vector of size 1 x seti.nOut).
% * |pdas.relDis| : Quotient disLin/dis 
%                   for each outer iteration
%                   (rel. discrepancy of linearized problem / rel. discrepancy of the non-linearized problem)
%                   (vector of size 1 x seti.nOut).
% * |pdas.pdaNv|  : Number of inner iterations for each outer iteration
%                   (vector of size 1 x seti.nOut).
% * |pdas.ThetaiOutV| : Inner tolerance for each outer iteration
%                       (in case of inner tolerance principle, see
%                       <minTolIn.html>).
%
% *Further output arguments*
%
% * |seti.disIni|   : Relative discrepancy before 1st iteration.
% * |seti.errIni|   : Relative error before 1st iteration.
%
%
%% Output Figures
%
% The functions in the code, that plot figures are:
%
% * subplots            :   figure 11
% * plotAndSaveFigures  :   figures 12-16 and in 3D case figures 21-26
% * pdaPlot             :   figures 31REPLACE_WITH_DASH_DASH36
%
% A description of all figures in the package are in <start.html>, Section
% "Output: Figures".
%
% Note that the creation and saving of plots also depends on the input
% argument |out|.
%
%
%% More About
%
% The outer iteration of the variational reconstruction process is
% briefly described in <start.html>, Section "More About". More information
% are available in [1].
%
% The primal-dual algorithm and its application to the inverse scattering
% problem is briefly described in <pda.html>, Section "More About". For
% further information of application see Section 4 in [1]. For details in
% context of primal-dual algorithm see [2].
%
% The initial contrast |seti.qROIcomp| is set to zero if no contrast is
% loaded from a previous reconstruction. 
%
%
%% References
% * [1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. _Journal of Computational Physics_, 339:1-30, 2017.
% * [2] Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. _Journal of Mathematical Imaging and Vision_, 40(1):120-145, 2011.
%
%% See Also
%
% * <start.html>
% * <pda.html>
% * <setFuncsPda.html>
% * <minPda.html>
% * <minTolIn.html>
%
%% Code
%
function seti = recon(seti,varargin)

if nargin == 2
    dispDepth = varargin{1};
    out = 0;
elseif nargin == 3
    dispDepth = varargin{1};
    out = varargin{2};
else
    dispDepth = 0;
    out = 0;
end

%%
% *Optional: loads reconstruction result from a previous computation.*
%
if ~isempty(seti.loadqROIcomp)
    disp('# Loading qROI from previous calculation.')
% REPLACE_WITH_DASH_DASH load old: start REPLACE_WITH_DASH_DASH
%     load(sprintf('%s',seti.loadqROIcomp)); % qROIcomp and iOutStop are inside
%     seti.qROIcomp = qROIcomp;
%     seti.iOutIni = iOutStop;
%     clear qROIcomp iOutStop;
% REPLACE_WITH_DASH_DASH load old: end REPLACE_WITH_DASH_DASH
% REPLACE_WITH_DASH_DASH load new: start REPLACE_WITH_DASH_DASH
    sloaded = load(sprintf('%s',seti.loadqROIcomp)); % qROIcomp and iOutStop are inside (sloaded: struct)
    seti.qROIcomp = sloaded.qROIcomp;
    seti.iOutIni = sloaded.iOutStop;
    clear sloaded;
% REPLACE_WITH_DASH_DASH load new: end REPLACE_WITH_DASH_DASH
else
    seti.qROIcomp = zeros(size(seti.qROIexact));
    seti.iOutIni = 0;
end

% FmeasDelta = seti.FmeasDelta; % perturbed data.
% If you call pertuped data, use consequently seti.FmeasDelta,
% if you are not in a function.

%%

% REPLACE_WITH_DASH_DASH iteration - start with q_0 = 0 or loaded qROI
seti = minimization(seti,out,dispDepth);

end

%% Code: subfunction: minimization
%
function seti = minimization(seti,out,dispDepth)

if dispDepth >= 1
    disp(' ')
    fprintf('   Remind: alpha = %g\n',seti.alpha);
    fprintf('   Remind: beta  = %g\n',seti.beta);
end

% qROIexact = seti.qROIexact; % use consequently seti.qROIexact
% qROIcomp = seti.qROIcomp; % use consequently seti.qROIcomp

seti.dis = zeros(1,seti.nOut); % seti.dis(iOut) = relative discrepancy after iOut
seti.err = zeros(1,seti.nOut); % seti.err(iOut) = relative error after iOut
seti.dif = zeros(1,seti.nOut); % seti.dif(iOut) = relative difference of iterated qROI to previously qROI after iOut

seti.MTv = zeros(1,seti.nOut); % results of minimized Tikhonov functional
seti.M1v = zeros(1,seti.nOut); % results of first part of min. functional
seti.M2v = zeros(1,seti.nOut); % results of second part of min. functional

if strcmp(seti.inv,'pda')
    pdas.disLin = ones(1,seti.nOut); % store results of last relative lin. discrepancy in inner iteration of pda
    pdas.relDis = zeros(1,seti.nOut); % disLin/dis (not in pda, but outside)

    pdas.pdaNv = zeros(1,seti.nOut); % number of inner iterations in each outer iteration
    pdas.ThetaiOutV = zeros(1,seti.nOut);
end

%%
% *minimization: Initialization*
%
ticMin = tic;

iOut = seti.iOutIni; % outer iteration
% (default: 0; higher if previously computed qROI is used; is set in start.m)

% initial input is seti.qROIcomp
if dispDepth >= 1
    disp(' ')
    fprintf(' - iOut = %02d (initial, no reconstruction done)\n',iOut); % initial...
end
if iOut ~= 0
    FFqMeas = mimo(seti, seti.qROIcomp, 'simo'); % only needed to compute dis
    seti.disIni = compDis(seti,FFqMeas,seti.FmeasDelta); % relative discrepancy before 1st iteration
    seti.errIni = compErr(seti.qROIexact,seti.qROIcomp); % relative error before 1st iteration
else
    if dispDepth >= 1
        disp('   Because iOut == 0 set disIni = 1 and errIni = 1 (otherwise compute them).')
    end
    seti.disIni = 1;
    seti.errIni = 1;
end
if dispDepth >= 1
    fprintf('   disIni = %g \n',seti.disIni)
    fprintf('   errIni = %g \n',seti.errIni)
end

if ~exist('ilast','var')
    ilast = false;
end

while 1
    %% 
    % *minimization: Evaluation of previous outer iteration*

    % qROIcomp: real and imag
    if dispDepth >= 1
        fprintf('   qROIcomp: real [%+3.2f,%+3.2f], imag [%+3.2f,%+3.2f].\n',...
            min(real(seti.qROIcomp)),max(real(seti.qROIcomp)),min(imag(seti.qROIcomp)),max(imag(seti.qROIcomp)));
        fprintf('   qROIexact: real [%+3.2f,%+3.2f], imag [%+3.2f,%+3.2f].\n',...
            min(real(seti.qROIexact)),max(real(seti.qROIexact)),min(imag(seti.qROIexact)),max(imag(seti.qROIexact)));
    end
    
    if iOut == seti.iOutIni
        dis = seti.disIni;
    else
        dis = seti.dis(iOut);
    end
    [ibreak,seti.iOutStop] = reconStop(seti,iOut,dis,dispDepth);

    if ilast == true
        seti.iOutStop = iOut;
        ibreak = true;
    elseif ilast == false && isfield(seti,'pdaNlast') && seti.pdaNlast > 0
        if iOut == seti.nOut-1 % set ilast = true because last iteration will follow
            disp(' ')
            disp('   seti.pdaNlast > 0. The last iteration will done by a higher number of inner iterations.')
            seti.pdaN = seti.pdaNlast; % pdaN is overwritten for the last step.
            ibreak = false;
            ilast = true;
        elseif ibreak == true % in the case of discrepancy principle
            disp(' ');
            fprintf('   Start the last outer iteration with %g inner iterations.\n', seti.pdaNlast)
            seti.pdaN = seti.pdaNlast; % pdaN is overwritten for the last step.
            ibreak = false;
            ilast = true;
        end
    end


    %% 
    % *minimization: Plot results from previous outer iteration*
    %
    % The figures are described in <start.html>.
    %
    if (out >= 1 && seti.plotFreq ~= 0 &&...
            (iOut == 1 || ibreak == true || (isfield(seti,'pdaNlast') && seti.pdaNlast > 0 && iOut == seti.nOut-1)...
             || ilast == true || floor(iOut/seti.plotFreq) == iOut/seti.plotFreq))
    % condition "iOut == seti.nOut-1" etc. to plot the step before the last step (interesting in the case of pdaNlast...) 
    
        if iOut ~= seti.iOutIni
            subplots(seti,seti.qROIexact,seti.qROIcomp,iOut); % figure 11
        end
        plotAndSaveFigures(seti,seti.qROIexact,seti.qROIcomp,iOut,out); % save figure 11; generate figures 12REPLACE_WITH_DASH_DASH16 and in 3D case 21REPLACE_WITH_DASH_DASH26
        
        if iOut > 0 && strcmp(seti.inv,'pda') && isfield(pdas,'pdaStopInd')
            pdaPlot(iOut,seti,pdas,out) % figures 31REPLACE_WITH_DASH_DASH36
        end
    end

    % time
    if iOut ~= seti.iOutIni
        tocOut = toc(ticOut);
        if dispDepth >= 1
            disp(' ')
            fprintf('   Elapsed time of outer minimization iOut = %03d is %05.1f min.\n',iOut,tocOut/60);
        end
        
        tocMin = toc(ticMin);
        if dispDepth >= 1
            disp(' ')
            fprintf('   Elapsed time of overall minimization process is %05.1f min.\n',tocMin/60);
        end
    end
    
    if ibreak == true
        break;
    end
    % break does mean: result is seti.qROIcomp after iOut iterations

    %% 
    % *minimization: Compute next step*
    %
    % (The new contrast "qROInew" is seti.qROIcomp after minShrink or minPda.)

    ticOut = tic;
    iOut = iOut + 1;
    if dispDepth >= 1
        disp(' ')
        fprintf(' - iOut = %02d\n',iOut);
    end
    
    switch seti.inv
        case 'shrinkage'
            % Note that the case seti.inv = 'shrinkage' is not available in
            % public version.
            if iOut == seti.iOutIni+1
                ADFFqPrev = zeros(seti.nROI^seti.dim,1); % to have a value
                qROIcompPrev = zeros(seti.nROI^seti.dim,1); % to have a value
            end
            % ADFFqPrev is needed in minShrink in case of Barzilai-Borwein
            [seti,FFqMeas,qROIcompPrev,ADFFqPrev] = minShrink(seti,iOut,seti.qROIcomp,qROIcompPrev,ADFFqPrev);
        case 'pda'
            if dispDepth >= 2
                disp('    - Start minimization by PDA')
            end
            if iOut == seti.iOutIni + 1 % otherwise it is done after pda algorithm
                FFqMeas = mimo(seti, seti.qROIcomp,'simo'); % needs upscaled qROI
            end
            qROIcompPrev = seti.qROIcomp;
            [seti,FFqMeas,pdas] = minPda(seti,iOut,seti.qROIcomp,pdas,FFqMeas,dispDepth);
    end
    % output: seti.qROIcomp (new reconstructed contrast after step iOut)
    
    % *Compute discrepancy, error and difference*
    %
    seti = disErrDif(FFqMeas,qROIcompPrev,seti,iOut,dispDepth);

    % *Compute quotient disLin/dis*
    % disLin/dis = rel. discrepancy of linearized problem / rel. discrepancy of the non-linearized problem
    %
    if iOut > 0 && strcmp(seti.inv,'pda')
        pdas.relDis(iOut) = pdas.disLin(iOut)/seti.dis(iOut);
        if dispDepth >= 3
            fprintf('   relDis = %5.3f \n',pdas.relDis(iOut));
        end
    end

end

%%
% *minimization: Optional: save relative discrepancies, errors, and differences of iterated contrasts*
%
if out == 2
    savedata(seti,seti.dis,seti.err,seti.dif);
end

% *Optional: save reconstructed contrast qROIcomp and stop index iOutStop
% for further computations*
%
if out == 2 && isfield(seti,'saveqROIcomp') && ~isempty(seti.saveqROIcomp)
    saveqROI(seti);
end

end

%% Code: Further Subfunctions

%%
% *subfunction: savedata*
%
% Save relative discrepancies, errors, and differences of iterated contrasts.
%
function savedata(seti,dis,err,dif)

if seti.savedata
    % Remove zeros from dis, err, and dif.
    % (dis ~= 0) or 1:iOutStop... should work too...
    disNonZeros = dis(dis ~= 0); %#ok (suppress MATLAB warning, because will be saved.)
    errNonZeros = err(err ~= 0); %#ok (suppress MATLAB warning, because will be saved.)
    difNonZeros = dif(dif ~= 0); %#ok (suppress MATLAB warning, because will be saved.)
    %  Save relative discrepancies, errors, and differences of iterated contrasts.
    save(sprintf('%s/save_dis%s.mat',seti.dirname,seti.fileSuffix),'disNonZeros');
    save(sprintf('%s/save_err%s.mat',seti.dirname,seti.fileSuffix),'errNonZeros');
    save(sprintf('%s/save_dif%s.mat',seti.dirname,seti.fileSuffix),'difNonZeros');
    clear disNonZeros;
    clear errNonZeros;
    clear difNonZeros;
end
end

%%
% *Subfunction: reconStop*
%
% Stops the reconstruction process, when maximal number of outer iterations
% |seti.nOut| is reached or discrepancy principle is fullfilled (optional).
%
function [ibreak,iOutStop] = reconStop(seti,iOut,dis,dispDepth)

if iOut == seti.nOut
    iOutStop = iOut;
    if dispDepth >= 1
        disp(' ')
        fprintf('   Reconstruction stopped after %0d outer iterations (max. number reached).\n',iOutStop)
    end
    ibreak = true;
end

if iOut > 0 && isnan(dis)
    iOutStop = iOut;
    if dispDepth >= 1
        disp(' ')
        fprintf('   Reconstruction stopped after %0d outer iterations (discrepancy not a number).\n',iOutStop);
    end
    ibreak = true;
end

if iOut > 0 && seti.useDis == 1 && (dis <= seti.tau*seti.delta)
    iOutStop = iOut;
    if dispDepth >= 1
        disp(' ')
        fprintf('   Reconstruction stopped after %0d outer iterations (by discrepancy principle).\n',iOutStop);
    end
    ibreak = true;
end

if ~exist('ibreak','var')
    ibreak = false;
end

if ~exist('iOutStop','var')
    iOutStop = [];
end

end

%%
% *Subfunction: compDis*
%
% Computes relative discrepancy
%
function dis = compDis(seti,FFqMeas,FmeasDelta)
dis = normws(FFqMeas-FmeasDelta,seti)/normws(FmeasDelta,seti); % relative discrepancy
end

%%
% *Subfunction: compErr*
%
% Computes relative error
%
function err = compErr(qROIexact,qROIcomp)
err = norm(qROIexact-qROIcomp,2)/norm(qROIexact,2); % relative error in 2-Norm
end

%%
% *Subfunction: disErrDif*
%
% Computes, stores and displays:
%
% * realtive discrepancy,
% * relative error, and
% * relative difference of iterated contrast to previous one
%

function seti = disErrDif(FFqMeas,qROIcompPrev,seti,iOut,dispDepth)
% relative discrepancy
seti.dis(iOut) = compDis(seti,FFqMeas,seti.FmeasDelta);
clear FFqmF;
% relative error
seti.err(iOut) = compErr(seti.qROIexact,seti.qROIcomp);
% relative difference of iterated qROI to previously qROI
seti.dif(iOut) = normroi(seti.qROIcomp-qROIcompPrev,seti)/normroi(seti.qROIcomp,seti);
% display:
if dispDepth >= 2
    fprintf('   dis = %5.3f \n',seti.dis(iOut))
    fprintf('   err = %5.3f \n',seti.err(iOut))
    fprintf('   dif = %5.3f \n',seti.dif(iOut))
end
end

%%
% *Subfunction: saveqROI*
%
% Saves the reconstructed contrast |qROIcomp| and the stop index |iOutStop|
% in a file |seti.saveqROIcomp|.
%
function seti = saveqROI(seti)
    disp(' ')
    disp('# Save qROIcomp for further calculations')
    qROIcomp = seti.qROIcomp; %#ok (suppress MATLAB warning, because will be saved.)
    iOutStop = seti.iOutStop; %#ok (suppress MATLAB warning, because will be saved.)
    save(seti.saveqROIcomp,'qROIcomp','iOutStop'); % save qROIcomp and iOutStop
    clear qROIcomp iOutStop;
end

##### SOURCE END #####
--></body></html>