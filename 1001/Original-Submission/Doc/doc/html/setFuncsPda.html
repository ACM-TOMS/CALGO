
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>setFuncsPda</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-30"><meta name="DC.source" content="setFuncsPda.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>setFuncsPda</h1><!--introduction--><p>Set functions required in primal-dual algorithm (pda.m).</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Input Arguments</a></li><li><a href="#4">Output Arguments</a></li><li><a href="#5">More About</a></li><li><a href="#6">References</a></li><li><a href="#7">See Also</a></li><li><a href="#8">Code: setFuncsPda</a></li><li><a href="#9">Code: subfunction: potPotNum</a></li><li><a href="#10">Code: subfunction: setminfParts</a></li><li><a href="#17">Code: subfunction: setminfPartsWavelet</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">seti = setFuncsPda(seti)
</pre><h2 id="2">Description</h2><p><tt>seti = setFuncsPda(seti)</tt> sets functions in structure array <tt>seti</tt>, that are required in primal-dual algorithm, see <a href="pda.html">pda.html</a>. Therefore this function is called in setRecon.m, see <a href="setRecon.html">setRecon.html</a>.</p><h2 id="3">Input Arguments</h2><div><ul><li>seti    :   structure array</li></ul></div><h2 id="4">Output Arguments</h2><div><ul><li>seti    :   structure array</li></ul></div><p>For the fields of the structrual array <tt>seti</tt> see the section "More About".</p><h2 id="5">More About</h2><p>We only give a overview of the functions. See also <a href="pda.html">pda.html</a>. Detailed information are in Section 4.5 in [1].</p><p>Note that grid scaling is respected in the code, but for simplicitiy is not presented in the formulas.</p><p><b>Auxiliary quantities</b></p><p>For <img src="setFuncsPda_eq08693472390149360398.png" alt="$\texttt{seti.S} = T_{\bf{C}\to\bf{R}^2}$"> and <img src="setFuncsPda_eq09451177321936060719.png" alt="$\texttt{seti.T} = T_{\bf{R}^2\to\bf{C}}$">, see "More About" in <a href="pda.html">pda.html</a>.</p><div><ul><li><img src="setFuncsPda_eq17637375530191488658.png" alt="$\texttt{seti.Kd} = K_\mathrm{dis} :=   T_{\bf{C}\to\bf{R}^2} [\mathcal{F}'(T_{\bf{R}^2\to\bf{C}}\ q)]T_{\bf{R}^2\to\bf{C}}$">,</li><li><img src="setFuncsPda_eq16938998143789232994.png" alt="$\texttt{seti.vd} = v_\mathrm{dis} :=   T_{\bf{C}\to\bf{R}^2}(\mathcal{F}(T_{\bf{R}^2\to\bf{C}}\ q)-F_\mathrm{meas}^\delta)$">,</li><li><img src="setFuncsPda_eq02825363139747132373.png" alt="$\texttt{seti.Kg} = K_\mathrm{tv}  :=   \beta\,T_{\bf{C}\to\bf{R}^2}\nabla T_{\bf{R}^2\to\bf{C}}$"></li><li><img src="setFuncsPda_eq05078065785412364417.png" alt="$\texttt{seti.vg} = v_\mathrm{tv} :=   \beta\, T_{\bf{C}\to\bf{R}^2} \nabla T_{\bf{R}^2\to\bf{C}}\ q$">.</li></ul></div><p>Note that the names <tt>Kg</tt> and <tt>vg</tt> were choosen because the appearance of the gradient.</p><p><b>Parts of functional to minimize</b></p><div><ul><li><img src="setFuncsPda_eq15175230372041173335.png" alt="$\texttt{seti.fd} = f_\mathrm{dis}(h) :=   \frac{1}{2} \|K_\mathrm{dis} h+  v_\mathrm{dis} \|_{\mathrm{dis},\bf{R}}^2$">   <img src="setFuncsPda_eq14974224158754676687.png" alt="$\quad$"> is the discrepancy (linearized problem),</li><li><img src="setFuncsPda_eq04901215922585328928.png" alt="$\texttt{seti.fs} = f_\mathrm{spa}(h) :=   \alpha \| h + q\|_{\mathrm{spa}, \bf{R}}$">   <img src="setFuncsPda_eq14974224158754676687.png" alt="$\quad$"> is the sparsity penalty,</li><li><img src="setFuncsPda_eq07387345009002004759.png" alt="$\texttt{seti.fg} = f_\mathrm{tv}(h) :=   \|K_\mathrm{tv} h + v_\mathrm{tv} \|_{\mathrm{tv},\bf{R}}$">   <img src="setFuncsPda_eq14974224158754676687.png" alt="$\quad$"> is the TV-penalty,</li><li><img src="setFuncsPda_eq15868304027089988726.png" alt="$\texttt{seti.fp} = f_\mathrm{phy}(h) :=   \delta_{[a,b,c,d]}(h + q)$">   <img src="setFuncsPda_eq14974224158754676687.png" alt="$\quad$"> is the penalty for physical bounds.</li></ul></div><p>Note that <img src="setFuncsPda_eq05585738636747232515.png" alt="$\delta_{[a,b,c,d]}(x)$"> is a indicator function, i.e. is 0, if all entries of the vector <img src="setFuncsPda_eq12045799382761315906.png" alt="$\mathrm{real}(x)$"> are between <img src="setFuncsPda_eq05508344529756732484.png" alt="$a$"> and <img src="setFuncsPda_eq02044268985122151499.png" alt="$b$"> and all entries of the vector <img src="setFuncsPda_eq15408084442914943985.png" alt="$\mathrm{imag}(x)$"> are between <img src="setFuncsPda_eq08422257486649890878.png" alt="$c$"> and <img src="setFuncsPda_eq17615571056258974497.png" alt="$d$">; and is <img src="setFuncsPda_eq16739024125614530807.png" alt="$\infty$">, otherwise.</p><p><b>Definition of parts of Tikhonov functional</b></p><p>The Tikhonov functional is <tt>MT = M1 + M2</tt>. Function <img src="setFuncsPda_eq08597826192214703288.png" alt="$F$"> is <img src="setFuncsPda_eq17040488434551444591.png" alt="$M_1$">, function <img src="setFuncsPda_eq07365524530707038546.png" alt="$G$"> is <img src="setFuncsPda_eq17449863970030415324.png" alt="$M_2$"> (with <img src="setFuncsPda_eq08597826192214703288.png" alt="$F$"> and <img src="setFuncsPda_eq07365524530707038546.png" alt="$G$"> from PDA) This is done in function <tt>minPda</tt> (<a href="minPda.html">minPda.html</a>) when function <tt>pda</tt> (<a href="pda.html">pda.html</a>) is called.</p><p><b>Further comments (in particular, interesting in not public version)</b></p><div><ul><li>In case of inversion by pda, it is always (automatically) set   <tt>seti.pNorm = 2</tt> and <tt>seti.qNorm = 1</tt> (except for invNo = 7), see   <a href="setInvType.html">setInvType.html</a>.</li><li>Exponent p of the discrepancy term, see <a href="setInvType.html">setInvType.html</a>, is usually   <tt>seti.p = 2</tt>.   In case of shrinkage or pda with wavelets it may differ, see   <a href="setInvType.html">setInvType.html</a>.</li><li><tt>vs</tt> and <tt>vp</tt> in term <img src="setFuncsPda_eq07365524530707038546.png" alt="$G$">: If you choose <tt>vs</tt> and <tt>vp</tt> manually and   <tt>fs</tt> and <tt>fp</tt> belong to term <img src="setFuncsPda_eq07365524530707038546.png" alt="$G$">, then <tt>vs = vp</tt> is required.</li></ul></div><h2 id="6">References</h2><div><ul><li>[1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. <i>Journal of Computational Physics</i>, 339:1-30, 2017.</li></ul></div><h2 id="7">See Also</h2><div><ul><li><a href="setRecon.html">setRecon.html</a></li><li><a href="pda.html">pda.html</a></li><li><a href="setInvType.html">setInvType.html</a></li></ul></div><h2 id="8">Code: setFuncsPda</h2><pre class="codeinput"><span class="keyword">function</span> seti = setFuncsPda(seti)

<span class="comment">% Definition of parts of function to minimize (f = minf)</span>
<span class="comment">% parts for reconstruction process</span>
seti = setminfParts(seti);
<span class="keyword">if</span> seti.useWavelet == 1 <span class="comment">% not available in public version</span>
    seti = setminfPartsWavelet(seti);
<span class="keyword">end</span>

<span class="keyword">end</span>
</pre><h2 id="9">Code: subfunction: potPotNum</h2><p>Numerical potential pot function.</p><pre class="codeinput"><span class="keyword">function</span> [d1,d2] = potPotNum(seti)
infty = 1E5;
dp = @(a,b,x) 0.* and((a&lt;=x),(x&lt;=b))+infty.*or((x&lt;a),(b&lt;x)); <span class="comment">% potential pot function</span>
d =  @(a,b,x) max(dp(a,b,x)); <span class="comment">% d = 0 if ALL entries are between a and b, otherwise d = \infty</span>
<span class="comment">% max because d = \infty if ONE entry of x \notin [a,b]</span>
clear <span class="string">infty</span>

l = seti.physBounds;
reMin = l(1); reMax = l(2); imMin = l(3); imMax = l(4);
tol = seti.tolDelta;
d1 = @(x) d(reMin-tol,reMax+tol,x); <span class="comment">% limits for real part</span>
d2 = @(x) d(imMin-tol,imMax+tol,x); <span class="comment">% limits for imag part</span>
<span class="comment">% tol important because e.g. (min(real(qROI))+1) = -2.2204e-16</span>
clear <span class="string">l</span> <span class="string">a</span> <span class="string">b</span> <span class="string">c</span>
<span class="keyword">end</span>
</pre><h2 id="10">Code: subfunction: setminfParts</h2><div><ul><li><img src="setFuncsPda_eq18007680180051843906.png" alt="$K: X \to Y$"></li><li>Y: depends on function <tt>Ki</tt> (<tt>Ki</tt> i.e. <tt>Kd</tt>, <tt>Kg</tt>, ...)</li><li>X: xnRVD (this means real vector downscaled):    size of elements: 2*seti.nInv^seti.dim</li><li><tt>hs</tt> was <tt>xnRVU</tt></li><li><tt>q</tt> is standard in qCVU (is fixed in pda),   but you can use qCVD etc. too, if you have them as argument</li></ul></div><pre class="codeinput"><span class="keyword">function</span> seti = setminfParts(seti)
</pre><p><b>f_d</b></p><div><ul><li>Remember that <tt>DFFq = @(xnRVD) JA*diag(seti.GU(seti.T(xnRVD)))*JB;</tt></li><li>The difference to DFFq is that finally <tt>seti.S</tt> is used.</li></ul></div><pre class="codeinput"><span class="keyword">if</span> strcmp(seti.model,<span class="string">'helmholtz2D'</span>) || strcmp(seti.model,<span class="string">'helmholtz3D'</span>)
    seti.Kd = @(xnRVD,JA,JB) seti.S(JA*diagsparse(seti.GU(seti.T(xnRVD)))*JB); <span class="comment">% K_d(h) = S(\F'(q)[GU(T(h_S))]) %real</span>
<span class="keyword">elseif</span> strcmp(seti.model,<span class="string">'helmholtzHMode2D'</span>)
    seti.Kd = @(xnRVD,JA,JB) seti.S( JA(:,:,1)*diagsparse(seti.GU(seti.T(xnRVD)))*JB(:,:,1) <span class="keyword">...</span>
        + JA(:,:,2)*diagsparse(seti.GU(seti.T(xnRVD)))*JB(:,:,2) ); <span class="comment">% K_d(h) = S(\F'(q)[GU(T(h_S))]) %real</span>
<span class="keyword">else</span>
    fprintf(<span class="string">'Error in setFuncs - pda not implemented for model %s.\n'</span>,  seti.model)
<span class="keyword">end</span>
<span class="comment">% Finally: Kd(x): R^{2 nInv^dim} -&gt; R^{2 measNb x incNb}</span>
<span class="comment">% Kd = \F'(q) (from mimo \F'(q): JA*diag(h)*JB = \F'(q)[h])</span>
seti.KdAdj = @(yd,JA,JB) seti.S(seti.GD(ADFFqFast(seti.T(yd),JA,JB,seti)));
seti.vd = @(FFq) seti.S(FFq-seti.FmeasDelta); <span class="comment">% 2* measNb x incNb</span>
seti.fd = @(DFFqh,FFq) (1/2)*normws(seti.S(DFFqh)+seti.vd(FFq),seti)^2;
</pre><p><b>f_s</b></p><pre class="codeinput">seti.vs = @(qCVU) seti.S(seti.GD(qCVU));
seti.fs = @(qCVU,xnRVD) seti.alpha*normroi(xnRVD+seti.vs(qCVU),seti);
</pre><p><b>f_g</b></p><pre class="codeinput">seti.Kg = @(xnRVD) seti.beta*gradientNeumann(xnRVD,seti.hInv,seti.nInv,seti.GInv,seti); <span class="comment">% K_g</span>
<span class="comment">%seti.KgAdj = @(yg) -seti.beta*div(yg,seti); % Note that this is wrong(!) (although analytically correct)</span>
seti.KgAdj = @(yg) seti.beta*gradientNeumannAdj(yg,seti); <span class="comment">%yg is 2*dim x nInv x nInv (x nInv)</span>
seti.vg = @(qCVU) seti.Kg(seti.S(seti.GD(qCVU)));
seti.fg = @(qCVU,xnRVD) normTVinv1(seti.Kg(xnRVD)+seti.vg(qCVU),seti); <span class="comment">%f_g(x) = ||beta*\nabla x + v_g)||_\tv (gradient sparsity)</span>
</pre><p><b>f_p</b></p><div><ul><li>Note that seti.vp = seti.vs is important because of prox Gsp   (prox Gsp does mean that the term G consists of fs and fp.   To compute the proximal mapping of G the equality of vp and vs is   required!)</li></ul></div><pre class="codeinput">[d1,d2] = potPotNum(seti);
<span class="comment">%seti.fp = @(q,hz) d1(real(q)+real(hz)) + d2(imag(q)+imag(hz));</span>
<span class="comment">% use seti.vs in fp:</span>
<span class="comment">%seti.fp = @(q,hz) d1(seti.R(seti.vs(q))+seti.R(seti.vs(hz))) + d2(seti.I(seti.vs(q))+seti.I(seti.vs(hz)));</span>
seti.fp = @(qCVU,xnRVD) d1(real(seti.GD(qCVU))+seti.R(xnRVD)) + d2(imag(seti.GD(qCVU))+seti.I(xnRVD));

seti.fp2 = seti.fp; <span class="comment">% In fact it is not the same function, but because the pixels in the background are zero the result is the same.</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="17">Code: subfunction: setminfPartsWavelet</h2><p>Definitions of functions in case of wavelets. (This is not supported in the public version.)</p><pre class="codeinput"><span class="keyword">function</span> seti = setminfPartsWavelet(seti)

<span class="comment">% f_dw</span>
<span class="comment">% seti.Kdw = seti.Kd;</span>
<span class="comment">%seti.KdwAdj = seti.KdAdj;</span>
seti.vdw = @(FFq) seti.S(FFq-seti.FmeasDelta);
<span class="comment">%seti.fdw = @(DFFqh,FFq) 1/seti.p*normws(seti.S(DFFqh)+seti.vdw(FFq),seti)^seti.p;</span>

seti.fdw1 = @(DFFqh,FFq) normws(seti.S(DFFqh)+seti.vdw(FFq),seti); <span class="comment">% seti.p = 1</span>
seti.fdw2 = @(DFFqh,FFq) 1/2*normws(seti.S(DFFqh)+seti.vdw(FFq),seti)^2; <span class="comment">% seti.p = 2</span>
seti.fdw3 = @(DFFqh,FFq) 1/seti.pNorm*normLp(DFFqh+FFq,seti)^seti.pNorm; <span class="comment">% seti.qNorm ~= 2</span>
<span class="comment">%fswPart = @(q,hz) seti.wW(q+hz);</span>
<span class="comment">%seti.fsw = @(q,hz) normroi(seti.alpha*[real(fswPart(q,hz)); imag(fswPart(q,hz))],seti);</span>

<span class="comment">% f_sw</span>
<span class="keyword">if</span> isfield(seti,<span class="string">'wavIsom'</span>) &amp;&amp; strcmp(seti.wavIsom,<span class="string">'W1p'</span>) &amp;&amp; isfield(seti,<span class="string">'omegaW1p'</span>)
    seti.Ksw = @(xnRVD) seti.alpha*seti.S(seti.wWi(seti.omegaW1p.*seti.T(xnRVD)));
    seti.KswAdj = @(ys) seti.alpha*seti.S(seti.omegaW1p.*seti.wWstari(seti.T(ys)));
    <span class="comment">%seti.KswAdj = @(ys) seti.alpha*[seti.wWstar(seti.R(ys)); seti.wWstar(seti.I(ys))];</span>
    <span class="comment">%seti.vsw = @(q) seti.alpha*[real(wWq(q)); imag(wWq(q))];</span>
    seti.vsw = @(qCVU) seti.alpha*seti.S(seti.wWi(seti.omegaW1p.*seti.GD(qCVU))); <span class="comment">% down scaled</span>
    seti.fsw = @(qCVU,xnRVD) norminv(seti.vsw(seti.GU(seti.T(xnRVD)))+seti.vsw(qCVU),seti);
    <span class="comment">% T(xnRVD) is upscaled and in seti.vsw down scaled...</span>
    <span class="comment">% using qCVD (down scaled) instead of qCVU would be useful...</span>
    <span class="comment">% In theory normroi(seti.S(...),...), but it does not matter</span>
<span class="keyword">else</span>
    seti.Ksw = @(xnRVD) seti.alpha*seti.S(seti.wWi(seti.T(xnRVD)));
    seti.KswAdj = @(ys) seti.alpha*seti.S(seti.wWstari(seti.T(ys)));
    seti.vsw = @(qCVU) seti.alpha*seti.S(seti.wWi(seti.GD(qCVU))); <span class="comment">% down scaled</span>
    seti.fsw = @(qCVU,xnRVD) norminv(seti.vsw(seti.GU(seti.T(xnRVD)))+seti.vsw(qCVU),seti);
<span class="keyword">end</span>


<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% setFuncsPda
%
% Set functions required in primal-dual algorithm (pda.m).
%
%% Syntax
%
%   seti = setFuncsPda(seti)
%
%% Description
% |seti = setFuncsPda(seti)| sets functions in structure array |seti|,
% that are required in primal-dual algorithm, see <pda.html>. 
% Therefore this function is called in setRecon.m, see <setRecon.html>.
%
%% Input Arguments
%
% * seti    :   structure array
%
%% Output Arguments
%
% * seti    :   structure array
%
% For the fields of the structrual array |seti| see the section "More About".
%
%% More About
%
% We only give a overview of the functions. See also <pda.html>.
% Detailed information are in Section 4.5 in [1].
%
% Note that grid scaling is respected in the code, but for 
% simplicitiy is not presented in the formulas.
%
% *Auxiliary quantities*
%
% For $\texttt{seti.S} = T_{\bf{C}\to\bf{R}^2}$ and $\texttt{seti.T} = T_{\bf{R}^2\to\bf{C}}$, see "More About" in <pda.html>.
%
% * $\texttt{seti.Kd} = K_\mathrm{dis} :=
%   T_{\bf{C}\to\bf{R}^2} [\mathcal{F}'(T_{\bf{R}^2\to\bf{C}}\ q)]T_{\bf{R}^2\to\bf{C}}$,
% * $\texttt{seti.vd} = v_\mathrm{dis} := 
%   T_{\bf{C}\to\bf{R}^2}(\mathcal{F}(T_{\bf{R}^2\to\bf{C}}\ q)-F_\mathrm{meas}^\delta)$,
% * $\texttt{seti.Kg} = K_\mathrm{tv}  := 
%   \beta\,T_{\bf{C}\to\bf{R}^2}\nabla T_{\bf{R}^2\to\bf{C}}$
% * $\texttt{seti.vg} = v_\mathrm{tv} :=
%   \beta\, T_{\bf{C}\to\bf{R}^2} \nabla T_{\bf{R}^2\to\bf{C}}\ q$.
%
% Note that the names |Kg| and |vg| were choosen because the appearance of the gradient.
%
% *Parts of functional to minimize*
%
% * $\texttt{seti.fd} = f_\mathrm{dis}(h) := 
%   \frac{1}{2} \|K_\mathrm{dis} h+  v_\mathrm{dis} \|_{\mathrm{dis},\bf{R}}^2$
%   $\quad$ is the discrepancy (linearized problem),
% * $\texttt{seti.fs} = f_\mathrm{spa}(h) := 
%   \alpha \| h + q\|_{\mathrm{spa}, \bf{R}}$
%   $\quad$ is the sparsity penalty,
% * $\texttt{seti.fg} = f_\mathrm{tv}(h) :=
%   \|K_\mathrm{tv} h + v_\mathrm{tv} \|_{\mathrm{tv},\bf{R}}$
%   $\quad$ is the TV-penalty,
% * $\texttt{seti.fp} = f_\mathrm{phy}(h) :=
%   \delta_{[a,b,c,d]}(h + q)$
%   $\quad$ is the penalty for physical bounds.
%
% Note that $\delta_{[a,b,c,d]}(x)$ is a indicator function, i.e. is 0, 
% if all entries of the vector $\mathrm{real}(x)$ are between $a$ and $b$
% and all entries of the vector $\mathrm{imag}(x)$ are between $c$ and $d$;
% and is $\infty$, otherwise.
%
% *Definition of parts of Tikhonov functional*
%
% The Tikhonov functional is |MT = M1 + M2|. 
% Function $F$ is $M_1$, function $G$ is $M_2$ (with $F$ and $G$ from PDA)
% This is done in function |minPda| (<minPda.html>) when function 
% |pda| (<pda.html>) is called.
%
% *Further comments (in particular, interesting in not public version)*
%
% * In case of inversion by pda, it is always (automatically) set 
%   |seti.pNorm = 2| and |seti.qNorm = 1| (except for invNo = 7), see
%   <setInvType.html>.
% * Exponent p of the discrepancy term, see <setInvType.html>, is usually
%   |seti.p = 2|.
%   In case of shrinkage or pda with wavelets it may differ, see
%   <setInvType.html>.
% * |vs| and |vp| in term $G$: If you choose |vs| and |vp| manually and 
%   |fs| and |fp| belong to term $G$, then |vs = vp| is required.
%
%% References
%
% * [1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. _Journal of Computational Physics_, 339:1-30, 2017.
%
%% See Also
% * <setRecon.html>
% * <pda.html>
% * <setInvType.html>
%
%% Code: setFuncsPda
%
function seti = setFuncsPda(seti)

% Definition of parts of function to minimize (f = minf)
% parts for reconstruction process
seti = setminfParts(seti);
if seti.useWavelet == 1 % not available in public version
    seti = setminfPartsWavelet(seti);
end

end

%% Code: subfunction: potPotNum
% Numerical potential pot function.
%
function [d1,d2] = potPotNum(seti)
infty = 1E5;
dp = @(a,b,x) 0.* and((a<=x),(x<=b))+infty.*or((x<a),(b<x)); % potential pot function
d =  @(a,b,x) max(dp(a,b,x)); % d = 0 if ALL entries are between a and b, otherwise d = \infty
% max because d = \infty if ONE entry of x \notin [a,b]
clear infty

l = seti.physBounds;
reMin = l(1); reMax = l(2); imMin = l(3); imMax = l(4);
tol = seti.tolDelta;
d1 = @(x) d(reMin-tol,reMax+tol,x); % limits for real part
d2 = @(x) d(imMin-tol,imMax+tol,x); % limits for imag part
% tol important because e.g. (min(real(qROI))+1) = -2.2204e-16
clear l a b c
end

%% Code: subfunction: setminfParts
%
% * $K: X \to Y$
% * Y: depends on function |Ki| (|Ki| i.e. |Kd|, |Kg|, ...)
% * X: xnRVD (this means real vector downscaled):
%    size of elements: 2*seti.nInv^seti.dim
% * |hs| was |xnRVU|
% * |q| is standard in qCVU (is fixed in pda), 
%   but you can use qCVD etc. too, if you have them as argument

function seti = setminfParts(seti)

%%
% *f_d*
%
% * Remember that |DFFq = @(xnRVD) JA*diag(seti.GU(seti.T(xnRVD)))*JB;|
% * The difference to DFFq is that finally |seti.S| is used.
%
if strcmp(seti.model,'helmholtz2D') || strcmp(seti.model,'helmholtz3D')
    seti.Kd = @(xnRVD,JA,JB) seti.S(JA*diagsparse(seti.GU(seti.T(xnRVD)))*JB); % K_d(h) = S(\F'(q)[GU(T(h_S))]) %real
elseif strcmp(seti.model,'helmholtzHMode2D')
    seti.Kd = @(xnRVD,JA,JB) seti.S( JA(:,:,1)*diagsparse(seti.GU(seti.T(xnRVD)))*JB(:,:,1) ...
        + JA(:,:,2)*diagsparse(seti.GU(seti.T(xnRVD)))*JB(:,:,2) ); % K_d(h) = S(\F'(q)[GU(T(h_S))]) %real
else
    fprintf('Error in setFuncs - pda not implemented for model %s.\n',  seti.model)
end
% Finally: Kd(x): R^{2 nInv^dim} -> R^{2 measNb x incNb}
% Kd = \F'(q) (from mimo \F'(q): JA*diag(h)*JB = \F'(q)[h])
seti.KdAdj = @(yd,JA,JB) seti.S(seti.GD(ADFFqFast(seti.T(yd),JA,JB,seti)));
seti.vd = @(FFq) seti.S(FFq-seti.FmeasDelta); % 2* measNb x incNb
seti.fd = @(DFFqh,FFq) (1/2)*normws(seti.S(DFFqh)+seti.vd(FFq),seti)^2;

%%
% *f_s*
%
seti.vs = @(qCVU) seti.S(seti.GD(qCVU));
seti.fs = @(qCVU,xnRVD) seti.alpha*normroi(xnRVD+seti.vs(qCVU),seti);

%%
% *f_g*
%
seti.Kg = @(xnRVD) seti.beta*gradientNeumann(xnRVD,seti.hInv,seti.nInv,seti.GInv,seti); % K_g
%seti.KgAdj = @(yg) -seti.beta*div(yg,seti); % Note that this is wrong(!) (although analytically correct)
seti.KgAdj = @(yg) seti.beta*gradientNeumannAdj(yg,seti); %yg is 2*dim x nInv x nInv (x nInv)
seti.vg = @(qCVU) seti.Kg(seti.S(seti.GD(qCVU)));
seti.fg = @(qCVU,xnRVD) normTVinv1(seti.Kg(xnRVD)+seti.vg(qCVU),seti); %f_g(x) = ||beta*\nabla x + v_g)||_\tv (gradient sparsity)

%%
% *f_p*
%
% * Note that seti.vp = seti.vs is important because of prox Gsp
%   (prox Gsp does mean that the term G consists of fs and fp.
%   To compute the proximal mapping of G the equality of vp and vs is
%   required!)
%
[d1,d2] = potPotNum(seti);
%seti.fp = @(q,hz) d1(real(q)+real(hz)) + d2(imag(q)+imag(hz));
% use seti.vs in fp:
%seti.fp = @(q,hz) d1(seti.R(seti.vs(q))+seti.R(seti.vs(hz))) + d2(seti.I(seti.vs(q))+seti.I(seti.vs(hz)));
seti.fp = @(qCVU,xnRVD) d1(real(seti.GD(qCVU))+seti.R(xnRVD)) + d2(imag(seti.GD(qCVU))+seti.I(xnRVD));

seti.fp2 = seti.fp; % In fact it is not the same function, but because the pixels in the background are zero the result is the same.

end

%% Code: subfunction: setminfPartsWavelet
% Definitions of functions in case of wavelets.
% (This is not supported in the public version.)
%
function seti = setminfPartsWavelet(seti)

% f_dw
% seti.Kdw = seti.Kd;
%seti.KdwAdj = seti.KdAdj;
seti.vdw = @(FFq) seti.S(FFq-seti.FmeasDelta);
%seti.fdw = @(DFFqh,FFq) 1/seti.p*normws(seti.S(DFFqh)+seti.vdw(FFq),seti)^seti.p;

seti.fdw1 = @(DFFqh,FFq) normws(seti.S(DFFqh)+seti.vdw(FFq),seti); % seti.p = 1
seti.fdw2 = @(DFFqh,FFq) 1/2*normws(seti.S(DFFqh)+seti.vdw(FFq),seti)^2; % seti.p = 2
seti.fdw3 = @(DFFqh,FFq) 1/seti.pNorm*normLp(DFFqh+FFq,seti)^seti.pNorm; % seti.qNorm ~= 2
%fswPart = @(q,hz) seti.wW(q+hz);
%seti.fsw = @(q,hz) normroi(seti.alpha*[real(fswPart(q,hz)); imag(fswPart(q,hz))],seti);

% f_sw
if isfield(seti,'wavIsom') && strcmp(seti.wavIsom,'W1p') && isfield(seti,'omegaW1p')
    seti.Ksw = @(xnRVD) seti.alpha*seti.S(seti.wWi(seti.omegaW1p.*seti.T(xnRVD)));
    seti.KswAdj = @(ys) seti.alpha*seti.S(seti.omegaW1p.*seti.wWstari(seti.T(ys)));
    %seti.KswAdj = @(ys) seti.alpha*[seti.wWstar(seti.R(ys)); seti.wWstar(seti.I(ys))];
    %seti.vsw = @(q) seti.alpha*[real(wWq(q)); imag(wWq(q))];
    seti.vsw = @(qCVU) seti.alpha*seti.S(seti.wWi(seti.omegaW1p.*seti.GD(qCVU))); % down scaled
    seti.fsw = @(qCVU,xnRVD) norminv(seti.vsw(seti.GU(seti.T(xnRVD)))+seti.vsw(qCVU),seti);
    % T(xnRVD) is upscaled and in seti.vsw down scaled...
    % using qCVD (down scaled) instead of qCVU would be useful...
    % In theory normroi(seti.S(...),...), but it does not matter
else
    seti.Ksw = @(xnRVD) seti.alpha*seti.S(seti.wWi(seti.T(xnRVD)));
    seti.KswAdj = @(ys) seti.alpha*seti.S(seti.wWstari(seti.T(ys)));
    seti.vsw = @(qCVU) seti.alpha*seti.S(seti.wWi(seti.GD(qCVU))); % down scaled
    seti.fsw = @(qCVU,xnRVD) norminv(seti.vsw(seti.GU(seti.T(xnRVD)))+seti.vsw(qCVU),seti);
end


end

##### SOURCE END #####
--></body></html>