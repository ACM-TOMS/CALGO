
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>pda</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-30"><meta name="DC.source" content="pda.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>pda</h1><!--introduction--><p>primal-dual algorithm in context of the Computational Framework for Inverse Medium Problem in Scattering.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Input Arguments</a></li><li><a href="#4">Output Arguments</a></li><li><a href="#5">More About</a></li><li><a href="#6">References</a></li><li><a href="#7">See Also</a></li><li><a href="#8">Code: function: pda</a></li><li><a href="#10">Code: function: pda: F and G terms</a></li><li><a href="#11">Code: function: pda: initialization</a></li><li><a href="#12">Code: function: pda: Algorithm 1</a></li><li><a href="#13">Code: function: pda: control results of F(K(h)) and G(h) (no influence on calculation)</a></li><li><a href="#14">Code: function: pda: pda</a></li><li><a href="#16">Code: subfunction to K components norm</a></li><li><a href="#17">Code: subfunctions to F and G (sum)</a></li><li><a href="#19">Code subfunctions to proximal mappings</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">[hsolCVU,pdaStopInd,FGval,Fval,Gval,relLinDis,disLinInPda,errInPda,minf] = pda(iOut,qCVU,ThetaiOut,seti,dispDepth)
</pre><h2 id="2">Description</h2><p><tt>[hsolCVU,pdaStopInd,FGval,Fval,Gval,relLinDis,disLinInPda,errInPda,minf] = pda(iOut,qCVU,ThetaiOut,seti)</tt> computes the update <tt>hsolCVU</tt> of the linearized minimization problem.</p><h2 id="3">Input Arguments</h2><p>Most important input arguments (there are more...)</p><div><ul><li>iOut        :   number of (current) outer iteration</li><li>qCVU        :   reconstructed contrast q as vector of size                   seti.nROI^seti.dim x 1.                   (CVU does mean complex, vector, upscaled)</li><li>ThetaiOut   :   inner tolerance, see <a href="minTolIn.html">minTolIn.html</a>                   (only required if inner tolerance principle is used by                   seti.useTolIn = 1; otherwise it is set to 0.)</li><li>seti        :   struct seti</li><li>dispDepth   :   depth of displayed messages                   (greater or equal 3 to see aything in this file).                   (3 less, 4 default, 5 additional information).</li></ul></div><p><b>Some of the fields in struct seti</b></p><p>Note that several fields in struct seti are necessary to run pda.</p><p>The routine <tt>pda</tt> is an internal one that needs the specific environment created in the package.</p><div><ul><li>seti.dim    :   dimension of the problem (2 or 3)</li><li>seti.nROI   :   discretization points for each dimension                   of region of interest (ROI) (in samples)</li></ul></div><div><ul><li>seti.pdaN   :   number of inner iterations (PDA) (is called nPda)</li><li>seti.pdaStepsize    :   method to choose primal and dual stepsizes                           (<tt>'fix'</tt> (default) or <tt>'adaptive'</tt>),                           see <a href="pdaChoosingStepsizes.html">pdaChoosingStepsizes.html</a>.</li><li>seti.vartheta       :   parameter in (0,1) used in case of adaptive stepsizes,                           see <a href="pdaChoosingStepsizes.html">pdaChoosingStepsizes.html</a>.</li></ul></div><h2 id="4">Output Arguments</h2><div><ul><li>hsolCVU     :   solution of the update h                   (at the end of pda: hsolCVU = seti.GU(seti.T(xnRVD)))</li><li>pdaStopInd  :   iteration, where primal-dual agorithm was stopped                   (iPda = 1:nPda, but maybe is stopped earlier becaue                   usage of seti.useTolIn or seti.useTolOut)                   (see <a href="minTolIn.html">minTolIn.html</a>, <a href="minTolOut.html">minTolOut.html</a>, <a href="minPda.html">minPda.html</a>).</li><li>FGval       :   stores values of <img src="pda_eq10365948801267560714.png" alt="$F(Kh) + G(h)$"> (vector of size nPda x 1)</li><li>Fval        :   stores values of <img src="pda_eq07151070768050933334.png" alt="$F(Kh)$"> (vector of size nPda x 1)</li><li>Gval        :   stores values of <img src="pda_eq08590019810632053506.png" alt="$G(h)$"> (vector of size nPda x 1)</li><li>relLinDis   :   quotient: relLinDis = disLin / dis                   (vector of size nPda x 1)</li><li>disLinInPda :   discrepancy of linearized problem for each inner iteration step                   (vector of size nPda x 1)</li><li>errInPda    :   relative error of the reconstructed contrast qROI                   (vector of size nPda x 1)</li><li>minf        :   struct with parts of the minimization functional                   (Tikhonov functional)</li></ul></div><div><ul><li>minf.fd     :   discrepancy of linearized problem                   (vector of size nPda x 1)</li><li>minf.fs     :   sparsity penalty                   (vector of size nPda x 1)</li><li>minf.fg     :   total variation penalty                   (vector of size nPda x 1)</li><li>minf.fp     :   penalty for physical bounds                   (vector of size nPda x 1)</li></ul></div><p>See "More About" for formulas.</p><h2 id="5">More About</h2><p><b>Minimization functional</b></p><p>The function pda minimizes the <b>Tikhonov functional</b> of the linearized problem, i.e.</p><p><img src="pda_eq12799784419893847904.png" alt="$$ \min_{h \in X}&#xA;     \underbrace{&#xA;         \frac{1}{2}\|\mathcal{F}'(q)[h]+\mathcal{F}(q) - F_\mathrm{meas}^\delta\|_\mathrm{F}^2&#xA;         }_{=: f_\mathrm{dis}(h),\ \mathrm{discrepancy\ (linearized\ problem)}}&#xA;   + \underbrace{\alpha \|q+h\|_\mathrm{1}}_{=: f_\mathrm{spa}(h),\ \mathrm{sparsity\ penalty}}&#xA;   + \underbrace{\beta \| \nabla (q+h) \|_\mathrm{1}}_{=: f_\mathrm{tv}(h),\ \mathrm{total\ variation\ penalty}}&#xA;   + \underbrace{&#xA;         \delta_{[a,b]}( \mathrm{Re}(q+h) ) +&#xA;         \delta_{[c,d]}(\mathrm{Im}(q+h) )}_{=: f_\mathrm{phy}(h),\ \mathrm{penalty\ for\ physical\ bounds}&#xA;         }.&#xA;   $$"></p><p><b>Next step</b></p><p>The update <img src="pda_eq18145746415082390862.png" alt="$q := q + h$"> is done in <a href="minPda.html">minPda.html</a>, see also "More About" in <a href="start.html">start.html</a> to see the connection.</p><p><b>Splitting the minimization problem</b></p><p>In pda we formulate the minimization problem as:</p><p><img src="pda_eq16087771646550626963.png" alt="$$ \min_{h \in X} F(Kh) + G(h)$$"></p><p>with</p><p><img src="pda_eq14935190976347105445.png" alt="$F(Kh) = f_\mathrm{dis}(h) + f_\mathrm{tv}(h)$">,</p><p><img src="pda_eq14321151443320988193.png" alt="$G(h)  = f_\mathrm{spa}(h) + f_\mathrm{phy}(h)$">.</p><div><ul><li>The splitting in <img src="pda_eq08597826192214703288.png" alt="$F$"> and <img src="pda_eq07365524530707038546.png" alt="$G$"> is done to be in the setting of primal-dual algorithm, see [2]. (The primal problem can be reformulated as primal-dual problem which leads to the primal-dual algorithm.)</li></ul></div><div><ul><li>Other identifications of the functionals <img src="pda_eq08597826192214703288.png" alt="$F$"> and <img src="pda_eq07365524530707038546.png" alt="$G$"> are possible, but in public version of this package we only provide this one. (This identification is set in <a href="setInvType.html">setInvType.html</a> with parameter <tt>seti.invNo = 6</tt>.)</li></ul></div><p><b>The primal-dual algorithm</b>, for convex problems, see Algorithm 1 in [2]:</p><div><ul><li>Note that <img src="pda_eq10948355176395003678.png" alt="$F^\ast$"> is the Fenchel conjugate of <img src="pda_eq08597826192214703288.png" alt="$F$">.</li><li>The x in the algorithm corresponds to h above.</li></ul></div><div><ul><li>Initialization:</li></ul></div><p>Choose primal step size <img src="pda_eq07996783651938012810.png" alt="$\tau &gt; 0$">, dual step size <img src="pda_eq03250267791875257362.png" alt="$\sigma &gt; 0$">, initial vectors <img src="pda_eq15914162385939132993.png" alt="$(x^0,y^0) \in X \times Y$"> (e.g. <img src="pda_eq03725967391095403773.png" alt="$x^0 = 0$">, <img src="pda_eq14339731156047789984.png" alt="$y^0 = 0$">), and set <img src="pda_eq05334114253021166382.png" alt="$\bar{x}^0 = x^0$">.</p><div><ul><li>Iterations (<img src="pda_eq05894460036729494888.png" alt="$n \geq 0$">): Update <img src="pda_eq13175037672950265658.png" alt="$x^n, y^n, \bar{x}^n$"> as follows:</li></ul></div><p>1. <img src="pda_eq00809248095359009523.png" alt="$\quad y^{n+1} = (I + \sigma \partial F^\ast)^{-1}  (y^n + \sigma K \bar{x}^n)$">,</p><p>2. <img src="pda_eq13899842508492875267.png" alt="$\quad x^{n+1} = (I + \tau \partial G)^{-1}  (x^n - \tau K^\ast y^{n+1})$">,</p><p>3. <img src="pda_eq12987416250000376086.png" alt="$\quad \bar{x}^{n+1} = 2x^{n+1} - x^n.$"></p><p>The motivation of this algorithm is: 3. is an over-relaxation step, and 1.-2. are fixed-point iterations (derived from extremality conditions).</p><p><b>Application of primal-dual algorithm in this package</b></p><p>To apply the primal-dual algorithm in the context of inverse scattering we have to remember that the contrast <img src="pda_eq15226540192103580117.png" alt="$q$"> is complex, but real vector spaces are indeed crucial for the primal-dual algorithm.</p><p>Therefore <b>transformation operators</b> are introduced in <a href="setIdImagReal.html">setIdImagReal.html</a>, see also Section 4.5 in [1]:</p><div><ul><li><img src="pda_eq13411477123890850836.png" alt="$\texttt{seti.S}  = T_{\bf{C} \to \bf{R}^2} : \bf{C} \to \bf{R} \times \bf{R}$">, <img src="pda_eq14974224158754676687.png" alt="$\quad$"> <img src="pda_eq07189123018235705862.png" alt="$T_{\bf{C} \to \bf{R}^2}(x) = (\mathrm{real}(x),\,  \mathrm{imag}(x))$">.</li></ul></div><div><ul><li><img src="pda_eq03336838427545904367.png" alt="$\texttt{seti.T} = T_{\bf{R} \to \bf{C}} : \bf{R} \times \bf{R} \to \bf{C}$">, <img src="pda_eq14974224158754676687.png" alt="$\quad$"> <img src="pda_eq15300575361199717257.png" alt="$T_{\bf{R} \to \bf{C}} =  y^{\mathrm{real}} + \mathrm{i}\,y^{\mathrm{imag}}  \mathrm{\ where\ } y = (y^{\mathrm{real}},y^{\mathrm{imag}})$">.</li></ul></div><p>The full iterative reconstruction scheme (with respect to transformation operators) is given in Section 4.4 of [1].</p><p>A full derivation is given in Setion 4 of [1].</p><p>The defintion of functions is done in <a href="setFuncsPda.html">setFuncsPda.html</a> (i.e. discrepancy, penalty terms, components of K and their adjoints, ...).</p><p><b>Grid scaling</b></p><p>Additionally, in the code a grid scaling is respected to offer to compute the reconstruction on a coarser grid. Therefore we use</p><div><ul><li>seti.GU     :   function to scale up the grid,</li><li>seti.GD     :   function to scale down the grid.</li></ul></div><p>For details see <a href="setGridScale.html">setGridScale.html</a>.</p><p>Note that grid scaling is not explained explicitly in [1].</p><h2 id="6">References</h2><div><ul><li>[1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. <i>Journal of Computational Physics</i>, 339:1-30, 2017.</li><li>[2] Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. <i>Journal of Mathematical Imaging and Vision</i>, 40(1):120-145, 2011.</li></ul></div><h2 id="7">See Also</h2><div><ul><li><a href="start.html">start.html</a></li><li><a href="minPda.html">minPda.html</a></li><li><a href="minTolIn.html">minTolIn.html</a></li><li><a href="minTolOut.html">minTolOut.html</a></li><li><a href="setInvType.html">setInvType.html</a></li><li><a href="setIdImagReal.html">setIdImagReal.html</a></li><li><a href="setFuncsPda.html">setFuncsPda.html</a></li><li><a href="setGridScale.html">setGridScale.html</a></li></ul></div><h2 id="8">Code: function: pda</h2><pre class="codeinput"><span class="keyword">function</span> [hsolCVU,pdaStopInd,FGval,Fval,Gval,relLinDis,disLinInPda,errInPda,minf] = pda(iOut,qCVU,ThetaiOut,seti,dispDepth)
</pre><pre class="codeinput"><span class="comment">% pda: primal dual algorithm</span>

<span class="keyword">if</span> ~isequal(size(qCVU),[seti.nROI^seti.dim,1])
    error(<span class="string">'size of qCVU does not fit.'</span>)
<span class="keyword">end</span>
<span class="comment">% qROI is a complex vector (and not scaled down)</span>

<span class="comment">% qCVU = qROI: complex vector upscaled (full) grid</span>

<span class="comment">% q: contrast: fixed in pda</span>
<span class="comment">% h: update of contrast (changes in pda) (in minPda: new q = q + h)</span>

<span class="comment">% Meaning of characters:</span>
<span class="comment">% C, R: stored complex or as real values</span>
<span class="comment">% M, V: matrix or vector</span>
<span class="comment">% U, D: full grid (upscaled, nROI) or small grid (downscaled, nInv)</span>
<span class="comment">% e.g.: CMU... is a complex matrix upscaled</span>

<span class="comment">% seti.pdaStepsize = 'adaptive'; % fix or adaptive</span>
<span class="comment">% is set in checkConsisRec (or in a file inseti...)</span>

GUCV = seti.GU; <span class="comment">% input and output is a complex vector (not stored as matrix)</span>
GDCV = seti.GD; <span class="comment">% input and output is a complex vector (not stored as matrix)</span>
<span class="comment">% iG and G inside GU and GD does matrix &lt;-&gt; vector</span>

<span class="comment">% input and output is the complex vector stored in real (RxR instead of C)</span>
GURV = @(x) seti.S(GUCV(seti.T(x))); <span class="comment">% RxR -&gt; C, then GU fits, then C -&gt; RxR</span>
GDRV = @(x) seti.S(GDCV(seti.T(x))); <span class="comment">% analog; GDRV is currently unused</span>

<span class="comment">% qROI is fix in pda algorithm</span>
<span class="comment">% store it in different formats... (to use it fast)</span>
<span class="comment">% qCVU = qCVU;</span>
qRVU = seti.S(qCVU); <span class="comment">% currently unused</span>
qCVD = GDCV(qCVU);
qRVD = seti.S(qCVD); <span class="comment">% currently unused</span>

<span class="comment">% qROI not down-scaled in this file</span>
<span class="comment">% (and not before; qROI is a fixed vector in this file)</span>

<span class="comment">% x is down-scaled</span>
<span class="comment">% final h is upscaled</span>

<span class="comment">% M1a, M1b only in case of seti.useWavelet == 1</span>

<span class="comment">% hs is real x real; h is corresponding complex</span>
<span class="comment">% inside pda: hs is used, but output is complex h</span>

<span class="comment">% in case of using pda: checkConsistency.m set</span>
<span class="comment">%seti.pNorm = 2; % then WHS-Norm is used(!) (important)</span>
<span class="comment">%seti.qNorm = 1;</span>
<span class="comment">% if you change pNorm or qNorm you have to change proximal mappings etc.</span>

<span class="comment">% inside pda h is real: hs = [hr; hi] = [real(h); imag(h)]</span>
<span class="comment">% outside: h is complex (so h = hz)</span>

<span class="comment">%[m,~,~] = size(A); 1:m/2 is real part and m/2+1:end is imag part</span>

<span class="comment">% notation:</span>
<span class="comment">% qROI is complex(!)</span>
<span class="comment">% qr = real(qROI);</span>
<span class="comment">% qi = imag(qROI);</span>
<span class="comment">% q = [qr;qi]; % in 2D: in R^{2 nROI^2}; in 3D: in R^{2 nROI^3}</span>
<span class="comment">% analog: h</span>

<span class="comment">% in this file: q = qROI is qROI and NOT W(qROI)</span>

speed = 0;
stopPda = 0; <span class="comment">% 0 or 1: break pda if changes are below tolerance</span>

nPda = seti.pdaN; <span class="comment">% number of iterations</span>

reMin = seti.physBounds(1);
reMax = seti.physBounds(2);
imMin = seti.physBounds(3);
imMax = seti.physBounds(4);

<span class="comment">% first-order primal-dual algorithm (pda)</span>
<span class="comment">% for convex problems (paper: Chambolle, Pock, 2011)</span>

<span class="comment">% input:</span>
<span class="comment">% K: X -&gt; Y: continuous linear operator</span>
<span class="comment">% nonlinear primal problem: min_{x \in X} F(Kx) + G(x)</span>
<span class="comment">% FC:= F; GC:= G (to have different names to shrinakge...)</span>

<span class="comment">% Symbols:</span>
<span class="comment">%</span>
<span class="comment">% F^\star: convex conjugate of F</span>
<span class="comment">% K^\ast: adjoint of K (symbol: *)</span>

<span class="comment">% P = seti.pNorm;</span>
<span class="comment">% Q = seti.qNorm;</span>
<span class="comment">% setting must be: P = 2; Q = 1; % see setInvType</span>

<span class="keyword">if</span> dispDepth &gt;= 3
    disp(<span class="string">'    - Compute auxiliary matrices JA and JB for Jacobian matrix'</span>);
<span class="keyword">end</span>
tic
[JA,JB] = mimo(seti, qCVU, <span class="string">'jacobian'</span>);
tocJac = toc(tic);
<span class="keyword">if</span> dispDepth &gt;= 3
    fprintf(<span class="string">'      Elapsed time of computation of Jacobian matrices is %05.1f min.\n'</span>,tocJac/60);
<span class="keyword">end</span>
</pre><h2 id="10">Code: function: pda: F and G terms</h2><p>tF: term F tG: term G</p><pre class="codeinput">clear <span class="string">tF</span> <span class="string">tG</span>;
<span class="comment">% tF and tG are set in setInvType</span>
<span class="comment">% look there for details, which terms are F and G (or not used)</span>
tF = seti.tF;
tG = seti.tG;
tFG = [tF,tG]; <span class="comment">% term FG contains terms of F and G</span>
</pre><h2 id="11">Code: function: pda: initialization</h2><pre class="codeinput">qCVDsize = size(qCVD); <span class="comment">% q complex vector downsize</span>
<span class="comment">% Consistency check</span>
<span class="keyword">if</span> ~isequal(qCVDsize,[seti.nInv^seti.dim,1])
    error(<span class="string">'pda: qCVDsize does not fit.'</span>)
<span class="keyword">end</span>

yCMsize = size(seti.FmeasDelta); <span class="comment">% y size (complex matrix)</span>
<span class="keyword">if</span> ~isequal(yCMsize,[seti.measNb,seti.incNb])
    error(<span class="string">'pda: ysize does not fit.'</span>)
<span class="keyword">end</span>

xnRVD = [zeros(qCVDsize); zeros(qCVDsize)]; <span class="comment">%x0 \in X = R^{2n} % real and down</span>
<span class="comment">% consistency check</span>
<span class="keyword">if</span> ~isequal(size(xnRVD),[2*seti.nInv^seti.dim,1])
    error(<span class="string">'pda: xnRVD does not fit.'</span>)
<span class="keyword">end</span>

xnRVDsize = size(xnRVD); <span class="comment">% currently unused</span>
xmnRVD = xnRVD;

<span class="comment">% -- choose K components and initializing y...</span>
<span class="comment">% if fclass(i,j) == 1 then you have to choose the fitting K component</span>
<span class="comment">% and define yn</span>
<span class="comment">% initialize yd0, ys0, ...</span>
<span class="comment">% using ysn in case of fs and fsw (because you will not use fs and fsw)</span>
<span class="keyword">if</span> ismember(<span class="string">'fd'</span>,tF) || ismember(<span class="string">'fdw1'</span>,tF) || ismember(<span class="string">'fdw2'</span>,tF) || ismember(<span class="string">'fdw3'</span>,tF) <span class="comment">% f_d or f_dw1 or f_dw2 in F</span>
    Kcomp.Kd = seti.Kd;
    ydnRM = [zeros(yCMsize); zeros(yCMsize)]; <span class="comment">% y_d_0 \in Y = R^{2m x i}</span>
    <span class="comment">% y_d_0 \in Y_1=R^(2 measNb x incNb) (data), short Y=R^{2m x i}</span>
    ydRMsize = size(ydnRM);
<span class="keyword">end</span>
<span class="keyword">if</span> ismember(<span class="string">'fsw'</span>,tF) <span class="comment">% f_sw in F</span>
    Kcomp.Ksw = seti.Ksw;
    yswn = xnRVD; <span class="comment">% y_s_0 \in Y_2 = R^{2n} (in sparsity term)</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ismember(<span class="string">'fg'</span>,tF) <span class="comment">% f_g in F</span>
    Kcomp.Kg = seti.Kg;
    <span class="comment">% ygn: size of grad(u) that is stored with components as real values (2*...)</span>
    <span class="comment">% in 2D: 2*dim x nInv x nInv</span>
    <span class="comment">% in 3D: 2*dim x nInv x nInv x nInv</span>

    <span class="keyword">if</span> seti.dim == 2
        ygnRMD = zeros(2*seti.dim,seti.nInv,seti.nInv); <span class="comment">% y_g_0 \in Y_g (in gradient sparsity term)</span>
    <span class="keyword">elseif</span> seti.dim == 3
        ygnRMD = zeros(2*seti.dim,seti.nInv,seti.nInv,seti.nInv);
    <span class="keyword">end</span>
    <span class="comment">%ygn = zeros(2*seti.dim,qsize); % does not work</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ismember(<span class="string">'fs'</span>,tF)
    error(<span class="string">'fs in term F (tF) is not implemented.'</span>)
<span class="keyword">end</span>

<span class="comment">% KcomponentsStruct can be outside of pda (is needed one time)</span>
[KcompNorm,KvarNames] = KcomponentsStruct(Kcomp,seti);
<span class="keyword">if</span> iOut == 1 &amp;&amp; dispDepth &gt;= 3
    disp(<span class="string">' '</span>)
    fprintf(<span class="string">'    - Using K components: '</span>)
    disp(KvarNames')
<span class="keyword">end</span>

F = Fsum(tF,seti);
G = Gsum(tG,seti);

<span class="comment">%DFFq = @(hz) JA*diag(hz)*JB; % for output: FF'(q)[h] (complex)</span>
<span class="keyword">if</span> strcmp(seti.model,<span class="string">'helmholtz2D'</span>) || strcmp(seti.model,<span class="string">'helmholtz3D'</span>)
    DFFq = @(xnRVD) JA*diagsparse(seti.GU(seti.T(xnRVD)))*JB;
<span class="keyword">elseif</span> strcmp(seti.model,<span class="string">'helmholtzHMode2D'</span>)
    DFFq = @(xnRVD) JA(:,:,1)*diagsparse(seti.GU(seti.T(xnRVD)))*JB(:,:,1)<span class="keyword">...</span>
        + JA(:,:,2)*diagsparse(seti.GU(seti.T(xnRVD)))*JB(:,:,2);
<span class="keyword">else</span>
    <span class="comment">%fprintf(strcat('Error in setFuncs - pda not implemented for model ',  seti.model))</span>
    fprintf(<span class="string">'Error in pda - pda not implemented for model %s.\n'</span>,  seti.model)
<span class="keyword">end</span>
<span class="comment">% with q = qCVU as input (you can use GU(qCVD) too)</span>
<span class="comment">% GUCV(T( . )): RVD -&gt; CVU</span>

<span class="keyword">if</span> dispDepth &gt;= 3
    disp(<span class="string">'    - Compute FF(q)'</span>);
<span class="keyword">end</span>
ticFFq = tic;

FFqMeas = mimo(seti, qCVU, <span class="string">'simo'</span>);

<span class="comment">% Slower (factor 2) alternative:</span>
<span class="comment">% FFqMeas = mimo(seti, qCVU,seti.T(ydnRM)); % expects complex qROI, Fmeas is 0; FFq is complex</span>
<span class="comment">% This is alternative is slower, because adjOfDer is computed but not</span>
<span class="comment">% needed.</span>

<span class="comment">% Notation in general:</span>
<span class="comment">% FFqmF  := FFqMeas - FmeasDelta</span>
<span class="comment">% ADFFq := FF'(q)^*[FF(q) - FmeasDelta] (Adjoint of derivative)</span>
tocFFq = toc(ticFFq);
<span class="keyword">if</span> dispDepth &gt;= 3
    fprintf(<span class="string">'      Elapsed time of FF(q) computation is %05.1f min.\n'</span>,tocFFq/60);
<span class="keyword">end</span>
</pre><h2 id="12">Code: function: pda: Algorithm 1</h2><pre class="codeinput"><span class="comment">% ynp = y_{n+1}</span>
<span class="comment">% xnp = x_{n+1}</span>
<span class="comment">% xmnp = \={x}_{n+1} (x with makron)</span>

<span class="comment">% yn = y_n</span>
<span class="comment">% xn = x_n</span>
<span class="comment">% xmn = \={x}_n (x with Makron)</span>

<span class="comment">% x     : primal variable</span>
<span class="comment">% tau   : primal stepsize (tau &gt; 0)</span>
<span class="comment">% y     : dual variable</span>
<span class="comment">% sigma : dual stepsize (sigma &gt; 0)</span>

<span class="comment">% exact: ||K|| = max_{||h||_1 \neq 0} ||Kh||_HS / ||h||_1</span>
<span class="comment">% implementation with random Vektors h...</span>

<span class="keyword">if</span> dispDepth &gt;= 3
    disp(<span class="string">'    - L operator norm: numerical approximation'</span>)
<span class="keyword">end</span>
ticOpNorm = tic;
L = opNormNum(xnRVD,JA,JB,KcompNorm,seti,dispDepth);
tocOpNorm = toc(ticOpNorm);
<span class="keyword">if</span> dispDepth &gt;= 3
    fprintf(<span class="string">'      Elapsed time of operator norm L is %05.1f min.\n'</span>,tocOpNorm/60);
<span class="keyword">end</span>
clear <span class="string">ticOpNorm</span> <span class="string">tocOpNorm</span>;
<span class="keyword">if</span> dispDepth &gt;= 3
    fprintf(<span class="string">'      L = ||K|| = %g\n'</span>,L);
<span class="keyword">end</span>

theta = 1; <span class="comment">% pda algorithm theta = 1 such that the proof works (Th. 1 in [2].)</span>
vartheta = seti.vartheta; <span class="comment">% vartheta \in (0,1) in choosingStepsizes!!! (not theta from PDA...)</span>

<span class="comment">% pda algorithm</span>
</pre><h2 id="13">Code: function: pda: control results of F(K(h)) and G(h) (no influence on calculation)</h2><pre class="codeinput">Fval = zeros(nPda,1); <span class="comment">% store values of FC(Kh)</span>
Gval = zeros(nPda,1); <span class="comment">% store values of GC(h)</span>
FGval = zeros(nPda,1);
disLinInPda = ones(nPda,1); <span class="comment">% linearized relative discrepancy</span>
<span class="comment">% disLinInPda = \|FF'(q)[h]+FF(q)-F_\meas^\delta\|_{WS,pNorm} / \|y^\delta\|_{WS,pNorm}</span>
relLinDis = zeros(nPda,1); <span class="comment">% relLinDis = disLin / dis;</span>
errInPda = zeros(nPda,1); <span class="comment">% relative error in pda</span>

fd = zeros(nPda,1);
fs = zeros(nPda,1);
fg = zeros(nPda,1);
fp = zeros(nPda,1);

<span class="comment">% Define variables... will be set in pdaChoosingStepsizes</span>
xnUp = GURV(xnRVD);
xnpRVDstore = xnUp; <span class="comment">% choosing needs upscaled</span>
xnRVDstore = xnUp;
tau = 0;
sigma = 0;
tauVal = zeros(nPda,1); <span class="comment">% vector to store tau values</span>
sigmaVal = zeros(nPda,1); <span class="comment">% vector to store sigma values</span>
</pre><h2 id="14">Code: function: pda: pda</h2><pre class="codeinput"><span class="keyword">for</span> iPda = 1:nPda

    [tau,sigma] = pdaChoosingStepsizes(seti.pdaStepsize,L,iPda,xnpRVDstore,xnRVDstore,KcompNorm,tau,sigma,vartheta,seti,JA,JB);

    tauVal(iPda) = tau; <span class="comment">% just to store...</span>
    sigmaVal(iPda) = sigma; <span class="comment">% just to store</span>

    <span class="comment">%----- pda algorithm steps -----</span>

    <span class="comment">%-- definition</span>
    <span class="comment">%wyi = @(yin,Ki) yin + sigma*GDRV(Ki(GURV(xmnRVD))); % down scaled (not for wyd)</span>
    wyi = @(yin,Ki) yin + sigma*Ki(xmnRVD);
    <span class="comment">% i is replaced by d, s or g (d and g extra cases...)</span>
    wyd = @(ydn,Kd) ydn + sigma*Kd(xmnRVD,JA,JB);
    wyg = @(ygn,Kg) ygn + sigma*Kg(xmnRVD);
    wxF = @(KAdjy) xnRVD-tau*KAdjy; <span class="comment">% w_x function handle</span>
    <span class="comment">%wx = wxF(KAdjy); % how to call it</span>

    <span class="comment">%-- compute KAdjySum (prepare pda step 2)</span>
    KAdjySum = 0;

    <span class="comment">%-- pda step 1: prox_F^+ (resolvent to F^+)</span>
    <span class="comment">% and prepare pda step 2 (compute KAdjySum)</span>
    <span class="comment">% 1) fd etc. in F (a discrepancy term should be in F)</span>

    wydVal = wyd(ydnRM,seti.Kd); <span class="comment">% w_{y_d}</span>
    <span class="keyword">if</span> ismember(<span class="string">'fd'</span>,tF) <span class="comment">% using Kd in cases of fd</span>
        ydnp = proxFdPlus(sigma,seti.vd(FFqMeas),wydVal); <span class="comment">% prox_{sigma F_d^+}(w_y_d)</span>
        <span class="comment">%fprintf('proxFdPlus: sigma = %g | max(vd) = %g | max(wyd) = %g\n',sigma,max(max(abs(seti.vd(FFq)))),max(max(abs(wydVal))));</span>
    <span class="keyword">elseif</span> ismember(<span class="string">'fdw1'</span>,tF) <span class="comment">% fdw1 in F (case seti.p = 1)</span>
        ydnp = proxFdw1Plus(sigma,seti.vd(FFqMeas),wydVal,seti); <span class="comment">% prox_{sigma F_d^+}(w_y_d)</span>
    <span class="keyword">elseif</span> ismember(<span class="string">'fdw2'</span>,tF) <span class="comment">% fdw2 in F (case seti.p == 2)</span>
        ydnp = proxFdPlus(sigma,seti.vd(FFqMeas),wydVal); <span class="comment">% prox_{sigma F_d^+}(w_y_d)</span>
        <span class="comment">% proxFdw2Plus = proxFdPlus because fdw2 = fd</span>
    <span class="keyword">elseif</span> ismember(<span class="string">'fdw3'</span>,tF) <span class="comment">% fdw3 in F (case seti.pNorm ~= 2)</span>
        ydnp = proxFdw3Plus(sigma,seti.vd(FFqMeas),wydVal,seti);
        <span class="comment">% proxFdw2Plus = proxFdPlus because fdw2 = fd</span>
    <span class="keyword">else</span>
        error(<span class="string">'No discrepancy term choosen... Does not make sense.'</span>)
    <span class="keyword">end</span>
    KdAdjyd = seti.KdAdj(ydnp,JA,JB); <span class="comment">% preparation of pda step 2</span>

    <span class="keyword">if</span> dispDepth &gt;= 5 <span class="comment">% additional information</span>
        fprintf(<span class="string">'   norm(KdAdjyd) = %g\n'</span>,norm(KdAdjyd));
        fprintf(<span class="string">'   max(KdAdjyd) = %g\n'</span>,max(KdAdjyd));
        fprintf(<span class="string">'   min(KdAdjyd) = %g\n'</span>,min(KdAdjyd));
    <span class="keyword">end</span>

    <span class="comment">% -- test start</span>
    <span class="comment">%seti.KdAdj = @(yd,JA,JB) seti.S(seti.GD(ADFFqFast(seti.T(yd),JA,JB,seti)));</span>

    <span class="keyword">if</span> 0
    <span class="keyword">if</span> iPda == 10
        disp(<span class="string">'iPda = 10'</span>);

        figure(101);
        imagesc(real(seti.T(ydnp))); colorbar; axis <span class="string">xy</span>;
        figure(102);
        imagesc(imag(seti.T(ydnp))); colorbar; axis <span class="string">xy</span>;

        figure(103);
        imagesc(real(seti.T(ydnp))+imag(seti.T(ydnp))); colorbar; axis <span class="string">xy</span>;

        A = ADFFqFast(seti.T(ydnp),JA,JB,seti);
        Amat = seti.G(A);
        figure(104);
        imagesc(real(Amat)); colorbar; axis <span class="string">xy</span>;
        figure(105);
        imagesc(imag(Amat)); colorbar; axis <span class="string">xy</span>;

        B = seti.GD(A);

        C = seti.S(B);

        figure(106);
        imagesc(seti.G(seti.R(xnRVD))); colorbar; axis <span class="string">xy</span>;
        figure(107);
        imagesc(seti.G(seti.I(xnRVD))); colorbar; axis <span class="string">xy</span>;

        error(<span class="string">'stop'</span>);
    <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% -- test end</span>

    KAdjySum = KAdjySum + KdAdjyd; <span class="comment">% preparation of pda step 2</span>

    <span class="comment">% 2) fs etc. in F</span>
    <span class="keyword">if</span> ismember(<span class="string">'fs'</span>,tF) <span class="comment">% fs in F</span>
        <span class="keyword">if</span> dispDepth &gt;= 4
            disp(<span class="string">'case fs in F not yet.'</span>)
        <span class="keyword">end</span>
    <span class="keyword">elseif</span> ismember(<span class="string">'fsw'</span>,tF) <span class="comment">% fsw in F</span>
        wysw = wyi(yswn,seti.Ksw); <span class="comment">% w_{y_sw}</span>
        yswnp = proxFswPlus(sigma,seti.vsw(qCVU),wysw,seti); <span class="comment">% prox_{sigma F_s^+}(w_y_s)</span>
        <span class="comment">% ysnp is down scaled</span>
        <span class="comment">%KswAdjys = seti.KswAdj(GURV(yswnp)); % preparation of pda step 2</span>
        KswAdjys = seti.KswAdj(yswnp); <span class="comment">% preparation of pda step 2</span>
        KAdjySum = KAdjySum + KswAdjys; <span class="comment">% preparation of pda step 2</span>
        clear <span class="string">wysw</span> <span class="string">KswAdjys</span>;
    <span class="keyword">else</span>
        <span class="keyword">if</span> iOut == 1 &amp;&amp; iPda == 1
            <span class="keyword">if</span> dispDepth &gt;= 4
                disp(<span class="string">'    - Note: No term like fs (sparsity) is used in F.'</span>)
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>


    <span class="comment">% 3) fg etc. in F</span>
    <span class="keyword">if</span> ismember(<span class="string">'fg'</span>,tF) <span class="comment">% fg in F</span>
        wygVal = wyg(ygnRMD,seti.Kg); <span class="comment">% w_{y_g}</span>
        ygnp = proxFgPlus(sigma,seti.vg(qCVU),wygVal,seti); <span class="comment">% prox_{sigma F_g^+}(w_y_g)</span>
        <span class="comment">%fprintf('proxFgPlus: sigma = %g | max(vg) = %g | max(wyg) = %g\n',sigma,max(max(max(abs(seti.vg(qCVU))))),max(max(max(abs(wygVal)))));</span>
        KgAdjyg = seti.KgAdj(ygnp); <span class="comment">% preparation of pda step 2</span>

        <span class="keyword">if</span> dispDepth &gt;= 5 <span class="comment">% additional information</span>
            fprintf(<span class="string">'   norm(KgAdjyg) = %g\n'</span>,norm(KgAdjyg));
            fprintf(<span class="string">'   max(KgAdjyg) = %g\n'</span>,max(KgAdjyg));
            fprintf(<span class="string">'   min(KgAdjyg) = %g\n'</span>,min(KgAdjyg));
        <span class="keyword">end</span>

        KAdjySum = KAdjySum + KgAdjyg; <span class="comment">% preparation of pda step 2</span>
        <span class="comment">%clear wygVal KgAdjyg;</span>
    <span class="keyword">end</span>

    <span class="comment">% 4) fp etc. in F</span>
    <span class="keyword">if</span> ismember(<span class="string">'fp'</span>,tF)
        <span class="keyword">if</span> dispDepth &gt;= 4
            disp(<span class="string">'fp in F not implemented. Maybe not useful.'</span>)
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">%-- pda step 2: prox_G(w_x) (Resolvente zu G)</span>
    wx = wxF(KAdjySum); <span class="comment">% grid down and real</span>

    <span class="comment">% order: dsgp, e.g. proxGsp, proxGp</span>
    <span class="comment">% fitting to fclass = [&lt;d&gt; &lt;s&gt; &lt;g&gt; &lt;p&gt;]</span>
    <span class="comment">% f_d in G does not make sense</span>

    <span class="comment">%fG = (fclass == 2);</span>
    <span class="keyword">if</span> ismember(<span class="string">'fd'</span>,tG) || ismember(<span class="string">'fdw1'</span>,tG) || ismember(<span class="string">'fdw2'</span>,tG)
        error(<span class="string">'f_d in Term G does not make sense.'</span>)
    <span class="keyword">elseif</span> isequal({<span class="string">'fs'</span>},tG)
        xnpRVD = proxGs(tau,seti.alpha,seti.vs(qCVU),wx); <span class="comment">% prox_{\tau G_s}(w_x)</span>
        <span class="comment">% to do: implement proxGs</span>
    <span class="keyword">elseif</span> isequal(sort({<span class="string">'fs'</span>,<span class="string">'fp'</span>}),sort(tG))
        vsp = seti.vs(qCVU); <span class="comment">% seti.vs = seti.vp in setiFuncs</span>
        <span class="comment">% qCVU does not change...</span>
        <span class="comment">% you can compute it at the beginning of pda</span>
        <span class="comment">% the same with vp, vsp...</span>
        xnpRVD = proxGsp(tau*seti.alpha*seti.dVinv,vsp,wx,seti);

        <span class="keyword">if</span> dispDepth &gt;= 5 <span class="comment">% additional information</span>
            fprintf(<span class="string">'   max(wx) = %g\n'</span>,max(wx));
            fprintf(<span class="string">'   max(xnpRVD) = %g\n'</span>,max(xnpRVD));
            fprintf(<span class="string">'   kappa = %g\n'</span>,tau*seti.alpha*seti.dVinv);
        <span class="keyword">end</span>
        <span class="comment">%fprintf('proxGsp: tau = %g | alpha*dV = %g | max(wx) = %g | max(vsp) = %g\n',tau,seti.alpha*seti.dVinv,max(max(abs(wx))), max(abs(vsp)));</span>
        <span class="comment">%xnp = proxGsp(tau,alpha,vsp,wx); % prox_{\tau G_sp}(w_x)</span>
    <span class="keyword">elseif</span> isequal(sort({<span class="string">'fs'</span>,<span class="string">'fp2'</span>}),sort(tG))
        vsp = seti.vs(qCVU);
        xnpRVD = proxGsp2(tau*seti.alpha*seti.dVinv,vsp,wx,seti);

        <span class="keyword">if</span> dispDepth &gt;= 5 <span class="comment">% additional information</span>
            fprintf(<span class="string">'   max(wx) = %g\n'</span>,max(wx));
            fprintf(<span class="string">'   max(xnpRVD) = %g\n'</span>,max(xnpRVD));
            fprintf(<span class="string">'   kappa = %g\n'</span>,tau*seti.alpha*seti.dVinv);
        <span class="keyword">end</span>
    <span class="keyword">elseif</span> isequal({<span class="string">'fp'</span>},tG)
        <span class="comment">% to do: rewrite seti.vsw, so that the arg is grid down</span>
        vp = seti.vs(qCVU);
        xnpRVD = proxGp(reMin,reMax,imMin,imMax,vp,wx,seti); <span class="comment">% prox_{\tau G_p}(w_x)</span>
    <span class="keyword">else</span>
        disp(<span class="string">'The wanted prox_G is not implemented yet.'</span>)
        error(<span class="string">'stop'</span>);
    <span class="keyword">end</span>
    <span class="comment">% xnp: grid down and real</span>

    <span class="comment">%-- pda step 3:</span>
    xmnpRVD = xnpRVD+theta.*(xnpRVD-xnRVD); <span class="comment">% xmnp: grid down and real</span>

    <span class="comment">%----- end of: pda algorithm steps -----</span>


    <span class="comment">% store to use in adaptive stepsize (is needed upscaled)</span>
    xnRVDstore = xnRVD;
    xnpRVDstore = xnpRVD;

    <span class="comment">%-- prepare new iteration</span>

    <span class="keyword">if</span> exist(<span class="string">'ydnp'</span>,<span class="string">'var'</span>) &amp;&amp; isnumeric(ydnp)
        ydnRM = ydnp;
    <span class="keyword">end</span>
    <span class="keyword">if</span> exist(<span class="string">'yswnp'</span>,<span class="string">'var'</span>) &amp;&amp; isnumeric(yswnp)
        yswn = yswnp;
    <span class="keyword">end</span>
    <span class="keyword">if</span> exist(<span class="string">'ygnp'</span>,<span class="string">'var'</span>) &amp;&amp; isnumeric(ygnp)
        ygnRMD = ygnp;
    <span class="keyword">end</span>
    <span class="keyword">if</span> exist(<span class="string">'ypnp'</span>,<span class="string">'var'</span>) &amp;&amp; isnumeric(ypnp)
        ypn = ypnp;
    <span class="keyword">end</span>

    xnRVD = xnpRVD;
    xmnRVD = xmnpRVD;

    <span class="keyword">if</span> speed == 0

        <span class="comment">% xnRVD: solution (real vector grid down)</span>

        <span class="comment">%-- store values of functions F, G</span>

        DFFqh = DFFq(xnRVD);
        Fval(iPda) = F(DFFqh,FFqMeas,qCVU,xnRVD);
        Gval(iPda) = G(qCVU,xnRVD);
        FGval(iPda) = Fval(iPda) + Gval(iPda);

        <span class="comment">%relLinDisc = linDiscr(DFFqh,FFq)/linDiscr(0*DFFqh,FFq); % altern. for abs lin. dis.</span>
        <span class="comment">%relLinDisc = linDiscr(DFFqh,FFq)/normws(FFq-seti.FmeasDelta,seti);</span>

        disLinInPda(iPda) = normws(seti.S(DFFqh)+seti.S(FFqMeas-seti.FmeasDelta),seti)/normws(seti.FmeasDelta,seti);

        <span class="comment">% dis of last iOut</span>
        <span class="keyword">if</span> iOut == seti.iOutIni+1
            dis = seti.disIni;
        <span class="keyword">else</span>
            dis = seti.dis(iOut-1);
        <span class="keyword">end</span>
        relLinDis(iPda) = disLinInPda(iPda)/dis;
        clear <span class="string">dis</span>;
        hsolCVUcurrent = seti.GU(seti.T(xnRVD));
        errInPda(iPda) = norm(seti.qROIexact-(qCVU+hsolCVUcurrent),2)/norm(seti.qROIexact,2); <span class="comment">% relative error in 2-Norm</span>

        <span class="comment">%-- compute discrepancy and penalty terms</span>

        <span class="keyword">if</span> dispDepth &gt;= 4
            fprintf(<span class="string">'    - i = %03d | stepsizes: tau = %1.2g, sigma = %1.2g\n'</span>,iPda,tau,sigma)
            fprintf(<span class="string">'               F = %1.2g | G = %1.2g | F + G = %1.2g \n'</span>,Fval(iPda),Gval(iPda),FGval(iPda))
        <span class="keyword">end</span>
        <span class="keyword">if</span> ismember(<span class="string">'fd'</span>,tFG)
            fd(iPda) = seti.fd(DFFqh,FFqMeas);
            <span class="keyword">if</span> dispDepth &gt;= 4
                fprintf(<span class="string">'               f_d = %1.2g \n'</span>,fd(iPda))
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> ismember(<span class="string">'fs'</span>,tFG)
            fs(iPda) = seti.fs(qCVU,xnRVD);
            <span class="keyword">if</span> dispDepth &gt;= 4
                fprintf(<span class="string">'               f_s = %1.2g\n'</span>,fs(iPda))
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> ismember(<span class="string">'fg'</span>,tFG)
            fg(iPda) = seti.fg(qCVU,xnRVD);
            <span class="keyword">if</span> dispDepth &gt;= 4
                fprintf(<span class="string">'               f_g = %1.2g\n'</span>,fg(iPda))
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> ismember(<span class="string">'fp'</span>,tFG)
            fp(iPda) = seti.fp(qCVU,xnRVD);
            <span class="keyword">if</span> dispDepth &gt;= 4
                fprintf(<span class="string">'               f_p = %1.2g\n'</span>,fp(iPda))
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> dispDepth &gt;= 4
            fprintf(<span class="string">'               disLinInPda = %1.2g | RelLinDis = %1.2g \n'</span>,disLinInPda(iPda),relLinDis(iPda))
            fprintf(<span class="string">'               errInPda = %1.2g \n'</span>,errInPda(iPda))
        <span class="keyword">end</span>

        <span class="keyword">if</span> iPda &gt; 0 &amp;&amp; seti.useTolIn == 1 &amp;&amp; relLinDis(iPda) &lt; ThetaiOut
            <span class="keyword">if</span> dispDepth &gt;= 3
                disp(<span class="string">'    - Break pda because inner tolerance principle.'</span>)
            <span class="keyword">end</span>
            <span class="keyword">break</span>;
        <span class="keyword">end</span>

        <span class="keyword">if</span> stopPda == 1 &amp;&amp; iPda &gt;= 3 &amp;&amp; norm(FGval(iPda)-FGval(iPda-2)) + norm(FGval(iPda)-FGval(iPda-1)) &lt; 1E-6*norm(FGval(iPda))
            <span class="keyword">if</span> dispDepth &gt;= 3
                disp(<span class="string">'    - Break pda because changes are below tolerance.'</span>)
            <span class="keyword">end</span>
            <span class="keyword">break</span>;
        <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="comment">% plots inside pda not available in public version</span>
    <span class="keyword">if</span> seti.plotFreqiPda ~= 0 &amp;&amp; (seti.plotFreqiPda == 1 || floor(iPda/seti.plotFreqiPda) == iPda/seti.plotFreqiPda)
        plotInsidePda;
    <span class="keyword">end</span>

    <span class="comment">% --</span>

    <span class="comment">% final:</span>
    <span class="comment">% x = xnp: min_x F(Kx) + G(x); here: x = hs;</span>

<span class="keyword">end</span>

pdaStopInd = iPda;

<span class="keyword">if</span> speed == 1
    <span class="comment">% xnRVD is the solution h (but grid down and real)</span>
    xnCVD = seti.T(xnRVD);
    DFFqh = DFFq(xnCVD);
    Fval(pdaStopInd-1) = F(DFFqh,FFqMeas,qCVU,xnCVD);
    Gval(pdaStopInd-1) = G(qCVU,xnCVD);
    FGval(pdaStopInd-1) = Fval(iPda) + Gval(iPda);
<span class="keyword">end</span>

<span class="keyword">if</span> speed == 0
    <span class="comment">% parts of functional f to minimize</span>
    minf.fd = fd;
    minf.fs = fs;
    minf.fg = fg;
    minf.fp = fp;
<span class="keyword">end</span>

<span class="comment">% output solution: xnRVD -&gt; xnCVU</span>
hsolCVU = seti.GU(seti.T(xnRVD)); <span class="comment">% Update (q := q+h) (q,h complex)</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="16">Code: subfunction to K components norm</h2><p><b>KcomponentsStruct</b></p><pre class="codeinput"><span class="keyword">function</span> [KcompNorm,KvarNames] = KcomponentsStruct(Kcomp,seti)
<span class="comment">% like Kcomponents but with input Kcomp as struct</span>
<span class="comment">%n = length(fieldnames(Kcomp)); % number of K_1, K_2, ..., K_n</span>
fields = fieldnames(Kcomp); <span class="comment">% e.g. 'Kd' 'Kg' 'Kp'; varNames(1) = 'Kd'</span>
<span class="comment">% if Kd... then normws2, otherwise normroi2</span>
KcompNorm = @(xnRVD,JA,JB) 0;
<span class="comment">% i = 1: must be Kd, so with normws2 norm</span>
i = 1;
KcompNorm = @(xnRVD,JA,JB) KcompNorm(xnRVD,JA,JB) + normws2(Kcomp.(fields{i})(xnRVD,JA,JB),seti)^2;
<span class="keyword">for</span> i = 2:numel(fields)
    <span class="comment">%Kcomp.(fields{i})</span>
    <span class="keyword">if</span> strcmp(<span class="string">'Kg'</span>,fields(i))
        KcompNorm = @(xnRVD,JA,JB) KcompNorm(xnRVD,JA,JB) + normTVinv2(Kcomp.(fields{i})(xnRVD),seti)^2;
    <span class="keyword">else</span>
        KcompNorm = @(xnRVD,JA,JB) KcompNorm(xnRVD,JA,JB) + norminv2(Kcomp.(fields{i})(xnRVD),seti)^2;
    <span class="keyword">end</span>
    <span class="comment">%fprintf('Kcomp inputname: %s\n',inputname(i))</span>
    <span class="comment">%KvarNames{i} = fields{i};</span>
<span class="keyword">end</span>
KcompNorm = @(xnRVD,JA,JB) sqrt(KcompNorm(xnRVD,JA,JB));
<span class="comment">% KcompNorm = \sqrt{ \|\cdot\|_WHS^2 + \|\cdot\|_\ROI^2 + ... }</span>
KvarNames = fields;
<span class="keyword">end</span>
</pre><h2 id="17">Code: subfunctions to F and G (sum)</h2><p><b>Fsum</b></p><pre class="codeinput"><span class="keyword">function</span> F = Fsum(tF,seti)
<span class="comment">% e.g. F = f_d + f_s, when tF stores fd and fs</span>
<span class="comment">% call F = Fsum(tF,seti) and later F(DFFqh,FFq,qCVU,xnRVD)</span>
<span class="comment">%old q = qCVU, old hz = xnRVD</span>
Fsum = @(DFFqh,FFq,qCVU,xnRVD) 0;
<span class="keyword">for</span> i = 1:length(tF)

    fj = seti.(tF{i});
    <span class="keyword">if</span> ismember(tF(i),{<span class="string">'fd'</span>,<span class="string">'fdw1'</span>,<span class="string">'fdw2'</span>,<span class="string">'fdw3'</span>}) <span class="comment">% f_d, f_dw etc. does need input arguments DFFqh and FFq</span>
        Fsum = @(DFFqh,FFq,qCVU,xnRVD) Fsum(DFFqh,FFq,qCVU,xnRVD) + fj(DFFqh,FFq);
    <span class="keyword">else</span> <span class="comment">% other like f_s, f_p does need input arguments q and hz</span>
        Fsum = @(DFFqh,FFq,qCVU,xnRVD) Fsum(DFFqh,FFq,qCVU,xnRVD) + fj(qCVU,xnRVD);
    <span class="keyword">end</span>
    clear <span class="string">fj</span>;
<span class="keyword">end</span>
<span class="comment">%if strcmp('tF',inputname(1)) % input tF, so you want to get F</span>
F = @(DFFqh,FFq,qCVU,xnRVD) Fsum(DFFqh,FFq,qCVU,xnRVD);
clear <span class="string">i</span> <span class="string">Fsum</span>;
<span class="keyword">end</span>
</pre><p><b>Gsum</b></p><pre class="codeinput"><span class="keyword">function</span> G = Gsum(tG,seti)
<span class="comment">% similar to Fsum, but only 2 arguments</span>
<span class="comment">% call G = Gsum(tG,seti)</span>
Gsum = @(q,hz) 0;
<span class="keyword">for</span> i = 1:length(tG)
    fj = seti.(tG{i});
    Gsum = @(q,hz) Gsum(q,hz) + fj(q,hz);
    clear <span class="string">fj</span>;
<span class="keyword">end</span>
G = @(q,hz) Gsum(q,hz);
clear <span class="string">i</span> <span class="string">Gsum</span>;
<span class="keyword">end</span>
</pre><h2 id="19">Code subfunctions to proximal mappings</h2><p><b>proxFdPlus</b></p><pre class="codeinput"><span class="keyword">function</span> res = proxFdPlus(sigma,vd,wyd) <span class="comment">% d: discrepancy</span>
<span class="comment">% f_d(x) = 1/2 ||S(FF'(q)[x]) + vd||_WS,2^2, here with vd = S(FFq-y^\delta)</span>
<span class="comment">% res = y_d^(n+1) = \prox_{\sigma F_d^+} (w_y_d)</span>
res = (wyd+sigma*vd)/(1+sigma);
<span class="keyword">end</span>
</pre><p><b>proxFdw1Plus</b></p><pre class="codeinput"><span class="keyword">function</span> res = proxFdw1Plus(sigma,vd,wyd,seti)
<span class="comment">%f_dw(x) = 1*||S(FF'(q)[x]) + vd||WS,2^1, here with vd = S(FF(q)-y^\delta)</span>
<span class="comment">% res = y_dw1^(n+1) = \prox_{\sigma F_dw1^+} (w_y_dw1)</span>
<span class="comment">% seti in normws is seti.pNorm, here seti.pNorm must be 2</span>
<span class="comment">% (in pda with invOps=3,4,5,6 always seti.pNorm = 2 and seti.qNorm = 1)</span>
res = (wyd+sigma*vd)/max(1,normws(wyd+sigma*vd,seti));
<span class="keyword">end</span>
</pre><p><b>proxFdw3Plus</b></p><pre class="codeinput"><span class="keyword">function</span> res = proxFdw3Plus(sigma,vd,wyd,seti)
<span class="comment">%f_dw3(x) = (1/p)*||S(FF'(q)[x]) + vd||_p^p, here with vd = S(FF(q)-y^\delta)</span>
<span class="comment">% res = y_dw1^(n+1) = \prox_{\sigma F_dw3^+} (w_y_dw1)</span>

<span class="keyword">if</span> seti.pNorm &gt; 1
    <span class="comment">% requires seti.qNorm&gt;1</span>
    pPrime = seti.pNorm/(seti.pNorm-1);
    res = shrinkFuncComp(real(wyd+sigma*vd),sigma,pPrime,<span class="string">'newton'</span>)<span class="keyword">...</span>
        +1i*shrinkFuncComp(imag(wyd+sigma*vd),sigma,pPrime,<span class="string">'newton'</span>);

<span class="keyword">elseif</span> seti.pNorm==1
    res = max((abs(real(wyd+sigma*vd))-sigma),0).*sign(real(wyd+sigma*vd)) <span class="keyword">...</span>
        +1i*max((abs(imag(wyd+sigma*vd))-sigma),0).*sign(imag(wyd+sigma*vd));
<span class="keyword">else</span>
    disp(<span class="string">'seti.qNorm is less than one in pda.m (?!)'</span>);
<span class="keyword">end</span>

<span class="keyword">end</span>
</pre><p><b>proxFswPlus</b></p><pre class="codeinput"><span class="keyword">function</span> res = proxFswPlus(sigma,vs,wys,seti) <span class="comment">% s: sparse</span>
<span class="comment">% f_s(x) = ||alpha*x + v_s||_ROI,1</span>
<span class="comment">% factor alpha must be inside v_s</span>
<span class="comment">% res = y_s^(n+1) = \prox{\sigma F_s^+} (w_y_s)</span>
rho = seti.dVinv; <span class="comment">% This factor was corrected from 1 to seti.dVinv on 20181213.</span>
res = intProj(-rho,rho,wys+sigma*vs);
<span class="keyword">end</span>
</pre><p><b>proxFgplus</b></p><pre class="codeinput"><span class="keyword">function</span> res = proxFgPlus(sigma,vg,wyg,seti) <span class="comment">% g gradient</span>
<span class="comment">% f_g(x) = ||beta*\grad(x) + v_g||_ROI,1</span>
<span class="comment">% factor beta must be inside v_g</span>
<span class="comment">% res = y_g^(n+1) = \prox{\sigma F_g^+} (w_y_g)</span>
<span class="comment">% --</span>
<span class="comment">%res = intProj(-1,1,wyg+sigma*vg); % used until 20160406, and [20160412,20160414] % wrong...</span>
<span class="comment">%new: 20160406--20160412: was wrong...:</span>
<span class="comment">%t = wyg+sigma*vg;</span>
<span class="comment">%res = t./max(1,abs(t)/seti.dV);</span>
<span class="comment">% --</span>
<span class="comment">% new...</span>

z = wyg + sigma*vg;
<span class="comment">%prepare matrix of norm of tuples...</span>
d = size(z,1)/2;
nInv = size(z,2);
sizez = size(z);
zreshape = reshape(z,[2*d nInv^d]); <span class="comment">% for 2D and 3D</span>
<span class="comment">% compute norms</span>
tupelnorms = transpose(sqrt(sum(abs(zreshape).^2,1)));
<span class="comment">%tupelnormsReshape = reshape(tupelnorms,sizey(2:end)); % for 2D and 3D</span>
tupelnorms = reshape(tupelnorms,[1 sizez(2:end)]); <span class="comment">% second reshape to add one dimension</span>
tupelnorms = repmat(tupelnorms,[2*d 1 1]); <span class="comment">% repmat for element-wise use...</span>

<span class="comment">% tupelnormsMatElWise has the the same dimension as z and can used component-wise</span>
z = wyg+sigma*vg;
res = z./max(1,tupelnorms);
<span class="keyword">end</span>
</pre><p><b>proxGsp</b></p><pre class="codeinput"><span class="keyword">function</span> res = proxGsp(kappa,vsp,wx,seti) <span class="comment">% s: sparse AND p: physical</span>
<span class="comment">% G(x) = f_s(x) + f_p(x)</span>
<span class="comment">%      = \alpha ||x + v_s||_1 + \delta_[a,b](Re(x + v_p)) + \delta_[c,d](Im(x + v_p))</span>
<span class="comment">% important: v_s == v_p</span>
<span class="comment">% res = x^(n+1) = \prox_{\tau G_sp} (w_x)</span>
<span class="comment">% (shrinkage with bounds a and b)</span>
<span class="comment">%res = [shrinkage(wx+vsp,tau*alpha,a,b); shrinkage(wx+vsp,tau*alpha,c,d)]-1/seti.alpha*seti.S(vsp);</span>

<span class="keyword">if</span> isfield(seti,<span class="string">'omegaW1p'</span>)
    <span class="keyword">if</span> strcmp(seti.wavIsom,<span class="string">'W1p'</span>)
        res = [seti.shrkRe(seti.R(wx+vsp),kappa*seti.omegaW1p); seti.shrkIm(seti.I(wx+vsp),kappa*seti.omegaW1p)]-vsp;
    <span class="keyword">else</span>
        error(<span class="string">'Error in pda.m: seti.wavIsom not implemented.'</span>)
    <span class="keyword">end</span>
<span class="keyword">else</span>
    res = -vsp+[seti.shrkRe(seti.R(wx+vsp),kappa); seti.shrkIm(seti.I(wx+vsp),kappa)];
<span class="keyword">end</span>

<span class="keyword">end</span>
</pre><p>-------------------------------------------------------------------- <b>proxGsp2</b> (fs and fp2 in G)</p><pre class="codeinput"><span class="keyword">function</span> res = proxGsp2(kappa,vsp,wx,seti) <span class="comment">% s: sparse AND p: physical (p2 distinguishes obstacle and background)</span>
<span class="comment">% This function is similar to proxGsp. The difference is the splitting of</span>
<span class="comment">% the contrast in the obstacle and the background.</span>
<span class="comment">%</span>
<span class="comment">% G(x) = f_s(x) + f_p2(x)</span>
<span class="comment">%      = \alpha ||x + v_s||_1 + \delta_[a,b](Re(obs(x + v_p))) + \delta_[c,d](Im(obs(x + v_p)))</span>
<span class="comment">%                             + \delta_[0,0](Re(back(x + v_p))) + \delta_[0,0](Im(back(x + v_p)))</span>
<span class="comment">% Notation: obs does mean seti.qObs, and back does mean seti.qBack.</span>
<span class="comment">% In mathematical notation we chose: obs(x) = \check{x} and back(x) = \mathring{x}.</span>
<span class="comment">% important: v_s == v_p</span>
<span class="comment">% res = x^(n+1) = \prox_{\tau G_sp2} (w_x)</span>

<span class="comment">% long:</span>
<span class="comment">% wvBack = seti.qBack(seti.R(wx+vsp));</span>
<span class="comment">% wvBack = zeros(size(wvBack)); % physical bounds of background are zero, i.e. wvBack is zero</span>
<span class="comment">% short:</span>
wvBack = zeros(size(seti.nROI^seti.dim,1)); <span class="comment">% physical bounds of background are zero, i.e. wvBack is zero</span>

res = -vsp+[seti.qMerge(seti.shrkRe(seti.qObs(seti.R(wx+vsp)),kappa),wvBack); seti.qMerge(seti.shrkIm(seti.qObs(seti.I(wx+vsp)),kappa),wvBack)];

<span class="keyword">end</span>
<span class="comment">% --------------------------------------------------------------------</span>
</pre><p><b>proxGp</b></p><pre class="codeinput"><span class="keyword">function</span> res = proxGp(a,b,c,d,vp,wx,seti) <span class="comment">% p: physical... Potentialtopf-Funktion</span>
<span class="comment">% f_p(x) = \delta_[a,b](R(wx + v_p)) + \delta_[0,c](I(wx+v_p))</span>
<span class="comment">% res = x^(n+1) = \prox_{\tau G_p} (w_x)</span>
res = [intProj(a,b,seti.R(wx+vp)); intProj(c,d,seti.I(wx+vp))]-vp;
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% pda
% primal-dual algorithm in context of the 
% Computational Framework for Inverse Medium Problem in Scattering.
%
%% Syntax
%   [hsolCVU,pdaStopInd,FGval,Fval,Gval,relLinDis,disLinInPda,errInPda,minf] = pda(iOut,qCVU,ThetaiOut,seti,dispDepth)
%
%% Description
% |[hsolCVU,pdaStopInd,FGval,Fval,Gval,relLinDis,disLinInPda,errInPda,minf] 
% = pda(iOut,qCVU,ThetaiOut,seti)|
% computes the update |hsolCVU| of the linearized minimization problem.
%
%
%% Input Arguments
%
% Most important input arguments (there are more...)
%
% * iOut        :   number of (current) outer iteration
% * qCVU        :   reconstructed contrast q as vector of size
%                   seti.nROI^seti.dim x 1.
%                   (CVU does mean complex, vector, upscaled)
% * ThetaiOut   :   inner tolerance, see <minTolIn.html>
%                   (only required if inner tolerance principle is used by
%                   seti.useTolIn = 1; otherwise it is set to 0.)
% * seti        :   struct seti
% * dispDepth   :   depth of displayed messages
%                   (greater or equal 3 to see aything in this file).
%                   (3 less, 4 default, 5 additional information).
%
% *Some of the fields in struct seti*
%
% Note that several fields in struct seti are necessary to run pda.
%
% The routine |pda| is an internal one that needs the specific environment created in
% the package.
%
% * seti.dim    :   dimension of the problem (2 or 3)
% * seti.nROI   :   discretization points for each dimension
%                   of region of interest (ROI) (in samples)
%
% * seti.pdaN   :   number of inner iterations (PDA) (is called nPda)
% * seti.pdaStepsize    :   method to choose primal and dual stepsizes
%                           (|'fix'| (default) or |'adaptive'|), 
%                           see <pdaChoosingStepsizes.html>.
% * seti.vartheta       :   parameter in (0,1) used in case of adaptive stepsizes,
%                           see <pdaChoosingStepsizes.html>.
%
%
%% Output Arguments
%
% * hsolCVU     :   solution of the update h
%                   (at the end of pda: hsolCVU = seti.GU(seti.T(xnRVD)))
% * pdaStopInd  :   iteration, where primal-dual agorithm was stopped
%                   (iPda = 1:nPda, but maybe is stopped earlier becaue
%                   usage of seti.useTolIn or seti.useTolOut)
%                   (see <minTolIn.html>, <minTolOut.html>, <minPda.html>).
% * FGval       :   stores values of $F(Kh) + G(h)$ (vector of size nPda x 1)
% * Fval        :   stores values of $F(Kh)$ (vector of size nPda x 1)
% * Gval        :   stores values of $G(h)$ (vector of size nPda x 1)
% * relLinDis   :   quotient: relLinDis = disLin / dis 
%                   (vector of size nPda x 1)
% * disLinInPda :   discrepancy of linearized problem for each inner iteration step
%                   (vector of size nPda x 1)
% * errInPda    :   relative error of the reconstructed contrast qROI
%                   (vector of size nPda x 1)
% * minf        :   struct with parts of the minimization functional
%                   (Tikhonov functional)
%
% * minf.fd     :   discrepancy of linearized problem
%                   (vector of size nPda x 1)
% * minf.fs     :   sparsity penalty
%                   (vector of size nPda x 1)
% * minf.fg     :   total variation penalty
%                   (vector of size nPda x 1)
% * minf.fp     :   penalty for physical bounds
%                   (vector of size nPda x 1)
%
% See "More About" for formulas.
%
%
%% More About
%
% *Minimization functional*
%
% The function pda minimizes the *Tikhonov functional* of the linearized
% problem, i.e. 
%
% $$ \min_{h \in X} 
%      \underbrace{
%          \frac{1}{2}\|\mathcal{F}'(q)[h]+\mathcal{F}(q) - F_\mathrm{meas}^\delta\|_\mathrm{F}^2
%          }_{=: f_\mathrm{dis}(h),\ \mathrm{discrepancy\ (linearized\ problem)}}
%    + \underbrace{\alpha \|q+h\|_\mathrm{1}}_{=: f_\mathrm{spa}(h),\ \mathrm{sparsity\ penalty}}
%    + \underbrace{\beta \| \nabla (q+h) \|_\mathrm{1}}_{=: f_\mathrm{tv}(h),\ \mathrm{total\ variation\ penalty}}
%    + \underbrace{
%          \delta_{[a,b]}( \mathrm{Re}(q+h) ) +
%          \delta_{[c,d]}(\mathrm{Im}(q+h) )}_{=: f_\mathrm{phy}(h),\ \mathrm{penalty\ for\ physical\ bounds}
%          }.
%    $$
%
% *Next step*
%
% The update $q := q + h$ is done in <minPda.html>, see also "More About" 
% in <start.html> to see the connection.
%
% *Splitting the minimization problem*
%
% In pda we formulate the minimization problem as:
% 
% $$ \min_{h \in X} F(Kh) + G(h)$$
% 
% with
% 
% $F(Kh) = f_\mathrm{dis}(h) + f_\mathrm{tv}(h)$,
% 
% $G(h)  = f_\mathrm{spa}(h) + f_\mathrm{phy}(h)$.
% 
% * The splitting in $F$ and $G$ is done to be in the setting of primal-dual
% algorithm, see [2]. (The primal problem can be reformulated as primal-dual
% problem which leads to the primal-dual algorithm.)
%
% * Other identifications of the functionals $F$ and $G$ are possible, but in
% public version of this package we only provide this one.
% (This identification is set in <setInvType.html> with parameter
% |seti.invNo = 6|.)
% 
%
% *The primal-dual algorithm*, for convex problems, see Algorithm 1 in [2]:
%
% * Note that $F^\ast$ is the Fenchel conjugate of $F$.
% * The x in the algorithm corresponds to h above.
%
% * Initialization:
%
% Choose
% primal step size $\tau > 0$,
% dual step size $\sigma > 0$,
% initial vectors $(x^0,y^0) \in X \times Y$
% (e.g. $x^0 = 0$, $y^0 = 0$),
% and set $\bar{x}^0 = x^0$.
%
% * Iterations ($n \geq 0$): Update $x^n, y^n, \bar{x}^n$ as follows:
%
% 1. $\quad y^{n+1} = (I + \sigma \partial F^\ast)^{-1}
%  (y^n + \sigma K \bar{x}^n)$,
%
% 2. $\quad x^{n+1} = (I + \tau \partial G)^{-1}
%  (x^n - \tau K^\ast y^{n+1})$,
%
% 3. $\quad \bar{x}^{n+1} = 2x^{n+1} - x^n.$
%
% The motivation of this algorithm is: 
% 3. is an over-relaxation step, and
% 1.-2. are fixed-point iterations (derived from extremality conditions).
%
%
% *Application of primal-dual algorithm in this package*
%
% To apply the primal-dual algorithm in the context of inverse scattering
% we have to remember that the contrast $q$ is complex, but 
% real vector spaces are indeed crucial for the primal-dual algorithm.
%
% Therefore *transformation operators* are introduced in 
% <setIdImagReal.html>, see also Section 4.5 in [1]:
%
% * $\texttt{seti.S}
%  = T_{\bf{C} \to \bf{R}^2} : \bf{C} \to \bf{R} \times \bf{R}$, $\quad$
% $T_{\bf{C} \to \bf{R}^2}(x) = (\mathrm{real}(x),\,  \mathrm{imag}(x))$.
%
% * $\texttt{seti.T} 
% = T_{\bf{R} \to \bf{C}} : \bf{R} \times \bf{R} \to \bf{C}$, $\quad$
% $T_{\bf{R} \to \bf{C}} = 
%  y^{\mathrm{real}} + \mathrm{i}\,y^{\mathrm{imag}} 
%  \mathrm{\ where\ } y = (y^{\mathrm{real}},y^{\mathrm{imag}})$.
%
%
% The full iterative reconstruction scheme 
% (with respect to transformation operators)
% is given in Section 4.4 of [1].
%
% A full derivation is given in Setion 4 of [1].
%
% The defintion of functions is done in <setFuncsPda.html> 
% (i.e. discrepancy, penalty terms, components of K and their adjoints,
% ...).
%
%
% *Grid scaling*
%
% Additionally, in the code a grid scaling is respected to offer to compute
% the reconstruction on a coarser grid. Therefore we use
%
% * seti.GU     :   function to scale up the grid,
% * seti.GD     :   function to scale down the grid.
%
% For details see <setGridScale.html>.
%
% Note that grid scaling is not explained explicitly in [1].
%
%
%% References
%
% * [1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. _Journal of Computational Physics_, 339:1-30, 2017.
% * [2] Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. _Journal of Mathematical Imaging and Vision_, 40(1):120-145, 2011.
%
%
%% See Also
%
% * <start.html>
% * <minPda.html>
% * <minTolIn.html>
% * <minTolOut.html>
% * <setInvType.html>
% * <setIdImagReal.html>
% * <setFuncsPda.html>
% * <setGridScale.html>
%
%
%% Code: function: pda
%
function [hsolCVU,pdaStopInd,FGval,Fval,Gval,relLinDis,disLinInPda,errInPda,minf] = pda(iOut,qCVU,ThetaiOut,seti,dispDepth)
% pda: primal dual algorithm

if ~isequal(size(qCVU),[seti.nROI^seti.dim,1])
    error('size of qCVU does not fit.')
end
% qROI is a complex vector (and not scaled down)

% qCVU = qROI: complex vector upscaled (full) grid

% q: contrast: fixed in pda
% h: update of contrast (changes in pda) (in minPda: new q = q + h)

% Meaning of characters:
% C, R: stored complex or as real values
% M, V: matrix or vector
% U, D: full grid (upscaled, nROI) or small grid (downscaled, nInv)
% e.g.: CMU... is a complex matrix upscaled

% seti.pdaStepsize = 'adaptive'; % fix or adaptive
% is set in checkConsisRec (or in a file inseti...)

GUCV = seti.GU; % input and output is a complex vector (not stored as matrix)
GDCV = seti.GD; % input and output is a complex vector (not stored as matrix)
% iG and G inside GU and GD does matrix <-> vector

% input and output is the complex vector stored in real (RxR instead of C)
GURV = @(x) seti.S(GUCV(seti.T(x))); % RxR -> C, then GU fits, then C -> RxR
GDRV = @(x) seti.S(GDCV(seti.T(x))); % analog; GDRV is currently unused

% qROI is fix in pda algorithm
% store it in different formats... (to use it fast)
% qCVU = qCVU;
qRVU = seti.S(qCVU); % currently unused
qCVD = GDCV(qCVU);
qRVD = seti.S(qCVD); % currently unused

% qROI not down-scaled in this file
% (and not before; qROI is a fixed vector in this file)

% x is down-scaled
% final h is upscaled

% M1a, M1b only in case of seti.useWavelet == 1

% hs is real x real; h is corresponding complex
% inside pda: hs is used, but output is complex h

% in case of using pda: checkConsistency.m set
%seti.pNorm = 2; % then WHS-Norm is used(!) (important)
%seti.qNorm = 1;
% if you change pNorm or qNorm you have to change proximal mappings etc.

% inside pda h is real: hs = [hr; hi] = [real(h); imag(h)]
% outside: h is complex (so h = hz)

%[m,~,~] = size(A); 1:m/2 is real part and m/2+1:end is imag part

% notation:
% qROI is complex(!)
% qr = real(qROI);
% qi = imag(qROI);
% q = [qr;qi]; % in 2D: in R^{2 nROI^2}; in 3D: in R^{2 nROI^3}
% analog: h

% in this file: q = qROI is qROI and NOT W(qROI)

speed = 0;
stopPda = 0; % 0 or 1: break pda if changes are below tolerance

nPda = seti.pdaN; % number of iterations

reMin = seti.physBounds(1);
reMax = seti.physBounds(2);
imMin = seti.physBounds(3);
imMax = seti.physBounds(4);

% first-order primal-dual algorithm (pda)
% for convex problems (paper: Chambolle, Pock, 2011)

% input:
% K: X -> Y: continuous linear operator
% nonlinear primal problem: min_{x \in X} F(Kx) + G(x)
% FC:= F; GC:= G (to have different names to shrinakge...)

% Symbols:
%
% F^\star: convex conjugate of F
% K^\ast: adjoint of K (symbol: *)

% P = seti.pNorm;
% Q = seti.qNorm;
% setting must be: P = 2; Q = 1; % see setInvType

if dispDepth >= 3
    disp('    - Compute auxiliary matrices JA and JB for Jacobian matrix');
end
tic
[JA,JB] = mimo(seti, qCVU, 'jacobian');
tocJac = toc(tic);
if dispDepth >= 3
    fprintf('      Elapsed time of computation of Jacobian matrices is %05.1f min.\n',tocJac/60);
end

%% Code: function: pda: F and G terms
% tF: term F
% tG: term G
clear tF tG;
% tF and tG are set in setInvType
% look there for details, which terms are F and G (or not used)
tF = seti.tF;
tG = seti.tG;
tFG = [tF,tG]; % term FG contains terms of F and G

%% Code: function: pda: initialization

qCVDsize = size(qCVD); % q complex vector downsize
% Consistency check
if ~isequal(qCVDsize,[seti.nInv^seti.dim,1])
    error('pda: qCVDsize does not fit.')
end

yCMsize = size(seti.FmeasDelta); % y size (complex matrix)
if ~isequal(yCMsize,[seti.measNb,seti.incNb])
    error('pda: ysize does not fit.')
end

xnRVD = [zeros(qCVDsize); zeros(qCVDsize)]; %x0 \in X = R^{2n} % real and down
% consistency check
if ~isequal(size(xnRVD),[2*seti.nInv^seti.dim,1])
    error('pda: xnRVD does not fit.')
end

xnRVDsize = size(xnRVD); % currently unused
xmnRVD = xnRVD;

% REPLACE_WITH_DASH_DASH choose K components and initializing y...
% if fclass(i,j) == 1 then you have to choose the fitting K component
% and define yn
% initialize yd0, ys0, ...
% using ysn in case of fs and fsw (because you will not use fs and fsw)
if ismember('fd',tF) || ismember('fdw1',tF) || ismember('fdw2',tF) || ismember('fdw3',tF) % f_d or f_dw1 or f_dw2 in F
    Kcomp.Kd = seti.Kd;
    ydnRM = [zeros(yCMsize); zeros(yCMsize)]; % y_d_0 \in Y = R^{2m x i}
    % y_d_0 \in Y_1=R^(2 measNb x incNb) (data), short Y=R^{2m x i}
    ydRMsize = size(ydnRM);
end
if ismember('fsw',tF) % f_sw in F
    Kcomp.Ksw = seti.Ksw;
    yswn = xnRVD; % y_s_0 \in Y_2 = R^{2n} (in sparsity term)
end
if ismember('fg',tF) % f_g in F
    Kcomp.Kg = seti.Kg;
    % ygn: size of grad(u) that is stored with components as real values (2*...)
    % in 2D: 2*dim x nInv x nInv
    % in 3D: 2*dim x nInv x nInv x nInv
    
    if seti.dim == 2
        ygnRMD = zeros(2*seti.dim,seti.nInv,seti.nInv); % y_g_0 \in Y_g (in gradient sparsity term)
    elseif seti.dim == 3
        ygnRMD = zeros(2*seti.dim,seti.nInv,seti.nInv,seti.nInv);
    end
    %ygn = zeros(2*seti.dim,qsize); % does not work
end
if ismember('fs',tF)
    error('fs in term F (tF) is not implemented.')
end

% KcomponentsStruct can be outside of pda (is needed one time)
[KcompNorm,KvarNames] = KcomponentsStruct(Kcomp,seti);
if iOut == 1 && dispDepth >= 3
    disp(' ')
    fprintf('    - Using K components: ')
    disp(KvarNames')
end

F = Fsum(tF,seti);
G = Gsum(tG,seti);

%DFFq = @(hz) JA*diag(hz)*JB; % for output: FF'(q)[h] (complex)
if strcmp(seti.model,'helmholtz2D') || strcmp(seti.model,'helmholtz3D')
    DFFq = @(xnRVD) JA*diagsparse(seti.GU(seti.T(xnRVD)))*JB;
elseif strcmp(seti.model,'helmholtzHMode2D')
    DFFq = @(xnRVD) JA(:,:,1)*diagsparse(seti.GU(seti.T(xnRVD)))*JB(:,:,1)...
        + JA(:,:,2)*diagsparse(seti.GU(seti.T(xnRVD)))*JB(:,:,2);
else
    %fprintf(strcat('Error in setFuncs - pda not implemented for model ',  seti.model))
    fprintf('Error in pda - pda not implemented for model %s.\n',  seti.model)
end
% with q = qCVU as input (you can use GU(qCVD) too)
% GUCV(T( . )): RVD -> CVU

if dispDepth >= 3
    disp('    - Compute FF(q)');
end
ticFFq = tic;

FFqMeas = mimo(seti, qCVU, 'simo');

% Slower (factor 2) alternative:
% FFqMeas = mimo(seti, qCVU,seti.T(ydnRM)); % expects complex qROI, Fmeas is 0; FFq is complex
% This is alternative is slower, because adjOfDer is computed but not
% needed.

% Notation in general:
% FFqmF  := FFqMeas - FmeasDelta
% ADFFq := FF'(q)^*[FF(q) - FmeasDelta] (Adjoint of derivative)
tocFFq = toc(ticFFq);
if dispDepth >= 3
    fprintf('      Elapsed time of FF(q) computation is %05.1f min.\n',tocFFq/60);
end

%% Code: function: pda: Algorithm 1

% ynp = y_{n+1}
% xnp = x_{n+1}
% xmnp = \={x}_{n+1} (x with makron)

% yn = y_n
% xn = x_n
% xmn = \={x}_n (x with Makron)

% x     : primal variable
% tau   : primal stepsize (tau > 0)
% y     : dual variable
% sigma : dual stepsize (sigma > 0)

% exact: ||K|| = max_{||h||_1 \neq 0} ||Kh||_HS / ||h||_1
% implementation with random Vektors h...

if dispDepth >= 3
    disp('    - L operator norm: numerical approximation')
end
ticOpNorm = tic;
L = opNormNum(xnRVD,JA,JB,KcompNorm,seti,dispDepth);
tocOpNorm = toc(ticOpNorm);
if dispDepth >= 3
    fprintf('      Elapsed time of operator norm L is %05.1f min.\n',tocOpNorm/60);
end
clear ticOpNorm tocOpNorm;
if dispDepth >= 3
    fprintf('      L = ||K|| = %g\n',L);
end

theta = 1; % pda algorithm theta = 1 such that the proof works (Th. 1 in [2].)
vartheta = seti.vartheta; % vartheta \in (0,1) in choosingStepsizes!!! (not theta from PDA...)

% pda algorithm

%% Code: function: pda: control results of F(K(h)) and G(h) (no influence on calculation)
Fval = zeros(nPda,1); % store values of FC(Kh)
Gval = zeros(nPda,1); % store values of GC(h)
FGval = zeros(nPda,1);
disLinInPda = ones(nPda,1); % linearized relative discrepancy
% disLinInPda = \|FF'(q)[h]+FF(q)-F_\meas^\delta\|_{WS,pNorm} / \|y^\delta\|_{WS,pNorm}
relLinDis = zeros(nPda,1); % relLinDis = disLin / dis;
errInPda = zeros(nPda,1); % relative error in pda

fd = zeros(nPda,1);
fs = zeros(nPda,1);
fg = zeros(nPda,1);
fp = zeros(nPda,1);

% Define variables... will be set in pdaChoosingStepsizes
xnUp = GURV(xnRVD);
xnpRVDstore = xnUp; % choosing needs upscaled
xnRVDstore = xnUp;
tau = 0;
sigma = 0;
tauVal = zeros(nPda,1); % vector to store tau values
sigmaVal = zeros(nPda,1); % vector to store sigma values

%% Code: function: pda: pda
for iPda = 1:nPda
    
    [tau,sigma] = pdaChoosingStepsizes(seti.pdaStepsize,L,iPda,xnpRVDstore,xnRVDstore,KcompNorm,tau,sigma,vartheta,seti,JA,JB);

    tauVal(iPda) = tau; % just to store...
    sigmaVal(iPda) = sigma; % just to store
    
    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- pda algorithm steps REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

    %REPLACE_WITH_DASH_DASH definition
    %wyi = @(yin,Ki) yin + sigma*GDRV(Ki(GURV(xmnRVD))); % down scaled (not for wyd)
    wyi = @(yin,Ki) yin + sigma*Ki(xmnRVD);
    % i is replaced by d, s or g (d and g extra cases...)
    wyd = @(ydn,Kd) ydn + sigma*Kd(xmnRVD,JA,JB);
    wyg = @(ygn,Kg) ygn + sigma*Kg(xmnRVD);
    wxF = @(KAdjy) xnRVD-tau*KAdjy; % w_x function handle
    %wx = wxF(KAdjy); % how to call it
    
    %REPLACE_WITH_DASH_DASH compute KAdjySum (prepare pda step 2)
    KAdjySum = 0;

    %REPLACE_WITH_DASH_DASH pda step 1: prox_F^+ (resolvent to F^+)
    % and prepare pda step 2 (compute KAdjySum)
    % 1) fd etc. in F (a discrepancy term should be in F)
    
    wydVal = wyd(ydnRM,seti.Kd); % w_{y_d}
    if ismember('fd',tF) % using Kd in cases of fd
        ydnp = proxFdPlus(sigma,seti.vd(FFqMeas),wydVal); % prox_{sigma F_d^+}(w_y_d)
        %fprintf('proxFdPlus: sigma = %g | max(vd) = %g | max(wyd) = %g\n',sigma,max(max(abs(seti.vd(FFq)))),max(max(abs(wydVal))));
    elseif ismember('fdw1',tF) % fdw1 in F (case seti.p = 1)
        ydnp = proxFdw1Plus(sigma,seti.vd(FFqMeas),wydVal,seti); % prox_{sigma F_d^+}(w_y_d)
    elseif ismember('fdw2',tF) % fdw2 in F (case seti.p == 2)
        ydnp = proxFdPlus(sigma,seti.vd(FFqMeas),wydVal); % prox_{sigma F_d^+}(w_y_d)
        % proxFdw2Plus = proxFdPlus because fdw2 = fd
    elseif ismember('fdw3',tF) % fdw3 in F (case seti.pNorm ~= 2)
        ydnp = proxFdw3Plus(sigma,seti.vd(FFqMeas),wydVal,seti); 
        % proxFdw2Plus = proxFdPlus because fdw2 = fd
    else
        error('No discrepancy term choosen... Does not make sense.')
    end
    KdAdjyd = seti.KdAdj(ydnp,JA,JB); % preparation of pda step 2

    if dispDepth >= 5 % additional information
        fprintf('   norm(KdAdjyd) = %g\n',norm(KdAdjyd));
        fprintf('   max(KdAdjyd) = %g\n',max(KdAdjyd));
        fprintf('   min(KdAdjyd) = %g\n',min(KdAdjyd));
    end
    
    % REPLACE_WITH_DASH_DASH test start
    %seti.KdAdj = @(yd,JA,JB) seti.S(seti.GD(ADFFqFast(seti.T(yd),JA,JB,seti)));
    
    if 0
    if iPda == 10
        disp('iPda = 10');
        
        figure(101);
        imagesc(real(seti.T(ydnp))); colorbar; axis xy;
        figure(102);
        imagesc(imag(seti.T(ydnp))); colorbar; axis xy;
        
        figure(103);
        imagesc(real(seti.T(ydnp))+imag(seti.T(ydnp))); colorbar; axis xy;
        
        A = ADFFqFast(seti.T(ydnp),JA,JB,seti);
        Amat = seti.G(A);
        figure(104);
        imagesc(real(Amat)); colorbar; axis xy;
        figure(105);
        imagesc(imag(Amat)); colorbar; axis xy;
        
        B = seti.GD(A);

        C = seti.S(B);

        figure(106);
        imagesc(seti.G(seti.R(xnRVD))); colorbar; axis xy;
        figure(107);
        imagesc(seti.G(seti.I(xnRVD))); colorbar; axis xy;

        error('stop');
    end
    end
    
    % REPLACE_WITH_DASH_DASH test end
    
    KAdjySum = KAdjySum + KdAdjyd; % preparation of pda step 2

    % 2) fs etc. in F
    if ismember('fs',tF) % fs in F
        if dispDepth >= 4
            disp('case fs in F not yet.')
        end
    elseif ismember('fsw',tF) % fsw in F
        wysw = wyi(yswn,seti.Ksw); % w_{y_sw}
        yswnp = proxFswPlus(sigma,seti.vsw(qCVU),wysw,seti); % prox_{sigma F_s^+}(w_y_s)
        % ysnp is down scaled
        %KswAdjys = seti.KswAdj(GURV(yswnp)); % preparation of pda step 2
        KswAdjys = seti.KswAdj(yswnp); % preparation of pda step 2
        KAdjySum = KAdjySum + KswAdjys; % preparation of pda step 2
        clear wysw KswAdjys;
    else
        if iOut == 1 && iPda == 1
            if dispDepth >= 4
                disp('    - Note: No term like fs (sparsity) is used in F.')
            end
        end
    end


    % 3) fg etc. in F
    if ismember('fg',tF) % fg in F
        wygVal = wyg(ygnRMD,seti.Kg); % w_{y_g}
        ygnp = proxFgPlus(sigma,seti.vg(qCVU),wygVal,seti); % prox_{sigma F_g^+}(w_y_g)
        %fprintf('proxFgPlus: sigma = %g | max(vg) = %g | max(wyg) = %g\n',sigma,max(max(max(abs(seti.vg(qCVU))))),max(max(max(abs(wygVal)))));
        KgAdjyg = seti.KgAdj(ygnp); % preparation of pda step 2
        
        if dispDepth >= 5 % additional information
            fprintf('   norm(KgAdjyg) = %g\n',norm(KgAdjyg));
            fprintf('   max(KgAdjyg) = %g\n',max(KgAdjyg));
            fprintf('   min(KgAdjyg) = %g\n',min(KgAdjyg));
        end

        KAdjySum = KAdjySum + KgAdjyg; % preparation of pda step 2
        %clear wygVal KgAdjyg;
    end
    
    % 4) fp etc. in F
    if ismember('fp',tF)
        if dispDepth >= 4
            disp('fp in F not implemented. Maybe not useful.')
        end
    end

    %REPLACE_WITH_DASH_DASH pda step 2: prox_G(w_x) (Resolvente zu G)
    wx = wxF(KAdjySum); % grid down and real

    % order: dsgp, e.g. proxGsp, proxGp
    % fitting to fclass = [<d> <s> <g> <p>]
    % f_d in G does not make sense

    %fG = (fclass == 2);
    if ismember('fd',tG) || ismember('fdw1',tG) || ismember('fdw2',tG)
        error('f_d in Term G does not make sense.')
    elseif isequal({'fs'},tG)
        xnpRVD = proxGs(tau,seti.alpha,seti.vs(qCVU),wx); % prox_{\tau G_s}(w_x)
        % to do: implement proxGs
    elseif isequal(sort({'fs','fp'}),sort(tG))
        vsp = seti.vs(qCVU); % seti.vs = seti.vp in setiFuncs
        % qCVU does not change...
        % you can compute it at the beginning of pda
        % the same with vp, vsp...
        xnpRVD = proxGsp(tau*seti.alpha*seti.dVinv,vsp,wx,seti);

        if dispDepth >= 5 % additional information
            fprintf('   max(wx) = %g\n',max(wx));
            fprintf('   max(xnpRVD) = %g\n',max(xnpRVD));
            fprintf('   kappa = %g\n',tau*seti.alpha*seti.dVinv);
        end
        %fprintf('proxGsp: tau = %g | alpha*dV = %g | max(wx) = %g | max(vsp) = %g\n',tau,seti.alpha*seti.dVinv,max(max(abs(wx))), max(abs(vsp)));
        %xnp = proxGsp(tau,alpha,vsp,wx); % prox_{\tau G_sp}(w_x)
    elseif isequal(sort({'fs','fp2'}),sort(tG))
        vsp = seti.vs(qCVU);
        xnpRVD = proxGsp2(tau*seti.alpha*seti.dVinv,vsp,wx,seti);

        if dispDepth >= 5 % additional information
            fprintf('   max(wx) = %g\n',max(wx));
            fprintf('   max(xnpRVD) = %g\n',max(xnpRVD));
            fprintf('   kappa = %g\n',tau*seti.alpha*seti.dVinv);
        end
    elseif isequal({'fp'},tG)
        % to do: rewrite seti.vsw, so that the arg is grid down
        vp = seti.vs(qCVU);
        xnpRVD = proxGp(reMin,reMax,imMin,imMax,vp,wx,seti); % prox_{\tau G_p}(w_x)
    else
        disp('The wanted prox_G is not implemented yet.')
        error('stop');
    end
    % xnp: grid down and real

    %REPLACE_WITH_DASH_DASH pda step 3:
    xmnpRVD = xnpRVD+theta.*(xnpRVD-xnRVD); % xmnp: grid down and real

    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- end of: pda algorithm steps REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

    
    % store to use in adaptive stepsize (is needed upscaled)
    xnRVDstore = xnRVD;
    xnpRVDstore = xnpRVD;

    %REPLACE_WITH_DASH_DASH prepare new iteration
    
    if exist('ydnp','var') && isnumeric(ydnp)
        ydnRM = ydnp;
    end
    if exist('yswnp','var') && isnumeric(yswnp)
        yswn = yswnp;
    end
    if exist('ygnp','var') && isnumeric(ygnp)
        ygnRMD = ygnp;
    end
    if exist('ypnp','var') && isnumeric(ypnp)
        ypn = ypnp;
    end

    xnRVD = xnpRVD;
    xmnRVD = xmnpRVD;
    
    if speed == 0

        % xnRVD: solution (real vector grid down)
        
        %REPLACE_WITH_DASH_DASH store values of functions F, G

        DFFqh = DFFq(xnRVD);
        Fval(iPda) = F(DFFqh,FFqMeas,qCVU,xnRVD);
        Gval(iPda) = G(qCVU,xnRVD);
        FGval(iPda) = Fval(iPda) + Gval(iPda);

        %relLinDisc = linDiscr(DFFqh,FFq)/linDiscr(0*DFFqh,FFq); % altern. for abs lin. dis.
        %relLinDisc = linDiscr(DFFqh,FFq)/normws(FFq-seti.FmeasDelta,seti);
        
        disLinInPda(iPda) = normws(seti.S(DFFqh)+seti.S(FFqMeas-seti.FmeasDelta),seti)/normws(seti.FmeasDelta,seti);
       
        % dis of last iOut
        if iOut == seti.iOutIni+1
            dis = seti.disIni;
        else
            dis = seti.dis(iOut-1);
        end
        relLinDis(iPda) = disLinInPda(iPda)/dis;
        clear dis;
        hsolCVUcurrent = seti.GU(seti.T(xnRVD));
        errInPda(iPda) = norm(seti.qROIexact-(qCVU+hsolCVUcurrent),2)/norm(seti.qROIexact,2); % relative error in 2-Norm
       
        %REPLACE_WITH_DASH_DASH compute discrepancy and penalty terms

        if dispDepth >= 4
            fprintf('    - i = %03d | stepsizes: tau = %1.2g, sigma = %1.2g\n',iPda,tau,sigma)
            fprintf('               F = %1.2g | G = %1.2g | F + G = %1.2g \n',Fval(iPda),Gval(iPda),FGval(iPda))
        end
        if ismember('fd',tFG)
            fd(iPda) = seti.fd(DFFqh,FFqMeas);
            if dispDepth >= 4
                fprintf('               f_d = %1.2g \n',fd(iPda))
            end
        end
        if ismember('fs',tFG)
            fs(iPda) = seti.fs(qCVU,xnRVD);
            if dispDepth >= 4
                fprintf('               f_s = %1.2g\n',fs(iPda))
            end
        end
        if ismember('fg',tFG)
            fg(iPda) = seti.fg(qCVU,xnRVD);
            if dispDepth >= 4
                fprintf('               f_g = %1.2g\n',fg(iPda))
            end
        end
        if ismember('fp',tFG)
            fp(iPda) = seti.fp(qCVU,xnRVD);
            if dispDepth >= 4
                fprintf('               f_p = %1.2g\n',fp(iPda))
            end
        end
        if dispDepth >= 4
            fprintf('               disLinInPda = %1.2g | RelLinDis = %1.2g \n',disLinInPda(iPda),relLinDis(iPda))
            fprintf('               errInPda = %1.2g \n',errInPda(iPda))
        end
       
        if iPda > 0 && seti.useTolIn == 1 && relLinDis(iPda) < ThetaiOut
            if dispDepth >= 3
                disp('    - Break pda because inner tolerance principle.')
            end
            break;
        end
        
        if stopPda == 1 && iPda >= 3 && norm(FGval(iPda)-FGval(iPda-2)) + norm(FGval(iPda)-FGval(iPda-1)) < 1E-6*norm(FGval(iPda))
            if dispDepth >= 3
                disp('    - Break pda because changes are below tolerance.')
            end
            break;
        end

    end
    
    % plots inside pda not available in public version
    if seti.plotFreqiPda ~= 0 && (seti.plotFreqiPda == 1 || floor(iPda/seti.plotFreqiPda) == iPda/seti.plotFreqiPda)
        plotInsidePda;
    end

    % REPLACE_WITH_DASH_DASH

    % final:
    % x = xnp: min_x F(Kx) + G(x); here: x = hs;
    
end

pdaStopInd = iPda;

if speed == 1
    % xnRVD is the solution h (but grid down and real)
    xnCVD = seti.T(xnRVD);
    DFFqh = DFFq(xnCVD);
    Fval(pdaStopInd-1) = F(DFFqh,FFqMeas,qCVU,xnCVD);
    Gval(pdaStopInd-1) = G(qCVU,xnCVD);
    FGval(pdaStopInd-1) = Fval(iPda) + Gval(iPda);
end

if speed == 0
    % parts of functional f to minimize
    minf.fd = fd;
    minf.fs = fs;
    minf.fg = fg;
    minf.fp = fp;
end

% output solution: xnRVD -> xnCVU
hsolCVU = seti.GU(seti.T(xnRVD)); % Update (q := q+h) (q,h complex)

end

%% Code: subfunction to K components norm
%
% *KcomponentsStruct*
%
function [KcompNorm,KvarNames] = KcomponentsStruct(Kcomp,seti)
% like Kcomponents but with input Kcomp as struct
%n = length(fieldnames(Kcomp)); % number of K_1, K_2, ..., K_n
fields = fieldnames(Kcomp); % e.g. 'Kd' 'Kg' 'Kp'; varNames(1) = 'Kd'
% if Kd... then normws2, otherwise normroi2
KcompNorm = @(xnRVD,JA,JB) 0;
% i = 1: must be Kd, so with normws2 norm
i = 1;
KcompNorm = @(xnRVD,JA,JB) KcompNorm(xnRVD,JA,JB) + normws2(Kcomp.(fields{i})(xnRVD,JA,JB),seti)^2; 
for i = 2:numel(fields)
    %Kcomp.(fields{i})
    if strcmp('Kg',fields(i))
        KcompNorm = @(xnRVD,JA,JB) KcompNorm(xnRVD,JA,JB) + normTVinv2(Kcomp.(fields{i})(xnRVD),seti)^2;
    else
        KcompNorm = @(xnRVD,JA,JB) KcompNorm(xnRVD,JA,JB) + norminv2(Kcomp.(fields{i})(xnRVD),seti)^2;
    end
    %fprintf('Kcomp inputname: %s\n',inputname(i))
    %KvarNames{i} = fields{i};
end
KcompNorm = @(xnRVD,JA,JB) sqrt(KcompNorm(xnRVD,JA,JB));
% KcompNorm = \sqrt{ \|\cdot\|_WHS^2 + \|\cdot\|_\ROI^2 + ... }
KvarNames = fields;
end

%% Code: subfunctions to F and G (sum)
%
% *Fsum*
%
function F = Fsum(tF,seti)
% e.g. F = f_d + f_s, when tF stores fd and fs
% call F = Fsum(tF,seti) and later F(DFFqh,FFq,qCVU,xnRVD)
%old q = qCVU, old hz = xnRVD
Fsum = @(DFFqh,FFq,qCVU,xnRVD) 0;
for i = 1:length(tF)
    
    fj = seti.(tF{i});
    if ismember(tF(i),{'fd','fdw1','fdw2','fdw3'}) % f_d, f_dw etc. does need input arguments DFFqh and FFq
        Fsum = @(DFFqh,FFq,qCVU,xnRVD) Fsum(DFFqh,FFq,qCVU,xnRVD) + fj(DFFqh,FFq);
    else % other like f_s, f_p does need input arguments q and hz
        Fsum = @(DFFqh,FFq,qCVU,xnRVD) Fsum(DFFqh,FFq,qCVU,xnRVD) + fj(qCVU,xnRVD);
    end
    clear fj;
end
%if strcmp('tF',inputname(1)) % input tF, so you want to get F
F = @(DFFqh,FFq,qCVU,xnRVD) Fsum(DFFqh,FFq,qCVU,xnRVD);
clear i Fsum;
end

%%
% *Gsum*
%
function G = Gsum(tG,seti)
% similar to Fsum, but only 2 arguments
% call G = Gsum(tG,seti)
Gsum = @(q,hz) 0;
for i = 1:length(tG)
    fj = seti.(tG{i});
    Gsum = @(q,hz) Gsum(q,hz) + fj(q,hz);
    clear fj;
end
G = @(q,hz) Gsum(q,hz);
clear i Gsum;
end

%% Code subfunctions to proximal mappings
%
%%
% *proxFdPlus*
%
function res = proxFdPlus(sigma,vd,wyd) % d: discrepancy
% f_d(x) = 1/2 ||S(FF'(q)[x]) + vd||_WS,2^2, here with vd = S(FFq-y^\delta)
% res = y_d^(n+1) = \prox_{\sigma F_d^+} (w_y_d)
res = (wyd+sigma*vd)/(1+sigma);
end

%%
% *proxFdw1Plus*
%
function res = proxFdw1Plus(sigma,vd,wyd,seti)
%f_dw(x) = 1*||S(FF'(q)[x]) + vd||WS,2^1, here with vd = S(FF(q)-y^\delta)
% res = y_dw1^(n+1) = \prox_{\sigma F_dw1^+} (w_y_dw1)
% seti in normws is seti.pNorm, here seti.pNorm must be 2
% (in pda with invOps=3,4,5,6 always seti.pNorm = 2 and seti.qNorm = 1)
res = (wyd+sigma*vd)/max(1,normws(wyd+sigma*vd,seti));
end

%%
% *proxFdw3Plus*
%
function res = proxFdw3Plus(sigma,vd,wyd,seti)
%f_dw3(x) = (1/p)*||S(FF'(q)[x]) + vd||_p^p, here with vd = S(FF(q)-y^\delta)
% res = y_dw1^(n+1) = \prox_{\sigma F_dw3^+} (w_y_dw1)

if seti.pNorm > 1
    % requires seti.qNorm>1
    pPrime = seti.pNorm/(seti.pNorm-1);
    res = shrinkFuncComp(real(wyd+sigma*vd),sigma,pPrime,'newton')...
        +1i*shrinkFuncComp(imag(wyd+sigma*vd),sigma,pPrime,'newton'); 
        
elseif seti.pNorm==1
    res = max((abs(real(wyd+sigma*vd))-sigma),0).*sign(real(wyd+sigma*vd)) ...
        +1i*max((abs(imag(wyd+sigma*vd))-sigma),0).*sign(imag(wyd+sigma*vd)); 
else
    disp('seti.qNorm is less than one in pda.m (?!)');
end

end

%%
% *proxFswPlus*
%
function res = proxFswPlus(sigma,vs,wys,seti) % s: sparse
% f_s(x) = ||alpha*x + v_s||_ROI,1
% factor alpha must be inside v_s
% res = y_s^(n+1) = \prox{\sigma F_s^+} (w_y_s)
rho = seti.dVinv; % This factor was corrected from 1 to seti.dVinv on 20181213.
res = intProj(-rho,rho,wys+sigma*vs);
end

%%
% *proxFgplus*
%
function res = proxFgPlus(sigma,vg,wyg,seti) % g gradient
% f_g(x) = ||beta*\grad(x) + v_g||_ROI,1
% factor beta must be inside v_g
% res = y_g^(n+1) = \prox{\sigma F_g^+} (w_y_g)
% REPLACE_WITH_DASH_DASH
%res = intProj(-1,1,wyg+sigma*vg); % used until 20160406, and [20160412,20160414] % wrong...
%new: 20160406REPLACE_WITH_DASH_DASH20160412: was wrong...:
%t = wyg+sigma*vg;
%res = t./max(1,abs(t)/seti.dV);
% REPLACE_WITH_DASH_DASH
% new...

z = wyg + sigma*vg;
%prepare matrix of norm of tuples...
d = size(z,1)/2;
nInv = size(z,2);
sizez = size(z);
zreshape = reshape(z,[2*d nInv^d]); % for 2D and 3D
% compute norms
tupelnorms = transpose(sqrt(sum(abs(zreshape).^2,1)));
%tupelnormsReshape = reshape(tupelnorms,sizey(2:end)); % for 2D and 3D
tupelnorms = reshape(tupelnorms,[1 sizez(2:end)]); % second reshape to add one dimension
tupelnorms = repmat(tupelnorms,[2*d 1 1]); % repmat for element-wise use...

% tupelnormsMatElWise has the the same dimension as z and can used component-wise
z = wyg+sigma*vg;
res = z./max(1,tupelnorms);
end

%%
% *proxGsp*
%
function res = proxGsp(kappa,vsp,wx,seti) % s: sparse AND p: physical
% G(x) = f_s(x) + f_p(x)
%      = \alpha ||x + v_s||_1 + \delta_[a,b](Re(x + v_p)) + \delta_[c,d](Im(x + v_p))
% important: v_s == v_p
% res = x^(n+1) = \prox_{\tau G_sp} (w_x)
% (shrinkage with bounds a and b)
%res = [shrinkage(wx+vsp,tau*alpha,a,b); shrinkage(wx+vsp,tau*alpha,c,d)]-1/seti.alpha*seti.S(vsp);

if isfield(seti,'omegaW1p')
    if strcmp(seti.wavIsom,'W1p') 
        res = [seti.shrkRe(seti.R(wx+vsp),kappa*seti.omegaW1p); seti.shrkIm(seti.I(wx+vsp),kappa*seti.omegaW1p)]-vsp;
    else
        error('Error in pda.m: seti.wavIsom not implemented.') 
    end
else
    res = -vsp+[seti.shrkRe(seti.R(wx+vsp),kappa); seti.shrkIm(seti.I(wx+vsp),kappa)];
end

end

%%
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% *proxGsp2* (fs and fp2 in G)
%
function res = proxGsp2(kappa,vsp,wx,seti) % s: sparse AND p: physical (p2 distinguishes obstacle and background)
% This function is similar to proxGsp. The difference is the splitting of
% the contrast in the obstacle and the background.
%
% G(x) = f_s(x) + f_p2(x)
%      = \alpha ||x + v_s||_1 + \delta_[a,b](Re(obs(x + v_p))) + \delta_[c,d](Im(obs(x + v_p)))
%                             + \delta_[0,0](Re(back(x + v_p))) + \delta_[0,0](Im(back(x + v_p)))
% Notation: obs does mean seti.qObs, and back does mean seti.qBack.
% In mathematical notation we chose: obs(x) = \check{x} and back(x) = \mathring{x}.
% important: v_s == v_p
% res = x^(n+1) = \prox_{\tau G_sp2} (w_x)

% long:
% wvBack = seti.qBack(seti.R(wx+vsp));
% wvBack = zeros(size(wvBack)); % physical bounds of background are zero, i.e. wvBack is zero
% short:
wvBack = zeros(size(seti.nROI^seti.dim,1)); % physical bounds of background are zero, i.e. wvBack is zero

res = -vsp+[seti.qMerge(seti.shrkRe(seti.qObs(seti.R(wx+vsp)),kappa),wvBack); seti.qMerge(seti.shrkIm(seti.qObs(seti.I(wx+vsp)),kappa),wvBack)];

end
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%%
% *proxGp*
%
function res = proxGp(a,b,c,d,vp,wx,seti) % p: physical... Potentialtopf-Funktion
% f_p(x) = \delta_[a,b](R(wx + v_p)) + \delta_[0,c](I(wx+v_p))
% res = x^(n+1) = \prox_{\tau G_p} (w_x)
res = [intProj(a,b,seti.R(wx+vp)); intProj(c,d,seti.I(wx+vp))]-vp;
end


##### SOURCE END #####
--></body></html>