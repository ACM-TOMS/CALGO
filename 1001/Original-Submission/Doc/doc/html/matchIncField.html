
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>matchIncField</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-30"><meta name="DC.source" content="matchIncField.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>matchIncField</h1><!--introduction--><p>Match an incident field on region (ROI or CD) corresponding to the measured data of the incident field on measurements (receivers' positions).</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Example</a></li><li><a href="#4">Input Arguments</a></li><li><a href="#5">Output Arguments</a></li><li><a href="#6">More About</a></li><li><a href="#7">References</a></li><li><a href="#8">Code: matchIncField</a></li><li><a href="#11">Code: matchIncFieldSingle</a></li><li><a href="#15">Code: Auxiliary Functions</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">[uIncROI,errC] = matchIncField(uIncRX,seti,region)
</pre><h2 id="2">Description</h2><p><tt>[uIncROI,errC] = matchIncField(uIncRX,seti,region)</tt> finds suitable incident fields <tt>uIncROI</tt> on a region (region of interest (ROI) or computational domain (CD) depending on <tt>region</tt>) corresponding to the measured data, <tt>uIncRX</tt>, of each incident field on measurements (receivers positions). The relative error of every matched incident field at receivers positions is given too in <tt>errC</tt>. Further input parameters are in struct <tt>seti</tt>. Note that this works only in case of a problem in 2 dimensions.</p><h2 id="3">Example</h2><pre class="language-matlab">init; <span class="comment">% Skip it if you are in folder proc/expData/, where matchIncField.m is located.</span>
</pre><pre class="language-matlab">seti.dim = 2;   <span class="comment">% dimension 2</span>
<span class="comment">% seti.nROI = 89; % (in case of region = 'ROI')</span>
<span class="comment">% seti.nCD = 250; % (in case of region = 'CD')</span>
</pre><pre class="language-matlab">seti.incNb = 3;     <span class="comment">% number of transmitters</span>
<span class="comment">% seti.measNb = 10;   % number of receivers</span>
<span class="comment">% seti.radSrc = 4;    % transmitters are on a circle with radius 4</span>
<span class="comment">% seti.radMeas = 5;   % receivers are on a circle with radius 5</span>
seti.k = 250;       <span class="comment">% wave number</span>
</pre><pre class="language-matlab"><span class="comment">% Positions of the transmitters</span>
seti.incPnts =  [4.0000   -2.0000   -2.0000;
                 0    3.4641   -3.4641];
</pre><pre class="language-matlab"><span class="comment">% Positions of the receivers</span>
seti.measPnts = [
 5.0000    4.0451    1.5451   -1.5451   -4.0451   -5.0000   -4.0451    -1.5451    1.5451    4.0451;
      0    2.9389    4.7553    4.7553    2.9389    0.0000   -2.9389    -4.7553   -4.7553   -2.9389];
</pre><pre class="language-matlab"><span class="comment">% Generate the grid for ROI</span>
h = 0.0016;
a = 0.0704;
x1ROI = -a:h:+a;
seti.nROI = length(x1ROI); <span class="comment">% is 89 in this example as above</span>
[X1ROI,X2ROI] = meshgrid(x1ROI,x1ROI);
seti.gridROI = [X1ROI(:).'; X2ROI(:).'];
</pre><pre class="language-matlab">seti.ampCalc = 1; <span class="comment">% method to compute the coefficients</span>
seti.nuMax = 3;   <span class="comment">% 2*nuMax+1 coefficients are computed for polynomial approximation</span>
</pre><pre class="language-matlab"><span class="comment">% uIncRX : incident field at receivers positions...</span>
<span class="comment">%          (complex matrix of size seti.measNb x seti.incNb)</span>
</pre><pre class="language-matlab">uIncRX = [
-0.0072 + 0.0028i  -0.0022 - 0.0009i  -0.0014 + 0.0012i;
 0.0125 + 0.0063i   0.0023 + 0.0017i  -0.0017 + 0.0003i;
 0.0059 + 0.0027i  -0.0002 - 0.0035i  -0.0009 + 0.0057i;
 0.0002 - 0.0005i  -0.0140 - 0.0085i  -0.0043 - 0.0071i;
-0.0021 + 0.0011i  -0.0042 - 0.0011i  -0.0067 - 0.0037i;
-0.0008 - 0.0024i  -0.0003 - 0.0039i  -0.0030 + 0.0004i;
-0.0004 + 0.0021i   0.0019 - 0.0013i  -0.0034 - 0.0040i;
 0.0028 + 0.0010i   0.0004 + 0.0013i  -0.0008 + 0.0054i;
-0.0020 + 0.0026i   0.0023 - 0.0003i   0.0023 - 0.0022i;
-0.0019 - 0.0012i   0.0005 + 0.0028i   0.0029 + 0.0014i];
</pre><pre class="language-matlab"><span class="comment">% Compute the incident field uIncROI on ROI</span>
[uIncROI,errC] = matchIncField(uIncRX,seti,<span class="string">'ROI'</span>);
</pre><pre class="language-matlab"><span class="comment">% Plots of incident fields from three transmitters</span>
</pre><pre class="language-matlab">uIncROI1 = reshape(uIncROI(:,1),[seti.nROI seti.nROI]);
uIncROI2 = reshape(uIncROI(:,2),[seti.nROI seti.nROI]);
uIncROI3 = reshape(uIncROI(:,3),[seti.nROI seti.nROI]);
</pre><pre class="language-matlab">figure(101); imagesc(real(uIncROI1)); axis <span class="string">xy</span>; axis <span class="string">square</span>;
figure(102); imagesc(real(uIncROI2)); axis <span class="string">xy</span>; axis <span class="string">square</span>;
figure(103); imagesc(real(uIncROI3)); axis <span class="string">xy</span>; axis <span class="string">square</span>;
</pre><h2 id="4">Input Arguments</h2><div><ul><li>seti.dim        :   dimension of the problem: 2 (3 not available)</li><li>seti.incNb      :   number of transmitters</li><li>seti.k          :   wave number</li><li>seti.incPnts    :   Positions of the transmitters,                       (matrix of size seti.dim x seti.incNb),                       seti.incPnts = [5 -2 3; 0 4 2]                       describes coordinates (5,0), (-2,4), and (3,2).</li><li>seti.measPnts   :   Positions of the receivers                       (matrix of size seti.dim x seti.measNb),                       coordinates analogical to seti.incPnts.</li><li>seti.gridROI    :   grid of region of interest (ROI)                       (in case of region = 'ROI')                       (matrix of size seti.dim x seti.nROI^seti.dim)</li><li>seti.grid       :   grid of computational domain (CD)                       (in case of region = 'CD')                       (seti.dim x seti.nCD^seti.dim)</li></ul></div><div><ul><li>seti.ampCalc    :   method to compute the coefficients c (1, 2 or 3),                       we recommend to use method 1 (default)                       because it is the most accurate and fast, as shown in [1].                       (1: best-approximation to V c = z via MATLAB                       function,                       2: <img src="matchIncField_eq05663473293913421361.png" alt="$c = (\gamma I + V^\ast\ V)^{-1} (V^\ast\                       \texttt{uIncRX})$">                           via linear Tikhonov regularization,                       3: Landweber iteration)</li><li>seti.nuMax      :   match incident field using Hankel functions of first kind and orders                       <img src="matchIncField_eq13234211905659582027.png" alt="$\nu = -\texttt{nuMax}, ..., -1, 0, 1, ...,                       \texttt{nuMax}$"> (default: 7)</li></ul></div><div><ul><li>uIncRX          :   incident field at receivers' positions for each                       transmitter                       (complex matrix of size seti.measNb x seti.incNb)</li><li>region          :   'ROI' or 'CD' (region of interest or computational domain)                       (usually we are interested in ROI)</li></ul></div><h2 id="5">Output Arguments</h2><div><ul><li>uIncROI   :       incident field on ROI (or CD) for each transmitter                     (complex array of size seti.nROI^seti.dim x seti.incNb)</li><li>errC      :       stores the relative error of                     the matched incident field at receivers positions for                     every transmitter                     (vector of size 1 x seti.incNb)</li></ul></div><h2 id="6">More About</h2><p><b>How does it work?</b></p><div><ol><li>Matching incident field in data <tt>uIncRX</tt> (receivers positions)   with harmonic polynomials for each transmitter by finding corresponding   coefficients <tt>c</tt> solving (approximately) <img src="matchIncField_eq07121154347581009266.png" alt="$V c = \texttt{uIncRX}$">.</li><li>Computes the resulting incident fields on the grid uIncROI   for each transmitter.</li></ol></div><p>More details of the method are in the subfunctions and in Section 6 of [1].</p><p><b>Please note</b></p><div><ul><li>The method is for 2 dimensional problems.</li><li>We assume point sources at transmitters positions.</li><li>We assume near field data.</li><li>c are coefficients. (They are kind of amplitudes, but this is not exact.)</li><li>Avoid same positions for receivers and transmitters. Some entries in matrix V will be not a number (NaN).</li></ul></div><h2 id="7">References</h2><div><ul><li>[1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. <i>Journal of Computational Physics</i>, 339:1-30, 2017.</li></ul></div><h2 id="8">Code: matchIncField</h2><pre class="codeinput"><span class="keyword">function</span> [uIncROI,errC] = matchIncField(uIncRX,seti,region)
</pre><p><tt>[uIncROI,errC] = matchIncField(uIncRX,seti,region)</tt> computes the incident field on grid of region ROI or CD (depends on <tt>region</tt>) from given incident field <tt>uIncRX</tt> at receivers postions. Relative error of given and matched indicent field <tt>uIncRX</tt> for each transmitter are stored in <tt>errC</tt>.</p><pre class="language-matlab">region =  <span class="string">'ROI'</span> or <span class="string">'CD'</span>
</pre><pre class="codeinput">nTX = seti.incNb; <span class="comment">% nTX: number of transmitters</span>
<span class="comment">% nROI = nnz(seti.ROImask); % works for ROI, alternative for ROI and CD</span>
<span class="keyword">switch</span> region
    <span class="keyword">case</span> <span class="string">'ROI'</span>
        nROI = seti.nROI^seti.dim;
    <span class="keyword">case</span> <span class="string">'CD'</span>
        nROI = seti.nCD^seti.dim;
<span class="keyword">end</span>
uIncROI = zeros(nROI,nTX);
errC = zeros(1,nTX);    <span class="comment">% store relative error of V c = uIncRX, i.e. every matched incident field at receivers positions</span>
errCAdj = zeros(1,nTX); <span class="comment">% store relative error of (\gamma Id + V^\ast V) c = V^\ast uIncRX</span>
<span class="comment">% All transmitters are active in experiment (but only one at once)</span>
<span class="keyword">for</span> activeTX = 1:nTX
    <span class="comment">% Matching for single incident field</span>
    [u,errCval,errCAdjval] = matchIncFieldSingleTX(uIncRX,seti,activeTX,region);
    uIncROI(:,activeTX) = u(:);
    errC(1,activeTX) = errCval;
    errCAdj(1,activeTX) = errCAdjval;
<span class="keyword">end</span>

disp(<span class="string">'--'</span>)
disp(<span class="string">'Check relative error of z = uIncRX because of choosen coefficients:'</span>)
fprintf(<span class="string">'rel. err. of (gamma Id + V''V)c = V''z    : mean = %g\n'</span>,mean(errCAdj));
fprintf(<span class="string">'             [min, max] = [%g, %g]\n'</span>, min(errCAdj), max(errCAdj));
fprintf(<span class="string">'rel. err. of V c = z                    : mean = %g\n'</span>,mean(errC));
fprintf(<span class="string">'             [min, max] = [%g, %g]\n'</span>, min(errC), max(errC));
disp(<span class="string">'--'</span>)
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="11">Code: matchIncFieldSingle</h2><pre class="codeinput"><span class="keyword">function</span> [uIncMatched,errC,errCAdj] = matchIncFieldSingleTX(uIncRX,seti,activeTX,region)
</pre><p><tt>[uIncMatched,errC,errCAdj] = matchIncFieldSingleTX(uIncRX,seti,activeTX,region)</tt> matches the incident field <tt>uIncRX</tt> in data (receivers positions) with harmonic polynomials and then computes the resulting field <tt>uIncMatched</tt> on the grid for one transmitter.</p><pre class="codeinput"><span class="comment">% Active receivers depend on the active transmitter</span>
<span class="comment">% (not all receivers are active at once).</span>
<span class="comment">% Mark active receivers with 1 and inactive with 0: (logical):</span>
activeRX = ~isnan(uIncRX(:,activeTX));
origin = seti.incPnts(:,activeTX); <span class="comment">% position of transmitter with number activeTX</span>
<span class="comment">%</span>
<span class="comment">% seti.measPnts(1,activeRX) : first components of active measPnts</span>
<span class="comment">% (depends on choosen active transmitter: activeTX)</span>
<span class="comment">% x and y: coordinates away from origin (currently active transmitter)</span>
<span class="comment">% so in this coordinate system:</span>
<span class="comment">%</span>
<span class="comment">% * active transmitter position (0,0)</span>
<span class="comment">% * receiver positions (x,y)</span>
<span class="comment">%</span>
x = transpose(seti.measPnts(1,activeRX) - origin(1)); <span class="comment">% x coordinate</span>
y = transpose(seti.measPnts(2,activeRX) - origin(2)); <span class="comment">% y coordinate</span>
z = uIncRX(activeRX,activeTX); <span class="comment">% incident field at this receivers (because of active transmitter)</span>
N = seti.nuMax; <span class="comment">% degree of matching polynomial (e.g. N = 30)</span>
phi0 = 0; <span class="comment">% see function harmonicpolyfit</span>

[c,errC,errCAdj] = harmonicpolyfit(x,y,z,N,seti.k,phi0,seti);

<span class="keyword">if</span> 0 <span class="comment">% store coefficients c (matchIncidentFieldSingleTX is called in for-loop)</span>
    seti.ampCalcNew = 1; <span class="comment">% Compute new coefficients (recommended).</span>
                         <span class="comment">% Could be stored, but not recommended...</span>
                         <span class="comment">% This works only in case of incNb == 1...</span>
    <span class="comment">% [pathstr,name,ext] = fileparts(file)</span>
    [~,name,~] = fileparts(seti.fresnelFile);
    freqGHz = seti.fresnelFreq/1E9;
    <span class="comment">% seti.ampCalc is not included in filename...</span>
    <span class="comment">% so compute the coefficients (and do not use the saved one...)</span>
    fileDataAmp = sprintf(<span class="string">'inmat/dataAmp/%s_%01d_GHz_N_%03d.mat'</span>,name,freqGHz,N);
    <span class="keyword">if</span> (seti.ampCalcNew ~= 1 &amp;&amp; exist(fileDataAmp, <span class="string">'file'</span>) == 2)
        <span class="comment">%file with name exists</span>
        disp(<span class="string">'Loading amplitudes of incident field of Fresnel data.'</span>);
        sloaded = load(fileDataAmp); <span class="comment">% contains amplitudes c</span>
        c = sloaded.c;
        clear <span class="string">sloaded</span>;
    <span class="keyword">else</span>
        disp(<span class="string">'Compute coefficients c'</span>)
        [c,errC,errCAdj] = harmonicpolyfit(x,y,z,N,seti.k,phi0,seti);
        fprintf(<span class="string">'Store in file: %s\n'</span>,fileDataAmp);
        save(fileDataAmp,<span class="string">'c'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">switch</span> region
    <span class="keyword">case</span> <span class="string">'ROI'</span>
        x = transpose(seti.gridROI(1,:) - origin(1));
        y = transpose(seti.gridROI(2,:) - origin(2));
    <span class="keyword">case</span> <span class="string">'CD'</span>
        x = transpose(seti.grid(1,:) - origin(1));
        y = transpose(seti.grid(2,:) - origin(2));
<span class="keyword">end</span>
uIncMatched = harmonicpolyval(c,x,y,seti.k,phi0); <span class="comment">% matched field on grid</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="15">Code: Auxiliary Functions</h2><p><b>harmonicpolyfit</b></p><pre class="codeinput"><span class="keyword">function</span> [c,errC,errCAdj] = harmonicpolyfit(x,y,uIncRX,N,k,phi0,seti)
</pre><p><tt>[c,errC,errCAdj] = harmonicpolyfit(x,y,uIncRX,N,k,phi0,seti)</tt> finds the coefficients of a 2D harmonic polynomial of (harmonic) degree <tt>N</tt> that fits the data <tt>uIncRX</tt> at the best in a least-squares sense (in case of <tt>seti.ampCalc = 1</tt> -- other methods are available). The <tt>c</tt> is a row vector of length 2*N+1 containing the polynomial coefficients.</p><p>Solution of Helmholtz equation in <img src="matchIncField_eq04223019192258237102.png" alt="$\bf{R}^2$"> without 0 is</p><p><img src="matchIncField_eq09873847986041736744.png" alt="$$\texttt{hmonomial} =&#xA;    \frac{\mathrm{i}}{4} H_\nu^{(1)} (k r) \exp(\mathrm{i} \nu \varphi),&#xA;    \quad r &gt; 0, \quad \varphi \in [0,2\pi),$$"></p><p>where r and phi are the polar coordinates of (x,y) and <img src="matchIncField_eq16976384611854885263.png" alt="$H_\nu^{(1)}$"> the Hankel function of the first kind and order <img src="matchIncField_eq01032094696205445730.png" alt="$\nu \in \bf{Z}$">.</p><p>Any linear combination of these products are solutions too. This linear combination is expressed by matrix V multiplied by vector c, which contains the coefficients.</p><p><img src="matchIncField_eq11133312587994369778.png" alt="$$V c = \texttt{uIncRX}$$"></p><p>See Also HARMONICPOLYVAL.</p><pre class="codeinput">[phi, r] = cart2pol(x(:),y(:));
V = zeros(length(r),2*N+1);
hmonomial = @(phi,r,n,k) (1i/4)*besselh(n, k*r).*exp(1i*n*(phi+phi0)); <span class="comment">% phi+phi0</span>

<span class="keyword">for</span> n = -N:N
    V(:,n+N+1) = hmonomial(phi,r,n,k);
<span class="keyword">end</span>

<span class="comment">% seti.ampCalc: options 1: c = V\z | 2: using adjoint | 3: landweber</span>
<span class="comment">% seti.ampCalc = 1 is recommended</span>
gamma = 1E-4; <span class="comment">% used in case 2 and calculation of relative error</span>
seti = checkfield(seti,<span class="string">'ampCalc'</span>,1);
<span class="keyword">switch</span> seti.ampCalc
    <span class="keyword">case</span> 1
        c = V\uIncRX(:); <span class="comment">%</span>
    <span class="keyword">case</span> 2
        c = (gamma*eye(size(V'*V)) + V'*V)\(V'*uIncRX(:));
    <span class="keyword">case</span> 3
        lwN = 2000; <span class="comment">% number of landweber iterations</span>
        <span class="comment">%lwN = 1E5;</span>
        <span class="comment">%lwN = 1E8; %test; very time-consuming</span>
        c = landweber(V,uIncRX,lwN); <span class="comment">% find c such that V c \approx z</span>
<span class="keyword">end</span>

<span class="comment">%figure(101);</span>
<span class="comment">%plot(real(V*c)); title('V*c approx z = uIncRX, real');</span>

<span class="comment">%figure(102);</span>
<span class="comment">%plot(imag(V*c)); title('V*c approx z = uIncRX, imag');</span>

<span class="comment">% z is incident field uIncRX at receivers positions of the active(!) receivers</span>
errCAdj = norm((gamma*eye(size(V'*V)) + V'*V)*c-V'*uIncRX(:))/norm(V'*uIncRX(:));
errC = norm(V*c-uIncRX(:))/norm(uIncRX(:));

<span class="keyword">if</span> 0
    disp(<span class="string">'Coefficients c = V\z correct? Is V*c-z = 0?'</span>)
    <span class="comment">% (\varepsilon Id + V^\ast V) c = V^\ast z, so V c = z</span>
    fprintf(<span class="string">'rel. err. of (gamma Id + V''V)c = V''z: %g\n'</span>,errCAdj);
    fprintf(<span class="string">'rel. err. of V c = z: %g\n'</span>,errC);
<span class="keyword">end</span>
<span class="comment">%figure(103); plot(real(c));</span>

<span class="comment">%figure(104);</span>
<span class="comment">%plot(real(c))</span>

<span class="comment">%figure(105);</span>
<span class="comment">%plot(imag(c))</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p><b>harmonicpolyval</b></p><pre class="codeinput"><span class="keyword">function</span> uIncROI = harmonicpolyval(c,x,y,k,phi0)
</pre><p><tt>uIncROI = harmonicpolyval(c,x,y,k,phi0)</tt> returns the value of the 2D harmonic polynomial evaluated at points (x,y). The c is a vector of length <img src="matchIncField_eq01217911152631175201.png" alt="$2\ \xi+1$"> (<img src="matchIncField_eq01107816166843824252.png" alt="$\xi = \texttt{nuMax}$">) whose elements are the coefficients of the polynomial in ascending (!!!) powers.</p><p><img src="matchIncField_eq03645167374554982454.png" alt="$$\texttt{uIncROI} = \sum_{\nu = -\xi}^{+\xi}&#xA;c_\nu\ \texttt{hmonomial}(\varphi,r)$$"></p><p>where <img src="matchIncField_eq09250458956798851649.png" alt="$\varphi$"> and <img src="matchIncField_eq04958265083611378313.png" alt="$r$"> are the polar coordinates of (x,y).</p><p>See also HARMONICPOLYFIT.</p><pre class="codeinput">[phi, r] = cart2pol(x(:),y(:));
uIncROI = zeros(size(x(:)));
L = length(c);
N = floor( (L-1)/2 );
hmonomial = @(phi,r,n,k) (1i/4)*besselh(n, k*r).*exp(1i*n*(phi+phi0)); <span class="comment">% phi+phi_0</span>
<span class="keyword">for</span> n = -N:(-N+L-1)
    uIncROI = uIncROI + c(n+N+1) * hmonomial(phi,r,n,k);
<span class="keyword">end</span>;
uIncROI = reshape(uIncROI,size(x));
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p><b>landweber</b></p><pre class="codeinput"><span class="keyword">function</span> res = landweber(V,uIncRX,lwN)
</pre><p>Try to improve fitting of coefficients c by Landweber sheme.</p><p>Landweber sheme in general is used to minimize</p><p><img src="matchIncField_eq12508295613018140697.png" alt="$\min_x \|Vx-y\|_2^2/2 \quad $ by $\quad x_{k+1} = x_{k} - \omega V^*(V x_k - y)$">.</p><p>Here we us it with</p><div><ul><li>y = uIncRX</li><li><img src="matchIncField_eq04226478111453365427.png" alt="$x_k = c$"> (seeked coefficients c)</li></ul></div><p>Further input:</p><div><ul><li>lwN   : number of iterations</li></ul></div><pre class="codeinput">m = size(V,2); <span class="comment">% 2*N+1</span>
n = size(uIncRX,2);
xk = zeros(m,n); <span class="comment">% zeros(size(c)); % start with c = 0</span>
<span class="comment">% $0 &lt; \omega &lt; 2/\sigma_1^2$</span>
s = svd(V);
size(V);
s1 = max(s);
omegaMax = 2/s1^2;
omega = 0.99*omegaMax;
A = V;
AT = transpose(conj(A));
y = uIncRX(:);
<span class="keyword">for</span> i = 1:lwN
    xkp1 = xk-omega*AT*(A*xk-y);
    xk = xkp1;
    <span class="keyword">if</span> floor(i/1000) == i/1000
        fprintf(<span class="string">'dis = %g\n'</span>, norm(A*xk-y));
    <span class="keyword">end</span>
<span class="keyword">end</span>
res = xk;
<span class="comment">% res is a c (or better c than input)</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% matchIncField
% Match an incident field on region (ROI or CD) corresponding to the
% measured data of the incident field on measurements (receivers'
% positions).
%
%% Syntax
%
%   [uIncROI,errC] = matchIncField(uIncRX,seti,region)
%
%% Description
% |[uIncROI,errC] = matchIncField(uIncRX,seti,region)| finds suitable
% incident fields |uIncROI| on a region 
% (region of interest (ROI) or computational domain (CD) depending on
% |region|)
% corresponding to the measured data, |uIncRX|, of each incident field on measurements (receivers positions). 
% The relative error of every matched incident field at receivers positions
% is given too in |errC|.
% Further input parameters are in struct |seti|. 
% Note that this works only in case of a problem in 2 dimensions.
% 
%
%% Example
%
%   init; % Skip it if you are in folder proc/expData/, where matchIncField.m is located.
%
%   seti.dim = 2;   % dimension 2
%   % seti.nROI = 89; % (in case of region = 'ROI')
%   % seti.nCD = 250; % (in case of region = 'CD')
%
%   seti.incNb = 3;     % number of transmitters
%   % seti.measNb = 10;   % number of receivers
%   % seti.radSrc = 4;    % transmitters are on a circle with radius 4
%   % seti.radMeas = 5;   % receivers are on a circle with radius 5
%   seti.k = 250;       % wave number
%
%   % Positions of the transmitters
%   seti.incPnts =  [4.0000   -2.0000   -2.0000;
%                    0    3.4641   -3.4641];
%
%   % Positions of the receivers
%   seti.measPnts = [
%    5.0000    4.0451    1.5451   -1.5451   -4.0451   -5.0000   -4.0451    -1.5451    1.5451    4.0451;
%         0    2.9389    4.7553    4.7553    2.9389    0.0000   -2.9389    -4.7553   -4.7553   -2.9389];
%
%   % Generate the grid for ROI
%   h = 0.0016;
%   a = 0.0704;
%   x1ROI = -a:h:+a;
%   seti.nROI = length(x1ROI); % is 89 in this example as above
%   [X1ROI,X2ROI] = meshgrid(x1ROI,x1ROI);
%   seti.gridROI = [X1ROI(:).'; X2ROI(:).'];
%
%   seti.ampCalc = 1; % method to compute the coefficients
%   seti.nuMax = 3;   % 2*nuMax+1 coefficients are computed for polynomial approximation
%
%   % uIncRX : incident field at receivers positions...
%   %          (complex matrix of size seti.measNb x seti.incNb)
%
%   uIncRX = [
%   -0.0072 + 0.0028i  -0.0022 - 0.0009i  -0.0014 + 0.0012i;
%    0.0125 + 0.0063i   0.0023 + 0.0017i  -0.0017 + 0.0003i;
%    0.0059 + 0.0027i  -0.0002 - 0.0035i  -0.0009 + 0.0057i;
%    0.0002 - 0.0005i  -0.0140 - 0.0085i  -0.0043 - 0.0071i;
%   -0.0021 + 0.0011i  -0.0042 - 0.0011i  -0.0067 - 0.0037i;
%   -0.0008 - 0.0024i  -0.0003 - 0.0039i  -0.0030 + 0.0004i;
%   -0.0004 + 0.0021i   0.0019 - 0.0013i  -0.0034 - 0.0040i;
%    0.0028 + 0.0010i   0.0004 + 0.0013i  -0.0008 + 0.0054i;
%   -0.0020 + 0.0026i   0.0023 - 0.0003i   0.0023 - 0.0022i;
%   -0.0019 - 0.0012i   0.0005 + 0.0028i   0.0029 + 0.0014i];
% 
%   % Compute the incident field uIncROI on ROI
%   [uIncROI,errC] = matchIncField(uIncRX,seti,'ROI');
%
%   % Plots of incident fields from three transmitters
%
%   uIncROI1 = reshape(uIncROI(:,1),[seti.nROI seti.nROI]);
%   uIncROI2 = reshape(uIncROI(:,2),[seti.nROI seti.nROI]);
%   uIncROI3 = reshape(uIncROI(:,3),[seti.nROI seti.nROI]);
% 
%   figure(101); imagesc(real(uIncROI1)); axis xy; axis square;
%   figure(102); imagesc(real(uIncROI2)); axis xy; axis square;
%   figure(103); imagesc(real(uIncROI3)); axis xy; axis square;
% 
%
%% Input Arguments
% 
% * seti.dim        :   dimension of the problem: 2 (3 not available)
% * seti.incNb      :   number of transmitters
% * seti.k          :   wave number
% * seti.incPnts    :   Positions of the transmitters, 
%                       (matrix of size seti.dim x seti.incNb), 
%                       seti.incPnts = [5 -2 3; 0 4 2] 
%                       describes coordinates (5,0), (-2,4), and (3,2).
% * seti.measPnts   :   Positions of the receivers
%                       (matrix of size seti.dim x seti.measNb),
%                       coordinates analogical to seti.incPnts.
% * seti.gridROI    :   grid of region of interest (ROI) 
%                       (in case of region = 'ROI')
%                       (matrix of size seti.dim x seti.nROI^seti.dim)
% * seti.grid       :   grid of computational domain (CD)
%                       (in case of region = 'CD')
%                       (seti.dim x seti.nCD^seti.dim)
%
% * seti.ampCalc    :   method to compute the coefficients c (1, 2 or 3),
%                       we recommend to use method 1 (default)
%                       because it is the most accurate and fast, as shown in [1].
%                       (1: best-approximation to V c = z via MATLAB
%                       function,
%                       2: $c = (\gamma I + V^\ast\ V)^{-1} (V^\ast\
%                       \texttt{uIncRX})$
%                           via linear Tikhonov regularization,
%                       3: Landweber iteration)
% * seti.nuMax      :   match incident field using Hankel functions of first kind and orders
%                       $\nu = -\texttt{nuMax}, ..., -1, 0, 1, ...,
%                       \texttt{nuMax}$ (default: 7)
%
% * uIncRX          :   incident field at receivers' positions for each
%                       transmitter
%                       (complex matrix of size seti.measNb x seti.incNb)
% * region          :   'ROI' or 'CD' (region of interest or computational domain)
%                       (usually we are interested in ROI)
%
%
%% Output Arguments
%
% * uIncROI   :       incident field on ROI (or CD) for each transmitter 
%                     (complex array of size seti.nROI^seti.dim x seti.incNb)
% * errC      :       stores the relative error of 
%                     the matched incident field at receivers positions for
%                     every transmitter
%                     (vector of size 1 x seti.incNb)
%
%
%% More About
%
% *How does it work?* 
%
% # Matching incident field in data |uIncRX| (receivers positions) 
%   with harmonic polynomials for each transmitter by finding corresponding
%   coefficients |c| solving (approximately) $V c = \texttt{uIncRX}$.
% # Computes the resulting incident fields on the grid uIncROI 
%   for each transmitter.
%
% More details of the method are in the subfunctions and in Section 6 of [1].
%
% *Please note*
%
% * The method is for 2 dimensional problems.
% * We assume point sources at transmitters positions.
% * We assume near field data.
% * c are coefficients. (They are kind of amplitudes, but this is not exact.)
% * Avoid same positions for receivers and transmitters. Some entries in
% matrix V will be not a number (NaN).
%
%
%% References
%
% * [1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. _Journal of Computational Physics_, 339:1-30, 2017.
%
%% Code: matchIncField
%
function [uIncROI,errC] = matchIncField(uIncRX,seti,region)
%%
% |[uIncROI,errC] = matchIncField(uIncRX,seti,region)|
% computes the incident field on grid of region ROI or CD (depends on
% |region|) from given incident field |uIncRX| at receivers postions.
% Relative error of given and matched indicent field |uIncRX| for each 
% transmitter are stored in |errC|.
%   
%   region =  'ROI' or 'CD'
%
nTX = seti.incNb; % nTX: number of transmitters
% nROI = nnz(seti.ROImask); % works for ROI, alternative for ROI and CD
switch region
    case 'ROI'
        nROI = seti.nROI^seti.dim;
    case 'CD'
        nROI = seti.nCD^seti.dim;
end
uIncROI = zeros(nROI,nTX);
errC = zeros(1,nTX);    % store relative error of V c = uIncRX, i.e. every matched incident field at receivers positions
errCAdj = zeros(1,nTX); % store relative error of (\gamma Id + V^\ast V) c = V^\ast uIncRX
% All transmitters are active in experiment (but only one at once)
for activeTX = 1:nTX
    % Matching for single incident field
    [u,errCval,errCAdjval] = matchIncFieldSingleTX(uIncRX,seti,activeTX,region);
    uIncROI(:,activeTX) = u(:);
    errC(1,activeTX) = errCval;
    errCAdj(1,activeTX) = errCAdjval;
end

disp('REPLACE_WITH_DASH_DASH')
disp('Check relative error of z = uIncRX because of choosen coefficients:')
fprintf('rel. err. of (gamma Id + V''V)c = V''z    : mean = %g\n',mean(errCAdj));
fprintf('             [min, max] = [%g, %g]\n', min(errCAdj), max(errCAdj));
fprintf('rel. err. of V c = z                    : mean = %g\n',mean(errC));
fprintf('             [min, max] = [%g, %g]\n', min(errC), max(errC));
disp('REPLACE_WITH_DASH_DASH')
end

%% Code: matchIncFieldSingle
function [uIncMatched,errC,errCAdj] = matchIncFieldSingleTX(uIncRX,seti,activeTX,region)

%%
% |[uIncMatched,errC,errCAdj] = matchIncFieldSingleTX(uIncRX,seti,activeTX,region)|
% matches the incident field |uIncRX| in data (receivers positions) with 
% harmonic polynomials and then computes the resulting field |uIncMatched| 
% on the grid for one transmitter.
%

% Active receivers depend on the active transmitter
% (not all receivers are active at once).
% Mark active receivers with 1 and inactive with 0: (logical):
activeRX = ~isnan(uIncRX(:,activeTX));
origin = seti.incPnts(:,activeTX); % position of transmitter with number activeTX
%
% seti.measPnts(1,activeRX) : first components of active measPnts
% (depends on choosen active transmitter: activeTX)
% x and y: coordinates away from origin (currently active transmitter)
% so in this coordinate system:
%
% * active transmitter position (0,0)
% * receiver positions (x,y)
%
x = transpose(seti.measPnts(1,activeRX) - origin(1)); % x coordinate
y = transpose(seti.measPnts(2,activeRX) - origin(2)); % y coordinate
z = uIncRX(activeRX,activeTX); % incident field at this receivers (because of active transmitter)
N = seti.nuMax; % degree of matching polynomial (e.g. N = 30)
phi0 = 0; % see function harmonicpolyfit

[c,errC,errCAdj] = harmonicpolyfit(x,y,z,N,seti.k,phi0,seti);

if 0 % store coefficients c (matchIncidentFieldSingleTX is called in for-loop)
    seti.ampCalcNew = 1; % Compute new coefficients (recommended).
                         % Could be stored, but not recommended...
                         % This works only in case of incNb == 1...
    % [pathstr,name,ext] = fileparts(file)
    [~,name,~] = fileparts(seti.fresnelFile);
    freqGHz = seti.fresnelFreq/1E9;
    % seti.ampCalc is not included in filename...
    % so compute the coefficients (and do not use the saved one...)
    fileDataAmp = sprintf('inmat/dataAmp/%s_%01d_GHz_N_%03d.mat',name,freqGHz,N);
    if (seti.ampCalcNew ~= 1 && exist(fileDataAmp, 'file') == 2)
        %file with name exists
        disp('Loading amplitudes of incident field of Fresnel data.');
        sloaded = load(fileDataAmp); % contains amplitudes c
        c = sloaded.c;
        clear sloaded;
    else
        disp('Compute coefficients c')
        [c,errC,errCAdj] = harmonicpolyfit(x,y,z,N,seti.k,phi0,seti);
        fprintf('Store in file: %s\n',fileDataAmp);
        save(fileDataAmp,'c');
    end
end

switch region
    case 'ROI'
        x = transpose(seti.gridROI(1,:) - origin(1));
        y = transpose(seti.gridROI(2,:) - origin(2));
    case 'CD'
        x = transpose(seti.grid(1,:) - origin(1));
        y = transpose(seti.grid(2,:) - origin(2));
end
uIncMatched = harmonicpolyval(c,x,y,seti.k,phi0); % matched field on grid
end

%% Code: Auxiliary Functions

%%
% *harmonicpolyfit*
%
function [c,errC,errCAdj] = harmonicpolyfit(x,y,uIncRX,N,k,phi0,seti)

%%
% |[c,errC,errCAdj] = harmonicpolyfit(x,y,uIncRX,N,k,phi0,seti)| finds the 
% coefficients of a 2D harmonic polynomial of (harmonic) degree |N| 
% that fits the data |uIncRX| at the best in a least-squares sense
% (in case of |seti.ampCalc = 1| REPLACE_WITH_DASH_DASH other methods are available).
% The |c| is a row vector of length 2*N+1 containing the polynomial
% coefficients.
%
% Solution of Helmholtz equation in $\bf{R}^2$ without 0 is
%
% $$\texttt{hmonomial} = 
%     \frac{\mathrm{i}}{4} H_\nu^{(1)} (k r) \exp(\mathrm{i} \nu \varphi), 
%     \quad r > 0, \quad \varphi \in [0,2\pi),$$
%
% where r and phi are the polar coordinates of (x,y) and 
% $H_\nu^{(1)}$ the Hankel function of the first kind and 
% order $\nu \in \bf{Z}$.
%
% Any linear combination of these products are solutions too.
% This linear combination is expressed by matrix V multiplied by 
% vector c, which contains the coefficients.
%
% $$V c = \texttt{uIncRX}$$
%
% See Also HARMONICPOLYVAL.

[phi, r] = cart2pol(x(:),y(:));
V = zeros(length(r),2*N+1);
hmonomial = @(phi,r,n,k) (1i/4)*besselh(n, k*r).*exp(1i*n*(phi+phi0)); % phi+phi0

for n = -N:N
    V(:,n+N+1) = hmonomial(phi,r,n,k);
end

% seti.ampCalc: options 1: c = V\z | 2: using adjoint | 3: landweber
% seti.ampCalc = 1 is recommended
gamma = 1E-4; % used in case 2 and calculation of relative error
seti = checkfield(seti,'ampCalc',1);
switch seti.ampCalc
    case 1
        c = V\uIncRX(:); % 
    case 2
        c = (gamma*eye(size(V'*V)) + V'*V)\(V'*uIncRX(:));
    case 3
        lwN = 2000; % number of landweber iterations
        %lwN = 1E5;
        %lwN = 1E8; %test; very time-consuming
        c = landweber(V,uIncRX,lwN); % find c such that V c \approx z
end

%figure(101);
%plot(real(V*c)); title('V*c approx z = uIncRX, real');

%figure(102);
%plot(imag(V*c)); title('V*c approx z = uIncRX, imag');

% z is incident field uIncRX at receivers positions of the active(!) receivers
errCAdj = norm((gamma*eye(size(V'*V)) + V'*V)*c-V'*uIncRX(:))/norm(V'*uIncRX(:));
errC = norm(V*c-uIncRX(:))/norm(uIncRX(:));

if 0
    disp('Coefficients c = V\z correct? Is V*c-z = 0?')
    % (\varepsilon Id + V^\ast V) c = V^\ast z, so V c = z
    fprintf('rel. err. of (gamma Id + V''V)c = V''z: %g\n',errCAdj);
    fprintf('rel. err. of V c = z: %g\n',errC);
end
%figure(103); plot(real(c));

%figure(104);
%plot(real(c))

%figure(105);
%plot(imag(c))

end

%%
% *harmonicpolyval*
%
function uIncROI = harmonicpolyval(c,x,y,k,phi0)

%%
% |uIncROI = harmonicpolyval(c,x,y,k,phi0)| returns the value of the 2D harmonic 
% polynomial evaluated at points (x,y).
% The c is a vector of length $2\ \xi+1$ ($\xi = \texttt{nuMax}$) 
% whose elements are the coefficients 
% of the polynomial in ascending (!!!) powers.
%
% $$\texttt{uIncROI} = \sum_{\nu = -\xi}^{+\xi}
% c_\nu\ \texttt{hmonomial}(\varphi,r)$$
%
% where $\varphi$ and $r$ are the polar coordinates of (x,y).
%
% See also HARMONICPOLYFIT.
%

[phi, r] = cart2pol(x(:),y(:));
uIncROI = zeros(size(x(:)));
L = length(c);
N = floor( (L-1)/2 );
hmonomial = @(phi,r,n,k) (1i/4)*besselh(n, k*r).*exp(1i*n*(phi+phi0)); % phi+phi_0
for n = -N:(-N+L-1)
    uIncROI = uIncROI + c(n+N+1) * hmonomial(phi,r,n,k);
end;
uIncROI = reshape(uIncROI,size(x));
end

%%
% *landweber*
%
function res = landweber(V,uIncRX,lwN)

%%
% Try to improve fitting of coefficients c by Landweber sheme.
%
% Landweber sheme in general is used to minimize
%
% $\min_x \|Vx-y\|_2^2/2 \quad $ by $\quad x_{k+1} = x_{k} - \omega V^*(V x_k - y)$.
%
% Here we us it with 
%
% * y = uIncRX
% * $x_k = c$ (seeked coefficients c)
%
% Further input:
%
% * lwN   : number of iterations
%
m = size(V,2); % 2*N+1
n = size(uIncRX,2);
xk = zeros(m,n); % zeros(size(c)); % start with c = 0
% $0 < \omega < 2/\sigma_1^2$
s = svd(V);
size(V);
s1 = max(s);
omegaMax = 2/s1^2;
omega = 0.99*omegaMax;
A = V;
AT = transpose(conj(A));
y = uIncRX(:);
for i = 1:lwN
    xkp1 = xk-omega*AT*(A*xk-y);
    xk = xkp1;
    if floor(i/1000) == i/1000
        fprintf('dis = %g\n', norm(A*xk-y));
    end
end
res = xk;
% res is a c (or better c than input)
end

##### SOURCE END #####
--></body></html>