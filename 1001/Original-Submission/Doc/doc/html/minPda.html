
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>minPda</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-30"><meta name="DC.source" content="minPda.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>minPda</h1><!--introduction--><p>This function is called in recon.m and minimizes the non-linear problem by linearizing it and solving the linearized problem by minimization with primal-dual algorithm in pda.m.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Input Arguments</a></li><li><a href="#4">Output Arguments</a></li><li><a href="#5">More About</a></li><li><a href="#6">References</a></li><li><a href="#7">See Also</a></li><li><a href="#8">Code</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">[seti,FFqMeas,pdas] = minPda(seti,iOut,qROIcomp,pdas,FFqMeas,dispDepth)
</pre><h2 id="2">Description</h2><p><tt>[seti,FFqMeas,pdas] = minPda(seti,iOut,qROIcomp,pdas,FFqMeas,dispDepth)</tt> computes the outer iteration step <tt>iOut</tt> to improve the reconstruction of the contrast <tt>qROIcomp</tt>, that results in measurement data <tt>FFqMeas</tt>, from given data <tt>seti.FmeasDelta</tt>. With <tt>dispDepth</tt> the frequency of displayed text messages is controlled.</p><p>The reconstruction is done by linearizing the non-linear problem and solve the linearized one by minimization with primal-dual algorithm.</p><p>The resulting contrast is saved in <tt>seti.qROIcomp</tt> and the corresponding measurement data in <tt>FFqMeas</tt>.</p><div><ul><li>If <tt>seti.useTolIn = 1</tt> the inner tolerance principle is used to stop the inner iterations (primal-dual algorithm).</li><li>If <tt>seti.useTolOut = 1</tt> the outer tolerance principle is used to stop the inner iterations.</li><li>The primal-dual algorithm stops at the latest afer <tt>seti.pdaN</tt> iteration steps.</li></ul></div><h2 id="3">Input Arguments</h2><p>Specific input arguments for primal-dual algorithm are described in <a href="pda.html">pda.html</a>.</p><div><ul><li>seti            :   structure array</li><li>seti.pdaNmax    :   maximal iteration number of inner iteration,                       if useTolIn or useTolOut (default : 250)</li></ul></div><div><ul><li>iOut        :   iteration index of outer iteration</li><li>qROIcomp    :   reconstruction of the contrast                   (complex vector of size seti.nROI^seti.dim x 1)</li><li>pdas        :   structure array for pda specific outputs,                   see below and also <a href="recon.html">recon.html</a>.</li><li><tt>FFqMeas</tt>  :    scattered field evaluated on receivers positions                   (complex matrix of size seti.measNb x seti.incNb)</li></ul></div><div><ul><li><tt>dispDepth</tt> : depth of displayed test messages (greater or equal 2 to get messages).</li></ul></div><p><b>structure array pdas</b></p><div><ul><li>pdas.pdaStopInd     :   stop index of inner iteration (i.e. primal-dual algorithm)</li><li>pdas.MTvN           :   result of minimized Tikhonov functional</li><li>pdas.M1vN           :   result of first part of min. functional</li><li>pdas.M2vN           :   result of second part of min. functional</li><li>See also <a href="recon.html">recon.html</a>.</li></ul></div><div><ul><li>pdas.relLinDisInPda :   quotient: relLinDis = disLin / dis (vector of size seti.pdaN x 1)</li><li>pdas.disLinInPda    :   discrepancy of linearized problem for each inner iteration step (vector of size seti.pdaN x 1)</li><li>pdas.errInPda       :   relative error of the reconstructed contrast qROI (vector of size seti.pdaN x 1)</li><li>pdas.minf = minf    :   struct with parts of the minimization functional (Tikhonov functional)</li><li>See also <a href="pda.html">pda.html</a>.</li></ul></div><div><ul><li>pdas.disLin :   last relative discrepancy of linearized problem in inner iteration of pda                   for each outer iteration                   (vector of size 1 x seti.nOut)</li><li>pdas.relDis :   quotient disLin/dis                   for each outer iteration                   (rel. discrepancy of linearized problem / rel. discrepancy of the non-linearized problem)                   (vector of size 1 x seti.nOut)</li><li>pdas.pdaNv  :   number of inner iterations for each outer iteration                   (vector of size 1 x seti.nOut)</li><li>pdas.ThetaiOutV     :   inner tolerance for each outer iteration                           (in case of inner tolerance principle, see                           <a href="minTolIn.html">minTolIn.html</a>.)</li></ul></div><h2 id="4">Output Arguments</h2><div><ul><li>seti    :   structure array</li><li>seti.qROIcomp   :   new computed reconstruction of the contrast                       (complex vector of size seti.nROI^seti.dim x 1)</li><li>FFqMeas :   scattered field of currently computed contrast evaluated on receivers positions               (complex matrix of size seti.measNb x seti.incNb)</li><li>pdas    :   structure array for pda specific output,               expanded for currently computed iteration step               (see "Input Arguments" for a reference).</li></ul></div><h2 id="5">More About</h2><div><ol><li>Inner iteration: pda minimizes the linearized Tikhonov functional, output h.</li><li>Update in outer iteration: <img src="minPda_eq18145746415082390862.png" alt="$q := q + h$">.</li><li>Compute scattered field of reconstructed contrast at receivers positions: <img src="minPda_eq08388952396145782734.png" alt="$\mathcal{F}(q)$">.</li></ol></div><p>See also <a href="start.html">start.html</a> and [1] Section 4.</p><h2 id="6">References</h2><div><ul><li>[1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. <i>Journal of Computational Physics</i>, 339:1-30, 2017.</li></ul></div><h2 id="7">See Also</h2><div><ul><li><a href="start.html">start.html</a></li><li><a href="pda.html">pda.html</a></li><li><a href="minTolIn.html">minTolIn.html</a></li><li><a href="minTolOut.html">minTolOut.html</a></li></ul></div><h2 id="8">Code</h2><pre class="codeinput"><span class="keyword">function</span> [seti,FFqMeas,pdas] = minPda(seti,iOut,qROIcomp,pdas,FFqMeas,dispDepth)
</pre><p><b>Parts of minimization function</b></p><p>seti.M1 = F(K(h)), seti.M2 = G(h)</p><pre class="codeinput"><span class="keyword">if</span> iOut == 1 <span class="comment">% to have a value...</span>
    seti.M1v(iOut) = 0;
    seti.M2v(iOut) = 0;
    seti.MTv(iOut) = 0;
<span class="keyword">end</span>
</pre><p><b>Tolerance principle in pda (in [1] "Stopping strategy 2")</b></p><pre class="codeinput"><span class="keyword">if</span> seti.useTolIn
    <span class="keyword">if</span> iOut == seti.iOutIni + 1
        ThetaiOut = seti.ThetaStart;
    <span class="keyword">else</span>
        ThetaiOut = pdas.ThetaiOutV(iOut-1);
    <span class="keyword">end</span>
    pdas.ThetaiOutV(iOut) = minTolIn(ThetaiOut,pdas.pdaNv,iOut,FFqMeas,seti,dispDepth);
    clear <span class="string">ThetaiOut</span>;
<span class="keyword">else</span>
    pdas.ThetaiOutV(iOut) = 0; <span class="comment">% to set a value...</span>
<span class="keyword">end</span>
</pre><p><b>Tolerance principle outside of pda (in [1] "Stopping strategy 1")</b></p><pre class="codeinput"><span class="keyword">if</span> seti.useTolOut
    <span class="keyword">if</span> iOut &gt; seti.iOutIni+1
        seti.pdaN = minTolOut(iOut,pdas.pdaNv,seti.dis,pdas.disLin,pdas.relDis,seti,dispDepth);
        <span class="comment">% choice of pdaN for next outer iteration</span>
    <span class="keyword">else</span>
        seti.pdaN = seti.pdaN;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p><b>Minimization of linearized Tikhonov functional by PDA</b></p><div><ul><li><tt>qROI</tt> is <tt>qCVU</tt>, i.e. complex vector upscaled</li><li>In pda we require <b>real</b> vector spaces.   Only the output h is complex.</li></ul></div><pre class="codeinput"><span class="keyword">if</span> dispDepth &gt;= 2
    disp(<span class="string">'    - Minimization of linearized Tikhonov functional by PDA (start)'</span>)
<span class="keyword">end</span>
[h,pdaStopInd,MTvN,M1vN,M2vN,relLinDisInPda,disLinInPda,errInPda,minf] = pda(iOut,qROIcomp,pdas.ThetaiOutV(iOut),seti,dispDepth); <span class="comment">%FCGC only to plot</span>
<span class="comment">% Remember in pda: DFFq = @(xnRVD) JA*diag(seti.GU(seti.T(xnRVD)))*JB;</span>
<span class="keyword">if</span> dispDepth &gt;= 2
    disp(<span class="string">'    - Minimization of linearized Tikhonov functional by PDA (end)'</span>)
<span class="keyword">end</span>
</pre><p><b>Store output of pda in struct pda (pda struct: pdas) (except h)</b></p><pre class="codeinput">pdas.pdaStopInd = pdaStopInd;
pdas.MTvN = MTvN;
pdas.M1vN = M1vN;
pdas.M2vN = M2vN;
pdas.relLinDisInPda = relLinDisInPda;
pdas.disLinInPda = disLinInPda;
pdas.errInPda = errInPda;
pdas.minf = minf;

clear <span class="string">pdaStopInd</span> <span class="string">MTvN</span> <span class="string">M1vN</span> <span class="string">M2vN</span> <span class="string">relLinDisInPda</span> <span class="string">disLinInPda</span> <span class="string">errInPda</span> <span class="string">minf</span>;
</pre><p><b>Store further values in struct pdas and seti</b></p><pre class="codeinput"><span class="comment">% COMMENTED OUT: sigmaVal...</span>
<span class="comment">%</span>
<span class="comment">%size(sigmaVal) e.g. 25 x 1</span>
<span class="comment">%pdaStopInd = length(sigmaVal)</span>
<span class="comment">% can happen that sigmaVal is too small for sigmaMat</span>
<span class="comment">% fill the rest with zeros.</span>
<span class="comment">% does not work in case of useTolOut because pdaN changes...:</span>
<span class="comment">% if pdaStopInd &lt; seti.pdaN</span>
<span class="comment">%    sigmaVal(seti.pdaN) = 0; % last is set 0, so the rest is filled with zero</span>
<span class="comment">%    tauVal(seti.pdaN) = 0;</span>
<span class="comment">%end</span>

pdas.disLin(iOut) = pdas.disLinInPda(pdas.pdaStopInd); <span class="comment">% lin. discrepancy</span>

<span class="comment">%pdaNv(iOut) = seti.pdaN; % does not respect inner tolerance principle</span>
pdas.pdaNv(iOut) = pdas.pdaStopInd;
pdas.pdaStopInd = pdas.pdaStopInd;

<span class="comment">%...N: vector of length N (from internal iteration)</span>
seti.MTv(iOut) = pdas.MTvN(pdas.pdaStopInd);
seti.M1v(iOut) = pdas.M1vN(pdas.pdaStopInd);
seti.M2v(iOut) = pdas.M2vN(pdas.pdaStopInd);
<span class="keyword">if</span> dispDepth &gt;= 3
    fprintf(<span class="string">'   MTv = %g, M1v = %g, M2v = %g\n'</span>,seti.MTv(iOut),seti.M1v(iOut),seti.M2v(iOut));
<span class="keyword">end</span>
</pre><p><b>Update in outer iteration</b></p><pre class="codeinput"><span class="keyword">if</span> dispDepth &gt;= 2
    disp(<span class="string">'    - Update in outer iteration'</span>)
<span class="keyword">end</span>
seti.qROIcomp = qROIcomp + h; <span class="comment">% complex vector upscaled</span>
</pre><p><b>Compute scattered field of reconstructed contrast at receivers positions</b></p><pre class="codeinput"><span class="keyword">if</span> dispDepth &gt;= 2
    disp(<span class="string">'    - Compute FF(q) for discrepancy and next step'</span>)
<span class="keyword">end</span>
FFqMeas = mimo(seti, seti.qROIcomp, <span class="string">'simo'</span>); <span class="comment">% needs upscaled qROI</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% minPda
%
% This function is called in recon.m and minimizes the non-linear problem
% by linearizing it and solving the linearized problem by minimization with
% primal-dual algorithm in pda.m.
%
%% Syntax
%
%   [seti,FFqMeas,pdas] = minPda(seti,iOut,qROIcomp,pdas,FFqMeas,dispDepth)
%
%% Description
%
% |[seti,FFqMeas,pdas] = minPda(seti,iOut,qROIcomp,pdas,FFqMeas,dispDepth)|
% computes the outer iteration step |iOut| 
% to improve the reconstruction of the contrast |qROIcomp|, 
% that results in measurement data |FFqMeas|,
% from given data |seti.FmeasDelta|.
% With |dispDepth| the frequency of displayed text messages is controlled.
% 
% The reconstruction is done by linearizing the non-linear problem and
% solve the linearized one by minimization with primal-dual algorithm.
%
% The resulting contrast is saved in |seti.qROIcomp| and the corresponding
% measurement data in |FFqMeas|.
% 
% * If |seti.useTolIn = 1| the inner tolerance principle is used to stop the
% inner iterations (primal-dual algorithm).
% * If |seti.useTolOut = 1| the outer tolerance principle is used to stop the
% inner iterations.
% * The primal-dual algorithm stops at the latest afer |seti.pdaN|
% iteration steps.
%
%
%% Input Arguments
%
% Specific input arguments for primal-dual algorithm are described in
% <pda.html>.
%
% * seti            :   structure array
% * seti.pdaNmax    :   maximal iteration number of inner iteration,
%                       if useTolIn or useTolOut (default : 250)
%
% * iOut        :   iteration index of outer iteration
% * qROIcomp    :   reconstruction of the contrast
%                   (complex vector of size seti.nROI^seti.dim x 1)
% * pdas        :   structure array for pda specific outputs, 
%                   see below and also <recon.html>.
% * |FFqMeas|  :    scattered field evaluated on receivers positions
%                   (complex matrix of size seti.measNb x seti.incNb)
%
% * |dispDepth| : depth of displayed test messages (greater or equal 2 to
% get messages).
%
% *structure array pdas*
%
% * pdas.pdaStopInd     :   stop index of inner iteration (i.e. primal-dual algorithm)
% * pdas.MTvN           :   result of minimized Tikhonov functional 
% * pdas.M1vN           :   result of first part of min. functional
% * pdas.M2vN           :   result of second part of min. functional
% * See also <recon.html>.
%
% * pdas.relLinDisInPda :   quotient: relLinDis = disLin / dis (vector of size seti.pdaN x 1)
% * pdas.disLinInPda    :   discrepancy of linearized problem for each inner iteration step (vector of size seti.pdaN x 1)
% * pdas.errInPda       :   relative error of the reconstructed contrast qROI (vector of size seti.pdaN x 1)
% * pdas.minf = minf    :   struct with parts of the minimization functional (Tikhonov functional)
% * See also <pda.html>.
%
% * pdas.disLin :   last relative discrepancy of linearized problem in inner iteration of pda
%                   for each outer iteration 
%                   (vector of size 1 x seti.nOut)
% * pdas.relDis :   quotient disLin/dis 
%                   for each outer iteration
%                   (rel. discrepancy of linearized problem / rel. discrepancy of the non-linearized problem)
%                   (vector of size 1 x seti.nOut)
% * pdas.pdaNv  :   number of inner iterations for each outer iteration
%                   (vector of size 1 x seti.nOut)
% * pdas.ThetaiOutV     :   inner tolerance for each outer iteration
%                           (in case of inner tolerance principle, see
%                           <minTolIn.html>.)
%
%
%% Output Arguments
%
% * seti    :   structure array
% * seti.qROIcomp   :   new computed reconstruction of the contrast
%                       (complex vector of size seti.nROI^seti.dim x 1)
% * FFqMeas :   scattered field of currently computed contrast evaluated on receivers positions
%               (complex matrix of size seti.measNb x seti.incNb)
% * pdas    :   structure array for pda specific output, 
%               expanded for currently computed iteration step 
%               (see "Input Arguments" for a reference).
%
%% More About
%
% # Inner iteration: pda minimizes the linearized Tikhonov functional, output h.
% # Update in outer iteration: $q := q + h$.
% # Compute scattered field of reconstructed contrast at receivers
% positions: $\mathcal{F}(q)$.
%
% See also <start.html> and [1] Section 4.
%
%% References
% * [1] Florian B&uuml;rgel, Kamil S. Kazimierski, and Armin Lechleiter. A sparsity regularization and total variation based computational framework for the inverse medium problem in scattering. _Journal of Computational Physics_, 339:1-30, 2017.
%
%% See Also
% * <start.html>
% * <pda.html>
% * <minTolIn.html>
% * <minTolOut.html>
%
%% Code
%
function [seti,FFqMeas,pdas] = minPda(seti,iOut,qROIcomp,pdas,FFqMeas,dispDepth)
%%
% *Parts of minimization function*
%
% seti.M1 = F(K(h)), seti.M2 = G(h)

if iOut == 1 % to have a value...
    seti.M1v(iOut) = 0;
    seti.M2v(iOut) = 0;
    seti.MTv(iOut) = 0;
end

%%
% *Tolerance principle in pda (in [1] "Stopping strategy 2")*
%
if seti.useTolIn
    if iOut == seti.iOutIni + 1
        ThetaiOut = seti.ThetaStart;
    else
        ThetaiOut = pdas.ThetaiOutV(iOut-1);
    end
    pdas.ThetaiOutV(iOut) = minTolIn(ThetaiOut,pdas.pdaNv,iOut,FFqMeas,seti,dispDepth);
    clear ThetaiOut;
else
    pdas.ThetaiOutV(iOut) = 0; % to set a value...
end

%%
% *Tolerance principle outside of pda (in [1] "Stopping strategy 1")*
%
if seti.useTolOut
    if iOut > seti.iOutIni+1
        seti.pdaN = minTolOut(iOut,pdas.pdaNv,seti.dis,pdas.disLin,pdas.relDis,seti,dispDepth);
        % choice of pdaN for next outer iteration
    else
        seti.pdaN = seti.pdaN;
    end
end

%%
% *Minimization of linearized Tikhonov functional by PDA*
%
% * |qROI| is |qCVU|, i.e. complex vector upscaled
% * In pda we require *real* vector spaces. 
%   Only the output h is complex.
%
if dispDepth >= 2
    disp('    - Minimization of linearized Tikhonov functional by PDA (start)')
end
[h,pdaStopInd,MTvN,M1vN,M2vN,relLinDisInPda,disLinInPda,errInPda,minf] = pda(iOut,qROIcomp,pdas.ThetaiOutV(iOut),seti,dispDepth); %FCGC only to plot
% Remember in pda: DFFq = @(xnRVD) JA*diag(seti.GU(seti.T(xnRVD)))*JB;
if dispDepth >= 2
    disp('    - Minimization of linearized Tikhonov functional by PDA (end)')
end

%%
% *Store output of pda in struct pda (pda struct: pdas) (except h)*
%
pdas.pdaStopInd = pdaStopInd;
pdas.MTvN = MTvN;
pdas.M1vN = M1vN;
pdas.M2vN = M2vN;
pdas.relLinDisInPda = relLinDisInPda;
pdas.disLinInPda = disLinInPda;
pdas.errInPda = errInPda;
pdas.minf = minf;

clear pdaStopInd MTvN M1vN M2vN relLinDisInPda disLinInPda errInPda minf;

%%
% *Store further values in struct pdas and seti*
%

% COMMENTED OUT: sigmaVal...
%
%size(sigmaVal) e.g. 25 x 1
%pdaStopInd = length(sigmaVal)
% can happen that sigmaVal is too small for sigmaMat
% fill the rest with zeros.
% does not work in case of useTolOut because pdaN changes...:
% if pdaStopInd < seti.pdaN
%    sigmaVal(seti.pdaN) = 0; % last is set 0, so the rest is filled with zero
%    tauVal(seti.pdaN) = 0;
%end

pdas.disLin(iOut) = pdas.disLinInPda(pdas.pdaStopInd); % lin. discrepancy

%pdaNv(iOut) = seti.pdaN; % does not respect inner tolerance principle
pdas.pdaNv(iOut) = pdas.pdaStopInd;
pdas.pdaStopInd = pdas.pdaStopInd;

%...N: vector of length N (from internal iteration)
seti.MTv(iOut) = pdas.MTvN(pdas.pdaStopInd);
seti.M1v(iOut) = pdas.M1vN(pdas.pdaStopInd);
seti.M2v(iOut) = pdas.M2vN(pdas.pdaStopInd);
if dispDepth >= 3
    fprintf('   MTv = %g, M1v = %g, M2v = %g\n',seti.MTv(iOut),seti.M1v(iOut),seti.M2v(iOut));
end

%%
% *Update in outer iteration*
if dispDepth >= 2
    disp('    - Update in outer iteration')
end
seti.qROIcomp = qROIcomp + h; % complex vector upscaled

%%
% *Compute scattered field of reconstructed contrast at receivers positions*
if dispDepth >= 2
    disp('    - Compute FF(q) for discrepancy and next step')
end
FFqMeas = mimo(seti, seti.qROIcomp, 'simo'); % needs upscaled qROI

end

##### SOURCE END #####
--></body></html>