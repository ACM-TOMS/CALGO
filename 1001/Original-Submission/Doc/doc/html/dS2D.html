
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>dS2D</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-30"><meta name="DC.source" content="dS2D.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>dS2D</h1><!--introduction--><p>Approximation of the infinitesimal element of a closed contour with control points.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Examples</a></li><li><a href="#4">Input Arguments</a></li><li><a href="#5">Output Arguments</a></li><li><a href="#6">More About</a></li><li><a href="#7">See Also</a></li><li><a href="#8">Code</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">dSp = dS2D(p)
</pre><h2 id="2">Description</h2><p><tt>dSp = dS2D(p)</tt> computes approximation of the infinitesimal element of a closed contour with control points. p is a real matrix of size Nb x 2. dSp is a vector of size Nb x 1.</p><div><ul><li>If all elements of dSp are almost the same dSp is a value.</li><li>If input is only one point, it is set dSp = 1 (a closed contour does not make sense).</li></ul></div><p>Note that p is a <b>matrix of size Nb x 2 and not 2 x Nb</b>. This is why in pntsGeometry is used:</p><pre class="language-matlab">dS = dS2D(transpose(Pnts));
</pre><h2 id="3">Examples</h2><p><b>Example 1</b></p><p>Point coordinates: (0,0), (1,0), (1,1)</p><pre class="language-matlab">p = [0 0; 1 0; 1 1];
dS2D(p)
</pre><p>Result:</p><pre class="language-matlab">1.2071
1.0000
1.2071
</pre><p><b>Example 2</b></p><p>Point coordinates: (0,0), (1,0), (1,1), (0,1) (a square)</p><pre class="language-matlab">p = [0 0; 1 0; 1 1; 0 1];
dS2D(p)
</pre><p>Result:</p><pre class="language-matlab">1
</pre><p>Result is a value and not a vector because if all elements of dSp are almost the same size, it is reduced to a single number.</p><h2 id="4">Input Arguments</h2><div><ul><li>p     :   coordinates of points (real matrix of size Nb x 2)</li></ul></div><h2 id="5">Output Arguments</h2><div><ul><li>dSp   :   approximation of the infinitesimal element of a closed contour             with control points. dSp is a vector of size Nb x 1.             If all elements of dSp are almost the same dSp is a value.             If input is only one point, it is set dSp = 1 (a closed contour does not make sense).</li></ul></div><h2 id="6">More About</h2><p>Please note that <tt>dSp</tt> does not contain the distances between the points, because then it would depend on the orientation of the parametrization. To omit this problem we use an average value (similar to the central difference in comparison to the forward or backward difference). It is explained in the following.</p><p><b>First, but wrong idea</b></p><p>The first (but kind of wrong) idea to discretize a closed contour is to compute the distances between the points, e.g. <img src="dS2D_eq16961251792093626640.png" alt="$dS(p_n) = \|p_{n+1} - p_n\|_2$"> for points <img src="dS2D_eq10376913527554223324.png" alt="$p_n$">.</p><p>Then, the distances for the point coordinates <img src="dS2D_eq04015966397851764917.png" alt="$p_1 = (0,0)$">, <img src="dS2D_eq07970752274406737160.png" alt="$p_2 = (1,0)$"> and <img src="dS2D_eq02534775023879876029.png" alt="$p_3 = (1,1)$"> are 1, <img src="dS2D_eq02214789561449400433.png" alt="$\sqrt{2}$"> and 1.</p><p>The problem is that the infinitesimal element then depends on the orientation of the parametrization. We consider the parametrization <img src="dS2D_eq14272535362975091672.png" alt="$[p_1, p_2, p_3, (p_1)]$"> and the (equivalent) one <img src="dS2D_eq01656912973042379623.png" alt="$[p_3, p_2, p_1, (p_3)]$">. Then the length of the infinitesimal element of <img src="dS2D_eq03052410687656979467.png" alt="$p_2$"> changes: In the first case it is <img src="dS2D_eq10802191687368684907.png" alt="$dS(p_2) = \|p_3 - p_2\|_2 = \sqrt{2}$"> and in the second <img src="dS2D_eq11179561089729828379.png" alt="$dS(p_2) = \|p_1 - p_2\|_2 = 1$">.</p><p><b>Second, orientation independent idea</b></p><p>The second idea avoids the orientation's dependence using the forward and backward definition of the distances between the points, i.e. <img src="dS2D_eq16961251792093626640.png" alt="$dS(p_n) = \|p_{n+1} - p_n\|_2$"> and <img src="dS2D_eq04754707816025941029.png" alt="$dS(p_n) = \|p_n - p_{n-1}\|_2$"> and compute the average, i.e.</p><p><img src="dS2D_eq12281746725250828155.png" alt="$$ dS(p_n) = \frac{1}{2} \left( \|p_{n+1} - p_n\|_2 + \|p_n - p_{n-1}\|_2 \right).$$"></p><p>This results in the infinitesimal elements are <img src="dS2D_eq14974224158754676687.png" alt="$\quad$"> <img src="dS2D_eq06260705886708622995.png" alt="$1+(\sqrt(2)-1)/2 \approx 1.2071$">, <img src="dS2D_eq14974224158754676687.png" alt="$\quad$"> <img src="dS2D_eq18395870634560867587.png" alt="$1$"> <img src="dS2D_eq14974224158754676687.png" alt="$\quad$"> and <img src="dS2D_eq14974224158754676687.png" alt="$\quad$"> <img src="dS2D_eq06260705886708622995.png" alt="$1+(\sqrt(2)-1)/2 \approx 1.2071$">.</p><p>The definition is chosen such that the point <img src="dS2D_eq10376913527554223324.png" alt="$p_n$"> is in the center of the closed contour's element belonging to <img src="dS2D_eq02580825996110960719.png" alt="$dS(p_n)$">. This is kind of a 'staggered definition' between <img src="dS2D_eq13018011809014209649.png" alt="$dS$"> and <img src="dS2D_eq09941021013676836398.png" alt="$p$"> (similar to the central difference in comparison to the forward or backward difference).</p><h2 id="7">See Also</h2><div><ul><li><a href="pntsGeometry.html">pntsGeometry.html</a></li><li><a href="dS3D.html">dS3D.html</a></li></ul></div><h2 id="8">Code</h2><pre class="codeinput"><span class="keyword">function</span> dSp = dS2D(p)

<span class="keyword">if</span> numel(p) == 2 <span class="comment">% i.e. ONE coordinate (a distance does not make sense)</span>
    dSp = 1;
<span class="keyword">elseif</span> numel(p) &gt; 2
    pm1 = circshift(p, 1); <span class="comment">% p minus 1</span>
    pp1 = circshift(p,-1); <span class="comment">% p plus 1</span>
    n = @(x) sqrt(sum( x.^2 ,2));
    dSp  = (  n(p-pm1) + n(p-pp1)  )/2;
    <span class="comment">% if all elements of dSp almost the same size,</span>
    <span class="comment">% reduce dSp to a single number</span>
    <span class="keyword">if</span> var(dSp) &lt; 10E-5*mean(dSp)
        dSp = mean(dSp);
    <span class="keyword">end</span>
<span class="keyword">else</span>
    disp(<span class="string">'Error in function dSp: size of input array too small'</span>)
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% dS2D
% Approximation of the infinitesimal element of a closed contour with control points.
%
%% Syntax
%
%   dSp = dS2D(p)
%
%% Description
% |dSp = dS2D(p)| computes approximation of the infinitesimal element of a
% closed contour with control points.
% p is a real matrix of size Nb x 2. 
% dSp is a vector of size Nb x 1.
%
% * If all elements of dSp are almost the same dSp is a value.
% * If input is only one point, it is set dSp = 1 (a closed contour does
% not make sense).
%
% Note that p is a *matrix of size Nb x 2 and not 2 x Nb*.
% This is why in pntsGeometry is used:
%
%   dS = dS2D(transpose(Pnts));
%
%
%% Examples
%
% *Example 1*
%
% Point coordinates: (0,0), (1,0), (1,1)
%
%   p = [0 0; 1 0; 1 1];
%   dS2D(p)
%
% Result:
%
%   1.2071
%   1.0000
%   1.2071
%
% *Example 2*
%
% Point coordinates: (0,0), (1,0), (1,1), (0,1) (a square)
%
%   p = [0 0; 1 0; 1 1; 0 1];
%   dS2D(p)
%
% Result:
%
%   1
%
% Result is a value and not a vector because if all elements of dSp are 
% almost the same size, it is reduced to a single number.
%
%
%% Input Arguments
%
% * p     :   coordinates of points (real matrix of size Nb x 2)
%
%% Output Arguments
%
% * dSp   :   approximation of the infinitesimal element of a closed contour 
%             with control points. dSp is a vector of size Nb x 1. 
%             If all elements of dSp are almost the same dSp is a value.
%             If input is only one point, it is set dSp = 1 (a closed contour does
% not make sense).
%
%
%% More About
%
% Please note that |dSp| does not contain the distances between the points,
% because then it would depend on the orientation of the parametrization. 
% To omit this problem we use an average value (similar to the central 
% difference in comparison to the forward or backward difference). It is
% explained in the following.
% 
% *First, but wrong idea*
%
% The first (but kind of wrong) idea to discretize a closed contour is to 
% compute the distances between the points, e.g. 
% $dS(p_n) = \|p_{n+1} - p_n\|_2$ for points $p_n$.
%
% Then, the distances for the point coordinates $p_1 = (0,0)$, $p_2 = (1,0)$
% and $p_3 = (1,1)$ are 1, $\sqrt{2}$ and 1.
%
% The problem is that the infinitesimal element then depends on the
% orientation of the parametrization. We consider the parametrization 
% $[p_1, p_2, p_3, (p_1)]$ and the (equivalent) one $[p_3, p_2, p_1, (p_3)]$. 
% Then the length of the infinitesimal element of $p_2$ changes: 
% In the first case it is $dS(p_2) = \|p_3 - p_2\|_2 = \sqrt{2}$ and 
% in the second $dS(p_2) = \|p_1 - p_2\|_2 = 1$.
%
% *Second, orientation independent idea*
%
% The second idea avoids the orientation's dependence using the forward and
% backward definition of the distances between the points, i.e. 
% $dS(p_n) = \|p_{n+1} - p_n\|_2$ and $dS(p_n) = \|p_n - p_{n-1}\|_2$ 
% and compute the average, i.e.
%
% $$ dS(p_n) = \frac{1}{2} \left( \|p_{n+1} - p_n\|_2 + \|p_n - p_{n-1}\|_2 \right).$$
%
% This results in the infinitesimal elements are $\quad$
% $1+(\sqrt(2)-1)/2 \approx 1.2071$, $\quad$
% $1$ $\quad$ and $\quad$
% $1+(\sqrt(2)-1)/2 \approx 1.2071$.
% 
% The definition is chosen such that the point $p_n$ is in the center of the 
% closed contour's element belonging to $dS(p_n)$. 
% This is kind of a 'staggered definition' between $dS$ and $p$ 
% (similar to the central difference in comparison to the forward or backward difference).
%
%
%% See Also
% * <pntsGeometry.html>
% * <dS3D.html>
%
%% Code
%
function dSp = dS2D(p)

if numel(p) == 2 % i.e. ONE coordinate (a distance does not make sense)
    dSp = 1;
elseif numel(p) > 2
    pm1 = circshift(p, 1); % p minus 1
    pp1 = circshift(p,-1); % p plus 1
    n = @(x) sqrt(sum( x.^2 ,2));
    dSp  = (  n(p-pm1) + n(p-pp1)  )/2;
    % if all elements of dSp almost the same size,
    % reduce dSp to a single number
    if var(dSp) < 10E-5*mean(dSp)
        dSp = mean(dSp);
    end
else
    disp('Error in function dSp: size of input array too small')
end
end

##### SOURCE END #####
--></body></html>