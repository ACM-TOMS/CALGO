
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>gmresKelley</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-30"><meta name="DC.source" content="gmresKelley.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>gmresKelley</h1><!--introduction--><p>GMRES linear equation solver.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Example</a></li><li><a href="#4">Input Arguments</a></li><li><a href="#5">Output Arguments</a></li><li><a href="#6">License Information</a></li><li><a href="#7">Code</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">x = gmresKelley(x0, b, atv, params)
</pre><h2 id="2">Description</h2><p><tt>x = gmresKelley(x0, b, atv, params)</tt> computes the solution x of linear equation <tt>atv(x) = b</tt> with matrix-vector product routine <tt>atv</tt>, and right hand side <tt>b</tt>. The initial vector is x0. Further parameters are given in params.</p><p>Implementation following Saad-Schultz.</p><p>C. T. Kelley, July 10, 1994</p><p>This code comes with no guarantee or warranty of any kind.</p><p>Output Arguments "error" and "total_iters" can be added by changing the code in <tt>function [x, error, total_iters] = gmres(x0, b, atv, params)</tt>.</p><p>Requires the function <tt>givapp</tt>, that is given as subfunction.</p><h2 id="3">Example</h2><pre class="language-matlab">x0 = [1; 1];
A = [1 2; 3 4];
b = [4.5; 9.5];
atv = @(x) A*x;
tol = 1E-6;
x = gmresKelley(x0, b, atv , [tol ,100,1]);
</pre><p><i>Result:</i></p><pre class="language-matlab">x =
</pre><pre>  0.5000
  2.0000</pre><h2 id="4">Input Arguments</h2><div><ul><li>x0  :   initial iterate</li><li>b   :   right hand side</li><li>atv :   a matrix-vector product routine           atv must return Ax when x is input           the format for atv is           function ax = atv(x).           Note that for GMRES we incorporate any           preconditioning into the atv routine.</li><li>params : three dimensional vector to control iteration</li><li>params(1) = relative residual reduction factor,</li><li>params(2) = max number of iterations,</li><li>params(3) (Optional) = reorthogonalization method:                   1 -- Brown/Hindmarsh condition (default),                   2 -- Never reorthogonalize (not recommended),                   3 -- Always reorthogonalize (not cheap!).</li></ul></div><h2 id="5">Output Arguments</h2><div><ul><li>x   :   solution</li></ul></div><p><i>Additional outputs after code changing:</i></p><div><ul><li>error   :   vector of residual norms for the history of               the iteration.</li><li>total_iters : number of iterations.</li></ul></div><h2 id="6">License Information</h2><p>Note that the source code of this file was not written by the authors of the toolbox IPscatt. It contains the GMRES by Kelley that is faster than the standard GMRES.</p><p>This method is describe in Ch. 3.4 of the following book: C. Tim Kelley. Iterative Methods for Linear and Nonlinear Equations. Society for Industrial and Applied Mathematics, 1995.</p><p>The source code is available at: C. Tim Kelley. Iterative methods for linear and nonlinear equations. companion software, 2002. <a href="https://de.mathworks.com/matlabcentral/fileexchange/2198-iterative-methods-for-linear-and-nonlinear-equations/content/kelley/gmres.m">https://de.mathworks.com/matlabcentral/fileexchange/2198-iterative-methods-for-linear-and-nonlinear-equations/content/kelley/gmres.m</a> Accessed: March 2017.</p><p>The corresponding license is available at: <a href="https://de.mathworks.com/matlabcentral/fileexchange/view_license?file_info_id=2198">https://de.mathworks.com/matlabcentral/fileexchange/view_license?file_info_id=2198</a></p><p>In the following we will cite this license (Accessed: May 2017):</p><p><b>License</b></p><p>Copyright (c) 2016, C.T. Kelley All rights reserved.</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p><div><ul><li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li><li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution</li></ul></div><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p><h2 id="7">Code</h2><pre class="codeinput"><span class="keyword">function</span> x = gmresKelley(x0, b, atv, params)
</pre><pre class="codeinput"><span class="comment">%</span>
<span class="comment">% initialization</span>
<span class="comment">%</span>
n=length(b);
errtol=params(1);
kmax=params(2);
reorth=1;
<span class="keyword">if</span> length(params) == 3
    reorth=params(3);
<span class="keyword">end</span>
x=x0;
<span class="comment">%</span>
<span class="comment">%</span>
h=zeros(kmax);
v=zeros(n,kmax);
c=zeros(kmax+1,1);
s=zeros(kmax+1,1);
<span class="keyword">if</span> norm(x) ~=0
   r = b-feval(atv,x);
<span class="keyword">else</span>
   r = b;
<span class="keyword">end</span>
rho=norm(r);
g=rho*eye(kmax+1,1);
errtol=errtol*norm(b);
error=[];
<span class="comment">%</span>
<span class="comment">% test for termination on entry</span>
<span class="comment">%</span>
error=[error,rho];
total_iters=0;
<span class="keyword">if</span>(rho &lt; errtol)
    <span class="keyword">return</span>
<span class="keyword">end</span>
<span class="comment">%</span>
v(:,1)=r/rho;
beta=rho;
k=0;
<span class="comment">%</span>
<span class="comment">% GMRES iteration</span>
<span class="comment">%</span>
<span class="keyword">while</span>((rho &gt; errtol) &amp; (k &lt; kmax))
    k=k+1;
    v(:,k+1)=feval(atv,v(:,k));
    normav=sqrt(v(:,k+1)'*v(:,k+1)); <span class="comment">%originally norm(v(:,k+1));</span>
<span class="comment">%</span>
<span class="comment">% Modified Gram-Schmidt</span>
<span class="comment">%</span>
    <span class="keyword">for</span> j=1:k
        h(j,k)=v(:,j)'*v(:,k+1);
        v(:,k+1)=v(:,k+1)-h(j,k)*v(:,j);
    <span class="keyword">end</span>
    h(k+1,k)=sqrt(v(:,k+1)'*v(:,k+1)); <span class="comment">%originally norm(v(:,k+1));</span>
    normav2=h(k+1,k);
<span class="comment">%</span>
<span class="comment">% Reorthogonalize?</span>
<span class="comment">%</span>
<span class="keyword">if</span>  (reorth == 1 &amp; normav + .001*normav2 == normav) | reorth ==  3
    <span class="keyword">for</span> j=1:k
        hr=v(:,j)'*v(:,k+1);
        h(j,k)=h(j,k)+hr;
        v(:,k+1)=v(:,k+1)-hr*v(:,j);
    <span class="keyword">end</span>
    h(k+1,k)=norm(v(:,k+1));
<span class="keyword">end</span>
<span class="comment">%</span>
<span class="comment">%   watch out for happy breakdown</span>
<span class="comment">%</span>
    <span class="keyword">if</span>(h(k+1,k) ~= 0)
         v(:,k+1)=v(:,k+1)/h(k+1,k);
    <span class="keyword">end</span>
<span class="comment">%</span>
<span class="comment">%   Form and store the information for the new Givens rotation</span>
<span class="comment">%</span>
    <span class="keyword">if</span> k &gt; 1
        h(1:k,k)=givapp(c(1:k-1),s(1:k-1),h(1:k,k),k-1);
    <span class="keyword">end</span>
    nu=sqrt(h(k:k+1,k)'*h(k:k+1,k)); <span class="comment">%originally norm(h(k:k+1,k));</span>
    <span class="keyword">if</span> nu~=0
<span class="comment">%        c(k)=h(k,k)/nu;</span>
        c(k)=conj(h(k,k)/nu);
        s(k)=-h(k+1,k)/nu;
        h(k,k)=c(k)*h(k,k)-s(k)*h(k+1,k);
        h(k+1,k)=0;
        g(k:k+1)=givapp(c(k),s(k),g(k:k+1),1);
    <span class="keyword">end</span>
<span class="comment">%</span>
<span class="comment">% Update the residual norm</span>
<span class="comment">%</span>
    rho=abs(g(k+1));
    error=[error,rho];
<span class="keyword">end</span>
<span class="comment">%</span>
<span class="comment">% At this point either k &gt; kmax or rho &lt; errtol.</span>
<span class="comment">% It's time to compute x and leave.</span>
<span class="comment">%</span>
y=h(1:k,1:k)\g(1:k);
total_iters=k;
x = x0 + v(1:n,1:k)*y;

<span class="keyword">return</span>
</pre><p><b>Code: subfunction givapp</b></p><pre class="codeinput"><span class="keyword">function</span> vrot=givapp(c,s,vin,k)
<span class="comment">%  Apply a sequence of k Givens rotations, used within gmres codes</span>
<span class="comment">%</span>
<span class="comment">%  C. T. Kelley, July 10, 1994</span>
<span class="comment">%</span>
<span class="comment">% This code comes with no guarantee or warranty of any kind.</span>
<span class="comment">%</span>
<span class="comment">%  function vrot=givapp(c, s, vin, k)</span>
<span class="comment">%</span>
vrot=vin;
<span class="keyword">for</span> i=1:k
    w1=c(i)*vrot(i)-s(i)*vrot(i+1);
<span class="comment">%    w2=s(i)*vrot(i)+c(i)*vrot(i+1);</span>
    w2=s(i)*vrot(i)+conj(c(i))*vrot(i+1);
    vrot(i:i+1)=[w1,w2];
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% gmresKelley
% GMRES linear equation solver.
%
%% Syntax
%
%   x = gmresKelley(x0, b, atv, params)
%
%% Description
%
% |x = gmresKelley(x0, b, atv, params)| computes the solution x of linear
% equation |atv(x) = b| with matrix-vector product routine |atv|, and right
% hand side |b|. The initial vector is x0. Further parameters are given in
% params.
%
% Implementation following Saad-Schultz.
%
% C. T. Kelley, July 10, 1994
%
% This code comes with no guarantee or warranty of any kind.
%
% Output Arguments "error" and "total_iters" can be added by changing the 
% code in |function [x, error, total_iters] = gmres(x0, b, atv, params)|.
%
% Requires the function |givapp|, that is given as subfunction.
%
%% Example
%
%   x0 = [1; 1];
%   A = [1 2; 3 4];
%   b = [4.5; 9.5];
%   atv = @(x) A*x;
%   tol = 1E-6;
%   x = gmresKelley(x0, b, atv , [tol ,100,1]);
%
% _Result:_
%
%   x =
%
%    0.5000
%    2.0000
%
%
%% Input Arguments
%
% * x0  :   initial iterate
% * b   :   right hand side
% * atv :   a matrix-vector product routine
%           atv must return Ax when x is input
%           the format for atv is
%           function ax = atv(x).
%           Note that for GMRES we incorporate any 
%           preconditioning into the atv routine.
% * params : three dimensional vector to control iteration
% * params(1) = relative residual reduction factor, 
% * params(2) = max number of iterations, 
% * params(3) (Optional) = reorthogonalization method:
%                   1 REPLACE_WITH_DASH_DASH Brown/Hindmarsh condition (default), 
%                   2 REPLACE_WITH_DASH_DASH Never reorthogonalize (not recommended), 
%                   3 REPLACE_WITH_DASH_DASH Always reorthogonalize (not cheap!).
%
%% Output Arguments
%
% * x   :   solution
%
% _Additional outputs after code changing:_
%
% * error   :   vector of residual norms for the history of
%               the iteration.
% * total_iters : number of iterations.
%
%
%% License Information
%
% Note that the source code of this file was not written by the authors of
% the toolbox IPscatt. It contains the GMRES by Kelley that is faster than the standard GMRES.
%
% This method is describe in Ch. 3.4 of the following book:
% C. Tim Kelley. Iterative Methods for Linear and Nonlinear Equations. Society for Industrial and Applied Mathematics, 1995.
% 
% The source code is available at:
% C. Tim Kelley. Iterative methods for linear and nonlinear equations. companion software, 2002.
% <https://de.mathworks.com/matlabcentral/fileexchange/2198-iterative-methods-for-linear-and-nonlinear-equations/content/kelley/gmres.m>
% Accessed: March 2017.
% 
% The corresponding license is available at:
% <https://de.mathworks.com/matlabcentral/fileexchange/view_license?file_info_id=2198>
% 
% In the following we will cite this license (Accessed: May 2017):
% 
% *License*
% 
% Copyright (c) 2016, C.T. Kelley
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are
% met:
%
% * Redistributions of source code must retain the above copyright
% notice, this list of conditions and the following disclaimer.
% * Redistributions in binary form must reproduce the above copyright
% notice, this list of conditions and the following disclaimer in
% the documentation and/or other materials provided with the distribution
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%
%% Code
%
function x = gmresKelley(x0, b, atv, params)
%
% initialization
%
n=length(b);
errtol=params(1);
kmax=params(2);
reorth=1;
if length(params) == 3
    reorth=params(3);
end
x=x0;
%
%
h=zeros(kmax);
v=zeros(n,kmax);
c=zeros(kmax+1,1);
s=zeros(kmax+1,1);
if norm(x) ~=0
   r = b-feval(atv,x);
else
   r = b;
end
rho=norm(r);
g=rho*eye(kmax+1,1);
errtol=errtol*norm(b);
error=[];
%
% test for termination on entry
%
error=[error,rho];
total_iters=0;
if(rho < errtol) 
    return
end
%
v(:,1)=r/rho;
beta=rho;
k=0;
%
% GMRES iteration
%
while((rho > errtol) & (k < kmax))
    k=k+1;
    v(:,k+1)=feval(atv,v(:,k));
    normav=sqrt(v(:,k+1)'*v(:,k+1)); %originally norm(v(:,k+1));
%
% Modified Gram-Schmidt
%
    for j=1:k
        h(j,k)=v(:,j)'*v(:,k+1);
        v(:,k+1)=v(:,k+1)-h(j,k)*v(:,j);
    end
    h(k+1,k)=sqrt(v(:,k+1)'*v(:,k+1)); %originally norm(v(:,k+1));
    normav2=h(k+1,k);
%
% Reorthogonalize?
%
if  (reorth == 1 & normav + .001*normav2 == normav) | reorth ==  3
    for j=1:k
        hr=v(:,j)'*v(:,k+1);
        h(j,k)=h(j,k)+hr;
        v(:,k+1)=v(:,k+1)-hr*v(:,j);
    end
    h(k+1,k)=norm(v(:,k+1));
end
%
%   watch out for happy breakdown 
%
    if(h(k+1,k) ~= 0)
         v(:,k+1)=v(:,k+1)/h(k+1,k);
    end
%
%   Form and store the information for the new Givens rotation
%
    if k > 1
        h(1:k,k)=givapp(c(1:k-1),s(1:k-1),h(1:k,k),k-1);
    end
    nu=sqrt(h(k:k+1,k)'*h(k:k+1,k)); %originally norm(h(k:k+1,k));
    if nu~=0
%        c(k)=h(k,k)/nu;
        c(k)=conj(h(k,k)/nu);
        s(k)=-h(k+1,k)/nu;
        h(k,k)=c(k)*h(k,k)-s(k)*h(k+1,k);
        h(k+1,k)=0;
        g(k:k+1)=givapp(c(k),s(k),g(k:k+1),1);
    end
%
% Update the residual norm
%
    rho=abs(g(k+1));
    error=[error,rho];
end
%
% At this point either k > kmax or rho < errtol.
% It's time to compute x and leave.
%
y=h(1:k,1:k)\g(1:k);
total_iters=k;
x = x0 + v(1:n,1:k)*y;

return

%%
% *Code: subfunction givapp*
%
function vrot=givapp(c,s,vin,k)
%  Apply a sequence of k Givens rotations, used within gmres codes
% 
%  C. T. Kelley, July 10, 1994
%
% This code comes with no guarantee or warranty of any kind.
%
%  function vrot=givapp(c, s, vin, k)
%
vrot=vin;
for i=1:k
    w1=c(i)*vrot(i)-s(i)*vrot(i+1);
%    w2=s(i)*vrot(i)+c(i)*vrot(i+1);
    w2=s(i)*vrot(i)+conj(c(i))*vrot(i+1);
    vrot(i:i+1)=[w1,w2];
end
##### SOURCE END #####
--></body></html>